{
  "generated_date": "2025-10-18",
  "generated_timestamp": "2025-10-18T00:25:36.604650",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8779,
  "game_filename": "2025-10-18.js",
  "game_size_bytes": 23520,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Drone Math Adventure\n  // Game for ages 7-9. Renders inside #game-of-the-day-stage in a 720x480 canvas.\n  // Uses Web Audio API for sounds. Keyboard accessible. Clear win/loss conditions.\n\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const TARGET_CORRECT = 10;\n  const MAX_LIVES = 3;\n  const PACKAGE_COUNT = 5;\n  const DRONE_RADIUS = 22;\n  const PACKAGE_SIZE = { w: 70, h: 40 };\n  const UI_PADDING = 10;\n  const MIN_BODY_FONT = 16;\n  const IMPORTANT_FONT = 22;\n\n  // Get container\n  const container = document.getElementById(\"game-of-the-day-stage\");\n  if (!container) {\n    console.error(\"Container element #game-of-the-day-stage not found.\");\n    return;\n  }\n\n  // Create canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.tabIndex = 0; // allow keyboard focus\n  canvas.style.outline = \"none\";\n  container.innerHTML = \"\";\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    console.error(\"Canvas 2D context unavailable.\");\n    return;\n  }\n\n  // Audio setup with error handling\n  let audioCtx = null;\n  let masterGain = null;\n  let bgGain = null;\n  let bgOsc = null;\n  let audioAllowed = true; // will be false if audio context creation fails\n  let audioMuted = false;\n\n  try {\n    const AC = window.AudioContext || window.webkitAudioContext;\n    if (!AC) throw new Error(\"Web Audio API not supported\");\n    audioCtx = new AC();\n    masterGain = audioCtx.createGain();\n    masterGain.gain.value = 0.9;\n    masterGain.connect(audioCtx.destination);\n\n    // Gentle background hum\n    bgGain = audioCtx.createGain();\n    bgGain.gain.value = 0.06;\n    bgGain.connect(masterGain);\n    bgOsc = audioCtx.createOscillator();\n    bgOsc.type = \"sine\";\n    bgOsc.frequency.value = 180;\n    const bgFilter = audioCtx.createBiquadFilter();\n    bgFilter.type = \"lowpass\";\n    bgFilter.frequency.value = 700;\n    bgOsc.connect(bgFilter);\n    bgFilter.connect(bgGain);\n    try {\n      bgOsc.start();\n    } catch (e) {\n      // Some browsers require user gesture to start; allow starting later\n    }\n  } catch (err) {\n    console.warn(\"Audio unavailable:\", err);\n    audioAllowed = false;\n    audioMuted = true;\n  }\n\n  // Utility: ensure audio context resumed on first user gesture\n  function ensureAudioStarted() {\n    if (!audioCtx) return;\n    if (audioCtx.state === \"suspended\") {\n      audioCtx.resume().catch((e) => {\n        console.warn(\"Audio resume failed:\", e);\n      });\n    }\n    try {\n      if (bgOsc && bgOsc.start) {\n        // starting twice throws; only call if not started\n      }\n    } catch (e) {}\n  }\n\n  // Sound effects using oscillators\n  function playSuccessChime() {\n    if (!audioAllowed || audioMuted) return;\n    try {\n      const now = audioCtx.currentTime;\n      const g = audioCtx.createGain();\n      g.gain.value = 0.0001;\n      g.connect(masterGain);\n      const o = audioCtx.createOscillator();\n      o.type = \"triangle\";\n      o.frequency.value = 880;\n      const o2 = audioCtx.createOscillator();\n      o2.type = \"sine\";\n      o2.frequency.value = 660;\n      const f = audioCtx.createBiquadFilter();\n      f.type = \"lowpass\";\n      f.frequency.value = 1500;\n      o.connect(f);\n      o2.connect(f);\n      f.connect(g);\n      o.start(now);\n      o2.start(now);\n      // envelope\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(0.12, now + 0.05);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);\n      o.stop(now + 0.7);\n      o2.stop(now + 0.7);\n    } catch (e) {\n      console.warn(\"playSuccessChime failed:\", e);\n    }\n  }\n\n  function playWrongBuzzer() {\n    if (!audioAllowed || audioMuted) return;\n    try {\n      const now = audioCtx.currentTime;\n      const g = audioCtx.createGain();\n      g.gain.value = 0.0001;\n      g.connect(masterGain);\n      const o = audioCtx.createOscillator();\n      o.type = \"sawtooth\";\n      o.frequency.value = 220;\n      const f = audioCtx.createBiquadFilter();\n      f.type = \"lowpass\";\n      f.frequency.value = 900;\n      o.connect(f);\n      f.connect(g);\n      o.start(now);\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(0.08, now + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);\n      o.frequency.exponentialRampToValueAtTime(80, now + 0.4);\n      o.stop(now + 0.45);\n    } catch (e) {\n      console.warn(\"playWrongBuzzer failed:\", e);\n    }\n  }\n\n  // Accessible text area for screen readers? We cannot add extra DOM per instruction.\n  // Provide clear canvas instructions and keyboard controls on-screen.\n\n  // Game state\n  let state = \"playing\"; // 'playing', 'won', 'lost'\n  let score = 0;\n  let lives = MAX_LIVES;\n  let question = null; // { left, right, op, answer }\n  let packages = []; // array of package objects\n  let keys = {};\n  let mouse = { x: 0, y: 0 };\n  let drone = { x: WIDTH / 2, y: HEIGHT / 2, vx: 0, vy: 0, speed: 3.5 };\n  let lastTime = performance.now();\n\n  // Restart function\n  function resetGame() {\n    score = 0;\n    lives = MAX_LIVES;\n    state = \"playing\";\n    drone.x = WIDTH / 2;\n    drone.y = HEIGHT / 2;\n    generateQuestionAndPackages();\n    ensureAudioStarted();\n  }\n\n  // Generate a simple math question (addition/subtraction, answers 0-20)\n  function makeQuestion() {\n    const ops = [\"+\" , \"-\"];\n    const op = ops[Math.floor(Math.random() * ops.length)];\n    let a, b;\n    if (op === \"+\") {\n      a = Math.floor(Math.random() * 11); // 0..10\n      b = Math.floor(Math.random() * 11); // 0..10\n    } else {\n      // subtraction ensure non-negative\n      a = Math.floor(Math.random() * 11); // 0..10\n      b = Math.floor(Math.random() * (a + 1)); // 0..a\n    }\n    const answer = op === \"+\" ? a + b : a - b;\n    return { a, b, op, answer };\n  }\n\n  // Generate packages with one correct answer and others incorrect\n  function generateQuestionAndPackages() {\n    question = makeQuestion();\n    packages = [];\n    const correctValue = question.answer;\n    const incorrectSet = new Set();\n    // create 4 incorrect distinct values\n    while (incorrectSet.size < PACKAGE_COUNT - 1) {\n      let val = correctValue + (Math.floor(Math.random() * 11) - 5);\n      if (val < 0 || val === correctValue || val > 20) {\n        val = Math.floor(Math.random() * 21);\n      }\n      if (val !== correctValue) incorrectSet.add(val);\n    }\n    const values = [correctValue, ...Array.from(incorrectSet)];\n    // Shuffle values\n    for (let i = values.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [values[i], values[j]] = [values[j], values[i]];\n    }\n    // Place packages in non-overlapping positions, top 3/4 of screen\n    const margin = 40;\n    const rows = PACKAGE_COUNT;\n    for (let i = 0; i < PACKAGE_COUNT; i++) {\n      const x = margin + (i % PACKAGE_COUNT) * ((WIDTH - margin * 2) / PACKAGE_COUNT) + Math.random() * 30 - 15;\n      const y = 80 + Math.random() * (HEIGHT - 220);\n      const vx = (Math.random() - 0.5) * 0.8;\n      const vy = (Math.random() - 0.5) * 0.8;\n      packages.push({\n        id: i + \"_\" + Date.now(),\n        x,\n        y,\n        vx,\n        vy,\n        w: PACKAGE_SIZE.w,\n        h: PACKAGE_SIZE.h,\n        value: values[i],\n        collected: false,\n        wobble: Math.random() * Math.PI * 2,\n      });\n    }\n  }\n\n  // Initialize\n  generateQuestionAndPackages();\n\n  // Controls\n  window.addEventListener(\"keydown\", (e) => {\n    keys[e.key.toLowerCase()] = true;\n    // Start audio on any key as many browsers require gesture\n    ensureAudioStarted();\n\n    if (state !== \"playing\") {\n      if (e.key.toLowerCase() === \"r\") {\n        resetGame();\n      }\n    } else {\n      // M to mute\n      if (e.key.toLowerCase() === \"m\") {\n        audioMuted = !audioMuted;\n      }\n    }\n  });\n\n  window.addEventListener(\"keyup\", (e) => {\n    keys[e.key.toLowerCase()] = false;\n  });\n\n  canvas.addEventListener(\"mousemove\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);\n    mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);\n  });\n\n  canvas.addEventListener(\"click\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const cx = (e.clientX - rect.left) * (canvas.width / rect.width);\n    const cy = (e.clientY - rect.top) * (canvas.height / rect.height);\n    // If in end state, clicking restart button will restart game\n    if (state === \"won\" || state === \"lost\") {\n      const btn = getRestartButtonRect();\n      if (cx >= btn.x && cx <= btn.x + btn.w && cy >= btn.y && cy <= btn.y + btn.h) {\n        resetGame();\n        return;\n      }\n    }\n    // Clicking also toggles audio if clicked near audio toggle\n    const audioRect = getAudioTextRect();\n    if (cx >= audioRect.x && cx <= audioRect.x + audioRect.w && cy >= audioRect.y && cy <= audioRect.y + audioRect.h) {\n      audioMuted = !audioMuted;\n      ensureAudioStarted();\n    }\n  });\n\n  // Restart button layout\n  function getRestartButtonRect() {\n    const btnW = 260;\n    const btnH = 48;\n    return { x: WIDTH / 2 - btnW / 2, y: HEIGHT / 2 + 80, w: btnW, h: btnH };\n  }\n\n  // Audio text rect (top center)\n  function getAudioTextRect() {\n    ctx.font = `${MIN_BODY_FONT}px Arial`;\n    const txt = audioMuted ? \"Audio: Off (M)\" : \"Audio: On (M)\";\n    const m = ctx.measureText(txt);\n    const w = m.width + UI_PADDING * 2;\n    const h = MIN_BODY_FONT + UI_PADDING * 2;\n    const x = WIDTH / 2 - w / 2;\n    const y = UI_PADDING;\n    return { x, y, w, h, txt };\n  }\n\n  // Draw helper: draw text with background using measureText to compute size\n  function drawTextBox(text, font, x, y, align = \"left\", fillStyle = \"#000\", bgStyle = \"rgba(255,255,255,0.7)\", padding = UI_PADDING) {\n    ctx.save();\n    ctx.font = font;\n    let metrics = ctx.measureText(text);\n    let textWidth = metrics.width;\n    const textHeight = parseInt(font, 10) || MIN_BODY_FONT;\n    let boxW = textWidth + padding * 2;\n    let boxH = textHeight + padding * 2;\n\n    let drawX = x;\n    if (align === \"center\") drawX = x - boxW / 2;\n    if (align === \"right\") drawX = x - boxW;\n\n    ctx.fillStyle = bgStyle;\n    ctx.strokeStyle = \"rgba(0,0,0,0.08)\";\n    roundRect(ctx, drawX, y, boxW, boxH, 6, true, false);\n    ctx.fillStyle = fillStyle;\n    ctx.textBaseline = \"top\";\n    ctx.fillText(text, drawX + padding, y + padding);\n    ctx.restore();\n    return { x: drawX, y, w: boxW, h: boxH, textWidth, textHeight };\n  }\n\n  // Round rectangle utility\n  function roundRect(ctx, x, y, w, h, r, fill, stroke) {\n    if (typeof r === \"undefined\") r = 5;\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  // Collision detection: circle vs rect\n  function circleRectCollision(cx, cy, r, rx, ry, rw, rh) {\n    const closestX = Math.max(rx, Math.min(cx, rx + rw));\n    const closestY = Math.max(ry, Math.min(cy, ry + rh));\n    const dx = cx - closestX;\n    const dy = cy - closestY;\n    return dx * dx + dy * dy < r * r;\n  }\n\n  // Update loop\n  function update(dt) {\n    if (state !== \"playing\") return;\n    // Input handling: arrow keys or WASD\n    let moveX = 0;\n    let moveY = 0;\n    if (keys[\"arrowleft\"] || keys[\"a\"]) moveX = -1;\n    if (keys[\"arrowright\"] || keys[\"d\"]) moveX = 1;\n    if (keys[\"arrowup\"] || keys[\"w\"]) moveY = -1;\n    if (keys[\"arrowdown\"] || keys[\"s\"]) moveY = 1;\n\n    // Smooth movement\n    const sp = drone.speed;\n    drone.vx += (moveX * sp - drone.vx) * 0.25;\n    drone.vy += (moveY * sp - drone.vy) * 0.25;\n    drone.x += drone.vx;\n    drone.y += drone.vy;\n    // Keep inside bounds\n    drone.x = Math.max(DRONE_RADIUS + 2, Math.min(WIDTH - DRONE_RADIUS - 2, drone.x));\n    drone.y = Math.max(DRONE_RADIUS + 2, Math.min(HEIGHT - DRONE_RADIUS - 2, drone.y));\n\n    // Update packages positions\n    for (const p of packages) {\n      p.x += p.vx;\n      p.y += p.vy;\n      p.wobble += 0.02;\n      // bounce on edges\n      if (p.x < 10) p.vx = Math.abs(p.vx) + 0.2;\n      if (p.x + p.w > WIDTH - 10) p.vx = -Math.abs(p.vx) - 0.2;\n      if (p.y < 60) p.vy = Math.abs(p.vy) + 0.2;\n      if (p.y + p.h > HEIGHT - 80) p.vy = -Math.abs(p.vy) - 0.2;\n    }\n\n    // Collision with packages\n    for (const p of packages) {\n      if (p.collected) continue;\n      if (circleRectCollision(drone.x, drone.y, DRONE_RADIUS, p.x, p.y, p.w, p.h)) {\n        p.collected = true;\n        if (p.value === question.answer) {\n          // Correct\n          score += 1;\n          playSuccessChime();\n          if (score >= TARGET_CORRECT) {\n            state = \"won\";\n          } else {\n            // small celebration, then new question\n            setTimeout(() => {\n              generateQuestionAndPackages();\n            }, 400);\n          }\n        } else {\n          // Wrong\n          lives -= 1;\n          playWrongBuzzer();\n          if (lives <= 0) {\n            state = \"lost\";\n          } else {\n            // remove wrong package and continue\n            setTimeout(() => {\n              // keep same question but generate a new set of packages so player has fresh try\n              generateQuestionAndPackages();\n            }, 400);\n          }\n        }\n      }\n    }\n  }\n\n  // Draw loop\n  function draw() {\n    // clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    // calming sky gradient background\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, \"#eaf6ff\");\n    g.addColorStop(1, \"#f7fff9\");\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Wacky background elements: floating cloud-like circles and geometric shapes\n    drawWackyBackground();\n\n    // Draw packages\n    for (const p of packages) {\n      drawPackage(p);\n    }\n\n    // Draw drone\n    drawDrone(drone);\n\n    // Draw UI: Score (top-left), audio toggle (top-center), lives (top-right)\n    // Score box\n    ctx.font = `${IMPORTANT_FONT}px Arial`;\n    const scoreText = `Correct: ${score}/${TARGET_CORRECT}`;\n    const scoreBox = drawTextBox(scoreText, `${IMPORTANT_FONT}px Arial`, UI_PADDING, UI_PADDING, \"left\", \"#113\", \"rgba(255,255,255,0.85)\", UI_PADDING);\n\n    // Audio toggle (top center)\n    const audioRect = getAudioTextRect();\n    // Check overlap between scoreBox and audioRect; if overlap, move audio down\n    const maybeAudioY = audioRect.y;\n    let audioY = maybeAudioY;\n    if (scoreBox.x + scoreBox.w + 10 > audioRect.x && scoreBox.y + scoreBox.h > audioRect.y) {\n      audioY = maybeAudioY + scoreBox.h + 12;\n    }\n    const audioText = audioMuted ? \"Audio: Off (M)\" : audioAllowed ? \"Audio: On (M)\" : \"Audio: Unavailable\";\n    drawTextBox(audioText, `${MIN_BODY_FONT}px Arial`, WIDTH / 2, audioY, \"center\", \"#114\", \"rgba(255,255,255,0.85)\", UI_PADDING);\n\n    // Lives (top-right)\n    ctx.font = `${IMPORTANT_FONT}px Arial`;\n    const livesText = `Lives: ${\"\u2764\".repeat(lives)}${\"\u2661\".repeat(MAX_LIVES - lives)}`;\n    const livesMetrics = ctx.measureText(livesText);\n    const livesW = livesMetrics.width + UI_PADDING * 2;\n    const livesX = WIDTH - livesW - UI_PADDING;\n    drawTextBox(livesText, `${IMPORTANT_FONT}px Arial`, livesX + livesW, UI_PADDING, \"right\", \"#711\", \"rgba(255,255,255,0.85)\", UI_PADDING);\n\n    // Draw current question near top center (below audio if audio moved down)\n    ctx.font = `${IMPORTANT_FONT + 4}px Arial`;\n    const qText = `Solve: ${question.a} ${question.op} ${question.b} = ?`;\n    // place it below audio area, ensure spacing\n    let qY = audioY + MIN_BODY_FONT + UI_PADDING * 2 + 6;\n    // Check for overlapping with score or lives; if overlapping push lower\n    const qMetrics = ctx.measureText(qText);\n    const qBoxH = IMPORTANT_FONT + 4 + UI_PADDING * 2;\n    // ensure at least 10px gap from top UI elements\n    qY = Math.max(qY, scoreBox.y + scoreBox.h + 12);\n    const qBox = drawTextBox(qText, `${IMPORTANT_FONT + 4}px Arial`, WIDTH / 2, qY, \"center\", \"#004\", \"rgba(255,255,255,0.92)\", UI_PADDING);\n\n    // Draw instructions bottom-center (multi-line)\n    const instructions = [\n      \"Controls: Arrow keys or WASD to fly the drone.\",\n      \"Goal: Collect the package with the correct answer 10 times.\",\n      \"Wrong package = lose a life. 3 wrong answers \u2192 Game Over.\",\n      \"Press M to toggle audio. Press R or click Restart to play again.\",\n    ];\n    drawMultilineBox(instructions, `${MIN_BODY_FONT}px Arial`, WIDTH / 2, HEIGHT - 110, \"center\");\n\n    // If game over or won, overlay end screen\n    if (state === \"won\") {\n      drawEndScreen(true);\n    } else if (state === \"lost\") {\n      drawEndScreen(false);\n    }\n  }\n\n  // Helper to draw multiline instruction box\n  function drawMultilineBox(lines, font, xCenter, yStart) {\n    ctx.save();\n    ctx.font = font;\n    const lineHeight = parseInt(font, 10) + 6;\n    // compute max width\n    let maxW = 0;\n    for (const line of lines) {\n      const m = ctx.measureText(line).width;\n      if (m > maxW) maxW = m;\n    }\n    const boxW = maxW + UI_PADDING * 2;\n    const boxH = lineHeight * lines.length + UI_PADDING * 2;\n    const x = xCenter - boxW / 2;\n    const y = yStart;\n    ctx.fillStyle = \"rgba(255,255,255,0.95)\";\n    roundRect(ctx, x, y, boxW, boxH, 8, true, false);\n    ctx.fillStyle = \"#003\";\n    ctx.textBaseline = \"top\";\n    for (let i = 0; i < lines.length; i++) {\n      ctx.fillText(lines[i], x + UI_PADDING, y + UI_PADDING + i * lineHeight);\n    }\n    ctx.restore();\n  }\n\n  // Draw package box\n  function drawPackage(p) {\n    ctx.save();\n    // wobble small hover\n    const wob = Math.sin(p.wobble) * 4;\n    const x = p.x;\n    const y = p.y + wob;\n    // shadow\n    ctx.fillStyle = \"rgba(0,0,0,0.08)\";\n    ctx.beginPath();\n    ctx.ellipse(x + p.w / 2, y + p.h + 8, p.w / 2, 8, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // body\n    ctx.fillStyle = p.collected ? \"rgba(200,200,200,0.6)\" : \"#ffd36b\";\n    roundRect(ctx, x, y, p.w, p.h, 8, true, false);\n    // label border\n    ctx.strokeStyle = \"rgba(0,0,0,0.12)\";\n    ctx.lineWidth = 1;\n    roundRect(ctx, x, y, p.w, p.h, 8, false, true);\n\n    // number text\n    ctx.font = `20px Arial`;\n    ctx.fillStyle = \"#112\";\n    ctx.textBaseline = \"middle\";\n    const txt = String(p.value);\n    // measure\n    const tw = ctx.measureText(txt).width;\n    ctx.fillText(txt, x + (p.w - tw) / 2, y + p.h / 2);\n    // small icon to hint collectability\n    ctx.fillStyle = \"rgba(0,0,0,0.06)\";\n    ctx.fillRect(x + p.w - 12, y - 10, 8, 6);\n    ctx.restore();\n  }\n\n  // Draw drone\n  function drawDrone(d) {\n    ctx.save();\n    // shadow\n    ctx.fillStyle = \"rgba(0,0,0,0.12)\";\n    ctx.beginPath();\n    ctx.ellipse(d.x, d.y + DRONE_RADIUS + 8, DRONE_RADIUS * 1.2, DRONE_RADIUS / 2, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // body\n    ctx.fillStyle = \"#6ec8f0\";\n    ctx.beginPath();\n    ctx.ellipse(d.x, d.y, DRONE_RADIUS + 6, DRONE_RADIUS - 2, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // cockpit\n    ctx.fillStyle = \"#114451\";\n    ctx.beginPath();\n    ctx.arc(d.x, d.y - 4, DRONE_RADIUS - 10, 0, Math.PI * 2);\n    ctx.fill();\n\n    // wacky propellers - four\n    const propOffsets = [\n      { dx: -28, dy: -18 },\n      { dx: 28, dy: -18 },\n      { dx: -28, dy: 18 },\n      { dx: 28, dy: 18 },\n    ];\n    let t = performance.now() / 200;\n    for (let i = 0; i < propOffsets.length; i++) {\n      const p = propOffsets[i];\n      const cx = d.x + p.dx;\n      const cy = d.y + p.dy;\n      // shaft\n      ctx.fillStyle = \"#333\";\n      ctx.fillRect(cx - 2, cy - 2, 4, 12);\n      // blades (rotating)\n      ctx.save();\n      ctx.translate(cx, cy);\n      ctx.rotate(t * (i % 2 === 0 ? 1 : -1));\n      ctx.fillStyle = \"rgba(0,0,0,0.12)\";\n      ctx.fillRect(-22, -4, 44, 8);\n      ctx.restore();\n    }\n\n    // cheerful eyes\n    ctx.fillStyle = \"#fff\";\n    ctx.beginPath();\n    ctx.arc(d.x - 8, d.y - 6, 4, 0, Math.PI * 2);\n    ctx.arc(d.x + 8, d.y - 6, 4, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = \"#000\";\n    ctx.beginPath();\n    ctx.arc(d.x - 8, d.y - 6, 2, 0, Math.PI * 2);\n    ctx.arc(d.x + 8, d.y - 6, 2, 0, Math.PI * 2);\n    ctx.fill();\n\n    // subtle glow when overlapping correct package nearby\n    let nearCorrect = packages.some((p) => {\n      if (p.collected) return false;\n      const dx = p.x + p.w / 2 - d.x;\n      const dy = p.y + p.h / 2 - d.y;\n      return Math.sqrt(dx * dx + dy * dy) < 100 && p.value === question.answer;\n    });\n    if (nearCorrect) {\n      ctx.fillStyle = \"rgba(150,255,180,0.08)\";\n      ctx.beginPath();\n      ctx.ellipse(d.x, d.y, DRONE_RADIUS * 2.2, DRONE_RADIUS * 2, 0, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    ctx.restore();\n  }\n\n  // Wacky background drawing\n  function drawWackyBackground() {\n    ctx.save();\n    // polygons like buildings\n    for (let i = 0; i < 6; i++) {\n      const x = i * 140 + 20;\n      ctx.fillStyle = `rgba(${150 + (i * 10) % 100}, ${200 - i * 12}, ${230 - i * 6}, 0.06)`;\n      ctx.beginPath();\n      ctx.moveTo(x, HEIGHT - 40);\n      ctx.lineTo(x + 40, HEIGHT - 120 - (i % 3) * 8);\n      ctx.lineTo(x + 80, HEIGHT - 40);\n      ctx.closePath();\n      ctx.fill();\n    }\n    // floating bubbles\n    for (let i = 0; i < 10; i++) {\n      const rr = 10 + (i * 7) % 30;\n      const x = (i * 73) % WIDTH + ((i * 13) % 30);\n      const y = (i * 53) % (HEIGHT - 150) + 30;\n      ctx.fillStyle = `rgba(200,230,255,${0.03 + (i % 3) * 0.02})`;\n      ctx.beginPath();\n      ctx.arc(x, y, rr, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    ctx.restore();\n  }\n\n  // Draw end screens\n  function drawEndScreen(won) {\n    ctx.save();\n    ctx.fillStyle = \"rgba(10,10,20,0.5)\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.fillStyle = \"#fff\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.font = `36px Arial`;\n    if (won) {\n      ctx.fillStyle = \"#0a4\";\n      ctx.fillText(\"Victory! You are a Drone Math Hero!\", WIDTH / 2, HEIGHT / 2 - 60);\n    } else {\n      ctx.fillStyle = \"#f44\";\n      ctx.fillText(\"Game Over \u2014 The sky gets tricky!\", WIDTH / 2, HEIGHT / 2 - 60);\n    }\n    ctx.font = `20px Arial`;\n    ctx.fillStyle = \"#fff\";\n    const msg = won ? `You collected ${score} correct answers!` : `You collected ${score} correct answers.`;\n    ctx.fillText(msg, WIDTH / 2, HEIGHT / 2 - 20);\n\n    // Restart button\n    const btn = getRestartButtonRect();\n    ctx.fillStyle = \"rgba(255,255,255,0.95)\";\n    roundRect(ctx, btn.x, btn.y, btn.w, btn.h, 10, true, false);\n    ctx.fillStyle = \"#003\";\n    ctx.font = `20px Arial`;\n    ctx.fillText(\"Restart (R) / Click Here\", WIDTH / 2, btn.y + btn.h / 2);\n    ctx.restore();\n  }\n\n  // Main loop\n  function loop(now) {\n    const dt = (now - lastTime) / 1000;\n    lastTime = now;\n    update(dt);\n    draw();\n    requestAnimationFrame(loop);\n  }\n\n  requestAnimationFrame(loop);\n\n  // Initial focus and hint\n  canvas.focus();\n  // Expose some state for debugging (not required, but helpful)\n  window.__droneMathGame = {\n    reset: resetGame,\n    mute: () => (audioMuted = true),\n    unmute: () => (audioMuted = false),\n  };\n\n  // Ensure Audio context start on first interaction\n  function handleFirstInteraction() {\n    ensureAudioStarted();\n    window.removeEventListener(\"mousedown\", handleFirstInteraction);\n    window.removeEventListener(\"touchstart\", handleFirstInteraction);\n    window.removeEventListener(\"keydown\", handleFirstInteraction);\n  }\n  window.addEventListener(\"mousedown\", handleFirstInteraction);\n  window.addEventListener(\"touchstart\", handleFirstInteraction);\n  window.addEventListener(\"keydown\", handleFirstInteraction);\n})();\n---\n",
  "improve_response_tokens": 17974,
  "formatted_code": true,
  "formatting_response_tokens": 20168,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}