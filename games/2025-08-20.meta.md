# Game of the Day - 2025-08-20

## Metadata
- **Generated Date:** 2025-08-20
- **Generated Time:** 2025-08-20T00:26:36.819553
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-20.js
- **File Size:** 26031 bytes
- **Tokens Used:** 9263

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-20.js` - The playable game
- `2025-08-20.meta.json` - Machine-readable metadata
- `2025-08-20.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 18201

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 20143

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Electricity Math Game for ages 7-9
  // Renders inside element with ID "game-of-the-day-stage"
  // Canvas must be exactly 720x480
  // Uses Web Audio API for sounds (oscillators), canvas-only graphics
  // Accessible: keyboard controls, aria labels, offscreen live region for screen readers

  // ==== Setup DOM and Canvas ====
  const STAGE_ID = 'game-of-the-day-stage';
  const STAGE = document.getElementById(STAGE_ID);
  if (!STAGE) {
    console.error('Game stage element not found:', STAGE_ID);
    return;
  }
  // Clear stage
  STAGE.innerHTML = '';

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = 720;
  canvas.height = 480;
  canvas.style.width = '720px';
  canvas.style.height = '480px';
  canvas.setAttribute('role', 'img');
  canvas.setAttribute('aria-label', 'Spark Factory math game. Use keyboard or mouse to select number nodes to equal a target number. Press S to toggle sound.');
  canvas.tabIndex = 0; // make focusable for keyboard events
  STAGE.appendChild(canvas);

  // Hidden live region for screen readers
  const live = document.createElement('div');
  live.setAttribute('aria-live', 'polite');
  live.style.position = 'absolute';
  live.style.left = '-10000px';
  live.style.width = '1px';
  live.style.height = '1px';
  live.style.overflow = 'hidden';
  STAGE.appendChild(live);

  const ctx = canvas.getContext('2d');
  if (!ctx) {
    console.error('2D context not available.');
    return;
  }

  // ==== Audio Setup with error handling ====
  let audioEnabled = true;
  let audioCtx = null;
  let ambientOsc = null;
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AudioContext();
  } catch (e) {
    console.warn('Web Audio API not available or blocked:', e);
    audioEnabled = false;
  }

  // Resume audio context on user gesture if suspended
  function ensureAudioRunning() {
    if (!audioEnabled || !audioCtx) return Promise.resolve();
    if (audioCtx.state === 'suspended') {
      return audioCtx.resume().catch((e) => {
        console.warn('Could not resume audio context:', e);
      });
    }
    return Promise.resolve();
  }

  // Create simple tone with envelope
  function playTone({ freq = 440, duration = 0.15, type = 'sine', gain = 0.12, attack = 0.01 }) {
    if (!audioEnabled || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, now);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.linearRampToValueAtTime(gain, now + attack);
      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);
      o.connect(g).connect(audioCtx.destination);
      o.start(now);
      o.stop(now + duration + 0.02);
    } catch (err) {
      console.warn('Error playing tone:', err);
      // disable audio to prevent repeated errors
      audioEnabled = false;
    }
  }

  // Ambient hum (gentle) for electricity theme
  function startAmbient() {
    if (!audioEnabled || !audioCtx || ambientOsc) return;
    try {
      ambientOsc = audioCtx.createOscillator();
      const ambientGain = audioCtx.createGain();
      ambientOsc.type = 'sine';
      ambientOsc.frequency.value = 120; // low hum
      ambientGain.gain.value = 0.02;
      // subtle movement with LFO
      const lfo = audioCtx.createOscillator();
      lfo.frequency.value = 0.08;
      const lfoGain = audioCtx.createGain();
      lfoGain.gain.value = 10;
      lfo.connect(lfoGain);
      lfoGain.connect(ambientOsc.frequency);
      ambientOsc.connect(ambientGain).connect(audioCtx.destination);
      ambientOsc.start();
      lfo.start();
      // store for stopping (we keep references)
      ambientOsc._lfo = lfo;
      ambientOsc._gain = ambientGain;
    } catch (err) {
      console.warn('Error starting ambient:', err);
    }
  }
  function stopAmbient() {
    if (!ambientOsc) return;
    try {
      if (ambientOsc._lfo) ambientOsc._lfo.stop();
      ambientOsc.stop();
      ambientOsc = null;
    } catch (err) {
      console.warn('Error stopping ambient:', err);
    }
  }

  // Sound effects
  function playSelectSound() {
    ensureAudioRunning().then(() => {
      playTone({ freq: 880, duration: 0.08, type: 'square', gain: 0.09 });
    });
  }
  function playDeselectSound() {
    ensureAudioRunning().then(() => {
      playTone({ freq: 400, duration: 0.08, type: 'triangle', gain: 0.06 });
    });
  }
  function playCorrectSound() {
    ensureAudioRunning().then(() => {
      // small melody
      playTone({ freq: 660, duration: 0.12, type: 'sine', gain: 0.14 });
      setTimeout(() => playTone({ freq: 880, duration: 0.18, type: 'sine', gain: 0.14 }), 120);
      setTimeout(() => playTone({ freq: 1320, duration: 0.22, type: 'sine', gain: 0.14 }), 320);
    });
  }
  function playIncorrectSound() {
    ensureAudioRunning().then(() => {
      playTone({ freq: 220, duration: 0.28, type: 'sawtooth', gain: 0.12 });
      setTimeout(() => playTone({ freq: 160, duration: 0.18, type: 'sawtooth', gain: 0.08 }), 160);
    });
  }

  // Toggle audio on/off
  function toggleAudio() {
    audioEnabled = !audioEnabled;
    if (audioEnabled) {
      ensureAudioRunning().then(() => startAmbient());
    } else {
      stopAmbient();
    }
    announce(`Sound ${audioEnabled ? 'on' : 'off'}`);
  }

  // ==== Game Logic ====
  const state = {
    nodes: [], // {x,y,r,value,selected,id}
    target: 10,
    selections: [], // indexes of nodes chosen in current attempt
    maxSelect: 3,
    score: 0,
    round: 1,
    attemptsLeft: 3,
    highlightIndex: 0,
    message: 'Select numbers to equal the target',
    showHelp: false,
    mutedByUser: false,
  };

  function announce(text) {
    if (!live) return;
    live.textContent = text;
  }

  // Utility: random integer inclusive
  function ri(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // Create a solvable round: ensure combination of up to maxSelect numbers sums to target
  function generateRound(roundNum = 1) {
    // Determine target: increase range slightly with rounds
    const minT = 6 + Math.min(roundNum - 1, 6); // small growth
    const maxT = 12 + Math.min(roundNum - 1, 8);
    const target = ri(minT, maxT);
    // choose number of terms (2 or 3 usually)
    const terms = Math.random() < 0.4 ? 2 : 3;
    // generate solution parts between 1 and 9
    const parts = [];
    let remaining = target;
    // ensure we can create valid parts: choose random solution composition
    for (let i = 0; i < terms - 1; i++) {
      const maxPart = Math.min(9, remaining - (terms - i - 1) * 1);
      const partMin = 1;
      const part = ri(partMin, Math.max(partMin, maxPart));
      parts.push(part);
      remaining -= part;
    }
    // last part
    if (remaining < 1) {
      // fallback: pick simple two-term split
      const a = ri(1, Math.min(9, target - 1));
      const b = target - a;
      parts.length = 0;
      parts.push(a, b);
    } else if (remaining > 9) {
      // split remaining
      const a = ri(1, 9);
      const b = remaining - a;
      if (b <= 9 && b >= 1) {
        parts.push(a, b);
      } else {
        parts.push(ri(1, 9));
        parts.push(ri(1, 9));
      }
    } else {
      parts.push(remaining);
    }
    // Shuffle parts
    for (let i = parts.length - 1; i > 0; i--) {
      const j = ri(0, i);
      [parts[i], parts[j]] = [parts[j], parts[i]];
    }

    // Create nodes: place 6 nodes, include all parts, fill rest with random numbers
    const nodes = [];
    const positions = [
      { x: 140, y: 160 },
      { x: 360, y: 100 },
      { x: 580, y: 160 },
      { x: 180, y: 320 },
      { x: 360, y: 260 },
      { x: 540, y: 320 },
    ];
    // Fill with parts first
    const used = [];
    for (let i = 0; i < positions.length; i++) {
      let value;
      if (i < parts.length) {
        value = parts[i];
      } else {
        // avoid creating extra numbers equal to parts too often
        let candidate;
        do {
          candidate = ri(1, 9);
        } while (Math.random() < 0.3 && parts.includes(candidate));
        value = candidate;
      }
      nodes.push({
        id: i,
        x: positions[i].x,
        y: positions[i].y,
        r: 40,
        value,
        selected: false,
        disabled: false,
      });
    }

    state.nodes = nodes;
    state.target = target;
    state.selections = [];
    state.highlightIndex = 0;
    state.round = roundNum;
    state.attemptsLeft = 3;
    state.message = 'Select numbers to equal the target';
  }

  // Check current selection
  function currentSum() {
    return state.selections.reduce((s, idx) => s + state.nodes[idx].value, 0);
  }
  function checkSelection() {
    const sum = currentSum();
    if (sum === state.target) {
      state.score += 1;
      state.message = 'Perfect! Gadget powered up!';
      announce(`Correct! Round ${state.round} complete. Score ${state.score}.`);
      playCorrectSound();
      // flash and then next round
      setTimeout(() => {
        generateRound(state.round + 1);
      }, 900);
    } else if (sum > state.target || state.selections.length >= state.maxSelect) {
      // incorrect attempt
      state.attemptsLeft -= 1;
      if (state.attemptsLeft <= 0) {
        state.message = `Out of attempts. The correct sum was ${state.target}. Try again!`;
        announce(`Round ${state.round} failed. Score ${state.score}.`);
        playIncorrectSound();
        setTimeout(() => {
          generateRound(Math.max(1, state.round)); // repeat same round
        }, 1200);
      } else {
        state.message = `Not quite. ${state.attemptsLeft} ${state.attemptsLeft === 1 ? 'attempt' : 'attempts'} left. Try another combo.`;
        announce(state.message);
        playIncorrectSound();
        // deselect all selections for retry
        for (const idx of state.selections) state.nodes[idx].selected = false;
        state.selections = [];
      }
    } else {
      // still less than target and selections remaining
      state.message = 'Good partial total. Keep going!';
      playSelectSound();
    }
  }

  // Select/deselect node by index
  function selectNode(idx) {
    if (!state.nodes[idx]) return;
    const node = state.nodes[idx];
    if (node.disabled) return;
    if (node.selected) {
      node.selected = false;
      // remove from selections
      const pos = state.selections.indexOf(idx);
      if (pos >= 0) state.selections.splice(pos, 1);
      playDeselectSound();
      state.message = 'Number removed.';
      announce('Number removed.');
      return;
    }
    if (state.selections.length >= state.maxSelect) {
      state.message = `You can only pick up to ${state.maxSelect} numbers.`;
      announce(state.message);
      return;
    }
    node.selected = true;
    state.selections.push(idx);
    // Immediately check after selection
    checkSelection();
  }

  // Keyboard navigation: move highlight (left right up down)
  function moveHighlight(dx, dy) {
    // find nearest by simple index navigation: left/right/up/down map to positions index ordering above
    const positions = state.nodes.map((n) => ({ x: n.x, y: n.y }));
    let current = state.highlightIndex || 0;
    const currPos = positions[current];
    let bestIdx = current;
    let bestScore = Infinity;
    for (let i = 0; i < positions.length; i++) {
      if (i === current) continue;
      const p = positions[i];
      const vx = p.x - currPos.x;
      const vy = p.y - currPos.y;
      // require directional dot > 0 (approx)
      if (dx !== 0 && Math.sign(vx) !== dx) continue;
      if (dy !== 0 && Math.sign(vy) !== dy) continue;
      const dist = Math.abs(vx) + Math.abs(vy);
      if (dist < bestScore) {
        bestScore = dist;
        bestIdx = i;
      }
    }
    if (bestIdx !== current) {
      state.highlightIndex = bestIdx;
      playSelectSound();
    }
  }

  // Mouse handling: detect hover & click
  function nodeIndexAt(x, y) {
    for (let i = 0; i < state.nodes.length; i++) {
      const n = state.nodes[i];
      const dx = x - n.x;
      const dy = y - n.y;
      if (dx * dx + dy * dy <= n.r * n.r) return i;
    }
    return -1;
  }

  // ==== Drawing ====
  function drawBackground() {
    // soft gradient background (canvas-only)
    const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
    g.addColorStop(0, '#eaf6ff');
    g.addColorStop(1, '#f0fff6');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // subtle grid of circuits: wavy dashed lines
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.strokeStyle = '#76c7ff';
    ctx.lineWidth = 2;
    for (let i = 0; i < 6; i++) {
      ctx.beginPath();
      const y = 40 + i * 80;
      for (let x = 0; x <= canvas.width; x += 20) {
        const ny = y + Math.sin((x / canvas.width) * Math.PI * 4 + i) * 6;
        if (x === 0) ctx.moveTo(x, ny);
        else ctx.lineTo(x, ny);
      }
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawCharacters() {
    // "Captain Capacitor" left - tall cylinder with friendly face
    ctx.save();
    // body
    ctx.fillStyle = '#ffd87d';
    ctx.beginPath();
    ctx.ellipse(90, 360, 56, 80, 0, 0, Math.PI * 2);
    ctx.fill();
    // metallic top
    ctx.fillStyle = '#e6e6e6';
    ctx.beginPath();
    ctx.ellipse(90, 300, 56, 22, 0, 0, Math.PI * 2);
    ctx.fill();
    // eyes
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.arc(70, 350, 6, 0, Math.PI * 2);
    ctx.arc(110, 350, 6, 0, Math.PI * 2);
    ctx.fill();
    // smile
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(90, 365, 18, 0, Math.PI);
    ctx.stroke();
    // label
    ctx.fillStyle = '#333';
    ctx.font = '12px sans-serif';
    ctx.fillText('Captain Capacitor', 40, 430);
    ctx.restore();

    // "Gigi the Gizmo" right - whimsical gadget
    ctx.save();
    ctx.translate(620, 90);
    ctx.fillStyle = '#dfefff';
    ctx.beginPath();
    ctx.moveTo(-60, 0);
    ctx.quadraticCurveTo(0, -90, 60, 0);
    ctx.quadraticCurveTo(0, 60, -60, 0);
    ctx.fill();
    // eye
    ctx.fillStyle = '#28527a';
    ctx.beginPath();
    ctx.arc(0, -10, 18, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(-6, -16, 6, 0, Math.PI * 2);
    ctx.fill();
    // antenna spark
    ctx.fillStyle = '#ffd36b';
    ctx.beginPath();
    ctx.moveTo(0, -90);
    ctx.lineTo(8, -72);
    ctx.lineTo(-8, -72);
    ctx.fill();
    ctx.fillStyle = '#333';
    ctx.font = '12px sans-serif';
    ctx.fillText('Gigi the Gizmo', -40, 50);
    ctx.restore();
  }

  function drawNodes() {
    for (let i = 0; i < state.nodes.length; i++) {
      const n = state.nodes[i];
      // glow if selected, highlight if hovered
      const isHighlighted = i === state.highlightIndex;
      // wire connection visual: draw a small curved wire to central gadget
      ctx.save();
      // wire base color depends on selection
      ctx.strokeStyle = n.selected ? '#ffd36b' : '#b3e0ff';
      ctx.lineWidth = n.selected ? 4 : 2;
      ctx.beginPath();
      const cx = 360;
      const cy = 60 + 260; // gadget center near middle bottom-ish
      ctx.moveTo(n.x, n.y);
      // control point for curve
      ctx.quadraticCurveTo((n.x + cx) / 2, n.y - 40, cx, cy - 20 + (i % 2 === 0 ? -10 : 10));
      ctx.stroke();
      ctx.restore();

      // node circle
      ctx.save();
      // shadow glow
      ctx.beginPath();
      ctx.fillStyle = isHighlighted ? 'rgba(255,220,120,0.22)' : 'rgba(180,220,255,0.12)';
      ctx.arc(n.x, n.y, n.r + (n.selected ? 8 : 4), 0, Math.PI * 2);
      ctx.fill();

      // circle body
      ctx.beginPath();
      ctx.fillStyle = n.selected ? '#ffefc2' : '#ffffff';
      ctx.strokeStyle = '#2b6a7a';
      ctx.lineWidth = 3;
      ctx.arc(n.x, n.y, n.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // number text
      ctx.fillStyle = '#2b6a7a';
      ctx.font = '28px "Segoe UI", Roboto, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(n.value), n.x, n.y - 4);

      // little label for keyboard hint (1-6)
      ctx.fillStyle = '#2b6a7a';
      ctx.font = '12px sans-serif';
      ctx.fillText(`Key ${i + 1}`, n.x, n.y + 30);

      // small bolt icon inside when selected
      if (n.selected) {
        ctx.beginPath();
        ctx.fillStyle = '#f9a825';
        ctx.moveTo(n.x - 6, n.y - 18);
        ctx.lineTo(n.x + 2, n.y - 8);
        ctx.lineTo(n.x - 2, n.y - 8);
        ctx.lineTo(n.x + 6, n.y + 8);
        ctx.lineTo(n.x - 2, n.y + 0);
        ctx.lineTo(n.x + 2, n.y + 0);
        ctx.closePath();
        ctx.fill();
      }

      ctx.restore();
    }
  }

  function drawGadget() {
    // Central gadget that needs to be powered to target number
    const cx = 360;
    const cy = 140 + 120;
    ctx.save();
    // base rectangle
    ctx.fillStyle = '#e8f8ff';
    ctx.strokeStyle = '#2b6a7a';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.roundRect
      ? ctx.roundRect(cx - 140, cy - 90, 280, 120, 14)
      : (function () {
          const x = cx - 140;
          const y = cy - 90;
          const w = 280;
          const h = 120;
          const r = 14;
          ctx.moveTo(x + r, y);
          ctx.arcTo(x + w, y, x + w, y + h, r);
          ctx.arcTo(x + w, y + h, x, y + h, r);
          ctx.arcTo(x, y + h, x, y, r);
          ctx.arcTo(x, y, x + w, y, r);
          ctx.closePath();
        })();
    ctx.fill();
    ctx.stroke();

    // display target number nicely
    ctx.fillStyle = '#0b486b';
    ctx.font = '28px "Segoe UI", Roboto, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Gadget Power Need', cx, cy - 40);
    ctx.font = '44px "Segoe UI", Roboto, sans-serif';
    ctx.fillStyle = '#2b6a7a';
    ctx.fillText(String(state.target), cx, cy + 6);

    // small meter showing progress
    const sum = currentSum();
    const pct = Math.min(1, sum / state.target);
    ctx.fillStyle = '#cfefff';
    ctx.fillRect(cx - 100, cy + 24, 200, 16);
    ctx.fillStyle = '#7ad0ff';
    ctx.fillRect(cx - 100, cy + 24, 200 * pct, 16);
    ctx.strokeStyle = '#2b6a7a';
    ctx.strokeRect(cx - 100, cy + 24, 200, 16);

    // little spark animation if exact
    if (sum === state.target) {
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2;
        const rx = cx + Math.cos(angle) * 120;
        const ry = cy + Math.sin(angle) * 6;
        ctx.beginPath();
        ctx.fillStyle = `rgba(255,200,90,${0.6 - i * 0.08})`;
        ctx.arc(rx, ry, 6 - i * 0.6, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    ctx.restore();
  }

  function drawUI() {
    // Top-left: score and round
    ctx.save();
    ctx.fillStyle = '#14444f';
    ctx.font = '16px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`Score: ${state.score}`, 16, 24);
    ctx.fillText(`Round: ${state.round}`, 16, 44);
    ctx.fillText(`Attempts: ${state.attemptsLeft}`, 16, 64);
    // instructions
    ctx.font = '13px sans-serif';
    ctx.fillStyle = '#0b486b';
    ctx.fillText('Keys: 1-6 select nodes, arrows to move, Enter to select, Backspace undo, S to toggle sound, R to reset', 150, 24);
    // message box bottom
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.fillRect(20, 420, 680, 44);
    ctx.strokeStyle = '#2b6a7a';
    ctx.strokeRect(20, 420, 680, 44);
    ctx.fillStyle = '#114b5f';
    ctx.font = '16px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(state.message, 36, 447);
    ctx.restore();

    // audio visual indicator
    ctx.save();
    ctx.translate(678, 8);
    // speaker icon
    ctx.fillStyle = audioEnabled ? '#ffd36b' : '#d8d8d8';
    ctx.beginPath();
    ctx.moveTo(0, 6);
    ctx.lineTo(10, 6);
    ctx.lineTo(18, 0);
    ctx.lineTo(18, 24);
    ctx.lineTo(10, 18);
    ctx.lineTo(0, 18);
    ctx.closePath();
    ctx.fill();
    if (audioEnabled) {
      ctx.beginPath();
      ctx.strokeStyle = '#ffedbc';
      ctx.lineWidth = 2;
      ctx.arc(22, 12, 8, -0.6, 0.6);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(22, 12, 12, -0.6, 0.6);
      ctx.stroke();
    } else {
      ctx.strokeStyle = '#a0a0a0';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(-2, -2);
      ctx.lineTo(30, 26);
      ctx.stroke();
    }
    ctx.restore();
  }

  // Draw loop
  function render() {
    // clear
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBackground();
    drawCharacters();
    drawNodes();
    drawGadget();
    drawUI();
    // highlight the currently highlighted node with a ring
    const hi = state.highlightIndex;
    if (typeof hi === 'number' && state.nodes[hi]) {
      const n = state.nodes[hi];
      ctx.save();
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(255,150,30,0.9)';
      ctx.lineWidth = 3;
      ctx.setLineDash([6, 4]);
      ctx.arc(n.x, n.y, n.r + 14, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
    requestAnimationFrame(render);
  }

  // ==== Input Handling ====
  // Focus canvas for keyboard
  canvas.addEventListener('click', (e) => {
    canvas.focus();
    // resume audio if necessary
    if (audioEnabled && audioCtx && audioCtx.state === 'suspended') {
      ensureAudioRunning().then(() => startAmbient());
    }
  });

  // Mouse interactions
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = ((e.clientX - rect.left) / rect.width) * canvas.width;
    const y = ((e.clientY - rect.top) / rect.height) * canvas.height;
    const idx = nodeIndexAt(x, y);
    if (idx !== -1) {
      state.highlightIndex = idx;
    }
  });

  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = ((e.clientX - rect.left) / rect.width) * canvas.width;
    const y = ((e.clientY - rect.top) / rect.height) * canvas.height;
    const idx = nodeIndexAt(x, y);
    if (idx !== -1) {
      selectNode(idx);
      announce(`Selected ${state.nodes[idx].value}. Current sum ${currentSum()} of ${state.target}.`);
    } else {
      // clicking gadget area resets selection maybe
      // if clicked on gadget area, show hint
      if (x > 220 && x < 500 && y > 180 && y < 320) {
        state.message = 'Click a number or press keys 1-6 to select nodes.';
        announce(state.message);
      }
    }
  });

  // Keyboard controls
  canvas.addEventListener('keydown', (e) => {
    // Prevent page from scrolling when using arrows
    const arrows = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
    if (arrows.includes(e.key)) e.preventDefault();

    if (e.key >= '1' && e.key <= '6') {
      const idx = parseInt(e.key, 10) - 1;
      selectNode(idx);
      announce(`Selected ${state.nodes[idx].value}. Current sum ${currentSum()} of ${state.target}.`);
      return;
    }
    if (e.key === 'Enter' || e.key === ' ') {
      // select highlighted
      selectNode(state.highlightIndex);
      announce(`Selected ${state.nodes[state.highlightIndex].value}. Current sum ${currentSum()} of ${state.target}.`);
      return;
    }
    if (e.key === 'Backspace' || e.key === 'Delete') {
      // undo last selection
      const last = state.selections.pop();
      if (typeof last !== 'undefined') {
        state.nodes[last].selected = false;
        state.message = 'Removed last selection.';
        announce(state.message);
        playDeselectSound();
      } else {
        state.message = 'No selections to undo.';
        announce(state.message);
      }
      return;
    }
    if (e.key === 'ArrowLeft') {
      moveHighlight(-1, 0);
      return;
    }
    if (e.key === 'ArrowRight') {
      moveHighlight(1, 0);
      return;
    }
    if (e.key === 'ArrowUp') {
      moveHighlight(0, -1);
      return;
    }
    if (e.key === 'ArrowDown') {
      moveHighlight(0, 1);
      return;
    }
    if (e.key.toLowerCase() === 's') {
      toggleAudio();
      return;
    }
    if (e.key.toLowerCase() === 'r') {
      generateRound(1);
      state.score = 0;
      announce('Game reset.');
      return;
    }
    if (e.key.toLowerCase() === 'h') {
      state.showHelp = !state.showHelp;
      state.message = state.showHelp ? 'Help shown.' : 'Help hidden.';
      announce(state.message);
      return;
    }
  });

  // Keyboard focus styles for accessibility
  canvas.addEventListener('focus', () => {
    canvas.style.outline = '2px dashed rgba(40,80,100,0.6)';
  });
  canvas.addEventListener('blur', () => {
    canvas.style.outline = 'none';
  });

  // ==== Initialization ====
  // Compatibility: add roundRect if not present (for older browsers)
  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
      if (w < 2 * r) r = w / 2;
      if (h < 2 * r) r = h / 2;
      this.beginPath();
      this.moveTo(x + r, y);
      this.arcTo(x + w, y, x + w, y + h, r);
      this.arcTo(x + w, y + h, x, y + h, r);
      this.arcTo(x, y + h, x, y, r);
      this.arcTo(x, y, x + w, y, r);
      this.closePath();
      return this;
    };
  }

  // Start ambient if audio allowed (but may be suspended until user gesture)
  if (audioEnabled && audioCtx) {
    // start ambient; if suspended it may throw, so guard
    ensureAudioRunning().then(() => {
      try {
        startAmbient();
      } catch (e) {
        // may be suspended; ignore
      }
    });
  }

  // Generate first round and begin loop
  generateRound(1);
  render();

  // Small guidance announcements for screen readers at start
  announce('Welcome to Spark Factory. Match numbers to the gadget target. Use keys 1 to 6 or click nodes. Press S to toggle sound.');

  // Expose minimal API for debugging (no global namespace pollution)
  // but attach to element for potential external control
  STAGE.game = {
    reset: () => {
      generateRound(1);
    },
    toggleAudio,
  };
})();
---

