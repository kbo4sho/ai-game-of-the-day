{
  "generated_date": "2025-10-27",
  "generated_timestamp": "2025-10-27T00:30:14.720768",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 10035,
  "game_filename": "2025-10-27.js",
  "game_size_bytes": 27921,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Drone Math Adventure - Canvas + Web Audio API\n// Designed for ages 7-9. Renders inside element with ID \"game-of-the-day-stage\".\n// All visuals drawn on canvas. Sounds generated using Web Audio API oscillators.\n// Single JS file - self-contained. No external assets.\n\n(function () {\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const PADDING = 10;\n  const GOAL_SCORE = 10;\n  const MAX_WRONG = 3;\n  const BALLOON_COUNT = 4; // number of answer targets on screen\n  const BALLOON_MIN_Y = 120;\n  const BALLOON_MAX_Y = 360;\n\n  // Get container element\n  const container = document.getElementById(\"game-of-the-day-stage\");\n  if (!container) {\n    console.error('Container element with ID \"game-of-the-day-stage\" not found.');\n    return;\n  }\n\n  // Clear container and create canvas\n  container.innerHTML = \"\";\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.display = \"block\";\n  canvas.style.background = \"#eaf3ff\"; // subtle sky\n  container.appendChild(canvas);\n  const ctx = canvas.getContext(\"2d\", { alpha: false });\n\n  // Audio context and sound utilities\n  let audioCtx = null;\n  let audioEnabled = false;\n  let ambientOsc = null;\n  let ambientGain = null;\n\n  async function initAudio() {\n    if (audioCtx) return;\n    try {\n      audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n      // create gentle ambient oscillator and gain\n      ambientOsc = audioCtx.createOscillator();\n      ambientGain = audioCtx.createGain();\n      ambientOsc.type = \"sine\";\n      ambientOsc.frequency.setValueAtTime(220, audioCtx.currentTime);\n      ambientGain.gain.setValueAtTime(0.02, audioCtx.currentTime);\n      const lfo = audioCtx.createOscillator();\n      lfo.type = \"sine\";\n      lfo.frequency.setValueAtTime(0.05, audioCtx.currentTime);\n      const lfoGain = audioCtx.createGain();\n      lfoGain.gain.setValueAtTime(30, audioCtx.currentTime);\n      lfo.connect(lfoGain);\n      lfoGain.connect(ambientOsc.frequency);\n      ambientOsc.connect(ambientGain);\n      ambientGain.connect(audioCtx.destination);\n      ambientOsc.start();\n      lfo.start();\n      audioEnabled = true;\n    } catch (e) {\n      console.warn(\"Audio unavailable:\", e);\n      audioEnabled = false;\n      audioCtx = null;\n    }\n  }\n\n  function playTone(type, frequency, duration = 0.25, volume = 0.12) {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      const f = audioCtx.createBiquadFilter();\n      o.type = type;\n      o.frequency.setValueAtTime(frequency, audioCtx.currentTime);\n      g.gain.setValueAtTime(volume, audioCtx.currentTime);\n      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);\n      f.type = \"lowpass\";\n      f.frequency.setValueAtTime(1200, audioCtx.currentTime);\n      o.connect(f);\n      f.connect(g);\n      g.connect(audioCtx.destination);\n      o.start();\n      o.stop(audioCtx.currentTime + duration + 0.02);\n    } catch (e) {\n      console.warn(\"Sound playback failed:\", e);\n    }\n  }\n\n  // UI and game state\n  let state = \"start\"; // \"start\", \"playing\", \"win\", \"lose\"\n  let score = 0;\n  let wrong = 0;\n  let drone = null;\n  let balloons = [];\n  let currentQuestion = null;\n  let keys = {};\n  let mouse = { x: 0, y: 0, down: false };\n  let lastTime = 0;\n  let animateAudioBars = 0;\n  let shakeTimer = 0;\n\n  // Fonts\n  const bodyFont = \"16px Arial\";\n  const importantFont = \"22px Arial\";\n  const titleFont = \"28px Arial\";\n\n  // Drone definition\n  function resetDrone() {\n    drone = {\n      x: WIDTH / 2,\n      y: HEIGHT - 140,\n      vx: 0,\n      vy: 0,\n      speed: 200, // pixels per second\n      radius: 28,\n      propellerAngle: 0\n    };\n  }\n\n  // Math question generation (appropriate for ages 7-9)\n  function generateQuestion() {\n    // Randomly choose addition or subtraction or simple multiplication occasionally\n    const r = Math.random();\n    let a, b, op, answer;\n    if (r < 0.55) {\n      // addition up to 20\n      a = randInt(1, 15);\n      b = randInt(1, 15);\n      op = \"+\";\n      answer = a + b;\n    } else if (r < 0.9) {\n      // subtraction but non-negative\n      a = randInt(5, 20);\n      b = randInt(1, Math.min(10, a));\n      op = \"-\";\n      answer = a - b;\n    } else {\n      // small multiplication\n      a = randInt(2, 6);\n      b = randInt(2, 6);\n      op = \"\u00d7\";\n      answer = a * b;\n    }\n    // Build alternatives\n    const choices = new Set();\n    choices.add(answer);\n    while (choices.size < BALLOON_COUNT) {\n      let alt = answer + randInt(-5, 6);\n      if (Math.abs(alt - answer) <= 0) alt = answer + randInt(1, 6);\n      if (alt < 0) alt = Math.abs(alt) + 1;\n      choices.add(alt);\n    }\n    const choiceArray = shuffle(Array.from(choices));\n    // Place balloons with values\n    const balloonPositions = generateBalloonPositions(choiceArray.length);\n    balloons = choiceArray.map((val, i) => ({\n      x: balloonPositions[i].x,\n      y: balloonPositions[i].y,\n      targetY: balloonPositions[i].y + randInt(-20, 20),\n      vx: randFloat(-20, 20),\n      vy: randFloat(-8, 8),\n      value: val,\n      correct: val === answer,\n      wobble: randFloat(0, Math.PI * 2),\n      color: pastelColor(i)\n    }));\n    currentQuestion = { a, b, op, answer };\n  }\n\n  // Helpers for positions\n  function generateBalloonPositions(count) {\n    const positions = [];\n    const margin = 90;\n    const usableWidth = WIDTH - 2 * margin;\n    for (let i = 0; i < count; i++) {\n      const x = margin + (i + 0.5) * (usableWidth / count) + randInt(-20, 20);\n      const y = randInt(BALLOON_MIN_Y, BALLOON_MAX_Y);\n      positions.push({ x, y });\n    }\n    return positions;\n  }\n\n  // Random helpers\n  function randInt(a, b) {\n    return Math.floor(Math.random() * (b - a + 1)) + a;\n  }\n  function randFloat(a, b) {\n    return Math.random() * (b - a) + a;\n  }\n  function shuffle(arr) {\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    return arr;\n  }\n  function pastelColor(i) {\n    const hues = [200, 150, 300, 40, 260, 120];\n    const h = hues[i % hues.length];\n    return `hsl(${h} 80% 78%)`;\n  }\n\n  // Initialize game variables\n  function resetGame() {\n    score = 0;\n    wrong = 0;\n    shakeTimer = 0;\n    resetDrone();\n    generateQuestion();\n    state = \"playing\";\n  }\n\n  // Collision detection\n  function checkCollisions() {\n    for (const b of balloons) {\n      const dx = drone.x - b.x;\n      const dy = drone.y - b.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      const threshold = drone.radius + 28; // balloon radius approx 28\n      if (dist < threshold) {\n        // collision\n        if (b.handled) continue;\n        b.handled = true; // avoid multiple triggers\n        if (b.correct) {\n          score += 1;\n          playTone(\"sine\", 880, 0.18, 0.12);\n          animateAudioBars = Math.min(1, animateAudioBars + 0.4);\n          // small celebration: spawn stars (visual only)\n          spawnStarsAt(b.x, b.y);\n          // If goal reached: win\n          if (score >= GOAL_SCORE) {\n            state = \"win\";\n            stopAmbientSmooth();\n          } else {\n            // Next question after short delay\n            setTimeout(() => {\n              generateQuestion();\n            }, 700);\n          }\n        } else {\n          wrong += 1;\n          playTone(\"square\", 180, 0.35, 0.14);\n          shakeTimer = 400; // ms\n          animateAudioBars = Math.min(1, animateAudioBars + 0.6);\n          if (wrong >= MAX_WRONG) {\n            state = \"lose\";\n            stopAmbientSmooth();\n          } else {\n            // continue (regenerate after a short bounce)\n            setTimeout(() => {\n              generateQuestion();\n            }, 800);\n          }\n        }\n      }\n    }\n  }\n\n  // Simple star particles\n  let particles = [];\n  function spawnStarsAt(x, y) {\n    for (let i = 0; i < 12; i++) {\n      particles.push({\n        x,\n        y,\n        vx: randFloat(-80, 80),\n        vy: randFloat(-220, -60),\n        life: randFloat(500, 1200),\n        t: 0,\n        size: randFloat(6, 10),\n        hue: randInt(40, 60)\n      });\n    }\n  }\n\n  // Stop ambient with gentle fade\n  function stopAmbientSmooth() {\n    if (!audioEnabled || !audioCtx || !ambientGain) return;\n    try {\n      ambientGain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.6);\n      setTimeout(() => {\n        try {\n          ambientOsc && ambientOsc.stop && ambientOsc.stop();\n          ambientOsc = null;\n          ambientGain = null;\n        } catch (e) {}\n      }, 700);\n    } catch (e) {\n      console.warn(\"Ambient stop error\", e);\n    }\n  }\n\n  // Input handlers\n  window.addEventListener(\"keydown\", (e) => {\n    if (e.key === \" \" || e.code === \"Space\") {\n      e.preventDefault();\n      if (state === \"start\") {\n        // start game and initialize audio context on user gesture\n        initAudio().then(() => {\n          // small confirmation tone\n          playTone(\"sine\", 660, 0.12, 0.08);\n          resetGame();\n        }).catch(() => {\n          resetGame();\n        });\n      } else if (state === \"win\" || state === \"lose\") {\n        restartGame();\n      }\n    } else if (e.key.toLowerCase() === \"r\") {\n      e.preventDefault();\n      restartGame();\n    } else if (e.key.toLowerCase() === \"m\") {\n      // toggle ambient mute\n      if (!audioCtx) return;\n      if (audioEnabled) {\n        // mute\n        try {\n          audioCtx.suspend();\n        } catch (e) {}\n        audioEnabled = false;\n      } else {\n        try {\n          audioCtx.resume();\n        } catch (e) {}\n        audioEnabled = true;\n      }\n    }\n    keys[e.key] = true;\n  });\n  window.addEventListener(\"keyup\", (e) => {\n    keys[e.key] = false;\n  });\n  canvas.addEventListener(\"mousemove\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);\n    mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);\n  });\n  canvas.addEventListener(\"mousedown\", (e) => {\n    mouse.down = true;\n    // clicking on start screen starts and creates audio context\n    if (state === \"start\") {\n      initAudio().then(() => {\n        playTone(\"sine\", 660, 0.12, 0.08);\n        resetGame();\n      }).catch(() => resetGame());\n    }\n    // clicking restart on end screens\n    if (state === \"win\" || state === \"lose\") {\n      // Check if click inside restart button area (we will compute and store it)\n      if (endButtonRect && pointInRect(mouse.x, mouse.y, endButtonRect)) {\n        restartGame();\n      }\n    }\n    // Clicking a balloon directly should trigger immediate pickup\n    if (state === \"playing\") {\n      for (const b of balloons) {\n        if (distance(mouse.x, mouse.y, b.x, b.y) < 36 && !b.handled) {\n          // simulate drone touching balloon by moving drone to it quickly\n          drone.x = b.x;\n          drone.y = b.y + 24;\n          b.handled = false; // ensure collision check handles it\n          checkCollisions();\n        }\n      }\n    }\n  });\n  canvas.addEventListener(\"mouseup\", () => {\n    mouse.down = false;\n  });\n\n  // Utility functions\n  function distance(x1, y1, x2, y2) {\n    const dx = x1 - x2;\n    const dy = y1 - y2;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n  function pointInRect(x, y, rect) {\n    return x >= rect.x && x <= rect.x + rect.w && y >= rect.y && y <= rect.y + rect.h;\n  }\n\n  // End screen button rect (global to detect clicks)\n  let endButtonRect = null;\n\n  // Restart game\n  function restartGame() {\n    try {\n      if (audioEnabled && audioCtx && ambientOsc === null) {\n        // attempt to recreate ambient if audio permitted\n        initAudio().catch(() => {});\n      }\n    } catch (e) {}\n    score = 0;\n    wrong = 0;\n    shakeTimer = 0;\n    resetDrone();\n    generateQuestion();\n    state = \"playing\";\n  }\n\n  // Main update loop\n  function update(dt) {\n    if (state === \"playing\") {\n      // Drone controls: arrow keys or WASD or mouse near pointer (accessible)\n      const moveX = (keys[\"ArrowRight\"] || keys[\"d\"] || keys[\"D\"]) - (keys[\"ArrowLeft\"] || keys[\"a\"] || keys[\"A\"]);\n      const moveY = (keys[\"ArrowDown\"] || keys[\"s\"] || keys[\"S\"]) - (keys[\"ArrowUp\"] || keys[\"w\"] || keys[\"W\"]);\n      // keyboard values booleans; map to -1/0/1\n      const kx = (keys[\"ArrowRight\"] || keys[\"d\"] || keys[\"D\"]) ? 1 : (keys[\"ArrowLeft\"] || keys[\"a\"] || keys[\"A\"]) ? -1 : 0;\n      const ky = (keys[\"ArrowDown\"] || keys[\"s\"] || keys[\"S\"]) ? 1 : (keys[\"ArrowUp\"] || keys[\"w\"] || keys[\"W\"]) ? -1 : 0;\n      // mouse influence when left button is down (drag to fly)\n      let targetX = drone.x;\n      let targetY = drone.y;\n      if (mouse.down) {\n        targetX = mouse.x;\n        targetY = mouse.y;\n      } else {\n        // slight follow mouse if near\n        if (Math.abs(mouse.x - drone.x) < 120) targetX = drone.x + (mouse.x - drone.x) * 0.02;\n        if (Math.abs(mouse.y - drone.y) < 120) targetY = drone.y + (mouse.y - drone.y) * 0.02;\n      }\n      // combine keyboard and mouse targeting\n      const speed = drone.speed;\n      if (kx !== 0 || ky !== 0) {\n        drone.vx = kx * speed;\n        drone.vy = ky * speed;\n      } else {\n        // gentle move toward target\n        drone.vx += (targetX - drone.x) * 2.5 * dt;\n        drone.vy += (targetY - drone.y) * 2.5 * dt;\n        // clamp\n        const max = speed * 0.9;\n        drone.vx = Math.max(-max, Math.min(max, drone.vx));\n        drone.vy = Math.max(-max, Math.min(max, drone.vy));\n      }\n      drone.x += drone.vx * dt;\n      drone.y += drone.vy * dt;\n      // bounds\n      drone.x = Math.max(40, Math.min(WIDTH - 40, drone.x));\n      drone.y = Math.max(70, Math.min(HEIGHT - 60, drone.y));\n      // propeller animation\n      drone.propellerAngle += (Math.abs(drone.vx) + Math.abs(drone.vy)) * 0.01 + 0.1;\n\n      // balloons float\n      for (const b of balloons) {\n        b.wobble += dt * 2;\n        b.x += b.vx * dt;\n        b.y += Math.sin(b.wobble) * 8 * dt;\n        // keep within area\n        if (b.x < 60) b.x = 60;\n        if (b.x > WIDTH - 60) b.x = WIDTH - 60;\n        // gentle horizontal drift\n        if (Math.random() < 0.002) b.vx = randFloat(-40, 40);\n      }\n\n      // particles\n      for (let i = particles.length - 1; i >= 0; i--) {\n        const p = particles[i];\n        p.t += dt * 1000;\n        p.x += p.vx * dt;\n        p.y += p.vy * dt;\n        p.vy += 320 * dt; // gravity\n        if (p.t >= p.life) particles.splice(i, 1);\n      }\n\n      // check collisions\n      checkCollisions();\n    } else {\n      // idle state animations (start/win/lose) slightly animate balloons if any\n    }\n\n    if (shakeTimer > 0) {\n      shakeTimer = Math.max(0, shakeTimer - dt * 1000);\n    }\n\n    // audio bar decay\n    animateAudioBars = Math.max(0, animateAudioBars - dt * 0.8);\n  }\n\n  // Drawing functions - ensure no overlapping text, use measureText\n  function draw() {\n    // clear\n    ctx.save();\n    // screen shake effect when wrong\n    if (shakeTimer > 0) {\n      const s = Math.sin(shakeTimer / 20) * 8;\n      ctx.translate(s, 0);\n    }\n    ctx.fillStyle = \"#eaf3ff\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // background: soft rolling clouds, wacky shapes\n    drawClouds();\n\n    // Ground strip\n    ctx.fillStyle = \"#d9f0e4\";\n    ctx.fillRect(0, HEIGHT - 60, WIDTH, 60);\n    ctx.fillStyle = \"#bfe8d6\";\n    ctx.fillRect(0, HEIGHT - 60, WIDTH, 10);\n\n    // UI: Score top-left, Lives top-right, Question top-center, Instructions bottom-center\n    drawTopUI();\n\n    // Draw balloons (answer targets)\n    for (const b of balloons) {\n      drawBalloon(b);\n    }\n\n    // Draw drone\n    drawDrone(drone);\n\n    // Draw particles (stars)\n    drawParticles();\n\n    // If playing, show gentle hint text near bottom center\n    if (state === \"playing\" && currentQuestion) {\n      drawInstruction(\"Fly the drone to the balloon with the correct answer!\", WIDTH / 2, HEIGHT - 24);\n    }\n\n    // Draw overlays for start/win/lose\n    if (state === \"start\") {\n      drawStartScreen();\n    } else if (state === \"win\") {\n      drawEndScreen(true);\n    } else if (state === \"lose\") {\n      drawEndScreen(false);\n    }\n\n    ctx.restore();\n  }\n\n  function drawClouds() {\n    // draw several wacky pastel cloud blobs\n    const clouds = [\n      { x: 90, y: 60, s: 44, hue: 210 },\n      { x: 260, y: 40, s: 56, hue: 194 },\n      { x: 480, y: 70, s: 40, hue: 220 },\n      { x: 620, y: 60, s: 50, hue: 200 }\n    ];\n    for (const c of clouds) {\n      drawWackyCloud(c.x, c.y, c.s, c.hue);\n    }\n    // faint grid of stars/dots for calm atmosphere\n    ctx.fillStyle = \"rgba(255,255,255,0.04)\";\n    for (let i = 0; i < 18; i++) {\n      ctx.beginPath();\n      const x = 40 + i * 36;\n      ctx.arc(x, 24 + Math.sin(i * 0.8) * 6, 2, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n\n  function drawWackyCloud(x, y, size, hue) {\n    ctx.save();\n    ctx.translate(x, y);\n    for (let i = 0; i < 5; i++) {\n      ctx.beginPath();\n      ctx.fillStyle = `hsl(${hue + i * 3} 80% ${78 - i * 2}%)`;\n      const rx = Math.cos(i * 1.7) * (size * 0.4);\n      const ry = Math.sin(i * 1.2) * (size * 0.2);\n      ctx.arc(rx, ry, size - i * 6, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    ctx.restore();\n  }\n\n  function drawTopUI() {\n    // Score top-left\n    ctx.font = importantFont;\n    ctx.textBaseline = \"middle\";\n    const scoreText = `Score: ${score}/${GOAL_SCORE}`;\n    const scoreW = ctx.measureText(scoreText).width;\n    const scoreBoxW = scoreW + PADDING * 2;\n    const scoreBoxH = 34;\n    const scoreX = PADDING;\n    const scoreY = PADDING;\n    // background rectangle\n    roundRect(ctx, scoreX, scoreY, scoreBoxW, scoreBoxH, 8, \"#ffffff\", \"rgba(0,0,0,0.08)\");\n    // text\n    ctx.fillStyle = \"#253b4a\";\n    ctx.fillText(scoreText, scoreX + PADDING, scoreY + scoreBoxH / 2 + 1);\n\n    // Audio visual cue (speaker) placed next to score with spacing\n    const speakerX = scoreX + scoreBoxW + 12;\n    const speakerY = scoreY + scoreBoxH / 2;\n    drawSpeakerIcon(speakerX, speakerY, 18, animateAudioBars);\n\n    // Lives top-right\n    ctx.font = importantFont;\n    const livesText = `Lives: ${Math.max(0, MAX_WRONG - wrong)}`;\n    const livesW = ctx.measureText(livesText).width;\n    const livesBoxW = livesW + PADDING * 2;\n    const livesBoxH = 34;\n    const livesX = WIDTH - livesBoxW - PADDING;\n    const livesY = PADDING;\n    roundRect(ctx, livesX, livesY, livesBoxW, livesBoxH, 8, \"#fff6f6\", \"rgba(0,0,0,0.06)\");\n    ctx.fillStyle = \"#5a2f2f\";\n    ctx.fillText(livesText, livesX + PADDING, livesY + livesBoxH / 2 + 1);\n\n    // Question at top-center with background\n    ctx.font = titleFont;\n    const qText = currentQuestion ? `${currentQuestion.a} ${currentQuestion.op} ${currentQuestion.b} = ?` : \"Ready?\";\n    const qW = ctx.measureText(qText).width;\n    const qBoxW = qW + PADDING * 2;\n    const qBoxH = 48;\n    const qX = Math.round((WIDTH - qBoxW) / 2);\n    const qY = PADDING;\n    roundRect(ctx, qX, qY, qBoxW, qBoxH, 10, \"#ffffff\", \"rgba(0,0,0,0.06)\");\n    ctx.fillStyle = \"#14384f\";\n    ctx.fillText(qText, qX + PADDING, qY + qBoxH / 2 + 2);\n  }\n\n  function drawSpeakerIcon(x, y, size, level) {\n    // Draw small speaker with animated bars indicating audio level\n    ctx.save();\n    ctx.translate(x, y);\n    // speaker body\n    ctx.fillStyle = \"#2d4b5b\";\n    ctx.fillRect(-8, -8, 12, 16);\n    // cone\n    ctx.beginPath();\n    ctx.moveTo(4, -8);\n    ctx.lineTo(8, -4);\n    ctx.lineTo(8, 4);\n    ctx.lineTo(4, 8);\n    ctx.closePath();\n    ctx.fill();\n    // bars\n    const barCount = 3;\n    for (let i = 0; i < barCount; i++) {\n      const h = 6 + level * 18 * Math.random() * (i + 1);\n      ctx.fillStyle = `rgba(40,120,160,${0.4 + i * 0.2})`;\n      ctx.fillRect(12 + i * 6, -h / 2, 4, h);\n    }\n    ctx.restore();\n  }\n\n  function drawBalloon(b) {\n    // balloon string\n    ctx.save();\n    // slight wobble effect\n    const wob = Math.sin(b.wobble) * 6;\n    // balloon body\n    ctx.beginPath();\n    ctx.fillStyle = b.color;\n    ctx.strokeStyle = \"rgba(0,0,0,0.06)\";\n    ctx.lineWidth = 1.5;\n    ctx.ellipse(b.x + wob, b.y, 28, 34, Math.sin(b.wobble) * 0.15, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n\n    // highlight\n    ctx.beginPath();\n    ctx.fillStyle = \"rgba(255,255,255,0.55)\";\n    ctx.ellipse(b.x - 8 + wob, b.y - 8, 8, 10, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // string\n    ctx.beginPath();\n    ctx.strokeStyle = \"rgba(80,80,80,0.18)\";\n    ctx.lineWidth = 2;\n    ctx.moveTo(b.x + wob, b.y + 28);\n    ctx.quadraticCurveTo(b.x + wob + 8, b.y + 44, b.x + wob - 6, b.y + 54);\n    ctx.stroke();\n\n    // label box behind value for readability\n    ctx.font = bodyFont;\n    ctx.textBaseline = \"middle\";\n    const text = String(b.value);\n    const tw = ctx.measureText(text).width;\n    const bw = tw + 14;\n    const bh = 26;\n    const bx = b.x - bw / 2 + wob;\n    const by = b.y + 44;\n    roundRect(ctx, bx, by, bw, bh, 8, \"#ffffff\", \"rgba(0,0,0,0.06)\");\n    ctx.fillStyle = \"#17394a\";\n    ctx.fillText(text, bx + 7, by + bh / 2 + 1);\n\n    ctx.restore();\n  }\n\n  function drawDrone(d) {\n    if (!d) return;\n    ctx.save();\n    ctx.translate(d.x, d.y);\n    // drone shadow\n    ctx.beginPath();\n    ctx.fillStyle = \"rgba(0,0,0,0.12)\";\n    ctx.ellipse(0, 34, 40, 12, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // body\n    ctx.beginPath();\n    ctx.fillStyle = \"#ffc86b\"; // wacky color\n    ctx.strokeStyle = \"#b37a2b\";\n    ctx.lineWidth = 2;\n    ctx.ellipse(0, 0, 48, 28, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n\n    // window\n    ctx.beginPath();\n    ctx.fillStyle = \"#cfefff\";\n    ctx.ellipse(-6, -4, 18, 12, 0.1, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = \"rgba(0,0,0,0.06)\";\n    ctx.stroke();\n\n    // legs\n    ctx.beginPath();\n    ctx.strokeStyle = \"#6a4b30\";\n    ctx.lineWidth = 3;\n    ctx.moveTo(-26, 18);\n    ctx.lineTo(-16, 30);\n    ctx.moveTo(26, 18);\n    ctx.lineTo(16, 30);\n    ctx.stroke();\n\n    // propellers (wacky)\n    for (let i = -1; i <= 1; i += 2) {\n      const px = i * 36;\n      const py = -12;\n      ctx.save();\n      ctx.translate(px, py);\n      ctx.rotate(d.propellerAngle * (i * -1));\n      // hub\n      ctx.beginPath();\n      ctx.fillStyle = \"#5a5a5a\";\n      ctx.arc(0, 0, 6, 0, Math.PI * 2);\n      ctx.fill();\n      // blades\n      ctx.beginPath();\n      ctx.fillStyle = \"rgba(80,80,80,0.8)\";\n      ctx.ellipse(0, -14, 6, 22, 0.6, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.beginPath();\n      ctx.ellipse(0, 14, 6, 22, -0.6, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n    }\n\n    // small smiley face on window (friendly)\n    ctx.beginPath();\n    ctx.fillStyle = \"#2c5d6f\";\n    ctx.arc(-10, -6, 2.5, 0, Math.PI * 2);\n    ctx.arc(-2, -6, 2.5, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.strokeStyle = \"#2c5d6f\";\n    ctx.lineWidth = 1.5;\n    ctx.arc(-6, -2, 4, 0, Math.PI);\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  function drawParticles() {\n    for (const p of particles) {\n      ctx.save();\n      ctx.translate(p.x, p.y);\n      ctx.globalAlpha = 1 - p.t / p.life;\n      ctx.fillStyle = `hsl(${p.hue} 80% 60%)`;\n      // draw star-ish shape\n      drawStar(ctx, 0, 0, 5, p.size * 0.4, p.size);\n      ctx.restore();\n    }\n    ctx.globalAlpha = 1;\n  }\n\n  function drawInstruction(text, x, y) {\n    ctx.font = bodyFont;\n    ctx.textBaseline = \"middle\";\n    const tw = ctx.measureText(text).width;\n    const bw = tw + PADDING * 2;\n    const bh = 32;\n    const bx = x - bw / 2;\n    const by = y - bh / 2;\n    roundRect(ctx, bx, by, bw, bh, 8, \"rgba(255,255,255,0.9)\", \"rgba(0,0,0,0.05)\");\n    ctx.fillStyle = \"#1b3b4b\";\n    ctx.fillText(text, bx + PADDING, by + bh / 2 + 1);\n  }\n\n  function drawStartScreen() {\n    // Big friendly title / instructions\n    ctx.save();\n    // dim background\n    ctx.fillStyle = \"rgba(8, 24, 40, 0.38)\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    const title = \"Drone Math Adventure!\";\n    const subtitle = \"Help your drone collect the correct answers.\";\n    const prompt = \"Click or press Space to start and enable sound (optional).\";\n    ctx.font = titleFont;\n    ctx.fillStyle = \"#fff\";\n    const tw = ctx.measureText(title).width;\n    ctx.fillText(title, (WIDTH - tw) / 2, HEIGHT / 2 - 40);\n    ctx.font = importantFont;\n    const tw2 = ctx.measureText(subtitle).width;\n    ctx.fillText(subtitle, (WIDTH - tw2) / 2, HEIGHT / 2 - 6);\n    ctx.font = bodyFont;\n    const tw3 = ctx.measureText(prompt).width;\n    ctx.fillText(prompt, (WIDTH - tw3) / 2, HEIGHT / 2 + 30);\n\n    // small accessibility hints\n    const hint = \"Controls: Arrow keys or WASD to fly. Or drag with mouse. Press M to mute/unmute. Press R to restart.\";\n    ctx.font = \"14px Arial\";\n    ctx.fillStyle = \"rgba(255,255,255,0.9)\";\n    const hintW = ctx.measureText(hint).width;\n    ctx.fillText(hint, (WIDTH - hintW) / 2, HEIGHT / 2 + 62);\n    ctx.restore();\n  }\n\n  function drawEndScreen(won) {\n    // semi-transparent overlay\n    ctx.fillStyle = \"rgba(8, 24, 40, 0.35)\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.save();\n    const title = won ? \"You Win! Great Flying!\" : \"Game Over\";\n    const message = won\n      ? `You collected ${score} correct answers!`\n      : `You made ${wrong} wrong answers. Try again!`;\n    ctx.font = titleFont;\n    ctx.fillStyle = \"#fff\";\n    const titleW = ctx.measureText(title).width;\n    ctx.fillText(title, (WIDTH - titleW) / 2, HEIGHT / 2 - 40);\n\n    ctx.font = importantFont;\n    const msgW = ctx.measureText(message).width;\n    ctx.fillText(message, (WIDTH - msgW) / 2, HEIGHT / 2 - 6);\n\n    // Restart button (draw and store rect for click detection)\n    const btnText = \"Restart (R)\";\n    ctx.font = importantFont;\n    const btnW = ctx.measureText(btnText).width + PADDING * 2;\n    const btnH = 44;\n    const bx = (WIDTH - btnW) / 2;\n    const by = HEIGHT / 2 + 20;\n    roundRect(ctx, bx, by, btnW, btnH, 10, \"#fff\", \"rgba(0,0,0,0.12)\");\n    ctx.fillStyle = \"#15384a\";\n    ctx.fillText(btnText, bx + PADDING, by + btnH / 2 + 2);\n\n    // store button rect (for click)\n    endButtonRect = { x: bx, y: by, w: btnW, h: btnH };\n\n    // small extra instruction\n    ctx.font = bodyFont;\n    const extra = \"Press Space or click Restart to play again.\";\n    const ew = ctx.measureText(extra).width;\n    ctx.fillStyle = \"rgba(255,255,255,0.9)\";\n    ctx.fillText(extra, (WIDTH - ew) / 2, by + btnH + 30);\n\n    ctx.restore();\n  }\n\n  // Drawing helpers\n  function roundRect(ctx, x, y, w, h, r, fillColor = \"#fff\", strokeStyle = null) {\n    ctx.save();\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fillColor) {\n      ctx.fillStyle = fillColor;\n      ctx.fill();\n    }\n    if (strokeStyle) {\n      ctx.strokeStyle = strokeStyle;\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  function drawStar(ctx, x, y, points, innerR, outerR) {\n    ctx.beginPath();\n    for (let i = 0; i < points * 2; i++) {\n      const r = (i % 2 === 0) ? outerR : innerR;\n      const a = (i / (points * 2)) * Math.PI * 2;\n      const px = x + Math.cos(a) * r;\n      const py = y + Math.sin(a) * r;\n      if (i === 0) ctx.moveTo(px, py);\n      else ctx.lineTo(px, py);\n    }\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  // Main loop\n  function loop(ts) {\n    if (!lastTime) lastTime = ts;\n    const dt = Math.min(35, ts - lastTime) / 1000; // clamp dt for stability\n    lastTime = ts;\n    update(dt);\n    draw();\n    requestAnimationFrame(loop);\n  }\n\n  // Start the animation loop\n  requestAnimationFrame(loop);\n\n  // Error handling for audio creation is handled in initAudio and playTone with try/catch\n\n  // Provide a small notify if audio not available\n  setTimeout(() => {\n    if (!audioEnabled && state === \"start\") {\n      // show tiny hint on start screen - drawn by drawStartScreen, but log also\n      console.info(\"Audio is disabled or blocked. You can still play the game without sound.\");\n    }\n  }, 800);\n\n})();\n---\n",
  "improve_response_tokens": 21079,
  "formatted_code": true,
  "formatting_response_tokens": 23159,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}