# Game of the Day - 2025-09-22

## Metadata
- **Generated Date:** 2025-09-22
- **Generated Time:** 2025-09-22T00:29:20.021769
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-22.js
- **File Size:** 24481 bytes
- **Tokens Used:** 8091

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-22.js` - The playable game
- `2025-09-22.meta.json` - Machine-readable metadata
- `2025-09-22.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 15536

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 16526

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Fix-the-Machine: a fun math game for ages 7-9
// Renders into the element with id "game-of-the-day-stage"
// All visuals are drawn on a canvas 720x480. Sounds use the Web Audio API (generated).
// Accessible via keyboard and includes on-screen instructions and ARIA live updates.

// Immediately-invoked function to avoid polluting global scope
(() => {
  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const NUM_GEARS = 3;
  const MAX_LEVELS = 6;

  // Helper: clamp
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  // Get container element
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Container element with id "game-of-the-day-stage" not found.');
    return;
  }
  // Clear and set basic styles for container
  container.innerHTML = '';
  container.style.position = 'relative';
  container.style.width = WIDTH + 'px';
  container.style.height = HEIGHT + 'px';
  container.setAttribute('role', 'application');
  container.setAttribute('aria-label', 'Fix the Machine math game');

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.display = 'block';
  canvas.style.outline = 'none';
  canvas.setAttribute('tabindex', '0'); // make keyboard focusable
  canvas.setAttribute('aria-label', 'Machine play area. Use arrow keys to set numbers and Enter to run.');
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Create a small UI area for controls and instructions inside container
  const ui = document.createElement('div');
  ui.style.position = 'absolute';
  ui.style.left = '10px';
  ui.style.top = '10px';
  ui.style.width = (WIDTH - 20) + 'px';
  ui.style.pointerEvents = 'none'; // let canvas handle clicks; UI only for text
  ui.style.color = '#114';
  ui.style.fontFamily = 'Arial, sans-serif';
  container.appendChild(ui);

  // Accessible live region for screen readers
  const live = document.createElement('div');
  live.setAttribute('aria-live', 'polite');
  live.style.position = 'absolute';
  live.style.left = '-9999px';
  live.style.top = 'auto';
  container.appendChild(live);

  // Small visible instruction box within canvas area (drawn on canvas too).
  // But also provide an always-available textual instructions block (pointerEvents none).
  const instructions = document.createElement('div');
  instructions.style.pointerEvents = 'none';
  instructions.innerHTML = 'Goal: Set the three dials so their SUM equals the machine target. Click a dial or use Tab to choose it, then use ↑/↓ to change. Press Space or Enter to RUN.';
  instructions.style.fontSize = '13px';
  instructions.style.padding = '6px';
  instructions.style.background = 'rgba(255,255,255,0.75)';
  instructions.style.borderRadius = '6px';
  instructions.style.width = 'calc(100% - 12px)';
  ui.appendChild(instructions);

  // Visual indicator for audio (muted/unavailable)
  const audioIndicator = document.createElement('div');
  audioIndicator.style.pointerEvents = 'none';
  audioIndicator.style.marginTop = '6px';
  audioIndicator.style.fontSize = '13px';
  audioIndicator.textContent = 'Audio: initializing...';
  ui.appendChild(audioIndicator);

  // Game state
  const state = {
    level: 0,
    target: 0,
    dials: [0, 0, 0],
    selected: 0,
    running: false,
    runProgress: 0,
    solvedCount: 0,
    moves: 0,
    maxMoves: 20,
    animationTime: 0,
    systemOK: true,
    backgroundOn: true,
  };

  // Generate solvable level: pick random digits then target = sum.
  const makeLevel = (levelIndex) => {
    // levels gradually increase complexity by widening digit range or targets
    const rangeMax = 9; // keep simple digits for ages 7-9
    const dials = [];
    for (let i = 0; i < NUM_GEARS; i++) {
      // random start value biased toward mid-values for easier play
      dials.push(Math.floor(Math.random() * (rangeMax + 1)));
    }
    const target = dials.reduce((a, b) => a + b, 0);
    // Optionally nudge target upward for later levels by adding small increments
    // But since we want solvable, adjust by storing "solution" internally:
    return { dialsStart: dials, target };
  };

  // Audio manager
  class AudioManager {
    constructor() {
      this.ctx = null;
      this.master = null;
      this.bgOsc = null;
      this.bgGain = null;
      this.available = false;
      this.initialized = false;
    }

    // Initialize on first user gesture to satisfy autoplay policies.
    async init() {
      if (this.initialized) return;
      this.initialized = true;
      try {
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        if (!AudioCtx) throw new Error('Web Audio API not supported.');
        this.ctx = new AudioCtx();
        // create master gain
        this.master = this.ctx.createGain();
        this.master.gain.value = 0.6;
        this.master.connect(this.ctx.destination);
        // gentle background hum
        this.bgOsc = this.ctx.createOscillator();
        this.bgOsc.type = 'sine';
        this.bgGain = this.ctx.createGain();
        this.bgGain.gain.value = 0.02; // very gentle
        this.bgOsc.frequency.value = 90; // low hum
        // subtle filter to make it warm
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 800;
        this.bgOsc.connect(filter);
        filter.connect(this.bgGain);
        this.bgGain.connect(this.master);
        this.bgOsc.start();
        this.available = true;
        audioIndicator.textContent = 'Audio: on';
      } catch (err) {
        console.warn('Audio init failed:', err);
        this.available = false;
        audioIndicator.textContent = 'Audio: unavailable';
      }
    }

    // Play a short tick sound when dial changes
    playTick() {
      if (!this.available) return;
      const t = this.ctx.currentTime;
      try {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'triangle';
        osc.frequency.value = 880 + Math.random() * 220;
        gain.gain.value = 0.0001;
        osc.connect(gain);
        gain.connect(this.master);
        gain.gain.setValueAtTime(0.0001, t);
        gain.gain.linearRampToValueAtTime(0.08, t + 0.005);
        gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.18);
        osc.start(t);
        osc.stop(t + 0.2);
      } catch (err) {
        console.warn('tick sound failed', err);
      }
    }

    // Play success chime (ascending arpeggio)
    playSuccess() {
      if (!this.available) return;
      const t = this.ctx.currentTime;
      try {
        const freqs = [440, 660, 880, 1100].map((f) => f * (1 + (Math.random() - 0.5) * 0.04));
        freqs.forEach((freq, i) => {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.type = i % 2 === 0 ? 'sine' : 'triangle';
          osc.frequency.value = freq;
          gain.gain.value = 0.0001;
          osc.connect(gain);
          gain.connect(this.master);
          const start = t + i * 0.08;
          gain.gain.setValueAtTime(0.0001, start);
          gain.gain.linearRampToValueAtTime(0.12, start + 0.02);
          gain.gain.exponentialRampToValueAtTime(0.0001, start + 0.32);
          osc.start(start);
          osc.stop(start + 0.34);
        });
      } catch (err) {
        console.warn('success sound failed', err);
      }
    }

    // Play incorrect buzzer
    playBuzzer() {
      if (!this.available) return;
      const t = this.ctx.currentTime;
      try {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 220;
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.master);
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(140, t);
        gain.gain.setValueAtTime(0.0001, t);
        gain.gain.linearRampToValueAtTime(0.2, t + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.5);
        osc.frequency.exponentialRampToValueAtTime(60, t + 0.45);
        osc.start(t);
        osc.stop(t + 0.5);
      } catch (err) {
        console.warn('buzzer sound failed', err);
      }
    }

    // Toggle background hum on/off
    setBackground(on) {
      if (!this.available || !this.bgGain) return;
      try {
        this.bgGain.gain.setTargetAtTime(on ? 0.02 : 0.0001, this.ctx.currentTime, 0.2);
      } catch (err) {
        console.warn('background toggle failed', err);
      }
    }
  }

  const audio = new AudioManager();

  // Start audio on first user gesture
  const ensureAudioOnUserGesture = async () => {
    if (!audio.initialized) {
      await audio.init();
      audio.setBackground(state.backgroundOn);
    }
  };

  // Game class managing logic and rendering
  class Game {
    constructor(ctx) {
      this.ctx = ctx;
      this.lastTime = performance.now();
      this.running = false;
      this.levelData = [];
      for (let i = 0; i < MAX_LEVELS; i++) {
        this.levelData.push(makeLevel(i));
      }
      this.resetToLevel(0);
      this.bindEvents();
      this.animationId = requestAnimationFrame((t) => this.loop(t));
      this.confetti = [];
    }

    resetToLevel(index) {
      state.level = index;
      const data = this.levelData[index];
      // For increasing difficulty, sometimes alter the target to be sum+small number and allow changes negative? To keep solvable, we store solution as target and start values differ.
      state.dials = data.dialsStart.map((v) => {
        // start value randomly offset by -3..3 but clamp 0..9
        const offset = Math.floor(Math.random() * 7) - 3;
        return clamp(v + offset, 0, 9);
      });
      state.target = data.target;
      state.selected = 0;
      state.running = false;
      state.runProgress = 0;
      state.moves = 0;
      state.solvedCount = 0;
      state.animationTime = 0;
      live.textContent = `Level ${state.level + 1}: target ${state.target}. Use arrow keys or click dials.`;
    }

    nextLevel() {
      if (state.level < MAX_LEVELS - 1) {
        this.resetToLevel(state.level + 1);
      } else {
        // finished all levels: show congratulations then restart
        live.textContent = 'All machines fixed! Great job! Press Enter to play again.';
        state.solvedCount = 0;
        // create confetti burst
        this.spawnConfetti(60);
        // reset to start after small delay
        setTimeout(() => {
          this.resetToLevel(0);
        }, 3000);
      }
    }

    bindEvents() {
      // Keyboard controls on canvas
      canvas.addEventListener('keydown', async (e) => {
        // Ensure audio init
        await ensureAudioOnUserGesture();
        const key = e.key;
        if (key === 'Tab') {
          e.preventDefault();
          // cycle selection
          state.selected = (state.selected + 1) % NUM_GEARS;
          this.announceSelection();
        } else if (key === 'ArrowRight') {
          state.selected = (state.selected + 1) % NUM_GEARS;
          this.announceSelection();
        } else if (key === 'ArrowLeft') {
          state.selected = (state.selected - 1 + NUM_GEARS) % NUM_GEARS;
          this.announceSelection();
        } else if (key === 'ArrowUp') {
          state.dials[state.selected] = clamp(state.dials[state.selected] + 1, 0, 9);
          audio.playTick();
          state.moves++;
        } else if (key === 'ArrowDown') {
          state.dials[state.selected] = clamp(state.dials[state.selected] - 1, 0, 9);
          audio.playTick();
          state.moves++;
        } else if (key === ' ' || key === 'Enter') {
          // Run the machine
          this.runMachine();
        } else if (key.toLowerCase() === 'r') {
          // Reset current dials to initial solution start
          this.resetToLevel(state.level);
        } else if (key.toLowerCase() === 'm') {
          // toggle background audio
          state.backgroundOn = !state.backgroundOn;
          audio.setBackground(state.backgroundOn);
          audioIndicator.textContent = 'Audio: ' + (state.backgroundOn ? 'on' : 'muted');
        }
      });

      // Mouse interactions over canvas
      canvas.addEventListener('click', async (e) => {
        await ensureAudioOnUserGesture();
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        // If click is on one of the dial areas, select it or adjust
        const dialIndex = this.dialIndexAt(x, y);
        if (dialIndex !== -1) {
          // If click on dial center, select. If clicked upper half, increment; lower half decrement.
          const dialCenter = this.dialCenter(dialIndex);
          if (y < dialCenter.y) {
            state.dials[dialIndex] = clamp(state.dials[dialIndex] + 1, 0, 9);
          } else {
            state.dials[dialIndex] = clamp(state.dials[dialIndex] - 1, 0, 9);
          }
          state.selected = dialIndex;
          state.moves++;
          audio.playTick();
          this.announceSelection();
          return;
        }
        // Click on "run" machine area (big button area near bottom)
        if (x > WIDTH / 2 - 80 && x < WIDTH / 2 + 80 && y > HEIGHT - 100 && y < HEIGHT - 40) {
          this.runMachine();
          return;
        }
      });

      // Support mouse wheel to change selected dial when hovering
      canvas.addEventListener('wheel', async (e) => {
        e.preventDefault();
        await ensureAudioOnUserGesture();
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const idx = this.dialIndexAt(x, y);
        if (idx !== -1) {
          state.dials[idx] = clamp(state.dials[idx] + (e.deltaY < 0 ? 1 : -1), 0, 9);
          audio.playTick();
          state.moves++;
        }
      });

      // Accessibility: focus canvas on pointer enter so keyboard works easily
      canvas.addEventListener('mouseenter', () => {
        canvas.focus();
      });
    }

    announceSelection() {
      live.textContent = `Selected dial ${state.selected + 1}. Value ${state.dials[state.selected]}. Target ${state.target}.`;
    }

    dialCenter(index) {
      // compute positions for three dials
      const spacing = 160;
      const centerY = HEIGHT / 2 + 10;
      const startX = WIDTH / 2 - spacing;
      return { x: startX + index * spacing, y: centerY };
    }

    dialIndexAt(x, y) {
      // check click near dials (circle radius 48)
      for (let i = 0; i < NUM_GEARS; i++) {
        const c = this.dialCenter(i);
        const dx = x - c.x;
        const dy = y - c.y;
        if (dx * dx + dy * dy <= 48 * 48) return i;
      }
      return -1;
    }

    runMachine() {
      if (state.running) return;
      state.running = true;
      state.runProgress = 0;
      state.animationTime = 0;
      // Play start sequence
      audio.playTick();
      live.textContent = 'Machine starting...';
    }

    spawnConfetti(n) {
      for (let i = 0; i < n; i++) {
        this.confetti.push({
          x: WIDTH / 2,
          y: HEIGHT / 2,
          vx: (Math.random() - 0.5) * 6,
          vy: (Math.random() - 1.8) * 6,
          size: 4 + Math.random() * 6,
          color: `hsl(${Math.random() * 360},70%,60%)`,
          rot: Math.random() * Math.PI * 2,
          life: 60 + Math.random() * 40,
        });
      }
    }

    update(dt) {
      // update running animation
      if (state.running) {
        state.runProgress += dt * 0.002; // progress 0..1
        state.animationTime += dt;
        if (state.runProgress >= 1) {
          state.running = false;
          state.runProgress = 1;
          // Evaluate result
          const sum = state.dials.reduce((a, b) => a + b, 0);
          if (sum === state.target) {
            audio.playSuccess();
            this.spawnConfetti(20);
            live.textContent = `Nice! The sum is ${sum}. Machine fixed! Press Enter for next machine.`;
            // prepare to advance to next level automatically after small delay
            setTimeout(() => {
              this.nextLevel();
            }, 1000);
          } else {
            audio.playBuzzer();
            live.textContent = `Oops! The sum is ${sum}. Try again.`;
            // small shake animation
            this.shake = 10;
          }
        } else {
          // While running, produce metallic ticks occasionally
          if (Math.random() < 0.02) audio.playTick();
        }
      }
      // update confetti
      for (let i = this.confetti.length - 1; i >= 0; i--) {
        const p = this.confetti[i];
        p.vy += 0.18; // gravity
        p.x += p.vx;
        p.y += p.vy;
        p.rot += 0.2;
        p.life -= 1;
        if (p.life <= 0 || p.y > HEIGHT + 50) this.confetti.splice(i, 1);
      }
      if (this.shake) {
        this.shake = Math.max(0, this.shake - dt * 0.02);
      }
    }

    draw() {
      const c = this.ctx;
      // calming background gradient with wacky details
      c.clearRect(0, 0, WIDTH, HEIGHT);
      const g = c.createLinearGradient(0, 0, 0, HEIGHT);
      g.addColorStop(0, '#E8F6F3');
      g.addColorStop(1, '#F6F9FF');
      c.fillStyle = g;
      c.fillRect(0, 0, WIDTH, HEIGHT);

      // subtle large gear shapes in background (wacky)
      for (let i = 0; i < 6; i++) {
        c.save();
        const gx = 60 + i * 120;
        const gy = 60 + (i % 2) * 40;
        c.globalAlpha = 0.06 + (i % 3) * 0.02;
        this.drawSimpleGear(c, gx, gy, 26 + (i % 3) * 8, i * 20);
        c.restore();
      }

      // central machine base
      c.save();
      const shakeX = this.shake ? Math.sin(this.animationTime * 0.03) * this.shake : 0;
      c.translate(shakeX, 0);
      c.fillStyle = '#FFF';
      this.roundRect(c, 40, 80, WIDTH - 80, HEIGHT - 160, 18);
      c.fillStyle = 'rgba(210,230,240,0.8)';
      this.roundRect(c, 44, 84, WIDTH - 88, HEIGHT - 168, 16);
      c.fill();

      // Machine face (display)
      c.fillStyle = '#112';
      c.fillRect(WIDTH / 2 - 160, 100, 320, 64);
      c.fillStyle = '#AEE';
      c.font = '28px "Comic Sans MS", Arial';
      c.textAlign = 'center';
      c.fillText('TARGET: ' + state.target, WIDTH / 2, 138);

      // small wacky pipes left
      c.strokeStyle = '#89B';
      c.lineWidth = 6;
      c.beginPath();
      c.moveTo(80, 160);
      c.quadraticCurveTo(120, 140, 180, 180);
      c.stroke();
      // right pipe
      c.beginPath();
      c.moveTo(WIDTH - 80, 160);
      c.quadraticCurveTo(WIDTH - 120, 140, WIDTH - 180, 180);
      c.stroke();

      // Dials / gears in center
      for (let i = 0; i < NUM_GEARS; i++) {
        const pos = this.dialCenter(i);
        const dialValue = state.dials[i];
        const isSelected = state.selected === i;
        // animated rotation while running
        const rot = (state.running ? state.runProgress * (i + 1) * Math.PI * 2 : 0) + (isSelected ? Math.sin(Date.now() / 300) * 0.08 : 0);
        this.drawBigDial(c, pos.x, pos.y, 48, dialValue, rot, isSelected);
      }

      // progress bar / running indicator below dials
      c.fillStyle = '#dde';
      c.fillRect(WIDTH / 2 - 180, HEIGHT / 2 + 90, 360, 14);
      c.fillStyle = '#4DB';
      c.fillRect(WIDTH / 2 - 180, HEIGHT / 2 + 90, 360 * state.runProgress, 14);

      // Run button region
      c.beginPath();
      const btnX = WIDTH / 2 - 80;
      const btnY = HEIGHT - 100;
      this.roundRect(c, btnX, btnY, 160, 48, 10);
      c.fillStyle = '#2A6';
      c.fill();
      c.fillStyle = '#fff';
      c.font = '20px Arial';
      c.textAlign = 'center';
      c.fillText('RUN MACHINE', WIDTH / 2, btnY + 32);

      // small hint text
      c.fillStyle = '#224';
      c.font = '13px Arial';
      c.textAlign = 'left';
      c.fillText('Moves: ' + state.moves + (state.moves > state.maxMoves ? ' (too many moves!)' : ''), 60, HEIGHT - 40);

      // speaker icon (visual cue for audio)
      c.save();
      c.translate(WIDTH - 90, 40);
      c.fillStyle = state.backgroundOn ? '#1b5' : '#999';
      c.beginPath();
      c.moveTo(-18, -8);
      c.lineTo(-8, -8);
      c.lineTo(0, -18);
      c.lineTo(0, 18);
      c.lineTo(-8, 8);
      c.lineTo(-18, 8);
      c.closePath();
      c.fill();
      if (audio.available && state.backgroundOn) {
        c.beginPath();
        c.strokeStyle = '#1b5';
        c.lineWidth = 2;
        c.arc(6, 0, 12, -0.6, 0.6);
        c.stroke();
      }
      c.restore();

      // confetti draw
      for (const p of this.confetti) {
        c.save();
        c.translate(p.x, p.y);
        c.rotate(p.rot);
        c.fillStyle = p.color;
        c.fillRect(-p.size / 2, -p.size / 2, p.size, p.size * 0.6);
        c.restore();
      }

      c.restore(); // end main container transform
    }

    // utility: draw big dial with teeth and number
    drawBigDial(c, x, y, r, value, rotation = 0, selected = false) {
      c.save();
      c.translate(x, y);
      c.rotate(rotation);
      // outer ring
      c.beginPath();
      c.fillStyle = selected ? '#FFE8A6' : '#FFF';
      c.strokeStyle = '#88A';
      c.lineWidth = 4;
      c.arc(0, 0, r + 8, 0, Math.PI * 2);
      c.fill();
      c.stroke();
      // gear teeth
      const teeth = 12;
      for (let i = 0; i < teeth; i++) {
        const ang = (i / teeth) * Math.PI * 2;
        const tx = Math.cos(ang) * (r + 12);
        const ty = Math.sin(ang) * (r + 12);
        c.beginPath();
        c.fillStyle = '#CCD';
        c.ellipse(tx, ty, 6, 3, ang, 0, Math.PI * 2);
        c.fill();
      }
      // dial face
      c.beginPath();
      c.fillStyle = '#EAF7FF';
      c.arc(0, 0, r, 0, Math.PI * 2);
      c.fill();
      c.lineWidth = 2;
      c.strokeStyle = '#779';
      c.stroke();
      // number
      c.fillStyle = '#113';
      c.font = '36px "Comic Sans MS", Arial';
      c.textAlign = 'center';
      c.textBaseline = 'middle';
      c.fillText(String(value), 0, 0);
      c.restore();
    }

    // small simple gear in background
    drawSimpleGear(c, x, y, r, rot) {
      c.save();
      c.translate(x, y);
      c.rotate(rot * 0.017);
      c.fillStyle = '#cfe';
      c.beginPath();
      c.arc(0, 0, r, 0, Math.PI * 2);
      c.fill();
      const teeth = 10;
      c.fillStyle = '#bcd';
      for (let i = 0; i < teeth; i++) {
        const ang = (i / teeth) * Math.PI * 2;
        const tx = Math.cos(ang) * (r + 6);
        const ty = Math.sin(ang) * (r + 6);
        c.fillRect(tx - 3, ty - 2, 6, 4);
      }
      c.restore();
    }

    // helper to draw rounded rect path
    roundRect(c, x, y, w, h, r) {
      c.beginPath();
      c.moveTo(x + r, y);
      c.arcTo(x + w, y, x + w, y + h, r);
      c.arcTo(x + w, y + h, x, y + h, r);
      c.arcTo(x, y + h, x, y, r);
      c.arcTo(x, y, x + w, y, r);
      c.closePath();
    }

    loop(time) {
      const dt = time - this.lastTime;
      this.lastTime = time;
      this.update(dt);
      this.draw();
      this.animationId = requestAnimationFrame((t) => this.loop(t));
    }
  }

  // Instantiate game
  const game = new Game(ctx);

  // Provide initial text content for screen readers
  live.textContent = 'Welcome to Fix-the-Machine! Focus the game area and follow the instructions to set the dials so their sum matches the target number.';

  // Click-to-enable audio hint: add a semi-transparent overlay telling the user to interact to enable audio if audio unavailable
  const hint = document.createElement('div');
  hint.style.position = 'absolute';
  hint.style.left = '0';
  hint.style.bottom = '8px';
  hint.style.width = '100%';
  hint.style.textAlign = 'center';
  hint.style.pointerEvents = 'none';
  hint.style.fontSize = '12px';
  hint.style.color = '#113';
  hint.textContent = 'Tip: Press M to toggle background sound. Press R to reset. Click or press Enter to run.';
  container.appendChild(hint);

  // Informational console: log errors for audio and resource handling
  window.addEventListener('unhandledrejection', (ev) => {
    console.error('Unhandled promise rejection:', ev.reason);
  });

  // Fallback: if Web Audio cannot start because of autoplay policy until user gesture, show a small note
  canvas.addEventListener('pointerdown', async () => {
    await ensureAudioOnUserGesture();
  }, { once: true });

})();
---

