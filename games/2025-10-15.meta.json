{
  "generated_date": "2025-10-15",
  "generated_timestamp": "2025-10-15T01:57:45.147429",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8027,
  "game_filename": "2025-10-15.js",
  "game_size_bytes": 23811,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Drone Math Catcher - Canvas Game\n  // Ages 7-9. Theme: Drones. Collect the correct numbered packages to answer math questions.\n  // Goal: Collect 10 correct packages. Lose when 3 wrong choices are made.\n  // All visuals via canvas. All sounds via Web Audio API oscillators/filters.\n  // Written for readability and accessibility.\n\n  // Ensure host container\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Container element with id \"game-of-the-day-stage\" not found.');\n    return;\n  }\n\n  // Create canvas\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  container.innerHTML = ''; // clear existing content\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.display = 'block';\n  canvas.setAttribute('role', 'application');\n  canvas.setAttribute('aria-label', 'Drone Math Catcher. Use left and right arrows to move. Press R to restart.');\n  canvas.tabIndex = 0; // make focusable for keyboard\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext('2d');\n\n  // UI layout constants and padding\n  const PADDING = 10;\n  const TOP_UI_Y = PADDING;\n  const SCORE_X = PADDING;\n  const LIVES_X = WIDTH - PADDING;\n  const INSTRUCTIONS_Y = HEIGHT - 70; // bottom area for instructions\n  const MIN_BODY_FONT = 14;\n  const BIG_FONT = 24;\n\n  // Game parameters\n  const TARGET_SCORE = 10;\n  const MAX_LIVES = 3;\n  const PACKAGE_SPEED_MIN = 0.4;\n  const PACKAGE_SPEED_MAX = 1.2;\n  const DRONE_SPEED = 4;\n  const PACKAGE_RADIUS = 28;\n  const DRONE_WIDTH = 80;\n  const DRONE_HEIGHT = 32;\n\n  // State\n  let score = 0;\n  let lives = MAX_LIVES;\n  let level = 1;\n  let gameState = 'running'; // running, won, lost, paused\n  let packages = [];\n  let currentProblem = null;\n  let keys = {};\n  let animationFrameId = null;\n  let lastTime = performance.now();\n\n  // Accessibility messages\n  function updateAriaMessage(msg) {\n    canvas.setAttribute('aria-label', msg);\n  }\n\n  // Audio setup with error handling\n  let audioCtx = null;\n  let audioAllowed = true;\n  try {\n    const AudioContext = window.AudioContext || window.webkitAudioContext;\n    audioCtx = new AudioContext();\n  } catch (e) {\n    console.warn('Web Audio API not available or blocked:', e);\n    audioAllowed = false;\n    audioCtx = null;\n  }\n\n  // Resume audio on user gesture if suspended\n  function tryResumeAudio() {\n    if (!audioCtx) return;\n    if (audioCtx.state === 'suspended') {\n      audioCtx.resume().catch((e) => {\n        console.warn('AudioContext resume failed:', e);\n      });\n    }\n  }\n\n  // Sound helpers (use oscillators; handle audio errors)\n  function playSuccessSound() {\n    if (!audioAllowed || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = 'sine';\n      o.frequency.setValueAtTime(880, now);\n      o.frequency.exponentialRampToValueAtTime(1320, now + 0.12);\n      g.gain.setValueAtTime(0, now);\n      g.gain.linearRampToValueAtTime(0.08, now + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);\n      o.connect(g);\n      g.connect(audioCtx.destination);\n      o.start(now);\n      o.stop(now + 0.3);\n    } catch (e) {\n      console.warn('Error playing success sound', e);\n    }\n  }\n\n  function playFailSound() {\n    if (!audioAllowed || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      const f = audioCtx.createBiquadFilter();\n      o.type = 'square';\n      o.frequency.setValueAtTime(200, now);\n      o.frequency.exponentialRampToValueAtTime(80, now + 0.15);\n      f.type = 'lowpass';\n      f.frequency.setValueAtTime(1200, now);\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(0.08, now + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.3);\n      o.connect(f);\n      f.connect(g);\n      g.connect(audioCtx.destination);\n      o.start(now);\n      o.stop(now + 0.35);\n    } catch (e) {\n      console.warn('Error playing fail sound', e);\n    }\n  }\n\n  // Background gentle hum: persistent oscillator low volume\n  let hum = null;\n  function startBackgroundHum() {\n    if (!audioAllowed || !audioCtx) return;\n    try {\n      if (hum) return;\n      hum = {};\n      hum.osc = audioCtx.createOscillator();\n      hum.gain = audioCtx.createGain();\n      hum.filter = audioCtx.createBiquadFilter();\n      hum.osc.type = 'sine';\n      hum.osc.frequency.setValueAtTime(120, audioCtx.currentTime);\n      hum.filter.type = 'lowpass';\n      hum.filter.frequency.setValueAtTime(600, audioCtx.currentTime);\n      hum.gain.gain.setValueAtTime(0.01, audioCtx.currentTime);\n      hum.osc.connect(hum.filter);\n      hum.filter.connect(hum.gain);\n      hum.gain.connect(audioCtx.destination);\n      hum.osc.start();\n    } catch (e) {\n      console.warn('Could not start background hum', e);\n      hum = null;\n    }\n  }\n\n  function stopBackgroundHum() {\n    if (!hum) return;\n    try {\n      hum.osc.stop();\n      hum.osc.disconnect();\n      hum.filter.disconnect();\n      hum.gain.disconnect();\n    } catch (e) {\n      // no-op\n    }\n    hum = null;\n  }\n\n  // Game objects\n  const drone = {\n    x: WIDTH / 2,\n    y: HEIGHT - 80,\n    vx: 0,\n    width: DRONE_WIDTH,\n    height: DRONE_HEIGHT,\n    color: '#6AB8FF',\n    draw: function (ctx) {\n      // draw drone body\n      ctx.save();\n      ctx.fillStyle = this.color;\n      ctx.strokeStyle = '#23395B';\n      ctx.lineWidth = 2;\n      // body\n      ctx.beginPath();\n      ctx.ellipse(this.x, this.y, this.width / 2, this.height / 2, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n      // propellers (wacky)\n      ctx.fillStyle = '#DDEEFF';\n      const pr = 10;\n      ctx.beginPath();\n      ctx.arc(this.x - this.width / 2 + 12, this.y - this.height / 2 - 6, pr, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.beginPath();\n      ctx.arc(this.x + this.width / 2 - 12, this.y - this.height / 2 - 6, pr, 0, Math.PI * 2);\n      ctx.fill();\n      // legs\n      ctx.strokeStyle = '#23395B';\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(this.x - 22, this.y + 14);\n      ctx.lineTo(this.x - 22, this.y + 24);\n      ctx.moveTo(this.x + 22, this.y + 14);\n      ctx.lineTo(this.x + 22, this.y + 24);\n      ctx.stroke();\n      ctx.restore();\n      // hitbox guide for accessibility (thin outline)\n      ctx.save();\n      ctx.strokeStyle = 'rgba(0,0,0,0.08)';\n      ctx.lineWidth = 1;\n      ctx.strokeRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);\n      ctx.restore();\n    },\n    update: function () {\n      // Horizontal movement constrained to canvas\n      if (keys['ArrowLeft'] || keys['a'] || keys['A']) {\n        this.vx = -DRONE_SPEED;\n      } else if (keys['ArrowRight'] || keys['d'] || keys['D']) {\n        this.vx = DRONE_SPEED;\n      } else {\n        this.vx = 0;\n      }\n      this.x += this.vx;\n      if (this.x < this.width / 2) this.x = this.width / 2;\n      if (this.x > WIDTH - this.width / 2) this.x = WIDTH - this.width / 2;\n    },\n  };\n\n  class PackageItem {\n    constructor(x, y, value, speed, color) {\n      this.x = x;\n      this.y = y;\n      this.value = value;\n      this.speed = speed;\n      this.color = color;\n      this.radius = PACKAGE_RADIUS;\n      this.collected = false;\n    }\n\n    update(dt) {\n      this.y += this.speed * dt;\n      // bounce horizontally slightly for wacky motion (sinus)\n      this.x += Math.sin(this.y / 40) * 0.2;\n    }\n\n    draw(ctx) {\n      ctx.save();\n      // package body\n      ctx.fillStyle = this.color;\n      ctx.beginPath();\n      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);\n      ctx.fill();\n      // stripe\n      ctx.fillStyle = 'rgba(255,255,255,0.9)';\n      ctx.fillRect(this.x - this.radius * 0.7, this.y - 6, this.radius * 1.4, 12);\n      // number\n      ctx.fillStyle = '#102A43';\n      ctx.font = 'bold 20px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(String(this.value), this.x, this.y);\n      // small shadow\n      ctx.globalAlpha = 0.12;\n      ctx.fillStyle = '#000';\n      ctx.beginPath();\n      ctx.ellipse(this.x + 6, this.y + this.radius + 6, this.radius * 0.7, 8, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n    }\n\n    isOffscreen() {\n      return this.y - this.radius > HEIGHT;\n    }\n\n    collidesWithDrone(drone) {\n      const dx = this.x - drone.x;\n      const dy = this.y - drone.y;\n      // rough collision circle vs rect: check if circle center inside extended rect region\n      const closestX = Math.max(drone.x - drone.width / 2, Math.min(this.x, drone.x + drone.width / 2));\n      const closestY = Math.max(drone.y - drone.height / 2, Math.min(this.y, drone.y + drone.height / 2));\n      const distX = this.x - closestX;\n      const distY = this.y - closestY;\n      return distX * distX + distY * distY < this.radius * this.radius;\n    }\n  }\n\n  // Utility: draw text with background box using measureText\n  function drawTextBox(ctx, text, x, y, options = {}) {\n    const font = options.font || `${MIN_BODY_FONT}px sans-serif`;\n    const padding = options.padding || 8;\n    const align = options.align || 'left';\n    const baseline = options.baseline || 'top';\n    ctx.save();\n    ctx.font = font;\n    ctx.textAlign = align;\n    ctx.textBaseline = baseline;\n    // support multiline by splitting lines\n    const lines = text.split('\\n');\n    // measure widest line\n    let maxWidth = 0;\n    for (const line of lines) {\n      const m = ctx.measureText(line).width;\n      if (m > maxWidth) maxWidth = m;\n    }\n    // determine box top-left\n    let boxX = x;\n    if (align === 'center') boxX = x - maxWidth / 2 - padding;\n    else if (align === 'right') boxX = x - maxWidth - padding * 2;\n    let boxY = y;\n    if (baseline === 'middle') boxY = y - (lines.length * parseInt(font, 10)) / 2 - padding;\n    else if (baseline === 'bottom') boxY = y - lines.length * parseInt(font, 10) - padding * 2;\n    // draw background\n    ctx.fillStyle = 'rgba(255,255,255,0.85)';\n    const boxW = maxWidth + padding * 2;\n    const lineHeight = parseInt(font, 10) + 6;\n    const boxH = lines.length * lineHeight + padding * 2 - 6;\n    ctx.fillRect(boxX, boxY, boxW, boxH);\n    // border\n    ctx.strokeStyle = 'rgba(0,0,0,0.12)';\n    ctx.lineWidth = 1;\n    ctx.strokeRect(boxX, boxY, boxW, boxH);\n    // draw lines\n    ctx.fillStyle = '#102A43';\n    ctx.textAlign = align;\n    ctx.textBaseline = 'top';\n    let textX = x;\n    if (align === 'center') textX = x;\n    else if (align === 'left') textX = boxX + padding;\n    else if (align === 'right') textX = boxX + boxW - padding;\n    let textY = boxY + padding;\n    for (const line of lines) {\n      ctx.fillText(line, textX, textY);\n      textY += lineHeight;\n    }\n    ctx.restore();\n    // return box bounds for interaction if needed\n    return { x: boxX, y: boxY, w: boxW, h: boxH };\n  }\n\n  // Generate math problems (age-appropriate)\n  function generateProblem() {\n    const type = Math.random() < 0.6 ? 'add' : 'sub';\n    let a, b, answer;\n    if (type === 'add') {\n      a = Math.floor(Math.random() * 10) + 1; // 1-10\n      b = Math.floor(Math.random() * Math.min(10, 11 - a)) + 1; // keep sums <= 20\n      answer = a + b;\n    } else {\n      a = Math.floor(Math.random() * 12) + 2; // 2-13\n      b = Math.floor(Math.random() * (a - 1)) + 1; // 1 to a-1 so result positive\n      answer = a - b;\n    }\n    const text = type === 'add' ? `${a} + ${b}` : `${a} - ${b}`;\n    return { text, answer, a, b, type };\n  }\n\n  // Spawn packages for a problem: one correct and two distractors\n  function spawnPackagesForProblem(problem) {\n    packages = [];\n    const correctValue = problem.answer;\n    // choose two distractors (avoid duplicates and negative)\n    const distractors = new Set();\n    while (distractors.size < 2) {\n      let delta = Math.floor(Math.random() * 5) - 2; // -2..2\n      if (delta === 0) delta = 3; // avoid zero\n      const val = correctValue + delta;\n      if (val < 0 || val === correctValue) continue;\n      distractors.add(val);\n    }\n    const values = [correctValue, ...Array.from(distractors)];\n    // shuffle\n    for (let i = values.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [values[i], values[j]] = [values[j], values[i]];\n    }\n    // place packages near top with varied x positions\n    const xPositions = [WIDTH * 0.25, WIDTH * 0.5, WIDTH * 0.75];\n    for (let i = 0; i < values.length; i++) {\n      const x = xPositions[i] + (Math.random() * 40 - 20);\n      const y = -20 - Math.random() * 80;\n      const speed = PACKAGE_SPEED_MIN + Math.random() * (PACKAGE_SPEED_MAX - PACKAGE_SPEED_MIN) + level * 0.06;\n      const color = ['#FFD166', '#06D6A0', '#FF6B6B'][i % 3];\n      packages.push(new PackageItem(x, y, values[i], speed, color));\n    }\n  }\n\n  // Initialize a new round\n  function newRound() {\n    currentProblem = generateProblem();\n    spawnPackagesForProblem(currentProblem);\n    updateAriaMessage(`New problem: ${currentProblem.text}. Move the drone to catch the correct package.`);\n  }\n\n  // Restart game\n  function restartGame() {\n    score = 0;\n    lives = MAX_LIVES;\n    level = 1;\n    gameState = 'running';\n    drone.x = WIDTH / 2;\n    packages = [];\n    newRound();\n    tryResumeAudio();\n    startBackgroundHum();\n  }\n\n  // Handle collection result\n  function handleCollection(pkg) {\n    if (!pkg) return;\n    if (pkg.value === currentProblem.answer) {\n      score += 1;\n      playSuccessSound();\n      updateAriaMessage(`Correct! You collected ${pkg.value}. Score ${score} of ${TARGET_SCORE}.`);\n      if (score >= TARGET_SCORE) {\n        gameState = 'won';\n        stopBackgroundHum();\n      } else {\n        level = 1 + Math.floor(score / 3);\n        newRound();\n      }\n    } else {\n      lives -= 1;\n      playFailSound();\n      updateAriaMessage(`Oops! ${pkg.value} was wrong. Lives left ${lives}.`);\n      if (lives <= 0) {\n        gameState = 'lost';\n        stopBackgroundHum();\n      } else {\n        // respawn same problem so player can try again\n        spawnPackagesForProblem(currentProblem);\n      }\n    }\n  }\n\n  // Input handling\n  window.addEventListener('keydown', (e) => {\n    keys[e.key] = true;\n    if (e.key === 'r' || e.key === 'R') {\n      // restart on R\n      restartGame();\n    }\n    // pause toggling with P\n    if (e.key === 'p' || e.key === 'P') {\n      gameState = gameState === 'running' ? 'paused' : 'running';\n      if (gameState === 'running') {\n        tryResumeAudio();\n        startBackgroundHum();\n      } else {\n        stopBackgroundHum();\n      }\n    }\n    // allow audio resume with AnyKey\n    tryResumeAudio();\n  });\n\n  window.addEventListener('keyup', (e) => {\n    keys[e.key] = false;\n  });\n\n  // Mouse click for restart button or focusing canvas\n  canvas.addEventListener('click', (e) => {\n    canvas.focus();\n    tryResumeAudio();\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    if (gameState === 'won' || gameState === 'lost') {\n      // check restart button bounds\n      const btnW = 220;\n      const btnH = 50;\n      const btnX = WIDTH / 2 - btnW / 2;\n      const btnY = HEIGHT / 2 + 40;\n      if (mx >= btnX && mx <= btnX + btnW && my >= btnY && my <= btnY + btnH) {\n        restartGame();\n      }\n    }\n  });\n\n  // Main update loop\n  function update(dt) {\n    if (gameState !== 'running') return;\n    drone.update();\n    // dt in ms, convert to factor\n    const factor = dt * 0.06; // tuned factor\n    for (let i = packages.length - 1; i >= 0; i--) {\n      const pkg = packages[i];\n      pkg.update(factor);\n      if (pkg.collidesWithDrone(drone)) {\n        // handle collection\n        const collected = pkg;\n        packages.splice(i, 1);\n        handleCollection(collected);\n      } else if (pkg.isOffscreen()) {\n        // if a correct package goes offscreen, respawn packages (player missed)\n        if (pkg.value === currentProblem.answer) {\n          // miss = lose a life\n          lives -= 1;\n          playFailSound();\n          updateAriaMessage(`You missed the correct package. Lives left ${lives}.`);\n          if (lives <= 0) {\n            gameState = 'lost';\n            stopBackgroundHum();\n            return;\n          }\n          // respawn same problem\n          spawnPackagesForProblem(currentProblem);\n          return;\n        } else {\n          // remove distractor offscreen\n          packages.splice(i, 1);\n          // If all packages gone unexpectedly, spawn new set\n          if (packages.length === 0) {\n            spawnPackagesForProblem(currentProblem);\n          }\n        }\n      }\n    }\n  }\n\n  // Drawing loop\n  function draw() {\n    // Clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // Background: calming gradient with wacky cloud-ish shapes\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, '#E6F7FF');\n    g.addColorStop(1, '#F6FBFF');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Draw some wacky floating shapes (simple clouds/drones)\n    ctx.save();\n    ctx.globalAlpha = 0.9;\n    ctx.fillStyle = '#FAFFFD';\n    for (let i = 0; i < 4; i++) {\n      const cx = 80 + i * 170;\n      const cy = 50 + Math.sin((Date.now() / 1000) + i) * 6;\n      ctx.beginPath();\n      ctx.ellipse(cx, cy, 54, 20, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.beginPath();\n      ctx.ellipse(cx + 24, cy - 6, 30, 12, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.beginPath();\n      ctx.ellipse(cx - 28, cy - 4, 26, 10, 0, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    ctx.restore();\n\n    // Top UI: Score on left\n    const scoreText = `Score: ${score}/${TARGET_SCORE}`;\n    ctx.font = `bold ${BIG_FONT}px sans-serif`;\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'top';\n    const scoreBox = drawTextBox(ctx, scoreText, SCORE_X + 2, TOP_UI_Y + 2, {\n      font: `bold ${BIG_FONT}px sans-serif`,\n      padding: 8,\n      align: 'left',\n      baseline: 'top',\n    });\n\n    // Lives on right\n    const livesText = `Lives: ${lives}`;\n    ctx.font = `bold ${BIG_FONT}px sans-serif`;\n    ctx.textAlign = 'right';\n    ctx.textBaseline = 'top';\n    // measure and draw right-aligned box using helper by giving x as right edge\n    const livesBox = drawTextBox(ctx, livesText, LIVES_X - 2, TOP_UI_Y + 2, {\n      font: `bold ${BIG_FONT}px sans-serif`,\n      padding: 8,\n      align: 'right',\n      baseline: 'top',\n    });\n\n    // Problem text centered top\n    const problemText = currentProblem ? `Solve: ${currentProblem.text}` : 'Loading...';\n    ctx.font = `bold 20px sans-serif`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'top';\n    drawTextBox(ctx, problemText, WIDTH / 2, TOP_UI_Y + 2, {\n      font: `bold 20px sans-serif`,\n      padding: 8,\n      align: 'center',\n      baseline: 'top',\n    });\n\n    // Draw drone (player)\n    drone.draw(ctx);\n\n    // Draw packages\n    for (const pkg of packages) {\n      pkg.draw(ctx);\n    }\n\n    // Instructions at bottom center (ensure not overlapping)\n    const instructions = 'Use \u2190 \u2192 or A D to move the drone. Catch the correct number.\\nPress R to restart, P to pause.';\n    ctx.font = `${MIN_BODY_FONT}px sans-serif`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'top';\n    drawTextBox(ctx, instructions, WIDTH / 2, INSTRUCTIONS_Y, {\n      font: `${MIN_BODY_FONT}px sans-serif`,\n      padding: 10,\n      align: 'center',\n      baseline: 'top',\n    });\n\n    // Audio visual cue (small icon top-left of instructions)\n    ctx.save();\n    const audioLabel = audioAllowed && audioCtx ? 'Audio: On (press any key to enable)' : 'Audio: Off';\n    ctx.font = `14px sans-serif`;\n    ctx.textBaseline = 'top';\n    ctx.textAlign = 'left';\n    const audioBox = drawTextBox(ctx, audioLabel, PADDING, INSTRUCTIONS_Y - 50, {\n      font: `14px sans-serif`,\n      padding: 6,\n      align: 'left',\n      baseline: 'top',\n    });\n    ctx.restore();\n\n    // If paused overlay\n    if (gameState === 'paused') {\n      ctx.save();\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n      ctx.font = 'bold 36px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      drawTextBox(ctx, 'Paused', WIDTH / 2, HEIGHT / 2 - 40, {\n        font: 'bold 36px sans-serif',\n        padding: 12,\n        align: 'center',\n        baseline: 'middle',\n      });\n      ctx.restore();\n    }\n\n    // End screens\n    if (gameState === 'won') {\n      ctx.save();\n      ctx.fillStyle = 'rgba(255,255,255,0.95)';\n      ctx.fillRect(60, 80, WIDTH - 120, HEIGHT - 160);\n      ctx.strokeStyle = '#1B4965';\n      ctx.lineWidth = 3;\n      ctx.strokeRect(60, 80, WIDTH - 120, HEIGHT - 160);\n      ctx.font = 'bold 32px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      drawTextBox(ctx, `Victory!\\nYou helped the drone collect ${TARGET_SCORE} correct packages!`, WIDTH / 2, HEIGHT / 2 - 40, {\n        font: 'bold 28px sans-serif',\n        padding: 12,\n        align: 'center',\n        baseline: 'middle',\n      });\n      // Restart button\n      const btnW = 220;\n      const btnH = 50;\n      const btnX = WIDTH / 2 - btnW / 2;\n      const btnY = HEIGHT / 2 + 40;\n      ctx.fillStyle = '#06D6A0';\n      ctx.fillRect(btnX, btnY, btnW, btnH);\n      ctx.strokeStyle = '#054A3C';\n      ctx.strokeRect(btnX, btnY, btnW, btnH);\n      ctx.font = 'bold 20px sans-serif';\n      ctx.fillStyle = '#053A2B';\n      ctx.fillText('Play Again (Click R)', WIDTH / 2, btnY + btnH / 2);\n      ctx.restore();\n    } else if (gameState === 'lost') {\n      ctx.save();\n      ctx.fillStyle = 'rgba(255,255,255,0.95)';\n      ctx.fillRect(60, 80, WIDTH - 120, HEIGHT - 160);\n      ctx.strokeStyle = '#6B0F1A';\n      ctx.lineWidth = 3;\n      ctx.strokeRect(60, 80, WIDTH - 120, HEIGHT - 160);\n      drawTextBox(ctx, `Game Over\\nYou ran out of lives. Score: ${score}`, WIDTH / 2, HEIGHT / 2 - 30, {\n        font: 'bold 26px sans-serif',\n        padding: 12,\n        align: 'center',\n        baseline: 'middle',\n      });\n      const btnW = 220;\n      const btnH = 50;\n      const btnX = WIDTH / 2 - btnW / 2;\n      const btnY = HEIGHT / 2 + 60;\n      ctx.fillStyle = '#FF6B6B';\n      ctx.fillRect(btnX, btnY, btnW, btnH);\n      ctx.strokeStyle = '#5B1010';\n      ctx.strokeRect(btnX, btnY, btnW, btnH);\n      ctx.font = 'bold 20px sans-serif';\n      ctx.fillStyle = '#381313';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText('Try Again (Click R)', WIDTH / 2, btnY + btnH / 2);\n      ctx.restore();\n    }\n  }\n\n  function gameLoop(ts) {\n    const dt = ts - lastTime;\n    lastTime = ts;\n    update(dt);\n    draw();\n    animationFrameId = requestAnimationFrame(gameLoop);\n  }\n\n  // Start game\n  function start() {\n    tryResumeAudio();\n    startBackgroundHum();\n    restartGame();\n    lastTime = performance.now();\n    if (animationFrameId) cancelAnimationFrame(animationFrameId);\n    animationFrameId = requestAnimationFrame(gameLoop);\n  }\n\n  // Graceful cleanup on page unload\n  window.addEventListener('blur', () => {\n    // pause when tab loses focus to save CPU and audio\n    if (gameState === 'running') {\n      gameState = 'paused';\n      stopBackgroundHum();\n    }\n  });\n\n  window.addEventListener('focus', () => {\n    // resume automatically only if not ended\n    if (gameState === 'paused') {\n      gameState = 'running';\n      tryResumeAudio();\n      startBackgroundHum();\n    }\n  });\n\n  // Provide some initial instruction in console and aria\n  console.log('Drone Math Catcher loaded. Focus the canvas and use arrow keys to play. Press R to restart.');\n  updateAriaMessage('Drone Math Catcher loaded. Press arrow keys to move. Press R to restart.');\n\n  // Kick off\n  start();\n})();\n---\n",
  "improve_response_tokens": 18092,
  "formatted_code": true,
  "formatting_response_tokens": 20974,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}