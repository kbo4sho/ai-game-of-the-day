# Game of the Day - 2025-09-13

## Metadata
- **Generated Date:** 2025-09-13
- **Generated Time:** 2025-09-13T00:25:07.818115
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-13.js
- **File Size:** 29341 bytes
- **Tokens Used:** 10311

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** âœ… PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** âœ… NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
â€¢ Be beatable.
â€¢ Use visually calming and interesting and wacky elements.
â€¢ Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
â€¢ Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
â€¢ Have a game area exactly 720px wide by 480px tall.
â€¢ Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
â€¢ Use modern JavaScript practices and avoid minification.
â€¢ Include proper error handling for audio and resource loading.
â€¢ Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
â€¢ Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
â€¢ Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
â€¢ Generate all sounds using Web Audio API oscillators and filters.
â€¢ Include proper error handling for audio context creation.
â€¢ Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
â€¢ Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-13.js` - The playable game
- `2025-09-13.meta.json` - Machine-readable metadata
- `2025-09-13.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 22006

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 25303

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** âœ… PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function() {
  // Machine Math - a calming math game for ages 7-9
  // Renders inside element with id 'game-of-the-day-stage'
  // All visuals drawn on canvas. Sounds created with Web Audio API.
  // Accessible controls via keyboard and mouse. Proper error handling included.

  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const MAX_LEVEL = 5;
  const CONTAINER_ID = 'game-of-the-day-stage';

  // Grab container
  const container = document.getElementById(CONTAINER_ID);
  if (!container) {
    console.error('Game container not found:', CONTAINER_ID);
    return;
  }

  // Make container accessible
  container.setAttribute('role', 'application');
  container.setAttribute('aria-label', 'Machine Math game. Choose gears (cogs) to add up to the target number. Use mouse or keyboard. Press space or click to start audio.');
  container.style.position = container.style.position || 'relative';
  container.style.outline = 'none';
  container.tabIndex = 0; // enable keyboard focus

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.width = WIDTH + 'px';
  canvas.style.height = HEIGHT + 'px';
  canvas.setAttribute('role', 'img');
  canvas.setAttribute('aria-label', 'Game area: a colorful machine and moving gears.');
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Create an offscreen live region for screen readers
  const live = document.createElement('div');
  live.setAttribute('aria-live', 'polite');
  live.style.position = 'absolute';
  live.style.left = '-9999px';
  live.style.width = '1px';
  live.style.height = '1px';
  live.style.overflow = 'hidden';
  container.appendChild(live);

  // DPR scaling for crisp canvas
  const DPR = window.devicePixelRatio || 1;
  canvas.width = Math.round(WIDTH * DPR);
  canvas.height = Math.round(HEIGHT * DPR);
  ctx.scale(DPR, DPR);

  // Audio setup with error handling
  let audioCtx = null;
  let audioEnabled = false;
  let ambientNodes = null;
  try {
    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
    if (AudioContextClass) {
      audioCtx = new AudioContextClass();
      // Do not mark audioEnabled true until user gesture resume
      audioEnabled = false;
    } else {
      console.warn('Web Audio API not available.');
      audioCtx = null;
      audioEnabled = false;
    }
  } catch (e) {
    console.error('AudioContext creation failed:', e);
    audioCtx = null;
    audioEnabled = false;
  }

  // Utility: safe connect
  function safeConnect(nodeA, nodeB) {
    try {
      if (nodeA && nodeB && typeof nodeA.connect === 'function') nodeA.connect(nodeB);
    } catch (e) {
      console.error('Audio connect error', e);
    }
  }

  // Play a short click (interaction)
  function playClick() {
    if (!audioEnabled || !audioCtx) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'square';
      o.frequency.value = 700;
      g.gain.value = 0.0001;
      safeConnect(o, g);
      safeConnect(g, audioCtx.destination);
      const now = audioCtx.currentTime;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.06, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);
      o.start(now);
      o.stop(now + 0.2);
    } catch (e) {
      console.error('playClick error', e);
    }
  }

  // Play correct chime (melody)
  function playCorrect() {
    if (!audioEnabled || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const freqs = [880, 1100, 1320];
      let offset = 0;
      freqs.forEach((f) => {
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'sine';
        o.frequency.value = f;
        g.gain.value = 0.0001;
        safeConnect(o, g);
        safeConnect(g, audioCtx.destination);
        g.gain.setValueAtTime(0.0001, now + offset);
        g.gain.exponentialRampToValueAtTime(0.04, now + offset + 0.03);
        g.gain.exponentialRampToValueAtTime(0.0001, now + offset + 0.2);
        o.start(now + offset);
        o.stop(now + offset + 0.24);
        offset += 0.12;
      });
    } catch (e) {
      console.error('playCorrect error', e);
    }
  }

  // Play wrong buzzer
  function playWrong() {
    if (!audioEnabled || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const f = audioCtx.createBiquadFilter();
      const g = audioCtx.createGain();
      o.type = 'square';
      o.frequency.value = 250;
      f.type = 'lowpass';
      f.frequency.value = 600;
      g.gain.value = 0.0001;
      safeConnect(o, f);
      safeConnect(f, g);
      safeConnect(g, audioCtx.destination);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.06, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);
      o.start(now);
      o.frequency.exponentialRampToValueAtTime(60, now + 0.35);
      o.stop(now + 0.36);
    } catch (e) {
      console.error('playWrong error', e);
    }
  }

  // Start ambient background sound (gentle)
  function startAmbient() {
    if (!audioCtx || !audioEnabled) return;
    stopAmbient();
    try {
      const master = audioCtx.createGain();
      master.gain.value = 0.02; // gentle
      safeConnect(master, audioCtx.destination);

      // Two slow oscillators with slight detune
      const o1 = audioCtx.createOscillator();
      o1.type = 'sine';
      o1.frequency.value = 110;
      const o2 = audioCtx.createOscillator();
      o2.type = 'sine';
      o2.frequency.value = 147;

      const g1 = audioCtx.createGain();
      const g2 = audioCtx.createGain();
      g1.gain.value = 0.5;
      g2.gain.value = 0.45;

      const filt = audioCtx.createBiquadFilter();
      filt.type = 'lowpass';
      filt.frequency.value = 600;

      safeConnect(o1, g1);
      safeConnect(o2, g2);
      safeConnect(g1, filt);
      safeConnect(g2, filt);
      safeConnect(filt, master);

      o1.start();
      o2.start();

      // Slow LFO on master gain
      const lfo = audioCtx.createOscillator();
      lfo.type = 'sine';
      lfo.frequency.value = 0.08;
      const lfoGain = audioCtx.createGain();
      lfoGain.gain.value = 0.01;
      safeConnect(lfo, lfoGain);
      safeConnect(lfoGain, master.gain);
      lfo.start();

      ambientNodes = { o1, o2, g1, g2, filt, lfo, lfoGain, master };
    } catch (e) {
      console.error('startAmbient error', e);
    }
  }

  function stopAmbient() {
    if (!ambientNodes) return;
    try {
      ['o1', 'o2', 'lfo'].forEach(k => {
        if (ambientNodes[k] && ambientNodes[k].stop) {
          try { ambientNodes[k].stop(); } catch (e) {}
        }
      });
    } catch (e) {
      console.error('stopAmbient error', e);
    } finally {
      ambientNodes = null;
    }
  }

  // Fade audio context on user gesture
  function enableAudioOnGesture() {
    if (!audioCtx) return;
    if (audioCtx.state === 'suspended') {
      audioCtx.resume().then(() => {
        audioEnabled = true;
        startAmbient();
        liveUpdate('Audio enabled. Gentle background sounds started.');
      }).catch((e) => {
        console.warn('Audio resume failed:', e);
        audioEnabled = false;
        liveUpdate('Audio could not be started. You can still play without sound.');
      });
    } else {
      audioEnabled = true;
      startAmbient();
      liveUpdate('Audio started.');
    }
  }

  // Live region update helper
  function liveUpdate(msg) {
    live.textContent = msg;
  }

  // Game state
  let level = 1;
  let score = 0;
  let state = 'start'; // start, playing, levelComplete, won
  let waitingForStart = true; // require initial user gesture for audio
  let cogs = []; // moving cogs on conveyor
  let placedCogs = []; // cogs placed in machine
  let selectedCog = null; // reference to cog object when grabbed
  let hoverCog = null;
  let conveyorY = 120;
  let machineX = 460;
  let machineY = 140;
  let target = 0;

  // Cog class/object factory
  function createCog(value, x, y, radius = 30) {
    return {
      id: Math.random().toString(36).slice(2, 9),
      value,
      x,
      y,
      radius,
      baseX: x,
      baseY: y,
      speed: 0.4 + Math.random() * 0.8,
      dir: Math.random() > 0.5 ? 1 : -1,
      rotation: Math.random() * Math.PI * 2,
      grabbed: false,
      placed: false,
      wobble: Math.random() * 0.5,
    };
  }

  // Level generation ensuring at least one subset equals target
  function generateLevel(lv) {
    cogs = [];
    placedCogs = [];
    selectedCog = null;
    hoverCog = null;

    // Choose subset count (2 or 3)
    const subsetCount = Math.random() > 0.5 ? 2 : 3;
    const subset = [];
    // Build a subset with values between 1 and 9
    let running = 0;
    for (let i = 0; i < subsetCount; i++) {
      const maxVal = Math.max(1, 6 - subsetCount + lv); // bias to slightly larger numbers as levels increase
      let val = 1 + Math.floor(Math.random() * Math.min(9, maxVal + 3));
      // ensure not too many smalls
      if (i === subsetCount - 1 && running + val < 4) val = 4;
      subset.push(val);
      running += val;
    }
    target = running; // target is sum of subset, ensures solvable

    // Place these subset cogs plus extras
    const totalCogs = 5; // number of items on conveyor
    const extrasCount = totalCogs - subset.length;
    const extras = [];
    for (let i = 0; i < extrasCount; i++) {
      // random extras that don't accidentally make alternate subset trivial but may mislead
      let val = 1 + Math.floor(Math.random() * 9);
      // avoid adding same combination that makes additional trivial solutions by chance: it's okay if duplicates exist
      extras.push(val);
    }

    const allValues = shuffleArray([...subset, ...extras]);

    // Place them along conveyor area horizontally
    const startX = 80;
    const spacing = 110;
    for (let i = 0; i < allValues.length; i++) {
      const x = startX + i * spacing;
      const y = conveyorY;
      cogs.push(createCog(allValues[i], x, y));
    }

    state = 'playing';
    waitingForStart = false;
    liveUpdate(`Level ${lv}. Target ${target}. Pick cogs that add to ${target}.`);
  }

  // Utility shuffle
  function shuffleArray(arr) {
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  // Collision detection for cog-point
  function pointInCog(px, py, cog) {
    const dx = px - cog.x;
    const dy = py - cog.y;
    return dx * dx + dy * dy <= cog.radius * cog.radius;
  }

  // Main draw loop
  function draw() {
    // Clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Soft background
    drawBackground();

    // Draw machine area
    drawMachine();

    // Draw conveyor and cogs
    drawConveyor();

    // HUD: level, target, instructions, audio icon
    drawHUD();

    // Overlay messages depending on state
    if (state === 'start') {
      drawStartOverlay();
    } else if (state === 'levelComplete') {
      drawLevelCompleteOverlay();
    } else if (state === 'won') {
      drawWonOverlay();
    }

    // Accessibility focus highlight
    if (selectedCog && selectedCog.grabbed) {
      // a subtle halo is drawn on selected cog already
    }
  }

  function drawBackground() {
    // calming gradient with wacky floating shapes
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#e8f4ff');
    g.addColorStop(1, '#f7fbf2');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // soft wacky clouds (circles)
    for (let i = 0; i < 5; i++) {
      const cx = 40 + (i * 160 + (Date.now() / 300) % 120);
      const cy = 40 + (i % 2 === 0 ? 10 : -10);
      ctx.globalAlpha = 0.06 + (i % 2) * 0.02;
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.ellipse(cx % WIDTH, cy + 20 * Math.sin(Date.now() / 3000 + i), 80, 32, 0, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  function drawConveyor() {
    // conveyor belt
    ctx.fillStyle = '#dcdcdc';
    roundRect(ctx, 40, conveyorY - 40, 380, 120, 16);
    ctx.fill();

    // little moving stripes for conveyor motion
    const stripeW = 40;
    const offset = (Date.now() / 60) % stripeW;
    ctx.fillStyle = '#c0c0c0';
    for (let x = 40 - offset; x < 420; x += stripeW * 2) {
      ctx.fillRect(x, conveyorY - 28, stripeW, 80);
    }

    // draw cogs
    cogs.forEach((cog) => {
      // animate movement for unreleased cogs along small horizontal swing
      if (!cog.grabbed && !cog.placed) {
        const sway = Math.sin((Date.now() / 1000) * cog.speed * cog.dir + cog.wobble) * 6;
        cog.x = cog.baseX + sway;
        cog.rotation += 0.01 * cog.dir * cog.speed;
      } else if (cog.placed) {
        // placed cogs have a tiny bounce
        cog.rotation += 0.02;
      } else if (cog.grabbed) {
        cog.rotation += 0.08;
      }

      drawCog(cog, cog === selectedCog ? '#ffedcc' : (cog === hoverCog ? '#edffec' : '#ffffff'));
    });
  }

  function drawMachine() {
    // machine body
    ctx.save();
    ctx.translate(machineX, machineY);

    // playful machine base
    ctx.fillStyle = '#cfe7ff';
    roundRect(ctx, 0, 0, 240, 260, 18);
    ctx.fill();

    // control panel
    ctx.fillStyle = '#ffffff';
    roundRect(ctx, 20, 20, 200, 90, 10);
    ctx.fill();

    // display target
    ctx.fillStyle = '#07263d';
    ctx.font = '28px Arial';
    ctx.fillText('Target', 32, 50);
    ctx.font = '44px Arial';
    ctx.fillStyle = '#d1495b';
    ctx.fillText(String(target), 32, 88);

    // slots area
    ctx.fillStyle = '#f2f6f9';
    roundRect(ctx, 20, 130, 200, 90, 8);
    ctx.fill();

    // draw placed cogs in slots (arranged)
    const slotCount = 5;
    const slotSpacing = 36;
    const startX = 30;
    const startY = 152;
    placedCogs.forEach((cog, idx) => {
      const px = startX + (idx % slotCount) * slotSpacing;
      const py = startY + Math.floor(idx / slotCount) * 32;
      // draw small cog circle with number
      drawMiniCog(px, py, 14, cog.value);
    });

    // machine mouth/slot where you drop cogs
    ctx.fillStyle = '#03263d';
    roundRect(ctx, 170, 86, 40, 120, 6);
    ctx.fill();

    ctx.restore();

    // decorative arms and gears
    ctx.save();
    ctx.translate(machineX - 30, machineY + 60);
    ctx.fillStyle = '#ffd179';
    ctx.beginPath();
    ctx.ellipse(0, 0, 30, 12, Math.sin(Date.now() / 800) * 0.1, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // draw small indicator showing sum so far
    const sumSoFar = placedCogs.reduce((s, c) => s + c.value, 0);
    ctx.fillStyle = '#07263d';
    ctx.font = '20px Arial';
    ctx.fillText(`Sum: ${sumSoFar}`, machineX + 28, machineY + 240);
  }

  function drawMiniCog(x, y, r, val) {
    ctx.save();
    ctx.translate(x, y);
    // teeth
    ctx.fillStyle = '#f9f9f9';
    for (let t = 0; t < 8; t++) {
      ctx.beginPath();
      const a = (t / 8) * Math.PI * 2;
      const tx = Math.cos(a) * (r + 6);
      const ty = Math.sin(a) * (r + 6);
      ctx.rect(tx - 3, ty - 2, 6, 4);
      ctx.fill();
    }
    // body
    ctx.fillStyle = '#ffd379';
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fill();

    // center
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(0, 0, r / 2, 0, Math.PI * 2);
    ctx.fill();

    // number
    ctx.fillStyle = '#052233';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(String(val), 0, 0);
    ctx.restore();
  }

  function drawCog(cog, fillColor = '#fff') {
    ctx.save();
    ctx.translate(cog.x, cog.y);
    ctx.rotate(cog.rotation);
    // teeth
    const teeth = 12;
    for (let i = 0; i < teeth; i++) {
      const a = (i / teeth) * Math.PI * 2;
      const tx = Math.cos(a) * (cog.radius + 8);
      const ty = Math.sin(a) * (cog.radius + 8);
      ctx.fillStyle = '#f2f2f2';
      ctx.beginPath();
      ctx.ellipse(tx, ty, 6, 10, a, 0, Math.PI * 2);
      ctx.fill();
    }
    // main body
    ctx.fillStyle = fillColor;
    ctx.beginPath();
    ctx.arc(0, 0, cog.radius, 0, Math.PI * 2);
    ctx.fill();
    // inner circle
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(0, 0, cog.radius * 0.6, 0, Math.PI * 2);
    ctx.fill();
    // number
    ctx.fillStyle = '#052233';
    ctx.font = `${cog.radius * 0.7}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(String(cog.value), 0, 0);
    // highlight if selected
    if (cog.grabbed) {
      ctx.strokeStyle = '#ff7b7b';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(0, 0, cog.radius + 6, 0, Math.PI * 2);
      ctx.stroke();
    } else if (cog === hoverCog) {
      ctx.strokeStyle = '#7bffbd';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(0, 0, cog.radius + 6, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawHUD() {
    // Level indicator
    ctx.fillStyle = '#07263d';
    ctx.font = '18px Arial';
    ctx.fillText(`Level ${level}`, 16, 24);

    // Score
    ctx.fillStyle = '#07263d';
    ctx.font = '18px Arial';
    ctx.fillText(`Score ${score}`, WIDTH - 120, 24);

    // Instructions compact
    ctx.fillStyle = '#07263d';
    ctx.font = '14px Arial';
    ctx.fillText('Pick cogs and drop into machine to match the target number.', 16, HEIGHT - 30);
    ctx.fillText('Keyboard: Tab/Left-Right to select, Space/Enter to grab/drop. Number keys to pick cogs.', 16, HEIGHT - 12);

    // Audio icon
    drawAudioIcon(WIDTH - 40, 36, audioEnabled);
  }

  function drawAudioIcon(x, y, on) {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = on ? '#9fe6a9' : '#ffd1d1';
    ctx.beginPath();
    ctx.arc(0, 0, 14, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#07263d';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(on ? 'ðŸ”Š' : 'ðŸ”ˆ', 0, 0);
    ctx.restore();
  }

  function drawStartOverlay() {
    ctx.fillStyle = 'rgba(4, 28, 52, 0.5)';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    ctx.fillStyle = '#fff';
    ctx.font = '26px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Machine Math', WIDTH / 2, 140);
    ctx.font = '18px Arial';
    ctx.fillText('Assemble cogs to match the target number.', WIDTH / 2, 180);
    ctx.fillText('Click or press Space to start. Use mouse or keyboard.', WIDTH / 2, 210);

    // friendly machine drawing
    ctx.save();
    ctx.translate(WIDTH / 2 - 80, 250);
    roundRect(ctx, 0, 0, 160, 140, 14);
    ctx.fillStyle = '#f7f2e8';
    ctx.fill();
    ctx.fillStyle = '#07263d';
    ctx.font = '20px Arial';
    ctx.fillText('Click to Start', 80, 80);
    ctx.restore();
  }

  function drawLevelCompleteOverlay() {
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.fillRect(160, 100, 400, 280);
    ctx.strokeStyle = '#07263d';
    ctx.strokeRect(160, 100, 400, 280);
    ctx.fillStyle = '#07263d';
    ctx.font = '22px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`Nice! Level ${level} complete`, WIDTH / 2, 170);
    ctx.font = '18px Arial';
    ctx.fillText('Press Space or Click to continue.', WIDTH / 2, 210);
  }

  function drawWonOverlay() {
    ctx.fillStyle = 'rgba(6, 60, 20, 0.85)';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    ctx.fillStyle = '#e6ffe9';
    ctx.font = '30px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('All Machines Fixed!', WIDTH / 2, 220);
    ctx.font = '18px Arial';
    ctx.fillText('Great work â€” you solved all the machine puzzles!', WIDTH / 2, 260);
    ctx.fillText('Refresh to play again.', WIDTH / 2, 290);
  }

  // Utility rounded rect
  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  // Interaction handling
  let mouse = { x: 0, y: 0, down: false };

  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - rect.left);
    mouse.y = (e.clientY - rect.top);
    // hover detection
    if (!selectedCog) {
      hoverCog = null;
      for (let i = 0; i < cogs.length; i++) {
        const cog = cogs[i];
        if (!cog.placed && pointInCog(mouse.x, mouse.y, cog)) {
          hoverCog = cog;
          break;
        }
      }
    } else if (selectedCog && selectedCog.grabbed) {
      // move selected to mouse
      selectedCog.x = mouse.x;
      selectedCog.y = mouse.y;
    }
  });

  canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - rect.left);
    mouse.y = (e.clientY - rect.top);
    mouse.down = true;

    // If start overlay present, clicking starts game
    if (state === 'start' || waitingForStart) {
      // enable audio on click gesture
      enableAudioOnGesture();
      waitingForStart = false;
      if (state === 'start') {
        generateLevel(level);
        playClick();
        return;
      }
    }

    // If in levelComplete or won, clicking continues
    if (state === 'levelComplete') {
      playClick();
      nextLevel();
      return;
    } else if (state === 'won') {
      // Reset game
      resetGame();
      playClick();
      return;
    }

    // pick a cog if clicked on one
    for (let i = cogs.length - 1; i >= 0; i--) {
      const cog = cogs[i];
      if (!cog.placed && pointInCog(mouse.x, mouse.y, cog)) {
        selectCog(cog);
        return;
      }
    }
  });

  canvas.addEventListener('mouseup', (e) => {
    mouse.down = false;
    if (selectedCog && selectedCog.grabbed) {
      // drop cog and check if over machine slot
      const inMachine = isOverMachineSlot(selectedCog.x, selectedCog.y);
      if (inMachine) {
        placeCog(selectedCog);
      } else {
        // return to base position (smoothly)
        playClick();
        selectedCog.grabbed = false;
        selectedCog = null;
      }
    }
  });

  // Keyboard controls
  container.addEventListener('keydown', (e) => {
    // Allow start on keyboard as well
    if (waitingForStart && (e.key === ' ' || e.key === 'Enter')) {
      enableAudioOnGesture();
      waitingForStart = false;
      if (state === 'start') {
        generateLevel(level);
        playClick();
      }
      e.preventDefault();
      return;
    }
    if (state === 'start') return;

    if (state === 'levelComplete' && (e.key === ' ' || e.key === 'Enter')) {
      nextLevel();
      e.preventDefault();
      return;
    } else if (state === 'won' && (e.key === ' ' || e.key === 'Enter')) {
      resetGame();
      e.preventDefault();
      return;
    }

    // Navigation among cogs
    const availableCogs = cogs.filter(c => !c.placed);
    if (e.key === 'ArrowRight' || e.key === 'Tab') {
      // cycle to next
      if (availableCogs.length) {
        let idx = availableCogs.indexOf(selectedCog);
        idx = idx === -1 ? 0 : (idx + 1) % availableCogs.length;
        selectCog(availableCogs[idx]);
      }
      e.preventDefault();
      return;
    } else if (e.key === 'ArrowLeft') {
      if (availableCogs.length) {
        let idx = availableCogs.indexOf(selectedCog);
        idx = idx === -1 ? availableCogs.length - 1 : (idx - 1 + availableCogs.length) % availableCogs.length;
        selectCog(availableCogs[idx]);
      }
      e.preventDefault();
      return;
    } else if (e.key === ' ' || e.key === 'Enter') {
      // toggle grab/drop
      if (!selectedCog && availableCogs.length) {
        selectCog(availableCogs[0]);
      } else if (selectedCog && !selectedCog.grabbed) {
        // grab
        grabSelected();
      } else if (selectedCog && selectedCog.grabbed) {
        // attempt drop at machine position (keyboard drops into machine)
        const dropX = machineX + 190; // into slot
        const dropY = machineY + 150;
        selectedCog.x = dropX;
        selectedCog.y = dropY;
        placeCog(selectedCog);
      }
      playClick();
      e.preventDefault();
      return;
    } else if (/^[1-9]$/.test(e.key)) {
      // pick cog by number key index (1-based)
      const idx = parseInt(e.key, 10) - 1;
      const av = availableCogs;
      if (idx >= 0 && idx < av.length) {
        selectCog(av[idx]);
      }
      e.preventDefault();
      return;
    } else if (e.key === 'm' || e.key === 'M') {
      // toggle audio
      if (audioCtx) {
        if (audioEnabled) {
          stopAmbient();
          audioEnabled = false;
          liveUpdate('Audio muted.');
        } else {
          enableAudioOnGesture();
        }
      } else {
        liveUpdate('Audio not available on this device.');
      }
    }
  });

  function selectCog(cog) {
    // Deselect previous
    if (selectedCog && selectedCog !== cog) {
      selectedCog.grabbed = false;
    }
    selectedCog = cog;
    // Bring selected to front by moving to end of array
    const idx = cogs.indexOf(cog);
    if (idx >= 0) {
      cogs.splice(idx, 1);
      cogs.push(cog);
    }
    // small visual highlight
    liveUpdate(`Selected cog ${cog.value}. Press Space to grab or drag to machine.`);
  }

  function grabSelected() {
    if (!selectedCog) return;
    selectedCog.grabbed = true;
  }

  function isOverMachineSlot(x, y) {
    // machine region rectangle roughly
    return x >= machineX + 20 && x <= machineX + 220 && y >= machineY + 130 && y <= machineY + 220;
  }

  function placeCog(cog) {
    cog.grabbed = false;
    cog.placed = true;
    // snap to placed array
    placedCogs.push(cog);
    selectedCog = null;
    playClick();
    // Check the sum
    const sum = placedCogs.reduce((s, c) => s + c.value, 0);
    if (sum === target) {
      // success
      playCorrect();
      score += 10 * level;
      state = 'levelComplete';
      liveUpdate(`Perfect! You matched ${target}. Level complete.`);
    } else if (sum > target) {
      // over target
      playWrong();
      liveUpdate(`Oh no! Sum ${sum} is more than ${target}. Remove a cog and try again.`);
      // We allow correction: remove last placed cog automatically with gentle rejection animation
      setTimeout(() => {
        // reject last placed
        const rejected = placedCogs.pop();
        if (rejected) {
          rejected.placed = false;
          // send it back to base position
          rejected.x = rejected.baseX;
          rejected.y = rejected.baseY;
        }
      }, 600);
    } else {
      // under target - encourage
      playClick();
      liveUpdate(`Good. Current sum ${sum}. Keep going to reach ${target}.`);
    }
  }

  function nextLevel() {
    if (level >= MAX_LEVEL) {
      state = 'won';
      liveUpdate('You have fixed all the machines. Fantastic!');
      stopAmbient();
      return;
    }
    level++;
    generateLevel(level);
  }

  function resetGame() {
    level = 1;
    score = 0;
    state = 'start';
    waitingForStart = true;
    cogs = [];
    placedCogs = [];
    selectedCog = null;
    hoverCog = null;
    liveUpdate('Game reset. Press Space or click to begin.');
    // ambient may continue if audio enabled
    startAmbient();
  }

  // Animation loop
  function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
  }

  function update() {
    // Hover detection subtle
    if (!selectedCog) {
      hoverCog = null;
      for (let i = 0; i < cogs.length; i++) {
        const cog = cogs[i];
        if (!cog.placed && pointInCog(mouse.x, mouse.y, cog)) {
          hoverCog = cog;
          break;
        }
      }
    }

    // idle floating for placed cogs
    placedCogs.forEach((c, i) => {
      c.y = machineY + 152 + Math.floor(i / 5) * 32;
      c.x = machineX + 30 + (i % 5) * 36;
      c.rotation += 0.01;
    });
  }

  // Start the loop
  draw();
  loop();

  // Expose a helpful message for initial state
  liveUpdate('Welcome to Machine Math. Press Space or click to start. Press M to toggle audio. Use keyboard or mouse.');

  // Ensure user sees instructions if audio fails
  if (!audioCtx) {
    liveUpdate('Audio not available. You can still play the game without sound.');
  }

  // Cleanup on unload: stop audio nodes
  window.addEventListener('unload', () => {
    try {
      stopAmbient();
      if (audioCtx && typeof audioCtx.close === 'function') audioCtx.close();
    } catch (e) { /* ignore */ }
  });

  // Handle visibility changes for audio
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      // reduce ambient
      if (ambientNodes && ambientNodes.master) ambientNodes.master.gain.setValueAtTime(0.001, audioCtx.currentTime);
    } else {
      if (ambientNodes && ambientNodes.master) ambientNodes.master.gain.setValueAtTime(0.02, audioCtx.currentTime);
    }
  });

  // Provide some friendly error handling for resource failures (none to load) but catching unexpected exceptions
  window.addEventListener('error', (ev) => {
    console.error('Unexpected error in Machine Math', ev.error || ev.message || ev);
    liveUpdate('An unexpected error occurred. Try refreshing the page.');
  });

})();
---

