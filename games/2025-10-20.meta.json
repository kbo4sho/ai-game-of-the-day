{
  "generated_date": "2025-10-20",
  "generated_timestamp": "2025-10-20T00:30:14.378648",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 10258,
  "game_filename": "2025-10-20.js",
  "game_size_bytes": 30241,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Drone Math Catcher\n  // Created for ages 7-9. Renders inside element with ID 'game-of-the-day-stage'.\n  // Game rules:\n  // - Answer 10 questions correctly to WIN.\n  // - 3 wrong answers = GAME OVER.\n  // - Move the drone with arrow keys or WASD or mouse.\n  // - Catch the correct answer bubble.\n  // - Press M to mute/unmute audio. Press Enter to restart on end screens.\n  // - Click the restart button on end screens to play again.\n\n  // -------------------------\n  // Basic setup and constants\n  // -------------------------\n  const STAGE_ID = \"game-of-the-day-stage\";\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const TARGET_CORRECT = 10;\n  const MAX_WRONG = 3;\n  const PADDING = 10; // UI padding minimum\n  const MIN_BODY_FONT = 14;\n  const IMPORTANT_FONT = 20; // >=18\n  const BG_COLOR = \"#E8F6FF\";\n\n  // Get container\n  const container = document.getElementById(STAGE_ID);\n  if (!container) {\n    console.error(`Container element with id \"${STAGE_ID}\" not found.`);\n    return;\n  }\n  container.style.position = \"relative\";\n\n  // Create canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.display = \"block\";\n  canvas.style.background = BG_COLOR;\n  container.appendChild(canvas);\n  const ctx = canvas.getContext(\"2d\");\n\n  // Accessibility: describe the canvas to screen readers\n  canvas.setAttribute(\n    \"role\",\n    \"application\"\n  );\n  canvas.setAttribute(\n    \"aria-label\",\n    \"Drone math catcher game. Move the drone to catch the bubble with the correct answer. Use arrow keys or WASD. Press M to mute sound.\"\n  );\n\n  // -------------------------\n  // Audio setup\n  // -------------------------\n  let audioCtx = null;\n  let masterGain = null;\n  let backgroundOsc = null;\n  let audioEnabled = true; // toggle with M\n  let audioInitAttempted = false;\n\n  function initAudio() {\n    if (audioCtx || audioInitAttempted) return;\n    audioInitAttempted = true;\n    try {\n      const AC = window.AudioContext || window.webkitAudioContext;\n      if (!AC) throw new Error(\"Web Audio API not supported\");\n      audioCtx = new AC();\n      masterGain = audioCtx.createGain();\n      masterGain.gain.value = 0.25;\n      masterGain.connect(audioCtx.destination);\n\n      // Gentle background hum using low-frequency oscillator and slight filter\n      backgroundOsc = audioCtx.createOscillator();\n      backgroundOsc.type = \"sine\";\n      backgroundOsc.frequency.value = 110;\n      const bgGain = audioCtx.createGain();\n      bgGain.gain.value = 0.02;\n      const bgFilter = audioCtx.createBiquadFilter();\n      bgFilter.type = \"lowpass\";\n      bgFilter.frequency.value = 300;\n      backgroundOsc.connect(bgFilter);\n      bgFilter.connect(bgGain);\n      bgGain.connect(masterGain);\n      backgroundOsc.start();\n\n      if (!audioEnabled) masterGain.gain.value = 0;\n    } catch (e) {\n      console.warn(\"Audio initialization failed:\", e);\n      audioCtx = null;\n      audioInitAttempted = true;\n      audioEnabled = false;\n    }\n  }\n\n  // Ensure audio context is resumed after user gesture\n  function resumeAudioIfRequired() {\n    if (!audioCtx) return;\n    if (typeof audioCtx.resume === \"function\") {\n      audioCtx.resume().catch((e) => {\n        console.warn(\"Audio resume failed:\", e);\n      });\n    }\n  }\n\n  // Play a short tone sequence for correct answer\n  function playCorrectSound() {\n    if (!audioCtx || !audioEnabled) return;\n    try {\n      const now = audioCtx.currentTime;\n      const g = audioCtx.createGain();\n      g.gain.value = 0;\n      g.connect(masterGain);\n\n      const o1 = audioCtx.createOscillator();\n      o1.type = \"sine\";\n      o1.frequency.value = 660;\n      o1.connect(g);\n\n      const o2 = audioCtx.createOscillator();\n      o2.type = \"triangle\";\n      o2.frequency.value = 880;\n      o2.connect(g);\n\n      g.gain.setValueAtTime(0, now);\n      g.gain.linearRampToValueAtTime(0.15, now + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);\n\n      o1.start(now);\n      o2.start(now + 0.03);\n      o1.stop(now + 0.35);\n      o2.stop(now + 0.35);\n    } catch (e) {\n      console.warn(\"playCorrectSound error:\", e);\n    }\n  }\n\n  // Play buzz for incorrect\n  function playIncorrectSound() {\n    if (!audioCtx || !audioEnabled) return;\n    try {\n      const now = audioCtx.currentTime;\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = \"square\";\n      o.frequency.value = 120;\n      o.connect(g);\n      g.connect(masterGain);\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(0.08, now + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.3);\n      o.start(now);\n      o.stop(now + 0.32);\n    } catch (e) {\n      console.warn(\"playIncorrectSound error:\", e);\n    }\n  }\n\n  // Visual audio indicator: will draw in UI (muted or not)\n  function toggleAudio() {\n    audioEnabled = !audioEnabled;\n    if (!audioEnabled) {\n      if (masterGain) masterGain.gain.value = 0;\n    } else {\n      if (!audioCtx) initAudio();\n      if (masterGain) masterGain.gain.value = 0.25;\n      resumeAudioIfRequired();\n    }\n  }\n\n  // -------------------------\n  // Game state\n  // -------------------------\n  const state = {\n    mode: \"loading\", // 'playing', 'win', 'gameover'\n    drone: {\n      x: WIDTH / 2,\n      y: HEIGHT - 120,\n      vx: 0,\n      vy: 0,\n      speed: 180, // px/s\n      radius: 26,\n    },\n    keys: {\n      left: false,\n      right: false,\n      up: false,\n      down: false,\n    },\n    mouse: {\n      x: null,\n      y: null,\n      active: false,\n    },\n    question: null,\n    bubbles: [], // {x,y,vy,value,isCorrect,id}\n    correctCount: 0,\n    wrongCount: 0,\n    lastSpawn: 0,\n    spawnInterval: 1200, // ms\n    lastTime: performance.now(),\n    feedbackFlash: { color: null, t: 0 }, // for visual feedback\n    rngCounter: 0,\n  };\n\n  // -------------------------\n  // Utility helpers\n  // -------------------------\n  function randomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  function nowMs() {\n    return performance.now();\n  }\n\n  function measureTextRect(text, font) {\n    ctx.font = font;\n    const metrics = ctx.measureText(text);\n    const w = Math.ceil(metrics.width);\n    // approximate height\n    const h = Math.ceil(parseInt(font, 10) || 16);\n    return { w, h };\n  }\n\n  // -------------------------\n  // Math question generator\n  // -------------------------\n  function generateQuestion() {\n    // Randomly choose operation: +, -, \u00d7 with weights favoring addition/subtraction\n    const ops = [\"+\", \"+\", \"+\", \"-\", \"-\", \"\u00d7\"];\n    const op = ops[randomInt(0, ops.length - 1)];\n    let a, b, answer;\n    if (op === \"+\") {\n      a = randomInt(1, 20);\n      b = randomInt(1, 20);\n      answer = a + b;\n    } else if (op === \"-\") {\n      a = randomInt(1, 20);\n      b = randomInt(1, Math.min(19, a)); // ensure non-negative\n      answer = a - b;\n    } else {\n      a = randomInt(2, 6);\n      b = randomInt(2, 6);\n      answer = a * b;\n    }\n    const qText = `${a} ${op} ${b} = ?`;\n    // Generate choices including correct answer\n    const choices = new Set();\n    choices.add(answer);\n    while (choices.size < 4) {\n      // generate plausible distractors\n      const delta = randomInt(1, Math.max(3, Math.floor(Math.abs(answer / 5) + 3)));\n      const sign = Math.random() < 0.5 ? -1 : 1;\n      let cand = answer + sign * delta;\n      if (cand < 0) cand = Math.abs(cand) + 1;\n      choices.add(cand);\n    }\n    const arr = Array.from(choices);\n    // shuffle\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    return { qText, answer, choices: arr };\n  }\n\n  // -------------------------\n  // Bubbles spawn management\n  // -------------------------\n  function spawnBubblesForQuestion(question) {\n    const bubbles = [];\n    const marginLeft = 60;\n    const marginRight = WIDTH - 60;\n    const total = question.choices.length;\n    const spacing = (marginRight - marginLeft) / (total - 1 || 1);\n    for (let i = 0; i < total; i++) {\n      const x = marginLeft + spacing * i + randomInt(-20, 20);\n      const y = randomInt(120, 220) + randomInt(-40, 40);\n      const vy = randomInt(10, 35) / 50; // slow vertical drift\n      const val = question.choices[i];\n      const isCorrect = val === question.answer;\n      bubbles.push({\n        id: `${Date.now()}-${i}-${state.rngCounter++}`,\n        x,\n        y,\n        vy,\n        value: val,\n        isCorrect,\n        r: 30 + Math.floor(Math.random() * 6),\n      });\n    }\n    state.bubbles = bubbles;\n  }\n\n  // -------------------------\n  // Game control functions\n  // -------------------------\n  function startNewGame() {\n    // initialize game variables\n    state.mode = \"playing\";\n    state.drone.x = WIDTH / 2;\n    state.drone.y = HEIGHT - 120;\n    state.drone.vx = 0;\n    state.drone.vy = 0;\n    state.correctCount = 0;\n    state.wrongCount = 0;\n    state.feedbackFlash.t = 0;\n    state.lastSpawn = nowMs();\n    state.spawnInterval = 1200;\n    state.bubbles = [];\n    state.question = generateQuestion();\n    spawnBubblesForQuestion(state.question);\n    state.lastTime = performance.now();\n    // ensure audio is prepared on first user interaction\n    initAudio();\n    resumeAudioIfRequired();\n    loop();\n  }\n\n  function endGame(win) {\n    state.mode = win ? \"win\" : \"gameover\";\n    // stop audio gently (leave background on but lower)\n    if (audioCtx && masterGain) {\n      // make a short visual/audio cue\n      if (!audioEnabled) {\n        // nothing\n      } else {\n        // brief celebratory or sad tone\n        if (win) playCorrectSound();\n        else playIncorrectSound();\n      }\n    }\n  }\n\n  // -------------------------\n  // Input handlers\n  // -------------------------\n  window.addEventListener(\"keydown\", (e) => {\n    // initialize audio on first gesture\n    initAudio();\n    resumeAudioIfRequired();\n\n    if (e.key === \"ArrowLeft\" || e.key === \"a\" || e.key === \"A\") {\n      state.keys.left = true;\n    } else if (e.key === \"ArrowRight\" || e.key === \"d\" || e.key === \"D\") {\n      state.keys.right = true;\n    } else if (e.key === \"ArrowUp\" || e.key === \"w\" || e.key === \"W\") {\n      state.keys.up = true;\n    } else if (e.key === \"ArrowDown\" || e.key === \"s\" || e.key === \"S\") {\n      state.keys.down = true;\n    } else if (e.key === \"m\" || e.key === \"M\") {\n      toggleAudio();\n    } else if (e.key === \"Enter\") {\n      if (state.mode === \"win\" || state.mode === \"gameover\") {\n        startNewGame();\n      }\n    }\n  });\n  window.addEventListener(\"keyup\", (e) => {\n    if (e.key === \"ArrowLeft\" || e.key === \"a\" || e.key === \"A\") {\n      state.keys.left = false;\n    } else if (e.key === \"ArrowRight\" || e.key === \"d\" || e.key === \"D\") {\n      state.keys.right = false;\n    } else if (e.key === \"ArrowUp\" || e.key === \"w\" || e.key === \"W\") {\n      state.keys.up = false;\n    } else if (e.key === \"ArrowDown\" || e.key === \"s\" || e.key === \"S\") {\n      state.keys.down = false;\n    }\n  });\n\n  // Mouse move to allow pointer control optional\n  canvas.addEventListener(\"mousemove\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    state.mouse.x = mx;\n    state.mouse.y = my;\n  });\n  canvas.addEventListener(\"mousedown\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    // handle click on restart button for end screens\n    if (state.mode === \"win\" || state.mode === \"gameover\") {\n      const btn = restartButtonRect();\n      if (mx >= btn.x && mx <= btn.x + btn.w && my >= btn.y && my <= btn.y + btn.h) {\n        startNewGame();\n        return;\n      }\n    }\n    // also allow clicking bubbles to catch them\n    if (state.mode === \"playing\") {\n      // check bubble collisions\n      for (const b of state.bubbles.slice()) {\n        const dx = b.x - mx;\n        const dy = b.y - my;\n        if (Math.sqrt(dx * dx + dy * dy) <= b.r + 5) {\n          handleBubbleCatch(b);\n          break;\n        }\n      }\n    }\n  });\n\n  // Restart button rectangle helper\n  function restartButtonRect() {\n    const font = `${IMPORTANT_FONT}px sans-serif`;\n    const text = \"Restart\";\n    ctx.font = font;\n    const metrics = ctx.measureText(text);\n    const tw = Math.ceil(metrics.width);\n    const th = IMPORTANT_FONT;\n    const bw = tw + PADDING * 2;\n    const bh = th + PADDING * 2;\n    const x = WIDTH / 2 - bw / 2;\n    const y = HEIGHT / 2 + 40;\n    return { x, y, w: bw, h: bh, text, font };\n  }\n\n  // -------------------------\n  // Game mechanics\n  // -------------------------\n  function handleBubbleCatch(bubble) {\n    // remove bubble\n    state.bubbles = state.bubbles.filter((b) => b.id !== bubble.id);\n    if (bubble.isCorrect) {\n      state.correctCount++;\n      state.feedbackFlash.color = \"rgba(80,200,120,0.35)\";\n      state.feedbackFlash.t = nowMs();\n      playCorrectSound();\n      // if reached target, win\n      if (state.correctCount >= TARGET_CORRECT) {\n        endGame(true);\n        return;\n      }\n      // next question\n      state.question = generateQuestion();\n      // spawn choices in a fun arrangement\n      spawnBubblesForQuestion(state.question);\n    } else {\n      state.wrongCount++;\n      state.feedbackFlash.color = \"rgba(255,80,80,0.35)\";\n      state.feedbackFlash.t = nowMs();\n      playIncorrectSound();\n      if (state.wrongCount >= MAX_WRONG) {\n        endGame(false);\n        return;\n      }\n      // remove incorrect bubble but keep question unchanged; spawn a new incorrect distractor to replace it after small delay\n      setTimeout(() => {\n        // only spawn new distractor if still playing\n        if (state.mode !== \"playing\") return;\n        const val = bubble.value + (Math.random() < 0.5 ? -2 : 2);\n        const newBubble = {\n          id: `${Date.now()}-spawn${state.rngCounter++}`,\n          x: Math.min(Math.max(60, bubble.x + randomInt(-40, 40)), WIDTH - 60),\n          y: Math.min(Math.max(120, bubble.y + randomInt(-20, 20)), HEIGHT - 180),\n          vy: randomInt(10, 30) / 50,\n          value: val,\n          isCorrect: val === state.question.answer,\n          r: 28 + Math.floor(Math.random() * 8),\n        };\n        state.bubbles.push(newBubble);\n      }, 700);\n    }\n  }\n\n  // -------------------------\n  // Drawing helpers\n  // -------------------------\n  function clearCanvas() {\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    // base calming background with wacky cloud shapes\n    ctx.fillStyle = BG_COLOR;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // soft diagonal gradient\n    const g = ctx.createLinearGradient(0, 0, WIDTH, HEIGHT);\n    g.addColorStop(0, \"rgba(232,246,255,0.6)\");\n    g.addColorStop(1, \"rgba(245,255,238,0.7)\");\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // gentle floating circles as decorative non-distracting elements\n    for (let i = 0; i < 20; i++) {\n      const x = (i * 97) % WIDTH;\n      const y = (i * 53 + (nowMs() / 50)) % HEIGHT;\n      ctx.fillStyle = `rgba(200,230,255,0.06)`;\n      ctx.beginPath();\n      ctx.arc(x, y, 35, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n\n  function drawUI() {\n    // Score top-left\n    const scoreText = `Correct: ${state.correctCount}/${TARGET_CORRECT}`;\n    const scoreFont = `${IMPORTANT_FONT}px sans-serif`;\n    ctx.font = scoreFont;\n    const scoreMetrics = ctx.measureText(scoreText);\n    const scoreW = Math.ceil(scoreMetrics.width);\n    const scoreH = IMPORTANT_FONT;\n    const scoreX = PADDING;\n    const scoreY = PADDING;\n    // background rect\n    ctx.fillStyle = \"rgba(255,255,255,0.85)\";\n    ctx.strokeStyle = \"rgba(100,120,140,0.2)\";\n    ctx.lineWidth = 1;\n    const sw = scoreW + PADDING * 2;\n    const sh = scoreH + PADDING * 2;\n    ctx.fillRect(scoreX, scoreY, sw, sh);\n    ctx.strokeRect(scoreX, scoreY, sw, sh);\n    // text\n    ctx.fillStyle = \"#123\";\n    ctx.font = scoreFont;\n    ctx.textBaseline = \"top\";\n    ctx.fillText(scoreText, scoreX + PADDING, scoreY + PADDING);\n\n    // Lives top-right\n    const livesText = `Wrong allowed: ${MAX_WRONG - state.wrongCount}`;\n    ctx.font = `${IMPORTANT_FONT}px sans-serif`;\n    const livesMetrics = ctx.measureText(livesText);\n    const lw = Math.ceil(livesMetrics.width);\n    const lh = IMPORTANT_FONT;\n    const livesX = WIDTH - PADDING - (lw + PADDING * 2);\n    const livesY = PADDING;\n    ctx.fillStyle = \"rgba(255,255,255,0.85)\";\n    ctx.fillRect(livesX, livesY, lw + PADDING * 2, lh + PADDING * 2);\n    ctx.strokeStyle = \"rgba(100,120,140,0.2)\";\n    ctx.strokeRect(livesX, livesY, lw + PADDING * 2, lh + PADDING * 2);\n    ctx.fillStyle = \"#123\";\n    ctx.fillText(livesText, livesX + PADDING, livesY + PADDING);\n\n    // Audio indicator near lives (small)\n    const audioText = audioEnabled ? \"\ud83d\udd0a\" : \"\ud83d\udd07\";\n    const audioFont = `${MIN_BODY_FONT}px sans-serif`;\n    ctx.font = audioFont;\n    const audMetrics = ctx.measureText(audioText);\n    const aw = Math.ceil(audMetrics.width);\n    const ah = MIN_BODY_FONT;\n    const apad = 6;\n    const ax = livesX - apad - aw - 6;\n    const ay = livesY + (lh + PADDING * 2 - ah) / 2;\n    // background for icon\n    ctx.fillStyle = \"rgba(255,255,255,0.85)\";\n    ctx.fillRect(ax - apad, ay - 4, aw + apad * 2, ah + 8);\n    ctx.fillStyle = \"#123\";\n    ctx.fillText(audioText, ax, ay);\n\n    // Question top-center\n    const qFont = `${IMPORTANT_FONT + 4}px sans-serif`;\n    ctx.font = qFont;\n    const qText = state.question ? state.question.qText : \"Loading...\";\n    const qMetrics = ctx.measureText(qText);\n    const qw = Math.ceil(qMetrics.width);\n    const qh = IMPORTANT_FONT + 4;\n    const qx = WIDTH / 2 - qw / 2;\n    const qy = 60 - qh / 2;\n    // background rectangle centered\n    ctx.fillStyle = \"rgba(255,255,255,0.95)\";\n    ctx.fillRect(qx - PADDING, qy - PADDING, qw + PADDING * 2, qh + PADDING * 2);\n    ctx.strokeStyle = \"rgba(80,120,150,0.12)\";\n    ctx.strokeRect(qx - PADDING, qy - PADDING, qw + PADDING * 2, qh + PADDING * 2);\n    ctx.fillStyle = \"#0B3\";\n    ctx.font = qFont;\n    ctx.fillText(qText, qx, qy);\n\n    // Instructions bottom-center (multi-line)\n    const instructions = [\n      \"Move: Arrow keys or WASD. Click or touch a bubble to catch it.\",\n      \"Press M to mute/unmute sound. Press Enter to restart after game ends.\",\n    ];\n    ctx.font = `${MIN_BODY_FONT}px sans-serif`;\n    const lineHeight = MIN_BODY_FONT + 6;\n    // compute width as max of lines\n    let maxW = 0;\n    for (const line of instructions) {\n      const m = ctx.measureText(line);\n      maxW = Math.max(maxW, Math.ceil(m.width));\n    }\n    const instrW = maxW + PADDING * 2;\n    const instrH = instructions.length * lineHeight + PADDING * 2;\n    const instrX = WIDTH / 2 - instrW / 2;\n    const instrY = HEIGHT - instrH - 12;\n    ctx.fillStyle = \"rgba(255,255,255,0.9)\";\n    ctx.fillRect(instrX, instrY, instrW, instrH);\n    ctx.strokeStyle = \"rgba(100,120,140,0.08)\";\n    ctx.strokeRect(instrX, instrY, instrW, instrH);\n    ctx.fillStyle = \"#044\";\n    for (let i = 0; i < instructions.length; i++) {\n      ctx.fillText(instructions[i], instrX + PADDING, instrY + PADDING + i * lineHeight);\n    }\n  }\n\n  function drawDrone(drone, t = 0) {\n    const { x, y, radius } = drone;\n    // Drone body\n    ctx.save();\n    ctx.translate(x, y);\n\n    // subtle shadow\n    ctx.beginPath();\n    ctx.ellipse(0, radius + 12, radius * 0.9, radius * 0.35, 0, 0, Math.PI * 2);\n    ctx.fillStyle = \"rgba(20,20,30,0.08)\";\n    ctx.fill();\n\n    // body rectangle (wacky)\n    ctx.fillStyle = \"#ffd66b\";\n    ctx.strokeStyle = \"#ab8a3f\";\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.roundRect = function (x, y, w, h, r) {\n      // utility\n      this.moveTo(x + r, y);\n      this.arcTo(x + w, y, x + w, y + h, r);\n      this.arcTo(x + w, y + h, x, y + h, r);\n      this.arcTo(x, y + h, x, y, r);\n      this.arcTo(x, y, x + w, y, r);\n    };\n    ctx.beginPath();\n    ctx.roundRect(-radius * 1.1, -radius * 0.6, radius * 2.2, radius * 1.2, 8);\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n\n    // little face\n    ctx.fillStyle = \"#5b3\";\n    ctx.beginPath();\n    ctx.arc(-8, 0, 6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(12, 0, 6, 0, Math.PI * 2);\n    ctx.fill();\n\n    // propellers (wacky, slightly animated)\n    const spin = (t / 200) % (Math.PI * 2);\n    function drawProp(cx, cy) {\n      ctx.save();\n      ctx.translate(cx, cy);\n      ctx.rotate(spin);\n      ctx.fillStyle = \"rgba(80,100,130,0.9)\";\n      ctx.beginPath();\n      ctx.ellipse(0, -8, 28, 7, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.beginPath();\n      ctx.ellipse(0, 8, 28, 7, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n    }\n    drawProp(-radius * 1.6, -radius * 0.8);\n    drawProp(radius * 1.6, -radius * 0.8);\n    drawProp(-radius * 1.6, radius * 0.7);\n    drawProp(radius * 1.6, radius * 0.7);\n\n    ctx.restore();\n  }\n\n  function drawBubbles(bubbles) {\n    for (const b of bubbles) {\n      // bubble shadow\n      ctx.beginPath();\n      ctx.ellipse(b.x + 6, b.y + 8, b.r * 0.9, b.r * 0.6, 0, 0, Math.PI * 2);\n      ctx.fillStyle = \"rgba(20,20,20,0.06)\";\n      ctx.fill();\n\n      // bubble body with gradient\n      const g = ctx.createLinearGradient(b.x - b.r, b.y - b.r, b.x + b.r, b.y + b.r);\n      g.addColorStop(0, \"rgba(255,255,255,0.95)\");\n      g.addColorStop(1, b.isCorrect ? \"rgba(130,220,160,1)\" : \"rgba(180,200,255,1)\");\n      ctx.fillStyle = g;\n      ctx.beginPath();\n      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);\n      ctx.fill();\n\n      // shiny highlight\n      ctx.fillStyle = \"rgba(255,255,255,0.55)\";\n      ctx.beginPath();\n      ctx.ellipse(b.x - b.r * 0.35, b.y - b.r * 0.45, b.r * 0.4, b.r * 0.25, 0, 0, Math.PI * 2);\n      ctx.fill();\n\n      // number\n      ctx.fillStyle = \"#072\";\n      ctx.font = `bold ${Math.max(18, Math.floor(b.r / 1.5))}px sans-serif`;\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillText(String(b.value), b.x, b.y);\n    }\n    ctx.textAlign = \"start\";\n  }\n\n  // -------------------------\n  // Main loop\n  // -------------------------\n  function loop() {\n    if (state.mode !== \"playing\") {\n      // still draw a single frame to show end state maybe\n      draw();\n      return;\n    }\n    const t0 = nowMs();\n    const dt = Math.min(100, t0 - state.lastTime);\n    update(dt / 1000);\n    draw();\n    state.lastTime = t0;\n    requestAnimationFrame(loop);\n  }\n\n  function update(dt) {\n    const d = state.drone;\n    // input movement\n    let moveX = 0;\n    let moveY = 0;\n    if (state.keys.left) moveX -= 1;\n    if (state.keys.right) moveX += 1;\n    if (state.keys.up) moveY -= 1;\n    if (state.keys.down) moveY += 1;\n    // if mouse is active, move toward mouse gently\n    if (state.mouse.x !== null && state.mouse.y !== null && !state.keys.left && !state.keys.right && !state.keys.up && !state.keys.down) {\n      // allow mouse to drag drone\n      const dx = state.mouse.x - d.x;\n      const dy = state.mouse.y - d.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      if (dist > 8) {\n        moveX = dx / dist;\n        moveY = dy / dist;\n      }\n    }\n\n    // normalize\n    if (moveX !== 0 || moveY !== 0) {\n      const len = Math.sqrt(moveX * moveX + moveY * moveY);\n      moveX /= len;\n      moveY /= len;\n      d.x += moveX * d.speed * dt;\n      d.y += moveY * d.speed * dt;\n    } else {\n      // slight drift to give wacky feel\n      d.x += Math.sin(nowMs() / 600) * 0.2;\n      d.y += Math.cos(nowMs() / 700) * 0.15;\n    }\n\n    // clamp\n    d.x = Math.max(30, Math.min(WIDTH - 30, d.x));\n    d.y = Math.max(80, Math.min(HEIGHT - 140, d.y));\n\n    // update bubbles: gentle floating\n    for (const b of state.bubbles) {\n      b.y += b.vy;\n      b.x += Math.sin((nowMs() + b.x) / 1200) * 0.4;\n      // wrap around top/bottom if floats too far\n      if (b.y > HEIGHT - 120) b.y = 120 + Math.random() * 40;\n      if (b.y < 100) b.y = 100 + Math.random() * 60;\n    }\n\n    // collision detection\n    for (const b of state.bubbles.slice()) {\n      const dx = b.x - d.x;\n      const dy = b.y - d.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      if (dist <= b.r + d.radius * 0.6) {\n        handleBubbleCatch(b);\n      }\n    }\n\n    // feedback flash fade\n    if (state.feedbackFlash.t > 0) {\n      if (nowMs() - state.feedbackFlash.t > 400) {\n        state.feedbackFlash.t = 0;\n      }\n    }\n  }\n\n  function draw() {\n    clearCanvas();\n\n    // optional feedback overlay\n    if (state.feedbackFlash.t > 0) {\n      ctx.fillStyle = state.feedbackFlash.color;\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    }\n\n    // Draw bubbles behind drone for depth effect\n    drawBubbles(state.bubbles);\n\n    // draw drone with animation timestamp\n    drawDrone(state.drone, nowMs());\n\n    // draw UI overlays on top\n    drawUI();\n\n    // draw game state end screens\n    if (state.mode === \"win\") {\n      drawEndScreen(true);\n    } else if (state.mode === \"gameover\") {\n      drawEndScreen(false);\n    }\n  }\n\n  function drawEndScreen(win) {\n    // dim panel\n    ctx.fillStyle = \"rgba(10,10,20,0.35)\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // central panel\n    const title = win ? \"You Win! Drone delivered the packages!\" : \"Game Over. Drone needs a recharge.\";\n    const subtitle = win ? `You answered ${state.correctCount} questions correctly!` : `You made ${state.wrongCount} wrong answers.`;\n    const titleFont = `${IMPORTANT_FONT + 6}px sans-serif`;\n    const subFont = `${MIN_BODY_FONT + 2}px sans-serif`;\n\n    // measure\n    ctx.font = titleFont;\n    const tmetrics = ctx.measureText(title);\n    const tw = Math.ceil(tmetrics.width);\n    ctx.font = subFont;\n    const smetrics = ctx.measureText(subtitle);\n    const sw = Math.ceil(smetrics.width);\n    const panelW = Math.max(tw, sw) + PADDING * 4;\n    const panelH = 120;\n    const px = WIDTH / 2 - panelW / 2;\n    const py = HEIGHT / 2 - panelH / 2 - 40;\n    ctx.fillStyle = \"rgba(255,255,255,0.98)\";\n    ctx.fillRect(px, py, panelW, panelH);\n    ctx.strokeStyle = \"rgba(80,120,140,0.12)\";\n    ctx.strokeRect(px, py, panelW, panelH);\n\n    // title\n    ctx.fillStyle = win ? \"#0A6\" : \"#B33\";\n    ctx.font = titleFont;\n    ctx.fillText(title, px + PADDING * 2, py + PADDING * 2);\n\n    // subtitle\n    ctx.fillStyle = \"#123\";\n    ctx.font = subFont;\n    ctx.fillText(subtitle, px + PADDING * 2, py + PADDING * 2 + (IMPORTANT_FONT + 10));\n\n    // restart button\n    const btn = restartButtonRect();\n    ctx.fillStyle = \"#64b5f6\";\n    ctx.strokeStyle = \"#2b6a9a\";\n    ctx.fillRect(btn.x, btn.y, btn.w, btn.h);\n    ctx.strokeRect(btn.x, btn.y, btn.w, btn.h);\n    ctx.fillStyle = \"#012\";\n    ctx.font = btn.font;\n    ctx.fillText(btn.text, btn.x + PADDING, btn.y + PADDING);\n\n    // instruction to press Enter\n    ctx.font = `${MIN_BODY_FONT}px sans-serif`;\n    ctx.fillStyle = \"#fff\";\n    const msg = \"Press Enter or click Restart to play again\";\n    const mm = ctx.measureText(msg);\n    ctx.fillText(msg, WIDTH / 2 - mm.width / 2, btn.y + btn.h + 28);\n  }\n\n  // -------------------------\n  // Start / Loading\n  // -------------------------\n  // Draw initial instructions and wait for user to click to start (and to allow audio init)\n  function drawLoadingScreen() {\n    clearCanvas();\n    ctx.fillStyle = \"#fff\";\n    const title = \"Drone Math Catcher\";\n    const fontTitle = \"28px sans-serif\";\n    ctx.font = fontTitle;\n    const tmetrics = ctx.measureText(title);\n    ctx.fillStyle = \"#123\";\n    ctx.fillText(title, WIDTH / 2 - tmetrics.width / 2, HEIGHT / 2 - 80);\n\n    // small image-like drone drawn\n    drawDrone({ x: WIDTH / 2, y: HEIGHT / 2 - 10, radius: 30 }, nowMs());\n\n    // instructions\n    const lines = [\n      \"Catch the bubble with the correct answer to the question.\",\n      `Get ${TARGET_CORRECT} correct answers to win. ${MAX_WRONG} wrongs and it's game over.`,\n      \"Click to begin. Press M to mute/unmute sound anytime.\",\n    ];\n    ctx.font = `${MIN_BODY_FONT}px sans-serif`;\n    ctx.fillStyle = \"#044\";\n    for (let i = 0; i < lines.length; i++) {\n      const m = ctx.measureText(lines[i]);\n      ctx.fillText(lines[i], WIDTH / 2 - m.width / 2, HEIGHT / 2 + 60 + i * 22);\n    }\n\n    // button\n    const btnText = \"Start Game\";\n    const btnFont = `${IMPORTANT_FONT}px sans-serif`;\n    ctx.font = btnFont;\n    const bm = ctx.measureText(btnText);\n    const bw = Math.ceil(bm.width) + PADDING * 2;\n    const bh = IMPORTANT_FONT + PADDING * 2;\n    const bx = WIDTH / 2 - bw / 2;\n    const by = HEIGHT / 2 + 120;\n    ctx.fillStyle = \"#fdd835\";\n    ctx.fillRect(bx, by, bw, bh);\n    ctx.strokeStyle = \"#b58a06\";\n    ctx.strokeRect(bx, by, bw, bh);\n    ctx.fillStyle = \"#012\";\n    ctx.fillText(btnText, bx + PADDING, by + PADDING);\n    // click handler for start\n    canvas.addEventListener(\n      \"click\",\n      function onStartClick(e) {\n        const rect = canvas.getBoundingClientRect();\n        const mx = e.clientX - rect.left;\n        const my = e.clientY - rect.top;\n        if (mx >= bx && mx <= bx + bw && my >= by && my <= by + bh) {\n          canvas.removeEventListener(\"click\", onStartClick);\n          startNewGame();\n        } else {\n          // allow clicking anywhere to start too\n          canvas.removeEventListener(\"click\", onStartClick);\n          startNewGame();\n        }\n      },\n      { once: true }\n    );\n  }\n\n  // Custom rounding helper for canvas path (polyfill)\n  if (!CanvasRenderingContext2D.prototype.roundRect) {\n    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {\n      if (w < 2 * r) r = w / 2;\n      if (h < 2 * r) r = h / 2;\n      this.beginPath();\n      this.moveTo(x + r, y);\n      this.arcTo(x + w, y, x + w, y + h, r);\n      this.arcTo(x + w, y + h, x, y + h, r);\n      this.arcTo(x, y + h, x, y, r);\n      this.arcTo(x, y, x + w, y, r);\n      this.closePath();\n      return this;\n    };\n  }\n\n  // Kick off loading screen\n  state.mode = \"loading\";\n  drawLoadingScreen();\n\n  // Expose for accessibility - simple keyboard instruction in case canvas not accessible\n  // (We won't add external DOM elements as per requirement; this is just a fallback log.)\n  console.info(\"Drone Math Catcher ready. Focus the page and press Start.\");\n\n  // Accessibility: allow resizing of fonts if user changes system settings - canvas won't adapt but we keep sizes readable.\n\n})();\n---\n",
  "improve_response_tokens": 20890,
  "formatted_code": true,
  "formatting_response_tokens": 22460,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}