# Game of the Day - 2025-10-08

## Metadata
- **Generated Date:** 2025-10-08
- **Generated Time:** 2025-10-08T00:26:47.104647
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-10-08.js
- **File Size:** 31041 bytes
- **Tokens Used:** 10089

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-10-08.js` - The playable game
- `2025-10-08.meta.json` - Machine-readable metadata
- `2025-10-08.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 21597

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 24233

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Math Machines — Canvas Game
  // Renders into element with ID "game-of-the-day-stage"
  // All assets drawn with canvas; all sounds are generated with Web Audio API oscillators.
  // Accessible: keyboard controls, on-screen instructions, hidden aria-live text updates.

  // ---------------------------
  // Setup and Constants
  // ---------------------------
  const STAGE_ID = 'game-of-the-day-stage';
  const WIDTH = 720;
  const HEIGHT = 480;

  // Ensure target container exists
  const stage = document.getElementById(STAGE_ID);
  if (!stage) {
    console.error(`Missing container element with id=${STAGE_ID}`);
    return;
  }
  // Clean stage
  stage.innerHTML = '';
  stage.style.position = 'relative';
  stage.setAttribute('tabindex', '0'); // allow focus

  // Create a canvas sized EXACTLY 720x480
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.width = WIDTH + 'px';
  canvas.style.height = HEIGHT + 'px';
  canvas.setAttribute('role', 'img');
  canvas.setAttribute('aria-label', 'Math Machines game canvas');
  stage.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Accessibility: hidden aria-live region for announcements
  const aria = document.createElement('div');
  aria.setAttribute('aria-live', 'polite');
  aria.style.position = 'absolute';
  aria.style.left = '-9999px';
  aria.style.width = '1px';
  aria.style.height = '1px';
  aria.style.overflow = 'hidden';
  stage.appendChild(aria);

  // Create simple on-canvas button area for audio toggle (drawn in canvas, but clickable via overlay for keyboard)
  const overlayControls = document.createElement('div');
  overlayControls.style.position = 'absolute';
  overlayControls.style.left = '0';
  overlayControls.style.top = '0';
  overlayControls.style.width = WIDTH + 'px';
  overlayControls.style.height = HEIGHT + 'px';
  overlayControls.style.pointerEvents = 'none'; // we'll use canvas click handling; maintain keyboard focus via stage
  stage.appendChild(overlayControls);

  // Game variables
  let running = false;
  let paused = false;
  let lastTime = 0;
  let animationFrame = null;

  // Audio setup
  let audioCtx = null;
  let audioAllowed = false;
  let backgroundGain = null;
  let backgroundOsc = null;
  let masterGain = null;

  function tryCreateAudioContext() {
    if (audioCtx) return audioCtx;
    try {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AudioContext();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.7;
      masterGain.connect(audioCtx.destination);

      // gentle background hum via low-frequency oscillator + filter
      backgroundGain = audioCtx.createGain();
      backgroundGain.gain.value = 0.06;
      backgroundGain.connect(masterGain);

      backgroundOsc = audioCtx.createOscillator();
      backgroundOsc.type = 'sine';
      backgroundOsc.frequency.value = 100;
      const bgFilter = audioCtx.createBiquadFilter();
      bgFilter.type = 'lowpass';
      bgFilter.frequency.value = 400;
      backgroundOsc.connect(bgFilter);
      bgFilter.connect(backgroundGain);
      try {
        backgroundOsc.start();
      } catch (e) {
        // Some browsers require user gesture to start audio; we'll handle resume on user interaction
      }
      audioAllowed = true;
      return audioCtx;
    } catch (err) {
      console.warn('AudioContext creation failed:', err);
      audioCtx = null;
      audioAllowed = false;
      return null;
    }
  }

  // Call on first user gesture
  function ensureAudioResume() {
    if (!audioCtx) tryCreateAudioContext();
    if (!audioCtx) return;
    if (audioCtx.state === 'suspended') {
      audioCtx.resume().catch((e) => {
        console.warn('AudioContext resume failed', e);
      });
    }
  }

  // Sound utilities: generate short oscillator-based sounds
  function playTone({ freq = 440, duration = 0.18, type = 'sine', attack = 0.01, decay = 0.12, volume = 0.15 }) {
    if (!audioAllowed || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      o.type = type;
      o.frequency.setValueAtTime(freq, now);
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.0001, now);
      g.gain.linearRampToValueAtTime(volume, now + attack);
      g.gain.linearRampToValueAtTime(0.0001, now + duration + decay);
      o.connect(g);
      g.connect(masterGain);
      o.start(now);
      o.stop(now + duration + decay + 0.02);
      // Visual cue: flash small speaker meter (we'll draw)
      lastAudioPulse = { at: performance.now(), strength: volume };
    } catch (e) {
      console.warn('Could not play tone', e);
    }
  }

  // Specific game sounds
  const soundCorrect = () => {
    playTone({ freq: 880, duration: 0.22, type: 'triangle', attack: 0.005, decay: 0.15, volume: 0.18 });
    // harmonic
    setTimeout(() => playTone({ freq: 1320, duration: 0.15, type: 'sine', attack: 0.002, decay: 0.12, volume: 0.09 }), 80);
  };
  const soundIncorrect = () => {
    playTone({ freq: 180, duration: 0.18, type: 'sawtooth', attack: 0.01, decay: 0.14, volume: 0.16 });
  };
  const soundPickup = () => {
    playTone({ freq: 620, duration: 0.12, type: 'square', attack: 0.005, decay: 0.09, volume: 0.12 });
  };
  const soundPlace = () => {
    playTone({ freq: 540, duration: 0.10, type: 'sine', attack: 0.002, decay: 0.08, volume: 0.12 });
  };
  const soundWin = () => {
    playTone({ freq: 740, duration: 0.08, type: 'sine', attack: 0.001, decay: 0.07, volume: 0.14 });
    setTimeout(() => playTone({ freq: 940, duration: 0.10, type: 'triangle', attack: 0.002, decay: 0.08, volume: 0.14 }), 90);
    setTimeout(() => playTone({ freq: 1180, duration: 0.12, type: 'sine', attack: 0.002, decay: 0.08, volume: 0.12 }), 200);
  };

  // visual audio pulse
  let lastAudioPulse = { at: 0, strength: 0 };

  // ---------------------------
  // Game Objects
  // ---------------------------

  // Utility random
  const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

  // Machines — top row
  class Machine {
    constructor(x, y, target) {
      this.x = x;
      this.y = y;
      this.target = target;
      this.current = 0;
      this.width = 180;
      this.height = 90;
      this.active = true;
      this.recent = 0; // for animation pulses
    }
    canAccept(value) {
      return this.current + value <= this.target;
    }
    accept(value) {
      if (!this.canAccept(value)) return false;
      this.current += value;
      this.recent = 1.0;
      return true;
    }
    resetForLevel(target) {
      this.target = target;
      this.current = 0;
      this.active = true;
    }
  }

  // Gear objects — values that flow from right to left on conveyor
  class Gear {
    constructor(value, x, y, speed) {
      this.value = value;
      this.x = x;
      this.y = y;
      this.radius = 22;
      this.speed = speed;
      this.picked = false;
    }
    update(dt) {
      if (!this.picked) {
        this.x -= this.speed * dt;
      }
    }
  }

  // Player robotic arm
  class PlayerArm {
    constructor() {
      this.x = WIDTH / 2;
      this.y = HEIGHT - 70;
      this.width = 84;
      this.height = 48;
      this.holding = null; // Gear object reference
      this.speed = 320; // px per second
      this.moveLeft = false;
      this.moveRight = false;
    }
    update(dt) {
      if (this.moveLeft) this.x -= this.speed * dt;
      if (this.moveRight) this.x += this.speed * dt;
      this.x = Math.max(40, Math.min(WIDTH - 40, this.x));
      if (this.holding) {
        // keep held gear relative to arm
        this.holding.x = this.x;
        this.holding.y = this.y - 30;
      }
    }
    pickClosestGear(gears) {
      if (this.holding) return false;
      let closest = null;
      let minDist = 9999;
      for (const g of gears) {
        if (g.picked) continue;
        const dx = g.x - this.x;
        const dy = g.y - (this.y - 30);
        const d = Math.sqrt(dx * dx + dy * dy);
        if (d < minDist && d < 48) {
          minDist = d;
          closest = g;
        }
      }
      if (closest) {
        closest.picked = true;
        this.holding = closest;
        soundPickup();
        announce(`Picked gear ${closest.value}`);
        return true;
      } else {
        // small negative sound
        soundIncorrect();
        announce('No gear nearby to pick');
        return false;
      }
    }
    placeIntoMachine(machines) {
      if (!this.holding) {
        soundIncorrect();
        announce('Not holding a gear to place');
        return false;
      }
      for (const m of machines) {
        if (!m.active) continue;
        // check horizontal overlap
        if (Math.abs(this.x - m.x) < m.width / 2 + 20) {
          const val = this.holding.value;
          if (m.canAccept(val)) {
            m.accept(val);
            // remove held gear
            const placed = this.holding;
            this.holding = null;
            placed.picked = true;
            soundPlace();
            announce(`Placed ${val} into machine (now ${m.current} of ${m.target})`);
            if (m.current === m.target) {
              m.active = false;
              soundCorrect();
              announce(`Machine completed!`);
            }
            return true;
          } else {
            // cannot accept — incorrect
            soundIncorrect();
            announce(`That would go over the target of ${m.target}`);
            return false;
          }
        }
      }
      // not over any machine
      // drop gear back onto conveyor (just release)
      this.holding.picked = false;
      this.holding = null;
      soundIncorrect();
      announce('Not close enough to a machine to place');
      return false;
    }
    dropHeldToConveyor() {
      if (this.holding) {
        this.holding.picked = false;
        // place slightly below arm
        this.holding.x = this.x;
        this.holding.y = this.y + 18;
        this.holding = null;
        soundPlace();
        announce('Dropped gear back on belt');
      }
    }
  }

  // ---------------------------
  // Level and Game Logic
  // ---------------------------
  const gameState = {
    level: 0,
    maxLevels: 6,
    machines: [],
    gears: [],
    player: new PlayerArm(),
    spawnTimer: 0,
    spawnInterval: 1.2, // seconds
    conveyorY: HEIGHT - 140,
    timeLeft: 45,
    levelTime: 45,
    score: 0,
    audioOn: true,
    message: 'Press Enter or Click to Start',
    lastAnnouncement: '',
    awaitingUserGesture: true,
  };

  // Setup initial machines (three machines across top)
  function initMachinesForLevel(level) {
    gameState.machines = [];
    const count = 3;
    const margin = 40;
    const spacing = (WIDTH - margin * 2) / (count);
    for (let i = 0; i < count; i++) {
      const x = margin + spacing * i + spacing / 2;
      const y = 110;
      // target grows with level: base 6 to 10
      const base = 6 + level;
      const target = randInt(base, base + 4);
      const m = new Machine(x, y, target);
      gameState.machines.push(m);
    }
  }

  function startLevel(level) {
    gameState.level = level;
    gameState.gears = [];
    gameState.spawnTimer = 0;
    gameState.spawnInterval = Math.max(0.9, 1.4 - level * 0.12);
    gameState.levelTime = Math.max(25, 45 - level * 3);
    gameState.timeLeft = gameState.levelTime;
    gameState.player = new PlayerArm();
    initMachinesForLevel(level);
    gameState.score = 0;
    gameState.message = `Level ${level + 1} — Fill all machines to their targets! Use ← → to move, Space to pick/place, Up to place into a machine.`;
    announce(gameState.message);
    running = true;
    paused = false;
    ensureAudioResume();
  }

  function allMachinesComplete() {
    return gameState.machines.every((m) => m.current === m.target);
  }

  // Spawn gears flowing on conveyor
  function spawnGear() {
    // gear value 1-5
    const value = randInt(1, 5);
    const x = WIDTH + 30;
    const y = gameState.conveyorY + randInt(-6, 16);
    // speed depends on level
    const speed = randInt(40 + gameState.level * 6, 90 + gameState.level * 8);
    const g = new Gear(value, x, y, speed);
    gameState.gears.push(g);
  }

  // ---------------------------
  // Input Handling
  // ---------------------------
  // Keyboard controls:
  // Left/Right arrows: move arm, Space: pick/place, Up: place into machine if holding, Down: drop gear to conveyor
  const keys = {};
  window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft' || e.key === 'Left') {
      keys.left = true;
      gameState.player.moveLeft = true;
    } else if (e.key === 'ArrowRight' || e.key === 'Right') {
      keys.right = true;
      gameState.player.moveRight = true;
    } else if (e.key === ' ' || e.key === 'Spacebar') {
      e.preventDefault();
      // space: pick if not holding else try place into machine
      if (!running) {
        // start game on Enter/Space
        if (audioCtx === null) tryCreateAudioContext();
        startLevel(0);
        return;
      }
      if (!gameState.player.holding) {
        gameState.player.pickClosestGear(gameState.gears);
      } else {
        // try to place into nearby machine
        gameState.player.placeIntoMachine(gameState.machines);
      }
    } else if (e.key === 'ArrowUp' || e.key === 'Up') {
      // explicit place into machine
      if (running) {
        gameState.player.placeIntoMachine(gameState.machines);
      }
    } else if (e.key === 'ArrowDown' || e.key === 'Down') {
      // drop to conveyor
      if (running) {
        gameState.player.dropHeldToConveyor();
      }
    } else if (e.key === 'p' || e.key === 'P') {
      // toggle pause
      if (running) {
        paused = !paused;
        announce(paused ? 'Paused' : 'Resumed');
      }
    } else if (e.key === 'm' || e.key === 'M') {
      // toggle audio mute
      gameState.audioOn = !gameState.audioOn;
      if (masterGain) masterGain.gain.value = gameState.audioOn ? 0.7 : 0.0;
      announce(gameState.audioOn ? 'Audio on' : 'Audio off');
    } else if ((e.key === 'Enter' || e.key === 'Return') && !running) {
      if (audioCtx === null) tryCreateAudioContext();
      startLevel(0);
    } else if ((e.key === 'r' || e.key === 'R') && !running) {
      // restart
      startLevel(0);
    }
  });

  window.addEventListener('keyup', (e) => {
    if (e.key === 'ArrowLeft' || e.key === 'Left') {
      keys.left = false;
      gameState.player.moveLeft = false;
    } else if (e.key === 'ArrowRight' || e.key === 'Right') {
      keys.right = false;
      gameState.player.moveRight = false;
    }
  });

  // Mouse/touch: move arm horizontally by mouse; click on gear to pick/place etc.
  function getCanvasPos(evt) {
    const rect = canvas.getBoundingClientRect();
    let clientX, clientY;
    if (evt.touches && evt.touches[0]) {
      clientX = evt.touches[0].clientX;
      clientY = evt.touches[0].clientY;
    } else {
      clientX = evt.clientX;
      clientY = evt.clientY;
    }
    return {
      x: ((clientX - rect.left) / rect.width) * canvas.width,
      y: ((clientY - rect.top) / rect.height) * canvas.height,
    };
  }

  canvas.addEventListener('mousemove', (e) => {
    const pos = getCanvasPos(e);
    gameState.player.x = Math.max(40, Math.min(WIDTH - 40, pos.x));
    // resume audio on first mouse
    ensureAudioResume();
  });
  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    const pos = getCanvasPos(e);
    gameState.player.x = Math.max(40, Math.min(WIDTH - 40, pos.x));
    ensureAudioResume();
  }, { passive: false });

  canvas.addEventListener('click', (e) => {
    // On click: if not running, start. If running: pick/place depending on proximity.
    ensureAudioResume();
    if (!running) {
      startLevel(0);
      return;
    }
    const pos = getCanvasPos(e);
    // if click near a gear, pick that gear if possible
    const dxToPlayer = Math.abs(pos.x - gameState.player.x);
    const dyToPlayer = Math.abs(pos.y - (gameState.player.y - 30));
    // If click is near player -> pick/place
    if (dxToPlayer < 80 && dyToPlayer < 80) {
      if (!gameState.player.holding) {
        gameState.player.pickClosestGear(gameState.gears);
      } else {
        gameState.player.placeIntoMachine(gameState.machines);
      }
    } else {
      // click near machine to place from player
      for (const m of gameState.machines) {
        if (Math.abs(pos.x - m.x) < m.width / 2 && Math.abs(pos.y - m.y) < m.height / 2) {
          // move player beneath and place
          gameState.player.x = m.x;
          if (gameState.player.holding) {
            gameState.player.placeIntoMachine(gameState.machines);
          }
          return;
        }
      }
      // else click somewhere: maybe pick gear under click directly
      let picked = false;
      for (const g of gameState.gears) {
        const d = Math.hypot(g.x - pos.x, g.y - pos.y);
        if (d < 30 && !g.picked && !gameState.player.holding) {
          // move arm to gear and pick
          gameState.player.x = g.x;
          gameState.player.pickClosestGear(gameState.gears);
          picked = true;
          break;
        }
      }
      if (!picked && gameState.player.holding) {
        // click background -> drop to conveyor near click
        gameState.player.dropHeldToConveyor();
      }
    }
  });

  // ---------------------------
  // Announcements for Accessibility
  // ---------------------------
  function announce(text) {
    aria.textContent = text;
    gameState.lastAnnouncement = text;
  }

  // ---------------------------
  // Update Loop
  // ---------------------------
  function update(dt) {
    if (!running || paused) return;
    // spawn gears
    gameState.spawnTimer -= dt;
    if (gameState.spawnTimer <= 0) {
      spawnGear();
      gameState.spawnTimer = gameState.spawnInterval + (Math.random() * 0.6 - 0.3);
    }

    // update gears
    for (const g of gameState.gears) {
      if (!g.picked) {
        g.update(dt);
      }
    }
    // remove off-screen gears
    gameState.gears = gameState.gears.filter((g) => g.x > -60 && !(g.picked && g === null));

    // update player
    gameState.player.update(dt);

    // time countdown
    gameState.timeLeft -= dt;
    if (gameState.timeLeft <= 0) {
      // time up -> level failed
      running = false;
      announce('Time\'s up! Press Enter to try again.');
      soundIncorrect();
      gameState.message = 'Time\'s up! Press Enter to try again.';
      return;
    }

    // check machine completions
    if (allMachinesComplete()) {
      // win this level; proceed to next or finish
      soundWin();
      gameState.score += 100;
      const nextLevel = gameState.level + 1;
      if (nextLevel >= gameState.maxLevels) {
        // game beaten
        running = false;
        announce('You finished all machines — great job! Press Enter to play again.');
        gameState.message = `You beat the game! Score: ${gameState.score}. Press Enter to play again.`;
      } else {
        // proceed to next level after small delay — clear gears and setup next
        running = false; // pause until player hits Enter
        gameState.message = `Level ${gameState.level + 1} complete! Press Enter to continue.`;
        announce(gameState.message);
      }
    }

    // animate machine pulses
    for (const m of gameState.machines) {
      if (m.recent > 0) m.recent = Math.max(0, m.recent - dt * 1.5);
    }
  }

  // ---------------------------
  // Drawing
  // ---------------------------
  function draw() {
    // clear with calming background gradient
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#eaf3ff');
    g.addColorStop(1, '#f0fff6');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // wacky cloud shapes at top
    drawClouds();

    // Draw machines
    for (const m of gameState.machines) {
      drawMachine(m);
    }

    // Conveyor belt
    drawConveyor();

    // Draw gears
    for (const g of gameState.gears) {
      drawGear(g);
    }

    // Draw player arm
    drawPlayer(gameState.player);

    // HUD: level, time, score
    drawHUD();

    // Draw message area
    ctx.fillStyle = 'rgba(20,20,30,0.06)';
    ctx.fillRect(18, HEIGHT - 40, WIDTH - 36, 30);
    ctx.fillStyle = '#18304e';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(gameState.message, 26, HEIGHT - 18);

    // audio visual meter pulse
    drawAudioMeter();
  }

  function drawClouds() {
    // wacky calming circles
    ctx.save();
    ctx.globalAlpha = 0.95;
    for (let i = 0; i < 6; i++) {
      const cx = 60 + i * 120 + Math.sin(performance.now() / 1300 + i) * 6;
      const cy = 30 + Math.cos(performance.now() / 1500 + i) * 4;
      const r = 34 + (i % 2) * 10;
      ctx.beginPath();
      ctx.fillStyle = i % 2 ? '#ffffff' : '#f8ffff';
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawMachine(m) {
    // machine body
    ctx.save();
    ctx.translate(m.x, m.y);
    // soft shadow and pulsing scale
    const pulse = 1 + m.recent * 0.06;
    ctx.scale(pulse, pulse);
    ctx.fillStyle = '#f1f6ff';
    roundRect(ctx, -m.width / 2, -m.height / 2, m.width, m.height, 12);
    ctx.fill();
    // decorative bolts
    ctx.fillStyle = '#cde6ff';
    for (let i = -1; i <= 1; i++) {
      ctx.beginPath();
      ctx.arc(i * 48, -m.height / 2 + 8, 5, 0, Math.PI * 2);
      ctx.fill();
    }

    // display current / target
    ctx.fillStyle = '#1b3b57';
    ctx.font = '16px Comic Sans MS, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`Machine`, 0, -4);
    ctx.font = '20px monospace';
    ctx.fillText(`${m.current} / ${m.target}`, 0, 22);

    // little window with wacky eyes to indicate status
    ctx.fillStyle = m.active ? '#ffe6a1' : '#c4ffd3';
    roundRect(ctx, m.width / 2 - 34, -m.height / 2 + 12, 48, 28, 8);
    ctx.fill();
    // eyes
    ctx.fillStyle = '#3b3b3b';
    ctx.beginPath();
    ctx.arc(m.width / 2 - 22, -m.height / 2 + 24, 3 + (m.active ? 0 : 1), 0, Math.PI * 2);
    ctx.arc(m.width / 2 - 10, -m.height / 2 + 24, 3 + (m.active ? 0 : 1), 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  function drawConveyor() {
    // base belt
    const y = gameState.conveyorY;
    ctx.fillStyle = '#d6e9ff';
    ctx.fillRect(0, y - 16, WIDTH, 36);
    // moving stripes
    ctx.save();
    ctx.translate((performance.now() / 20) % 40, 0);
    for (let i = -40; i < WIDTH + 40; i += 40) {
      ctx.fillStyle = 'rgba(20,50,80,0.06)';
      ctx.fillRect(i, y - 16, 24, 36);
    }
    ctx.restore();
    // some machine-like pipes at edges
    ctx.fillStyle = '#bfe0ff';
    roundRect(ctx, 14, y + 18, 110, 22, 8);
    roundRect(ctx, WIDTH - 124, y + 18, 110, 22, 8);
    ctx.fill();
  }

  function drawGear(g) {
    ctx.save();
    ctx.translate(g.x, g.y);
    // gear body
    ctx.beginPath();
    ctx.fillStyle = g.picked ? '#ffe6d6' : '#ffd8ff';
    ctx.arc(0, 0, g.radius, 0, Math.PI * 2);
    ctx.fill();

    // teeth
    ctx.fillStyle = '#ffb4ff';
    for (let i = 0; i < 8; i++) {
      const ang = (i / 8) * Math.PI * 2;
      const tx = Math.cos(ang) * (g.radius + 8);
      const ty = Math.sin(ang) * (g.radius + 8);
      ctx.beginPath();
      ctx.rect(tx - 5, ty - 3, 10, 6);
      ctx.save();
      ctx.translate(tx, ty);
      ctx.rotate(ang);
      ctx.fillRect(-5, -3, 10, 6);
      ctx.restore();
    }

    // center hole
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(0, 0, 8, 0, Math.PI * 2);
    ctx.fill();

    // number value
    ctx.fillStyle = '#3b3b3b';
    ctx.font = 'bold 16px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(g.value.toString(), 0, 6);

    ctx.restore();
  }

  function drawPlayer(p) {
    ctx.save();
    // arm body
    ctx.translate(p.x, p.y);
    ctx.fillStyle = '#dbefff';
    roundRect(ctx, -p.width / 2, -p.height / 2, p.width, p.height, 10);
    ctx.fill();

    // claw
    ctx.fillStyle = '#a5d0ff';
    ctx.beginPath();
    ctx.moveTo(-10, -p.height / 2);
    ctx.lineTo(0, -p.height / 2 - 20);
    ctx.lineTo(10, -p.height / 2);
    ctx.fill();

    ctx.fillStyle = '#17364f';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('ROBO-ARM', 0, 10);

    // held gear drawn over arm if present (gear draws with its own coords)
    ctx.restore();
  }

  function drawHUD() {
    // top-left: level and time
    ctx.fillStyle = '#24445e';
    ctx.font = '16px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`Level: ${gameState.level + 1}/${gameState.maxLevels}`, 18, 22);

    // time bar
    const timeX = 160;
    const timeY = 12;
    const timeW = 200;
    const timeH = 18;
    ctx.fillStyle = '#cfe8ff';
    roundRect(ctx, timeX, timeY, timeW, timeH, 10);
    ctx.fill();
    const pct = Math.max(0, gameState.timeLeft / gameState.levelTime);
    // gradient from green to orange
    const tg = ctx.createLinearGradient(timeX, 0, timeX + timeW, 0);
    tg.addColorStop(0, '#8bf59f');
    tg.addColorStop(1, '#ffd08a');
    ctx.fillStyle = tg;
    roundRect(ctx, timeX + 2, timeY + 2, (timeW - 4) * pct, timeH - 4, 8);
    ctx.fill();
    ctx.fillStyle = '#083248';
    ctx.font = '12px monospace';
    ctx.fillText(`Time: ${Math.ceil(gameState.timeLeft)}s`, timeX + timeW + 8, timeY + 13);

    // Score top-right
    ctx.textAlign = 'right';
    ctx.fillStyle = '#18304e';
    ctx.fillText(`Score: ${gameState.score}`, WIDTH - 18, 22);
  }

  function drawAudioMeter() {
    const meterX = WIDTH - 54;
    const meterY = HEIGHT - 46;
    // background speaker box
    ctx.fillStyle = '#e9f7ff';
    roundRect(ctx, meterX - 8, meterY - 8, 44, 36, 8);
    ctx.fill();
    // speaker icon
    ctx.fillStyle = '#18304e';
    ctx.beginPath();
    ctx.moveTo(meterX, meterY + 8);
    ctx.lineTo(meterX + 8, meterY - 6);
    ctx.lineTo(meterX + 8, meterY + 28);
    ctx.closePath();
    ctx.fillRect(meterX - 10, meterY + 0, 10, 20);
    // arc waves based on lastAudioPulse
    const since = (performance.now() - lastAudioPulse.at);
    const strength = lastAudioPulse.strength ? Math.min(1, lastAudioPulse.strength / 0.2) : 0;
    ctx.strokeStyle = `rgba(24,48,78,${0.4 * strength})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(meterX + 14, meterY + 8, 10 + since * 0.02, 0.6, 2.2);
    ctx.stroke();
  }

  // small utility: rounded rectangle
  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  // ---------------------------
  // Game Loop
  // ---------------------------
  function loop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const dt = Math.min(0.040, (timestamp - lastTime) / 1000); // clamp dt ~40ms
    lastTime = timestamp;

    if (running && !paused) update(dt);

    draw();

    animationFrame = requestAnimationFrame(loop);
  }

  // Start drawing static start screen first
  function drawStartScreen() {
    // initial welcome
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    // background
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#eef7ff');
    g.addColorStop(1, '#f7fff4');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    ctx.fillStyle = '#17364f';
    ctx.font = '36px Comic Sans MS, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Math Machines!', WIDTH / 2, 100);

    ctx.font = '18px sans-serif';
    ctx.fillText('Help the wacky machines by placing the right-number gears into them.', WIDTH / 2, 140);
    ctx.fillText('Use ← → to move, Space to pick/place, Up to place into a machine.', WIDTH / 2, 165);
    ctx.fillText('Press Enter or click to start. Press M to toggle sound. Press P to pause.', WIDTH / 2, 190);

    // small playful machine drawing
    const m = new Machine(WIDTH / 2, 260, 10);
    drawMachine(m);

    // sample gears
    const g1 = new Gear(3, WIDTH / 2 - 80, 350, 0);
    const g2 = new Gear(5, WIDTH / 2, 350, 0);
    const g3 = new Gear(2, WIDTH / 2 + 80, 350, 0);
    drawGear(g1);
    drawGear(g2);
    drawGear(g3);

    ctx.fillStyle = '#18304e';
    ctx.font = '16px sans-serif';
    ctx.fillText('Beating the game: finish all levels to win. Each machine must be exactly filled!', WIDTH / 2, 420);

    // audio instructions
    ctx.fillStyle = '#0e2b45';
    ctx.font = '14px monospace';
    ctx.fillText('Audio: press M to mute/unmute. Click to resume audio if disabled.', WIDTH / 2, 450);
  }

  drawStartScreen();
  animationFrame = requestAnimationFrame(loop);

  // Resume audio on any user interaction in stage
  stage.addEventListener('pointerdown', () => {
    ensureAudioResume();
  });

  // Start on click within canvas area (already handled), but also support on-screen keyboard focus to start game
  stage.addEventListener('keydown', (e) => {
    if ((e.key === 'Enter' || e.key === ' ') && !running) {
      ensureAudioResume();
      startLevel(0);
    }
  });

  // Hook into Enter to progress to next level after completion
  window.addEventListener('keydown', (e) => {
    if ((e.key === 'Enter' || e.key === ' ') && !running) {
      // if game ended because of level completion we can move to next
      if (gameState.level + 1 < gameState.maxLevels && gameState.message && gameState.message.startsWith('Level')) {
        // proceed to next
        startLevel(gameState.level + 1);
      } else if (gameState.message && gameState.message.startsWith('You beat')) {
        // restart new playthrough
        startLevel(0);
      } else if (gameState.message && gameState.message.startsWith("Time's up")) {
        // restart
        startLevel(0);
      }
    }
  });

  // Error handling for audio resume attempts
  window.addEventListener('unhandledrejection', (ev) => {
    console.warn('Unhandled promise rejection', ev.reason);
  });

  // Make sure canvas is keyboard focusable for accessibility
  canvas.setAttribute('tabindex', '0');
  canvas.addEventListener('focus', () => {
    announce('Canvas focused. Use arrow keys and space to play.');
  });

  // Small periodic autosave of last game state to aria for screen reader
  setInterval(() => {
    if (!running) return;
    const nextMachine = gameState.machines.find((m) => m.current < m.target);
    if (nextMachine) {
      aria.textContent = `Time ${Math.ceil(gameState.timeLeft)}s. Next machine needs ${nextMachine.target - nextMachine.current}.`;
    } else {
      aria.textContent = `All machines complete.`;
    }
  }, 4500);

  // Clean up on window unload
  window.addEventListener('beforeunload', () => {
    if (audioCtx && audioCtx.close) {
      try { audioCtx.close(); } catch (_) {}
    }
    if (animationFrame) cancelAnimationFrame(animationFrame);
  });

})();
---

