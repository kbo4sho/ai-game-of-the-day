{
  "generated_date": "2025-11-03",
  "generated_timestamp": "2025-11-03T00:29:44.994906",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 10000,
  "game_filename": "2025-11-03.js",
  "game_size_bytes": 27872,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Drone Math Adventure for ages 7-9\n  // Renders into element with id \"game-of-the-day-stage\"\n  // All visuals drawn on canvas; all sound via Web Audio API oscillators.\n  // Clear win condition: answer targetCorrect questions correctly.\n  // Lose condition: reach 0 lives (wrongAllowed wrong answers).\n  // Keyboard: 1/2/3 to pick answers, arrows to move selection, Enter to confirm,\n  // Space to begin/resume audio, M to mute, R to restart.\n  // Accessible: container aria-label updated; keyboard controls documented on canvas.\n\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const PADDING = 12; // min 10px per requirements\n  const TARGET_CORRECT = 10;\n  const WRONG_ALLOWED = 3;\n  const FONT_BODY = '16px Arial';\n  const FONT_IMPORTANT = '20px Arial';\n  const FONT_TITLE = '28px \"Segoe UI\", Arial';\n\n  // State\n  let container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Container element #game-of-the-day-stage not found.');\n    return;\n  }\n\n  // Clear container\n  container.innerHTML = '';\n  container.style.position = 'relative';\n  container.setAttribute('role', 'application');\n  container.setAttribute('aria-label', 'Drone Math Adventure. Use number keys 1 to 3 to answer. Press Space to start audio. Press R to restart.');\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.tabIndex = 0; // make focusable\n  canvas.style.outline = 'none';\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Audio\n  let audioCtx = null;\n  let masterGain = null;\n  let humOsc = null;\n  let humGain = null;\n  let audioEnabled = false;\n  let muted = false;\n  let audioInitTried = false;\n\n  function initAudio() {\n    if (audioInitTried) return;\n    audioInitTried = true;\n    try {\n      const AC = window.AudioContext || window.webkitAudioContext;\n      if (!AC) throw new Error('Web Audio API not supported');\n      audioCtx = new AC();\n      masterGain = audioCtx.createGain();\n      masterGain.gain.value = 0.12;\n      masterGain.connect(audioCtx.destination);\n\n      // Gentle hum background using low-frequency oscillator and lowpass\n      humOsc = audioCtx.createOscillator();\n      humOsc.type = 'sine';\n      humOsc.frequency.value = 110; // low\n      humGain = audioCtx.createGain();\n      humGain.gain.value = 0.02;\n      const lowpass = audioCtx.createBiquadFilter();\n      lowpass.type = 'lowpass';\n      lowpass.frequency.value = 400;\n      humOsc.connect(humGain);\n      humGain.connect(lowpass);\n      lowpass.connect(masterGain);\n      humOsc.start();\n\n      audioEnabled = true;\n    } catch (e) {\n      console.warn('Audio initialization failed:', e);\n      audioEnabled = false;\n    }\n  }\n\n  // Utility: play short tone for correct/incorrect feedback\n  function playTone({frequency = 440, type = 'sine', duration = 0.18, volume = 0.15, attack = 0.005, release = 0.08}) {\n    if (!audioEnabled || muted || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const osc = audioCtx.createOscillator();\n      osc.type = type;\n      osc.frequency.setValueAtTime(frequency, now);\n      const gain = audioCtx.createGain();\n      gain.gain.setValueAtTime(0.0001, now);\n      gain.gain.linearRampToValueAtTime(volume, now + attack);\n      gain.gain.linearRampToValueAtTime(0.0001, now + duration - release);\n      osc.connect(gain);\n      gain.connect(masterGain);\n      osc.start(now);\n      osc.stop(now + duration + 0.05);\n      // cleanup handled by gc\n    } catch (e) {\n      console.warn('playTone error:', e);\n    }\n  }\n\n  function playCorrect() {\n    // A little rising arpeggio\n    playTone({frequency: 660, type: 'sine', duration: 0.16, volume: 0.12});\n    setTimeout(() => playTone({frequency: 880, type: 'triangle', duration: 0.12, volume: 0.09}), 80);\n  }\n  function playIncorrect() {\n    playTone({frequency: 220, type: 'sawtooth', duration: 0.26, volume: 0.12});\n    setTimeout(() => playTone({frequency: 170, type: 'sine', duration: 0.12, volume: 0.08}), 120);\n  }\n\n  // Game variables\n  let state = 'intro'; // 'intro'|'playing'|'won'|'lost'\n  let score = 0;\n  let lives = WRONG_ALLOWED;\n  let question = null;\n  let options = [];\n  let correctIndex = 0;\n  let selectedIndex = 0;\n  let droneX = WIDTH / 2;\n  let droneY = HEIGHT / 3;\n  let droneTargetX = droneX;\n  let droneTargetY = droneY;\n  let animations = []; // {type, t0, duration, ...}\n  let spawnStars = []; // positions of collected stars for visuals\n\n  // Timing\n  let lastTime = performance.now();\n\n  // Accessibility: live text feedback via container attribute\n  function announce(text) {\n    container.setAttribute('aria-live', 'polite');\n    container.setAttribute('aria-label', text + '. ' + 'Score ' + score + ', lives ' + lives);\n    // Also draw it briefly on-screen in instructions\n    latestAnnouncement = text;\n    latestAnnouncementTimer = 2400;\n  }\n  let latestAnnouncement = '';\n  let latestAnnouncementTimer = 0;\n\n  // Generate question\n  function makeQuestion() {\n    // For 7-9, mostly addition and subtraction, occasional multiplication\n    const typeRand = Math.random();\n    let a, b, op, correct;\n    if (typeRand < 0.6) {\n      // addition\n      a = Math.floor(Math.random() * 20) + 1; // 1-20\n      b = Math.floor(Math.random() * 20) + 1;\n      op = '+';\n      correct = a + b;\n    } else if (typeRand < 0.9) {\n      // subtraction ensure non-negative\n      a = Math.floor(Math.random() * 20) + 5;\n      b = Math.floor(Math.random() * 15);\n      op = '-';\n      correct = a - b;\n    } else {\n      // simple multiplication\n      a = Math.floor(Math.random() * 8) + 2; // 2-9\n      b = Math.floor(Math.random() * 8) + 2;\n      op = '\u00d7';\n      correct = a * b;\n    }\n    // create options: correct plus two distractors\n    const opts = new Set();\n    opts.add(correct);\n    while (opts.size < 3) {\n      const perturb = Math.floor(Math.random() * 7) - 3; // -3..3\n      let val = correct + perturb;\n      if (val < 0) val = Math.abs(val) + 1;\n      if (val === correct) val = correct + (Math.random() < 0.5 ? 2 : -2);\n      opts.add(val);\n    }\n    const arrayOpts = Array.from(opts);\n    // shuffle\n    for (let i = arrayOpts.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arrayOpts[i], arrayOpts[j]] = [arrayOpts[j], arrayOpts[i]];\n    }\n    correctIndex = arrayOpts.indexOf(correct);\n    options = arrayOpts;\n    question = `${a} ${op} ${b} = ?`;\n    selectedIndex = 0;\n    announce('New question: ' + question);\n  }\n\n  function resetGame() {\n    score = 0;\n    lives = WRONG_ALLOWED;\n    spawnStars = [];\n    animations = [];\n    droneX = WIDTH / 2;\n    droneY = HEIGHT / 3;\n    droneTargetX = droneX;\n    droneTargetY = droneY;\n    latestAnnouncement = '';\n    latestAnnouncementTimer = 0;\n    makeQuestion();\n    state = 'playing';\n    announce('Game started. Answer ' + TARGET_CORRECT + ' questions correctly to win. You have ' + WRONG_ALLOWED + ' lives.');\n  }\n\n  // Hit detection for option boxes (we compute their rects each draw)\n  let optionRects = []; // array of {x,y,w,h}\n\n  // Draw helpers\n  function drawRoundedRect(x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n  }\n\n  function drawBackground() {\n    // calming gradient sky with subtle wacky blobs\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, '#e9f7ff');\n    g.addColorStop(1, '#f7fbff');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // soft clouds (wacky)\n    ctx.fillStyle = 'rgba(255,255,255,0.85)';\n    for (let i = 0; i < 5; i++) {\n      const cx = (i * 160 + (Math.sin(performance.now() / 3000 + i) * 20)) % (WIDTH + 200) - 100;\n      const cy = 60 + i * 10 + Math.sin(performance.now() / 2000 + i) * 8;\n      drawCloud(cx, cy, 60 + (i % 2) * 20);\n    }\n  }\n\n  function drawCloud(cx, cy, size) {\n    ctx.beginPath();\n    ctx.ellipse(cx, cy, size, size * 0.6, 0, 0, Math.PI * 2);\n    ctx.ellipse(cx + size * 0.7, cy + 6, size * 0.8, size * 0.5, 0, 0, Math.PI * 2);\n    ctx.ellipse(cx - size * 0.6, cy + 4, size * 0.7, size * 0.5, 0, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  function drawDrone(x, y, t) {\n    // Wacky drone: body, propellers, googly eyes\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(Math.sin(t / 300) * 0.04);\n    // shadow\n    ctx.beginPath();\n    ctx.ellipse(0, 44, 70, 14, 0, 0, Math.PI * 2);\n    ctx.fillStyle = 'rgba(20,20,20,0.06)';\n    ctx.fill();\n\n    // body\n    ctx.fillStyle = '#8bd3ff';\n    ctx.strokeStyle = '#4a9bbf';\n    ctx.lineWidth = 2;\n    drawRoundedRect(-50, -20, 100, 40, 12);\n\n    // nose\n    ctx.fillStyle = '#6ec3f7';\n    ctx.beginPath();\n    ctx.moveTo(50, 0);\n    ctx.lineTo(70, -10);\n    ctx.lineTo(70, 10);\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n\n    // eyes\n    ctx.fillStyle = '#fff';\n    ctx.beginPath();\n    ctx.ellipse(-20, 0, 12, 12, 0, 0, Math.PI * 2);\n    ctx.ellipse(10, 0, 12, 12, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.fillStyle = '#222';\n    ctx.beginPath();\n    const eyeShift = Math.sin(t / 300) * 2;\n    ctx.ellipse(-20 + eyeShift, 0, 5, 6, 0, 0, Math.PI * 2);\n    ctx.ellipse(10 + eyeShift, 0, 5, 6, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // arms with rotors\n    ctx.strokeStyle = '#5aa7c7';\n    ctx.lineWidth = 6;\n    ctx.beginPath();\n    ctx.moveTo(-40, -10);\n    ctx.lineTo(-90, -40);\n    ctx.moveTo(40, -10);\n    ctx.lineTo(90, -40);\n    ctx.moveTo(-40, 10);\n    ctx.lineTo(-90, 40);\n    ctx.moveTo(40, 10);\n    ctx.lineTo(90, 40);\n    ctx.stroke();\n\n    // rotors (wacky animated)\n    for (let i = 0; i < 4; i++) {\n      const angle = t / 80 + i;\n      const rx = Math.cos(i * Math.PI / 2) * 90;\n      const ry = Math.sin(i * Math.PI / 2) * 40;\n      ctx.save();\n      ctx.translate(rx, ry);\n      ctx.rotate(Math.sin(angle) * 4);\n      ctx.beginPath();\n      ctx.fillStyle = 'rgba(60,60,60,0.8)';\n      ctx.ellipse(0, 0, 30, 6, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n    }\n\n    ctx.restore();\n  }\n\n  function drawStar(x, y, r, filled = true) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.beginPath();\n    for (let i = 0; i < 5; i++) {\n      ctx.lineTo(Math.cos((18 + i * 72) / 180 * Math.PI) * r, -Math.sin((18 + i * 72) / 180 * Math.PI) * r);\n      ctx.lineTo(Math.cos((54 + i * 72) / 180 * Math.PI) * (r / 2.2), -Math.sin((54 + i * 72) / 180 * Math.PI) * (r / 2.2));\n    }\n    ctx.closePath();\n    ctx.fillStyle = filled ? '#ffd166' : 'rgba(255,209,102,0.4)';\n    ctx.fill();\n    ctx.strokeStyle = '#e6b543';\n    ctx.lineWidth = 1;\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  function drawUI(t) {\n    ctx.font = FONT_IMPORTANT;\n    ctx.textBaseline = 'top';\n    ctx.lineWidth = 1;\n\n    // Score top-left with background rectangle\n    const scoreText = 'Stars: ' + score + ' / ' + TARGET_CORRECT;\n    ctx.font = FONT_IMPORTANT;\n    const scoreW = ctx.measureText(scoreText).width;\n    const scoreX = PADDING;\n    const scoreY = PADDING;\n    const scorePad = 8;\n    ctx.fillStyle = 'rgba(255,255,255,0.85)';\n    ctx.strokeStyle = 'rgba(0,0,0,0.06)';\n    ctx.fillRect(scoreX - scorePad, scoreY - scorePad, scoreW + scorePad * 2, 36 + scorePad - 8);\n    ctx.strokeRect(scoreX - scorePad, scoreY - scorePad, scoreW + scorePad * 2, 36 + scorePad - 8);\n    ctx.fillStyle = '#0b5394';\n    ctx.fillText(scoreText, scoreX, scoreY);\n\n    // Lives top-right\n    const livesText = 'Lives: ' + lives;\n    const livesPad = 8;\n    ctx.font = FONT_IMPORTANT;\n    const livesW = ctx.measureText(livesText).width;\n    const livesX = WIDTH - livesW - PADDING;\n    const livesY = PADDING;\n    ctx.fillStyle = 'rgba(255,255,255,0.85)';\n    ctx.fillRect(livesX - livesPad, livesY - livesPad, livesW + livesPad * 2, 36 + livesPad - 8);\n    ctx.strokeStyle = 'rgba(0,0,0,0.06)';\n    ctx.strokeRect(livesX - livesPad, livesY - livesPad, livesW + livesPad * 2, 36 + livesPad - 8);\n    ctx.fillStyle = '#b22222';\n    ctx.fillText(livesText, livesX, livesY);\n\n    // Instructions bottom-center\n    ctx.font = FONT_BODY;\n    ctx.textBaseline = 'bottom';\n    const instr = state === 'intro'\n      ? 'Press Space or Click to Start. Use 1/2/3 to choose, arrows to move selection, Enter to confirm. M to mute, R to restart.'\n      : 'Choose the correct answer! Keys: 1-3 to pick, Enter to confirm. M to mute. R to restart.';\n    const instrW = ctx.measureText(instr).width;\n    const instrX = (WIDTH - instrW) / 2;\n    const instrY = HEIGHT - PADDING;\n    // background rectangle\n    ctx.fillStyle = 'rgba(255,255,255,0.7)';\n    ctx.fillRect(instrX - 10, instrY - 36, instrW + 20, 36 + 12);\n    ctx.fillStyle = '#064273';\n    ctx.fillText(instr, instrX, instrY - 8);\n\n    // Audio visual cue (speaker) near bottom-left\n    const spX = PADDING;\n    const spY = HEIGHT - 60;\n    drawSpeaker(spX, spY, muted ? 0.5 : 1);\n\n    // latest announcement box just above bottom, non-overlapping with instructions (ensure 10px)\n    if (latestAnnouncementTimer > 0 && latestAnnouncement) {\n      ctx.font = FONT_BODY;\n      const ta = latestAnnouncement;\n      const taW = ctx.measureText(ta).width;\n      const taX = (WIDTH - taW) / 2;\n      const taY = instrY - 60;\n      ctx.fillStyle = 'rgba(255,255,255,0.9)';\n      ctx.fillRect(taX - 8, taY - 10, taW + 16, 36);\n      ctx.fillStyle = '#0b4f6c';\n      ctx.fillText(ta, taX, taY + 6);\n    }\n  }\n\n  function drawSpeaker(x, y, alpha) {\n    ctx.save();\n    ctx.globalAlpha = alpha;\n    ctx.fillStyle = '#1f618d';\n    ctx.strokeStyle = '#0b3b59';\n    ctx.lineWidth = 2;\n    // box\n    ctx.fillRect(x - 6, y - 6, 32, 32);\n    ctx.strokeRect(x - 6, y - 6, 32, 32);\n    // speaker icon\n    ctx.beginPath();\n    ctx.moveTo(x + 2, y + 2);\n    ctx.lineTo(x + 10, y + 10);\n    ctx.lineTo(x + 2, y + 18);\n    ctx.closePath();\n    ctx.fillStyle = '#fff';\n    ctx.fill();\n    // waves\n    if (!muted) {\n      ctx.beginPath();\n      ctx.arc(x + 16, y + 10, 8, -0.6, 0.6);\n      ctx.strokeStyle = '#ffd166';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    } else {\n      // draw X for muted\n      ctx.strokeStyle = '#ff6b6b';\n      ctx.beginPath();\n      ctx.moveTo(x + 22, y + 2);\n      ctx.lineTo(x + 8, y + 24);\n      ctx.moveTo(x + 8, y + 2);\n      ctx.lineTo(x + 22, y + 24);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  // Main draw\n  function draw(now) {\n    const dt = now - lastTime;\n    lastTime = now;\n\n    // background\n    drawBackground();\n\n    // drone movement towards target\n    const dx = droneTargetX - droneX;\n    const dy = droneTargetY - droneY;\n    droneX += dx * Math.min(1, 0.02 + Math.sqrt(Math.abs(dx)) * 0.002);\n    droneY += dy * Math.min(1, 0.02 + Math.sqrt(Math.abs(dy)) * 0.002);\n\n    // draw drone\n    drawDrone(droneX, droneY, now);\n\n    // draw collected stars near top-center\n    const starsStartX = WIDTH / 2 - (TARGET_CORRECT * 14) / 2;\n    for (let i = 0; i < TARGET_CORRECT; i++) {\n      const x = starsStartX + i * 14;\n      const y = PADDING + 60;\n      if (i < score) drawStar(x, y, 6, true);\n      else drawStar(x, y, 6, false);\n    }\n\n    // options area - placed below drone, centered\n    ctx.font = FONT_TITLE;\n    ctx.fillStyle = '#073b4c';\n    ctx.textBaseline = 'top';\n    const questionY = HEIGHT / 2 - 60;\n    // draw question inside background rectangle\n    ctx.font = FONT_TITLE;\n    const qW = ctx.measureText(question || '').width;\n    const qX = (WIDTH - qW) / 2;\n    const qPad = 12;\n    ctx.fillStyle = 'rgba(255,255,255,0.92)';\n    ctx.fillRect(qX - qPad, questionY - qPad, qW + qPad * 2, 48 + qPad - 8);\n    ctx.strokeStyle = 'rgba(0,0,0,0.06)';\n    ctx.strokeRect(qX - qPad, questionY - qPad, qW + qPad * 2, 48 + qPad - 8);\n    ctx.fillStyle = '#073b4c';\n    ctx.fillText(question || '', qX, questionY);\n\n    // draw option boxes\n    ctx.font = FONT_BODY;\n    optionRects = [];\n    const optY = questionY + 70;\n    const spacing = 18;\n    // compute widths to ensure no overlap\n    const optionWidths = options.map(o => ctx.measureText((options.indexOf(o)+1) + '. ' + o).width + 24);\n    // total width\n    const totalW = optionWidths.reduce((a, b) => a + b, 0) + spacing * (options.length - 1);\n    let startX = (WIDTH - totalW) / 2;\n    for (let i = 0; i < options.length; i++) {\n      const w = optionWidths[i];\n      const h = 48;\n      const x = startX;\n      const y = optY;\n      // background\n      ctx.fillStyle = (selectedIndex === i) ? 'rgba(139,195,74,0.95)' : 'rgba(255,255,255,0.94)';\n      ctx.fillRect(x, y, w, h);\n      ctx.strokeStyle = 'rgba(0,0,0,0.06)';\n      ctx.strokeRect(x, y, w, h);\n      // text\n      ctx.fillStyle = '#073b4c';\n      ctx.fillText((i + 1) + '. ' + options[i], x + 12, y + 12);\n      // store rect\n      optionRects[i] = {x, y, w, h};\n      startX += w + spacing;\n    }\n\n    // draw small hints for keyboard (non-overlapping)\n    ctx.font = FONT_BODY;\n    const hintText = 'Press 1,2,3 or Click an option. Press Enter to confirm.';\n    const hintW = ctx.measureText(hintText).width;\n    const hintX = (WIDTH - hintW) / 2;\n    const hintY = optY + 70;\n    ctx.fillStyle = 'rgba(255,255,255,0.9)';\n    ctx.fillRect(hintX - 8, hintY - 8, hintW + 16, 36);\n    ctx.fillStyle = '#064273';\n    ctx.fillText(hintText, hintX, hintY + 6);\n\n    // Draw animations (collecting stars, small explosions)\n    animations = animations.filter(a => {\n      const localT = (now - a.t0) / a.duration;\n      if (a.type === 'collect') {\n        // animate star moving from option to star bar\n        const sx = a.sx;\n        const sy = a.sy;\n        const tx = a.tx;\n        const ty = a.ty;\n        const cx = sx + (tx - sx) * easeOutCubic(Math.min(1, localT));\n        const cy = sy + (ty - sy) * easeOutCubic(Math.min(1, localT));\n        drawStar(cx, cy, 8, true);\n        if (localT >= 1) return false;\n        return true;\n      } else if (a.type === 'spark') {\n        // small circles\n        for (let k = 0; k < 6; k++) {\n          const ang = (k / 6) * Math.PI * 2 + a.offset;\n          const r = 10 + localT * 40;\n          const x = a.x + Math.cos(ang) * r;\n          const y = a.y + Math.sin(ang) * r;\n          ctx.beginPath();\n          ctx.fillStyle = `rgba(255, ${140 + k * 10}, 60, ${1 - localT})`;\n          ctx.arc(x, y, 4 * (1 - localT), 0, Math.PI * 2);\n          ctx.fill();\n        }\n        if (localT >= 1) return false;\n        return true;\n      }\n      return false;\n    });\n\n    // victory or game over overlay\n    if (state === 'won' || state === 'lost' || state === 'intro') {\n      // ensure overlay does not cover top UI; place centered\n      const boxW = 520;\n      const boxH = 220;\n      const boxX = (WIDTH - boxW) / 2;\n      const boxY = (HEIGHT - boxH) / 2 - 10;\n      ctx.fillStyle = 'rgba(255,255,255,0.96)';\n      ctx.fillRect(boxX, boxY, boxW, boxH);\n      ctx.strokeStyle = 'rgba(0,0,0,0.06)';\n      ctx.strokeRect(boxX, boxY, boxW, boxH);\n\n      ctx.font = FONT_TITLE;\n      ctx.fillStyle = '#0b3b59';\n      ctx.textBaseline = 'top';\n      const title = state === 'intro' ? 'Drone Math Adventure' : (state === 'won' ? 'YOU WIN!' : 'GAME OVER');\n      const titleW = ctx.measureText(title).width;\n      ctx.fillText(title, boxX + (boxW - titleW) / 2, boxY + 18);\n\n      ctx.font = FONT_BODY;\n      ctx.fillStyle = '#064273';\n      let message = '';\n      if (state === 'intro') {\n        message = 'Help your friendly drone collect ' + TARGET_CORRECT + ' stars by answering math questions.\\nYou can make up to ' + WRONG_ALLOWED + ' mistakes. Press Space or Click to begin.';\n      } else if (state === 'won') {\n        message = 'Great flying! You collected ' + score + ' stars. Press R or Click to play again.';\n      } else {\n        message = 'Oops! Your drone ran out of lives. You collected ' + score + ' stars. Press R or Click to try again.';\n      }\n      // multi-line text draw, ensure spacing\n      const lines = message.split('\\n');\n      let textY = boxY + 72;\n      for (const line of lines) {\n        const lw = ctx.measureText(line).width;\n        ctx.fillText(line, boxX + (boxW - lw) / 2, textY);\n        textY += 26;\n      }\n\n      // restart button rectangle\n      const btnText = 'Restart (R)';\n      ctx.font = FONT_IMPORTANT;\n      const btnW = ctx.measureText(btnText).width + 24;\n      const btnH = 42;\n      const btnX = boxX + (boxW - btnW) / 2;\n      const btnY = boxY + boxH - btnH - 18;\n      ctx.fillStyle = '#8bd3ff';\n      ctx.fillRect(btnX, btnY, btnW, btnH);\n      ctx.strokeStyle = '#4a9bbf';\n      ctx.strokeRect(btnX, btnY, btnW, btnH);\n      ctx.fillStyle = '#073b4c';\n      ctx.fillText(btnText, btnX + 12, btnY + 8);\n\n      // store restart rect for click\n      restartRect = {x: btnX, y: btnY, w: btnW, h: btnH};\n    } else {\n      // no overlay\n      restartRect = null;\n    }\n\n    // draw small credits / keyboard help top center (non overlapping)\n    ctx.font = '14px Arial';\n    ctx.fillStyle = 'rgba(0,0,0,0.45)';\n    const help = 'Keyboard: 1-3 select \u2022 Enter confirm \u2022 M mute \u2022 R restart';\n    const helpW = ctx.measureText(help).width;\n    const helpX = (WIDTH - helpW) / 2;\n    const helpY = PADDING + 4;\n    ctx.fillText(help, helpX, helpY + 24);\n\n    // reduce announcement timer\n    if (latestAnnouncementTimer > 0) latestAnnouncementTimer -= dt;\n\n    // loop\n    requestAnimationFrame(draw);\n  }\n\n  function easeOutCubic(x) {\n    return 1 - Math.pow(1 - x, 3);\n  }\n\n  // Input handlers\n  canvas.addEventListener('keydown', e => {\n    if (e.key === 'm' || e.key === 'M') {\n      muted = !muted;\n      announce(muted ? 'Muted' : 'Sound on');\n      e.preventDefault();\n      return;\n    }\n    if (state === 'intro') {\n      if (e.code === 'Space' || e.key === 'Enter') {\n        // start game and audio\n        try {\n          initAudio();\n          if (audioEnabled && audioCtx && audioCtx.state === 'suspended') {\n            audioCtx.resume();\n          }\n        } catch (e) {\n          console.warn('Audio start error', e);\n        }\n        resetGame();\n        e.preventDefault();\n      }\n      return;\n    }\n    if (state === 'won' || state === 'lost') {\n      if (e.key === 'r' || e.key === 'R' || e.code === 'Space') {\n        // restart\n        try {\n          initAudio();\n        } catch (err) {}\n        resetGame();\n        e.preventDefault();\n      }\n      return;\n    }\n    // playing\n    switch (e.key) {\n      case '1':\n      case '2':\n      case '3':\n        const idx = parseInt(e.key, 10) - 1;\n        if (idx >= 0 && idx < options.length) {\n          selectedIndex = idx;\n          announce('Selected option ' + (idx + 1));\n        }\n        break;\n      case 'ArrowLeft':\n      case 'ArrowUp':\n        selectedIndex = (selectedIndex + options.length - 1) % options.length;\n        break;\n      case 'ArrowRight':\n      case 'ArrowDown':\n        selectedIndex = (selectedIndex + 1) % options.length;\n        break;\n      case 'Enter':\n        confirmSelection();\n        break;\n      case 'r':\n      case 'R':\n        resetGame();\n        break;\n      default:\n        break;\n    }\n  });\n\n  // Mouse click support\n  let restartRect = null;\n  canvas.addEventListener('click', e => {\n    // compute canvas coordinates\n    const rect = canvas.getBoundingClientRect();\n    const cx = e.clientX - rect.left;\n    const cy = e.clientY - rect.top;\n\n    if (state === 'intro') {\n      try {\n        initAudio();\n      } catch (ex) {}\n      resetGame();\n      return;\n    }\n    if (restartRect && cx >= restartRect.x && cx <= restartRect.x + restartRect.w &&\n      cy >= restartRect.y && cy <= restartRect.y + restartRect.h) {\n      resetGame();\n      return;\n    }\n    if (state === 'won' || state === 'lost') {\n      // clicking anywhere restarts\n      resetGame();\n      return;\n    }\n    // check option rects\n    for (let i = 0; i < optionRects.length; i++) {\n      const r = optionRects[i];\n      if (cx >= r.x && cx <= r.x + r.w && cy >= r.y && cy <= r.y + r.h) {\n        selectedIndex = i;\n        confirmSelection();\n        return;\n      }\n    }\n    // click near speaker toggles mute\n    const spX = PADDING;\n    const spY = HEIGHT - 60;\n    if (cx >= spX - 10 && cx <= spX + 32 && cy >= spY - 10 && cy <= spY + 32) {\n      muted = !muted;\n      announce(muted ? 'Muted' : 'Sound unmuted');\n    }\n  });\n\n  function confirmSelection() {\n    if (state !== 'playing') return;\n    const chosen = selectedIndex;\n    const now = performance.now();\n    // animate drone to option for fun\n    const rect = optionRects[chosen];\n    if (rect) {\n      droneTargetX = rect.x + rect.w / 2;\n      droneTargetY = rect.y - 40;\n    }\n    if (chosen === correctIndex) {\n      // correct\n      score++;\n      spawnStars.push({t: now, fromX: rect ? rect.x + rect.w / 2 : droneX, fromY: rect ? rect.y + rect.h / 2 : droneY});\n      // animate collect\n      const tx = WIDTH / 2 - (TARGET_CORRECT * 14) / 2 + (score - 1) * 14;\n      const ty = PADDING + 60;\n      animations.push({type: 'collect', t0: now, duration: 600, sx: rect ? rect.x + rect.w / 2 : droneX, sy: rect ? rect.y + rect.h / 2 : droneY, tx, ty});\n      animations.push({type: 'spark', t0: now, duration: 700, x: rect ? rect.x + rect.w / 2 : droneX, y: rect ? rect.y + rect.h / 2 : droneY, offset: Math.random() * 2});\n      playCorrect();\n      announce('Correct! You have ' + score + ' stars.');\n      if (score >= TARGET_CORRECT) {\n        // win\n        state = 'won';\n        announce('You win! Great job.');\n      } else {\n        // next question after a short delay\n        setTimeout(() => {\n          makeQuestion();\n        }, 700);\n      }\n    } else {\n      // incorrect\n      lives--;\n      animations.push({type: 'spark', t0: now, duration: 700, x: rect ? rect.x + rect.w / 2 : droneX, y: rect ? rect.y + rect.h / 2 : droneY, offset: Math.random() * 2});\n      playIncorrect();\n      announce('Oops! That was not correct. Lives left: ' + lives);\n      if (lives <= 0) {\n        state = 'lost';\n        announce('Game over. Press R to try again.');\n      } else {\n        // flash correct answer visually by small animation\n        setTimeout(() => {\n          // show next question\n          makeQuestion();\n        }, 700);\n      }\n    }\n  }\n\n  // Start animation loop\n  lastTime = performance.now();\n  requestAnimationFrame(draw);\n\n  // Generate a first question for intro display\n  makeQuestion();\n  state = 'intro';\n\n  // Ensure focus\n  setTimeout(() => {\n    try {\n      canvas.focus();\n    } catch (e) {}\n  }, 50);\n\n  // Expose a small debug in case of audio issues\n  window.DroneMathGame = {\n    startAudio: initAudio,\n    isAudioEnabled: () => audioEnabled,\n    mute: (v) => { muted = v; }\n  };\n\n  // Error handling: check audio context resume on gesture if created\n  canvas.addEventListener('mousedown', () => {\n    if (!audioInitTried) {\n      try {\n        initAudio();\n      } catch (e) {}\n    } else if (audioEnabled && audioCtx && audioCtx.state === 'suspended') {\n      audioCtx.resume().catch(() => {});\n    }\n  });\n\n  // Keyboard focus reminder for accessibility\n  canvas.addEventListener('blur', () => {\n    // draw a subtle ring in canvas by announcing\n    latestAnnouncement = 'Canvas lost focus. Click or press Tab to focus the game for keyboard control.';\n    latestAnnouncementTimer = 2000;\n  });\n\n  // Handle page visibility to suspend/resume audio safely\n  document.addEventListener('visibilitychange', () => {\n    if (audioCtx && typeof audioCtx.suspend === 'function') {\n      if (document.hidden) audioCtx.suspend().catch(() => {});\n      else audioCtx.resume().catch(() => {});\n    }\n  });\n\n  // Final safety: catch uncaught errors\n  window.addEventListener('error', (ev) => {\n    console.error('Unhandled error in Drone Math Adventure:', ev.error || ev.message);\n    announce('An unexpected error occurred. Try refreshing the page.');\n  });\n})();\n---\n",
  "improve_response_tokens": 19434,
  "formatted_code": true,
  "formatting_response_tokens": 20740,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}