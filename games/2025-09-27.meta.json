{
  "generated_date": "2025-09-27",
  "generated_timestamp": "2025-09-27T00:25:25.202543",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8359,
  "game_filename": "2025-09-27.js",
  "game_size_bytes": 25364,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Machine Math - Educational Game for ages 7-9\n// Renders into the element with ID \"game-of-the-day-stage\"\n// All visuals drawn on canvas. Sound via Web Audio API. Accessible instructions added to DOM.\n// Written with clean modern JavaScript and comments.\n\n(() => {\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const MAX_LEVELS = 5;\n  const CONTAINER_ID = \"game-of-the-day-stage\";\n\n  // Utility helpers\n  const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));\n\n  // Find container\n  const container = document.getElementById(CONTAINER_ID);\n  if (!container) {\n    console.error(\"Game container not found: #\" + CONTAINER_ID);\n    return;\n  }\n\n  // Clear container and set up accessible instructions node\n  container.innerHTML = \"\";\n  container.style.position = \"relative\";\n  container.setAttribute(\"aria-label\", \"Machine Math game. A child-friendly math puzzle with machines and number tiles.\");\n  const textInstructions = document.createElement(\"div\");\n  textInstructions.style.position = \"absolute\";\n  textInstructions.style.left = \"8px\";\n  textInstructions.style.top = \"8px\";\n  textInstructions.style.maxWidth = \"440px\";\n  textInstructions.style.background = \"rgba(255,255,255,0.0)\";\n  textInstructions.style.color = \"#000\";\n  textInstructions.style.fontFamily = \"sans-serif\";\n  textInstructions.style.fontSize = \"12px\";\n  textInstructions.style.lineHeight = \"1.2\";\n  textInstructions.setAttribute(\"role\", \"region\");\n  textInstructions.setAttribute(\"aria-live\", \"polite\");\n  textInstructions.innerText =\n    \"Machine Math: Help power the silly machines! Use mouse or keyboard. Arrow keys to move, Enter or Space to pick a tile, Backspace to remove, P to press the power button. Match the tiles to the target sum shown on the machine. Complete all machines to win!\";\n  container.appendChild(textInstructions);\n\n  // Create canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.border = \"2px solid #223\";\n  canvas.style.display = \"block\";\n  canvas.style.margin = \"0 auto\";\n  canvas.style.background = \"#F6FBFF\";\n  canvas.setAttribute(\"role\", \"img\");\n  canvas.setAttribute(\"aria-label\", \"Game canvas for Machine Math\");\n  container.appendChild(canvas);\n  const ctx = canvas.getContext(\"2d\");\n\n  // Audio setup with error handling\n  let audioCtx = null;\n  let bgGain = null;\n  let bgOsc = null;\n  let masterGain = null;\n  let clickGain = null;\n  let playingBackground = false;\n\n  function initAudio() {\n    try {\n      const AudioContext = window.AudioContext || window.webkitAudioContext;\n      if (!AudioContext) throw new Error(\"Web Audio API not supported in this browser.\");\n      audioCtx = new AudioContext();\n      masterGain = audioCtx.createGain();\n      masterGain.gain.value = 0.9;\n      masterGain.connect(audioCtx.destination);\n\n      // Background gentle hum - two detuned oscillators through lowpass\n      bgGain = audioCtx.createGain();\n      bgGain.gain.value = 0.04;\n      const filter = audioCtx.createBiquadFilter();\n      filter.type = \"lowpass\";\n      filter.frequency.value = 600;\n      filter.Q.value = 0.7;\n\n      bgOsc = audioCtx.createOscillator();\n      bgOsc.type = \"sine\";\n      bgOsc.frequency.value = 110; // low hum\n      const bgOsc2 = audioCtx.createOscillator();\n      bgOsc2.type = \"sine\";\n      bgOsc2.frequency.value = 115;\n\n      bgOsc.connect(bgGain);\n      bgOsc2.connect(bgGain);\n      bgGain.connect(filter);\n      filter.connect(masterGain);\n\n      // gentle tremolo via gain automation\n      const lfo = audioCtx.createOscillator();\n      const lfoGain = audioCtx.createGain();\n      lfo.frequency.value = 0.12;\n      lfoGain.gain.value = 0.03;\n      lfo.connect(lfoGain);\n      lfoGain.connect(bgGain.gain);\n\n      // click gain for short sounds\n      clickGain = audioCtx.createGain();\n      clickGain.gain.value = 0.9;\n      clickGain.connect(masterGain);\n\n      // start oscillators on user gesture (we'll start when resumeAudio called)\n      bgOsc.start();\n      bgOsc2.start();\n      lfo.start();\n      playingBackground = true;\n    } catch (err) {\n      console.error(\"Audio init error:\", err);\n      audioCtx = null;\n    }\n  }\n\n  // Call initAudio but be prepared to resume on user gesture\n  initAudio();\n\n  function resumeAudio() {\n    if (!audioCtx) initAudio();\n    if (!audioCtx) return;\n    if (audioCtx.state === \"suspended\") {\n      audioCtx.resume().catch((e) => console.warn(\"Audio resume failed:\", e));\n    }\n  }\n\n  function playTone({ frequency = 440, type = \"sine\", duration = 0.15, volume = 0.12, attack = 0.01, release = 0.06, filterFreq = 4000 }) {\n    if (!audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const osc = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      const filt = audioCtx.createBiquadFilter();\n\n      osc.type = type;\n      osc.frequency.value = frequency;\n      filt.type = \"lowpass\";\n      filt.frequency.value = filterFreq;\n\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.linearRampToValueAtTime(volume, now + attack);\n      g.gain.linearRampToValueAtTime(0.0001, now + duration - release);\n\n      osc.connect(filt);\n      filt.connect(g);\n      g.connect(clickGain);\n\n      osc.start(now);\n      osc.stop(now + duration + 0.02);\n    } catch (err) {\n      console.warn(\"playTone error:\", err);\n    }\n  }\n\n  function playCorrect() {\n    resumeAudio();\n    // pleasant rising triad gliss\n    playTone({ frequency: 660, type: \"sine\", duration: 0.14, volume: 0.12, filterFreq: 900 });\n    setTimeout(() => playTone({ frequency: 880, type: \"sawtooth\", duration: 0.12, volume: 0.12, filterFreq: 1200 }), 80);\n    setTimeout(() => playTone({ frequency: 990, type: \"triangle\", duration: 0.16, volume: 0.12, filterFreq: 1500 }), 160);\n  }\n\n  function playIncorrect() {\n    resumeAudio();\n    // low buzz with quick decay\n    playTone({ frequency: 130, type: \"square\", duration: 0.26, volume: 0.12, filterFreq: 900 });\n  }\n\n  function playClick() {\n    resumeAudio();\n    playTone({ frequency: 420, type: \"sine\", duration: 0.08, volume: 0.12, filterFreq: 1200 });\n  }\n\n  // Game state\n  let level = 1;\n  let target = 0;\n  let tiles = []; // array of numbers\n  let selectedIndices = new Set();\n  let attempts = 0;\n  let score = 0;\n  let message = \"Welcome! Press Space or click a tile to select. Press P to power the machine.\";\n  let mouse = { x: 0, y: 0, down: false };\n  let focusedTile = 0; // for keyboard navigation\n  let powerButton = { x: WIDTH - 140, y: HEIGHT - 110, w: 110, h: 70 };\n\n  // Generate level: target sum and tiles\n  function generateLevel(l) {\n    // Difficulty scales: start with small sums, increase targets and number of tiles\n    const tileCount = clamp(4 + Math.floor(l / 2), 4, 9);\n    // target between 6 and 20 + l*3\n    target = randInt(6 + l * 1, 10 + l * 3);\n    // Create tiles that include at least one valid combination\n    tiles = [];\n    // ensure at least 2-3 tiles sum to target\n    const comboSize = clamp(2 + (l % 3), 2, 4);\n    let combo = [];\n    // build combo numbers\n    let remaining = target;\n    for (let i = 0; i < comboSize - 1; i++) {\n      const maxPart = Math.max(1, Math.floor(remaining / (comboSize - i)));\n      const part = randInt(1, maxPart);\n      combo.push(part);\n      remaining -= part;\n    }\n    combo.push(remaining);\n    // Fill tiles with combo and other randoms\n    combo.forEach((n) => tiles.push(n));\n    while (tiles.length < tileCount) {\n      tiles.push(randInt(1, Math.max(6, target - 1)));\n    }\n    // Shuffle tiles\n    for (let i = tiles.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [tiles[i], tiles[j]] = [tiles[j], tiles[i]];\n    }\n    selectedIndices.clear();\n    attempts = 0;\n    focusedTile = 0;\n    message = `Level ${l}: Make the machine target ${target}.`;\n  }\n\n  // Start game\n  function startGame() {\n    level = 1;\n    score = 0;\n    generateLevel(level);\n    running = true;\n  }\n\n  // Game interactions\n  function toggleSelectIndex(idx) {\n    if (idx < 0 || idx >= tiles.length) return;\n    if (selectedIndices.has(idx)) {\n      selectedIndices.delete(idx);\n      playClick();\n    } else {\n      selectedIndices.add(idx);\n      playClick();\n    }\n    attempts++;\n  }\n\n  function submitPower() {\n    // sum selected\n    const sum = Array.from(selectedIndices).reduce((acc, i) => acc + tiles[i], 0);\n    if (sum === target) {\n      // success animation and advance\n      score += 10 + Math.max(0, 5 - attempts);\n      playCorrect();\n      message = \"Perfect! Machine powered up! Moving to next machine...\";\n      // small celebration animation trigger\n      triggerFireworks();\n      setTimeout(() => {\n        level++;\n        if (level > MAX_LEVELS) {\n          message = `You powered all machines! Score: ${score}. Press R to play again.`;\n          running = false;\n        } else {\n          generateLevel(level);\n        }\n      }, 1100);\n    } else {\n      // incorrect\n      playIncorrect();\n      message = `Hmm! Selected sum is ${sum}. Try again!`;\n      // subtle shake or visual cue\n      shakeStart = performance.now();\n      // do not remove selections automatically to encourage retry\n    }\n  }\n\n  // Visual state for wacky calming machines\n  function drawBackground() {\n    // Soft gradient sky\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, \"#EAF6FF\");\n    g.addColorStop(1, \"#F6FBFF\");\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // soft floating bubbles\n    for (let i = 0; i < 6; i++) {\n      const bx = (i * 137) % WIDTH + 50;\n      const by = ((i * 73) % HEIGHT) + 30;\n      const r = 20 + (i % 3) * 6;\n      ctx.beginPath();\n      ctx.fillStyle = \"rgba(200,230,255,0.22)\";\n      ctx.arc(bx + Math.sin((time / 1000) + i) * 12, by + Math.cos((time / 1400) + i) * 7, r, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n\n  function drawMachine() {\n    // Machine body - whimsical shapes\n    const mx = WIDTH / 2;\n    const my = 120;\n    // base\n    ctx.fillStyle = \"#F0E9FF\";\n    ctx.strokeStyle = \"#664466\";\n    ctx.lineWidth = 3;\n    roundRect(ctx, mx - 220, my - 30, 440, 160, 18, true, true);\n    // screen\n    ctx.fillStyle = \"#111a2b\";\n    roundRect(ctx, mx - 180, my - 10, 260, 90, 12, true, true);\n    // target display\n    ctx.fillStyle = \"#D1F0FF\";\n    roundRect(ctx, mx + 40, my - 0, 100, 54, 8, true, true);\n    ctx.fillStyle = \"#004b66\";\n    ctx.font = \"28px Comic Sans MS, Arial\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(`TARGET`, mx + 90, my + 8);\n    ctx.font = \"36px Comic Sans MS, Arial\";\n    ctx.fillStyle = \"#003a4d\";\n    ctx.fillText(`${target}`, mx + 90, my + 40);\n\n    // pipes and knobs\n    for (let i = 0; i < 3; i++) {\n      const px = mx - 180 + i * 140;\n      ctx.fillStyle = \"#c9e6ff\";\n      roundRect(ctx, px, my + 60, 80, 24, 8, true, true);\n      // knob\n      ctx.beginPath();\n      ctx.fillStyle = \"#FFEAAD\";\n      ctx.arc(px + 12, my + 72, 10, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n    }\n\n    // power socket with wacky eyes\n    ctx.fillStyle = \"#FFD8EE\";\n    ctx.beginPath();\n    ctx.ellipse(mx + 180, my + 40, 42, 34, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = \"#AA5577\";\n    ctx.stroke();\n\n    // eyes\n    ctx.fillStyle = \"#fff\";\n    ctx.beginPath();\n    ctx.arc(mx + 170, my + 30, 8, 0, Math.PI * 2);\n    ctx.arc(mx + 190, my + 32, 8, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = \"#111\";\n    ctx.beginPath();\n    ctx.arc(mx + 170, my + 30, 3, 0, Math.PI * 2);\n    ctx.arc(mx + 190, my + 32, 3, 0, Math.PI * 2);\n    ctx.fill();\n\n    // power button (draw as separate interactive area)\n    ctx.fillStyle = \"#2b5235\";\n    roundRect(ctx, powerButton.x, powerButton.y, powerButton.w, powerButton.h, 10, true, true);\n    // if keyboard focus is on power (when no tile focused?) show highlight - we'll show when focusedTile equals -1\n    if (focusedTile === -1) {\n      ctx.strokeStyle = \"#FFE07A\";\n      ctx.lineWidth = 4;\n      roundRect(ctx, powerButton.x - 4, powerButton.y - 4, powerButton.w + 8, powerButton.h + 8, 14, false, true);\n    }\n    ctx.fillStyle = \"#BFF0AD\";\n    ctx.font = \"22px Comic Sans MS, Arial\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"POWER\", powerButton.x + powerButton.w / 2, powerButton.y + 42);\n  }\n\n  // draw tiles (number tiles)\n  function drawTiles() {\n    const areaX = 36;\n    const areaY = 260;\n    const tileW = 84;\n    const tileH = 64;\n    const gap = 12;\n    for (let i = 0; i < tiles.length; i++) {\n      const col = i % 5;\n      const row = Math.floor(i / 5);\n      const x = areaX + col * (tileW + gap);\n      const y = areaY + row * (tileH + gap);\n      const isSelected = selectedIndices.has(i);\n      const isFocused = (focusedTile === i);\n      // tile background with wacky patterns\n      ctx.save();\n      // subtle rotation for fun\n      const wobble = Math.sin((i * 1234 + time / 120) / 20) * 0.02;\n      ctx.translate(x + tileW / 2, y + tileH / 2);\n      ctx.rotate(wobble);\n      ctx.translate(-(x + tileW / 2), -(y + tileH / 2));\n      // fill\n      ctx.fillStyle = isSelected ? \"#FFF7D6\" : \"#FFFFFF\";\n      roundRect(ctx, x, y, tileW, tileH, 12, true, true);\n      // pattern\n      ctx.fillStyle = isSelected ? \"rgba(120,180,255,0.06)\" : \"rgba(100,120,160,0.04)\";\n      ctx.fillRect(x + 6, y + 6, tileW - 12, tileH - 12);\n      // border\n      ctx.strokeStyle = isFocused ? \"#FFB26B\" : \"#6b6b6b\";\n      ctx.lineWidth = isFocused ? 3 : 2;\n      roundRect(ctx, x, y, tileW, tileH, 12, false, true);\n      // number\n      ctx.fillStyle = \"#223\";\n      ctx.font = \"28px Comic Sans MS, Arial\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(`${tiles[i]}`, x + tileW / 2, y + tileH / 2 + 10);\n      ctx.restore();\n    }\n  }\n\n  // draw HUD\n  function drawHUD() {\n    // Title\n    ctx.fillStyle = \"#223\";\n    ctx.font = \"24px Comic Sans MS, Arial\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(\"Machine Math\", 18, 32);\n\n    // Score and level\n    ctx.font = \"16px Arial\";\n    ctx.fillStyle = \"#224\";\n    ctx.fillText(`Level: ${level} / ${MAX_LEVELS}`, WIDTH - 180, 28);\n    ctx.fillText(`Score: ${score}`, WIDTH - 180, 48);\n\n    // message box\n    ctx.fillStyle = \"rgba(255,255,255,0.8)\";\n    roundRect(ctx, 12, HEIGHT - 76, 460, 64, 10, true, true);\n    ctx.fillStyle = \"#253\";\n    ctx.font = \"14px Arial\";\n    ctx.textAlign = \"left\";\n    wrapText(ctx, message, 24, HEIGHT - 52, 440, 18);\n  }\n\n  // Show current selected sum\n  function drawSelectedSummary() {\n    const sum = Array.from(selectedIndices).reduce((acc, i) => acc + tiles[i], 0);\n    ctx.fillStyle = \"#002b2b\";\n    ctx.font = \"20px Comic Sans MS, Arial\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(`Selected sum: ${sum}`, 20, HEIGHT - 100);\n\n    // also provide auditory icon indicator (speaker) that toggles audio\n    // Draw small speaker icon that indicates audio is available or not\n    ctx.save();\n    const sx = WIDTH - 34;\n    const sy = 20;\n    ctx.fillStyle = audioCtx ? \"#3a7\" : \"#ccc\";\n    ctx.beginPath();\n    ctx.moveTo(sx - 12, sy - 6);\n    ctx.lineTo(sx - 4, sy - 6);\n    ctx.lineTo(sx + 4, sy - 12);\n    ctx.lineTo(sx + 4, sy + 12);\n    ctx.lineTo(sx - 4, sy + 6);\n    ctx.lineTo(sx - 12, sy + 6);\n    ctx.closePath();\n    ctx.fill();\n    ctx.strokeStyle = \"#224\";\n    ctx.stroke();\n    if (!audioCtx) {\n      // draw mute cross\n      ctx.strokeStyle = \"#900\";\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(sx - 10, sy - 10);\n      ctx.lineTo(sx + 10, sy + 10);\n      ctx.moveTo(sx + 10, sy - 10);\n      ctx.lineTo(sx - 10, sy + 10);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  // Helpers for canvas shapes and text wrapping\n  function roundRect(ctx, x, y, w, h, r, fill, stroke) {\n    if (typeof r === \"undefined\") r = 5;\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  function wrapText(context, text, x, y, maxWidth, lineHeight) {\n    const words = text.split(\" \");\n    let line = \"\";\n    let testLine;\n    for (let n = 0; n < words.length; n++) {\n      testLine = line + words[n] + \" \";\n      const metrics = context.measureText(testLine);\n      if (metrics.width > maxWidth && n > 0) {\n        context.fillText(line, x, y);\n        line = words[n] + \" \";\n        y += lineHeight;\n      } else {\n        line = testLine;\n      }\n    }\n    context.fillText(line, x, y);\n  }\n\n  // Mouse and keyboard handling\n  canvas.addEventListener(\"mousemove\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);\n    mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);\n  });\n\n  canvas.addEventListener(\"mousedown\", (e) => {\n    mouse.down = true;\n    resumeAudio();\n    // check tile clicked or power pressed\n    const clicked = hitTest(mouse.x, mouse.y);\n    if (clicked.type === \"tile\") {\n      toggleSelectIndex(clicked.index);\n      focusedTile = clicked.index;\n    } else if (clicked.type === \"power\") {\n      focusedTile = -1;\n      submitPower();\n    } else {\n      playClick();\n    }\n  });\n\n  canvas.addEventListener(\"mouseup\", () => {\n    mouse.down = false;\n  });\n\n  // keyboard interactions\n  window.addEventListener(\"keydown\", (e) => {\n    // Allow keyboard only when game running or after game ends\n    if (e.key === \"r\" || e.key === \"R\") {\n      e.preventDefault();\n      startGame();\n      return;\n    }\n    if (e.key === \"p\" || e.key === \"P\") {\n      e.preventDefault();\n      submitPower();\n      return;\n    }\n    if (e.key === \" \" || e.key === \"Enter\") {\n      e.preventDefault();\n      // select focused tile or if focus is power, submit\n      if (focusedTile === -1) {\n        submitPower();\n      } else {\n        toggleSelectIndex(focusedTile);\n      }\n      return;\n    }\n    if (e.key === \"Backspace\") {\n      e.preventDefault();\n      // remove last selected\n      const arr = Array.from(selectedIndices);\n      if (arr.length) {\n        const last = arr[arr.length - 1];\n        selectedIndices.delete(last);\n        playClick();\n      } else {\n        message = \"No tiles selected.\";\n      }\n      return;\n    }\n    // arrow navigation\n    if ([\"ArrowLeft\", \"ArrowRight\", \"ArrowUp\", \"ArrowDown\"].includes(e.key)) {\n      e.preventDefault();\n      moveFocus(e.key);\n      return;\n    }\n    // number keys quick select\n    if (/^[0-9]$/.test(e.key)) {\n      // choose a tile with this number that is not selected yet\n      const num = parseInt(e.key, 10);\n      let found = -1;\n      for (let i = 0; i < tiles.length; i++) {\n        if (tiles[i] === num && !selectedIndices.has(i)) {\n          found = i;\n          break;\n        }\n      }\n      if (found >= 0) {\n        focusedTile = found;\n        toggleSelectIndex(found);\n      } else {\n        message = `No unselected tile with number ${num}.`;\n        playIncorrect();\n      }\n    }\n  });\n\n  function moveFocus(key) {\n    if (focusedTile === -1) {\n      // from power, go to last tile\n      focusedTile = tiles.length - 1;\n      return;\n    }\n    if (tiles.length === 0) return;\n    const cols = 5;\n    const col = focusedTile % cols;\n    const row = Math.floor(focusedTile / cols);\n    let newIndex = focusedTile;\n    if (key === \"ArrowLeft\") {\n      if (col > 0) newIndex = focusedTile - 1;\n    } else if (key === \"ArrowRight\") {\n      if (col < cols - 1 && focusedTile + 1 < tiles.length) newIndex = focusedTile + 1;\n      else newIndex = -1; // move to power\n    } else if (key === \"ArrowUp\") {\n      if (row > 0) newIndex = focusedTile - cols;\n    } else if (key === \"ArrowDown\") {\n      if (row < Math.ceil(tiles.length / cols) - 1 && focusedTile + cols < tiles.length) newIndex = focusedTile + cols;\n      else newIndex = -1; // to power\n    }\n    if (newIndex === -1) focusedTile = -1;\n    else focusedTile = clamp(newIndex, 0, tiles.length - 1);\n    playClick();\n  }\n\n  // Hit testing for mouse events\n  function hitTest(mxPos, myPos) {\n    // tiles\n    const areaX = 36;\n    const areaY = 260;\n    const tileW = 84;\n    const tileH = 64;\n    const gap = 12;\n    for (let i = 0; i < tiles.length; i++) {\n      const col = i % 5;\n      const row = Math.floor(i / 5);\n      const x = areaX + col * (tileW + gap);\n      const y = areaY + row * (tileH + gap);\n      if (mxPos >= x && mxPos <= x + tileW && myPos >= y && myPos <= y + tileH) {\n        return { type: \"tile\", index: i };\n      }\n    }\n    // power button\n    if (mxPos >= powerButton.x && mxPos <= powerButton.x + powerButton.w && myPos >= powerButton.y && myPos <= powerButton.y + powerButton.h) {\n      return { type: \"power\" };\n    }\n    return { type: \"none\" };\n  }\n\n  // Small fireworks for celebration\n  let sparks = [];\n  let fireworksActive = false;\n  function triggerFireworks() {\n    fireworksActive = true;\n    sparks = [];\n    const centerX = WIDTH / 2;\n    const centerY = 140;\n    for (let s = 0; s < 36; s++) {\n      const angle = (Math.PI * 2 * s) / 36;\n      const speed = 0.6 + Math.random() * 2.2;\n      sparks.push({\n        x: centerX,\n        y: centerY,\n        vx: Math.cos(angle) * speed,\n        vy: Math.sin(angle) * speed - 0.6,\n        life: 0.6 + Math.random() * 0.6,\n        age: 0,\n        color: `hsl(${Math.floor(Math.random() * 360)}, 70%, 60%)`,\n      });\n    }\n    setTimeout(() => {\n      fireworksActive = false;\n    }, 900);\n  }\n\n  function updateSparks(dt) {\n    for (let s of sparks) {\n      s.age += dt;\n      s.x += s.vx * dt * 140;\n      s.y += s.vy * dt * 140;\n      s.vy += 0.6 * dt * 80; // gravity\n    }\n    sparks = sparks.filter((p) => p.age < p.life);\n  }\n\n  function drawSparks() {\n    for (let s of sparks) {\n      const alpha = 1 - s.age / s.life;\n      ctx.fillStyle = s.color;\n      ctx.globalAlpha = alpha;\n      ctx.beginPath();\n      ctx.arc(s.x, s.y, 4 + 3 * (1 - alpha), 0, Math.PI * 2);\n      ctx.fill();\n      ctx.globalAlpha = 1;\n    }\n  }\n\n  // Small shake effect\n  let shakeStart = 0;\n\n  // Main loop\n  let lastTime = performance.now();\n  let time = 0;\n  let running = true;\n\n  function gameLoop(now) {\n    const dt = Math.min(0.06, (now - lastTime) / 1000);\n    lastTime = now;\n    time += now - (lastTime - (now - lastTime)); // small consistent time\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // Apply shake when wrong submit\n    let dx = 0;\n    let dy = 0;\n    if (shakeStart > 0) {\n      const t = (performance.now() - shakeStart) / 300;\n      if (t < 1) {\n        dx = Math.sin(t * 24) * 4 * (1 - t);\n        dy = Math.cos(t * 18) * 3 * (1 - t);\n      } else {\n        shakeStart = 0;\n      }\n    }\n    ctx.save();\n    ctx.translate(dx, dy);\n\n    drawBackground();\n    drawMachine();\n    drawTiles();\n    drawHUD();\n    drawSelectedSummary();\n\n    if (fireworksActive) {\n      updateSparks(dt);\n      drawSparks();\n    }\n\n    // If game ended, show overlay\n    if (!running && level > MAX_LEVELS) {\n      ctx.fillStyle = \"rgba(10, 10, 20, 0.6)\";\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n      ctx.fillStyle = \"#FFF\";\n      ctx.font = \"32px Comic Sans MS, Arial\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(\"All Machines Powered!\", WIDTH / 2, HEIGHT / 2 - 20);\n      ctx.font = \"20px Arial\";\n      ctx.fillText(`Your Score: ${score}`, WIDTH / 2, HEIGHT / 2 + 20);\n      ctx.font = \"16px Arial\";\n      ctx.fillText(\"Press R to play again.\", WIDTH / 2, HEIGHT / 2 + 56);\n    }\n\n    ctx.restore();\n\n    requestAnimationFrame(gameLoop);\n  }\n\n  // Start\n  generateLevel(level);\n  requestAnimationFrame(gameLoop);\n\n  // Start audio on first user gesture; also show accessible control\n  function setupFirstGesture() {\n    const clickHandler = () => {\n      resumeAudio();\n      canvas.removeEventListener(\"click\", clickHandler);\n    };\n    canvas.addEventListener(\"click\", clickHandler);\n  }\n  setupFirstGesture();\n\n  // Initialize a few UI hints and ensure accessible text updates on state change\n  const srStatus = document.createElement(\"div\");\n  srStatus.style.position = \"absolute\";\n  srStatus.style.left = \"8px\";\n  srStatus.style.top = \"380px\";\n  srStatus.style.width = \"1px\";\n  srStatus.style.height = \"1px\";\n  srStatus.style.overflow = \"hidden\";\n  srStatus.style.clip = \"rect(1px, 1px, 1px, 1px)\";\n  srStatus.setAttribute(\"aria-live\", \"polite\");\n  container.appendChild(srStatus);\n\n  // Periodically update srStatus to reflect game state for screen readers\n  setInterval(() => {\n    const sum = Array.from(selectedIndices).reduce((acc, i) => acc + tiles[i], 0);\n    srStatus.innerText = `Level ${level}. Target ${target}. Selected sum ${sum}. ${message}`;\n  }, 900);\n\n  // Expose some debug functions in case of console usage (non-essential)\n  window.machineMath = {\n    restart: startGame,\n    playTestSound: () => {\n      playClick();\n    },\n  };\n\n  // Good practice: handle page visibility to suspend audio if tab is hidden\n  document.addEventListener(\"visibilitychange\", () => {\n    if (!audioCtx) return;\n    if (document.hidden) {\n      if (audioCtx.state === \"running\") audioCtx.suspend().catch(() => {});\n    } else {\n      if (audioCtx.state === \"suspended\") audioCtx.resume().catch(() => {});\n    }\n  });\n\n  // On load, provide short greeting\n  message = \"Ready! Use tiles to match the target and press Power. You can use keyboard or mouse.\";\n\n})();\n---\n",
  "improve_response_tokens": 18454,
  "formatted_code": true,
  "formatting_response_tokens": 19685,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}