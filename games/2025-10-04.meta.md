# Game of the Day - 2025-10-04

## Metadata
- **Generated Date:** 2025-10-04
- **Generated Time:** 2025-10-04T00:24:34.824683
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-10-04.js
- **File Size:** 25858 bytes
- **Tokens Used:** 8970

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-10-04.js` - The playable game
- `2025-10-04.meta.json` - Machine-readable metadata
- `2025-10-04.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 17800

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 19658

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Machine Mix-Up - Educational Math Game for Ages 7-9
// Renders inside element with id 'game-of-the-day-stage'.
// All visuals drawn on a canvas 720x480. Sounds via Web Audio API oscillators.
// Keyboard controls, accessible labels, audio error handling, and beatable levels.

// Immediately-invoked function to avoid leaking globals
(function () {
  // Find container element
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Game container with id "game-of-the-day-stage" not found.');
    return;
  }

  // Clear container and create canvas
  container.innerHTML = '';
  container.style.position = 'relative';
  const canvas = document.createElement('canvas');
  canvas.width = 720;
  canvas.height = 480;
  canvas.style.width = '720px';
  canvas.style.height = '480px';
  canvas.style.display = 'block';
  canvas.style.outline = 'none';
  canvas.setAttribute('role', 'img');
  canvas.setAttribute('aria-label', 'Machine Mix-Up math game. Use arrow keys to move, space to load a number, Enter to run the machine.');
  canvas.setAttribute('tabindex', '0'); // focusable for keyboard
  container.appendChild(canvas);

  // Create hidden accessible instructions for screen readers
  const srInstructions = document.createElement('div');
  srInstructions.style.position = 'absolute';
  srInstructions.style.left = '-10000px';
  srInstructions.style.top = 'auto';
  srInstructions.style.width = '1px';
  srInstructions.style.height = '1px';
  srInstructions.style.overflow = 'hidden';
  srInstructions.setAttribute('aria-hidden', 'false');
  srInstructions.id = 'machine-mixup-instructions';
  srInstructions.innerText =
    'Machine Mix-Up. Collect three number tiles from the conveyor by moving the selector with left and right arrows and pressing space to load each into the machine. ' +
    'Press Enter to run the machine. Try to make the result match the target number. Press Backspace to remove the last loaded tile. Press R to reset, M to toggle sound.';
  container.appendChild(srInstructions);

  const ctx = canvas.getContext('2d', { alpha: false });

  // Game constants
  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;
  const CONVEYOR_Y = 330;
  const TILE_WIDTH = 72;
  const TILE_HEIGHT = 64;
  const NUM_TILES = 8; // number of tiles on conveyor
  const SLOTS = 3;
  const BG_COLORS = ['#EAF6F6', '#F7F3FF']; // calming gradient
  const MACHINE_COLOR = '#5C9EA3';
  const ACCENT_COLOR = '#FFB86B';
  const TEXT_COLOR = '#21333B';

  // Game state
  let gameState = {
    tiles: [], // {value, x, y, sx (speed), id}
    selectorIndex: 0,
    slots: [null, null, null],
    currentSlotIndex: 0,
    target: 0,
    ops: [], // two ops for machine: ['+', '-', '×']
    message: 'Load three tiles then press Enter to run the machine.',
    level: 1,
    attempts: 0,
    solvedLevels: 0,
    playing: true,
    audioEnabled: false,
    soundMuted: false,
    lastRunResult: null,
  };

  // Audio setup
  let audioContext = null;
  let masterGain = null;
  let bgOsc = null;
  let bgGain = null;
  let bgLFO = null;

  // Helper: Create Audio Context with error handling
  function createAudioContext() {
    if (audioContext) return audioContext;
    try {
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      audioContext = new AudioCtx();
      masterGain = audioContext.createGain();
      masterGain.gain.value = 0.0; // start silent until user toggles
      masterGain.connect(audioContext.destination);

      // Background soothing sound: low triangle with slow LFO to filter frequency
      bgOsc = audioContext.createOscillator();
      bgOsc.type = 'sine';
      bgOsc.frequency.value = 110; // low pitch
      bgGain = audioContext.createGain();
      bgGain.gain.value = 0.02; // very gentle
      bgOsc.connect(bgGain);
      bgGain.connect(masterGain);

      // LFO to modulate bg frequency slightly
      try {
        bgLFO = audioContext.createOscillator();
        const lfoGain = audioContext.createGain();
        bgLFO.frequency.value = 0.08; // very slow wobble
        lfoGain.gain.value = 10;
        bgLFO.connect(lfoGain);
        lfoGain.connect(bgOsc.frequency);
        bgLFO.start();
      } catch (e) {
        // Not critical; continue without LFO
        console.warn('LFO not available:', e);
      }

      bgOsc.start();
      gameState.audioEnabled = true;
      updateAudioVisualCue();
      return audioContext;
    } catch (e) {
      console.warn('AudioContext creation failed or is disallowed by browser:', e);
      audioContext = null;
      gameState.audioEnabled = false;
      return null;
    }
  }

  // Toggle sound on/off
  function setSoundMuted(mute) {
    gameState.soundMuted = !!mute;
    if (!audioContext && !mute) {
      // Try to create audio context on demand
      createAudioContext();
    }
    if (masterGain) {
      masterGain.gain.value = gameState.soundMuted ? 0.0 : 0.6;
    }
    updateAudioVisualCue();
  }

  // Visual cue: show speaker icon state on canvas via gameState flags
  function updateAudioVisualCue() {
    // Nothing to change in DOM; drawing uses gameState.audioEnabled & soundMuted
  }

  // Utility: play a short sound with oscillator
  function playTone({ freq = 440, type = 'sine', duration = 0.2, gain = 0.1, attack = 0.005, release = 0.1, filterFreq = null } = {}) {
    if (!audioContext) {
      return;
    }
    try {
      const o = audioContext.createOscillator();
      const g = audioContext.createGain();
      o.type = type;
      o.frequency.value = freq;

      if (filterFreq) {
        const filter = audioContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = filterFreq;
        o.connect(filter);
        filter.connect(g);
      } else {
        o.connect(g);
      }
      g.connect(masterGain);
      const now = audioContext.currentTime;
      g.gain.cancelScheduledValues(now);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.linearRampToValueAtTime(gain, now + attack);
      g.gain.linearRampToValueAtTime(0.0001, now + duration - release);
      o.start(now);
      o.stop(now + duration + 0.02);
    } catch (e) {
      console.warn('playTone failed:', e);
    }
  }

  // Specialized sounds: correct, incorrect, pick
  function soundCorrect() {
    if (gameState.soundMuted) return;
    // small arp ascending
    playTone({ freq: 440, type: 'sine', duration: 0.12, gain: 0.12 });
    setTimeout(() => playTone({ freq: 660, type: 'sine', duration: 0.12, gain: 0.1 }), 120);
    setTimeout(() => playTone({ freq: 880, type: 'sine', duration: 0.18, gain: 0.08 }), 260);
  }
  function soundIncorrect() {
    if (gameState.soundMuted) return;
    // low wobble
    playTone({ freq: 120, type: 'sawtooth', duration: 0.35, gain: 0.14, filterFreq: 600 });
  }
  function soundPick() {
    if (gameState.soundMuted) return;
    playTone({ freq: 740, type: 'triangle', duration: 0.12, gain: 0.08 });
  }

  // Game generation: create tiles and target such that level is solvable
  function generateLevel(level = 1) {
    // choose three numbers 1..9 biased by level
    function randInt(a, b) { return Math.floor(Math.random() * (b - a + 1)) + a; }
    let a, b, c, ops, result;
    const opsSet = ['+', '-', '×'];
    // Try until find a result in 0..99 and not too trivial
    let attempts = 0;
    do {
      a = randInt(1, Math.min(9, 4 + level)); // grow difficulty slightly
      b = randInt(1, Math.min(9, 4 + level));
      c = randInt(1, Math.min(9, 4 + level));
      ops = [opsSet[randInt(0, 2)], opsSet[randInt(0, 2)]];
      try {
        // apply operations left-to-right: ((a op b) op c)
        result = applyOps(a, b, c, ops);
      } catch (e) {
        result = NaN;
      }
      attempts++;
      if (attempts > 500) {
        // fallback simple
        a = 2; b = 3; c = 4; ops = ['+', '+']; result = 9;
        break;
      }
    } while (!Number.isFinite(result) || result < 0 || result > 99);
    // Create tiles: include the three numbers plus some random decoys
    const tiles = [];
    const values = [a, b, c];
    // Insert the three values
    for (let v of values) {
      tiles.push({ value: v, id: 'core-' + Math.random().toString(36).slice(2) });
    }
    // Add decoys until NUM_TILES reached
    while (tiles.length < NUM_TILES) {
      tiles.push({ value: randInt(1, 9), id: 'decoy-' + Math.random().toString(36).slice(2) });
    }
    // Shuffle tiles
    for (let i = tiles.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
    }
    // Assign positions and speeds
    const startX = 40;
    const spacing = (WIDTH - 80 - TILE_WIDTH) / Math.max(1, NUM_TILES - 1);
    tiles.forEach((t, i) => {
      t.x = startX + i * spacing;
      t.y = CONVEYOR_Y;
      t.sx = 0.2 + Math.random() * 0.6;
    });
    gameState.tiles = tiles;
    gameState.selectorIndex = 0;
    gameState.slots = [null, null, null];
    gameState.currentSlotIndex = 0;
    gameState.ops = ops;
    gameState.target = result;
    gameState.message = 'Level ' + level + ': Make the machine result equal ' + result + '.';
    gameState.lastRunResult = null;
    gameState.attempts = 0;
  }

  // Apply operations left-to-right
  function applyOps(a, b, c, ops) {
    function apply(x, op, y) {
      if (op === '+') return x + y;
      if (op === '-') return x - y;
      if (op === '×') return x * y;
      return x + y;
    }
    const r1 = apply(a, ops[0], b);
    const r2 = apply(r1, ops[1], c);
    return r2;
  }

  // Place selected tile into next slot
  function loadSelectedTile() {
    if (gameState.currentSlotIndex >= SLOTS) {
      gameState.message = 'All slots are filled. Press Enter to run the machine or Backspace to remove a tile.';
      return;
    }
    const tile = gameState.tiles[gameState.selectorIndex];
    if (!tile) {
      gameState.message = 'No tile selected.';
      return;
    }
    // Copy tile into slot
    gameState.slots[gameState.currentSlotIndex] = { value: tile.value, id: tile.id };
    gameState.currentSlotIndex++;
    gameState.message = 'Loaded ' + tile.value + ' into slot ' + gameState.currentSlotIndex + '.';
    soundPick();
  }

  // Remove last loaded slot
  function removeLastSlot() {
    if (gameState.currentSlotIndex <= 0) {
      gameState.message = 'No tiles to remove.';
      return;
    }
    gameState.currentSlotIndex--;
    const removed = gameState.slots[gameState.currentSlotIndex];
    gameState.slots[gameState.currentSlotIndex] = null;
    gameState.message = 'Removed ' + (removed ? removed.value : 'tile') + ' from slot ' + (gameState.currentSlotIndex + 1) + '.';
  }

  // Run machine: compute result from slots and compare to target
  function runMachine() {
    if (gameState.slots.some(s => s === null)) {
      gameState.message = 'Fill all slots first.';
      soundIncorrect();
      return;
    }
    const vals = gameState.slots.map(s => s.value);
    const result = applyOps(vals[0], vals[1], vals[2], gameState.ops);
    gameState.lastRunResult = result;
    gameState.attempts++;
    if (result === gameState.target) {
      // success
      gameState.message = 'Success! The machine produced ' + result + '. Press R to play next level.';
      soundCorrect();
      gameState.solvedLevels++;
      gameState.playing = false;
    } else {
      // incorrect
      gameState.message = 'Oops! Machine result was ' + result + '. Try again or press R to reset the level.';
      soundIncorrect();
      // Allow player to try again; do not clear slots automatically
    }
  }

  // Reset current level
  function resetLevel() {
    generateLevel(gameState.level);
    gameState.playing = true;
  }

  // Advance to next level (beatability)
  function nextLevel() {
    gameState.level++;
    generateLevel(gameState.level);
    gameState.playing = true;
  }

  // Keyboard controls handling
  function handleKeyDown(e) {
    // Ensure audio can be started on user gesture
    if (e.key && !gameState.audioEnabled && !gameState.soundMuted) {
      tryResumeAudio();
    }
    switch (e.key) {
      case 'ArrowLeft':
        gameState.selectorIndex = (gameState.selectorIndex - 1 + gameState.tiles.length) % gameState.tiles.length;
        e.preventDefault();
        break;
      case 'ArrowRight':
        gameState.selectorIndex = (gameState.selectorIndex + 1) % gameState.tiles.length;
        e.preventDefault();
        break;
      case ' ':
        // space to load
        loadSelectedTile();
        e.preventDefault();
        break;
      case 'Enter':
        runMachine();
        e.preventDefault();
        break;
      case 'Backspace':
        removeLastSlot();
        e.preventDefault();
        break;
      case 'r':
      case 'R':
        if (!gameState.playing) {
          // If finished, go to next level
          nextLevel();
        } else {
          resetLevel();
        }
        e.preventDefault();
        break;
      case 'm':
      case 'M':
        setSoundMuted(!gameState.soundMuted);
        e.preventDefault();
        break;
      default:
        break;
    }
  }

  // Mouse controls: clicking canvas focuses and optionally picks tile
  canvas.addEventListener('click', (ev) => {
    // Start audio on click if possible
    tryResumeAudio();
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;
    // If click on a tile region, move selector there
    for (let i = 0; i < gameState.tiles.length; i++) {
      const t = gameState.tiles[i];
      if (x >= t.x && x <= t.x + TILE_WIDTH && y >= t.y && y <= t.y + TILE_HEIGHT) {
        gameState.selectorIndex = i;
        // If click is inside tile, also load it
        loadSelectedTile();
        return;
      }
    }
    // If click on "Run" area (machine center), run
    const runBox = { x: 520, y: 160, w: 160, h: 120 };
    if (x >= runBox.x && x <= runBox.x + runBox.w && y >= runBox.y && y <= runBox.y + runBox.h) {
      runMachine();
      return;
    }
    // Otherwise focus
    canvas.focus();
  });

  // Try to resume/create audio context on user gesture
  function tryResumeAudio() {
    if (!audioContext) {
      createAudioContext();
    }
    if (audioContext) {
      // Some browsers require resume
      if (typeof audioContext.resume === 'function') {
        audioContext.resume().then(() => {
          setSoundMuted(gameState.soundMuted); // apply gain
        }).catch((e) => {
          console.warn('AudioContext resume failed:', e);
        });
      } else {
        setSoundMuted(gameState.soundMuted);
      }
    }
  }

  window.addEventListener('keydown', handleKeyDown);
  canvas.addEventListener('keydown', handleKeyDown);

  // Drawing helpers
  function drawRoundedRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  // Render loop
  let lastTime = 0;
  function render(time) {
    const dt = (time - lastTime) / 1000 || 0;
    lastTime = time;

    // Update tile drifting motion
    for (let i = 0; i < gameState.tiles.length; i++) {
      const t = gameState.tiles[i];
      t.x += Math.sin(time / 1000 + i) * 0.2 * dt * 60 * t.sx;
      // keep tiles within bounds
      if (t.x < 20) t.x = 20 + (i * 2);
      if (t.x > WIDTH - TILE_WIDTH - 20) t.x = WIDTH - TILE_WIDTH - 20 - (i * 2);
    }

    // Clear background with calming gradient
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, BG_COLORS[0]);
    g.addColorStop(1, BG_COLORS[1]);
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Decorative soft shapes (wacky)
    drawSoftWackyShapes();

    // Draw machine body
    drawMachine();

    // Draw conveyor belt and tiles
    drawConveyor();

    // Draw selector
    drawSelector();

    // Draw slots
    drawSlots();

    // Draw target display and ops display
    drawTargetPanel();

    // Draw instructions and messages
    drawHUD();

    requestAnimationFrame(render);
  }

  // Decorative soft shapes to make visuals calming & wacky
  function drawSoftWackyShapes() {
    // floating blobs at top-left and top-right
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.fillStyle = '#7FB5B3';
    ctx.beginPath();
    ctx.ellipse(80, 70, 70, 40, 0.3, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#C5E7E6';
    ctx.beginPath();
    ctx.ellipse(620, 110, 90, 50, -0.5, 0, Math.PI * 2);
    ctx.fill();

    ctx.globalAlpha = 1.0;
    ctx.restore();
  }

  function drawMachine() {
    // Main machine box
    ctx.save();
    ctx.fillStyle = MACHINE_COLOR;
    drawRoundedRect(ctx, 440, 110, 260, 200, 16);

    // Machine "face"
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath();
    ctx.arc(560, 180, 28, 0, Math.PI * 2);
    ctx.fill();

    // Wacky eye
    ctx.fillStyle = '#21333B';
    ctx.beginPath();
    ctx.arc(560, 180, 8, 0, Math.PI * 2);
    ctx.fill();

    // Small blinking light as audio visual cue
    const blinkAlpha = gameState.audioEnabled && !gameState.soundMuted ? 1.0 : 0.2;
    ctx.fillStyle = `rgba(255, 230, 180, ${blinkAlpha})`;
    ctx.beginPath();
    ctx.arc(640, 135, 8, 0, Math.PI * 2);
    ctx.fill();

    // Flowy pipes to run into machine center
    ctx.strokeStyle = '#3C6E70';
    ctx.lineWidth = 8;
    ctx.beginPath();
    ctx.moveTo(300, 220);
    ctx.quadraticCurveTo(380, 140, 520, 180);
    ctx.stroke();

    ctx.restore();
  }

  function drawConveyor() {
    // Conveyor belt base
    ctx.save();
    ctx.fillStyle = '#A3C4C4';
    drawRoundedRect(ctx, 20, CONVEYOR_Y - 16, WIDTH - 40, TILE_HEIGHT + 32, 12);

    // Treads
    ctx.fillStyle = '#D6EDEE';
    for (let i = 20; i < WIDTH - 20; i += 30) {
      ctx.fillRect(i, CONVEYOR_Y + TILE_HEIGHT + 6, 20, 6);
    }

    // Draw tiles
    for (let i = 0; i < gameState.tiles.length; i++) {
      const t = gameState.tiles[i];
      drawTile(t.x, t.y, t.value, i === gameState.selectorIndex, t.id);
    }

    ctx.restore();
  }

  function drawTile(x, y, value, selected = false, id = '') {
    // Shadow
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.08)';
    drawRoundedRect(ctx, x + 6, y + 10, TILE_WIDTH, TILE_HEIGHT, 8);

    // Tile body
    ctx.fillStyle = '#FFFFFF';
    drawRoundedRect(ctx, x, y, TILE_WIDTH, TILE_HEIGHT, 10);

    // wacky pattern
    ctx.fillStyle = '#F1F8F8';
    ctx.fillRect(x + 6, y + 36, TILE_WIDTH - 12, 6);

    // Number
    ctx.fillStyle = TEXT_COLOR;
    ctx.font = 'bold 28px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(String(value), x + TILE_WIDTH / 2, y + TILE_HEIGHT / 2 - 6);

    // id small invisible marker for testing/dev
    // draw selection
    if (selected) {
      ctx.strokeStyle = ACCENT_COLOR;
      ctx.lineWidth = 4;
      ctx.strokeRect(x - 2, y - 2, TILE_WIDTH + 4, TILE_HEIGHT + 4);
    }
    ctx.restore();
  }

  function drawSelector() {
    // small arrow below selected tile
    const t = gameState.tiles[gameState.selectorIndex];
    if (!t) return;
    ctx.save();
    ctx.fillStyle = ACCENT_COLOR;
    const sx = t.x + TILE_WIDTH / 2;
    const sy = t.y + TILE_HEIGHT + 22;
    ctx.beginPath();
    ctx.moveTo(sx - 10, sy - 10);
    ctx.lineTo(sx + 10, sy - 10);
    ctx.lineTo(sx, sy + 4);
    ctx.closePath();
    ctx.fill();

    // Accessibility text near selector (visible)
    ctx.fillStyle = TEXT_COLOR;
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Selected: ' + t.value, sx, sy + 28);
    ctx.restore();
  }

  function drawSlots() {
    // Draw three input slots feeding into machine pipe
    ctx.save();
    const baseX = 260;
    const baseY = 160;
    const slotW = 72;
    const slotH = 52;
    for (let i = 0; i < SLOTS; i++) {
      const x = baseX - i * (slotW + 18);
      const y = baseY;
      ctx.fillStyle = '#F8FFFF';
      drawRoundedRect(ctx, x, y, slotW, slotH, 8);
      ctx.strokeStyle = '#CEEFEF';
      ctx.stroke();

      // Draw loaded value
      const s = gameState.slots[i];
      if (s) {
        ctx.fillStyle = TEXT_COLOR;
        ctx.font = 'bold 20px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(String(s.value), x + slotW / 2, y + slotH / 2);
      } else {
        ctx.fillStyle = '#9EB7B7';
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Slot ' + (i + 1), x + slotW / 2, y + slotH / 2);
      }

      // Visual cue for current slot
      if (i === gameState.currentSlotIndex) {
        ctx.strokeStyle = ACCENT_COLOR;
        ctx.lineWidth = 3;
        ctx.strokeRect(x - 2, y - 2, slotW + 4, slotH + 4);
      }

      // Draw little arrow to machine
      ctx.strokeStyle = '#3C6E70';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(x + slotW + 6, y + slotH / 2);
      ctx.lineTo(420, 200);
      ctx.stroke();

      // Draw operation icon between slots except last
      if (i < SLOTS - 1) {
        const op = gameState.ops[i];
        ctx.fillStyle = '#FFFBF2';
        drawRoundedRect(ctx, x - 24, y + slotH + 10, 48, 28, 6);
        ctx.fillStyle = TEXT_COLOR;
        ctx.font = 'bold 18px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(op, x, y + slotH + 24);
      }
    }
    ctx.restore();
  }

  function drawTargetPanel() {
    ctx.save();
    // target display
    ctx.fillStyle = '#FFFFFF';
    drawRoundedRect(ctx, 520, 60, 160, 76, 10);
    ctx.strokeStyle = '#DCEFF0';
    ctx.stroke();

    ctx.fillStyle = TEXT_COLOR;
    ctx.font = '20px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Target Number', 600, 80);

    ctx.fillStyle = ACCENT_COLOR;
    ctx.font = 'bold 34px sans-serif';
    ctx.fillText(String(gameState.target), 600, 112);

    // Run button area (visual)
    ctx.fillStyle = '#EFFFF9';
    drawRoundedRect(ctx, 520, 160, 160, 120, 10);
    ctx.fillStyle = '#7EDABF';
    ctx.font = 'bold 20px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('RUN MACHINE', 600, 210);
    ctx.fillStyle = TEXT_COLOR;
    ctx.font = '14px sans-serif';
    ctx.fillText('Press Enter', 600, 235);

    // Last result display
    if (gameState.lastRunResult !== null) {
      ctx.fillStyle = '#FFFFFF';
      drawRoundedRect(ctx, 520, 290, 160, 60, 8);
      ctx.fillStyle = TEXT_COLOR;
      ctx.font = '14px sans-serif';
      ctx.fillText('Last result: ' + String(gameState.lastRunResult), 600, 320);
    }

    ctx.restore();
  }

  function drawHUD() {
    ctx.save();
    // Message
    ctx.fillStyle = '#21333B';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(gameState.message, 24, 30);

    // Level & attempts
    ctx.fillStyle = '#21333B';
    ctx.font = '13px sans-serif';
    ctx.fillText('Level: ' + gameState.level + '   Attempts: ' + gameState.attempts, 24, 50);

    // Controls reminder
    ctx.fillStyle = '#21333B';
    ctx.font = '12px sans-serif';
    ctx.fillText('← → Move   Space Load   Backspace Remove   Enter Run   R Reset/Next   M Toggle sound', 24, HEIGHT - 16);

    // Audio visual indicator (speaker)
    const speakerX = WIDTH - 42;
    const speakerY = 26;
    ctx.fillStyle = '#FFFFFF';
    ctx.strokeStyle = '#9FBDBD';
    ctx.lineWidth = 2;
    drawRoundedRect(ctx, speakerX - 26, speakerY - 18, 52, 36, 8);
    ctx.fillStyle = gameState.soundMuted ? '#FFADAD' : '#C9FFEE';
    ctx.beginPath();
    ctx.moveTo(speakerX - 12, speakerY + 2);
    ctx.lineTo(speakerX - 12, speakerY - 10);
    ctx.lineTo(speakerX - 2, speakerY - 4);
    ctx.lineTo(speakerX + 10, speakerY - 12);
    ctx.lineTo(speakerX + 10, speakerY + 12);
    ctx.lineTo(speakerX - 2, speakerY + 4);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Cross out if muted
    if (gameState.soundMuted) {
      ctx.strokeStyle = '#C33';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(speakerX - 20, speakerY - 12);
      ctx.lineTo(speakerX + 20, speakerY + 12);
      ctx.stroke();
    }

    // Friendly machine name
    ctx.fillStyle = '#21333B';
    ctx.font = '16px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Machine Mix-Up', WIDTH / 2, 30);

    ctx.restore();
  }

  // Initialize
  function init() {
    // Safety checks
    try {
      canvas.focus();
    } catch (e) {
      // ignore
    }
    // Default audio muted until user interacts
    gameState.soundMuted = true;
    updateAudioVisualCue();
    generateLevel(gameState.level);
    requestAnimationFrame(render);
  }

  // Start
  init();

  // Expose a small debug API on container for testing (non-intrusive)
  container.__machineMixup = {
    reset: resetLevel,
    next: nextLevel,
    toggleSound: () => setSoundMuted(!gameState.soundMuted),
    getState: () => JSON.parse(JSON.stringify(gameState)),
  };

  // Provide basic accessibility: announce messages via ARIA live region
  let liveRegion = document.createElement('div');
  liveRegion.setAttribute('aria-live', 'polite');
  liveRegion.style.position = 'absolute';
  liveRegion.style.left = '-10000px';
  liveRegion.style.top = 'auto';
  container.appendChild(liveRegion);

  // Update live region when messages change
  let lastAnnounced = '';
  setInterval(() => {
    if (gameState.message && gameState.message !== lastAnnounced) {
      liveRegion.textContent = gameState.message;
      lastAnnounced = gameState.message;
    }
  }, 300);

  // Graceful cleanup on unload
  window.addEventListener('beforeunload', () => {
    try {
      if (audioContext && typeof audioContext.close === 'function') {
        audioContext.close();
      }
    } catch (e) {
      // ignore
    }
  });
})();
---

