# Game of the Day - 2025-10-30

## Metadata
- **Generated Date:** 2025-10-30
- **Generated Time:** 2025-10-30T00:28:35.505372
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-10-30.js
- **File Size:** 26252 bytes
- **Tokens Used:** 9306

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-10-30.js` - The playable game
- `2025-10-30.meta.json` - Machine-readable metadata
- `2025-10-30.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 19557

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 21843

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Drone Math Delivery - Canvas Game
  // For ages 7-9. Answer 10 math questions correctly to win.
  // 3 wrong answers = game over.
  // All rendering in a 720x480 canvas inside element with ID 'game-of-the-day-stage'.
  // Sounds are generated with the Web Audio API. Accessible via keyboard and mouse.
  'use strict';

  // CONFIG
  const WIDTH = 720;
  const HEIGHT = 480;
  const GOAL_CORRECT = 10;
  const MAX_WRONG = 3;
  const MIN_BODY_FONT = 16; // ensure >=14px
  const IMPORTANT_FONT = 22; // ensure >=18px

  // Retrieve container
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error("Container with id 'game-of-the-day-stage' not found. Cannot initialize game.");
    return;
  }

  // Clear container and add canvas
  container.innerHTML = '';
  container.style.position = 'relative';
  container.style.userSelect = 'none';

  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute('role', 'application');
  canvas.setAttribute('aria-label', 'Drone math delivery game. Use number keys 1-3 to answer, arrow keys or tab to change selection, space or enter to select. Press M to mute/unmute. Press R to restart.');
  canvas.style.display = 'block';
  canvas.style.background = '#e8f7ff';
  container.appendChild(canvas);

  const ctx = canvas.getContext('2d');

  // Accessibility: make focusable
  canvas.tabIndex = 0;

  // Audio context setup with error handling
  let audioContext = null;
  let audioAllowed = false;
  let ambientGain = null;
  let ambientOsc = null;
  let masterGain = null;
  try {
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if (AudioCtx) {
      audioContext = new AudioCtx();
      // create master gain
      masterGain = audioContext.createGain();
      masterGain.gain.value = 0.8;
      masterGain.connect(audioContext.destination);
    } else {
      console.warn('Web Audio API not supported in this browser.');
    }
  } catch (e) {
    console.warn('Error creating AudioContext:', e);
    audioContext = null;
  }

  // Resumable audio on user gesture
  function ensureAudioAllowed() {
    if (!audioContext) return;
    if (audioContext.state === 'suspended') {
      audioContext.resume().then(() => {
        audioAllowed = true;
        startAmbient();
      }).catch((e) => {
        console.warn('AudioContext resume failed:', e);
        audioAllowed = false;
      });
    } else {
      audioAllowed = true;
      startAmbient();
    }
  }

  // Ambient hum
  function startAmbient() {
    if (!audioContext || ambientOsc) return;
    try {
      ambientOsc = audioContext.createOscillator();
      ambientOsc.type = 'sine';
      ambientOsc.frequency.value = 120; // low hum
      const lfo = audioContext.createOscillator();
      lfo.type = 'sine';
      lfo.frequency.value = 0.25; // slow wobble

      const lfoGain = audioContext.createGain();
      lfoGain.gain.value = 10; // modulate frequency by small amount
      lfo.connect(lfoGain);
      lfoGain.connect(ambientOsc.frequency);

      ambientGain = audioContext.createGain();
      ambientGain.gain.value = 0.03; // gentle
      ambientOsc.connect(ambientGain);
      ambientGain.connect(masterGain || audioContext.destination);

      ambientOsc.start();
      lfo.start();
      // store lfo on ambientOsc for cleanup reference
      ambientOsc._lfo = lfo;
      ambientOsc._lfoGain = lfoGain;
    } catch (e) {
      console.warn('Failed to start ambient sound:', e);
      ambientOsc = null;
    }
  }

  function stopAmbient() {
    if (!ambientOsc) return;
    try {
      ambientOsc._lfo && ambientOsc._lfo.stop();
      ambientOsc.stop();
    } catch (e) {
      // ignore
    }
    ambientOsc = null;
    ambientGain = null;
  }

  // Play short sound effects
  function playBeep({ freq = 800, type = 'sine', duration = 0.12, gain = 0.15, attack = 0.01, decay = 0.08, filterFreq = null } = {}) {
    if (!audioContext || !audioAllowed) return;
    try {
      const now = audioContext.currentTime;
      const osc = audioContext.createOscillator();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, now);

      let node = osc;
      let filter = null;
      if (filterFreq) {
        filter = audioContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = filterFreq;
        node.connect(filter);
        node = filter;
      }

      const gainNode = audioContext.createGain();
      gainNode.gain.setValueAtTime(0.0001, now);
      gainNode.gain.linearRampToValueAtTime(gain, now + attack);
      gainNode.gain.exponentialRampToValueAtTime(0.0001, now + duration + decay);

      node.connect(gainNode);
      gainNode.connect(masterGain || audioContext.destination);

      osc.start(now);
      osc.stop(now + duration + decay + 0.05);
    } catch (e) {
      console.warn('playBeep failed:', e);
    }
  }

  function playCorrect() {
    // joyful chord-ish using two oscillators
    if (!audioContext || !audioAllowed) return;
    try {
      const now = audioContext.currentTime;
      const freqs = [880, 1100, 660];
      freqs.forEach((f, i) => {
        const osc = audioContext.createOscillator();
        osc.type = i === 1 ? 'triangle' : 'sine';
        osc.frequency.setValueAtTime(f, now);
        const g = audioContext.createGain();
        g.gain.setValueAtTime(0.0001, now);
        g.gain.linearRampToValueAtTime(0.06 / (i + 1), now + 0.02 + i * 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.35 + i * 0.05);
        osc.connect(g);
        g.connect(masterGain || audioContext.destination);
        osc.start(now);
        osc.stop(now + 0.45 + i * 0.05);
      });
    } catch (e) {
      console.warn('playCorrect failed:', e);
    }
  }

  function playWrong() {
    playBeep({ freq: 140, type: 'sawtooth', duration: 0.25, gain: 0.18, filterFreq: 800 });
    // slight buzzer
    setTimeout(() => playBeep({ freq: 220, type: 'square', duration: 0.12, gain: 0.12 }), 120);
  }

  function playSelect() {
    playBeep({ freq: 600, duration: 0.08, gain: 0.06 });
  }

  // Game state
  let score = 0;
  let wrong = 0;
  let currentQuestion = null;
  let options = [];
  let focusedOption = 0; // for keyboard focus
  let isPaused = false;
  let gameState = 'playing'; // 'playing', 'won', 'lost'
  let questionIndex = 0;

  // Drone visual state
  const drone = {
    x: WIDTH / 2,
    y: 160,
    vx: 0,
    bobPhase: 0,
    rotation: 0,
    rotTarget: 0,
  };

  // Floating clouds and balloons for background
  const floaters = [];
  for (let i = 0; i < 6; i++) {
    floaters.push({
      x: Math.random() * WIDTH,
      y: Math.random() * HEIGHT * 0.6,
      size: 30 + Math.random() * 40,
      speed: 0.2 + Math.random() * 0.6,
      type: Math.random() > 0.7 ? 'balloon' : 'cloud',
      wobble: Math.random() * Math.PI * 2,
    });
  }

  // Answer button boxes (will be computed)
  let answerBoxes = [];

  // Generate a question
  function generateQuestion(index) {
    // Increase difficulty slowly
    const level = Math.min(5, Math.floor(index / 2) + 1);
    let a, b, op, answer;
    if (Math.random() < 0.6) {
      // addition/subtraction
      if (Math.random() < 0.5) {
        a = Math.floor(Math.random() * (10 * level)) + 1;
        b = Math.floor(Math.random() * Math.min(10 * level, a)) + 1;
        op = Math.random() < 0.5 ? '+' : '-';
        answer = op === '+' ? a + b : a - b;
      } else {
        a = Math.floor(Math.random() * (10 * level)) + 1;
        b = Math.floor(Math.random() * (10 * level)) + 1;
        op = '+';
        answer = a + b;
      }
    } else {
      // simple multiplication
      a = Math.floor(Math.random() * (level + 2)) + 2;
      b = Math.floor(Math.random() * 5) + 2;
      op = '×';
      answer = a * b;
    }

    // prepare options: one correct and two distractors
    const opts = new Set();
    opts.add(answer);
    while (opts.size < 3) {
      let delta;
      if (Math.random() < 0.6) {
        delta = Math.floor(Math.random() * 5) + 1;
      } else {
        delta = Math.floor(Math.random() * 10) + 1;
      }
      const sign = Math.random() < 0.5 ? -1 : 1;
      let candidate = answer + sign * delta;
      // avoid negative or equal
      if (candidate < 0) candidate = Math.abs(candidate) + 1;
      if (candidate === answer) candidate += 2;
      opts.add(candidate);
    }
    const optsArr = Array.from(opts);
    // shuffle
    for (let i = optsArr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [optsArr[i], optsArr[j]] = [optsArr[j], optsArr[i]];
    }
    return {
      text: `${a} ${op} ${b} = ?`,
      correct: answer,
      options: optsArr,
    };
  }

  function startNewQuestion() {
    currentQuestion = generateQuestion(questionIndex);
    options = currentQuestion.options;
    focusedOption = 0;
    // compute answer boxes based on text sizes and layout rules.
    layoutAnswerBoxes();
  }

  function layoutAnswerBoxes() {
    // We'll draw question in center-top area, answers below in three boxes.
    // Ensure no overlap with drone (drone at y=160).
    answerBoxes = [];
    ctx.font = `${IMPORTANT_FONT}px sans-serif`;
    const questionText = currentQuestion ? currentQuestion.text : '';
    const qMetrics = ctx.measureText(questionText);
    const qW = Math.min(qMetrics.width, WIDTH - 40);

    // Compute answer box widths by measuring each option text.
    ctx.font = `${MIN_BODY_FONT}px sans-serif`;
    const padd = 16;
    const boxHe = 48;
    const gap = 18;
    const totalWidthEstimate = options.reduce((sum, opt) => {
      const w = ctx.measureText(String(opt)).width + padd * 2;
      return sum + w;
    }, 0) + gap * (options.length - 1);

    let startX = Math.max(20, (WIDTH - totalWidthEstimate) / 2);
    const y = 240;
    // create boxes and ensure they don't overlap the drone area (drone at y=160 with size ~60)
    // If they overlap, shift answers lower
    let finalY = y;
    const droneBottom = drone.y + 40;
    if (finalY < droneBottom + 20) finalY = droneBottom + 30;
    // Ensure finalY + boxHe doesn't overlap with bottom instructions area (reserve bottom 70px)
    const bottomReserve = 70;
    if (finalY + boxHe > HEIGHT - bottomReserve) finalY = HEIGHT - bottomReserve - boxHe - 10;

    for (let i = 0; i < options.length; i++) {
      const text = String(options[i]);
      const w = Math.max(80, ctx.measureText(text).width + padd * 2);
      const box = {
        x: startX,
        y: finalY,
        w,
        h: boxHe,
        text,
        index: i,
      };
      answerBoxes.push(box);
      startX += w + gap;
    }
  }

  // Input handling
  function handleOptionSelection(idx) {
    if (gameState !== 'playing') return;
    const chosen = options[idx];
    if (chosen === currentQuestion.correct) {
      score++;
      playCorrect();
      // celebrate animation maybe
    } else {
      wrong++;
      playWrong();
    }
    questionIndex++;
    // animate drone rotation slightly toward chosen option
    drone.rotTarget = (idx - 1) * 0.15;
    // Check end conditions
    if (score >= GOAL_CORRECT) {
      gameState = 'won';
      stopAmbient();
    } else if (wrong >= MAX_WRONG) {
      gameState = 'lost';
      stopAmbient();
    } else {
      startNewQuestion();
    }
  }

  // Mouse interaction: click detection
  canvas.addEventListener('pointerdown', function (e) {
    const rect = canvas.getBoundingClientRect();
    const cx = (e.clientX - rect.left) * (canvas.width / rect.width);
    const cy = (e.clientY - rect.top) * (canvas.height / rect.height);
    ensureAudioAllowed();
    // Check answer boxes
    for (let box of answerBoxes) {
      if (cx >= box.x && cx <= box.x + box.w && cy >= box.y && cy <= box.y + box.h) {
        focusedOption = box.index;
        playSelect();
        handleOptionSelection(box.index);
        return;
      }
    }
    // Check speaker icon (top center small circle)
    const speakerX = WIDTH / 2;
    const speakerY = 30;
    const d = Math.hypot(cx - speakerX, cy - speakerY);
    if (d <= 14) {
      toggleAudioMute();
      return;
    }
    // If clicked on restart buttons in end screens
    if (gameState === 'won' || gameState === 'lost') {
      const btn = getRestartButtonRect();
      if (cx >= btn.x && cx <= btn.x + btn.w && cy >= btn.y && cy <= btn.y + btn.h) {
        restartGame();
      }
    }
  });

  // Keyboard controls
  window.addEventListener('keydown', function (e) {
    // Provide keyboard access
    if (e.key === 'm' || e.key === 'M') {
      // toggle audio
      toggleAudioMute();
      e.preventDefault();
      return;
    }
    if (e.key === 'r' || e.key === 'R') {
      restartGame();
      e.preventDefault();
      return;
    }
    if (gameState !== 'playing') {
      if (e.key === 'Enter' || e.key === ' ') {
        // restart if finished
        restartGame();
        e.preventDefault();
      }
      return;
    }
    ensureAudioAllowed();
    if (e.key === 'ArrowLeft') {
      focusedOption = (focusedOption - 1 + options.length) % options.length;
      playSelect();
      e.preventDefault();
      return;
    } else if (e.key === 'ArrowRight') {
      focusedOption = (focusedOption + 1) % options.length;
      playSelect();
      e.preventDefault();
      return;
    } else if (e.key === 'Tab') {
      // cycle focus
      focusedOption = (focusedOption + (e.shiftKey ? -1 : 1) + options.length) % options.length;
      playSelect();
      e.preventDefault();
      return;
    } else if (e.key === '1' || e.key === '2' || e.key === '3') {
      const idx = parseInt(e.key, 10) - 1;
      if (idx >= 0 && idx < options.length) {
        focusedOption = idx;
        handleOptionSelection(idx);
      }
      e.preventDefault();
      return;
    } else if (e.key === 'Enter' || e.key === ' ') {
      playSelect();
      handleOptionSelection(focusedOption);
      e.preventDefault();
      return;
    }
  });

  // Keep track if audio muted
  let muted = false;
  function toggleAudioMute() {
    if (!audioContext) return;
    muted = !muted;
    if (masterGain) masterGain.gain.value = muted ? 0 : 0.8;
    // stop or start ambient accordingly
    if (muted) stopAmbient();
    else ensureAudioAllowed();
  }

  function getRestartButtonRect() {
    const w = 200;
    const h = 48;
    return {
      x: (WIDTH - w) / 2,
      y: HEIGHT / 2 + 60,
      w,
      h,
    };
  }

  function restartGame() {
    score = 0;
    wrong = 0;
    questionIndex = 0;
    gameState = 'playing';
    drone.x = WIDTH / 2;
    drone.y = 160;
    drone.vx = 0;
    drone.bobPhase = 0;
    drone.rotation = 0;
    drone.rotTarget = 0;
    ensureAudioAllowed();
    startNewQuestion();
  }

  // Drawing helpers
  function drawRoundedRect(x, y, w, h, r, style = '#000', fill = true) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) {
      ctx.fillStyle = style;
      ctx.fill();
    } else {
      ctx.strokeStyle = style;
      ctx.stroke();
    }
  }

  function drawBackground() {
    // gradient sky
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#e8f7ff');
    g.addColorStop(1, '#ffffff');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // soft ground line
    ctx.fillStyle = '#dff3e6';
    ctx.fillRect(0, HEIGHT - 60, WIDTH, 60);

    // draw floaters
    for (let f of floaters) {
      f.x += f.type === 'balloon' ? 0.1 * f.speed : -0.1 * f.speed;
      f.y += Math.sin(f.wobble + performance.now() / 2000) * 0.05;
      f.x += Math.sin(f.wobble + performance.now() / 1000) * 0.02;
      f.wobble += 0.002 * f.speed;
      if (f.x > WIDTH + 60) f.x = -60;
      if (f.x < -60) f.x = WIDTH + 60;
      if (f.type === 'cloud') {
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        drawCloud(f.x, f.y, f.size);
      } else {
        drawBalloon(f.x, f.y, f.size);
      }
    }
  }

  function drawCloud(cx, cy, size) {
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.ellipse(cx, cy, size * 0.6, size * 0.32, 0, 0, Math.PI * 2);
    ctx.ellipse(cx - size * 0.4, cy + 4, size * 0.4, size * 0.24, 0, 0, Math.PI * 2);
    ctx.ellipse(cx + size * 0.5, cy + 2, size * 0.36, size * 0.22, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawBalloon(cx, cy, size) {
    // string
    ctx.strokeStyle = '#6a6a6a';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(cx, cy + size * 0.6);
    ctx.lineTo(cx, cy + size * 1.4);
    ctx.stroke();
    // balloon
    const grd = ctx.createLinearGradient(cx - size * 0.5, cy - size * 0.6, cx + size * 0.5, cy + size * 0.6);
    grd.addColorStop(0, '#ffefef');
    grd.addColorStop(1, '#ffd1d1');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.ellipse(cx, cy, size * 0.5, size * 0.66, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawDrone() {
    // bobbing effect
    drone.bobPhase += 0.02;
    drone.y += Math.sin(drone.bobPhase) * 0.2;
    drone.x += drone.vx;
    drone.vx *= 0.94;

    // slowly relax rotation towards rotTarget
    drone.rotation += (drone.rotTarget - drone.rotation) * 0.06;

    // drone body
    const x = drone.x;
    const y = drone.y;
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(drone.rotation);

    // propellers wobble
    const propPhase = performance.now() / 100;

    // body shadow
    ctx.fillStyle = 'rgba(0,0,0,0.06)';
    ctx.beginPath();
    ctx.ellipse(0, 36, 46, 12, 0, 0, Math.PI * 2);
    ctx.fill();

    // main pod
    ctx.fillStyle = '#ffd66b';
    drawRoundedRect(-60, -18, 120, 40, 12, '#ffd66b', true);

    // cockpit
    ctx.fillStyle = '#5fdffb';
    ctx.beginPath();
    ctx.ellipse(18, -6, 28, 18, 0, 0, Math.PI * 2);
    ctx.fill();

    // funny eyes
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.ellipse(10, -8, 6, 6, 0, 0, Math.PI * 2);
    ctx.ellipse(22, -8, 6, 6, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#2b2b2b';
    ctx.beginPath();
    ctx.ellipse(12, -6, 2.5, 2.5, 0, 0, Math.PI * 2);
    ctx.ellipse(24, -6, 2.5, 2.5, 0, 0, Math.PI * 2);
    ctx.fill();

    // landing skids
    ctx.strokeStyle = '#7a4d20';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-40, 24);
    ctx.lineTo(-12, 24);
    ctx.moveTo(12, 24);
    ctx.lineTo(40, 24);
    ctx.stroke();

    // propeller arms and blades
    ctx.fillStyle = '#a0d5ff';
    for (let i = -1; i <= 1; i += 2) {
      ctx.save();
      ctx.translate(i * 56, -6);
      ctx.rotate(Math.sin(propPhase + i) * 0.6);
      // arm
      ctx.fillStyle = '#9fb5c9';
      drawRoundedRect(-4, -2, 48, 6, 3, '#9fb5c9', true);
      // prop
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.ellipse(28, 0, 8, 8, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
    ctx.restore();
  }

  // Text boxes must not overlap. We'll layout UI carefully.
  function drawUI() {
    // Score top-left
    ctx.font = `${MIN_BODY_FONT}px sans-serif`;
    const padding = 12;
    const scoreText = `Score: ${score}/${GOAL_CORRECT}`;
    const scoreW = Math.ceil(ctx.measureText(scoreText).width) + padding * 2;
    const scoreBox = { x: 12, y: 12, w: scoreW, h: 36 };
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    drawRoundedRect(scoreBox.x, scoreBox.y, scoreBox.w, scoreBox.h, 8, ctx.fillStyle, true);
    ctx.fillStyle = '#2b2b2b';
    ctx.font = `${MIN_BODY_FONT}px sans-serif`;
    ctx.fillText(scoreText, scoreBox.x + padding, scoreBox.y + 24);

    // Lives top-right
    const livesText = `Misses: ${wrong}/${MAX_WRONG}`;
    const livesW = Math.ceil(ctx.measureText(livesText).width) + padding * 2;
    const livesBox = { x: WIDTH - livesW - 12, y: 12, w: livesW, h: 36 };
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    drawRoundedRect(livesBox.x, livesBox.y, livesBox.w, livesBox.h, 8, ctx.fillStyle, true);
    ctx.fillStyle = '#2b2b2b';
    ctx.fillText(livesText, livesBox.x + padding, livesBox.y + 24);

    // Audio status - top center
    const speakerX = WIDTH / 2;
    const speakerY = 30;
    ctx.beginPath();
    ctx.arc(speakerX, speakerY, 14, 0, Math.PI * 2);
    ctx.fillStyle = audioContext ? (muted ? '#ffd1d1' : '#d1ffd6') : '#f2f2f2';
    ctx.fill();
    ctx.strokeStyle = '#cfcfcf';
    ctx.stroke();
    ctx.fillStyle = '#2b2b2b';
    ctx.font = '12px sans-serif';
    ctx.fillText(audioContext ? (muted ? 'Audio Off (M)' : 'Audio On (M)') : 'Audio Unavailable', speakerX - 38, speakerY + 4);

    // Instructions bottom-center
    ctx.font = `${MIN_BODY_FONT}px sans-serif`;
    const instructions = 'Use 1-3 keys or arrow keys + Enter to answer. Press M to toggle audio, R to restart.';
    const instrW = ctx.measureText(instructions).width;
    const instrX = (WIDTH - instrW) / 2;
    const instrY = HEIGHT - 28;
    // put background rectangle behind instructions
    drawRoundedRect(instrX - 10, instrY - 18, instrW + 20, 36, 8, 'rgba(255,255,255,0.85)', true);
    ctx.fillStyle = '#2b2b2b';
    ctx.fillText(instructions, instrX, instrY - 4);

    // Question text in center top area
    ctx.font = `${IMPORTANT_FONT}px sans-serif`;
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    const qText = currentQuestion ? currentQuestion.text : '';
    const qW = Math.min(ctx.measureText(qText).width, WIDTH - 40);
    const qX = (WIDTH - qW) / 2 - 12;
    const qY = 200 - 60;
    drawRoundedRect(qX, qY - 6, qW + 24, 48, 10, 'rgba(255,255,255,0.86)', true);
    ctx.fillStyle = '#123a4a';
    ctx.textAlign = 'center';
    ctx.fillText(qText, WIDTH / 2, qY + 28);
    ctx.textAlign = 'start';
  }

  // Draw answer options
  function drawAnswers() {
    ctx.font = `${MIN_BODY_FONT}px sans-serif`;
    for (let i = 0; i < answerBoxes.length; i++) {
      const box = answerBoxes[i];
      // check focus and hover states
      const isFocused = (i === focusedOption);
      // background
      ctx.fillStyle = isFocused ? 'rgba(181, 230, 255, 0.95)' : 'rgba(255,255,255,0.95)';
      drawRoundedRect(box.x, box.y, box.w, box.h, 8, ctx.fillStyle, true);
      // border
      ctx.strokeStyle = isFocused ? '#2b9bd7' : 'rgba(120,120,120,0.25)';
      ctx.lineWidth = isFocused ? 2 : 1;
      ctx.strokeRect(box.x + 0.5, box.y + 0.5, box.w - 1, box.h - 1);

      // text in center-left
      ctx.fillStyle = '#123a4a';
      ctx.font = `${MIN_BODY_FONT}px sans-serif`;
      const txtX = box.x + 16;
      const txtY = box.y + box.h / 2 + 6;
      ctx.fillText((i + 1) + '. ' + box.text, txtX, txtY);

      // small pad beneath each as a landing pad
      ctx.fillStyle = '#f0f8ff';
      ctx.beginPath();
      ctx.ellipse(box.x + box.w / 2, box.y + box.h + 12, box.w / 3, 8, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.05)';
      ctx.stroke();
    }
  }

  // End screens
  function drawEndScreen() {
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    const title = gameState === 'won' ? 'Delivery Complete!' : 'Game Over';
    ctx.font = '36px sans-serif';
    ctx.fillStyle = '#ffffff';
    const titleW = ctx.measureText(title).width;
    ctx.fillText(title, (WIDTH - titleW) / 2, HEIGHT / 2 - 20);

    ctx.font = `${IMPORTANT_FONT}px sans-serif`;
    const msg = gameState === 'won'
      ? `You answered ${score} questions! The drones are dancing.`
      : `You had ${wrong} misses. Try again to make more deliveries!`;
    const mW = ctx.measureText(msg).width;
    ctx.fillText(msg, (WIDTH - mW) / 2, HEIGHT / 2 + 12);

    // Restart button
    const btn = getRestartButtonRect();
    ctx.fillStyle = '#ffd66b';
    drawRoundedRect(btn.x, btn.y, btn.w, btn.h, 10, ctx.fillStyle, true);
    ctx.fillStyle = '#2b2b2b';
    ctx.font = `${MIN_BODY_FONT}px sans-serif`;
    const btnText = 'Restart (R)';
    const btnTextW = ctx.measureText(btnText).width;
    ctx.fillText(btnText, btn.x + (btn.w - btnTextW) / 2, btn.y + btn.h / 2 + 6);
  }

  // Main update and render loop
  function updateAndRender() {
    // update drone slight movement towards target center
    // make sure drone not overlapping answer boxes by adjusting y maybe
    // Keep drone within bounds
    drone.x += (WIDTH / 2 - drone.x) * 0.02;

    // Draw everything
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    drawBackground();
    drawDrone();
    drawUI();
    drawAnswers();

    // Draw visual cue for which option is correct for debugging? Not for kids.

    // If ended, show overlay
    if (gameState === 'won' || gameState === 'lost') {
      drawEndScreen();
    }

    requestAnimationFrame(updateAndRender);
  }

  // Initialize first question and start loop
  startNewQuestion();
  updateAndRender();

  // initial audio resume on first user gesture for browser autoplay policies
  function onFirstInteraction() {
    ensureAudioAllowed();
    window.removeEventListener('pointerdown', onFirstInteraction);
    window.removeEventListener('keydown', onFirstInteraction);
  }
  window.addEventListener('pointerdown', onFirstInteraction);
  window.addEventListener('keydown', onFirstInteraction);

  // Provide accessible error handling: if audio fails, show small toast inside canvas, logged to console
  if (!audioContext) {
    console.warn('AudioContext unavailable. Sounds will be disabled.');
  }

  // Provide a small animation to hint keyboard controls if inactive
  let idleTimer = null;
  function startIdleHint() {
    clearTimeout(idleTimer);
    idleTimer = setTimeout(() => {
      // show hint by pulsing focused option briefly
      focusedOption = (focusedOption + 1) % Math.max(1, options.length);
      playSelect();
    }, 8000);
  }
  window.addEventListener('mousemove', startIdleHint);
  window.addEventListener('keydown', startIdleHint);
  window.addEventListener('pointerdown', startIdleHint);
  startIdleHint();

  // Safety: ensure text does not overlap by measuring layout on resize or device pixel ratio changes.
  // Since canvas is fixed size, just re-layout answers whenever question changes.
  // Already handled by startNewQuestion/layoutAnswerBoxes.

  // Export nothing; all inside closure.
})();
---

