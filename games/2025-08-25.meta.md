# Game of the Day - 2025-08-25

## Metadata
- **Generated Date:** 2025-08-25
- **Generated Time:** 2025-08-25T00:29:10.155044
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-25.js
- **File Size:** 34740 bytes
- **Tokens Used:** 11669

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-25.js` - The playable game
- `2025-08-25.meta.json` - Machine-readable metadata
- `2025-08-25.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 24779

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 27905

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function() {
  // Electricity-themed Math Game for ages 7-9
  // Renders into the element with ID "game-of-the-day-stage".
  // All visuals are canvas-drawn. Sounds use the Web Audio API.
  // Accessible instructions and controls are provided as DOM text inside the container.

  // --- Configuration ---
  const WIDTH = 720;
  const HEIGHT = 480;
  const CONTAINER_ID = "game-of-the-day-stage";
  const MAX_ROUNDS = 6;

  // --- Utility Functions ---
  function clamp(v, a, b) {
    return Math.max(a, Math.min(b, v));
  }

  function rand(min, max) {
    return Math.random() * (max - min) + min;
  }

  function choose(array) {
    return array[Math.floor(Math.random() * array.length)];
  }

  // --- Setup DOM and Canvas ---
  const container = document.getElementById(CONTAINER_ID);
  if (!container) {
    console.error(`Container element with id "${CONTAINER_ID}" not found.`);
    return;
  }
  // Clear container
  container.innerHTML = "";
  container.style.position = "relative";
  container.setAttribute("role", "application");
  container.setAttribute("aria-label", "Power Planet math game. Use mouse or keyboard controls.");
  container.tabIndex = 0;

  // Instruction / status area for accessibility (text, not visual)
  const infoBox = document.createElement("div");
  infoBox.style.fontFamily = "sans-serif";
  infoBox.style.fontSize = "13px";
  infoBox.style.color = "#0b0b0b";
  infoBox.style.margin = "6px 0";
  infoBox.setAttribute("aria-live", "polite");
  container.appendChild(infoBox);

  // Canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.width = WIDTH + "px";
  canvas.style.height = HEIGHT + "px";
  canvas.style.display = "block";
  canvas.style.cursor = "pointer";
  canvas.setAttribute("role", "img");
  canvas.setAttribute("aria-label", "Electric playground game canvas");
  container.appendChild(canvas);

  const ctx = canvas.getContext("2d");
  if (!ctx) {
    infoBox.textContent = "Sorry — your browser does not support canvas required for this game.";
    return;
  }

  // --- Audio Setup ---
  let audioCtx = null;
  let audioAvailable = false;
  let humOsc = null;
  let humGain = null;

  function tryCreateAudioContext() {
    if (audioCtx) return;
    try {
      window.AudioContext = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AudioContext();
      audioAvailable = true;
    } catch (e) {
      console.warn("AudioContext cannot be created:", e);
      audioAvailable = false;
      audioCtx = null;
    }
  }

  tryCreateAudioContext();

  // Because AudioContext often needs resume after user gesture, we resume on first interaction
  function ensureAudioOnUserGesture() {
    if (!audioCtx) tryCreateAudioContext();
    if (!audioCtx) return;
    if (audioCtx.state === "suspended") {
      audioCtx.resume().catch((e) => {
        console.warn("AudioContext resume failed:", e);
      });
    }
  }

  function startHum() {
    if (!audioAvailable) return;
    stopHum();
    try {
      humOsc = audioCtx.createOscillator();
      humGain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      humOsc.type = "sine";
      humOsc.frequency.value = 120; // gentle hum low freq
      filter.type = "lowpass";
      filter.frequency.value = 800;
      humGain.gain.value = 0.02;
      humOsc.connect(filter);
      filter.connect(humGain);
      humGain.connect(audioCtx.destination);
      humOsc.start();
    } catch (e) {
      console.warn("Failed to start hum:", e);
    }
  }

  function stopHum() {
    try {
      if (humOsc) {
        humOsc.stop();
        humOsc.disconnect();
      }
      if (humGain) humGain.disconnect();
    } catch (e) {
      // ignore
    } finally {
      humOsc = null;
      humGain = null;
    }
  }

  function playTone({ freq = 440, duration = 0.2, type = "sine", volume = 0.08, detune = 0 } = {}) {
    if (!audioAvailable) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      o.detune.value = detune;
      g.gain.value = volume;
      const filter = audioCtx.createBiquadFilter();
      filter.type = "lowpass";
      filter.frequency.value = freq * 3;
      o.connect(filter);
      filter.connect(g);
      g.connect(audioCtx.destination);

      const now = audioCtx.currentTime;
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(volume, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);
      o.start(now);
      o.stop(now + duration + 0.02);
    } catch (e) {
      console.warn("playTone error", e);
    }
  }

  function playSuccessMelody() {
    if (!audioAvailable) return;
    // simple short melody
    const notes = [660, 880, 990];
    notes.forEach((n, i) => {
      setTimeout(() => playTone({ freq: n, duration: 0.12, type: "triangle", volume: 0.08 }), i * 120);
    });
  }

  function playErrorSound() {
    if (!audioAvailable) return;
    // buzz with distortion effect by quick frequency modulation
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      o.type = "square";
      o.frequency.value = 120;
      filter.type = "lowpass";
      filter.frequency.value = 800;
      g.gain.value = 0.12;
      o.connect(filter);
      filter.connect(g);
      g.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(0.12, now + 0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.28);
      o.start(now);
      o.frequency.setValueAtTime(120, now);
      o.frequency.linearRampToValueAtTime(40, now + 0.15);
      o.stop(now + 0.3);
    } catch (e) {
      console.warn("playErrorSound error", e);
    }
  }

  // --- Game Data Structures ---
  const electrons = [];
  const devices = []; // bulbs that need a target sum
  let selectedDeviceIndex = 0;
  let round = 1;
  let score = 0;
  let lastActionMsg = "";
  let animations = [];
  let isPaused = false;
  let audioEnabled = true;

  // Characters (drawn in canvas)
  const characters = {
    DrVolt: { color: "#f2c94c", name: "Dr. Volt" },
    Sparky: { color: "#8bd3ff", name: "Sparky" },
    Bulby: { color: "#ffd1dc", name: "Bulby" }
  };

  // --- Create initial game state ---
  function resetGameState() {
    electrons.length = 0;
    devices.length = 0;
    selectedDeviceIndex = 0;
    round = 1;
    score = 0;
    animations.length = 0;
    spawnRound(round);
  }

  function spawnRound(r) {
    electrons.length = 0;
    devices.length = 0;
    animations.length = 0;

    // Create 3 target devices (bulbs) with target sums appropriate to round
    const targets = [];
    // as rounds progress, targets can grow
    for (let i = 0; i < 3; i++) {
      const base = clamp(4 + r + i, 4, 14);
      // add variety
      targets.push(base + (Math.random() < 0.4 ? 1 : 0));
    }

    // make device positions
    const padding = 40;
    const areaWidth = WIDTH - padding * 2;
    for (let i = 0; i < 3; i++) {
      const x = padding + (i + 0.5) * (areaWidth / 3);
      const y = 110;
      const device = {
        x,
        y,
        target: targets[i],
        collected: [],
        active: true,
        id: `bulb-${r}-${i}`
      };
      devices.push(device);
    }

    // spawn electrons with random values 1-9; ensure there are combinations to satisfy targets.
    // We'll create a pool biased to sums: include explicit needed numbers by decomposing targets.
    const neededPool = [];
    devices.forEach(dev => {
      let remaining = dev.target;
      // break target into 1-4 parts to ensure possible combinations
      const parts = Math.min(3, Math.max(1, Math.round(rand(1, 3))));
      for (let p = 0; p < parts - 1; p++) {
        const v = Math.max(1, Math.min(9, Math.round(rand(1, remaining - (parts - p - 1)))));
        neededPool.push(v);
        remaining -= v;
      }
      neededPool.push(Math.max(1, Math.min(9, remaining)));
    });

    // Add some random values too
    for (let i = 0; i < 8; i++) {
      neededPool.push(Math.ceil(rand(1, 9)));
    }

    // shuffle and create electrons
    for (let i = 0; i < neededPool.length; i++) {
      const v = neededPool[i];
      electrons.push(makeElectron(rand(80, WIDTH - 80), rand(200, HEIGHT - 80), v));
    }

    // Add some animated decorative sparks
    for (let i = 0; i < 12; i++) {
      animations.push(makeFloatingSpark(rand(40, WIDTH - 40), rand(40, HEIGHT - 40)));
    }

    lastActionMsg = `Round ${r}: Help Bulby, Sparky and Dr. Volt reach their charge! Select a bulb, then tap electrons to add numbers until the bulb reaches its target.`;
    updateInfoBox();
  }

  function makeElectron(x, y, value) {
    return {
      x,
      y,
      baseY: y,
      vx: rand(-0.3, 0.3),
      vy: rand(-0.2, 0.2),
      r: 18,
      value,
      id: Math.random().toString(36).slice(2),
      collected: false,
      angle: rand(0, Math.PI * 2),
      bob: rand(0, Math.PI * 2)
    };
  }

  function makeFloatingSpark(x, y) {
    return {
      type: "spark",
      x,
      y,
      r: rand(2, 6),
      phase: rand(0, Math.PI * 2)
    };
  }

  // --- Input Handling ---
  let mouse = { x: 0, y: 0, down: false };

  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
    mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
  });

  canvas.addEventListener("mousedown", (e) => {
    mouse.down = true;
    ensureAudioOnUserGesture();
    if (!audioCtx) audioAvailable = false;
    // Also resume hum
    if (audioEnabled && audioAvailable && !humOsc) startHum();
    handlePointerDown(mouse.x, mouse.y);
  });

  canvas.addEventListener("mouseup", (e) => {
    mouse.down = false;
  });

  canvas.addEventListener("click", (e) => {
    // also ensure audio context is resumed on click
    ensureAudioOnUserGesture();
  });

  // Touch support: map touch -> mouse
  canvas.addEventListener("touchstart", (e) => {
    e.preventDefault();
    const touch = e.changedTouches[0];
    const rect = canvas.getBoundingClientRect();
    mouse.x = (touch.clientX - rect.left) * (canvas.width / rect.width);
    mouse.y = (touch.clientY - rect.top) * (canvas.height / rect.height);
    mouse.down = true;
    ensureAudioOnUserGesture();
    handlePointerDown(mouse.x, mouse.y);
  }, { passive: false });

  canvas.addEventListener("touchend", (e) => {
    e.preventDefault();
    mouse.down = false;
  }, { passive: false });

  // Keyboard controls
  container.addEventListener("keydown", (e) => {
    // ensure key controls resume audio
    ensureAudioOnUserGesture();
    if (e.key === "ArrowLeft") {
      selectedDeviceIndex = (selectedDeviceIndex - 1 + devices.length) % devices.length;
      lastActionMsg = `${devices[selectedDeviceIndex].id} selected.`;
      updateInfoBox();
      playTone({ freq: 300, duration: 0.06, volume: 0.03, type: "sine" });
      e.preventDefault();
    } else if (e.key === "ArrowRight") {
      selectedDeviceIndex = (selectedDeviceIndex + 1) % devices.length;
      lastActionMsg = `${devices[selectedDeviceIndex].id} selected.`;
      updateInfoBox();
      playTone({ freq: 360, duration: 0.06, volume: 0.03, type: "sine" });
      e.preventDefault();
    } else if (e.key === "Enter" || e.key === " ") {
      // toggle selection message
      lastActionMsg = `Selected ${devices[selectedDeviceIndex].id}. Tap an electron to add it or press number keys 1-9.`;
      updateInfoBox();
      playTone({ freq: 480, duration: 0.06, volume: 0.04, type: "triangle" });
      e.preventDefault();
    } else if (e.key === "Backspace" || e.key === "Delete" || e.key === "Undo") {
      undoLastElectron();
      e.preventDefault();
    } else if (e.key >= "1" && e.key <= "9") {
      // pick nearest electron with that value
      const val = parseInt(e.key, 10);
      pickElectronByValue(val);
      e.preventDefault();
    } else if (e.key === "m" || e.key === "M") {
      toggleAudio();
      e.preventDefault();
    } else if (e.key === "p" || e.key === "P") {
      togglePause();
      e.preventDefault();
    }
  });

  // --- Interaction logic ---
  function handlePointerDown(x, y) {
    // Check audio toggle area top-left (we draw speaker icon there)
    if (x >= 12 && x <= 56 && y >= 12 && y <= 56) {
      toggleAudio();
      return;
    }

    // Check if clicked a device (bulb)
    for (let i = 0; i < devices.length; i++) {
      const d = devices[i];
      const dx = x - d.x;
      const dy = y - d.y;
      if (Math.sqrt(dx * dx + dy * dy) < 48) {
        selectedDeviceIndex = i;
        lastActionMsg = `Selected ${characters.Bulby.name} device ${i + 1}. Now add electrons to reach ${d.target}.`;
        updateInfoBox();
        playTone({ freq: 420, duration: 0.08, type: "triangle", volume: 0.05 });
        return;
      }
    }

    // Else check electrons
    for (let e of electrons) {
      if (e.collected) continue;
      const dx = x - e.x;
      const dy = y - e.y;
      if (Math.sqrt(dx * dx + dy * dy) < e.r + 6) {
        collectElectron(e);
        return;
      }
    }
  }

  function collectElectron(electron) {
    const dev = devices[selectedDeviceIndex];
    if (!dev || !dev.active) {
      lastActionMsg = "Select a device first by clicking on a bulb.";
      updateInfoBox();
      playErrorSound();
      return;
    }

    // compute sum if added
    const currentSum = dev.collected.reduce((a, b) => a + b.value, 0);
    const newSum = currentSum + electron.value;

    if (newSum > dev.target) {
      // incorrect: overload
      lastActionMsg = `Oh no! Overload: ${currentSum} + ${electron.value} = ${newSum} (target ${dev.target}). Try a smaller electron.`;
      updateInfoBox();
      playErrorSound();
      // show small explosion animation
      animations.push(makeOverloadAnim(electron.x, electron.y));
      return;
    }

    // successful pick
    electron.collected = true;
    electron.collectedAt = { x: electron.x, y: electron.y };
    electron.collectTime = performance.now();
    dev.collected.push(electron);

    // small visual attach animation: animate electron to device
    animations.push(makeAttachAnim(electron, dev));

    lastActionMsg = `Added ${electron.value} to device (${currentSum} -> ${newSum}/${dev.target})`;
    updateInfoBox();
    playTone({ freq: 520 + electron.value * 15, duration: 0.12, type: "sine", volume: 0.06 });

    // If exact
    if (newSum === dev.target) {
      dev.active = false;
      score += 10;
      lastActionMsg = `Great! Device reached ${dev.target}. The bulb lights up!`;
      updateInfoBox();
      playSuccessMelody();
      animations.push(makeLightUpAnim(dev.x, dev.y));
      // check if all done -> next round
      if (devices.every(d => !d.active)) {
        setTimeout(() => {
          round++;
          if (round <= MAX_ROUNDS) {
            lastActionMsg = `Round complete! Get ready for round ${round}.`;
            updateInfoBox();
            spawnRound(round);
          } else {
            lastActionMsg = `You finished all rounds! Final score: ${score}. Press R to replay.`;
            updateInfoBox();
            // listen for R to reset
            const onR = (ev) => {
              if (ev.key === "r" || ev.key === "R") {
                resetGameState();
                container.removeEventListener("keydown", onR);
              }
            };
            container.addEventListener("keydown", onR);
          }
        }, 900);
      }
    }
  }

  function undoLastElectron() {
    const dev = devices[selectedDeviceIndex];
    if (!dev) return;
    const removed = dev.collected.pop();
    if (!removed) {
      lastActionMsg = "Nothing to undo for this device.";
      updateInfoBox();
      playErrorSound();
      return;
    }
    // return electron to active
    removed.collected = false;
    removed.collectTime = null;
    lastActionMsg = `Removed ${removed.value} from device.`;
    updateInfoBox();
    playTone({ freq: 240, duration: 0.08, type: "sine", volume: 0.04 });
  }

  function pickElectronByValue(val) {
    // choose nearest electron to selected device with that value that is not collected
    const candidates = electrons.filter(e => !e.collected && e.value === val);
    if (candidates.length === 0) {
      lastActionMsg = `No available electron with value ${val}.`;
      updateInfoBox();
      playErrorSound();
      return;
    }
    const dev = devices[selectedDeviceIndex];
    const chosen = candidates.reduce((best, c) => {
      const d = Math.hypot(c.x - dev.x, c.y - dev.y);
      if (!best || d < best.d) return { c, d };
      return best;
    }, null).c;
    collectElectron(chosen);
  }

  // --- Animations / Visual effects ---
  function makeAttachAnim(electron, device) {
    const start = { x: electron.x, y: electron.y };
    const end = { x: device.x + rand(-18, 18), y: device.y + rand(24, 40) };
    const startTime = performance.now();
    const duration = 470;
    return {
      type: "attach",
      electron,
      start,
      end,
      startTime,
      duration
    };
  }

  function makeOverloadAnim(x, y) {
    return { type: "overload", x, y, t: performance.now(), life: 520 };
  }

  function makeLightUpAnim(x, y) {
    return { type: "light", x, y, t: performance.now(), life: 900 };
  }

  // --- Drawing ---
  function draw() {
    // background
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    drawBackground();
    drawCharacters();
    drawDevices();
    drawElectrons();
    drawAnimations();
    drawHUD();
    drawAudioIcon();
  }

  function drawBackground() {
    // gradient sky
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, "#e8f7ff");
    g.addColorStop(1, "#f6fbff");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // wacky clouds using arcs
    for (let i = 0; i < 5; i++) {
      const cx = (i / 5) * WIDTH + ((i % 2) * 80) - 60;
      const cy = 50 + (i % 2) * 10;
      ctx.fillStyle = `rgba(255,255,255,0.85)`;
      ctx.beginPath();
      ctx.ellipse(cx + 30, cy, 60, 26, 0, 0, Math.PI * 2);
      ctx.ellipse(cx - 10, cy - 6, 44, 22, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    // soft grid lines to suggest circuits
    ctx.strokeStyle = "rgba(12,22,45,0.03)";
    ctx.lineWidth = 1;
    for (let x = 0; x < WIDTH; x += 36) {
      ctx.beginPath();
      ctx.moveTo(x + (Math.sin(performance.now() / 2000 + x) * 3), 0);
      ctx.lineTo(x + (Math.cos(performance.now() / 1800 + x) * 3), HEIGHT);
      ctx.stroke();
    }
  }

  function drawCharacters() {
    // Dr. Volt (battery) left bottom
    const dvx = 82;
    const dvy = HEIGHT - 80;
    drawBattery(dvx, dvy, characters.DrVolt.color, "Dr. Volt");

    // Sparky (spark) right bottom
    drawSpark( WIDTH - 120, HEIGHT - 85, characters.Sparky.color, "Sparky");

    // Bulby small mascot near top center
    drawBulb(WIDTH / 2, 60, characters.Bulby.color, "Bulby");

    // subtle ground platform
    ctx.fillStyle = "rgba(10,10,10,0.04)";
    ctx.fillRect(0, HEIGHT - 40, WIDTH, 40);
  }

  function drawBattery(x, y, color, label) {
    ctx.save();
    ctx.translate(x, y);
    // body
    ctx.fillStyle = color;
    roundRect(ctx, -32, -24, 64, 48, 10);
    ctx.fill();
    ctx.strokeStyle = "#6b4c00";
    ctx.lineWidth = 1.5;
    ctx.stroke();
    // plus terminal
    ctx.fillStyle = "#ffffff";
    roundRect(ctx, -12, -34, 24, 8, 3);
    ctx.fill();
    // eyes and smile
    ctx.fillStyle = "#3a2b1a";
    ctx.beginPath();
    ctx.arc(-10, -6, 3.5, 0, Math.PI * 2);
    ctx.arc(10, -6, 3.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(0, 2, 9, 0, Math.PI);
    ctx.stroke();
    // label text
    ctx.fillStyle = "#2c2c2c";
    ctx.font = "12px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(label, 0, 30);
    ctx.restore();
  }

  function drawSpark(x, y, color, label) {
    ctx.save();
    ctx.translate(x, y);
    // body
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(0, -28);
    ctx.lineTo(12, -4);
    ctx.lineTo(28, 0);
    ctx.lineTo(12, 6);
    ctx.lineTo(0, 28);
    ctx.lineTo(-12, 6);
    ctx.lineTo(-28, 0);
    ctx.lineTo(-12, -4);
    ctx.closePath();
    ctx.fill();
    // eyes
    ctx.fillStyle = "#1d2a2e";
    ctx.beginPath();
    ctx.arc(-8, -2, 3, 0, Math.PI * 2);
    ctx.arc(8, -2, 3, 0, Math.PI * 2);
    ctx.fill();
    // label
    ctx.fillStyle = "#1d2a2e";
    ctx.font = "12px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(label, 0, 36);
    ctx.restore();
  }

  function drawBulb(x, y, color, label) {
    ctx.save();
    ctx.translate(x, y);
    // glass
    const gradient = ctx.createRadialGradient(-6, -6, 4, 6, 6, 50);
    gradient.addColorStop(0, "#ffffff");
    gradient.addColorStop(1, color);
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.ellipse(0, 6, 30, 32, 0, 0, Math.PI * 2);
    ctx.fill();
    // base
    ctx.fillStyle = "#b3b3b3";
    roundRect(ctx, -14, 32, 28, 14, 3);
    ctx.fill();
    // filament smile
    ctx.strokeStyle = "#6b4c00";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-10, 6);
    ctx.quadraticCurveTo(0, 18, 10, 6);
    ctx.stroke();
    // label
    ctx.fillStyle = "#2c2c2c";
    ctx.font = "12px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(label, 0, -28);
    ctx.restore();
  }

  function drawDevices() {
    // draw each bulb device with target and collected electrons
    devices.forEach((d, idx) => {
      // bulb body
      const lit = !d.active;
      ctx.save();
      ctx.translate(d.x, d.y);
      // outer glow when lit
      if (lit) {
        const g = ctx.createRadialGradient(0, 6, 4, 0, 6, 60);
        g.addColorStop(0, "rgba(255,228,120,0.8)");
        g.addColorStop(1, "rgba(255,228,120,0)");
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.ellipse(0, 6, 66, 72, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      // glass
      ctx.fillStyle = lit ? "#fff1b8" : "#fff";
      ctx.beginPath();
      ctx.ellipse(0, 6, 30, 32, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "#d7c2a6";
      ctx.lineWidth = 1.5;
      ctx.stroke();
      // base
      ctx.fillStyle = "#a0a0a0";
      roundRect(ctx, -14, 32, 28, 14, 3);
      ctx.fill();

      // target label and current sum
      const current = d.collected.reduce((a, b) => a + b.value, 0);
      ctx.fillStyle = "#1d2a2e";
      ctx.font = "14px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(`Target: ${d.target}`, 0, -46);
      ctx.fillText(`${current} / ${d.target}`, 0, 60);

      // show selection highlight
      if (selectedDeviceIndex === idx) {
        ctx.strokeStyle = "rgba(38, 150, 255, 0.9)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.ellipse(0, 6, 40, 44, 0, 0, Math.PI * 2);
        ctx.stroke();
      }

      // draw wires: connect to battery left bottom
      ctx.strokeStyle = "rgba(60,60,60,0.25)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(-300, HEIGHT - 80 - 20); // left towards battery
      ctx.quadraticCurveTo(d.x - 120, d.y + 60, d.x, d.y + 34);
      ctx.stroke();

      // draw collected tokens near device
      const startX = -28;
      d.collected.forEach((e, i) => {
        const px = startX + i * 18;
        const py = 44;
        ctx.fillStyle = "#fffaf0";
        ctx.beginPath();
        ctx.arc(px, py, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#2b2b2b";
        ctx.font = "12px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(String(e.value), px, py + 4);
      });

      ctx.restore();
    });
  }

  function drawElectrons() {
    // update electron positions (bob motion), then draw
    const now = performance.now();
    electrons.forEach(e => {
      if (e.collected) {
        // when collected, do not draw at original pos; attach anim moves it
        return;
      }
      // bob
      e.bob += 0.02 + Math.sin(now / 6000 + e.angle) * 0.002;
      e.x += e.vx;
      e.y = e.baseY + Math.sin(e.bob) * 8;
      // wrap edges
      if (e.x < 30) e.x = 30;
      if (e.x > WIDTH - 30) e.x = WIDTH - 30;
      // draw
      drawElectron(e);
    });
  }

  function drawElectron(e) {
    // glow
    ctx.save();
    ctx.globalAlpha = 0.95;
    const g = ctx.createRadialGradient(e.x, e.y - 4, 2, e.x, e.y, 28);
    g.addColorStop(0, "rgba(255,255,200,0.95)");
    g.addColorStop(1, "rgba(255,225,100,0.02)");
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.ellipse(e.x, e.y, e.r + 10, e.r + 6, 0, 0, Math.PI * 2);
    ctx.fill();

    // core circle
    ctx.beginPath();
    ctx.fillStyle = "#fff8e5";
    ctx.arc(e.x, e.y, e.r + 2, 0, Math.PI * 2);
    ctx.fill();
    // ring
    ctx.strokeStyle = "#f2b800";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.r + 2, 0, Math.PI * 2);
    ctx.stroke();
    // number text
    ctx.fillStyle = "#2a2a2a";
    ctx.font = "bold 14px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(String(e.value), e.x, e.y + 5);
    ctx.restore();
  }

  function drawAnimations() {
    const now = performance.now();
    // process attach animations
    animations = animations.filter(a => {
      if (a.type === "attach") {
        const t = (now - a.startTime) / a.duration;
        if (t >= 1) return false;
        const ease = 1 - Math.pow(1 - t, 3);
        const x = a.start.x + (a.end.x - a.start.x) * ease;
        const y = a.start.y + (a.end.y - a.start.y) * ease;
        // draw a moving electron
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.beginPath();
        ctx.fillStyle = "#fffaf0";
        ctx.arc(x, y, 10 + (1 - t) * 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#2a2a2a";
        ctx.font = "12px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(String(a.electron.value), x, y + 4);
        ctx.restore();
        // small wire spark
        ctx.save();
        ctx.strokeStyle = `rgba(255,220,120,${1 - t})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(a.start.x, a.start.y);
        ctx.lineTo(x, y);
        ctx.stroke();
        ctx.restore();
        return true;
      } else if (a.type === "overload") {
        const tt = (now - a.t) / a.life;
        if (tt > 1) return false;
        // draw a quick burst
        ctx.save();
        const alpha = 1 - tt;
        for (let i = 0; i < 7; i++) {
          ctx.strokeStyle = `rgba(255,60,60,${alpha})`;
          ctx.lineWidth = 1.2;
          ctx.beginPath();
          const ang = (i / 7) * Math.PI * 2 + tt * 8;
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(a.x + Math.cos(ang) * 18 * (1 - tt), a.y + Math.sin(ang) * 18 * (1 - tt));
          ctx.stroke();
        }
        ctx.restore();
        return true;
      } else if (a.type === "light") {
        const life = a.life;
        const t = (now - a.t) / life;
        if (t > 1) return false;
        // expanding glow
        ctx.save();
        const rad = 40 + t * 60;
        const g = ctx.createRadialGradient(a.x, a.y, 10, a.x, a.y, rad);
        g.addColorStop(0, `rgba(255,236,150,${0.6 - t * 0.5})`);
        g.addColorStop(1, "rgba(255,236,150,0)");
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.ellipse(a.x, a.y, rad, rad * 1.2, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        return true;
      }
      return false;
    });

    // decorative floating sparks
    animations.forEach(a => {
      if (a.type === "spark") {
        a.phase += 0.01;
        const r = a.r + Math.sin(a.phase * 2) * 1.25;
        ctx.save();
        ctx.fillStyle = `rgba(255,255,180,0.6)`;
        ctx.beginPath();
        ctx.arc(a.x, a.y + Math.sin(a.phase) * 6, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    });

    // draw collected electrons anchored to devices (static)
    devices.forEach(d => {
      d.collected.forEach((e, i) => {
        // find if an attach anim in progress for this electron; if so skip drawing static small token
        const inAnim = animations.some(a => a.type === "attach" && a.electron === e);
        if (inAnim) return;
        // else draw a token near device
        ctx.save();
        ctx.translate(d.x, d.y);
        const px = -28 + i * 18;
        const py = 44;
        ctx.beginPath();
        ctx.fillStyle = "#fffaf0";
        ctx.arc(px, py, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#2d2d2d";
        ctx.font = "12px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(String(e.value), px, py + 4);
        ctx.restore();
      });
    });
  }

  function drawHUD() {
    // top bar with score, round, instructions
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.6)";
    ctx.fillRect(8, 8, WIDTH - 16, 52);
    // title and info
    ctx.fillStyle = "#15202b";
    ctx.font = "18px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText(`Power Planet - Round ${round}`, 20, 30);
    ctx.font = "14px sans-serif";
    ctx.fillText(`Score: ${score}`, 20, 48);

    // last action message
    ctx.font = "13px sans-serif";
    ctx.textAlign = "center";
    ctx.fillStyle = "#2c3a47";
    ctx.fillText(lastActionMsg, WIDTH / 2, 34);

    // small control hints right
    ctx.font = "12px sans-serif";
    ctx.textAlign = "right";
    ctx.fillStyle = "#2d3b44";
    ctx.fillText("Click a bulb → Click electrons to add | Keys: ← → 1-9 Backspace M", WIDTH - 16, 44);

    ctx.restore();
  }

  function drawAudioIcon() {
    // top-left small speaker icon inside canvas for toggling audio
    const x = 22;
    const y = 34;
    ctx.save();
    ctx.beginPath();
    ctx.fillStyle = audioEnabled ? "#2d9cdb" : "#b0b0b0";
    ctx.rect(12, 12, 44, 44);
    ctx.fillStyle = "rgba(255,255,255,0.05)";
    ctx.fillRect(12, 12, 44, 44);
    // speaker body
    ctx.fillStyle = audioEnabled ? "#2d9cdb" : "#a0a0a0";
    ctx.beginPath();
    ctx.moveTo(16, 32);
    ctx.lineTo(28, 24);
    ctx.lineTo(28, 40);
    ctx.closePath();
    ctx.fill();
    // sound waves
    ctx.strokeStyle = audioEnabled ? "#2d9cdb" : "#a0a0a0";
    ctx.lineWidth = 2;
    if (audioEnabled) {
      ctx.beginPath();
      ctx.arc(36, 32, 8, -0.6, 0.6);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(36, 32, 12, -0.6, 0.6);
      ctx.stroke();
    } else {
      // X mark when muted
      ctx.strokeStyle = "#d9534f";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(34, 25);
      ctx.lineTo(44, 39);
      ctx.moveTo(44, 25);
      ctx.lineTo(34, 39);
      ctx.stroke();
    }

    // accessible hint text near icon
    ctx.font = "10px sans-serif";
    ctx.fillStyle = "#2d3b44";
    ctx.textAlign = "left";
    ctx.fillText("M to mute", 12, 58);
    ctx.restore();
  }

  // --- Helpers ---
  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  // --- Animation Loop ---
  let lastTime = 0;
  function loop(t) {
    if (isPaused) {
      // draw paused overlay
      draw();
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.36)";
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = "#fff";
      ctx.font = "34px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Paused", WIDTH / 2, HEIGHT / 2);
      ctx.restore();
      requestAnimationFrame(loop);
      return;
    }
    draw();
    lastTime = t;
    requestAnimationFrame(loop);
  }

  // --- Pause / Audio toggles ---
  function togglePause() {
    isPaused = !isPaused;
    lastActionMsg = isPaused ? "Game paused. Press P to resume." : "Game resumed!";
    updateInfoBox();
    playTone({ freq: 320, duration: 0.08, volume: 0.03 });
  }

  function toggleAudio() {
    audioEnabled = !audioEnabled;
    if (audioEnabled) {
      ensureAudioOnUserGesture();
      if (audioAvailable) startHum();
      lastActionMsg = "Audio on.";
      playTone({ freq: 600, duration: 0.08, volume: 0.05, type: "triangle" });
    } else {
      stopHum();
      lastActionMsg = "Audio muted. Press M or click speaker to unmute.";
      playErrorSound();
    }
    updateInfoBox();
  }

  // --- Info Box / Accessibility Text ---
  function updateInfoBox() {
    // Provide simple textual instructions and current state
    const dev = devices[selectedDeviceIndex];
    const devLabel = dev ? `Bulb ${selectedDeviceIndex + 1} target ${dev.target} current ${dev.collected.reduce((a,b)=>a+b.value,0)}` : "";
    infoBox.textContent = `Round ${round} | Score ${score} | ${devLabel} | ${lastActionMsg} Controls: Click a bulb, then click electrons. Keyboard: Left/Right to change bulb, 1-9 to pick, Backspace to undo, M to mute.`;
  }

  // --- Extra Animations on specific events are added in their functions above ---

  // --- Initialize and start ---
  resetGameState();

  // Ensure audio is off initially until user interacts
  if (audioAvailable && audioEnabled) {
    // do not auto-start hum until user interacts
    stopHum();
  }

  // Kick off loop
  requestAnimationFrame(loop);

  // Announce initial instructions
  lastActionMsg = "Welcome to Power Planet! Click a bulb to select it, then click electrons to add numbers to reach the target. Try using keys 1-9 too. Press M to mute.";
  updateInfoBox();

  // In case audio context cannot be created, inform user
  if (!audioAvailable) {
    lastActionMsg = "Audio is not available in this browser — sound will be disabled. Follow on-screen text instructions.";
    updateInfoBox();
  }

  // Expose a small help overlay when pressing H or ?
  container.addEventListener("keydown", (e) => {
    if (e.key === "?" || e.key === "h" || e.key === "H") {
      alert("Power Planet Help:\n- Click a bulb (top) to select it.\n- Click electrons (floating circles) to add their value to the selected bulb.\n- Use keys 1-9 to pick electrons by number.\n- Use ← → to switch selected bulb. Backspace to undo the last pick for the selected bulb.\n- M to mute/unmute audio. P to pause.\n- Reach the target exactly to light each bulb. Enjoy!");
    }
  });

  // Provide error handling for unexpected runtime exceptions inside animation frames
  window.addEventListener("error", (ev) => {
    console.error("Runtime error in game:", ev.error || ev.message);
    lastActionMsg = "An unexpected error occurred. Please reload the page to try again.";
    updateInfoBox();
    stopHum();
  });
})();
---

