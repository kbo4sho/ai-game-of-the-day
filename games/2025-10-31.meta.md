# Game of the Day - 2025-10-31

## Metadata
- **Generated Date:** 2025-10-31
- **Generated Time:** 2025-10-31T00:28:00.037570
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-10-31.js
- **File Size:** 27110 bytes
- **Tokens Used:** 9752

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-10-31.js` - The playable game
- `2025-10-31.meta.json` - Machine-readable metadata
- `2025-10-31.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 20364

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 22584

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Drone Math Delivery - Canvas Game
  // Renders into element with id "game-of-the-day-stage"
  // For kids ages 7-9. Uses Web Audio API for sounds. All graphics drawn on canvas.

  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const PADDING = 12;
  const TARGET_SCORE = 10;
  const MAX_LIVES = 3;
  const OPTION_COUNT = 4;

  // DOM setup
  const container = document.getElementById("game-of-the-day-stage");
  if (!container) {
    console.error("Missing container element with id 'game-of-the-day-stage'.");
    return;
  }
  container.innerHTML = ""; // clear any children
  container.style.position = "relative";

  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute("role", "img");
  canvas.setAttribute("aria-label", "Drone Delivery Math Game");
  canvas.style.display = "block";
  container.appendChild(canvas);

  const ctx = canvas.getContext("2d");
  if (!ctx) {
    console.error("Unable to get 2D context.");
    return;
  }

  // Audio setup with error handling
  let audioContext = null;
  let masterGain = null;
  let ambientGain = null;
  let audioEnabled = false;
  let audioAllowed = false;
  try {
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if (AudioCtx) {
      audioContext = new AudioCtx();
      masterGain = audioContext.createGain();
      ambientGain = audioContext.createGain();
      masterGain.gain.value = 0.9;
      ambientGain.gain.value = 0.06; // very gentle ambient hum
      ambientGain.connect(masterGain);
      masterGain.connect(audioContext.destination);
      // start ambient hum
      startAmbientHum();
    } else {
      console.warn("Web Audio API not supported in this browser.");
    }
  } catch (e) {
    console.error("Error creating AudioContext:", e);
    audioContext = null;
  }

  function resumeAudioIfNeeded() {
    if (!audioContext) return;
    if (audioContext.state === "suspended") {
      audioContext.resume().then(() => {
        audioAllowed = true;
        audioEnabled = true;
      }).catch((err) => {
        console.warn("Audio resume failed:", err);
      });
    } else {
      audioAllowed = true;
      audioEnabled = true;
    }
  }

  // Ambient hum - a gentle backing oscillator with subtle movement
  let ambientOsc1 = null;
  let ambientOsc2 = null;
  function startAmbientHum() {
    if (!audioContext) return;
    try {
      ambientOsc1 = audioContext.createOscillator();
      ambientOsc1.type = "sine";
      ambientOsc1.frequency.value = 90; // low drone hum
      const amp1 = audioContext.createGain();
      amp1.gain.value = 0.02;
      ambientOsc1.connect(amp1);
      amp1.connect(ambientGain);

      ambientOsc2 = audioContext.createOscillator();
      ambientOsc2.type = "sine";
      ambientOsc2.frequency.value = 120;
      const amp2 = audioContext.createGain();
      amp2.gain.value = 0.02;
      ambientOsc2.connect(amp2);
      amp2.connect(ambientGain);

      ambientOsc1.start();
      ambientOsc2.start();
      audioAllowed = audioContext.state !== "suspended";
      audioEnabled = audioAllowed;
    } catch (e) {
      console.error("Error starting ambient sound:", e);
    }
  }

  // Play a short tone; returns a promise that resolves when done
  function playTone({ frequency = 440, type = "sine", duration = 0.2, volume = 0.12, detune = 0 } = {}) {
    if (!audioContext || !audioEnabled) return Promise.resolve();
    try {
      const now = audioContext.currentTime;
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      osc.type = type;
      osc.frequency.value = frequency;
      osc.detune.value = detune;
      gain.gain.setValueAtTime(volume, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
      osc.connect(gain);
      gain.connect(masterGain);
      osc.start(now);
      osc.stop(now + duration + 0.05);
      return new Promise((res) => {
        setTimeout(res, (duration + 0.05) * 1000);
      });
    } catch (e) {
      console.warn("playTone failed:", e);
      return Promise.resolve();
    }
  }

  // Correct and incorrect feedback sequences
  async function playCorrectSound() {
    if (!audioContext || !audioEnabled) return;
    // pleasant ascending chirp
    const seq = [
      { f: 660, d: 0.08 },
      { f: 880, d: 0.10 },
      { f: 990, d: 0.12 }
    ];
    for (const s of seq) {
      await playTone({ frequency: s.f, type: "sine", duration: s.d, volume: 0.08 });
    }
  }
  async function playIncorrectSound() {
    if (!audioContext || !audioEnabled) return;
    // low buzzer
    await playTone({ frequency: 160, type: "square", duration: 0.22, volume: 0.14 });
    await playTone({ frequency: 120, type: "square", duration: 0.18, volume: 0.12 });
  }

  // Utility: rounded rectangle
  function roundRect(ctx, x, y, w, h, r) {
    const radius = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.arcTo(x + w, y, x + w, y + h, radius);
    ctx.arcTo(x + w, y + h, x, y + h, radius);
    ctx.arcTo(x, y + h, x, y, radius);
    ctx.arcTo(x, y, x + w, y, radius);
    ctx.closePath();
  }

  // Game state
  let state = {
    score: 0,
    lives: MAX_LIVES,
    currentQuestion: null,
    options: [],
    correctIndex: 0,
    selectedOption: -1,
    wrongCount: 0,
    started: false,
    phase: "playing", // "playing", "won", "lost"
    droneX: 40,
    droneY: 110,
    lastAnswerTime: 0,
    hoverIndex: -1,
    ambientEnabled: true,
    lastInteraction: Date.now()
  };

  // Accessibility: instructions text
  const instructionsLines = [
    "Use mouse or keyboard to answer:",
    "Click an option or press 1-4 to choose, Enter to confirm.",
    "Press M to toggle sound. Press R or Enter on end screen to restart."
  ];

  // Generate a new math question appropriate for ages 7-9
  function makeQuestion() {
    // Randomly choose addition/subtraction or simple multiplication occasionally
    const typeRoll = Math.random();
    let a, b, problemText, answer;
    if (typeRoll < 0.7) {
      // addition or subtraction
      if (Math.random() < 0.5) {
        // addition up to 20
        a = Math.floor(Math.random() * 16) + 2; // 2..17
        b = Math.floor(Math.random() * 9) + 1; // 1..9
        answer = a + b;
        problemText = `${a} + ${b} = ?`;
      } else {
        // subtraction ensuring non-negative
        a = Math.floor(Math.random() * 19) + 5; // 5..23
        b = Math.floor(Math.random() * 5) + 1; // 1..5
        if (b > a) [a, b] = [b, a];
        answer = a - b;
        problemText = `${a} − ${b} = ?`;
      }
    } else {
      // simple multiplication 2..5 times 2..6
      a = Math.floor(Math.random() * 4) + 2; // 2..5
      b = Math.floor(Math.random() * 5) + 2; // 2..6
      answer = a * b;
      problemText = `${a} × ${b} = ?`;
    }
    // Build options: include correct and distractors
    const options = new Set();
    options.add(answer);
    while (options.size < OPTION_COUNT) {
      // distractors within reasonable range
      let delta = Math.max(1, Math.floor(Math.random() * 5));
      let candidate = answer + (Math.random() < 0.5 ? -delta : delta);
      if (Math.random() < 0.1) candidate = answer + (Math.floor(Math.random() * 10) - 5);
      if (candidate < 0) continue;
      options.add(candidate);
    }
    const optsArr = Array.from(options);
    // Shuffle and determine correct index
    for (let i = optsArr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [optsArr[i], optsArr[j]] = [optsArr[j], optsArr[i]];
    }
    const correctIndex = optsArr.indexOf(answer);
    state.currentQuestion = problemText;
    state.options = optsArr;
    state.correctIndex = correctIndex;
    state.selectedOption = -1;
    state.hoverIndex = -1;
    state.lastAnswerTime = 0;
  }

  // Hit test for option rectangles: compute layout then check
  function layoutOptions() {
    // Two-by-two grid centered in lower half
    const boxW = 280;
    const boxH = 64;
    const gapX = 20;
    const gapY = 18;
    const totalW = boxW * 2 + gapX;
    const startX = (WIDTH - totalW) / 2;
    const startY = 220;
    const rects = [];
    for (let i = 0; i < OPTION_COUNT; i++) {
      const col = i % 2;
      const row = Math.floor(i / 2);
      const x = startX + col * (boxW + gapX);
      const y = startY + row * (boxH + gapY);
      rects.push({ x, y, w: boxW, h: boxH });
    }
    return rects;
  }

  // Input handling
  canvas.addEventListener("mousedown", (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    handlePointer(mx, my, true);
    resumeAudioIfNeeded();
    state.lastInteraction = Date.now();
  });
  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    handlePointer(mx, my, false);
  });
  window.addEventListener("keydown", (e) => {
    // Global keyboard control
    if (!state.started) {
      state.started = true;
    }
    resumeAudioIfNeeded();
    state.lastInteraction = Date.now();
    if (state.phase === "won" || state.phase === "lost") {
      if (e.key === "r" || e.key === "R" || e.key === "Enter") {
        restartGame();
      }
      return;
    }
    if (e.key === "m" || e.key === "M") {
      toggleAudio();
      return;
    }
    // number keys 1 to 4 select
    if (["1", "2", "3", "4"].includes(e.key)) {
      const idx = parseInt(e.key, 10) - 1;
      selectOption(idx);
      return;
    }
    // arrows navigate
    if (e.key === "ArrowRight") {
      moveSelection(1);
    } else if (e.key === "ArrowLeft") {
      moveSelection(-1);
    } else if (e.key === "ArrowUp") {
      moveSelection(-2);
    } else if (e.key === "ArrowDown") {
      moveSelection(2);
    } else if (e.key === "Enter" || e.key === " ") {
      // confirm
      if (state.selectedOption >= 0) {
        submitAnswer(state.selectedOption);
      }
    }
  });

  function toggleAudio() {
    if (!audioContext) return;
    audioEnabled = !audioEnabled;
    if (audioEnabled && audioContext.state === "suspended") {
      audioContext.resume().catch(() => {});
    }
  }

  function handlePointer(mx, my, isClick) {
    // If on end screen, check restart button
    if (state.phase === "won" || state.phase === "lost") {
      const btn = endScreenButtonRect();
      if (mx >= btn.x && mx <= btn.x + btn.w && my >= btn.y && my <= btn.y + btn.h) {
        if (isClick) restartGame();
      }
      return;
    }

    // Check options
    const rects = layoutOptions();
    let found = -1;
    for (let i = 0; i < rects.length; i++) {
      const r = rects[i];
      if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) {
        found = i;
        break;
      }
    }
    state.hoverIndex = found;
    if (isClick && found >= 0) {
      selectOption(found);
      submitAnswer(found);
    }
  }

  function moveSelection(delta) {
    let idx = state.selectedOption;
    if (idx < 0) idx = 0;
    idx = (idx + delta + OPTION_COUNT) % OPTION_COUNT;
    state.selectedOption = idx;
  }

  function selectOption(idx) {
    if (state.phase !== "playing") return;
    state.selectedOption = idx;
  }

  // Submission and scoring
  function submitAnswer(idx) {
    if (state.phase !== "playing") return;
    const now = Date.now();
    // prevent very fast repeat submissions
    if (now - state.lastAnswerTime < 250) return;
    state.lastAnswerTime = now;

    if (idx === state.correctIndex) {
      state.score += 1;
      state.droneX = Math.min(WIDTH - 120, 40 + Math.floor((state.score / TARGET_SCORE) * (WIDTH - 180)));
      playCorrectSound().catch(() => {});
      // fun wobble
      animateSuccess();
      if (state.score >= TARGET_SCORE) {
        state.phase = "won";
        playVictorySequence();
      } else {
        // new question after short delay
        setTimeout(makeQuestion, 700);
      }
    } else {
      state.lives -= 1;
      state.wrongCount += 1;
      playIncorrectSound().catch(() => {});
      animateCrash();
      if (state.lives <= 0) {
        state.phase = "lost";
      } else {
        // keep same question or provide new? We'll provide a new question after short delay
        setTimeout(makeQuestion, 700);
      }
    }
    state.selectedOption = -1;
  }

  // Victory sound sequence
  async function playVictorySequence() {
    if (!audioContext || !audioEnabled) return;
    // arpeggio
    const notes = [880, 990, 1320, 1760];
    for (let i = 0; i < notes.length; i++) {
      await playTone({ frequency: notes[i], type: "sine", duration: 0.16, volume: 0.09 });
    }
    // small celebratory burst
    for (let i = 0; i < 3; i++) {
      await playTone({ frequency: 660 + i * 80, type: "triangle", duration: 0.12, volume: 0.08 });
    }
  }

  // Simple animations tracked by timers
  let anims = {
    successPulse: { t: 0 },
    crashShake: { t: 0 }
  };

  function animateSuccess() {
    anims.successPulse.t = 1.0; // counts down in update
  }
  function animateCrash() {
    anims.crashShake.t = 1.0;
  }

  // Restart game
  function restartGame() {
    state.score = 0;
    state.lives = MAX_LIVES;
    state.wrongCount = 0;
    state.phase = "playing";
    state.droneX = 40;
    state.started = true;
    makeQuestion();
  }

  // End screen button rect
  function endScreenButtonRect() {
    const text = "Restart (R or Enter)";
    ctx.font = "18px sans-serif";
    const textW = ctx.measureText(text).width;
    const btnW = textW + 28;
    const btnH = 42;
    const x = (WIDTH - btnW) / 2;
    const y = HEIGHT / 2 + 60;
    return { x, y, w: btnW, h: btnH, text };
  }

  // Drawing the entire scene
  function draw() {
    try {
      // clear
      ctx.clearRect(0, 0, WIDTH, HEIGHT);

      // background - calming sky gradient with wacky stripes
      const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
      g.addColorStop(0, "#BEE3F8");
      g.addColorStop(0.5, "#E6F7FF");
      g.addColorStop(1, "#FAFFFE");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      // playful clouds (wacky)
      drawCloud(80, 60, 70, 36, "#FFFFFF", "#EAF7FF");
      drawCloud(250, 40, 100, 52, "#F8FFFF", "#E0F4FF");
      drawCloud(560, 70, 72, 38, "#FFFFFF", "#F0FBFF");

      // distant hills
      ctx.fillStyle = "#D6F7E3";
      roundRect(ctx, -40, HEIGHT - 160, WIDTH + 80, 220, 120);
      ctx.fill();

      // decorative sun
      ctx.beginPath();
      ctx.arc(WIDTH - 70, 60, 30, 0, Math.PI * 2);
      ctx.fillStyle = "#FFF2B8";
      ctx.fill();

      // UI: Score top-left
      ctx.font = "18px sans-serif";
      const scoreText = `Delivered: ${state.score}/${TARGET_SCORE}`;
      const scoreTextW = ctx.measureText(scoreText).width;
      const scoreBgW = scoreTextW + 20;
      const scoreX = PADDING;
      const scoreY = PADDING;
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      roundRect(ctx, scoreX, scoreY, scoreBgW, 34, 8);
      ctx.fill();
      ctx.fillStyle = "#2d6a9f";
      ctx.font = "18px sans-serif";
      ctx.fillText(scoreText, scoreX + 10, scoreY + 22);

      // UI: Lives top-right
      ctx.font = "18px sans-serif";
      const livesText = `Lives: ${state.lives}`;
      const livesTextW = ctx.measureText(livesText).width;
      const livesBgW = livesTextW + 20;
      const livesX = WIDTH - livesBgW - PADDING;
      const livesY = PADDING;
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      roundRect(ctx, livesX, livesY, livesBgW, 34, 8);
      ctx.fill();
      ctx.fillStyle = "#a94444";
      ctx.fillText(livesText, livesX + 10, livesY + 22);
      // little heart icons
      for (let i = 0; i < MAX_LIVES; i++) {
        const hx = livesX + livesBgW - 12 - i * 18;
        const hy = livesY + 8;
        drawHeart(hx - 10, hy + 6, 8, i < state.lives ? "#e74c3c" : "#f0dede");
      }

      // UI: Audio indicator top-center
      ctx.font = "14px sans-serif";
      const audioText = audioEnabled ? "Sound: On (M to mute)" : "Sound: Off (M to unmute)";
      const audioW = ctx.measureText(audioText).width + 16;
      const audioX = (WIDTH - audioW) / 2;
      const audioY = PADDING + 40;
      ctx.fillStyle = "rgba(255,255,255,0.7)";
      roundRect(ctx, audioX, audioY, audioW, 28, 8);
      ctx.fill();
      ctx.fillStyle = "#2c3e50";
      ctx.font = "14px sans-serif";
      ctx.fillText(audioText, audioX + 8, audioY + 18);

      // Progress lane and drone path
      drawProgressPath();

      // Drone - position depends on score and animation pulses
      const pulse = anims.successPulse.t * 0.4;
      const shake = anims.crashShake.t * 5;
      const droneX = state.droneX + (Math.random() - 0.5) * shake;
      const droneY = state.droneY - pulse * 10;
      drawDrone(droneX, droneY);

      // Draw package target ahead
      drawTarget(WIDTH - 100, state.droneY + 10);

      // Question display in upper center-left
      ctx.font = "28px sans-serif";
      ctx.fillStyle = "rgba(255,255,255,0.88)";
      const qW = Math.max(180, ctx.measureText(state.currentQuestion || "").width + 40);
      const qX = PADDING + 8;
      const qY = 90;
      roundRect(ctx, qX, qY, qW, 56, 10);
      ctx.fill();
      ctx.fillStyle = "#16324a";
      ctx.font = "24px sans-serif";
      ctx.fillText(state.currentQuestion || "Press any key or click to start", qX + 12, qY + 36);

      // Options area
      drawOptions();

      // Bottom-center instructions
      ctx.font = "16px sans-serif";
      const instrY = HEIGHT - 72;
      // Draw multi-line instructions with spacing and background
      let instrMaxW = 0;
      for (const line of instructionsLines) {
        instrMaxW = Math.max(instrMaxW, ctx.measureText(line).width);
      }
      const instrBgW = instrMaxW + 24;
      const instrX = (WIDTH - instrBgW) / 2;
      const instrH = instructionsLines.length * 20 + 18;
      roundRect(ctx, instrX, instrY - 6, instrBgW, instrH, 10);
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.fill();
      ctx.fillStyle = "#2d4760";
      ctx.font = "16px sans-serif";
      for (let i = 0; i < instructionsLines.length; i++) {
        ctx.fillText(instructionsLines[i], instrX + 12, instrY + 20 * i + 18);
      }

      // If paused or awaiting audio permission show small overlay
      if (!state.started) {
        ctx.fillStyle = "rgba(10,10,30,0.25)";
        roundRect(ctx, WIDTH / 2 - 180, HEIGHT / 2 - 54, 360, 108, 12);
        ctx.fill();
        ctx.fillStyle = "#ffffff";
        ctx.font = "20px sans-serif";
        const welcome = "Welcome! Click or press any key to begin and enable sound.";
        const welcomeW = ctx.measureText(welcome).width;
        ctx.fillText(welcome, WIDTH / 2 - welcomeW / 2, HEIGHT / 2 + 8);
      }

      // End screens
      if (state.phase === "won") {
        drawEndScreen(true);
      } else if (state.phase === "lost") {
        drawEndScreen(false);
      }

    } catch (e) {
      console.error("Draw error:", e);
    }
  }

  function drawCloud(cx, cy, w, h, color1, color2) {
    const gradient = ctx.createLinearGradient(cx - w / 2, cy - h / 2, cx + w / 2, cy + h / 2);
    gradient.addColorStop(0, color1);
    gradient.addColorStop(1, color2);
    ctx.fillStyle = gradient;
    roundRect(ctx, cx - w / 2, cy - h / 2, w, h, h / 2);
    ctx.fill();
    // playful puff circles
    ctx.fillStyle = color1;
    ctx.beginPath();
    ctx.arc(cx - w / 4, cy - h / 4, h / 2.6, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(cx + w / 6, cy - h / 5, h / 3.2, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawHeart(x, y, size, color) {
    ctx.save();
    ctx.fillStyle = color;
    ctx.beginPath();
    const topCurveHeight = size * 0.3;
    ctx.moveTo(x, y + topCurveHeight);
    // left
    ctx.bezierCurveTo(x, y, x - size / 2, y, x - size / 2, y + topCurveHeight);
    // bottom left
    ctx.bezierCurveTo(x - size / 2, y + (size + topCurveHeight) / 2, x, y + (size + topCurveHeight) / 1.2, x, y + size);
    // bottom right
    ctx.bezierCurveTo(x, y + (size + topCurveHeight) / 1.2, x + size / 2, y + (size + topCurveHeight) / 2, x + size / 2, y + topCurveHeight);
    // right
    ctx.bezierCurveTo(x + size / 2, y, x, y, x, y + topCurveHeight);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawTarget(x, y) {
    // a quirky landing pad
    ctx.fillStyle = "#fff1b6";
    roundRect(ctx, x - 28, y + 20, 120, 46, 12);
    ctx.fill();
    ctx.fillStyle = "#ffb54d";
    ctx.font = "18px sans-serif";
    const txt = "Delivery Hub";
    ctx.fillText(txt, x - 6, y + 48);
    // target circle
    ctx.beginPath();
    ctx.arc(x + 10, y, 32, 0, Math.PI * 2);
    ctx.fillStyle = "#fff";
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x + 10, y, 22, 0, Math.PI * 2);
    ctx.fillStyle = "#ffd166";
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x + 10, y, 8, 0, Math.PI * 2);
    ctx.fillStyle = "#ff6b6b";
    ctx.fill();
  }

  function drawProgressPath() {
    // draw a subtle strip from left to right indicating route
    const pathY = state.droneY + 42;
    ctx.lineWidth = 8;
    ctx.strokeStyle = "rgba(255,255,255,0.5)";
    ctx.beginPath();
    ctx.moveTo(20, pathY);
    const seg = WIDTH - 140;
    for (let i = 0; i < 6; i++) {
      ctx.lineTo(20 + seg * ((i + 1) / 6), pathY + (i % 2 === 0 ? 4 : -4));
    }
    ctx.stroke();
    // little sign posts
    for (let i = 0; i < 4; i++) {
      const x = 80 + i * 130;
      ctx.fillStyle = "#d7eaf2";
      roundRect(ctx, x, pathY - 18, 36, 16, 6);
      ctx.fill();
    }
  }

  function drawDrone(cx, cy) {
    ctx.save();
    ctx.translate(cx, cy);
    // body
    ctx.fillStyle = "#8ad4ff";
    roundRect(ctx, -38, -10, 76, 34, 8);
    ctx.fill();
    // cockpit
    ctx.fillStyle = "#eaf8ff";
    roundRect(ctx, -10, -6, 30, 22, 6);
    ctx.fill();
    // rotors
    drawRotor(-26, -12, 18, 0.9);
    drawRotor(26, -12, 18, -0.9);
    drawRotor(-26, 22, 18, -0.6);
    drawRotor(26, 22, 18, 0.6);
    // legs
    ctx.strokeStyle = "#3b5b6e";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-25, 24);
    ctx.lineTo(-15, 36);
    ctx.moveTo(25, 24);
    ctx.lineTo(15, 36);
    ctx.stroke();
    // package
    ctx.fillStyle = "#ffd29f";
    roundRect(ctx, -12, 24, 28, 18, 4);
    ctx.fill();
    ctx.strokeStyle = "#d79b5f";
    ctx.lineWidth = 2;
    ctx.strokeRect(-12, 24, 28, 18);
    ctx.restore();
  }

  function drawRotor(x, y, r, spin) {
    ctx.save();
    ctx.translate(x, y);
    // blades
    ctx.fillStyle = "rgba(30,30,30,0.6)";
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.ellipse(0, 0, r, r / 6, i * Math.PI * 0.66, 0, Math.PI * 2);
      ctx.fill();
    }
    // center
    ctx.beginPath();
    ctx.arc(0, 0, 6, 0, Math.PI * 2);
    ctx.fillStyle = "#2b3b44";
    ctx.fill();
    ctx.restore();
  }

  function drawOptions() {
    const rects = layoutOptions();
    ctx.font = "20px sans-serif";
    for (let i = 0; i < rects.length; i++) {
      const r = rects[i];
      // background
      const isSelected = state.selectedOption === i;
      const isHover = state.hoverIndex === i;
      if (isSelected) {
        ctx.fillStyle = "rgba(146,196,255,0.95)";
      } else if (isHover) {
        ctx.fillStyle = "rgba(255,255,255,0.92)";
      } else {
        ctx.fillStyle = "rgba(255,255,255,0.88)";
      }
      roundRect(ctx, r.x, r.y, r.w, r.h, 10);
      ctx.fill();

      // text
      ctx.fillStyle = "#16324a";
      const optText = `${i + 1}. ${state.options[i]}`;
      ctx.font = "20px sans-serif";
      const textW = ctx.measureText(optText).width;
      // ensure padding and non-overlap
      ctx.fillText(optText, r.x + 16, r.y + 38);

      // if last answered recently, show correct/incorrect highlight
      if (Date.now() - state.lastAnswerTime < 800) {
        if (i === state.correctIndex) {
          ctx.strokeStyle = "rgba(46,204,113,0.9)";
          ctx.lineWidth = 3;
          roundRect(ctx, r.x + 2, r.y + 2, r.w - 4, r.h - 4, 8);
          ctx.stroke();
        }
        if (state.hoverIndex === i && state.wrongCount > 0) {
          // no-op; handled by lives feedback
        }
      }
    }
  }

  function drawEndScreen(isWin) {
    ctx.save();
    // dim background
    ctx.fillStyle = "rgba(6, 20, 30, 0.45)";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // card
    const cardW = 460;
    const cardH = 220;
    const cardX = (WIDTH - cardW) / 2;
    const cardY = (HEIGHT - cardH) / 2 - 20;
    ctx.fillStyle = "#ffffff";
    roundRect(ctx, cardX, cardY, cardW, cardH, 12);
    ctx.fill();

    // Title text
    ctx.fillStyle = isWin ? "#1b6b2e" : "#8a2432";
    ctx.font = "28px sans-serif";
    const title = isWin ? "All Packages Delivered!" : "Uh-oh! The drone ran out of lives!";
    const titleW = ctx.measureText(title).width;
    ctx.fillText(title, cardX + (cardW - titleW) / 2, cardY + 48);

    // Message
    ctx.font = "18px sans-serif";
    ctx.fillStyle = "#2b4756";
    const msg = isWin ? "Great job! You helped the drone deliver all packages." : `Delivered ${state.score} package(s). Try again to beat the route!`;
    const msgW = ctx.measureText(msg).width;
    ctx.fillText(msg, cardX + (cardW - msgW) / 2, cardY + 88);

    // Restart button
    const btn = endScreenButtonRect();
    const bx = btn.x;
    const by = btn.y;
    const bw = btn.w;
    const bh = btn.h;
    ctx.fillStyle = "#4aa3ff";
    roundRect(ctx, bx, by, bw, bh, 8);
    ctx.fill();
    ctx.fillStyle = "#fff";
    ctx.font = "18px sans-serif";
    const txt = btn.text;
    const txtW = ctx.measureText(txt).width;
    ctx.fillText(txt, bx + (bw - txtW) / 2, by + 26);

    // Small hint
    ctx.fillStyle = "#2b4756";
    ctx.font = "14px sans-serif";
    const hint = "Press R or Enter to restart. Or click the button.";
    const hintW = ctx.measureText(hint).width;
    ctx.fillText(hint, cardX + (cardW - hintW) / 2, cardY + cardH - 22);

    ctx.restore();
  }

  // Animations update
  function update(dt) {
    // decay animations
    if (anims.successPulse.t > 0) anims.successPulse.t = Math.max(0, anims.successPulse.t - dt * 2.4);
    if (anims.crashShake.t > 0) anims.crashShake.t = Math.max(0, anims.crashShake.t - dt * 2.6);

    // subtle auto-hover reset
    if (Date.now() - state.lastInteraction > 4000) {
      state.hoverIndex = -1;
    }
  }

  // Simple game loop
  let last = performance.now();
  function loop(now) {
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;
    try {
      update(dt);
      draw();
    } catch (e) {
      console.error("Main loop error:", e);
    }
    requestAnimationFrame(loop);
  }

  // Start-up
  function init() {
    // initial question
    makeQuestion();
    state.started = true;
    // ensure initial audio resume will happen on first click/keypress
    canvas.addEventListener("click", resumeAudioIfNeeded, { once: true });
    window.addEventListener("keydown", resumeAudioIfNeeded, { once: true });
    loop(performance.now());
  }

  init();
})();
---

