{
  "generated_date": "2025-09-16",
  "generated_timestamp": "2025-09-16T00:26:16.299239",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9453,
  "game_filename": "2025-09-16.js",
  "game_size_bytes": 29150,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function() {\n  // Machine Math Game (ages 7-9)\n  // Renders into #game-of-the-day-stage as a 720x480 canvas\n  // All graphics drawn with Canvas API. Sounds generated with Web Audio API.\n  'use strict';\n\n  // Utility helpers\n  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }\n  function rand(min, max) { return Math.random() * (max - min) + min; }\n  function choice(arr) { return arr[Math.floor(Math.random() * arr.length)]; }\n\n  // Locate container\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Game container with id \"game-of-the-day-stage\" not found.');\n    return;\n  }\n\n  // Clear container and create canvas\n  container.innerHTML = '';\n  const canvas = document.createElement('canvas');\n  canvas.width = 720;\n  canvas.height = 480;\n  canvas.setAttribute('tabindex', '0'); // allow keyboard focus\n  canvas.setAttribute('role', 'application');\n  canvas.setAttribute('aria-label', 'Machine Math Game. Press Enter to start or click to interact. Use arrow keys to move parts, space to place. Press M to toggle sound.');\n  canvas.style.outline = 'none';\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Accessibility: visually show focus ring when canvas focused\n  let hasFocus = false;\n  canvas.addEventListener('focus', () => { hasFocus = true; draw(); });\n  canvas.addEventListener('blur', () => { hasFocus = false; draw(); });\n\n  // Audio setup with error handling\n  let audioContext = null;\n  let audioAllowed = false;\n  let audioErr = null;\n  let masterGain = null;\n  let bgGain = null;\n  let bgOsc = null;\n  let bgFilter = null;\n  let isMuted = false;\n\n  function createAudioContext() {\n    if (audioContext) return audioContext;\n    try {\n      const AC = window.AudioContext || window.webkitAudioContext;\n      audioContext = new AC();\n      masterGain = audioContext.createGain();\n      masterGain.gain.value = 0.7;\n      masterGain.connect(audioContext.destination);\n\n      // Gentle background oscillator with slow modulation\n      bgGain = audioContext.createGain();\n      bgGain.gain.value = 0.02;\n      bgOsc = audioContext.createOscillator();\n      bgOsc.type = 'sine';\n      bgOsc.frequency.value = 110; // low drone\n      bgFilter = audioContext.createBiquadFilter();\n      bgFilter.type = 'lowpass';\n      bgFilter.frequency.value = 400;\n      bgOsc.connect(bgFilter);\n      bgFilter.connect(bgGain);\n      bgGain.connect(masterGain);\n      bgOsc.start();\n\n      // LFO to modulate filter for gentle movement\n      const lfo = audioContext.createOscillator();\n      lfo.frequency.value = 0.08;\n      const lfoGain = audioContext.createGain();\n      lfoGain.gain.value = 200;\n      lfo.connect(lfoGain);\n      lfoGain.connect(bgFilter.frequency);\n      lfo.start();\n\n      audioAllowed = true;\n      isMuted = false;\n      return audioContext;\n    } catch (e) {\n      console.warn('Audio context creation failed:', e);\n      audioErr = e;\n      audioAllowed = false;\n      return null;\n    }\n  }\n\n  function resumeAudioIfNeeded() {\n    if (!audioContext) return createAudioContext();\n    if (audioContext.state === 'suspended') {\n      audioContext.resume().catch((e) => {\n        console.warn('Audio resume failed:', e);\n      });\n    }\n  }\n\n  function setMuted(m) {\n    isMuted = !!m;\n    if (masterGain) masterGain.gain.value = isMuted ? 0 : 0.7;\n    draw(); // update speaker icon\n  }\n\n  // Play sound effects generated with oscillators\n  function playCorrectSound() {\n    if (!audioAllowed || !audioContext || isMuted) return;\n    try {\n      const t0 = audioContext.currentTime;\n      const notes = [440, 660, 880];\n      notes.forEach((freq, i) => {\n        const osc = audioContext.createOscillator();\n        const g = audioContext.createGain();\n        osc.type = i === 1 ? 'triangle' : 'sine';\n        osc.frequency.value = freq;\n        g.gain.value = 0;\n        osc.connect(g);\n        g.connect(masterGain);\n        const start = t0 + i * 0.07;\n        const dur = 0.18;\n        g.gain.setValueAtTime(0, start);\n        g.gain.linearRampToValueAtTime(0.12, start + 0.01);\n        g.gain.exponentialRampToValueAtTime(0.001, start + dur);\n        osc.start(start);\n        osc.stop(start + dur + 0.05);\n      });\n    } catch (e) {\n      console.warn('playCorrectSound error', e);\n    }\n  }\n\n  function playWrongSound() {\n    if (!audioAllowed || !audioContext || isMuted) return;\n    try {\n      const t0 = audioContext.currentTime;\n      const osc = audioContext.createOscillator();\n      const g = audioContext.createGain();\n      const filt = audioContext.createBiquadFilter();\n      filt.type = 'highpass';\n      filt.frequency.value = 500;\n      osc.type = 'sawtooth';\n      osc.frequency.value = 140;\n      g.gain.value = 0;\n      osc.connect(filt);\n      filt.connect(g);\n      g.connect(masterGain);\n      g.gain.setValueAtTime(0, t0);\n      g.gain.linearRampToValueAtTime(0.12, t0 + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.001, t0 + 0.35);\n      osc.start(t0);\n      osc.stop(t0 + 0.4);\n    } catch (e) {\n      console.warn('playWrongSound error', e);\n    }\n  }\n\n  // Visual theme elements\n  const bgStars = Array.from({length: 18}, () => ({\n    x: rand(0, canvas.width),\n    y: rand(0, canvas.height),\n    r: rand(1.5, 4),\n    sway: rand(0.5, 1.5),\n    phase: rand(0, Math.PI * 2)\n  }));\n\n  // Game state\n  let rngSeed = Date.now();\n  const state = {\n    level: 0,\n    maxLevels: 6,\n    parts: [], // available parts\n    slots: [], // slot positions with placed parts or null\n    target: 0,\n    selectedPartIndex: -1,\n    dragging: false,\n    dragOffset: {x:0,y:0},\n    score: 0,\n    message: 'Press Enter or Click to start',\n    started: false,\n    completed: false,\n    animTime: 0,\n    lastTick: performance.now(),\n    showFocusHint: true\n  };\n\n  // Generate level data: number of slots and simple sums to practice addition/subtraction\n  function generateLevel(n) {\n    // n from 0..maxLevels-1\n    const slotCount = clamp(2 + Math.floor(n/2), 2, 4); // 2 to 4 slots\n    const maxValue = 5 + n * 2; // increase values\n    // Build a target by adding random values for the number of slots but hide some choices\n    const targetParts = [];\n    for (let i=0;i<slotCount;i++) {\n      targetParts.push(Math.floor(rand(1, maxValue+1)));\n    }\n    const target = targetParts.reduce((a,b) => a+b, 0);\n    // Create available parts pool: include correct parts and some distractors\n    const parts = [];\n    // Add each needed part as an item\n    targetParts.forEach((v) => parts.push({val: v, x: 560 + Math.random()*120, y: 120 + Math.random()*260}));\n    // Add distractors\n    for (let i=0;i<Math.max(2, slotCount);i++) {\n      parts.push({val: Math.floor(rand(1, maxValue+1)), x: 560 + Math.random()*120, y: 120 + Math.random()*260});\n    }\n    // Shuffle and assign gentle angles\n    for (let i=parts.length-1;i>0;i--) {\n      const j = Math.floor(Math.random()*(i+1));\n      [parts[i], parts[j]] = [parts[j], parts[i]];\n    }\n    // Assign visuals positions\n    parts.forEach((p, idx) => {\n      p.x = 520 + (idx%3) * 60 + rand(-8,8);\n      p.y = 150 + Math.floor(idx/3) * 70 + rand(-6,6);\n      p.wob = rand(0, Math.PI*2);\n      p.id = Math.random().toString(36).slice(2);\n      p.placed = false;\n      p.selected = false;\n    });\n\n    // Slots positioned on the machine\n    const slots = [];\n    const centerX = 320;\n    const centerY = 230;\n    const gap = 72;\n    const startX = centerX - (slotCount-1) * gap / 2;\n    for (let i=0;i<slotCount;i++){\n      slots.push({\n        x: startX + i*gap,\n        y: centerY + 6 + (i%2===0? -8 : 8),\n        r: 28,\n        placedPart: null\n      });\n    }\n    return {parts, slots, target};\n  }\n\n  function startGame() {\n    state.level = 0;\n    state.score = 0;\n    state.started = true;\n    state.completed = false;\n    state.message = 'Assemble the machine! Reach the target number.';\n    nextLevel();\n    resumeAudioIfNeeded();\n  }\n\n  function nextLevel() {\n    if (state.level >= state.maxLevels) {\n      // Game completed\n      state.completed = true;\n      state.message = 'Fantastic! You fixed all the machines!';\n      playCorrectSound();\n      return;\n    }\n    const data = generateLevel(state.level);\n    state.parts = data.parts;\n    state.slots = data.slots;\n    state.target = data.target;\n    state.selectedPartIndex = -1;\n    state.dragging = false;\n    state.message = `Level ${state.level+1}: Make ${state.target}`;\n    state.animTime = 0;\n  }\n\n  // Hit test for parts\n  function partAt(x,y) {\n    for (let i = state.parts.length - 1; i >= 0; i--) {\n      const p = state.parts[i];\n      if (p.placed) continue;\n      // circular parts\n      const dx = x - p.x;\n      const dy = y - p.y;\n      if (Math.sqrt(dx*dx + dy*dy) < 24) return i;\n    }\n    return -1;\n  }\n\n  function slotAt(x,y) {\n    for (let i=0;i<state.slots.length;i++){\n      const s = state.slots[i];\n      const dx = x - s.x;\n      const dy = y - s.y;\n      if (Math.sqrt(dx*dx + dy*dy) < s.r + 6) return i;\n    }\n    return -1;\n  }\n\n  // Place part into slot; validate sum when all filled\n  function tryPlacePart(partIndex, slotIndex) {\n    const p = state.parts[partIndex];\n    const s = state.slots[slotIndex];\n    if (s.placedPart) {\n      // swap back: return to free area\n      state.message = 'That slot is occupied. Try a different slot.';\n      playWrongSound();\n      return false;\n    }\n    // Place it\n    p.placed = true;\n    p.selected = false;\n    s.placedPart = p;\n    // Snap position\n    p.x = s.x;\n    p.y = s.y;\n    checkLevelComplete();\n    draw();\n    return true;\n  }\n\n  function removeFromSlot(slotIndex) {\n    const s = state.slots[slotIndex];\n    if (!s.placedPart) return;\n    const p = s.placedPart;\n    s.placedPart = null;\n    p.placed = false;\n    // Return it to the pool area\n    p.x = 520 + rand(0,140);\n    p.y = 150 + rand(0,260);\n    draw();\n  }\n\n  function checkLevelComplete() {\n    // If all slots filled, evaluate\n    const allFilled = state.slots.every(s => s.placedPart !== null);\n    if (!allFilled) return;\n    const sum = state.slots.reduce((acc, s) => acc + (s.placedPart ? s.placedPart.val : 0), 0);\n    if (sum === state.target) {\n      // success\n      state.message = 'Perfect! Machine fixed!';\n      state.score += 10 + state.level*2;\n      playCorrectSound();\n      // animate machine run for a moment then advance\n      setTimeout(() => {\n        state.level++;\n        nextLevel();\n      }, 1200);\n    } else {\n      // failure: show gentle feedback, unplace one part automatically to give learning\n      state.message = `Oops! That adds to ${sum}. Try again.`;\n      playWrongSound();\n      // unplace a random slot to give second chance\n      const placedSlots = state.slots.map((s,i)=>s.placedPart?i:null).filter(i=>i!==null);\n      if (placedSlots.length>0) {\n        const idx = choice(placedSlots);\n        setTimeout(()=> removeFromSlot(idx), 600);\n      }\n    }\n  }\n\n  // Input handling\n  canvas.addEventListener('mousedown', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);\n    const my = (e.clientY - rect.top) * (canvas.height / rect.height);\n    if (!state.started) {\n      state.started = true;\n      startGame();\n      return;\n    }\n    // Check clicking on speaker toggler\n    if (mx > 16 && mx < 56 && my > 16 && my < 56) {\n      // toggle mute\n      if (!audioAllowed) {\n        createAudioContext();\n      } else {\n        setMuted(!isMuted);\n      }\n      draw();\n      return;\n    }\n    // click on part\n    const idx = partAt(mx, my);\n    if (idx >= 0) {\n      const p = state.parts[idx];\n      if (p.placed) {\n        // already placed, find its slot and remove\n        const slotIndex = state.slots.findIndex(s => s.placedPart && s.placedPart.id === p.id);\n        if (slotIndex >= 0) {\n          removeFromSlot(slotIndex);\n        }\n        return;\n      }\n      state.selectedPartIndex = idx;\n      state.dragging = true;\n      state.dragOffset.x = mx - p.x;\n      state.dragOffset.y = my - p.y;\n      p.selected = true;\n      // Ensure audio context started by user gesture\n      createAudioContext();\n      resumeAudioIfNeeded();\n      draw();\n      return;\n    }\n    // click on slot to remove part if any\n    const slotIdx = slotAt(mx,my);\n    if (slotIdx >= 0) {\n      if (state.slots[slotIdx].placedPart) {\n        removeFromSlot(slotIdx);\n      } else {\n        state.message = 'Drop a number here.';\n        draw();\n      }\n      return;\n    }\n  });\n\n  window.addEventListener('mouseup', (e) => {\n    if (!state.dragging) return;\n    // drop logic\n    const rect = canvas.getBoundingClientRect();\n    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);\n    const my = (e.clientY - rect.top) * (canvas.height / rect.height);\n    if (state.selectedPartIndex >= 0) {\n      const slotIdx = slotAt(mx,my);\n      if (slotIdx >= 0) {\n        tryPlacePart(state.selectedPartIndex, slotIdx);\n      } else {\n        // return to pocket\n        const p = state.parts[state.selectedPartIndex];\n        p.selected = false;\n        p.x = 520 + rand(0,140);\n        p.y = 150 + rand(0,260);\n        state.message = 'Try placing numbers in the slots to reach the target.';\n        draw();\n      }\n    }\n    state.dragging = false;\n    state.selectedPartIndex = -1;\n  });\n\n  canvas.addEventListener('mousemove', (e) => {\n    if (!state.dragging || state.selectedPartIndex < 0) return;\n    const rect = canvas.getBoundingClientRect();\n    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);\n    const my = (e.clientY - rect.top) * (canvas.height / rect.height);\n    const p = state.parts[state.selectedPartIndex];\n    p.x = mx - state.dragOffset.x;\n    p.y = my - state.dragOffset.y;\n    draw();\n  });\n\n  // Keyboard controls\n  canvas.addEventListener('keydown', (e) => {\n    if (!state.started) {\n      if (e.key === 'Enter' || e.key === ' ') {\n        startGame();\n        e.preventDefault();\n      }\n      return;\n    }\n    // Toggle sound with M\n    if (e.key.toLowerCase() === 'm') {\n      if (!audioAllowed) {\n        createAudioContext();\n      } else {\n        setMuted(!isMuted);\n      }\n      e.preventDefault();\n      return;\n    }\n    // Quick help with H\n    if (e.key.toLowerCase() === 'h') {\n      state.message = 'Use arrows to pick parts, Enter to drop into nearest slot, Space to pick/place, M toggles sound.';\n      draw();\n      e.preventDefault();\n      return;\n    }\n    // Number keys to pick a part by index (1..9)\n    if (/^[1-9]$/.test(e.key)) {\n      const idx = parseInt(e.key,10)-1;\n      if (idx < state.parts.length) {\n        const p = state.parts[idx];\n        if (!p.placed) {\n          state.selectedPartIndex = idx;\n          p.selected = true;\n          state.dragging = false;\n          state.message = `Selected part ${p.val}. Use arrow keys to move; Enter to place into nearest slot.`;\n          draw();\n        }\n      }\n      e.preventDefault();\n      return;\n    }\n    // If selection exists, arrow keys move it\n    if (state.selectedPartIndex >= 0) {\n      const p = state.parts[state.selectedPartIndex];\n      let moved = false;\n      if (e.key === 'ArrowLeft') { p.x -= 12; moved = true; }\n      if (e.key === 'ArrowRight') { p.x += 12; moved = true; }\n      if (e.key === 'ArrowUp') { p.y -= 10; moved = true; }\n      if (e.key === 'ArrowDown') { p.y += 10; moved = true; }\n      if (moved) {\n        p.x = clamp(p.x, 480, canvas.width-40);\n        p.y = clamp(p.y, 80, canvas.height-40);\n        draw();\n        e.preventDefault();\n        return;\n      }\n      if (e.key === ' ' || e.key === 'Enter') {\n        // drop into nearest slot if within distance\n        const nearest = state.slots.reduce((best, s, i) => {\n          const d = Math.hypot(p.x - s.x, p.y - s.y);\n          if (d < best.dist) return {dist: d, idx: i};\n          return best;\n        }, {dist: 9999, idx: -1});\n        if (nearest.idx >= 0 && nearest.dist < 80) {\n          tryPlacePart(state.selectedPartIndex, nearest.idx);\n        } else {\n          // place back to pool\n          p.selected = false;\n          p.x = 520 + rand(0,140);\n          p.y = 150 + rand(0,260);\n          state.selectedPartIndex = -1;\n          draw();\n        }\n        e.preventDefault();\n        return;\n      }\n      if (e.key === 'Escape') {\n        p.selected = false;\n        state.selectedPartIndex = -1;\n        draw();\n        e.preventDefault();\n        return;\n      }\n    } else {\n      // No selection: use arrows to cycle selection\n      if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {\n        cycleSelect(-1);\n        e.preventDefault();\n      } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {\n        cycleSelect(1);\n        e.preventDefault();\n      } else if (e.key === 'Enter') {\n        // pick nearest part to center\n        const idx = nearestPartTo(320,240);\n        if (idx >= 0) {\n          state.selectedPartIndex = idx;\n          state.parts[idx].selected = true;\n          state.message = `Selected part ${state.parts[idx].val}.`;\n          draw();\n        }\n        e.preventDefault();\n      }\n    }\n  });\n\n  function cycleSelect(dir) {\n    let start = state.selectedPartIndex;\n    if (start < 0) start = -1;\n    let i = start;\n    for (let k=0;k<state.parts.length;k++) {\n      i = (i + dir + state.parts.length) % state.parts.length;\n      const p = state.parts[i];\n      if (!p.placed) {\n        if (state.selectedPartIndex >= 0) state.parts[state.selectedPartIndex].selected = false;\n        state.selectedPartIndex = i;\n        p.selected = true;\n        state.message = `Selected part ${p.val}. Use arrows & Enter to place.`;\n        draw();\n        return;\n      }\n    }\n  }\n\n  function nearestPartTo(x,y) {\n    let best = {dist: 9999, idx: -1};\n    for (let i=0;i<state.parts.length;i++){\n      const p = state.parts[i];\n      if (p.placed) continue;\n      const d = Math.hypot(p.x-x, p.y-y);\n      if (d < best.dist) { best = {dist:d, idx:i}; }\n    }\n    return best.idx;\n  }\n\n  // Main draw loop\n  function drawBackground(ts) {\n    // calming gradient\n    const g = ctx.createLinearGradient(0,0,0,canvas.height);\n    g.addColorStop(0, '#eef7f9');\n    g.addColorStop(1, '#dfeff6');\n    ctx.fillStyle = g;\n    ctx.fillRect(0,0,canvas.width,canvas.height);\n\n    // floating wacky plants / gears as blobs\n    ctx.save();\n    for (let i=0;i<bgStars.length;i++){\n      const s = bgStars[i];\n      const sway = Math.sin((ts/1000)*s.sway + s.phase) * 6;\n      ctx.beginPath();\n      ctx.fillStyle = `rgba(120,160,200, 0.12)`;\n      ctx.ellipse(s.x + sway, s.y + Math.sin((ts/700)+s.phase)*8, s.r*6, s.r*3, 0, 0, Math.PI*2);\n      ctx.fill();\n      ctx.beginPath();\n      ctx.fillStyle = `rgba(255,255,255,0.6)`;\n      ctx.arc(s.x + sway, s.y + Math.cos((ts/900)+s.phase)*8, s.r, 0, Math.PI*2);\n      ctx.fill();\n    }\n    ctx.restore();\n\n    // Soft grid behind machine\n    ctx.save();\n    ctx.strokeStyle = 'rgba(0,0,0,0.03)';\n    ctx.lineWidth = 1;\n    for (let x=0;x<canvas.width;x+=36) {\n      ctx.beginPath();\n      ctx.moveTo(x, 0);\n      ctx.lineTo(x, canvas.height);\n      ctx.stroke();\n    }\n    for (let y=0;y<canvas.height;y+=36) {\n      ctx.beginPath();\n      ctx.moveTo(0, y);\n      ctx.lineTo(canvas.width, y);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  function drawMachine(ts) {\n    // Central machine body\n    const mx = 320, my = 220;\n    ctx.save();\n    // body\n    ctx.fillStyle = '#cfe3ea';\n    ctx.strokeStyle = '#8aa9b6';\n    ctx.lineWidth = 4;\n    roundRect(ctx, mx-160, my-96, 320, 192, 18, true, true);\n\n    // display window showing target\n    ctx.fillStyle = '#ffffff';\n    roundRect(ctx, mx-72, my-86, 144, 44, 12, true, true);\n    ctx.fillStyle = '#123c4b';\n    ctx.font = '22px \"Arial\", sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('TARGET', mx, my-56);\n\n    ctx.font = '30px \"Comic Sans MS\", \"Arial\", sans-serif';\n    ctx.fillStyle = '#0b3b47';\n    ctx.fillText(String(state.target), mx, my-28);\n\n    // slots area: draw connectors\n    state.slots.forEach((s, i) => {\n      // connector tube\n      ctx.beginPath();\n      ctx.strokeStyle = 'rgba(20,40,50,0.12)';\n      ctx.lineWidth = 10;\n      ctx.moveTo(mx, my - 6);\n      const cx = s.x - 12;\n      ctx.quadraticCurveTo((mx+cx)/2, my - 40 + (i%2?20:-20), s.x, s.y-18);\n      ctx.stroke();\n\n      // slot ring\n      ctx.beginPath();\n      ctx.fillStyle = '#e9f4f6';\n      ctx.strokeStyle = '#7aa0ad';\n      ctx.lineWidth = 3;\n      ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);\n      ctx.fill();\n      ctx.stroke();\n      // inner dashed\n      ctx.beginPath();\n      ctx.strokeStyle = 'rgba(0,0,0,0.06)';\n      ctx.setLineDash([4,6]);\n      ctx.lineWidth = 2;\n      ctx.arc(s.x, s.y, s.r-8, 0, Math.PI*2);\n      ctx.stroke();\n      ctx.setLineDash([]);\n      // show placed number\n      if (s.placedPart) {\n        ctx.fillStyle = '#13414b';\n        ctx.font = '20px \"Arial\", sans-serif';\n        ctx.textAlign = 'center';\n        ctx.fillText(String(s.placedPart.val), s.x, s.y+6);\n      } else {\n        ctx.fillStyle = 'rgba(10,20,30,0.06)';\n        ctx.font = '16px \"Arial\", sans-serif';\n        ctx.fillText('?', s.x, s.y+6);\n      }\n    });\n\n    // decorative levers & silly face\n    ctx.fillStyle = '#a7d0dc';\n    ctx.beginPath();\n    ctx.ellipse(mx+160, my-60, 30, 24, Math.PI/8, 0, Math.PI*2);\n    ctx.fill();\n    ctx.fillStyle = '#fefefe';\n    ctx.beginPath();\n    ctx.arc(mx+160-6, my-64, 4, 0, Math.PI*2);\n    ctx.arc(mx+160+8, my-64, 4, 0, Math.PI*2);\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  function drawParts(ts) {\n    // Pool area on right\n    ctx.save();\n    ctx.fillStyle = 'rgba(255,255,255,0.6)';\n    roundRect(ctx, 480, 100, 224, 300, 14, true, false);\n\n    ctx.fillStyle = '#0b3b47';\n    ctx.font = '16px \"Arial\", sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText('Parts Rack', 492, 122);\n\n    // Draw each part as a colorful cog\n    for (let i=0;i<state.parts.length;i++){\n      const p = state.parts[i];\n      // wobble\n      p.wob += 0.02;\n      const wob = Math.sin(p.wob) * 2;\n      const x = p.x;\n      const y = p.y + wob;\n      // background cog\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(Math.sin((ts/800)+p.wob)*0.08);\n      // body\n      ctx.beginPath();\n      ctx.fillStyle = p.selected ? '#ffdfa3' : '#fff5e6';\n      ctx.strokeStyle = '#b18f67';\n      ctx.lineWidth = 2;\n      ctx.arc(0,0,22,0,Math.PI*2);\n      ctx.fill();\n      ctx.stroke();\n      // teeth\n      for (let t=0;t<8;t++){\n        ctx.rotate(Math.PI*2/8);\n        ctx.fillStyle = 'rgba(80,130,140,0.12)';\n        ctx.fillRect(14, -6, 6, 12);\n      }\n      // number\n      ctx.fillStyle = '#154b52';\n      ctx.font = '18px \"Comic Sans MS\", \"Arial\", sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText(String(p.val), 0, 6);\n      ctx.restore();\n\n      // index label for keyboard users\n      ctx.fillStyle = 'rgba(20,40,50,0.12)';\n      ctx.font = '12px \"Arial\", sans-serif';\n      ctx.fillText(String(i+1), x+18, y+18);\n    }\n    ctx.restore();\n  }\n\n  function drawUI(ts) {\n    // Top left panel: message and small controls\n    ctx.save();\n    ctx.fillStyle = 'rgba(255,255,255,0.8)';\n    roundRect(ctx, 12, 12, 260, 72, 10, true, true);\n\n    ctx.fillStyle = '#0b3b47';\n    ctx.font = '18px \"Arial\", sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText(`Level: ${Math.min(state.level+1, state.maxLevels)}/${state.maxLevels}`, 28, 36);\n\n    ctx.font = '14px \"Arial\", sans-serif';\n    ctx.fillStyle = '#0b3b47';\n    ctx.fillText(state.message, 28, 56);\n\n    // Speaker icon\n    ctx.restore();\n    ctx.save();\n    const sx = 20, sy = 20;\n    // clickable square\n    ctx.fillStyle = 'rgba(255,255,255,0.0)';\n    ctx.fillRect(sx-4, sy-4, 40, 40);\n    // speaker\n    ctx.fillStyle = '#0b3b47';\n    ctx.beginPath();\n    ctx.moveTo(sx+6, sy+12);\n    ctx.lineTo(sx+18, sy+8);\n    ctx.lineTo(sx+18, sy+28);\n    ctx.lineTo(sx+6, sy+24);\n    ctx.closePath();\n    ctx.fill();\n    if (audioAllowed && !isMuted) {\n      // draw small bars as visual audio cue\n      ctx.fillStyle = '#6bb6c6';\n      for (let i=0;i<3;i++){\n        ctx.fillRect(sx+22+i*6, sy+10 - Math.abs(Math.sin(ts/300 + i))*8, 4, 8 + Math.abs(Math.sin(ts/300 + i))*8);\n      }\n    } else {\n      // draw muted cross\n      ctx.strokeStyle = '#dd5b5b';\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(sx+22, sy+6);\n      ctx.lineTo(sx+34, sy+18);\n      ctx.moveTo(sx+34, sy+6);\n      ctx.lineTo(sx+22, sy+18);\n      ctx.stroke();\n    }\n    ctx.restore();\n\n    // Instructions bottom left\n    ctx.save();\n    ctx.fillStyle = 'rgba(255,255,255,0.85)';\n    roundRect(ctx, 12, 380, 260, 88, 10, true, true);\n    ctx.fillStyle = '#0b3b47';\n    ctx.font = '13px \"Arial\", sans-serif';\n    ctx.fillText('Controls:', 28, 398);\n    ctx.fillText('- Click or press Enter to select a part', 28, 416);\n    ctx.fillText('- Arrow keys move selected part', 28, 434);\n    ctx.fillText('- Press Enter/Space near a slot to place it', 28, 452);\n    ctx.restore();\n\n    // Focus ring\n    if (hasFocus) {\n      ctx.save();\n      ctx.strokeStyle = 'rgba(20,80,100,0.18)';\n      ctx.lineWidth = 4;\n      roundRect(ctx, 4, 4, canvas.width-8, canvas.height-8, 18, false, true);\n      ctx.restore();\n    }\n  }\n\n  function drawFooter(ts) {\n    ctx.save();\n    ctx.fillStyle = '#0b3b47';\n    ctx.font = '16px \"Arial\", sans-serif';\n    ctx.textAlign = 'center';\n    if (!state.started) {\n      ctx.fillText('Wacky Machine Workshop \u2014 Click or press Enter to start', canvas.width/2, canvas.height - 12);\n    } else if (state.completed) {\n      ctx.fillText('You fixed the machines! Great job!', canvas.width/2, canvas.height - 12);\n    } else {\n      ctx.fillText(`Score: ${state.score}`, canvas.width - 76, canvas.height - 12);\n    }\n    ctx.restore();\n  }\n\n  // Small utility to draw rounded rectangles\n  function roundRect(ctx, x, y, w, h, r, fill, stroke) {\n    if (typeof r === 'undefined') r = 5;\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  // Main render\n  function draw(ts = 0) {\n    // clear\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    drawBackground(ts);\n    drawMachine(ts);\n    drawParts(ts);\n    drawUI(ts);\n    drawFooter(ts);\n    // If dragging, draw ghost drop target\n    if (state.selectedPartIndex >= 0) {\n      const p = state.parts[state.selectedPartIndex];\n      const nearest = state.slots.reduce((best, s, i) => {\n        const d = Math.hypot(p.x - s.x, p.y - s.y);\n        if (d < best.dist) return {dist: d, idx: i, s:s};\n        return best;\n      }, {dist:9999, idx:-1});\n      if (nearest.idx !== -1 && nearest.dist < 80) {\n        ctx.save();\n        ctx.beginPath();\n        ctx.fillStyle = 'rgba(110,180,190,0.14)';\n        ctx.arc(nearest.s.x, nearest.s.y, nearest.s.r+8, 0, Math.PI*2);\n        ctx.fill();\n        ctx.restore();\n      }\n    }\n    // Overlay instructions if audio not allowed or blocked\n    if (!audioAllowed && audioErr) {\n      ctx.save();\n      ctx.fillStyle = 'rgba(255,255,255,0.9)';\n      roundRect(ctx, 160, 200, 400, 80, 10, true, true);\n      ctx.fillStyle = '#d23f3f';\n      ctx.font = '16px \"Arial\", sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText('Audio is unavailable in this browser.', canvas.width/2, 228);\n      ctx.fillStyle = '#0b3b47';\n      ctx.fillText('Sound will remain off. You can still play the game.', canvas.width/2, 254);\n      ctx.restore();\n    } else if (!audioAllowed) {\n      ctx.save();\n      ctx.fillStyle = 'rgba(255,255,255,0.9)';\n      roundRect(ctx, 160, 200, 400, 80, 10, true, true);\n      ctx.fillStyle = '#0b3b47';\n      ctx.font = '16px \"Arial\", sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText('Tap or press M to enable sound for fun chimes.', canvas.width/2, 228);\n      ctx.fillText('Sounds are generated on your device \u2014 no downloads.', canvas.width/2, 254);\n      ctx.restore();\n    }\n  }\n\n  // Game loop for animations\n  function tick(now) {\n    const dt = (now - state.lastTick) / 1000;\n    state.lastTick = now;\n    state.animTime += dt;\n    // gentle floating of background\n    draw(now);\n    requestAnimationFrame(tick);\n  }\n\n  // Kick things off\n  draw();\n  requestAnimationFrame(tick);\n\n  // Expose some debugging on container for testing (not necessary for gameplay)\n  container.dataset.gameReady = 'true';\n\n  // Ensure canvas is focusable and initially focused for keyboard controls\n  setTimeout(() => {\n    try { canvas.focus(); } catch(e){}\n  }, 200);\n\n  // Basic keyboard instructions in console for accessibility testers\n  console.info('Machine Math Game ready. Controls: Click parts to pick & drag, arrows to move, Enter/Space to place, M to toggle sound.');\n\n  // Error handling example: catch unexpected errors in event loop\n  window.addEventListener('error', (ev) => {\n    console.error('Unexpected error in Machine Math Game:', ev.error || ev.message);\n    state.message = 'An unexpected error occurred. Please reload the page.';\n    draw();\n  });\n\n})();\n---\n",
  "improve_response_tokens": 19982,
  "formatted_code": true,
  "formatting_response_tokens": 21929,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}