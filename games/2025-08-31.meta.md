# Game of the Day - 2025-08-31

## Metadata
- **Generated Date:** 2025-08-31
- **Generated Time:** 2025-08-31T00:29:14.411075
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-08-31.js
- **File Size:** 27290 bytes
- **Tokens Used:** 8959

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-08-31.js` - The playable game
- `2025-08-31.meta.json` - Machine-readable metadata
- `2025-08-31.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 18124

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 19422

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Wacky Machine Math - JavaScript Game
  // Ages 7-9. All visuals drawn on canvas. Sounds via Web Audio API.
  // Renders into element with ID 'game-of-the-day-stage'

  // ====== Configuration ======
  const GAME_WIDTH = 720;
  const GAME_HEIGHT = 480;
  const LEVEL_COUNT = 5;
  const MAX_PARTS = 6;
  const BG_COLOR = '#e9f3ef'; // calming mint
  const MACHINE_COLOR = '#d6e6f2';
  const PART_COLOR = '#ffd89b';
  const PART_COLOR_ALT = '#ffd1e0';
  const TEXT_COLOR = '#21333b';
  const HIGHLIGHT = '#6bb3ff';
  const FONT = '16px "Segoe UI", Roboto, sans-serif';
  const TITLE_FONT = 'bold 20px "Segoe UI", Roboto, sans-serif';

  // ====== Setup canvas and accessibility ======
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Game container with ID "game-of-the-day-stage" not found.');
    return;
  }

  // Clear container
  container.innerHTML = '';

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = GAME_WIDTH;
  canvas.height = GAME_HEIGHT;
  canvas.style.width = GAME_WIDTH + 'px';
  canvas.style.height = GAME_HEIGHT + 'px';
  canvas.tabIndex = 0; // make focusable for keyboard controls
  canvas.setAttribute('role', 'application');
  canvas.setAttribute(
    'aria-label',
    'Wacky Machine Math. Add number parts to match the machine target. Use mouse or keyboard to play.'
  );
  container.appendChild(canvas);

  const ctx = canvas.getContext('2d', { alpha: false });

  // ====== Audio Manager ======
  class AudioManager {
    constructor() {
      this.enabled = true;
      this.ctx = null;
      this.bgGain = null;
      this.bgOsc = null;
      this.isBgPlaying = false;

      try {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
      } catch (e) {
        console.warn('Web Audio API not available:', e);
        this.enabled = false;
        this.ctx = null;
      }

      // Resume handling for autoplay policies
      if (this.ctx) {
        // Try to resume on first user interaction if suspended
        const resumeIfNeeded = () => {
          if (this.ctx && this.ctx.state === 'suspended') {
            this.ctx.resume().catch((err) => {
              console.warn('Audio context resume failed:', err);
            });
          }
          window.removeEventListener('pointerdown', resumeIfNeeded);
          window.removeEventListener('keydown', resumeIfNeeded);
        };
        window.addEventListener('pointerdown', resumeIfNeeded);
        window.addEventListener('keydown', resumeIfNeeded);
      }
    }

    safeCreateGain() {
      if (!this.ctx) return null;
      try {
        return this.ctx.createGain();
      } catch (e) {
        console.warn('Gain creation failed:', e);
        return null;
      }
    }

    playClick() {
      if (!this.enabled || !this.ctx) return;
      try {
        const now = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.safeCreateGain();
        if (!gain) return;
        osc.type = 'sine';
        osc.frequency.value = 880;
        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(0.05, now + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.2);
        osc.connect(gain).connect(this.ctx.destination);
        osc.start(now);
        osc.stop(now + 0.25);
      } catch (e) {
        console.warn('playClick error:', e);
      }
    }

    playCorrect() {
      if (!this.enabled || !this.ctx) return;
      try {
        // pleasant rising triad sequence
        const now = this.ctx.currentTime;
        const freqs = [660, 880, 990];
        freqs.forEach((f, i) => {
          const osc = this.ctx.createOscillator();
          const gain = this.safeCreateGain();
          if (!gain) return;
          osc.type = 'sine';
          osc.frequency.value = f;
          gain.gain.setValueAtTime(0.0001, now + i * 0.12);
          gain.gain.exponentialRampToValueAtTime(0.06, now + i * 0.14);
          gain.gain.exponentialRampToValueAtTime(0.0001, now + i * 0.5);
          osc.connect(gain).connect(this.ctx.destination);
          osc.start(now + i * 0.12);
          osc.stop(now + i * 0.6);
        });
      } catch (e) {
        console.warn('playCorrect error:', e);
      }
    }

    playIncorrect() {
      if (!this.enabled || !this.ctx) return;
      try {
        const now = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.safeCreateGain();
        if (!gain) return;
        osc.type = 'sawtooth';
        osc.frequency.value = 160;
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 600;
        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(0.08, now + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.36);
        osc.connect(filter);
        filter.connect(gain).connect(this.ctx.destination);
        osc.start(now);
        osc.frequency.exponentialRampToValueAtTime(80, now + 0.35);
        osc.stop(now + 0.4);
      } catch (e) {
        console.warn('playIncorrect error:', e);
      }
    }

    startBackground() {
      if (!this.enabled || !this.ctx || this.isBgPlaying) return;
      try {
        const now = this.ctx.currentTime;
        this.bgOsc = this.ctx.createOscillator();
        this.bgOsc.type = 'sine';
        this.bgOsc.frequency.value = 55;
        this.bgGain = this.safeCreateGain();
        if (!this.bgGain) return;
        this.bgGain.gain.setValueAtTime(0.01, now);
        // subtle LFO for gentle wobble
        const lfo = this.ctx.createOscillator();
        lfo.type = 'sine';
        lfo.frequency.value = 0.25;
        const lfoGain = this.safeCreateGain();
        lfoGain.gain.value = 10;
        lfo.connect(lfoGain).connect(this.bgOsc.frequency);
        this.bgOsc.connect(this.bgGain).connect(this.ctx.destination);
        lfo.start();
        this.bgOsc.start();
        this.isBgPlaying = true;
      } catch (e) {
        console.warn('startBackground error:', e);
      }
    }

    stopBackground() {
      if (!this.ctx || !this.isBgPlaying) return;
      try {
        this.bgOsc.stop();
      } catch (e) {
        // ignore
      }
      this.bgOsc = null;
      this.bgGain = null;
      this.isBgPlaying = false;
    }

    toggleEnabled() {
      this.enabled = !this.enabled;
      if (this.enabled) {
        if (this.ctx && this.ctx.state === 'suspended') {
          this.ctx.resume().catch((err) => console.warn('resume failed', err));
        }
        this.startBackground();
      } else {
        this.stopBackground();
      }
    }
  }

  const audio = new AudioManager();
  if (audio.enabled) {
    audio.startBackground();
  }

  // ====== Utilities ======
  const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

  function subsetSumExists(parts, target) {
    // small dynamic programming check
    const possible = new Set([0]);
    for (const p of parts) {
      const next = new Set(possible);
      for (const s of possible) {
        next.add(s + p);
      }
      for (const v of next) possible.add(v);
      if (possible.has(target)) return true;
    }
    return possible.has(target);
  }

  function pickPartsForTarget(target, count) {
    // Ensure there's a subset summing to target. We'll create a solution and then add distractors.
    // Approach: create some numbers that sum to target by random partition, then add extras.
    const minPart = 1;
    const maxPart = Math.max(3, Math.floor(target * 0.9));
    const solution = [];
    let remaining = target;
    let picks = rand(1, Math.min(3, count));
    for (let i = 0; i < picks; i++) {
      if (i === picks - 1) {
        solution.push(remaining);
      } else {
        const maxPossible = Math.max(minPart, Math.floor(remaining - (picks - i - 1) * minPart));
        const v = Math.max(minPart, rand(1, maxPossible));
        solution.push(v);
        remaining -= v;
      }
    }

    // Now fill distractors
    const parts = solution.slice();
    while (parts.length < count) {
      let d = rand(1, Math.max(1, target + 3));
      // avoid exact duplicates of solution numbers excessively
      parts.push(d);
    }
    // Shuffle
    for (let i = parts.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [parts[i], parts[j]] = [parts[j], parts[i]];
    }

    // Validate subset sum exists
    if (!subsetSumExists(parts, target)) {
      // As fallback, make first two parts sum to target
      parts[0] = Math.max(1, target - 1);
      parts[1] = target - parts[0];
    }

    return parts.slice(0, count);
  }

  // ====== Game State ======
  let levelIndex = 0;
  let levels = [];
  let parts = []; // objects for current level
  let machineParts = []; // parts placed in machine
  let selectedPartIndex = -1;
  let isAnimating = false;
  let animationTicks = 0;
  let feedbackText = '';
  let showMuted = !audio.enabled;
  let usedAttempts = 0;

  // Floating decorative orbs for calming effect
  const orbs = Array.from({ length: 8 }, (_, i) => ({
    x: rand(40, GAME_WIDTH - 40),
    y: rand(40, GAME_HEIGHT - 40),
    r: rand(8, 24),
    hue: rand(150, 200),
    phase: Math.random() * Math.PI * 2,
    speed: (Math.random() * 0.5 + 0.2) / 60,
  }));

  function initLevels() {
    levels = [];
    for (let i = 0; i < LEVEL_COUNT; i++) {
      const difficulty = i + 1;
      // target increases with difficulty, stays kid-friendly
      const target = rand(5 + difficulty * 2, 8 + difficulty * 4);
      const count = Math.min(MAX_PARTS, 3 + difficulty);
      const partsList = pickPartsForTarget(target, count);
      levels.push({
        target,
        partsList,
      });
    }
  }

  function startLevel(idx) {
    levelIndex = idx;
    const level = levels[levelIndex];
    parts = [];
    machineParts = [];
    selectedPartIndex = -1;
    usedAttempts = 0;
    feedbackText = 'Place parts so their sum equals the machine target.';
    const trayX = 40;
    const trayY = 300;
    const spacing = 100;
    for (let i = 0; i < level.partsList.length; i++) {
      const p = {
        id: `p${i}`,
        value: level.partsList[i],
        x: trayX + i * spacing,
        y: trayY,
        tx: trayX + i * spacing,
        ty: trayY,
        w: 72,
        h: 48,
        inMachine: false,
        visible: true,
        color: i % 2 === 0 ? PART_COLOR : PART_COLOR_ALT,
      };
      parts.push(p);
    }
    isAnimating = false;
    animationTicks = 0;
  }

  // Initialize game
  initLevels();
  startLevel(0);

  // ====== Drawing ======
  function draw() {
    // Clear
    ctx.fillStyle = BG_COLOR;
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    // calming orbs background
    for (const orb of orbs) {
      const g = ctx.createRadialGradient(orb.x, orb.y, 0, orb.x, orb.y, orb.r * 3);
      g.addColorStop(0, `rgba(${orb.hue},200,220,0.18)`);
      g.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.ellipse(orb.x, orb.y, orb.r * 3, orb.r * 1.8, orb.phase, 0, Math.PI * 2);
      ctx.fill();
    }

    // Title and instructions
    ctx.fillStyle = TEXT_COLOR;
    ctx.font = TITLE_FONT;
    ctx.fillText('Wacky Machine Math', 20, 28);
    ctx.font = FONT;
    ctx.fillStyle = TEXT_COLOR;
    ctx.fillText('Theme: Machines — add parts to match the output number!', 20, 48);

    // Machine area
    const machineX = 420;
    const machineY = 70;
    const machineW = 260;
    const machineH = 280;
    // machine base
    ctx.fillStyle = MACHINE_COLOR;
    roundRect(ctx, machineX, machineY, machineW, machineH, 12);
    ctx.fill();

    // machine window
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(machineX + 20, machineY + 20, machineW - 40, 120);
    // target display
    ctx.fillStyle = '#1b2b31';
    ctx.font = 'bold 34px "Segoe UI", Roboto, sans-serif';
    const targetText = `TARGET: ${levels[levelIndex].target}`;
    ctx.fillText(targetText, machineX + 28, machineY + 64);

    // running dial / gauge
    ctx.strokeStyle = '#b9d8f5';
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.arc(machineX + machineW / 2, machineY + 200, 44, Math.PI, Math.PI * 1.9);
    ctx.stroke();

    // show current sum
    ctx.font = 'bold 24px "Segoe UI", Roboto, sans-serif';
    const currentSum = machineParts.reduce((s, p) => s + p.value, 0);
    ctx.fillStyle = TEXT_COLOR;
    ctx.fillText(`Sum: ${currentSum}`, machineX + 28, machineY + 220);

    // Visual gears and wacky elements on machine
    drawGears(machineX + 40, machineY + 160, 28, animationTicks * 0.06, '#cbe6ff');
    drawGear(machineX + 210, machineY + 160, 16, -animationTicks * 0.08, '#ffd2b3');

    // Tray area for parts
    ctx.fillStyle = '#f6fbf9';
    roundRect(ctx, 20, 250, 360, 200, 12);
    ctx.fill();
    ctx.font = 'bold 18px "Segoe UI", Roboto, sans-serif';
    ctx.fillStyle = '#344b50';
    ctx.fillText('Parts Tray (click or use keys 1-' + parts.length + ')', 28, 276);

    // Draw parts
    for (let i = 0; i < parts.length; i++) {
      const p = parts[i];
      // animate movement towards target positions if needed
      p.x += (p.tx - p.x) * 0.2;
      p.y += (p.ty - p.y) * 0.2;
      drawPart(p, i === selectedPartIndex);
    }

    // Draw machine area contents (placed parts)
    const placedBaseX = machineX + 40;
    const placedBaseY = machineY + 120;
    for (let i = 0; i < machineParts.length; i++) {
      const mp = machineParts[i];
      // position them in a stack
      const px = placedBaseX + (i % 3) * 72;
      const py = placedBaseY + Math.floor(i / 3) * 56;
      ctx.save();
      ctx.translate(px, py);
      drawPart({ ...mp, x: px, y: py, tx: px, ty: py }, false);
      ctx.restore();
    }

    // Control hints
    ctx.fillStyle = TEXT_COLOR;
    ctx.font = FONT;
    ctx.fillText('Controls:', 28, 380);
    ctx.fillText('Click part -> Click machine to add. Or press 1-' + parts.length + ' then Enter to add.', 28, 400);
    ctx.fillText('Backspace removes last part. R runs the machine. Arrow keys to select.', 28, 420);

    // Buttons (drawn)
    drawButton(GAME_WIDTH - 200, GAME_HEIGHT - 100, 160, 44, 'Run Machine (R)', '#6bb3ff');
    drawButton(GAME_WIDTH - 200, GAME_HEIGHT - 42, 160, 36, showMuted ? 'Audio Off' : 'Audio On', showMuted ? '#c2c2c2' : '#ffd28a');

    // Level progress
    ctx.fillStyle = TEXT_COLOR;
    ctx.font = FONT;
    ctx.fillText(`Level ${levelIndex + 1} of ${LEVEL_COUNT}`, GAME_WIDTH - 220, 36);

    // Feedback
    ctx.fillStyle = '#23414a';
    ctx.font = 'bold 18px "Segoe UI", Roboto, sans-serif';
    ctx.fillText(feedbackText, 20, GAME_HEIGHT - 12);

    // Audio visual cue
    ctx.beginPath();
    ctx.fillStyle = showMuted ? '#999' : '#2d7a2d';
    ctx.arc(GAME_WIDTH - 42, 40, 10, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawPart(p, highlighted) {
    // shadow
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.beginPath();
    roundRect(ctx, -p.w / 2, -p.h / 2, p.w, p.h, 8);
    ctx.fillStyle = p.color;
    ctx.fill();
    // outline
    ctx.lineWidth = highlighted ? 3 : 1.5;
    ctx.strokeStyle = highlighted ? HIGHLIGHT : '#b28b6a';
    ctx.stroke();
    // number
    ctx.fillStyle = '#21333b';
    ctx.font = 'bold 20px "Segoe UI", Roboto, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(p.value.toString(), 0, 0);
    // little bolt or screw for wacky machine look
    ctx.fillStyle = '#7a5f4e';
    ctx.beginPath();
    ctx.arc(-p.w / 4, -p.h / 4, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawGears(x, y, r, angle, color) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    ctx.fillStyle = color;
    ctx.beginPath();
    // simple toothed gear using many arcs
    const teeth = 10;
    for (let i = 0; i < teeth; i++) {
      const a = (i / teeth) * Math.PI * 2;
      const sx = Math.cos(a) * (r + 6);
      const sy = Math.sin(a) * (r + 6);
      ctx.moveTo(Math.cos(a) * r, Math.sin(a) * r);
      ctx.lineTo(sx, sy);
    }
    ctx.fill();
    // inner circle
    ctx.beginPath();
    ctx.fillStyle = '#ffffff';
    ctx.arc(0, 0, r * 0.55, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawGear(x, y, r, angle, color) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(0, 0, r + 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawButton(x, y, w, h, text, color) {
    ctx.fillStyle = color;
    roundRect(ctx, x, y, w, h, 8);
    ctx.fill();
    ctx.fillStyle = '#0b2430';
    ctx.font = 'bold 14px "Segoe UI", Roboto, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, x + w / 2, y + h / 2);
    ctx.textAlign = 'start';
  }

  function roundRect(ctx, x, y, w, h, r) {
    if (w < 2 * r) r = w / 2;
    if (h < 2 * r) r = h / 2;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  // ====== Interaction ======
  function pickPartAt(x, y) {
    for (let i = parts.length - 1; i >= 0; i--) {
      const p = parts[i];
      if (!p.visible) continue;
      const left = p.x - p.w / 2;
      const right = p.x + p.w / 2;
      const top = p.y - p.h / 2;
      const bottom = p.y + p.h / 2;
      if (x >= left && x <= right && y >= top && y <= bottom) return i;
    }
    return -1;
  }

  canvas.addEventListener('pointerdown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);
    // check tray parts
    const idx = pickPartAt(x, y);
    if (idx >= 0) {
      // select part
      selectedPartIndex = idx;
      audio.playClick();
      return;
    }
    // check run button
    if (x >= GAME_WIDTH - 200 && x <= GAME_WIDTH - 40 && y >= GAME_HEIGHT - 100 && y <= GAME_HEIGHT - 56) {
      // Run Machine clicked
      runMachine();
      return;
    }
    // audio toggle
    if (x >= GAME_WIDTH - 200 && x <= GAME_WIDTH - 40 && y >= GAME_HEIGHT - 42 && y <= GAME_HEIGHT - 6) {
      showMuted = !showMuted;
      audio.toggleEnabled();
      feedbackText = showMuted ? 'Audio muted' : 'Audio enabled';
      return;
    }
    // click machine area to add selected part
    const machineX = 420;
    const machineY = 70;
    const machineW = 260;
    const machineH = 280;
    if (x >= machineX && x <= machineX + machineW && y >= machineY && y <= machineY + machineH) {
      if (selectedPartIndex >= 0) {
        addSelectedPartToMachine();
      } else {
        // clicked machine; check if clicked on placed part to remove
        const mpIndex = pickMachinePartAt(x, y);
        if (mpIndex >= 0) {
          removeMachinePart(mpIndex);
        }
      }
      return;
    }
  });

  function pickMachinePartAt(x, y) {
    const machineX = 420;
    const machineY = 70;
    const placedBaseX = machineX + 40;
    const placedBaseY = machineY + 120;
    for (let i = 0; i < machineParts.length; i++) {
      const px = placedBaseX + (i % 3) * 72;
      const py = placedBaseY + Math.floor(i / 3) * 56;
      const left = px - 36;
      const right = px + 36;
      const top = py - 24;
      const bottom = py + 24;
      if (x >= left && x <= right && y >= top && y <= bottom) return i;
    }
    return -1;
  }

  // Keyboard controls
  canvas.addEventListener('keydown', (e) => {
    if (e.key >= '1' && e.key <= String(Math.max(1, parts.length))) {
      const idx = Math.min(parts.length - 1, parseInt(e.key, 10) - 1);
      selectedPartIndex = idx;
      audio.playClick();
      e.preventDefault();
      return;
    }

    switch (e.key) {
      case 'ArrowRight':
        if (parts.length === 0) break;
        selectedPartIndex = (selectedPartIndex + 1 + parts.length) % parts.length;
        audio.playClick();
        e.preventDefault();
        break;
      case 'ArrowLeft':
        if (parts.length === 0) break;
        selectedPartIndex = (selectedPartIndex - 1 + parts.length) % parts.length;
        audio.playClick();
        e.preventDefault();
        break;
      case 'Enter':
      case ' ':
        if (selectedPartIndex >= 0) {
          addSelectedPartToMachine();
        }
        e.preventDefault();
        break;
      case 'Backspace':
        removeLastMachinePart();
        e.preventDefault();
        break;
      case 'r':
      case 'R':
        runMachine();
        e.preventDefault();
        break;
      case 'm':
      case 'M':
        showMuted = !showMuted;
        audio.toggleEnabled();
        e.preventDefault();
        break;
      default:
        break;
    }
  });

  function addSelectedPartToMachine() {
    if (selectedPartIndex < 0 || selectedPartIndex >= parts.length) {
      feedbackText = 'Select a part first (click or press 1-' + parts.length + ').';
      return;
    }
    const part = parts[selectedPartIndex];
    if (!part.visible) {
      feedbackText = 'That part is already used.';
      return;
    }
    // animate moving into machine
    const machineX = 420;
    const placedBaseX = machineX + 40;
    const placedBaseY = machineX ? machineX + 120 : 0; // not used, compute later
    // compute target slot
    const slotX = 420 + 40 + (machineParts.length % 3) * 72;
    const slotY = 70 + 120 + Math.floor(machineParts.length / 3) * 56;
    part.tx = slotX;
    part.ty = slotY;
    part.visible = false; // hide in tray, will be added to machineParts when close enough
    // store a copy for machineParts (visual)
    machineParts.push({ id: part.id, value: part.value, color: part.color });
    selectedPartIndex = -1;
    feedbackText = 'Placed part inside the machine.';
    audio.playClick();
  }

  function removeMachinePart(index) {
    if (index < 0 || index >= machineParts.length) return;
    const mp = machineParts.splice(index, 1)[0];
    // return a part to tray (find first invisible part slot)
    const returnSlot = parts.find((p) => p.id === mp.id);
    if (returnSlot) {
      returnSlot.visible = true;
      // animate back to tray
      returnSlot.tx = returnSlot.tx; // stay in its tray slot
    } else {
      // if not found, create new part back in tray
      const trayX = 40 + (parts.length % 4) * 100;
      const trayY = 300 + Math.floor(parts.length / 4) * 60;
      parts.push({
        id: mp.id,
        value: mp.value,
        x: trayX,
        y: trayY,
        tx: trayX,
        ty: trayY,
        w: 72,
        h: 48,
        inMachine: false,
        visible: true,
        color: mp.color,
      });
    }
    feedbackText = 'Removed a part from the machine.';
    audio.playClick();
  }

  function removeLastMachinePart() {
    if (machineParts.length === 0) {
      feedbackText = 'No parts in the machine to remove.';
      return;
    }
    const last = machineParts.pop();
    // return to tray
    const slotIdx = parts.findIndex((p) => p.id === last.id);
    if (slotIdx >= 0) {
      parts[slotIdx].visible = true;
      parts[slotIdx].tx = parts[slotIdx].tx; // keep position
    } else {
      parts.push({
        id: last.id,
        value: last.value,
        x: 40,
        y: 300,
        tx: 40,
        ty: 300,
        w: 72,
        h: 48,
        visible: true,
        color: last.color,
      });
    }
    feedbackText = 'Removed the last part.';
    audio.playClick();
  }

  // ====== Game logic - Run machine and level progression ======
  function runMachine() {
    if (isAnimating) return;
    usedAttempts++;
    const target = levels[levelIndex].target;
    const sum = machineParts.reduce((s, p) => s + p.value, 0);
    if (sum === target) {
      // success
      isAnimating = true;
      animationTicks = 0;
      feedbackText = 'Perfect! Machine is happy!';
      if (audio.enabled) audio.playCorrect();
      // celebration animation and next level after short delay
      setTimeout(() => {
        levelIndex++;
        if (levelIndex >= levels.length) {
          // game complete
          feedbackText = 'You fixed all the machines! Great job!';
          // create confetti effect by altering orbs
          for (const orb of orbs) {
            orb.hue = rand(20, 330);
          }
        } else {
          feedbackText = 'Level up! New machine appears...';
          startLevel(levelIndex);
        }
      }, 1200);
    } else {
      // incorrect - allow retries
      feedbackText = `Not quite. Machine shows ${sum}. Try again.`;
      if (audio.enabled) audio.playIncorrect();
      // small wobble animation
      isAnimating = true;
      animationTicks = 0;
      setTimeout(() => {
        isAnimating = false;
      }, 700);
    }
  }

  // ====== Animation loop ======
  let last = performance.now();
  function loop(now) {
    const dt = now - last;
    last = now;

    // update anims
    animationTicks += dt / 16;
    // animate orbs gentle movement
    for (const orb of orbs) {
      orb.phase += orb.speed * dt;
      orb.x += Math.cos(orb.phase) * 0.02 * dt;
      orb.y += Math.sin(orb.phase) * 0.01 * dt;
    }

    // detect when a part has reached its tx/ty to finalize placement (for parts that were set invisible)
    for (const p of parts) {
      if (!p.visible) {
        // find if this part corresponds to a machineParts entry (by id) and if so, set visible false until settled
        p.x += (p.tx - p.x) * 0.18;
        p.y += (p.ty - p.y) * 0.18;
      }
    }
    // finalize "invisible" tray parts placed into machine when close enough
    for (let i = parts.length - 1; i >= 0; i--) {
      const p = parts[i];
      if (!p.visible) {
        if (Math.hypot(p.x - p.tx, p.y - p.ty) < 6) {
          // remove this tray part (since machineParts holds a copy)
          parts.splice(i, 1);
        }
      }
    }

    // stop background audio gracefully if disabled
    if (!audio.enabled && audio.isBgPlaying) {
      audio.stopBackground();
    }
    if (audio.enabled && audio.ctx && !audio.isBgPlaying) {
      audio.startBackground();
    }

    draw();
    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);

  // ====== Helpful HUD and restart controls (keyboard accessible) ======
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      // reset game
      initLevels();
      startLevel(0);
      feedbackText = 'Game reset. Start again!';
      audio.playClick();
    }
  });

  // focus the canvas for keyboard on load
  setTimeout(() => {
    try {
      canvas.focus();
    } catch (e) {
      // ignore
    }
  }, 100);

  // Expose small help in console for testers
  console.log('Wacky Machine Math loaded. Use mouse or keyboard. Press Escape to reset.');

  // ====== Error handling hints (audible and visual) ======
  if (!audio.enabled) {
    feedbackText = 'Audio unavailable. You can still play with visual cues.';
  }
})();
---

