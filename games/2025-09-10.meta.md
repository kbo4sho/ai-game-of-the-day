# Game of the Day - 2025-09-10

## Metadata
- **Generated Date:** 2025-09-10
- **Generated Time:** 2025-09-10T00:25:44.790995
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-10.js
- **File Size:** 27705 bytes
- **Tokens Used:** 8743

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-10.js` - The playable game
- `2025-09-10.meta.json` - Machine-readable metadata
- `2025-09-10.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 19888

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 22156

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Machine Math: a calming, wacky math game for ages 7-9.
  // Renders inside the element with ID "game-of-the-day-stage".
  // All visuals drawn on a 720x480 canvas. Audio via Web Audio API oscillators.
  // Author: AI educational game designer

  // Utility helpers
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const randInt = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;

  // Game config
  const WIDTH = 720;
  const HEIGHT = 480;
  const MAX_ROUNDS = 5; // Beatable after this many correct assemblies
  const INITIAL_SPEED = 1.0; // conveyor speed
  const COG_RADIUS = 28;

  // Colors (calming pastels, wacky accents)
  const COLORS = {
    background: '#F3F7F9',
    stage: '#E8F1F2',
    conveyor: '#B2D9D9',
    cog: '#FFE0B2',
    cogAccent: '#FFB74D',
    arm: '#9AD3BC',
    slot: '#E1E8EB',
    text: '#264653',
    good: '#2a9d8f',
    bad: '#e76f51',
    speaker: '#6C7A89'
  };

  // Element and canvas setup
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    throw new Error('Game container element with ID "game-of-the-day-stage" not found.');
  }
  // Clear container content (render entirely inside it)
  container.innerHTML = '';
  container.style.position = 'relative'; // ensure positioning support

  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute('role', 'img');
  canvas.setAttribute('aria-label', 'Machine Math game canvas');
  canvas.style.display = 'block';
  canvas.style.outline = 'none';
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d', { alpha: false });

  // Accessible text region for screen readers (offscreen but inside container)
  const sr = document.createElement('div');
  sr.setAttribute('aria-live', 'polite');
  sr.setAttribute('role', 'status');
  sr.style.position = 'absolute';
  sr.style.left = '-10000px';
  sr.style.width = '1px';
  sr.style.height = '1px';
  sr.style.overflow = 'hidden';
  container.appendChild(sr);

  // Game state
  let audioEnabled = true;
  let audioInitialized = false;
  let audioError = null;
  let audioContext = null;
  let masterGain = null;
  let backgroundOsc = null;
  let bgGainNode = null;

  // Audio initialization with error handling
  async function initAudio() {
    if (audioInitialized) return;
    try {
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtx) throw new Error('Web Audio API is not supported in this browser.');
      audioContext = new AudioCtx();
      masterGain = audioContext.createGain();
      masterGain.gain.value = 0.7;
      masterGain.connect(audioContext.destination);

      // Gentle background hum: create two detuned oscillators for a soothing pad
      backgroundOsc = audioContext.createOscillator();
      const backgroundOsc2 = audioContext.createOscillator();
      bgGainNode = audioContext.createGain();
      bgGainNode.gain.value = 0.06; // quiet
      backgroundOsc.type = 'sine';
      backgroundOsc.frequency.value = 110; // low hum
      backgroundOsc2.type = 'sine';
      backgroundOsc2.frequency.value = 112; // slightly detuned

      // Gentle lowpass to mellow the hum
      const bgFilter = audioContext.createBiquadFilter();
      bgFilter.type = 'lowpass';
      bgFilter.frequency.value = 1000;
      backgroundOsc.connect(bgFilter);
      backgroundOsc2.connect(bgFilter);
      bgFilter.connect(bgGainNode);
      bgGainNode.connect(masterGain);

      backgroundOsc.start();
      backgroundOsc2.start();

      audioInitialized = true;
    } catch (err) {
      audioError = err.message || String(err);
      audioEnabled = false;
      audioInitialized = false;
      console.warn('Audio init failed:', audioError);
    }
  }

  // Sound effects
  function playClick() {
    if (!audioEnabled || !audioInitialized) return;
    try {
      const o = audioContext.createOscillator();
      const g = audioContext.createGain();
      o.type = 'triangle';
      o.frequency.value = 880;
      g.gain.value = 0.0001;
      o.connect(g);
      g.connect(masterGain);
      const now = audioContext.currentTime;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.08, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);
      o.start(now);
      o.stop(now + 0.2);
    } catch (e) {
      console.warn('playClick error', e);
    }
  }

  function playCorrect() {
    if (!audioEnabled || !audioInitialized) return;
    try {
      const now = audioContext.currentTime;
      // Glorious ascending arpeggio
      const freqs = [440, 660, 880].map(f => f * (Math.random() * 0.03 + 0.98));
      freqs.forEach((f, i) => {
        const o = audioContext.createOscillator();
        const g = audioContext.createGain();
        o.type = i === 1 ? 'sine' : 'triangle';
        o.frequency.value = f;
        g.gain.value = 0.0001;
        const filt = audioContext.createBiquadFilter();
        filt.type = 'lowpass';
        filt.frequency.value = 1200 + i * 200;
        o.connect(filt);
        filt.connect(g);
        g.connect(masterGain);
        const t0 = now + i * 0.08;
        g.gain.setValueAtTime(0.0001, t0);
        g.gain.exponentialRampToValueAtTime(0.12, t0 + 0.03);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.25);
        o.start(t0);
        o.stop(t0 + 0.3);
      });
    } catch (e) {
      console.warn('playCorrect error', e);
    }
  }

  function playWrong() {
    if (!audioEnabled || !audioInitialized) return;
    try {
      const o = audioContext.createOscillator();
      const g = audioContext.createGain();
      o.type = 'square';
      o.frequency.value = 220;
      g.gain.value = 0.0001;
      const filt = audioContext.createBiquadFilter();
      filt.type = 'lowpass';
      filt.frequency.value = 1000;
      o.connect(filt);
      filt.connect(g);
      g.connect(masterGain);
      const now = audioContext.currentTime;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.12, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);
      o.start(now);
      o.stop(now + 0.2);
    } catch (e) {
      console.warn('playWrong error', e);
    }
  }

  // Game classes
  class Cog {
    constructor(number, x, y, speed) {
      this.number = number;
      this.x = x;
      this.y = y;
      this.theta = Math.random() * Math.PI * 2;
      this.speed = speed; // horizontal speed for conveyor
      this.radius = COG_RADIUS;
      this.picked = false;
      this.id = Math.random().toString(36).slice(2);
    }

    update(dt) {
      if (!this.picked) {
        this.x += this.speed * dt;
        this.theta += 0.8 * dt;
        // Wrap around horizontally within conveyor region
        if (this.x > WIDTH + this.radius) {
          this.x = -this.radius;
        } else if (this.x < -this.radius) {
          this.x = WIDTH + this.radius;
        }
      }
    }

    draw(ctx) {
      // Cog body
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.theta);
      // Teeth
      for (let i = 0; i < 8; i++) {
        ctx.rotate((Math.PI * 2) / 8);
        ctx.fillStyle = COLORS.cogAccent;
        ctx.beginPath();
        ctx.roundRect(-6, this.radius - 6, 12, 12, 3);
        ctx.fill();
      }
      // Main circle
      ctx.beginPath();
      ctx.fillStyle = COLORS.cog;
      ctx.arc(0, 0, this.radius - 6, 0, Math.PI * 2);
      ctx.fill();

      // Face: friendly eyes
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(-8, -6, 5, 0, Math.PI * 2);
      ctx.arc(8, -6, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#333';
      ctx.beginPath();
      ctx.arc(-8, -6, 2, 0, Math.PI * 2);
      ctx.arc(8, -6, 2, 0, Math.PI * 2);
      ctx.fill();

      // Number
      ctx.fillStyle = COLORS.text;
      ctx.font = 'bold 20px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(this.number), 0, 10);

      ctx.restore();
    }

    containsPoint(px, py) {
      const dx = px - this.x;
      const dy = py - this.y;
      return dx * dx + dy * dy <= this.radius * this.radius;
    }
  }

  class Slot {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.width = 110;
      this.height = 70;
      this.filledCog = null;
    }

    draw(ctx) {
      ctx.save();
      ctx.translate(this.x, this.y);
      // Slot base
      ctx.fillStyle = COLORS.slot;
      roundRect(ctx, -this.width / 2, -this.height / 2, this.width, this.height, 12);
      ctx.fill();
      // Label
      ctx.fillStyle = COLORS.text;
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Slot', 0, -this.height / 2 - 10);

      // If filled, draw the cog smaller
      if (this.filledCog) {
        ctx.save();
        ctx.translate(0, 8);
        ctx.scale(0.8, 0.8);
        this.filledCog.draw(ctx);
        ctx.restore();
      }
      ctx.restore();
    }

    containsPoint(px, py) {
      return (
        px >= this.x - this.width / 2 &&
        px <= this.x + this.width / 2 &&
        py >= this.y - this.height / 2 &&
        py <= this.y + this.height / 2
      );
    }
  }

  // Drawing utils
  function roundRect(ctx, x, y, w, h, r) {
    r = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  // Main Game class
  class MachineMathGame {
    constructor(ctx) {
      this.ctx = ctx;
      this.cogs = [];
      this.slots = [];
      this.armX = WIDTH / 2;
      this.armY = 110;
      this.armTargetX = this.armX;
      this.armSpeed = 400; // px per second
      this.heldCog = null;
      this.conveyorY = 220;
      this.conveyorSpeed = INITIAL_SPEED;
      this.round = 1;
      this.score = 0;
      this.targetSum = 5;
      this.elapsed = 0;
      this.lastTime = performance.now();
      this.paused = false;
      this.ready = false;
      this.message = 'Press Space or Click a cog to pick it up.';
      this.hint = 'Use ← → or drag; press Space to pick/place. Press M to toggle sound.';
      this.note = '';
      this.speakerAnimating = 0;
      this.initLevel();
      this.bindEvents();
      this.isPlaying = true;
      sr.innerText = `Welcome to Machine Math. Target: ${this.targetSum}. ${this.message}`;
    }

    initLevel() {
      // Create cogs with numbers 1-9 scattered on conveyor
      this.cogs = [];
      const count = 7; // number of cogs on conveyor
      for (let i = 0; i < count; i++) {
        const n = randInt(1, Math.min(9, 4 + this.round)); // increase max with rounds
        const x = (i / count) * WIDTH + randInt(-40, 40);
        const y = this.conveyorY + randInt(-10, 10);
        const speed = this.conveyorSpeed * (randInt(80, 120) / 100);
        this.cogs.push(new Cog(n, x, y, speed));
      }
      // Slots: two slots to add up to target
      this.slots = [];
      const sx = WIDTH / 2;
      this.slots.push(new Slot(sx - 130, 360));
      this.slots.push(new Slot(sx + 130, 360));
      this.heldCog = null;
      // target sum increases modestly
      this.targetSum = clamp(3 + this.round + randInt(0, 3), 3, 15);
      this.message = `Assemble two cogs that add up to ${this.targetSum}.`;
      this.hint = 'Drag or use arrow keys and Space. M toggles sound.';
      this.ready = true;
      sr.innerText = `Round ${this.round}. Target: ${this.targetSum}. ${this.message}`;
    }

    bindEvents() {
      // Keyboard controls
      window.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') {
          this.armTargetX = clamp(this.armTargetX - 60, 40, WIDTH - 40);
          e.preventDefault();
        } else if (e.key === 'ArrowRight') {
          this.armTargetX = clamp(this.armTargetX + 60, 40, WIDTH - 40);
          e.preventDefault();
        } else if (e.key === ' ' || e.key === 'Spacebar') {
          // pick/place
          this.tryPickOrPlace();
          e.preventDefault();
        } else if (e.key.toLowerCase() === 'm') {
          toggleAudio();
        } else if (e.key === 'Enter' && !this.isPlaying) {
          this.resetGame();
        }
      });

      // Mouse events: dragging and clicking
      let dragging = false;
      let dragOffsetX = 0;
      canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        // If clicked on a cog, pick it up
        for (let cog of this.cogs) {
          if (!cog.picked && cog.containsPoint(mx, my)) {
            this.pickCog(cog);
            dragging = true;
            dragOffsetX = cog.x - mx;
            return;
          }
        }
        // Click near arm to set target pos
        if (Math.abs(my - this.armY) < 80) {
          this.armTargetX = clamp(mx, 40, WIDTH - 40);
        }
      });

      canvas.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        // Move held cog with cursor
        if (this.heldCog) {
          this.heldCog.x = clamp(mx + dragOffsetX, 20, WIDTH - 20);
          this.heldCog.y = this.armY + 24;
        }
      });

      window.addEventListener('mouseup', (e) => {
        if (dragging) {
          dragging = false;
          // Try to place if near slot
          if (this.heldCog) {
            let placed = false;
            for (const slot of this.slots) {
              if (slot.containsPoint(this.heldCog.x, this.heldCog.y)) {
                this.placeInSlot(slot);
                placed = true;
                break;
              }
            }
            if (!placed) {
              // drop back to conveyor
              this.dropToConveyor();
            }
          }
        }
      });

      // Touch support
      canvas.addEventListener('touchstart', (e) => {
        const t = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const mx = t.clientX - rect.left;
        const my = t.clientY - rect.top;
        for (let cog of this.cogs) {
          if (!cog.picked && cog.containsPoint(mx, my)) {
            this.pickCog(cog);
            e.preventDefault();
            return;
          }
        }
        if (Math.abs(my - this.armY) < 100) {
          this.armTargetX = clamp(mx, 40, WIDTH - 40);
        }
      }, { passive: false });
    }

    pickCog(cog) {
      if (this.heldCog) {
        // Already holding one; ignore pick
        return;
      }
      cog.picked = true;
      this.heldCog = cog;
      // Move cog above arm
      cog.x = this.armX;
      cog.y = this.armY + 24;
      playClick();
      sr.innerText = `Picked up a ${cog.number}.`;
    }

    tryPickOrPlace() {
      if (this.heldCog) {
        // Try place into a slot under the arm
        let placed = false;
        for (const slot of this.slots) {
          if (slot.containsPoint(this.armX, slot.y)) {
            this.placeInSlot(slot);
            placed = true;
            break;
          }
        }
        if (!placed) {
          this.dropToConveyor();
        }
      } else {
        // pick the nearest cog under the arm
        let nearest = null;
        let bestD = 1e9;
        for (const cog of this.cogs) {
          if (!cog.picked) {
            const d = Math.abs(cog.x - this.armX) + Math.abs(cog.y - this.armY);
            if (d < bestD && d < 120) {
              bestD = d;
              nearest = cog;
            }
          }
        }
        if (nearest) {
          this.pickCog(nearest);
        } else {
          // no cog found
          this.note = 'No cog within reach. Move closer!';
          playWrong();
          sr.innerText = 'No cog within reach. Move closer!';
        }
      }
    }

    placeInSlot(slot) {
      if (slot.filledCog) {
        // Already filled
        this.note = 'This slot is already filled.';
        playWrong();
        sr.innerText = 'Slot already filled. Choose another.';
        this.dropToConveyor();
        return;
      }
      slot.filledCog = this.heldCog;
      slot.filledCog.x = slot.x;
      slot.filledCog.y = slot.y;
      this.heldCog = null;
      playClick();
      sr.innerText = `Placed a cog in a slot.`;
      // Check if all slots filled
      if (this.slots.every(s => s.filledCog)) {
        this.checkSolution();
      }
    }

    dropToConveyor() {
      if (this.heldCog) {
        this.heldCog.picked = false;
        this.heldCog.speed = this.conveyorSpeed * (randInt(90, 110) / 100);
        this.heldCog.y = this.conveyorY + randInt(-8, 8);
        this.heldCog = null;
        playClick();
      }
    }

    checkSolution() {
      const sum = this.slots.reduce((s, slot) => s + (slot.filledCog ? slot.filledCog.number : 0), 0);
      if (sum === this.targetSum) {
        // success!
        this.score++;
        this.message = 'Perfect! The machine whirs to life.';
        playCorrect();
        sr.innerText = `${this.message} You completed round ${this.round}.`;
        // animate a little (machine runs) then next round
        setTimeout(() => {
          this.showMachineSuccess();
        }, 500);
      } else {
        // wrong
        this.message = `Oops. That adds to ${sum}. Try again.`;
        playWrong();
        sr.innerText = `Incorrect. ${this.message}`;
        // empty slots and return cogs to conveyor spots
        setTimeout(() => {
          for (const slot of this.slots) {
            if (slot.filledCog) {
              const c = slot.filledCog;
              c.picked = false;
              c.x = slot.x + randInt(-80, 80);
              c.y = this.conveyorY + randInt(-12, 12);
              c.speed = this.conveyorSpeed * (randInt(80, 120) / 100);
              slot.filledCog = null;
            }
          }
        }, 600);
      }
    }

    showMachineSuccess() {
      // Visual effect: gear spins quickly, new toy appears
      this.note = 'A toy is made!';
      // Clear slots (remove used cogs) and increase round
      for (const slot of this.slots) {
        if (slot.filledCog) {
          // remove the cog from the conveyor (simulate used)
          const idx = this.cogs.indexOf(slot.filledCog);
          if (idx >= 0) this.cogs.splice(idx, 1);
        }
        slot.filledCog = null;
      }
      this.round++;
      // Increase difficulty slightly
      this.conveyorSpeed = clamp(this.conveyorSpeed + 0.15, 0.8, 2.5);
      if (this.score >= MAX_ROUNDS || this.round > MAX_ROUNDS) {
        this.winGame();
      } else {
        setTimeout(() => {
          this.initLevel();
        }, 900);
      }
    }

    winGame() {
      this.isPlaying = false;
      this.message = 'You win! The Machine built a parade of toys!';
      sr.innerText = `Congratulations! ${this.message} Press Enter to play again.`;
      playCorrect();
    }

    resetGame() {
      this.round = 1;
      this.score = 0;
      this.conveyorSpeed = INITIAL_SPEED;
      this.isPlaying = true;
      this.initLevel();
      this.lastTime = performance.now();
    }

    update(dt) {
      if (!this.isPlaying) return;
      this.elapsed += dt;
      // Smooth arm movement toward target
      const dist = this.armTargetX - this.armX;
      const move = clamp(dist, -this.armSpeed * dt / 1000, this.armSpeed * dt / 1000);
      this.armX += move;

      // Update cogs
      for (const cog of this.cogs) {
        cog.speed = this.conveyorSpeed * (Math.sign(cog.speed) || 1);
        cog.update(dt / 16); // scale dt to be pleasant
      }

      // If holding a cog, keep above arm
      if (this.heldCog) {
        this.heldCog.x += (this.armX - this.heldCog.x) * 0.45;
        this.heldCog.y += (this.armY + 24 - this.heldCog.y) * 0.25;
      }

      // Slight speaker animation
      this.speakerAnimating = (this.speakerAnimating + dt / 400) % Math.PI * 2;
    }

    draw() {
      // background
      ctx.fillStyle = COLORS.background;
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      // wacky clouds / shapes for calming effect
      drawDecorativeShapes(ctx);

      // stage
      ctx.fillStyle = COLORS.stage;
      roundRect(ctx, 18, 40, WIDTH - 36, HEIGHT - 70, 18);
      ctx.fill();

      // Conveyor belt
      ctx.save();
      ctx.translate(0, this.conveyorY);
      ctx.fillStyle = COLORS.conveyor;
      roundRect(ctx, 20, -34, WIDTH - 40, 80, 14);
      ctx.fill();

      // Decorative bolts on conveyor
      for (let i = 0; i < 10; i++) {
        ctx.fillStyle = 'rgba(255,255,255,0.25)';
        ctx.beginPath();
        const bx = 50 + i * 70 + ((Date.now() / 250) % 70);
        ctx.arc(bx % WIDTH, 8, 6, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();

      // Draw cogs on conveyor
      // sort to give depth (by y)
      const drawList = this.cogs.slice().sort((a, b) => a.y - b.y);
      for (const cog of drawList) {
        cog.draw(ctx);
      }

      // Robotic arm
      this.drawArm(ctx);

      // Slots and assembly area
      for (const slot of this.slots) slot.draw(ctx);

      // HUD: target, round, score
      ctx.fillStyle = COLORS.text;
      ctx.font = '20px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText(`Round: ${this.round}`, 30, 30);
      ctx.textAlign = 'center';
      ctx.fillText(`Target: ${this.targetSum}`, WIDTH / 2, 30);
      ctx.textAlign = 'right';
      ctx.fillText(`Built: ${this.score}`, WIDTH - 30, 30);

      // Instructions and messages
      ctx.fillStyle = 'rgba(38,70,83,0.9)';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(this.message, WIDTH / 2, HEIGHT - 28);
      ctx.font = '12px sans-serif';
      ctx.fillStyle = 'rgba(38,70,83,0.7)';
      ctx.fillText(this.hint, WIDTH / 2, HEIGHT - 10);

      // Speaker visual (audio on/off)
      this.drawSpeaker(ctx);

      // If game over, overlay
      if (!this.isPlaying) {
        ctx.fillStyle = 'rgba(38,70,83,0.6)';
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
        ctx.fillStyle = '#fff';
        ctx.font = '28px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('You did it! Parade of toys!', WIDTH / 2, HEIGHT / 2 - 10);
        ctx.font = '16px sans-serif';
        ctx.fillText('Press Enter to play again', WIDTH / 2, HEIGHT / 2 + 22);
      }
    }

    drawArm(ctx) {
      ctx.save();
      ctx.translate(this.armX, this.armY);
      // Arm shadow
      ctx.fillStyle = 'rgba(0,0,0,0.05)';
      ctx.beginPath();
      ctx.ellipse(0, 80, 60, 16, 0, 0, Math.PI * 2);
      ctx.fill();

      // Arm vertical column
      ctx.fillStyle = COLORS.arm;
      roundRect(ctx, -20, -80, 40, 140, 12);
      ctx.fill();

      // Gripper
      ctx.save();
      ctx.translate(0, 60);
      ctx.fillStyle = '#7FBFAD';
      roundRect(ctx, -44, -8, 88, 16, 6);
      ctx.fill();
      // Individual fingers
      ctx.fillStyle = '#5DAE96';
      roundRect(ctx, -38, -12, 18, 20, 4);
      roundRect(ctx, 20, -12, 18, 20, 4);
      ctx.restore();

      ctx.restore();

      // If held cog, draw it anchored to arm
      if (this.heldCog) {
        ctx.save();
        ctx.globalAlpha = 1;
        this.heldCog.draw(ctx);
        ctx.restore();
      }
    }

    drawSpeaker(ctx) {
      const sx = WIDTH - 40;
      const sy = 60;
      ctx.save();
      // base speaker box
      ctx.fillStyle = COLORS.speaker;
      roundRect(ctx, sx - 14, sy - 12, 28, 24, 6);
      ctx.fill();
      // sound waves
      ctx.strokeStyle = audioEnabled ? COLORS.good : COLORS.bad;
      ctx.lineWidth = 2;
      ctx.beginPath();
      if (audioEnabled) {
        const t = Date.now() / 400;
        ctx.arc(sx + 16, sy, 12 + Math.sin(t) * 2, -0.6, 0.6);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(sx + 16, sy, 18 + Math.sin(t * 1.2) * 2, -0.6, 0.6);
        ctx.stroke();
      } else {
        ctx.moveTo(sx + 6, sy - 8);
        ctx.lineTo(sx + 24, sy + 8);
        ctx.moveTo(sx + 24, sy - 8);
        ctx.lineTo(sx + 6, sy + 8);
        ctx.stroke();
      }
      ctx.restore();
    }
  }

  // Decorative shapes to keep visuals calming and wacky
  function drawDecorativeShapes(ctx) {
    // Soft rounded blobs
    ctx.fillStyle = 'rgba(120,180,170,0.08)';
    ctx.beginPath();
    ctx.ellipse(110, 90, 70, 36, 0.4, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(560, 140, 90, 40, -0.5, 0, Math.PI * 2);
    ctx.fill();

    // Little gears motif top-right
    ctx.save();
    ctx.translate(WIDTH - 100, 80);
    for (let i = 0; i < 3; i++) {
      ctx.fillStyle = i === 1 ? 'rgba(255,180,120,0.11)' : 'rgba(160,200,190,0.07)';
      ctx.beginPath();
      ctx.arc(-i * 18, i * 10, 22 - i * 4, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  // Instantiate game
  const game = new MachineMathGame(ctx);

  // Animation loop
  function loop(now) {
    const dt = now - game.lastTime;
    game.lastTime = now;
    game.update(dt);
    game.draw();
    requestAnimationFrame(loop);
  }

  // Start audio on user gesture if available
  function resumeAudioOnGesture() {
    // If audio not initialized, try when user interacts
    if (!audioInitialized && audioEnabled) {
      initAudio().then(() => {
        if (!audioInitialized) {
          audioEnabled = false;
          sr.innerText = 'Audio could not be started.';
        } else {
          sr.innerText = 'Audio enabled. Press M to mute.';
        }
      }).catch((e) => {
        audioEnabled = false;
        sr.innerText = 'Audio initialization failed.';
        console.warn(e);
      });
    }
  }

  // Toggle audio on/off
  function toggleAudio() {
    if (!audioInitialized && !audioError) {
      // attempt to initialize audio
      initAudio().then(() => {
        if (audioInitialized) {
          audioEnabled = true;
          sr.innerText = 'Audio enabled.';
        } else {
          audioEnabled = false;
          sr.innerText = 'Audio unavailable.';
        }
      }).catch((e) => {
        audioEnabled = false;
        sr.innerText = 'Audio cannot be enabled.';
      });
      return;
    }
    audioEnabled = !audioEnabled;
    if (audioEnabled) {
      // restore gain
      if (masterGain) masterGain.gain.value = 0.7;
      sr.innerText = 'Audio on.';
    } else {
      if (masterGain) masterGain.gain.value = 0;
      sr.innerText = 'Audio muted. Press M to unmute.';
    }
  }

  // Try to initialize audio lazily (browsers require gesture)
  // Add gesture listeners
  function setupGestureInit() {
    const once = () => {
      resumeAudioOnGesture();
      window.removeEventListener('pointerdown', once);
      window.removeEventListener('keydown', once);
      window.removeEventListener('touchstart', once);
    };
    window.addEventListener('pointerdown', once);
    window.addEventListener('keydown', once);
    window.addEventListener('touchstart', once);
  }

  setupGestureInit();
  requestAnimationFrame(loop);

  // Expose minimal controls via container dataset for automation (optional)
  container.dataset.gameReady = 'true';

  // Graceful handling if audio cannot be created
  try {
    // nothing else here; audio will be lazy-initialized on gesture
  } catch (err) {
    audioEnabled = false;
    audioError = err.message || String(err);
    sr.innerText = 'Audio not available: ' + audioError;
  }

  // Provide developer-friendly console hints
  console.log('Machine Math game started. Controls: Arrow keys or drag. Space to pick/place. M to toggle sound.');

})();
---

