# Game of the Day - 2025-11-03

## Metadata
- **Generated Date:** 2025-11-03
- **Generated Time:** 2025-11-03T00:29:44.994906
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-11-03.js
- **File Size:** 27872 bytes
- **Tokens Used:** 10000

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-11-03.js` - The playable game
- `2025-11-03.meta.json` - Machine-readable metadata
- `2025-11-03.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 19434

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 20740

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Drone Math Adventure for ages 7-9
  // Renders into element with id "game-of-the-day-stage"
  // All visuals drawn on canvas; all sound via Web Audio API oscillators.
  // Clear win condition: answer targetCorrect questions correctly.
  // Lose condition: reach 0 lives (wrongAllowed wrong answers).
  // Keyboard: 1/2/3 to pick answers, arrows to move selection, Enter to confirm,
  // Space to begin/resume audio, M to mute, R to restart.
  // Accessible: container aria-label updated; keyboard controls documented on canvas.

  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const PADDING = 12; // min 10px per requirements
  const TARGET_CORRECT = 10;
  const WRONG_ALLOWED = 3;
  const FONT_BODY = '16px Arial';
  const FONT_IMPORTANT = '20px Arial';
  const FONT_TITLE = '28px "Segoe UI", Arial';

  // State
  let container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Container element #game-of-the-day-stage not found.');
    return;
  }

  // Clear container
  container.innerHTML = '';
  container.style.position = 'relative';
  container.setAttribute('role', 'application');
  container.setAttribute('aria-label', 'Drone Math Adventure. Use number keys 1 to 3 to answer. Press Space to start audio. Press R to restart.');

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.tabIndex = 0; // make focusable
  canvas.style.outline = 'none';
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Audio
  let audioCtx = null;
  let masterGain = null;
  let humOsc = null;
  let humGain = null;
  let audioEnabled = false;
  let muted = false;
  let audioInitTried = false;

  function initAudio() {
    if (audioInitTried) return;
    audioInitTried = true;
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) throw new Error('Web Audio API not supported');
      audioCtx = new AC();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.12;
      masterGain.connect(audioCtx.destination);

      // Gentle hum background using low-frequency oscillator and lowpass
      humOsc = audioCtx.createOscillator();
      humOsc.type = 'sine';
      humOsc.frequency.value = 110; // low
      humGain = audioCtx.createGain();
      humGain.gain.value = 0.02;
      const lowpass = audioCtx.createBiquadFilter();
      lowpass.type = 'lowpass';
      lowpass.frequency.value = 400;
      humOsc.connect(humGain);
      humGain.connect(lowpass);
      lowpass.connect(masterGain);
      humOsc.start();

      audioEnabled = true;
    } catch (e) {
      console.warn('Audio initialization failed:', e);
      audioEnabled = false;
    }
  }

  // Utility: play short tone for correct/incorrect feedback
  function playTone({frequency = 440, type = 'sine', duration = 0.18, volume = 0.15, attack = 0.005, release = 0.08}) {
    if (!audioEnabled || muted || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      osc.type = type;
      osc.frequency.setValueAtTime(frequency, now);
      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.linearRampToValueAtTime(volume, now + attack);
      gain.gain.linearRampToValueAtTime(0.0001, now + duration - release);
      osc.connect(gain);
      gain.connect(masterGain);
      osc.start(now);
      osc.stop(now + duration + 0.05);
      // cleanup handled by gc
    } catch (e) {
      console.warn('playTone error:', e);
    }
  }

  function playCorrect() {
    // A little rising arpeggio
    playTone({frequency: 660, type: 'sine', duration: 0.16, volume: 0.12});
    setTimeout(() => playTone({frequency: 880, type: 'triangle', duration: 0.12, volume: 0.09}), 80);
  }
  function playIncorrect() {
    playTone({frequency: 220, type: 'sawtooth', duration: 0.26, volume: 0.12});
    setTimeout(() => playTone({frequency: 170, type: 'sine', duration: 0.12, volume: 0.08}), 120);
  }

  // Game variables
  let state = 'intro'; // 'intro'|'playing'|'won'|'lost'
  let score = 0;
  let lives = WRONG_ALLOWED;
  let question = null;
  let options = [];
  let correctIndex = 0;
  let selectedIndex = 0;
  let droneX = WIDTH / 2;
  let droneY = HEIGHT / 3;
  let droneTargetX = droneX;
  let droneTargetY = droneY;
  let animations = []; // {type, t0, duration, ...}
  let spawnStars = []; // positions of collected stars for visuals

  // Timing
  let lastTime = performance.now();

  // Accessibility: live text feedback via container attribute
  function announce(text) {
    container.setAttribute('aria-live', 'polite');
    container.setAttribute('aria-label', text + '. ' + 'Score ' + score + ', lives ' + lives);
    // Also draw it briefly on-screen in instructions
    latestAnnouncement = text;
    latestAnnouncementTimer = 2400;
  }
  let latestAnnouncement = '';
  let latestAnnouncementTimer = 0;

  // Generate question
  function makeQuestion() {
    // For 7-9, mostly addition and subtraction, occasional multiplication
    const typeRand = Math.random();
    let a, b, op, correct;
    if (typeRand < 0.6) {
      // addition
      a = Math.floor(Math.random() * 20) + 1; // 1-20
      b = Math.floor(Math.random() * 20) + 1;
      op = '+';
      correct = a + b;
    } else if (typeRand < 0.9) {
      // subtraction ensure non-negative
      a = Math.floor(Math.random() * 20) + 5;
      b = Math.floor(Math.random() * 15);
      op = '-';
      correct = a - b;
    } else {
      // simple multiplication
      a = Math.floor(Math.random() * 8) + 2; // 2-9
      b = Math.floor(Math.random() * 8) + 2;
      op = '×';
      correct = a * b;
    }
    // create options: correct plus two distractors
    const opts = new Set();
    opts.add(correct);
    while (opts.size < 3) {
      const perturb = Math.floor(Math.random() * 7) - 3; // -3..3
      let val = correct + perturb;
      if (val < 0) val = Math.abs(val) + 1;
      if (val === correct) val = correct + (Math.random() < 0.5 ? 2 : -2);
      opts.add(val);
    }
    const arrayOpts = Array.from(opts);
    // shuffle
    for (let i = arrayOpts.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arrayOpts[i], arrayOpts[j]] = [arrayOpts[j], arrayOpts[i]];
    }
    correctIndex = arrayOpts.indexOf(correct);
    options = arrayOpts;
    question = `${a} ${op} ${b} = ?`;
    selectedIndex = 0;
    announce('New question: ' + question);
  }

  function resetGame() {
    score = 0;
    lives = WRONG_ALLOWED;
    spawnStars = [];
    animations = [];
    droneX = WIDTH / 2;
    droneY = HEIGHT / 3;
    droneTargetX = droneX;
    droneTargetY = droneY;
    latestAnnouncement = '';
    latestAnnouncementTimer = 0;
    makeQuestion();
    state = 'playing';
    announce('Game started. Answer ' + TARGET_CORRECT + ' questions correctly to win. You have ' + WRONG_ALLOWED + ' lives.');
  }

  // Hit detection for option boxes (we compute their rects each draw)
  let optionRects = []; // array of {x,y,w,h}

  // Draw helpers
  function drawRoundedRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }

  function drawBackground() {
    // calming gradient sky with subtle wacky blobs
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#e9f7ff');
    g.addColorStop(1, '#f7fbff');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // soft clouds (wacky)
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    for (let i = 0; i < 5; i++) {
      const cx = (i * 160 + (Math.sin(performance.now() / 3000 + i) * 20)) % (WIDTH + 200) - 100;
      const cy = 60 + i * 10 + Math.sin(performance.now() / 2000 + i) * 8;
      drawCloud(cx, cy, 60 + (i % 2) * 20);
    }
  }

  function drawCloud(cx, cy, size) {
    ctx.beginPath();
    ctx.ellipse(cx, cy, size, size * 0.6, 0, 0, Math.PI * 2);
    ctx.ellipse(cx + size * 0.7, cy + 6, size * 0.8, size * 0.5, 0, 0, Math.PI * 2);
    ctx.ellipse(cx - size * 0.6, cy + 4, size * 0.7, size * 0.5, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawDrone(x, y, t) {
    // Wacky drone: body, propellers, googly eyes
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(Math.sin(t / 300) * 0.04);
    // shadow
    ctx.beginPath();
    ctx.ellipse(0, 44, 70, 14, 0, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(20,20,20,0.06)';
    ctx.fill();

    // body
    ctx.fillStyle = '#8bd3ff';
    ctx.strokeStyle = '#4a9bbf';
    ctx.lineWidth = 2;
    drawRoundedRect(-50, -20, 100, 40, 12);

    // nose
    ctx.fillStyle = '#6ec3f7';
    ctx.beginPath();
    ctx.moveTo(50, 0);
    ctx.lineTo(70, -10);
    ctx.lineTo(70, 10);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // eyes
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.ellipse(-20, 0, 12, 12, 0, 0, Math.PI * 2);
    ctx.ellipse(10, 0, 12, 12, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#222';
    ctx.beginPath();
    const eyeShift = Math.sin(t / 300) * 2;
    ctx.ellipse(-20 + eyeShift, 0, 5, 6, 0, 0, Math.PI * 2);
    ctx.ellipse(10 + eyeShift, 0, 5, 6, 0, 0, Math.PI * 2);
    ctx.fill();

    // arms with rotors
    ctx.strokeStyle = '#5aa7c7';
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(-40, -10);
    ctx.lineTo(-90, -40);
    ctx.moveTo(40, -10);
    ctx.lineTo(90, -40);
    ctx.moveTo(-40, 10);
    ctx.lineTo(-90, 40);
    ctx.moveTo(40, 10);
    ctx.lineTo(90, 40);
    ctx.stroke();

    // rotors (wacky animated)
    for (let i = 0; i < 4; i++) {
      const angle = t / 80 + i;
      const rx = Math.cos(i * Math.PI / 2) * 90;
      const ry = Math.sin(i * Math.PI / 2) * 40;
      ctx.save();
      ctx.translate(rx, ry);
      ctx.rotate(Math.sin(angle) * 4);
      ctx.beginPath();
      ctx.fillStyle = 'rgba(60,60,60,0.8)';
      ctx.ellipse(0, 0, 30, 6, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    ctx.restore();
  }

  function drawStar(x, y, r, filled = true) {
    ctx.save();
    ctx.translate(x, y);
    ctx.beginPath();
    for (let i = 0; i < 5; i++) {
      ctx.lineTo(Math.cos((18 + i * 72) / 180 * Math.PI) * r, -Math.sin((18 + i * 72) / 180 * Math.PI) * r);
      ctx.lineTo(Math.cos((54 + i * 72) / 180 * Math.PI) * (r / 2.2), -Math.sin((54 + i * 72) / 180 * Math.PI) * (r / 2.2));
    }
    ctx.closePath();
    ctx.fillStyle = filled ? '#ffd166' : 'rgba(255,209,102,0.4)';
    ctx.fill();
    ctx.strokeStyle = '#e6b543';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.restore();
  }

  function drawUI(t) {
    ctx.font = FONT_IMPORTANT;
    ctx.textBaseline = 'top';
    ctx.lineWidth = 1;

    // Score top-left with background rectangle
    const scoreText = 'Stars: ' + score + ' / ' + TARGET_CORRECT;
    ctx.font = FONT_IMPORTANT;
    const scoreW = ctx.measureText(scoreText).width;
    const scoreX = PADDING;
    const scoreY = PADDING;
    const scorePad = 8;
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.strokeStyle = 'rgba(0,0,0,0.06)';
    ctx.fillRect(scoreX - scorePad, scoreY - scorePad, scoreW + scorePad * 2, 36 + scorePad - 8);
    ctx.strokeRect(scoreX - scorePad, scoreY - scorePad, scoreW + scorePad * 2, 36 + scorePad - 8);
    ctx.fillStyle = '#0b5394';
    ctx.fillText(scoreText, scoreX, scoreY);

    // Lives top-right
    const livesText = 'Lives: ' + lives;
    const livesPad = 8;
    ctx.font = FONT_IMPORTANT;
    const livesW = ctx.measureText(livesText).width;
    const livesX = WIDTH - livesW - PADDING;
    const livesY = PADDING;
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.fillRect(livesX - livesPad, livesY - livesPad, livesW + livesPad * 2, 36 + livesPad - 8);
    ctx.strokeStyle = 'rgba(0,0,0,0.06)';
    ctx.strokeRect(livesX - livesPad, livesY - livesPad, livesW + livesPad * 2, 36 + livesPad - 8);
    ctx.fillStyle = '#b22222';
    ctx.fillText(livesText, livesX, livesY);

    // Instructions bottom-center
    ctx.font = FONT_BODY;
    ctx.textBaseline = 'bottom';
    const instr = state === 'intro'
      ? 'Press Space or Click to Start. Use 1/2/3 to choose, arrows to move selection, Enter to confirm. M to mute, R to restart.'
      : 'Choose the correct answer! Keys: 1-3 to pick, Enter to confirm. M to mute. R to restart.';
    const instrW = ctx.measureText(instr).width;
    const instrX = (WIDTH - instrW) / 2;
    const instrY = HEIGHT - PADDING;
    // background rectangle
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    ctx.fillRect(instrX - 10, instrY - 36, instrW + 20, 36 + 12);
    ctx.fillStyle = '#064273';
    ctx.fillText(instr, instrX, instrY - 8);

    // Audio visual cue (speaker) near bottom-left
    const spX = PADDING;
    const spY = HEIGHT - 60;
    drawSpeaker(spX, spY, muted ? 0.5 : 1);

    // latest announcement box just above bottom, non-overlapping with instructions (ensure 10px)
    if (latestAnnouncementTimer > 0 && latestAnnouncement) {
      ctx.font = FONT_BODY;
      const ta = latestAnnouncement;
      const taW = ctx.measureText(ta).width;
      const taX = (WIDTH - taW) / 2;
      const taY = instrY - 60;
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fillRect(taX - 8, taY - 10, taW + 16, 36);
      ctx.fillStyle = '#0b4f6c';
      ctx.fillText(ta, taX, taY + 6);
    }
  }

  function drawSpeaker(x, y, alpha) {
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = '#1f618d';
    ctx.strokeStyle = '#0b3b59';
    ctx.lineWidth = 2;
    // box
    ctx.fillRect(x - 6, y - 6, 32, 32);
    ctx.strokeRect(x - 6, y - 6, 32, 32);
    // speaker icon
    ctx.beginPath();
    ctx.moveTo(x + 2, y + 2);
    ctx.lineTo(x + 10, y + 10);
    ctx.lineTo(x + 2, y + 18);
    ctx.closePath();
    ctx.fillStyle = '#fff';
    ctx.fill();
    // waves
    if (!muted) {
      ctx.beginPath();
      ctx.arc(x + 16, y + 10, 8, -0.6, 0.6);
      ctx.strokeStyle = '#ffd166';
      ctx.lineWidth = 2;
      ctx.stroke();
    } else {
      // draw X for muted
      ctx.strokeStyle = '#ff6b6b';
      ctx.beginPath();
      ctx.moveTo(x + 22, y + 2);
      ctx.lineTo(x + 8, y + 24);
      ctx.moveTo(x + 8, y + 2);
      ctx.lineTo(x + 22, y + 24);
      ctx.stroke();
    }
    ctx.restore();
  }

  // Main draw
  function draw(now) {
    const dt = now - lastTime;
    lastTime = now;

    // background
    drawBackground();

    // drone movement towards target
    const dx = droneTargetX - droneX;
    const dy = droneTargetY - droneY;
    droneX += dx * Math.min(1, 0.02 + Math.sqrt(Math.abs(dx)) * 0.002);
    droneY += dy * Math.min(1, 0.02 + Math.sqrt(Math.abs(dy)) * 0.002);

    // draw drone
    drawDrone(droneX, droneY, now);

    // draw collected stars near top-center
    const starsStartX = WIDTH / 2 - (TARGET_CORRECT * 14) / 2;
    for (let i = 0; i < TARGET_CORRECT; i++) {
      const x = starsStartX + i * 14;
      const y = PADDING + 60;
      if (i < score) drawStar(x, y, 6, true);
      else drawStar(x, y, 6, false);
    }

    // options area - placed below drone, centered
    ctx.font = FONT_TITLE;
    ctx.fillStyle = '#073b4c';
    ctx.textBaseline = 'top';
    const questionY = HEIGHT / 2 - 60;
    // draw question inside background rectangle
    ctx.font = FONT_TITLE;
    const qW = ctx.measureText(question || '').width;
    const qX = (WIDTH - qW) / 2;
    const qPad = 12;
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    ctx.fillRect(qX - qPad, questionY - qPad, qW + qPad * 2, 48 + qPad - 8);
    ctx.strokeStyle = 'rgba(0,0,0,0.06)';
    ctx.strokeRect(qX - qPad, questionY - qPad, qW + qPad * 2, 48 + qPad - 8);
    ctx.fillStyle = '#073b4c';
    ctx.fillText(question || '', qX, questionY);

    // draw option boxes
    ctx.font = FONT_BODY;
    optionRects = [];
    const optY = questionY + 70;
    const spacing = 18;
    // compute widths to ensure no overlap
    const optionWidths = options.map(o => ctx.measureText((options.indexOf(o)+1) + '. ' + o).width + 24);
    // total width
    const totalW = optionWidths.reduce((a, b) => a + b, 0) + spacing * (options.length - 1);
    let startX = (WIDTH - totalW) / 2;
    for (let i = 0; i < options.length; i++) {
      const w = optionWidths[i];
      const h = 48;
      const x = startX;
      const y = optY;
      // background
      ctx.fillStyle = (selectedIndex === i) ? 'rgba(139,195,74,0.95)' : 'rgba(255,255,255,0.94)';
      ctx.fillRect(x, y, w, h);
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.strokeRect(x, y, w, h);
      // text
      ctx.fillStyle = '#073b4c';
      ctx.fillText((i + 1) + '. ' + options[i], x + 12, y + 12);
      // store rect
      optionRects[i] = {x, y, w, h};
      startX += w + spacing;
    }

    // draw small hints for keyboard (non-overlapping)
    ctx.font = FONT_BODY;
    const hintText = 'Press 1,2,3 or Click an option. Press Enter to confirm.';
    const hintW = ctx.measureText(hintText).width;
    const hintX = (WIDTH - hintW) / 2;
    const hintY = optY + 70;
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.fillRect(hintX - 8, hintY - 8, hintW + 16, 36);
    ctx.fillStyle = '#064273';
    ctx.fillText(hintText, hintX, hintY + 6);

    // Draw animations (collecting stars, small explosions)
    animations = animations.filter(a => {
      const localT = (now - a.t0) / a.duration;
      if (a.type === 'collect') {
        // animate star moving from option to star bar
        const sx = a.sx;
        const sy = a.sy;
        const tx = a.tx;
        const ty = a.ty;
        const cx = sx + (tx - sx) * easeOutCubic(Math.min(1, localT));
        const cy = sy + (ty - sy) * easeOutCubic(Math.min(1, localT));
        drawStar(cx, cy, 8, true);
        if (localT >= 1) return false;
        return true;
      } else if (a.type === 'spark') {
        // small circles
        for (let k = 0; k < 6; k++) {
          const ang = (k / 6) * Math.PI * 2 + a.offset;
          const r = 10 + localT * 40;
          const x = a.x + Math.cos(ang) * r;
          const y = a.y + Math.sin(ang) * r;
          ctx.beginPath();
          ctx.fillStyle = `rgba(255, ${140 + k * 10}, 60, ${1 - localT})`;
          ctx.arc(x, y, 4 * (1 - localT), 0, Math.PI * 2);
          ctx.fill();
        }
        if (localT >= 1) return false;
        return true;
      }
      return false;
    });

    // victory or game over overlay
    if (state === 'won' || state === 'lost' || state === 'intro') {
      // ensure overlay does not cover top UI; place centered
      const boxW = 520;
      const boxH = 220;
      const boxX = (WIDTH - boxW) / 2;
      const boxY = (HEIGHT - boxH) / 2 - 10;
      ctx.fillStyle = 'rgba(255,255,255,0.96)';
      ctx.fillRect(boxX, boxY, boxW, boxH);
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.strokeRect(boxX, boxY, boxW, boxH);

      ctx.font = FONT_TITLE;
      ctx.fillStyle = '#0b3b59';
      ctx.textBaseline = 'top';
      const title = state === 'intro' ? 'Drone Math Adventure' : (state === 'won' ? 'YOU WIN!' : 'GAME OVER');
      const titleW = ctx.measureText(title).width;
      ctx.fillText(title, boxX + (boxW - titleW) / 2, boxY + 18);

      ctx.font = FONT_BODY;
      ctx.fillStyle = '#064273';
      let message = '';
      if (state === 'intro') {
        message = 'Help your friendly drone collect ' + TARGET_CORRECT + ' stars by answering math questions.\nYou can make up to ' + WRONG_ALLOWED + ' mistakes. Press Space or Click to begin.';
      } else if (state === 'won') {
        message = 'Great flying! You collected ' + score + ' stars. Press R or Click to play again.';
      } else {
        message = 'Oops! Your drone ran out of lives. You collected ' + score + ' stars. Press R or Click to try again.';
      }
      // multi-line text draw, ensure spacing
      const lines = message.split('\n');
      let textY = boxY + 72;
      for (const line of lines) {
        const lw = ctx.measureText(line).width;
        ctx.fillText(line, boxX + (boxW - lw) / 2, textY);
        textY += 26;
      }

      // restart button rectangle
      const btnText = 'Restart (R)';
      ctx.font = FONT_IMPORTANT;
      const btnW = ctx.measureText(btnText).width + 24;
      const btnH = 42;
      const btnX = boxX + (boxW - btnW) / 2;
      const btnY = boxY + boxH - btnH - 18;
      ctx.fillStyle = '#8bd3ff';
      ctx.fillRect(btnX, btnY, btnW, btnH);
      ctx.strokeStyle = '#4a9bbf';
      ctx.strokeRect(btnX, btnY, btnW, btnH);
      ctx.fillStyle = '#073b4c';
      ctx.fillText(btnText, btnX + 12, btnY + 8);

      // store restart rect for click
      restartRect = {x: btnX, y: btnY, w: btnW, h: btnH};
    } else {
      // no overlay
      restartRect = null;
    }

    // draw small credits / keyboard help top center (non overlapping)
    ctx.font = '14px Arial';
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    const help = 'Keyboard: 1-3 select • Enter confirm • M mute • R restart';
    const helpW = ctx.measureText(help).width;
    const helpX = (WIDTH - helpW) / 2;
    const helpY = PADDING + 4;
    ctx.fillText(help, helpX, helpY + 24);

    // reduce announcement timer
    if (latestAnnouncementTimer > 0) latestAnnouncementTimer -= dt;

    // loop
    requestAnimationFrame(draw);
  }

  function easeOutCubic(x) {
    return 1 - Math.pow(1 - x, 3);
  }

  // Input handlers
  canvas.addEventListener('keydown', e => {
    if (e.key === 'm' || e.key === 'M') {
      muted = !muted;
      announce(muted ? 'Muted' : 'Sound on');
      e.preventDefault();
      return;
    }
    if (state === 'intro') {
      if (e.code === 'Space' || e.key === 'Enter') {
        // start game and audio
        try {
          initAudio();
          if (audioEnabled && audioCtx && audioCtx.state === 'suspended') {
            audioCtx.resume();
          }
        } catch (e) {
          console.warn('Audio start error', e);
        }
        resetGame();
        e.preventDefault();
      }
      return;
    }
    if (state === 'won' || state === 'lost') {
      if (e.key === 'r' || e.key === 'R' || e.code === 'Space') {
        // restart
        try {
          initAudio();
        } catch (err) {}
        resetGame();
        e.preventDefault();
      }
      return;
    }
    // playing
    switch (e.key) {
      case '1':
      case '2':
      case '3':
        const idx = parseInt(e.key, 10) - 1;
        if (idx >= 0 && idx < options.length) {
          selectedIndex = idx;
          announce('Selected option ' + (idx + 1));
        }
        break;
      case 'ArrowLeft':
      case 'ArrowUp':
        selectedIndex = (selectedIndex + options.length - 1) % options.length;
        break;
      case 'ArrowRight':
      case 'ArrowDown':
        selectedIndex = (selectedIndex + 1) % options.length;
        break;
      case 'Enter':
        confirmSelection();
        break;
      case 'r':
      case 'R':
        resetGame();
        break;
      default:
        break;
    }
  });

  // Mouse click support
  let restartRect = null;
  canvas.addEventListener('click', e => {
    // compute canvas coordinates
    const rect = canvas.getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;

    if (state === 'intro') {
      try {
        initAudio();
      } catch (ex) {}
      resetGame();
      return;
    }
    if (restartRect && cx >= restartRect.x && cx <= restartRect.x + restartRect.w &&
      cy >= restartRect.y && cy <= restartRect.y + restartRect.h) {
      resetGame();
      return;
    }
    if (state === 'won' || state === 'lost') {
      // clicking anywhere restarts
      resetGame();
      return;
    }
    // check option rects
    for (let i = 0; i < optionRects.length; i++) {
      const r = optionRects[i];
      if (cx >= r.x && cx <= r.x + r.w && cy >= r.y && cy <= r.y + r.h) {
        selectedIndex = i;
        confirmSelection();
        return;
      }
    }
    // click near speaker toggles mute
    const spX = PADDING;
    const spY = HEIGHT - 60;
    if (cx >= spX - 10 && cx <= spX + 32 && cy >= spY - 10 && cy <= spY + 32) {
      muted = !muted;
      announce(muted ? 'Muted' : 'Sound unmuted');
    }
  });

  function confirmSelection() {
    if (state !== 'playing') return;
    const chosen = selectedIndex;
    const now = performance.now();
    // animate drone to option for fun
    const rect = optionRects[chosen];
    if (rect) {
      droneTargetX = rect.x + rect.w / 2;
      droneTargetY = rect.y - 40;
    }
    if (chosen === correctIndex) {
      // correct
      score++;
      spawnStars.push({t: now, fromX: rect ? rect.x + rect.w / 2 : droneX, fromY: rect ? rect.y + rect.h / 2 : droneY});
      // animate collect
      const tx = WIDTH / 2 - (TARGET_CORRECT * 14) / 2 + (score - 1) * 14;
      const ty = PADDING + 60;
      animations.push({type: 'collect', t0: now, duration: 600, sx: rect ? rect.x + rect.w / 2 : droneX, sy: rect ? rect.y + rect.h / 2 : droneY, tx, ty});
      animations.push({type: 'spark', t0: now, duration: 700, x: rect ? rect.x + rect.w / 2 : droneX, y: rect ? rect.y + rect.h / 2 : droneY, offset: Math.random() * 2});
      playCorrect();
      announce('Correct! You have ' + score + ' stars.');
      if (score >= TARGET_CORRECT) {
        // win
        state = 'won';
        announce('You win! Great job.');
      } else {
        // next question after a short delay
        setTimeout(() => {
          makeQuestion();
        }, 700);
      }
    } else {
      // incorrect
      lives--;
      animations.push({type: 'spark', t0: now, duration: 700, x: rect ? rect.x + rect.w / 2 : droneX, y: rect ? rect.y + rect.h / 2 : droneY, offset: Math.random() * 2});
      playIncorrect();
      announce('Oops! That was not correct. Lives left: ' + lives);
      if (lives <= 0) {
        state = 'lost';
        announce('Game over. Press R to try again.');
      } else {
        // flash correct answer visually by small animation
        setTimeout(() => {
          // show next question
          makeQuestion();
        }, 700);
      }
    }
  }

  // Start animation loop
  lastTime = performance.now();
  requestAnimationFrame(draw);

  // Generate a first question for intro display
  makeQuestion();
  state = 'intro';

  // Ensure focus
  setTimeout(() => {
    try {
      canvas.focus();
    } catch (e) {}
  }, 50);

  // Expose a small debug in case of audio issues
  window.DroneMathGame = {
    startAudio: initAudio,
    isAudioEnabled: () => audioEnabled,
    mute: (v) => { muted = v; }
  };

  // Error handling: check audio context resume on gesture if created
  canvas.addEventListener('mousedown', () => {
    if (!audioInitTried) {
      try {
        initAudio();
      } catch (e) {}
    } else if (audioEnabled && audioCtx && audioCtx.state === 'suspended') {
      audioCtx.resume().catch(() => {});
    }
  });

  // Keyboard focus reminder for accessibility
  canvas.addEventListener('blur', () => {
    // draw a subtle ring in canvas by announcing
    latestAnnouncement = 'Canvas lost focus. Click or press Tab to focus the game for keyboard control.';
    latestAnnouncementTimer = 2000;
  });

  // Handle page visibility to suspend/resume audio safely
  document.addEventListener('visibilitychange', () => {
    if (audioCtx && typeof audioCtx.suspend === 'function') {
      if (document.hidden) audioCtx.suspend().catch(() => {});
      else audioCtx.resume().catch(() => {});
    }
  });

  // Final safety: catch uncaught errors
  window.addEventListener('error', (ev) => {
    console.error('Unhandled error in Drone Math Adventure:', ev.error || ev.message);
    announce('An unexpected error occurred. Try refreshing the page.');
  });
})();
---

