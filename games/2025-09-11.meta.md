# Game of the Day - 2025-09-11

## Metadata
- **Generated Date:** 2025-09-11
- **Generated Time:** 2025-09-11T00:27:07.466890
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-11.js
- **File Size:** 27210 bytes
- **Tokens Used:** 8835

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-11.js` - The playable game
- `2025-09-11.meta.json` - Machine-readable metadata
- `2025-09-11.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 17858

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 19387

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // MACHINE MATH - JavaScript Game
  // Ages 7-9. Theme: Machines. All graphics drawn on canvas. Sounds via Web Audio API.
  // Render inside element with ID 'game-of-the-day-stage'.
  // Accessible: keyboard controls, screen-reader live region, visual audio indicator.
  // Author: Expert educational game designer (assistant).
  'use strict';

  /* -------------------------
     Basic setup and utilities
     ------------------------- */
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Game container element with ID "game-of-the-day-stage" not found.');
    return;
  }

  // Clear container and prepare DOM elements
  container.innerHTML = '';
  container.style.position = 'relative';
  container.style.width = '720px';
  container.style.height = '480px';
  container.setAttribute('aria-label', 'Machine Math Game. A number puzzle game for children.');
  container.setAttribute('role', 'application');

  // Visually hidden live region for screen readers (kept inside container for accessibility)
  const liveRegion = document.createElement('div');
  liveRegion.setAttribute('aria-live', 'polite');
  liveRegion.style.position = 'absolute';
  liveRegion.style.left = '-9999px';
  liveRegion.style.width = '1px';
  liveRegion.style.height = '1px';
  liveRegion.style.overflow = 'hidden';
  liveRegion.style.whiteSpace = 'nowrap';
  container.appendChild(liveRegion);

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = 720;
  canvas.height = 480;
  canvas.style.width = '720px';
  canvas.style.height = '480px';
  canvas.style.outline = 'none';
  canvas.setAttribute('role', 'img');
  canvas.setAttribute('aria-label', 'Machine Math game area. Use keyboard or mouse to play.');
  canvas.tabIndex = 0; // make focusable for keyboard
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Utility helpers
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
  const copy = obj => JSON.parse(JSON.stringify(obj));

  /* -------------------------
     Audio manager using Web Audio API
     ------------------------- */
  class AudioManager {
    constructor() {
      this.enabled = false;
      this.context = null;
      this.bgNodes = null;
      this.gainMaster = null;
      this.muted = false;
      this.initAttempted = false;
    }

    async init() {
      // Create audio context on first user gesture ideally.
      if (this.initAttempted) return;
      this.initAttempted = true;
      try {
        // Some browsers require resume; prefer constructing only when allowed.
        this.context = new (window.AudioContext || window.webkitAudioContext)();
        // Master gain
        this.gainMaster = this.context.createGain();
        this.gainMaster.gain.value = 0.6;
        this.gainMaster.connect(this.context.destination);
        // Start gentle background hum
        this.startBackground();
        this.enabled = true;
      } catch (e) {
        console.warn('AudioContext could not be created:', e);
        this.enabled = false;
        this.context = null;
      }
    }

    // play a short tone (frequency, duration, type)
    _playTone(freq = 440, duration = 0.2, type = 'sine', when = 0, options = {}) {
      if (!this.context || this.muted) return;
      try {
        const osc = this.context.createOscillator();
        const gain = this.context.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.context.currentTime + when);
        gain.gain.setValueAtTime(0.0001, this.context.currentTime + when);
        gain.gain.exponentialRampToValueAtTime(0.12, this.context.currentTime + when + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, this.context.currentTime + when + duration);
        // filter for color
        const filter = this.context.createBiquadFilter();
        filter.type = options.filterType || 'lowpass';
        filter.frequency.value = options.filterFreq || 1200;
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.gainMaster);
        osc.start(this.context.currentTime + when);
        osc.stop(this.context.currentTime + when + duration + 0.02);
      } catch (e) {
        console.warn('Error playing tone:', e);
      }
    }

    playClick() {
      if (!this.context) return;
      this._playTone(800, 0.06, 'square', 0, { filterFreq: 2000 });
    }

    playError() {
      if (!this.context) return;
      // descending minor chord-ish effect
      this._playTone(220, 0.16, 'sawtooth', 0, { filterFreq: 800 });
      this._playTone(180, 0.16, 'sawtooth', 0.06, { filterFreq: 800 });
    }

    playSuccess() {
      if (!this.context) return;
      this._playTone(880, 0.12, 'sine', 0, { filterFreq: 4000 });
      this._playTone(1320, 0.14, 'sine', 0.08, { filterFreq: 6000 });
    }

    startBackground() {
      if (!this.context) return;
      try {
        if (this.bgNodes) return;
        const osc = this.context.createOscillator();
        const gain = this.context.createGain();
        const filter = this.context.createBiquadFilter();
        osc.type = 'sine';
        osc.frequency.value = 55 + Math.random() * 10;
        filter.type = 'lowpass';
        filter.frequency.value = 300;
        gain.gain.value = 0.02;
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.gainMaster);
        osc.start();
        this.bgNodes = { osc, gain, filter };
      } catch (e) {
        console.warn('Background audio failed:', e);
      }
    }

    stopBackground() {
      if (!this.bgNodes) return;
      try {
        this.bgNodes.osc.stop();
        this.bgNodes.osc.disconnect();
        this.bgNodes.gain.disconnect();
        this.bgNodes.filter.disconnect();
      } catch (e) {
        console.warn('Stopping bg failed:', e);
      }
      this.bgNodes = null;
    }

    toggleMute() {
      this.muted = !this.muted;
      // if muted, set master gain to near zero; else normal
      if (this.gainMaster) {
        this.gainMaster.gain.value = this.muted ? 0.0001 : 0.6;
      }
      return this.muted;
    }

    // Attempt to resume context (useful when created by gesture)
    async resumeIfNeeded() {
      if (!this.context) return;
      try {
        if (this.context.state === 'suspended' && typeof this.context.resume === 'function') {
          await this.context.resume();
        }
      } catch (e) {
        console.warn('Audio resume failed:', e);
      }
    }
  }

  const audio = new AudioManager();

  /* -------------------------
     Game logic and generation
     ------------------------- */

  // Available operation types for children 7-9: add, subtract, times2, times3, minus2 etc.
  const OP_TYPES = [
    { type: 'add', value: 1, label: '+1' },
    { type: 'add', value: 2, label: '+2' },
    { type: 'add', value: 3, label: '+3' },
    { type: 'add', value: 4, label: '+4' },
    { type: 'sub', value: 1, label: '-1' },
    { type: 'sub', value: 2, label: '-2' },
    { type: 'sub', value: 3, label: '-3' },
    { type: 'mul', value: 2, label: '×2' },
    { type: 'mul', value: 3, label: '×3' }
  ];

  // Apply operation to a number (returns integer).
  function applyOp(num, op) {
    let result = num;
    switch (op.type) {
      case 'add':
        result = num + op.value;
        break;
      case 'sub':
        result = num - op.value;
        break;
      case 'mul':
        result = num * op.value;
        break;
    }
    // Keep numbers within a friendly range for children
    result = clamp(Math.round(result), -50, 200);
    return result;
  }

  // Compose a random solvable puzzle: pick an input, pick a random sequence of ops, generate target.
  // Then generate a pool of components includes the sequence (in random order) plus distractors.
  function generatePuzzle(level) {
    const seqLen = clamp(2 + Math.floor(level / 2), 2, 5); // easier at low levels
    // choose start number 1..10 for younger kids
    const start = randInt(1, 10);
    let cur = start;
    const seq = [];
    // Choose operations ensuring intermediate stays reasonable
    for (let i = 0; i < seqLen; i++) {
      const candidate = OP_TYPES[randInt(0, OP_TYPES.length - 1)];
      // Avoid sequences that produce too large numbers by favoring add/sub
      let chosen = candidate;
      // Slight bias: at higher level more multipliers allowed
      if (Math.random() < 0.1 + level * 0.05) {
        chosen = OP_TYPES[randInt(0, OP_TYPES.length - 1)];
      }
      seq.push(chosen);
      cur = applyOp(cur, chosen);
    }
    const target = cur;
    // Build pool: include the needed ops (but may include duplicates)
    const pool = [];
    // Add the necessary operations as distinct objects
    seq.forEach(op => pool.push(copy(op)));
    // Add distractors
    while (pool.length < Math.min(6, seqLen + 3)) {
      const p = copy(OP_TYPES[randInt(0, OP_TYPES.length - 1)]);
      // Don't add identical amount of all required ops more than twice
      pool.push(p);
    }
    // Shuffle pool
    for (let i = pool.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [pool[i], pool[j]] = [pool[j], pool[i]];
    }

    return {
      start,
      target,
      sequence: seq,
      pool
    };
  }

  /* -------------------------
     Game State
     ------------------------- */
  const Game = {
    level: 1,
    maxLevel: 5,
    puzzle: null,
    current: 0,
    moves: [],
    selectedIndex: 0,
    status: 'playing', // 'playing','won','levelComplete'
    attempts: 0,
    hintsUsed: 0,
    audioEnabled: false,
    // UI animation helpers
    lastActionTime: 0,
    // for gentle machine animation
    time: 0
  };

  // Initialize a new level
  function startLevel(level) {
    Game.level = level;
    Game.puzzle = generatePuzzle(level);
    Game.current = Game.puzzle.start;
    Game.moves = [];
    Game.selectedIndex = 0;
    Game.status = 'playing';
    Game.attempts = 0;
    Game.hintsUsed = 0;
    updateLive(`Level ${level}. Start number ${Game.current}. Target ${Game.puzzle.target}. Use operations to reach the target.`);
    // Ensure audio is available by prompting on first play when possible
    // Do not auto-init audio; wait for user gesture (keypress/click)
    requestRender();
  }

  // Apply an operation from pool (index)
  function applyFromPool(index) {
    if (!Game.puzzle || Game.status !== 'playing') return;
    if (index < 0 || index >= Game.puzzle.pool.length) return;
    const op = Game.puzzle.pool[index];
    Game.current = applyOp(Game.current, op);
    Game.moves.push(op);
    Game.attempts++;
    Game.lastActionTime = performance.now();
    audio.playClick();
    // Check win condition: if number equals target AND length of moves >= sequence length
    if (Game.current === Game.puzzle.target && Game.moves.length >= Game.puzzle.sequence.length) {
      // Level complete
      Game.status = 'levelComplete';
      audio.playSuccess();
      updateLive(`Great! You made ${Game.current}. Level ${Game.level} complete.`);
      // Proceed to next level after short delay
      setTimeout(() => {
        if (Game.level < Game.maxLevel) {
          startLevel(Game.level + 1);
        } else {
          Game.status = 'won';
          updateLive('You repaired the big machine! You finished all levels.');
        }
      }, 1200);
    } else {
      // If too many moves, check if player is stuck and provide gentle feedback
      if (Game.moves.length > Game.puzzle.sequence.length + 2) {
        audio.playError();
        updateLive('Try a different sequence. You can undo with Backspace or U.');
      }
    }
  }

  // Undo last move
  function undoMove() {
    if (Game.moves.length === 0) return;
    // Recompute from start by removing last move and replaying
    Game.moves.pop();
    let cur = Game.puzzle.start;
    for (const m of Game.moves) cur = applyOp(cur, m);
    Game.current = cur;
    audio.playClick();
    updateLive(`Undid last move. Current value ${Game.current}.`);
  }

  // Provide hint: apply the next correct operation from sequence (but limited)
  function hint() {
    if (!Game.puzzle || Game.status !== 'playing') return;
    if (Game.hintsUsed >= 2) {
      updateLive('No more hints available for this level.');
      return;
    }
    // Determine next needed op from sequence at index moves.length
    const nextIndex = Game.moves.length;
    if (nextIndex >= Game.puzzle.sequence.length) {
      updateLive('You are at or beyond the sequence length. Try different steps or undo.');
      return;
    }
    const needed = Game.puzzle.sequence[nextIndex];
    // Try to find a matching op in pool and apply
    const poolIndex = Game.puzzle.pool.findIndex(p => p.type === needed.type && p.value === needed.value);
    if (poolIndex >= 0) {
      Game.hintsUsed++;
      // apply
      applyFromPool(poolIndex);
      updateLive(`Hint used. Applied ${needed.label}.`);
    } else {
      // If not directly available, just reveal label
      Game.hintsUsed++;
      updateLive(`Hint: You need ${needed.label} next.`);
    }
  }

  // Restart current level
  function restartLevel() {
    startLevel(Game.level);
    audio.playClick();
  }

  function updateLive(msg) {
    liveRegion.textContent = msg;
  }

  /* -------------------------
     Drawing / Rendering
     ------------------------- */

  // Colors and theme
  const theme = {
    background1: '#eaf6ff',
    background2: '#fff7ea',
    machine: '#cfd8dc',
    accent: '#ff7f50',
    calm: '#6ca0dc',
    dark: '#333',
    panel: '#f4f7f9',
    button: '#ffd36a',
    selected: '#ffb86b',
    error: '#ff6b6b',
    success: '#7bd389'
  };

  // Draw helper functions
  function roundedRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  // Draw gear (simple stylized)
  function drawGear(ctx, cx, cy, radius, teeth, angle, color) {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(angle);
    ctx.fillStyle = color;
    ctx.beginPath();
    for (let i = 0; i < teeth; i++) {
      const a1 = (i / teeth) * Math.PI * 2;
      const a2 = ((i + 0.5) / teeth) * Math.PI * 2;
      const a3 = ((i + 1) / teeth) * Math.PI * 2;
      ctx.arc(0, 0, radius * 0.75, a1, a2);
      ctx.lineTo(Math.cos(a2) * radius, Math.sin(a2) * radius);
      ctx.arc(0, 0, radius, a2, a3);
      ctx.lineTo(Math.cos(a3) * radius * 0.75, Math.sin(a3) * radius * 0.75);
    }
    ctx.closePath();
    ctx.fill();
    // center hole
    ctx.fillStyle = '#222';
    ctx.beginPath();
    ctx.arc(0, 0, radius * 0.22, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  // Primary render function
  let rafId = null;
  function render() {
    Game.time += 0.016;
    // Background
    const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
    g.addColorStop(0, theme.background1);
    g.addColorStop(1, theme.background2);
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Wacky clouds / circuits
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    for (let i = 0; i < 4; i++) {
      const x = 80 + i * 150;
      const y = 40 + Math.sin(Game.time + i) * 8;
      ctx.beginPath();
      ctx.ellipse(x, y, 60, 20, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    // Big machine body
    ctx.fillStyle = theme.panel;
    roundedRect(ctx, 60, 90, 600, 330, 18);
    ctx.strokeStyle = '#c8d7de';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Gears on left
    drawGear(ctx, 140, 230, 40, 10, Game.time * 1.2, '#a7d0ff');
    drawGear(ctx, 200, 275, 28, 8, -Game.time * 1.6, '#ffd6a5');
    drawGear(ctx, 240, 210, 18, 6, Game.time * 2.2, '#d0f0c0');

    // Pipes to display numbers
    ctx.fillStyle = '#e6eef8';
    roundedRect(ctx, 120, 110, 480, 60, 12);
    ctx.fillStyle = '#fff';
    roundedRect(ctx, 130, 120, 460, 40, 10);
    // labels
    ctx.fillStyle = theme.dark;
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Machine Input → Current Value → Target', 140, 100);

    // Draw input, current, target panels
    function drawNumberBox(x, y, w, h, label, value, highlight) {
      // box
      ctx.fillStyle = theme.button;
      ctx.strokeStyle = '#d2a34a';
      roundedRect(ctx, x, y, w, h, 10);
      ctx.lineWidth = 2;
      ctx.stroke();
      // label
      ctx.fillStyle = '#2f2f2f';
      ctx.font = '14px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(label, x + w / 2, y + 18);
      // value
      ctx.fillStyle = highlight ? theme.success : '#222';
      ctx.font = '28px Arial';
      ctx.fillText(String(value), x + w / 2, y + 42);
      // small wobble for highlight
      if (highlight) {
        ctx.strokeStyle = 'rgba(0,0,0,0.05)';
        ctx.lineWidth = 1;
        roundedRect(ctx, x - 2, y - 2, w + 4, h + 4, 12);
      }
    }

    drawNumberBox(150, 130, 120, 60, 'Input', Game.puzzle ? Game.puzzle.start : '-', false);
    drawNumberBox(300, 130, 150, 60, 'Current', Game.current, Game.current === (Game.puzzle ? Game.puzzle.target : null));
    drawNumberBox(480, 130, 120, 60, 'Target', Game.puzzle ? Game.puzzle.target : '-', true);

    // Draw operation tiles as levers/buttons on machine
    const tileX = 130;
    const tileY = 220;
    const tileW = 100;
    const tileH = 60;
    ctx.font = '20px Arial';
    ctx.textAlign = 'center';

    if (Game.puzzle) {
      for (let i = 0; i < Game.puzzle.pool.length; i++) {
        const col = i % 3;
        const row = Math.floor(i / 3);
        const x = tileX + col * (tileW + 20);
        const y = tileY + row * (tileH + 16);
        const isSelected = i === Game.selectedIndex;
        // tile shadow
        ctx.fillStyle = 'rgba(0,0,0,0.06)';
        roundedRect(ctx, x + 4, y + 6, tileW, tileH, 8);
        // tile
        ctx.fillStyle = isSelected ? theme.selected : theme.panel;
        ctx.strokeStyle = isSelected ? theme.accent : '#cfd8dc';
        ctx.lineWidth = 2;
        roundedRect(ctx, x, y, tileW, tileH, 8);
        // op label
        ctx.fillStyle = '#222';
        ctx.fillText(Game.puzzle.pool[i].label, x + tileW / 2, y + 38);
        // small icon: little lever
        ctx.fillStyle = '#9aa9b3';
        ctx.fillRect(x + 8, y + 8, 18, 6);
        ctx.beginPath();
        ctx.arc(x + 17, y + 20, 8, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Small instruction panel
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    roundedRect(ctx, 430, 210, 210, 120, 10);
    ctx.fillStyle = '#333';
    ctx.font = '14px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Controls:', 440, 232);
    ctx.font = '12px Arial';
    ctx.fillText('←/→ : Move selection', 440, 252);
    ctx.fillText('Enter : Apply operation', 440, 268);
    ctx.fillText('U / Backspace : Undo', 440, 284);
    ctx.fillText('H : Hint (2 max)', 440, 300);
    ctx.fillText('Space : Toggle sound', 440, 316);

    // Status / feedback
    ctx.fillStyle = '#222';
    ctx.font = '14px Arial';
    ctx.textAlign = 'left';
    const statusMsg = Game.status === 'won' ? 'You finished all levels! Press R to play again.' :
      Game.status === 'levelComplete' ? `Level ${Game.level} complete!` :
        `Level ${Game.level}. Moves: ${Game.moves.length}. Attempts: ${Game.attempts}.`;
    ctx.fillText(statusMsg, 70, 370);

    // Draw small audio icon showing state
    const audioOn = audio.enabled && !audio.muted;
    ctx.save();
    ctx.translate(660, 20);
    ctx.fillStyle = audioOn ? theme.success : '#aaa';
    ctx.beginPath();
    ctx.moveTo(0, 6);
    ctx.lineTo(6, 6);
    ctx.lineTo(12, 0);
    ctx.lineTo(12, 24);
    ctx.lineTo(6, 18);
    ctx.lineTo(0, 18);
    ctx.closePath();
    ctx.fill();
    if (!audioOn) {
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(2, 2);
      ctx.lineTo(20, 20);
      ctx.stroke();
    }
    ctx.restore();

    // If game finished
    if (Game.status === 'won') {
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 36px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('You fixed the Mega Machine!', canvas.width / 2, canvas.height / 2 - 10);
      ctx.font = '20px Arial';
      ctx.fillText('Press R to play again.', canvas.width / 2, canvas.height / 2 + 30);
    }

    // tiny animation: pipes glowing when last action occurred
    if (Game.lastActionTime && performance.now() - Game.lastActionTime < 600) {
      const t = (performance.now() - Game.lastActionTime) / 600;
      ctx.strokeStyle = `rgba(255,150,80,${1 - t})`;
      ctx.lineWidth = 6 * (1 - t);
      ctx.beginPath();
      ctx.moveTo(260, 160);
      ctx.lineTo(430, 160);
      ctx.stroke();
    }

    rafId = requestAnimationFrame(render);
  }

  function requestRender() {
    if (!rafId) rafId = requestAnimationFrame(render);
  }

  /* -------------------------
     Input handling (keyboard & mouse)
     ------------------------- */

  // Map keyboard commands
  function handleKey(e) {
    // Ensure audio context created on first user gesture
    audio.init().then(() => audio.resumeIfNeeded()).catch(() => { /* ignore */ });

    // Ignore when no puzzle loaded
    if (!Game.puzzle) return;
    const key = e.key.toLowerCase();
    if (key === 'arrowleft') {
      Game.selectedIndex = (Game.selectedIndex - 1 + Game.puzzle.pool.length) % Game.puzzle.pool.length;
      audio.playClick();
      e.preventDefault();
      updateLive(`Selected ${Game.puzzle.pool[Game.selectedIndex].label}.`);
    } else if (key === 'arrowright') {
      Game.selectedIndex = (Game.selectedIndex + 1) % Game.puzzle.pool.length;
      audio.playClick();
      e.preventDefault();
      updateLive(`Selected ${Game.puzzle.pool[Game.selectedIndex].label}.`);
    } else if (key === 'enter') {
      applyFromPool(Game.selectedIndex);
      e.preventDefault();
    } else if (key === 'backspace' || key === 'u') {
      undoMove();
      e.preventDefault();
    } else if (key === 'h') {
      hint();
      e.preventDefault();
    } else if (key === ' ') {
      // toggle audio
      audio.init().then(() => {
        const muted = audio.toggleMute();
        updateLive(muted ? 'Audio muted.' : 'Audio unmuted.');
      }).catch(() => {
        // If audio init failed, provide message
        updateLive('Audio not available on this device.');
      });
      e.preventDefault();
    } else if (key === 'r') {
      // restart or replay from win
      if (Game.status === 'won') {
        startLevel(1);
      } else {
        restartLevel();
      }
      e.preventDefault();
    }
  }

  // Mouse/touch interactions
  function handleClick(e) {
    audio.init().then(() => audio.resumeIfNeeded()).catch(() => { /* ignore */ });
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    // If clicked inside any tile
    if (Game.puzzle) {
      const tileX = 130;
      const tileY = 220;
      const tileW = 100;
      const tileH = 60;
      for (let i = 0; i < Game.puzzle.pool.length; i++) {
        const col = i % 3;
        const row = Math.floor(i / 3);
        const x = tileX + col * (tileW + 20);
        const y = tileY + row * (tileH + 16);
        if (mx >= x && mx <= x + tileW && my >= y && my <= y + tileH) {
          Game.selectedIndex = i;
          applyFromPool(i);
          return;
        }
      }
      // audio toggle area
      if (mx >= 660 && mx <= 700 && my >= 2 && my <= 38) {
        audio.init().then(() => {
          const muted = audio.toggleMute();
          updateLive(muted ? 'Audio muted.' : 'Audio unmuted.');
        }).catch(() => updateLive('Audio not available.'));
      }
    }
  }

  canvas.addEventListener('keydown', handleKey);
  canvas.addEventListener('click', handleClick);
  // also allow container click to focus canvas for keyboard
  container.addEventListener('click', () => {
    canvas.focus();
  });

  // Provide on-screen buttons accessibility via keyboard focusable hints
  canvas.addEventListener('focus', () => {
    updateLive('Canvas focused. Use arrow keys to select an operation, Enter to apply.');
  });

  // Touch events map to click
  canvas.addEventListener('touchstart', function (e) {
    if (e.touches && e.touches.length > 0) {
      const t = e.touches[0];
      handleClick({ clientX: t.clientX, clientY: t.clientY, preventDefault: () => { } });
      e.preventDefault();
    }
  }, { passive: false });

  /* -------------------------
     Initialization and error handling
     ------------------------- */

  // Ensure Web Audio context created only after gesture; provide a big friendly start button overlay prompting
  function showStartOverlay() {
    // Draw an overlay on canvas instructing to press any key or click to start
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = theme.background1;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#222';
    ctx.font = 'bold 28px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Machine Math!', canvas.width / 2, 140);
    ctx.font = '18px Arial';
    ctx.fillText('Help the wacky machine reach a target number by choosing operations.', canvas.width / 2, 180);
    ctx.font = '16px Arial';
    ctx.fillText('Click or press any key to begin. Use the keyboard or tap the tiles.', canvas.width / 2, 220);

    ctx.fillStyle = theme.calm;
    roundedRect(ctx, canvas.width / 2 - 80, 260, 160, 50, 10);
    ctx.fillStyle = '#fff';
    ctx.fillText('Start Game', canvas.width / 2, 293);

    // Listener to initialize on first user gesture
    function beginOnce(e) {
      // initialize audio now
      audio.init().then(() => audio.resumeIfNeeded()).catch(() => {
        updateLive('Audio could not start. The game will still work without sound.');
      });
      // start first level
      startLevel(1);
      // remove this listener
      window.removeEventListener('keydown', beginOnce);
      canvas.removeEventListener('click', beginOnce);
    }
    window.addEventListener('keydown', beginOnce);
    canvas.addEventListener('click', beginOnce);
  }

  // Kick off
  showStartOverlay();

  // Ensure clean up on unload
  window.addEventListener('unload', () => {
    if (rafId) cancelAnimationFrame(rafId);
    if (audio && audio.context) {
      try {
        audio.stopBackground();
        if (audio.context.close) audio.context.close();
      } catch (e) { /* ignore */ }
    }
  });

  // Expose some helpful instructions for screen reader users via live region
  updateLive('Welcome to Machine Math. Press any key or click to start. After starting, use arrow keys and Enter or tap tiles to play. Press Space to toggle sound.');

  // Ensure initial render so canvas is not blank
  requestRender();

  // Safety: set a periodic animation if render loop didn't start
  setTimeout(() => { if (!rafId) requestRender(); }, 500);

})();
---

