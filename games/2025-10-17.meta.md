# Game of the Day - 2025-10-17

## Metadata
- **Generated Date:** 2025-10-17
- **Generated Time:** 2025-10-17T00:27:24.871060
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-10-17.js
- **File Size:** 25571 bytes
- **Tokens Used:** 8686

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-10-17.js` - The playable game
- `2025-10-17.meta.json` - Machine-readable metadata
- `2025-10-17.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 19271

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 22219

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Drone Math Delivery — Canvas Game
// Designed for children ages 7-9. Render into element with ID "game-of-the-day-stage"
// IMPORTANT: This file is standalone JavaScript. It creates a canvas inside the given container.

(() => {
  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const PADDING = 10; // minimum padding between UI elements
  const TARGET_CORRECT = 10; // win condition: collect this many correct parcels
  const MAX_LIVES = 3; // lose condition: this many wrong collections ends the game
  const PARCEL_SPAWN_INTERVAL = 1000; // ms between parcel spawns (changes with difficulty)
  const PARCEL_SPEED_MIN = 0.6;
  const PARCEL_SPEED_MAX = 1.6;

  // Get container and create canvas
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Container element with id "game-of-the-day-stage" not found.');
    return;
  }
  container.style.position = 'relative';
  container.style.width = `${WIDTH}px`;
  container.style.height = `${HEIGHT}px`;
  container.tabIndex = 0; // make focusable for keyboard events

  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.display = 'block';
  canvas.style.outline = 'none';
  container.appendChild(canvas);

  const ctx = canvas.getContext('2d');

  // Fonts and sizes
  const BODY_FONT = '16px sans-serif';
  const IMPORTANT_FONT = '20px sans-serif';
  const TITLE_FONT = '28px sans-serif';
  const SMALL_FONT = '14px sans-serif'; // for small labels; ensure it's readable per requirements

  // Game state
  let state = 'menu'; // 'menu' | 'playing' | 'win' | 'gameover'
  let score = 0;
  let lives = MAX_LIVES;
  let targetQuestion = null; // {a,b,op,answer}
  let parcels = []; // falling items
  let lastSpawn = 0;
  let spawnInterval = PARCEL_SPAWN_INTERVAL;
  let keys = {};
  let lastTime = performance.now();
  let drone = {
    x: WIDTH / 2,
    y: HEIGHT - 70,
    width: 80,
    height: 36,
    speed: 240 // pixels per second
  };
  let audioEnabled = true;
  let audioContext = null;
  let backgroundNode = null;
  let masterGain = null;

  // Accessibility: show if audio available
  let audioAvailable = false;

  // Error handling wrapper for audio creation
  function createAudioContextSafely() {
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) throw new Error('Web Audio API not supported.');
      const ctx = new AC();
      audioAvailable = true;
      return ctx;
    } catch (err) {
      console.warn('AudioContext creation failed:', err);
      audioAvailable = false;
      return null;
    }
  }

  // Initialize Audio
  function initAudio() {
    if (audioContext) return;
    audioContext = createAudioContextSafely();
    if (!audioContext) return;
    try {
      masterGain = audioContext.createGain();
      masterGain.gain.value = 0.12; // gentle volume
      masterGain.connect(audioContext.destination);

      // background gentle hum: low frequency sawtooth with slow LFO filter
      const osc = audioContext.createOscillator();
      osc.type = 'sine';
      osc.frequency.value = 120;
      const bgGain = audioContext.createGain();
      bgGain.gain.value = 0.03;

      // gentle tremolo using a low-frequency oscillator controlling bgGain.gain
      const lfo = audioContext.createOscillator();
      lfo.type = 'sine';
      lfo.frequency.value = 0.15;
      const lfoGain = audioContext.createGain();
      lfoGain.gain.value = 0.02;
      lfo.connect(lfoGain);
      lfoGain.connect(bgGain.gain);

      osc.connect(bgGain);
      bgGain.connect(masterGain);

      osc.start();
      lfo.start();

      backgroundNode = { osc, bgGain, lfo, lfoGain };
    } catch (err) {
      console.warn('Error initializing audio nodes:', err);
      audioAvailable = false;
    }
  }

  // Play feedback sound: 'correct' or 'wrong' or 'pick'
  function playSound(type = 'pick') {
    if (!audioContext || !audioAvailable || !audioEnabled) return;
    try {
      const now = audioContext.currentTime;
      const o = audioContext.createOscillator();
      const g = audioContext.createGain();
      const filter = audioContext.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 1200;
      o.connect(filter);
      filter.connect(g);
      g.connect(masterGain);

      if (type === 'correct') {
        o.type = 'sine';
        o.frequency.setValueAtTime(880, now);
        o.frequency.exponentialRampToValueAtTime(440, now + 0.2);
        g.gain.setValueAtTime(0.12, now);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);
      } else if (type === 'wrong') {
        o.type = 'sawtooth';
        o.frequency.setValueAtTime(220, now);
        o.frequency.exponentialRampToValueAtTime(110, now + 0.25);
        g.gain.setValueAtTime(0.14, now);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);
      } else {
        // pick / hover
        o.type = 'triangle';
        o.frequency.setValueAtTime(660, now);
        g.gain.setValueAtTime(0.04, now);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);
      }
      o.start(now);
      o.stop(now + 1);
    } catch (err) {
      console.warn('Error creating sound:', err);
    }
  }

  // Utility: generate a simple addition or subtraction question suitable for ages 7-9
  function generateQuestion() {
    const op = Math.random() < 0.6 ? '+' : '-';
    let a, b, answer;
    if (op === '+') {
      a = Math.floor(Math.random() * 10) + 1; // 1-10
      b = Math.floor(Math.random() * 10) + 1;
      answer = a + b;
    } else {
      a = Math.floor(Math.random() * 15) + 1; // 1-15
      b = Math.floor(Math.random() * a) + 0; // ensure non-negative result
      answer = a - b;
    }
    return { a, b, op, answer };
  }

  // Parcel object creation
  function spawnParcel() {
    const q = targetQuestion;
    // Make numbers around typical ranges: include some equal to the answer
    // Probability that a spawned parcel equals the answer: ~35%
    const isCorrect = Math.random() < 0.35;
    let value;
    if (isCorrect) {
      value = q.answer;
    } else {
      // create plausible distractors: near answer or random within 0-20
      const offset = Math.floor(Math.random() * 7) - 3; // -3..3
      value = Math.max(0, q.answer + offset);
      if (value === q.answer) {
        value = (value + 2) % 21;
      }
    }
    const x = Math.random() * (WIDTH - 40) + 20;
    const speed = PARCEL_SPEED_MIN + Math.random() * (PARCEL_SPEED_MAX - PARCEL_SPEED_MIN);
    const color = pastelColor();
    const shape = Math.random() < 0.5 ? 'box' : 'circle';
    parcels.push({ x, y: -20, vy: 40 * speed, value, color, shape, r: 18 });
  }

  // Pastel color generator
  function pastelColor() {
    const hue = Math.floor(Math.random() * 360);
    const sat = 60 + Math.floor(Math.random() * 20);
    const light = 70 + Math.floor(Math.random() * 10);
    return `hsl(${hue}deg ${sat}% ${light}%)`;
  }

  // Draw helpers with measureText background rectangles ensuring no overlap
  function drawTextWithBackground(text, font, x, y, options = {}) {
    const padding = options.padding ?? 8;
    ctx.font = font;
    const metrics = ctx.measureText(text);
    const textWidth = metrics.width;
    const textHeight = parseInt(font) || 16;
    let rectX = x;
    let rectY = y - textHeight;
    // If center option, center rect
    if (options.center) rectX = x - textWidth / 2 - padding;
    if (options.right) rectX = x - textWidth - padding * 2;
    const rectW = textWidth + padding * 2;
    const rectH = textHeight + padding * 1.6;
    ctx.fillStyle = options.bgColor ?? 'rgba(255,255,255,0.75)';
    roundRect(ctx, rectX, rectY, rectW, rectH, 6, true, false);
    ctx.fillStyle = options.color ?? '#111';
    ctx.font = font;
    ctx.textBaseline = 'top';
    if (options.center) ctx.fillText(text, x - textWidth / 2, rectY + padding * 0.6);
    else if (options.right) ctx.fillText(text, rectX + padding, rectY + padding * 0.6);
    else ctx.fillText(text, rectX + padding, rectY + padding * 0.6);
    return { rectX, rectY, rectW, rectH };
  }

  // Rounded rectangle utility
  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    if (typeof stroke === 'undefined') stroke = true;
    if (typeof r === 'undefined') r = 5;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // Draw scene background with wacky clouds and calm colors
  function drawBackground(t) {
    // gentle gradient sky
    const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    grad.addColorStop(0, 'hsl(210deg 60% 95%)');
    grad.addColorStop(1, 'hsl(210deg 60% 85%)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // sun / light
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255, 245, 200, 0.6)';
    ctx.arc(620, 80, 45, 0, Math.PI * 2);
    ctx.fill();

    // wacky clouds
    for (let i = 0; i < 4; i++) {
      drawCloud(80 + i * 150 + ((t / 500) % 60), 60 + (i % 2) * 20, 1 + (i % 2) * 0.2, i);
    }

    // distant grid/hills like a landing zone
    ctx.fillStyle = 'hsl(120deg 40% 94%)';
    ctx.fillRect(0, HEIGHT - 110, WIDTH, 110);
    ctx.fillStyle = 'hsl(120deg 35% 86%)';
    ctx.fillRect(0, HEIGHT - 110, WIDTH, 14);
  }

  function drawCloud(cx, cy, scale = 1, odd = 0) {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.scale(scale, scale);
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,255,255,0.88)';
    ctx.strokeStyle = 'rgba(220,220,255,0.6)';
    ctx.lineWidth = 2;
    const wobble = Math.sin((cx + cy) / 60 + odd) * 4;
    ctx.ellipse(-10 + wobble, 0, 28, 18, 0, 0, Math.PI * 2);
    ctx.ellipse(10 + wobble, 0, 34, 22, 0, 0, Math.PI * 2);
    ctx.ellipse(28 + wobble, 0, 22, 14, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  // Draw drone
  function drawDrone(dt, t) {
    // drone body
    ctx.save();
    ctx.translate(drone.x, drone.y);
    // shadow
    ctx.beginPath();
    ctx.ellipse(0, drone.height / 2 + 20, 38, 12, 0, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.fill();

    ctx.fillStyle = 'hsl(210deg 70% 86%)';
    roundRect(ctx, -drone.width / 2, -drone.height / 2, drone.width, drone.height, 10, true, false);

    // propellers (wacky arms)
    ctx.fillStyle = 'hsl(200deg 60% 60%)';
    for (let i = -1; i <= 1; i += 2) {
      ctx.save();
      ctx.translate(i * (drone.width / 2 - 6), -drone.height / 2 - 8);
      ctx.beginPath();
      const spin = (t / 100) * (i > 0 ? 1 : -1);
      ctx.rotate(spin);
      ctx.fillRect(-20, -4, 40, 8);
      ctx.restore();
      // small rotor circle
      ctx.beginPath();
      ctx.arc(i * (drone.width / 2 - 6), -drone.height / 2 - 8, 6, 0, Math.PI * 2);
      ctx.fill();
    }

    // face
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.arc(-18, 0, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(6, 0, 10, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  // Draw parcels
  function drawParcels() {
    parcels.forEach(p => {
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.fillStyle = p.color;
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.lineWidth = 2;
      if (p.shape === 'circle') {
        ctx.beginPath();
        ctx.arc(0, 0, p.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
      } else {
        roundRect(ctx, -p.r, -p.r, p.r * 2, p.r * 2, 8, true, true);
      }
      // text value
      ctx.fillStyle = '#123';
      ctx.font = IMPORTANT_FONT;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(p.value), 0, 0);
      ctx.restore();
    });
  }

  // Collision detection between drone rect and parcel circle/box
  function checkCollision(p) {
    // drone bounding box
    const dx = Math.abs(p.x - drone.x);
    const dy = Math.abs(p.y - drone.y);
    const halfW = drone.width / 2;
    const halfH = drone.height / 2;
    // approximate: if parcel circle intersects rect
    const closestX = Math.max(drone.x - halfW, Math.min(p.x, drone.x + halfW));
    const closestY = Math.max(drone.y - halfH, Math.min(p.y, drone.y + halfH));
    const distX = p.x - closestX;
    const distY = p.y - closestY;
    return distX * distX + distY * distY < (p.r + 4) * (p.r + 4);
  }

  // Start new game
  function startGame() {
    score = 0;
    lives = MAX_LIVES;
    parcels = [];
    spawnInterval = PARCEL_SPAWN_INTERVAL;
    lastSpawn = 0;
    targetQuestion = generateQuestion();
    state = 'playing';
    lastTime = performance.now();
    // ensure audio context created on user interaction
    if (!audioContext && audioAvailable) {
      initAudio();
    }
  }

  // End game with win or lose
  function endGame(outcome) {
    state = outcome === 'win' ? 'win' : 'gameover';
    // stop background audio gentle hum if present
    if (backgroundNode && audioContext) {
      // reduce background gracefully
      try {
        backgroundNode.bgGain.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.8);
      } catch (err) {
        console.warn('Error fading background:', err);
      }
    }
  }

  // Restart game from end screens
  function restart() {
    // restart background if audio enabled
    if (audioAvailable && audioEnabled && audioContext == null) {
      initAudio();
    }
    startGame();
  }

  // Main update loop
  function update(now) {
    const dt = (now - lastTime) / 1000;
    lastTime = now;
    // update based on state
    if (state === 'playing') {
      // move drone with keyboard
      let move = 0;
      if (keys.ArrowLeft || keys.a || keys.A) move -= 1;
      if (keys.ArrowRight || keys.d || keys.D) move += 1;
      if (move !== 0) drone.x += move * drone.speed * dt;
      // clamp
      drone.x = Math.max(drone.width / 2 + 6, Math.min(WIDTH - drone.width / 2 - 6, drone.x));

      // spawn parcels
      lastSpawn += dt * 1000;
      if (lastSpawn > spawnInterval) {
        spawnParcel();
        lastSpawn = 0;
        // gradual difficulty increase
        if (spawnInterval > 500) spawnInterval -= 6;
      }

      // update parcels
      for (let i = parcels.length - 1; i >= 0; i--) {
        const p = parcels[i];
        p.y += p.vy * dt;
        // check collision
        if (checkCollision(p)) {
          // handle pick up
          const correct = p.value === targetQuestion.answer;
          if (correct) {
            score++;
            playSound('correct');
            // cheerful sparkle effect: quick visual flash (we can just add a short life in parcel)
            // update target every few corrects for variety
            if (score % 3 === 0) {
              targetQuestion = generateQuestion();
            }
            // win?
            if (score >= TARGET_CORRECT) {
              endGame('win');
            }
          } else {
            lives--;
            playSound('wrong');
            // slightly change the target question to avoid repetition
            if (Math.random() < 0.5) targetQuestion = generateQuestion();
            if (lives <= 0) {
              endGame('lose');
            }
          }
          parcels.splice(i, 1);
          continue;
        }
        // remove if off bottom
        if (p.y - p.r > HEIGHT) {
          parcels.splice(i, 1);
        }
      }
    }

    draw(now);
    if (state === 'playing' || state === 'menu') {
      requestAnimationFrame(update);
    } else {
      // draw end screen once; still listen for restart
      draw(now);
    }
  }

  // Drawing everything
  function draw(t) {
    // background
    drawBackground(t);

    // parcels
    drawParcels();

    // drone
    drawDrone(0, t);

    // UI: score top-left, lives top-right, target top-center, instructions bottom-center
    // Score
    ctx.save();
    ctx.strokeStyle = 'rgba(20,20,20,0.06)';
    drawTextWithBackground(`Score: ${score}`, IMPORTANT_FONT, PADDING, PADDING + 22, {
      bgColor: 'rgba(255,255,255,0.85)',
      color: '#0b3d91',
      padding: 12
    });
    ctx.restore();

    // Lives top-right
    ctx.save();
    const livesText = `Lives: ${lives}`;
    ctx.font = IMPORTANT_FONT;
    const metrics = ctx.measureText(livesText);
    const rightX = WIDTH - PADDING;
    drawTextWithBackground(livesText, IMPORTANT_FONT, rightX, PADDING + 22, {
      right: true,
      bgColor: 'rgba(255,255,255,0.85)',
      color: '#a11',
      padding: 12
    });
    ctx.restore();

    // Audio indicator near top-left below score
    ctx.save();
    const audioText = audioAvailable ? (audioEnabled ? 'Audio: On' : 'Audio: Off') : 'Audio: Unavailable';
    ctx.font = SMALL_FONT;
    drawTextWithBackground(audioText, SMALL_FONT, PADDING, PADDING + 64, {
      bgColor: 'rgba(255,255,255,0.8)',
      color: '#333',
      padding: 8
    });
    ctx.restore();

    // Target question top-center
    ctx.save();
    const qText = state === 'playing' ? `Deliver parcels that equal: ${targetQuestion.a} ${targetQuestion.op} ${targetQuestion.b} = ?` : '';
    if (qText) {
      ctx.font = TITLE_FONT;
      const centerX = WIDTH / 2;
      drawTextWithBackground(qText, TITLE_FONT, centerX, PADDING + 30, {
        center: true,
        bgColor: 'rgba(255,255,255,0.9)',
        color: '#053',
        padding: 12
      });
    }
    ctx.restore();

    // bottom-center instructions (non overlapping)
    ctx.save();
    ctx.font = BODY_FONT;
    const instrLines = [];
    if (state === 'menu') {
      instrLines.push('Welcome! Help the drone collect correct parcels.');
      instrLines.push('Use ← → or A/D to move. Click or press Enter to start (enables audio).');
    } else if (state === 'playing') {
      instrLines.push('Move the drone to collect parcels with the correct number.');
      instrLines.push(`Goal: Collect ${TARGET_CORRECT} correct parcels. Wrong parcels: lose a life. Lives: ${MAX_LIVES}`);
      instrLines.push('Controls: ← → (or A/D). Press M to toggle audio. Press R to restart anytime.');
    } else if (state === 'win') {
      instrLines.push('Victory! You delivered all parcels!');
      instrLines.push('Click Restart or press R to play again.');
    } else if (state === 'gameover') {
      instrLines.push('Game Over. The drone ran out of lives.');
      instrLines.push('Click Restart or press R to try again.');
    }
    // compute combined width of multi-line block using measureText longest line
    let maxWidth = 0;
    ctx.font = BODY_FONT;
    instrLines.forEach(line => {
      const w = ctx.measureText(line).width;
      if (w > maxWidth) maxWidth = w;
    });
    const blockW = maxWidth + 24;
    const lineHeight = 20;
    const blockH = instrLines.length * lineHeight + 18;
    const bx = WIDTH / 2 - blockW / 2;
    const by = HEIGHT - blockH - 14;
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    roundRect(ctx, bx, by, blockW, blockH, 8, true, false);
    ctx.fillStyle = '#112';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    let ty = by + 9;
    ctx.font = BODY_FONT;
    instrLines.forEach(line => {
      ctx.fillText(line, WIDTH / 2, ty);
      ty += lineHeight;
    });
    ctx.restore();

    // If menu screen, show big instructions and start button area
    if (state === 'menu') {
      ctx.save();
      const title = 'Drone Math Delivery';
      ctx.font = '34px sans-serif';
      const centerX = WIDTH / 2;
      const centerY = HEIGHT / 2 - 30;
      drawTextWithBackground(title, '34px sans-serif', centerX, centerY, {
        center: true,
        bgColor: 'rgba(255,255,255,0.92)',
        color: '#006',
        padding: 14
      });

      // start button
      const startText = 'Click or Press Enter to Start';
      ctx.font = IMPORTANT_FONT;
      const res = drawTextWithBackground(startText, IMPORTANT_FONT, centerX, centerY + 70, {
        center: true,
        bgColor: 'rgba(10,120,180,0.12)',
        color: '#005',
        padding: 14
      });
      // store start button area for pointer detection
      menuStartButtonRect = { x: res.rectX, y: res.rectY, w: res.rectW, h: res.rectH };
      ctx.restore();
    }

    // End screens
    if (state === 'win' || state === 'gameover') {
      ctx.save();
      ctx.globalAlpha = 0.96;
      // overlay dim
      ctx.fillStyle = 'rgba(10, 10, 20, 0.08)';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.globalAlpha = 1;

      const title = state === 'win' ? 'You Win!' : 'Game Over';
      const subtitle = state === 'win'
        ? `You collected ${score} correct parcels.`
        : `You collected ${score} correct parcels.`;

      ctx.font = '36px sans-serif';
      drawTextWithBackground(title, '36px sans-serif', WIDTH / 2, HEIGHT / 2 - 40, {
        center: true,
        bgColor: 'rgba(255,255,255,0.95)',
        color: state === 'win' ? '#0a7' : '#a00',
        padding: 16
      });
      ctx.font = IMPORTANT_FONT;
      drawTextWithBackground(subtitle, IMPORTANT_FONT, WIDTH / 2, HEIGHT / 2 + 10, {
        center: true,
        bgColor: 'rgba(255,255,255,0.95)',
        color: '#123',
        padding: 12
      });
      // restart button area
      ctx.font = IMPORTANT_FONT;
      const restartText = 'Restart (Click or press R)';
      const res = drawTextWithBackground(restartText, IMPORTANT_FONT, WIDTH / 2, HEIGHT / 2 + 70, {
        center: true,
        bgColor: 'rgba(255,255,255,0.95)',
        color: '#035',
        padding: 12
      });
      menuStartButtonRect = { x: res.rectX, y: res.rectY, w: res.rectW, h: res.rectH, isRestart: true };
      ctx.restore();
    }
  }

  // Pointer/click handling: to start or restart
  let menuStartButtonRect = null;
  canvas.addEventListener('pointerdown', e => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    // enable audio context upon user interaction
    if (!audioContext && audioAvailable) {
      try {
        initAudio();
        // resume context if suspended (necessary in some browsers)
        if (audioContext && audioContext.state === 'suspended') audioContext.resume();
      } catch (err) {
        console.warn('Error resuming audioContext on pointerdown:', err);
      }
    }
    if (state === 'menu') {
      // start if clicked on start button or anywhere
      if (!menuStartButtonRect || pointInRect(x, y, menuStartButtonRect)) {
        startGame();
      }
    } else if (state === 'playing') {
      // allow clicking to toggle audio indicator when clicking audio box near top-left
      // determine audio box rectangle by re-drawing measurement (approx)
      // for simplicity, check if click was within top-left PADDING area
      if (x < 180 && y < 110) {
        toggleAudio();
      }
    } else if (state === 'win' || state === 'gameover') {
      if (menuStartButtonRect && pointInRect(x, y, menuStartButtonRect)) {
        restart();
        requestAnimationFrame(update);
      }
    }
  });

  function pointInRect(x, y, r) {
    return x >= r.x && x <= r.x + r.w && y >= r.y && y <= r.y + r.h;
  }

  // Keyboard controls
  window.addEventListener('keydown', e => {
    if (!keys[e.key]) keys[e.key] = true;
    // start game with Enter from menu
    if (state === 'menu' && (e.key === 'Enter' || e.key === ' ')) {
      // initialize audio on keypress
      if (!audioContext && audioAvailable) {
        initAudio();
        if (audioContext && audioContext.state === 'suspended') audioContext.resume().catch(()=>{});
      }
      startGame();
      requestAnimationFrame(update);
    }
    // restart with R
    if ((state === 'gameover' || state === 'win') && (e.key === 'r' || e.key === 'R')) {
      restart();
      requestAnimationFrame(update);
    }
    // toggle audio with M
    if (e.key === 'm' || e.key === 'M') {
      toggleAudio();
    }
    // accessibility: space toggles audio on menu maybe
  });

  window.addEventListener('keyup', e => {
    keys[e.key] = false;
  });

  // Toggle audio on/off
  function toggleAudio() {
    if (!audioAvailable) return;
    audioEnabled = !audioEnabled;
    if (!audioEnabled && masterGain) {
      masterGain.gain.setValueAtTime(0.0001, audioContext.currentTime);
    } else if (audioEnabled && masterGain) {
      masterGain.gain.setValueAtTime(0.12, audioContext.currentTime);
    }
    playSound('pick');
  }

  // Start with menu drawing and instructions
  function init() {
    // Try to create audio context lazily but not required
    try {
      // Some browsers may restrict creation; we only test support here
      const AC = window.AudioContext || window.webkitAudioContext;
      if (AC) {
        audioAvailable = true;
      } else {
        audioAvailable = false;
      }
    } catch (err) {
      audioAvailable = false;
    }
    // initial question for menu display
    targetQuestion = generateQuestion();
    // focus container for keyboard events
    container.focus();
    lastTime = performance.now();
    // initial draw and update loop
    requestAnimationFrame(update);
  }

  // Kick off
  init();

  // Error resilience for audio context visibility change
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible' && audioContext && audioEnabled) {
      if (audioContext.state === 'suspended') {
        audioContext.resume().catch(err => console.warn('Resume audio failed:', err));
      }
    }
  });

})();
---

