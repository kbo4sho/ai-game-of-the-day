{
  "generated_date": "2025-10-05",
  "generated_timestamp": "2025-10-05T00:30:00.154171",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9138,
  "game_filename": "2025-10-05.js",
  "game_size_bytes": 26127,
  "functionality": {
    "score": 7,
    "max_score": 8,
    "percentage": 87.5,
    "passing": true,
    "issues": [],
    "warnings": [
      "No game state management found"
    ]
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(() => {\n  // MACHINE MATH GAME\n  // For ages 7-9. Renders inside element with ID 'game-of-the-day-stage'.\n  // Creates a 720x480 canvas and uses Web Audio API oscillators for sounds.\n  // Accessible via keyboard, includes audio on/off visual, clear instructions,\n  // and error handling for audio creation and resume.\n\n  // Utility helpers\n  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));\n  const randInt = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;\n\n  // Find container\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Game container with ID \"game-of-the-day-stage\" not found.');\n    return;\n  }\n  // Clear container\n  container.innerHTML = '';\n  container.style.position = 'relative';\n  container.style.userSelect = 'none';\n\n  // Create ARIA live region for screen readers (offscreen)\n  const liveRegion = document.createElement('div');\n  liveRegion.setAttribute('aria-live', 'polite');\n  liveRegion.setAttribute('role', 'status');\n  liveRegion.style.position = 'absolute';\n  liveRegion.style.left = '-9999px';\n  liveRegion.style.width = '1px';\n  liveRegion.style.height = '1px';\n  liveRegion.style.overflow = 'hidden';\n  container.appendChild(liveRegion);\n\n  // Create canvas exactly 720x480\n  const canvas = document.createElement('canvas');\n  canvas.width = 720;\n  canvas.height = 480;\n  canvas.tabIndex = 0; // make focusable for keyboard\n  canvas.style.outline = 'none';\n  canvas.style.display = 'block';\n  canvas.style.background = '#f3f8fb';\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext('2d', { alpha: false });\n\n  // Global settings\n  const GAME_WIDTH = 720;\n  const GAME_HEIGHT = 480;\n\n  // Colors and design\n  const palette = {\n    bg: '#eaf2f7',\n    machine: '#d2e9f8',\n    accent: '#6aa7d8',\n    accent2: '#f4b183',\n    tile: '#ffffff',\n    tileText: '#223',\n    gear: '#cfe8f6',\n    wrong: '#e27a7a',\n    correct: '#7ad28f',\n    text: '#123',\n    dim: '#8aa1b8',\n  };\n\n  // Audio manager with error handling\n  class AudioManager {\n    constructor() {\n      this.enabled = true;\n      this.supported = true;\n      this.ctx = null;\n      this.bgGain = null;\n      this.bgOsc = null;\n      this.masterGain = null;\n      this.initialized = false;\n      try {\n        const AudioContext = window.AudioContext || window.webkitAudioContext;\n        if (!AudioContext) throw new Error('Web Audio API not supported');\n        this.ctx = new AudioContext();\n        this.masterGain = this.ctx.createGain();\n        this.masterGain.gain.value = 0.9;\n        this.masterGain.connect(this.ctx.destination);\n\n        // background ambient oscillator (gentle)\n        this.bgOsc = this.ctx.createOscillator();\n        this.bgOsc.type = 'sine';\n        this.bgOsc.frequency.value = 110; // low hum\n        this.bgGain = this.ctx.createGain();\n        this.bgGain.gain.value = 0.02;\n        this.bgOsc.connect(this.bgGain);\n        this.bgGain.connect(this.masterGain);\n        this.bgOsc.start();\n\n        // We'll keep background muted until user toggles\n        this.bgPlaying = false;\n        this.initialized = true;\n      } catch (e) {\n        console.warn('Audio initialization failed:', e);\n        this.supported = false;\n        this.enabled = false;\n      }\n    }\n\n    async resumeIfNeeded() {\n      if (!this.initialized || !this.ctx) return;\n      if (this.ctx.state === 'suspended') {\n        try {\n          await this.ctx.resume();\n        } catch (e) {\n          console.warn('AudioContext resume failed', e);\n        }\n      }\n    }\n\n    toggleBackground(on) {\n      if (!this.supported) return;\n      this.bgPlaying = !!on;\n      if (this.bgGain) this.bgGain.gain.value = this.bgPlaying ? 0.02 : 0;\n      this.resumeIfNeeded().catch(() => {});\n    }\n\n    playTone(frequency = 660, duration = 0.2, type = 'sine', when = 0) {\n      if (!this.supported) return;\n      try {\n        const osc = this.ctx.createOscillator();\n        const gain = this.ctx.createGain();\n        osc.type = type;\n        osc.frequency.value = frequency;\n        gain.gain.value = 0.0001;\n        osc.connect(gain);\n        gain.connect(this.masterGain);\n        const t0 = this.ctx.currentTime + when;\n        gain.gain.setValueAtTime(0.0001, t0);\n        gain.gain.exponentialRampToValueAtTime(0.05, t0 + 0.01);\n        osc.start(t0);\n        gain.gain.exponentialRampToValueAtTime(0.0001, t0 + duration);\n        osc.stop(t0 + duration + 0.02);\n      } catch (e) {\n        console.warn('playTone error', e);\n      }\n    }\n\n    beepCorrect() {\n      // Pleasant arpeggio\n      if (!this.supported) return;\n      this.resumeIfNeeded().catch(() => {});\n      this.playTone(880, 0.12, 'sine', 0);\n      this.playTone(1100, 0.12, 'sine', 0.12);\n      this.playTone(1320, 0.18, 'sine', 0.24);\n    }\n\n    beepWrong() {\n      if (!this.supported) return;\n      this.resumeIfNeeded().catch(() => {});\n      this.playTone(220, 0.18, 'sawtooth', 0);\n      this.playTone(180, 0.12, 'sine', 0.12);\n    }\n  }\n\n  const audio = new AudioManager();\n\n  // Game logic\n  class MachineMathGame {\n    constructor(ctx, audio) {\n      this.ctx = ctx;\n      this.audio = audio;\n      this.round = 0;\n      this.maxRounds = 6;\n      this.state = 'intro'; // intro, playing, success, finished\n      this.tiles = Array.from({ length: 10 }, (_, i) => i); // 0-9\n      this.slotA = null;\n      this.slotB = null;\n      this.cursor = 0; // keyboard selection index among tiles\n      this.message = 'Press Enter or Click a number tile to feed the machine';\n      this.msgTimer = 0;\n      this.animTime = 0;\n      this.roundData = [];\n      this.failedAttempts = 0;\n      this.generateRounds();\n      this.onAction = null; // optional callback\n      this.focused = false;\n      this.audioOn = !!(this.audio && this.audio.supported && this.audio.bgPlaying);\n      this.audioAvailable = !!(this.audio && this.audio.supported);\n      this.initAccessibility();\n      this.announce('Welcome to Machine Math! Press Enter to begin.');\n    }\n\n    generateRounds() {\n      // Generate solvable rounds by picking two numbers and operation\n      // Beginner: addition first 3 rounds, then subtraction, then mixed.\n      this.roundData = [];\n      for (let i = 0; i < this.maxRounds; i++) {\n        let op = '+';\n        if (i < 3) op = '+';\n        else if (i < 5) op = '-';\n        else op = Math.random() < 0.5 ? '+' : '-';\n        // For subtraction, ensure non-negative\n        let a = randInt(0, 9);\n        let b = randInt(0, 9);\n        if (op === '-' && a < b) [a, b] = [b, a];\n        const target = op === '+' ? a + b : a - b;\n        this.roundData.push({ op, a, b, target });\n      }\n    }\n\n    initAccessibility() {\n      // Update live region with instructions\n      const instr = `Machine Math. Use Arrow keys to move selection. Press Enter to place a number. Press Backspace to clear a slot.\n        Press A to toggle audio. Press R to restart. Click the speaker in top-right to toggle audio.`;\n      liveRegion.textContent = instr;\n    }\n\n    start() {\n      this.state = 'playing';\n      this.round = 0;\n      this.slotA = null;\n      this.slotB = null;\n      this.cursor = 0;\n      this.failedAttempts = 0;\n      this.audioOn = !!(this.audio && this.audio.supported && this.audio.bgPlaying);\n      this.announce('Round 1. Solve the machine!');\n    }\n\n    currentRound() {\n      return this.roundData[this.round];\n    }\n\n    placeTile(index) {\n      const value = this.tiles[index];\n      if (this.slotA === null) {\n        this.slotA = { index, value };\n      } else if (this.slotB === null) {\n        // prevent placing same tile index twice? Allow since tiles are reusable\n        this.slotB = { index, value };\n      } else {\n        // both slots full: clicking cycles replace second\n        this.slotB = { index, value };\n      }\n      this.msg('Placed ' + value);\n      this.checkIfReady();\n    }\n\n    removeLastSlot() {\n      if (this.slotB !== null) {\n        this.msg('Removed ' + this.slotB.value);\n        this.slotB = null;\n      } else if (this.slotA !== null) {\n        this.msg('Removed ' + this.slotA.value);\n        this.slotA = null;\n      } else {\n        this.msg('No slots to clear');\n      }\n    }\n\n    clearSlots() {\n      this.slotA = null;\n      this.slotB = null;\n    }\n\n    msg(text) {\n      this.message = text;\n      this.msgTimer = 180; // show for some frames\n      liveRegion.textContent = text;\n    }\n\n    announce(text) {\n      // Use live region for announcements\n      liveRegion.textContent = text;\n    }\n\n    checkIfReady() {\n      if (this.slotA && this.slotB) {\n        // compute\n        const round = this.currentRound();\n        if (!round) return;\n        const computed = round.op === '+' ? (this.slotA.value + this.slotB.value) : (this.slotA.value - this.slotB.value);\n        const target = round.target;\n        if (computed === target) {\n          // success for this round\n          this.audio.beepCorrect();\n          this.msg('Correct! Machine accepted the input.');\n          this.celebrate(() => {\n            this.round++;\n            if (this.round >= this.maxRounds) {\n              this.state = 'finished';\n              this.announce('All rounds complete! Great job! Press R to play again.');\n            } else {\n              this.clearSlots();\n              this.state = 'playing';\n              this.msg(`Round ${this.round + 1}. Next machine ready.`);\n              this.announce(`Round ${this.round + 1}.`);\n            }\n            if (this.onAction) this.onAction();\n          });\n        } else {\n          // wrong\n          this.audio.beepWrong();\n          this.failedAttempts++;\n          this.msg('That did not match the target. Try again.');\n          this.shake();\n          // keep slots so child can see; but clear B to let try again\n          this.slotB = null;\n          if (this.failedAttempts >= 5) {\n            // give hint by revealing one of the numbers that will work\n            this.revealHint();\n            this.failedAttempts = 0;\n          }\n        }\n      }\n    }\n\n    revealHint() {\n      const round = this.currentRound();\n      if (!round) return;\n      // Reveal one of the original numbers by filling slotA with the correct a\n      this.slotA = { index: round.a, value: round.a };\n      this.slotB = null;\n      this.msg(`Hint: one slot filled with ${round.a}`);\n      this.announce('Hint provided.');\n    }\n\n    celebrate(done) {\n      this.state = 'celebrating';\n      // simple delay then callback\n      setTimeout(() => {\n        this.state = 'playing';\n        if (done) done();\n      }, 1000);\n    }\n\n    shake() {\n      this.animTime = 18;\n    }\n\n    toggleAudio() {\n      if (!this.audioAvailable) {\n        this.msg('Audio not available in this browser.');\n        return;\n      }\n      this.audioOn = !this.audioOn;\n      this.audio.toggleBackground(this.audioOn);\n      this.msg(this.audioOn ? 'Audio on' : 'Audio off');\n      this.announce(this.audioOn ? 'Audio enabled' : 'Audio disabled');\n    }\n\n    restart() {\n      this.generateRounds();\n      this.round = 0;\n      this.clearSlots();\n      this.state = 'playing';\n      this.msg('Game restarted. Good luck!');\n      this.announce('Game restarted.');\n    }\n\n    keyboardMove(dir) {\n      // dir: -1 left, 1 right\n      this.cursor = (this.cursor + dir + this.tiles.length) % this.tiles.length;\n    }\n\n    handleKey(e) {\n      if (this.state === 'intro' && (e.key === 'Enter' || e.key === ' ')) {\n        this.start();\n        return;\n      }\n      if (e.key === 'a' || e.key === 'A') {\n        // toggle audio; resume audio context if needed after gesture\n        if (this.audioAvailable) this.audio.resumeIfNeeded().catch(() => {});\n        this.toggleAudio();\n      } else if (e.key === 'r' || e.key === 'R') {\n        this.restart();\n      } else if (e.key === 'ArrowLeft') {\n        this.keyboardMove(-1);\n      } else if (e.key === 'ArrowRight') {\n        this.keyboardMove(1);\n      } else if (e.key === 'Enter') {\n        this.placeTile(this.cursor);\n      } else if (e.key === 'Backspace') {\n        this.removeLastSlot();\n      } else if (e.key === ' ') {\n        // space acts as place\n        this.placeTile(this.cursor);\n      }\n    }\n\n    handleMouseClick(x, y) {\n      // coordinates inside canvas\n      // Speaker icon in top-right toggle audio\n      if (x >= GAME_WIDTH - 46 && x <= GAME_WIDTH - 10 && y >= 10 && y <= 46) {\n        this.toggleAudio();\n        return;\n      }\n\n      // Tiles region bottom: determine which tile clicked\n      const tileY = GAME_HEIGHT - 120;\n      if (y >= tileY && y <= GAME_HEIGHT - 20) {\n        const tileCount = this.tiles.length;\n        const spacing = 60;\n        const startX = (GAME_WIDTH - (spacing * tileCount - 10)) / 2;\n        for (let i = 0; i < tileCount; i++) {\n          const cx = startX + i * spacing;\n          const cy = tileY + 40;\n          const r = 24;\n          if ((x - cx) ** 2 + (y - cy) ** 2 <= r * r) {\n            this.cursor = i;\n            this.placeTile(i);\n            return;\n          }\n        }\n      }\n\n      // clicking on slots to remove\n      const slotABox = { x: 180, y: 170, w: 90, h: 90 };\n      const slotBBox = { x: 360, y: 170, w: 90, h: 90 };\n      if (x >= slotABox.x && x <= slotABox.x + slotABox.w && y >= slotABox.y && y <= slotABox.y + slotABox.h) {\n        if (this.slotA) {\n          this.msg(`Removed ${this.slotA.value}`);\n          this.slotA = null;\n          return;\n        }\n      }\n      if (x >= slotBBox.x && x <= slotBBox.x + slotBBox.w && y >= slotBBox.y && y <= slotBBox.y + slotBBox.h) {\n        if (this.slotB) {\n          this.msg(`Removed ${this.slotB.value}`);\n          this.slotB = null;\n          return;\n        }\n      }\n    }\n\n    update() {\n      if (this.msgTimer > 0) this.msgTimer--;\n      if (this.animTime > 0) this.animTime--;\n    }\n\n    draw() {\n      const c = this.ctx;\n      // clear\n      c.fillStyle = palette.bg;\n      c.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);\n\n      // gentle background wacky elements: clouds and floating bolts\n      this.drawBackground(c);\n\n      // machine body\n      this.drawMachine(c);\n\n      // slots\n      this.drawSlots(c);\n\n      // tiles row\n      this.drawTiles(c);\n\n      // UI top info: round, operation, target\n      this.drawTopInfo(c);\n\n      // message bar\n      this.drawMessage(c);\n\n      // audio visual indicator (speaker)\n      this.drawAudioIcon(c);\n\n      // accessibility hint text (small)\n      this.drawHints(c);\n    }\n\n    drawBackground(c) {\n      // subtle waves\n      for (let i = 0; i < 3; i++) {\n        c.beginPath();\n        c.fillStyle = ['#eef7fb', '#f6fbff', '#eaf2f7'][i % 3];\n        const y = 60 + i * 30;\n        c.ellipse(GAME_WIDTH - i * 180 - 40, y, 120, 26, 0, 0, Math.PI * 2);\n        c.fill();\n      }\n      // wacky floating robot head in corner\n      const x = 60, y = 70;\n      c.fillStyle = '#fff';\n      c.beginPath();\n      c.ellipse(x, y, 50, 40, 0, 0, Math.PI * 2);\n      c.fill();\n      c.fillStyle = '#dfeff8';\n      c.fillRect(x - 38, y + 10, 76, 12);\n      c.fillStyle = '#123';\n      c.beginPath();\n      c.arc(x - 18, y - 4, 5, 0, Math.PI * 2);\n      c.fill();\n      c.beginPath();\n      c.arc(x + 18, y - 4, 5, 0, Math.PI * 2);\n      c.fill();\n      c.strokeStyle = '#8aa1b8';\n      c.lineWidth = 2;\n      c.beginPath();\n      c.arc(x, y + 6, 12, 0, Math.PI);\n      c.stroke();\n    }\n\n    drawMachine(c) {\n      // Machine frame\n      c.save();\n      // shake effect\n      const shakeOffset = this.animTime > 0 ? Math.sin(this.animTime * 0.7) * 6 : 0;\n      c.translate(shakeOffset, 0);\n\n      const mX = 120;\n      const mY = 120;\n      const mW = 480;\n      const mH = 200;\n      c.fillStyle = palette.machine;\n      c.fillRect(mX, mY, mW, mH);\n      c.strokeStyle = palette.dim;\n      c.lineWidth = 3;\n      c.strokeRect(mX, mY, mW, mH);\n\n      // control panel (wacky knobs)\n      c.fillStyle = '#fff';\n      c.fillRect(mX + 20, mY + 16, 140, 54);\n      c.strokeStyle = palette.dim;\n      c.strokeRect(mX + 20, mY + 16, 140, 54);\n      c.fillStyle = palette.accent;\n      c.beginPath();\n      c.arc(mX + 90, mY + 44, 12, 0, Math.PI * 2);\n      c.fill();\n\n      // Target display (round screen)\n      const screenX = mX + mW - 140;\n      const screenY = mY + 26;\n      c.fillStyle = '#123';\n      c.fillRect(screenX, screenY, 120, 56);\n      c.fillStyle = '#eaf6ff';\n      c.font = '28px \"Arial\"';\n      c.textAlign = 'center';\n      c.textBaseline = 'middle';\n      const round = this.currentRound() || { target: '--', op: '?' };\n      c.fillText(`${round.target}`, screenX + 60, screenY + 28);\n\n      // machine window with gears\n      const winX = mX + 80;\n      const winY = mY + 90;\n      const winW = 320;\n      const winH = 88;\n      c.fillStyle = '#d9f0ff';\n      c.fillRect(winX, winY, winW, winH);\n      c.strokeStyle = '#bcd9ea';\n      c.strokeRect(winX, winY, winW, winH);\n\n      // draw gears (animated)\n      const time = Date.now() / 400;\n      this.drawGear(c, winX + 60, winY + 44, 28, 10, time, '#c3e2f4');\n      this.drawGear(c, winX + 160, winY + 44, 22, 8, -time * 1.2, '#b8dff0');\n      this.drawGear(c, winX + 260, winY + 44, 16, 8, time * 1.8, '#d7effc');\n\n      c.restore();\n    }\n\n    drawGear(c, cx, cy, radius, teeth, angle, color) {\n      // simple stylized gear\n      c.save();\n      c.translate(cx, cy);\n      c.rotate(angle);\n      c.fillStyle = color;\n      c.beginPath();\n      const inner = radius * 0.65;\n      for (let i = 0; i < teeth; i++) {\n        const a1 = (i / teeth) * Math.PI * 2;\n        const a2 = ((i + 0.5) / teeth) * Math.PI * 2;\n        const a3 = ((i + 1) / teeth) * Math.PI * 2;\n        c.lineTo(Math.cos(a1) * radius, Math.sin(a1) * radius);\n        c.lineTo(Math.cos(a2) * (radius + 6), Math.sin(a2) * (radius + 6));\n        c.lineTo(Math.cos(a3) * radius, Math.sin(a3) * radius);\n      }\n      c.closePath();\n      c.fill();\n      c.fillStyle = '#fff';\n      c.beginPath();\n      c.arc(0, 0, inner, 0, Math.PI * 2);\n      c.fill();\n      c.restore();\n    }\n\n    drawSlots(c) {\n      // Draw two input slots\n      c.font = '20px Arial';\n      c.textAlign = 'center';\n      c.textBaseline = 'middle';\n\n      const slotABox = { x: 180, y: 170, w: 90, h: 90 };\n      const slotBBox = { x: 360, y: 170, w: 90, h: 90 };\n\n      // labels\n      c.fillStyle = palette.text;\n      c.fillText('Input A', slotABox.x + slotABox.w / 2, slotABox.y - 12);\n      c.fillText('Input B', slotBBox.x + slotBBox.w / 2, slotBBox.y - 12);\n\n      // slot backgrounds\n      c.fillStyle = '#fff';\n      c.strokeStyle = '#cfe8f6';\n      c.lineWidth = 3;\n      c.fillRect(slotABox.x, slotABox.y, slotABox.w, slotABox.h);\n      c.strokeRect(slotABox.x, slotABox.y, slotABox.w, slotABox.h);\n      c.fillRect(slotBBox.x, slotBBox.y, slotBBox.w, slotBBox.h);\n      c.strokeRect(slotBBox.x, slotBBox.y, slotBBox.w, slotBBox.h);\n\n      // values\n      if (this.slotA) {\n        this.drawTileOnSlot(c, slotABox.x + slotABox.w / 2, slotABox.y + slotABox.h / 2, this.slotA.value);\n      } else {\n        c.fillStyle = '#f7fbff';\n        c.font = '18px Arial';\n        c.fillText('choose', slotABox.x + slotABox.w / 2, slotABox.y + slotABox.h / 2);\n      }\n\n      if (this.slotB) {\n        this.drawTileOnSlot(c, slotBBox.x + slotBBox.w / 2, slotBBox.y + slotBBox.h / 2, this.slotB.value);\n      } else {\n        c.fillStyle = '#f7fbff';\n        c.font = '18px Arial';\n        c.fillText('choose', slotBBox.x + slotBBox.w / 2, slotBBox.y + slotBBox.h / 2);\n      }\n\n      // operation display between slots\n      const op = (this.currentRound() && this.currentRound().op) || '?';\n      c.fillStyle = palette.accent2;\n      c.beginPath();\n      c.arc(300, 210, 22, 0, Math.PI * 2);\n      c.fill();\n      c.fillStyle = '#123';\n      c.font = '20px Arial';\n      c.fillText(op, 300, 210);\n    }\n\n    drawTileOnSlot(c, x, y, val) {\n      c.fillStyle = palette.tile;\n      c.strokeStyle = palette.dim;\n      c.lineWidth = 2;\n      c.beginPath();\n      c.arc(x, y - 4, 28, 0, Math.PI * 2);\n      c.fill();\n      c.stroke();\n      c.fillStyle = palette.tileText;\n      c.font = '22px Arial';\n      c.fillText(val, x, y - 6);\n    }\n\n    drawTiles(c) {\n      // bottom row of number tiles 0-9\n      const tileCount = this.tiles.length;\n      const spacing = 60;\n      const startX = (GAME_WIDTH - (spacing * tileCount - 10)) / 2;\n      const baseY = GAME_HEIGHT - 120;\n      for (let i = 0; i < tileCount; i++) {\n        const cx = startX + i * spacing;\n        const cy = baseY + 40;\n        const r = 24;\n        // tile background\n        c.beginPath();\n        c.fillStyle = palette.tile;\n        c.strokeStyle = this.cursor === i ? palette.accent : palette.dim;\n        c.lineWidth = this.cursor === i ? 4 : 2;\n        c.arc(cx, cy, r, 0, Math.PI * 2);\n        c.fill();\n        c.stroke();\n        // number\n        c.fillStyle = palette.tileText;\n        c.font = '20px Arial';\n        c.textAlign = 'center';\n        c.textBaseline = 'middle';\n        c.fillText(this.tiles[i], cx, cy - 4);\n      }\n    }\n\n    drawTopInfo(c) {\n      c.fillStyle = palette.text;\n      c.font = '16px Arial';\n      c.textAlign = 'left';\n      c.fillText(`Round ${this.round + 1} / ${this.maxRounds}`, 20, 28);\n      const round = this.currentRound();\n      c.fillText(`Operation: ${round ? round.op : '-'}`, 20, 54);\n      c.textAlign = 'right';\n      c.fillText(`Target: ${round ? round.target : '--'}`, GAME_WIDTH - 20, 36);\n    }\n\n    drawMessage(c) {\n      // bottom message bar\n      c.fillStyle = '#ffffff';\n      c.fillRect(0, GAME_HEIGHT - 64, GAME_WIDTH, 64);\n      c.strokeStyle = '#d6e8f2';\n      c.strokeRect(0, GAME_HEIGHT - 64, GAME_WIDTH, 64);\n      c.fillStyle = palette.text;\n      c.font = '16px Arial';\n      c.textAlign = 'center';\n      c.textBaseline = 'middle';\n      c.fillText(this.message || '', GAME_WIDTH / 2, GAME_HEIGHT - 32);\n    }\n\n    drawAudioIcon(c) {\n      const x = GAME_WIDTH - 24;\n      const y = 28;\n      // box\n      c.fillStyle = '#fff';\n      c.strokeStyle = '#d6e8f2';\n      c.fillRect(GAME_WIDTH - 58, 10, 48, 36);\n      c.strokeRect(GAME_WIDTH - 58, 10, 48, 36);\n\n      // speaker icon\n      c.fillStyle = this.audioOn ? palette.accent : palette.dim;\n      c.beginPath();\n      c.moveTo(x - 10, y - 6);\n      c.lineTo(x - 2, y - 6);\n      c.lineTo(x + 6, y - 14);\n      c.lineTo(x + 6, y + 14);\n      c.lineTo(x - 2, y + 6);\n      c.lineTo(x - 10, y + 6);\n      c.closePath();\n      c.fill();\n\n      // waves\n      if (this.audioOn) {\n        c.strokeStyle = palette.accent;\n        c.lineWidth = 2;\n        c.beginPath();\n        c.arc(x + 8, y - 2, 8, -0.8, 0.8);\n        c.stroke();\n      } else {\n        c.strokeStyle = palette.dim;\n        c.lineWidth = 2;\n        c.beginPath();\n        c.moveTo(x + 6, y - 10);\n        c.lineTo(x + 14, y + 8);\n        c.stroke();\n      }\n    }\n\n    drawHints(c) {\n      c.fillStyle = '#6a8196';\n      c.font = '12px Arial';\n      c.textAlign = 'left';\n      c.fillText('Keys: \u2190 \u2192 to move, Enter to place, Backspace to remove, A audio, R restart', 12, GAME_HEIGHT - 8);\n    }\n  }\n\n  // Instantiate game\n  const game = new MachineMathGame(ctx, audio);\n\n  // Focus canvas for keyboard\n  canvas.addEventListener('focus', () => {\n    game.focused = true;\n  });\n  canvas.addEventListener('blur', () => {\n    game.focused = false;\n  });\n\n  // Mouse handling\n  canvas.addEventListener('mousedown', (ev) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = ((ev.clientX - rect.left) / rect.width) * canvas.width;\n    const y = ((ev.clientY - rect.top) / rect.height) * canvas.height;\n    try {\n      // User gesture: resume audio context if needed\n      if (audio && audio.supported) audio.resumeIfNeeded().catch(() => {});\n    } catch (e) {\n      console.warn('Audio resume on click failed', e);\n    }\n    game.handleMouseClick(x, y);\n  });\n\n  // Keyboard handling\n  canvas.addEventListener('keydown', (ev) => {\n    // Prevent page scrolling for arrow keys and space\n    if (['ArrowLeft', 'ArrowRight', ' ', 'Spacebar', 'Backspace'].includes(ev.key)) {\n      ev.preventDefault();\n    }\n    try {\n      game.handleKey(ev);\n    } catch (e) {\n      console.error('Key handling error', e);\n    }\n  });\n\n  // Also capture global keydown when canvas is focused to help accessibility\n  window.addEventListener('keydown', (ev) => {\n    if (document.activeElement !== canvas) return;\n    if (['ArrowLeft', 'ArrowRight', 'Enter', 'Backspace', ' ', 'a', 'A', 'r', 'R'].includes(ev.key)) {\n      // forward to canvas handler\n      const event = new KeyboardEvent('keydown', ev);\n      canvas.dispatchEvent(event);\n    }\n  });\n\n  // Resize observer not needed since we have fixed size\n\n  // Game loop\n  function loop() {\n    game.update();\n    game.draw();\n    requestAnimationFrame(loop);\n  }\n  requestAnimationFrame(loop);\n\n  // Provide a friendly intro overlay drawn for a moment\n  let introFrames = 240;\n  function introAnimate() {\n    if (introFrames <= 0) return;\n    const c = ctx;\n    c.save();\n    c.fillStyle = 'rgba(255,255,255,0.6)';\n    c.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);\n    c.fillStyle = '#123';\n    c.font = '28px Arial';\n    c.textAlign = 'center';\n    c.textBaseline = 'middle';\n    c.fillText('Machine Math', GAME_WIDTH / 2, GAME_HEIGHT / 2 - 40);\n    c.font = '18px Arial';\n    c.fillText('Feed numbers to the machine to reach the target number', GAME_WIDTH / 2, GAME_HEIGHT / 2);\n    c.fillText('Use arrows + Enter, or click tiles. Press A to toggle audio.', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 30);\n    c.restore();\n    introFrames--;\n    if (introFrames > 0) requestAnimationFrame(introAnimate);\n  }\n  introAnimate();\n\n  // Provide small instructions to screen readers\n  liveRegion.textContent = 'Machine Math ready. Use arrow keys to move, Enter to place numbers, Backspace to remove. Press A to toggle audio, R to restart. Click the canvas and interact to enable audio.';\n\n  // Ensure audio toggle button can be activated by click via canvas area (handled in mousedown)\n  // Expose simple API for testing (optional)\n  window._machineMathGame = {\n    restart: () => game.restart(),\n    toggleAudio: () => game.toggleAudio(),\n  };\n})();\n---\n",
  "improve_response_tokens": 18152,
  "formatted_code": true,
  "formatting_response_tokens": 19836,
  "final_functionality": {
    "score": 7,
    "max_score": 8,
    "percentage": 87.5,
    "passing": true,
    "issues": [],
    "warnings": [
      "No game state management found"
    ]
  }
}