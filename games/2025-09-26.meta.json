{
  "generated_date": "2025-09-26",
  "generated_timestamp": "2025-09-26T00:26:43.075534",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 10219,
  "game_filename": "2025-09-26.js",
  "game_size_bytes": 32151,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Machine Math Game for ages 7-9\n  // Renders into element with id \"game-of-the-day-stage\"\n  // Canvas-based visuals, Web Audio API sounds (generated), accessible text alternatives, keyboard controls.\n\n  // --------- Setup and Constants ----------\n  const STAGE_ID = \"game-of-the-day-stage\";\n  const WIDTH = 720;\n  const HEIGHT = 480;\n\n  const COLORS = {\n    bg: \"#E8F1F2\",\n    panel: \"#E6EEF7\",\n    machine: \"#D3E8DF\",\n    gear: \"#FFD6A5\",\n    gearAccent: \"#FFB86B\",\n    highlight: \"#88C0D0\",\n    text: \"#1E3A44\",\n    wrong: \"#E85A4F\",\n    correct: \"#4BB543\",\n    muted: \"#A0A0A0\",\n  };\n\n  const MAX_LEVEL = 6;\n\n  // Accessibility live region\n  let liveRegion = null;\n\n  // Canvas & context\n  const stage = document.getElementById(STAGE_ID);\n  if (!stage) {\n    console.error(`Element with id \"${STAGE_ID}\" not found.`);\n    return;\n  }\n  stage.style.position = \"relative\"; // ensure positioning for hidden live region\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute(\"role\", \"img\");\n  canvas.setAttribute(\"aria-label\", \"Machine Math game canvas\");\n  canvas.style.width = WIDTH + \"px\";\n  canvas.style.height = HEIGHT + \"px\";\n  canvas.style.display = \"block\";\n  canvas.style.margin = \"0 auto\";\n  stage.appendChild(canvas);\n\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    console.error(\"Canvas 2D context not supported.\");\n    return;\n  }\n\n  // Create an aria-live region for screen readers (visually hidden but accessible)\n  liveRegion = document.createElement(\"div\");\n  liveRegion.setAttribute(\"aria-live\", \"polite\");\n  liveRegion.style.position = \"absolute\";\n  liveRegion.style.left = \"-9999px\";\n  liveRegion.style.width = \"1px\";\n  liveRegion.style.height = \"1px\";\n  liveRegion.style.overflow = \"hidden\";\n  stage.appendChild(liveRegion);\n\n  // --------- Audio Setup (Web Audio API) ----------\n  let audioCtx = null;\n  let audioEnabled = true;\n  let bgGainNode = null;\n  let bgOsc = null;\n\n  function safeCreateAudioContext() {\n    try {\n      const AC = window.AudioContext || window.webkitAudioContext;\n      if (!AC) throw new Error(\"Web Audio API not supported in this browser.\");\n      audioCtx = new AC();\n      // resume on user interaction if necessary\n      if (audioCtx.state === \"suspended\") {\n        const resume = () => {\n          audioCtx.resume().catch(() => {});\n          window.removeEventListener(\"pointerdown\", resume);\n          window.removeEventListener(\"keydown\", resume);\n        };\n        window.addEventListener(\"pointerdown\", resume);\n        window.addEventListener(\"keydown\", resume);\n      }\n      return true;\n    } catch (err) {\n      console.warn(\"Audio context could not be created:\", err);\n      audioEnabled = false;\n      audioCtx = null;\n      return false;\n    }\n  }\n\n  safeCreateAudioContext();\n\n  function playTone(frequency = 440, duration = 0.25, type = \"sine\", when = 0, gain = 0.12) {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = type;\n      o.frequency.value = frequency;\n      g.gain.value = 0;\n      o.connect(g);\n      g.connect(audioCtx.destination);\n      const start = audioCtx.currentTime + when;\n      // envelope\n      g.gain.setValueAtTime(0, start);\n      g.gain.linearRampToValueAtTime(gain, start + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.0001, start + duration);\n      o.start(start);\n      o.stop(start + duration + 0.02);\n    } catch (err) {\n      console.warn(\"playTone error:\", err);\n    }\n  }\n\n  function playCorrect() {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      // Cheap arpeggio\n      const now = audioCtx.currentTime;\n      playTone(880, 0.12, \"triangle\", 0, 0.08);\n      playTone(1100, 0.12, \"triangle\", 0.12, 0.08);\n      playTone(1320, 0.2, \"sine\", 0.26, 0.12);\n    } catch (err) {\n      console.warn(\"playCorrect error:\", err);\n    }\n  }\n\n  function playWrong() {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      playTone(220, 0.35, \"sawtooth\", 0, 0.16);\n      // small dissonant second\n      playTone(260, 0.2, \"sawtooth\", 0.06, 0.08);\n    } catch (err) {\n      console.warn(\"playWrong error:\", err);\n    }\n  }\n\n  function startBackgroundHum() {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      if (bgOsc) return; // already running\n      bgOsc = audioCtx.createOscillator();\n      const lfo = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n      const filter = audioCtx.createBiquadFilter();\n      bgOsc.type = \"sine\";\n      bgOsc.frequency.value = 60;\n      lfo.frequency.value = 0.25;\n      gain.gain.value = 0.02;\n      filter.type = \"lowpass\";\n      filter.frequency.value = 600;\n\n      lfo.connect(gain.gain);\n      bgOsc.connect(filter);\n      filter.connect(audioCtx.destination);\n      bgOsc.start();\n      lfo.start();\n      bgOsc.connect(audioCtx.destination); // softened by low volumes later\n      // Use a separate gain node at destination for control\n      bgGainNode = audioCtx.createGain();\n      bgGainNode.gain.value = 0.02;\n      bgOsc.disconnect();\n      bgOsc.connect(filter);\n      filter.disconnect();\n      filter.connect(bgGainNode);\n      bgGainNode.connect(audioCtx.destination);\n      lfo.connect(bgGainNode.gain);\n      // Ensure background presence but not loud.\n    } catch (err) {\n      console.warn(\"startBackgroundHum error:\", err);\n    }\n  }\n\n  function stopBackgroundHum() {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      if (bgOsc) {\n        bgOsc.stop();\n        bgOsc.disconnect();\n        bgOsc = null;\n      }\n      if (bgGainNode) {\n        bgGainNode.disconnect();\n        bgGainNode = null;\n      }\n    } catch (err) {\n      console.warn(\"stopBackgroundHum error:\", err);\n    }\n  }\n\n  // Start background hum if audio works\n  if (audioEnabled && audioCtx) {\n    try {\n      startBackgroundHum();\n    } catch (e) {\n      console.warn(\"Background hum failed:\", e);\n    }\n  }\n\n  // Allow toggling audio with 'M'\n  function toggleAudio() {\n    audioEnabled = !audioEnabled;\n    if (!audioEnabled) {\n      stopBackgroundHum();\n      announce(\"Audio muted.\");\n    } else {\n      if (!audioCtx) safeCreateAudioContext();\n      if (audioCtx) startBackgroundHum();\n      announce(\"Audio unmuted.\");\n    }\n  }\n\n  // --------- Game State ----------\n  let level = 1;\n  let availableGears = []; // array of numbers\n  let slots = []; // built gears (numbers or null)\n  let selectedIndex = 0; // index of selected gear or slot\n  let selectedMode = \"gear\"; // 'gear' or 'slot'\n  let target = 0;\n  let maxSlots = 3;\n  let messageText = \"Welcome! Use arrow keys to pick gears and press Space to load into the machine. Press S to start the machine.\";\n  let showHint = false;\n  let gameWon = false;\n  let muteVisual = !audioEnabled;\n\n  // Helper for announcing to screen reader\n  function announce(text) {\n    if (!liveRegion) return;\n    try {\n      liveRegion.textContent = text;\n    } catch (e) {\n      console.warn(\"announce failed:\", e);\n    }\n  }\n\n  // Create a solvable level:\n  function generateLevel(lvl) {\n    // Determine number of slots based on level (increase gradually up to 5)\n    maxSlots = Math.min(3 + Math.floor((lvl - 1) / 2), 5);\n    // Choose n numbers that will form the solution\n    const solution = [];\n    const pool = [];\n    // Create a pool of numbers appropriate to level\n    const maxVal = Math.min(12 + lvl * 2, 20);\n    for (let i = 1; i <= maxVal; i++) pool.push(i);\n\n    // Randomly pick maxSlots numbers from pool to be the solution\n    for (let i = 0; i < maxSlots; i++) {\n      const idx = Math.floor(Math.random() * pool.length);\n      solution.push(pool.splice(idx, 1)[0]);\n    }\n\n    // target is sum of solution\n    target = solution.reduce((a, b) => a + b, 0);\n\n    // Now create available gears: include the solution numbers, plus some distractors\n    const gears = solution.slice();\n    // Add distractors: up to 6 available total\n    const totalGears = Math.max(6, Math.min(8, 4 + lvl));\n    while (gears.length < totalGears) {\n      // pick random from pool or from set 1..maxVal\n      const candidate = 1 + Math.floor(Math.random() * maxVal);\n      // avoid too many duplicates of same value so there's a chance to choose right combos\n      if (gears.filter((x) => x === candidate).length < 2) {\n        gears.push(candidate);\n      }\n    }\n\n    // Shuffle gears\n    for (let i = gears.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [gears[i], gears[j]] = [gears[j], gears[i]];\n    }\n\n    availableGears = gears;\n    slots = new Array(maxSlots).fill(null);\n    selectedIndex = 0;\n    selectedMode = \"gear\";\n    messageText = `Level ${lvl}: Build a sum of ${target} using ${maxSlots} slots.`;\n    showHint = false;\n    gameWon = false;\n    announce(messageText);\n  }\n\n  // Place a gear into selected slot (or remove if slot selected)\n  function loadGearToSlot(gearIndex, slotIndex) {\n    if (gearIndex < 0 || gearIndex >= availableGears.length) return false;\n    if (slotIndex < 0 || slotIndex >= slots.length) return false;\n    if (slots[slotIndex] !== null) {\n      // replace: return current gear to availableGears (in next free spot)\n      // to keep it simple, swap\n      // find empty or replace\n      const temp = slots[slotIndex];\n      slots[slotIndex] = availableGears[gearIndex];\n      availableGears[gearIndex] = temp;\n    } else {\n      // place gear into slot and remove from available list (set to null marker)\n      slots[slotIndex] = availableGears[gearIndex];\n      // mark available slot with null marker to keep indices consistent\n      availableGears[gearIndex] = null;\n      // compact availableGears so nulls cluster, but keep indices stable enough: we will redraw skipping nulls\n      compactAvailableGears();\n    }\n    // sound\n    playTone(660, 0.08, \"sine\", 0, 0.06);\n    messageText = `Placed a gear in slot ${slotIndex + 1}.`;\n    announce(messageText);\n    return true;\n  }\n\n  function removeFromSlot(slotIndex) {\n    if (slotIndex < 0 || slotIndex >= slots.length) return false;\n    if (slots[slotIndex] === null) return false;\n    // Return gear to availableGears; find a null spot or push\n    let found = false;\n    for (let i = 0; i < availableGears.length; i++) {\n      if (availableGears[i] === null) {\n        availableGears[i] = slots[slotIndex];\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      availableGears.push(slots[slotIndex]);\n    }\n    slots[slotIndex] = null;\n    compactAvailableGears();\n    playTone(520, 0.08, \"sine\", 0, 0.06);\n    messageText = `Removed gear from slot ${slotIndex + 1}.`;\n    announce(messageText);\n    return true;\n  }\n\n  function compactAvailableGears() {\n    // Remove trailing nulls but keep some nulls if too few gears\n    const newGears = availableGears.filter((g) => g !== null && g !== undefined);\n    // Keep at least 4 spots for visual consistency\n    while (newGears.length < 6) newGears.push(null);\n    availableGears = newGears;\n  }\n\n  function computeSlotSum() {\n    return slots.reduce((sum, v) => (v ? sum + v : sum), 0);\n  }\n\n  // Validate the machine: if sum equals target it's correct\n  function startMachine() {\n    const sum = computeSlotSum();\n    if (slots.includes(null)) {\n      messageText = `Fill all ${maxSlots} slots before starting!`;\n      playWrong();\n      announce(messageText);\n      return false;\n    }\n    if (sum === target) {\n      // success\n      playCorrect();\n      // celebratory animation\n      messageText = `Nice! You built ${target}.`;\n      announce(messageText);\n      gameWon = true;\n      setTimeout(() => {\n        level++;\n        if (level > MAX_LEVEL) {\n          // game finished\n          messageText = \"You fixed the Great Machine! You win! Press R to play again.\";\n          announce(messageText);\n        } else {\n          generateLevel(level);\n        }\n      }, 900);\n      return true;\n    } else {\n      playWrong();\n      // brief shake effect\n      messageText = `Not quite. Your machine produced ${sum}, but the target is ${target}. Try again or press H for a hint.`;\n      announce(messageText);\n      return false;\n    }\n  }\n\n  // Provide a hint: show one gear from the solution or show whether sum is too low/high\n  function provideHint() {\n    showHint = true;\n    const sum = computeSlotSum();\n    if (slots.includes(null)) {\n      messageText = `Hint: Try picking a combination that adds to ${target}.`;\n    } else {\n      if (sum < target) {\n        messageText = `Hint: Your sum ${sum} is too low. Try larger numbers.`;\n      } else {\n        messageText = `Hint: Your sum ${sum} is too high. Try smaller numbers.`;\n      }\n    }\n    playTone(440, 0.18, \"triangle\", 0, 0.06);\n    announce(messageText);\n  }\n\n  // Reset level\n  function resetLevel() {\n    generateLevel(level);\n  }\n\n  // Reset entire game\n  function resetGame() {\n    level = 1;\n    generateLevel(level);\n  }\n\n  // Build initial level\n  generateLevel(level);\n\n  // ---------- Input Handling (mouse and keyboard) ----------\n  // Convert mouse position to gear index or slot index\n  function getHitAt(x, y) {\n    // Gear area on left bottom\n    // Gear bounds layout\n    const gearArea = { x: 40, y: 320, w: 640, h: 140 };\n    // Each gear drawn horizontally\n    const gearCount = availableGears.length;\n    const gearWidth = 88;\n    const gearGap = 16;\n    const baseX = 60;\n    const baseY = 340;\n    for (let i = 0, drawnIndex = 0; i < availableGears.length; i++) {\n      const val = availableGears[i];\n      // Skip nulls (empty spots)\n      if (val === null || val === undefined) {\n        // empty slot area - still clickable for placing returned gear? we skip.\n      }\n      const gx = baseX + drawnIndex * (gearWidth + gearGap);\n      const gy = baseY;\n      const gw = gearWidth;\n      const gh = gearWidth;\n      if (x >= gx && x <= gx + gw && y >= gy && y <= gy + gh) {\n        return { type: \"gear\", index: i, drawnIndex };\n      }\n      if (val !== null) drawnIndex++;\n    }\n\n    // Slot area on machine center\n    const slotsWidth = slots.length * 80 + (slots.length - 1) * 20;\n    const sx = WIDTH / 2 - slotsWidth / 2;\n    const sy = 200;\n    for (let i = 0; i < slots.length; i++) {\n      const gx = sx + i * 100;\n      const gy = sy;\n      const gw = 80;\n      const gh = 80;\n      if (x >= gx && x <= gx + gw && y >= gy && y <= gy + gh) {\n        return { type: \"slot\", index: i };\n      }\n    }\n\n    // Start button\n    const btn = getStartButtonRect();\n    if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {\n      return { type: \"start\" };\n    }\n\n    // Audio toggle\n    const aud = getAudioIconRect();\n    if (x >= aud.x && x <= aud.x + aud.w && y >= aud.y && y <= aud.y + aud.h) {\n      return { type: \"audio\" };\n    }\n\n    return null;\n  }\n\n  function canvasPointerHandler(e) {\n    let rect = canvas.getBoundingClientRect();\n    let x = (e.clientX - rect.left) * (canvas.width / rect.width);\n    let y = (e.clientY - rect.top) * (canvas.height / rect.height);\n    const hit = getHitAt(x, y);\n    if (!hit) return;\n    if (hit.type === \"gear\") {\n      // select gear (toggle mode)\n      selectedMode = \"gear\";\n      selectedIndex = hit.index;\n      announce(`Selected gear ${availableGears[hit.index] || \"empty\"}`);\n      // if currently selected slot, and slot empty, place into slot automatically?\n      // Let's just pick and let user place in slot by clicking slot\n    } else if (hit.type === \"slot\") {\n      selectedMode = \"slot\";\n      selectedIndex = hit.index;\n      announce(`Selected slot ${hit.index + 1}`);\n    } else if (hit.type === \"start\") {\n      startMachine();\n    } else if (hit.type === \"audio\") {\n      toggleAudio();\n      muteVisual = !audioEnabled;\n    }\n  }\n\n  canvas.addEventListener(\"pointerdown\", canvasPointerHandler);\n\n  // Click-to-place: when gear selected and then clicking slot will place\n  canvas.addEventListener(\"pointerup\", (e) => {\n    let rect = canvas.getBoundingClientRect();\n    let x = (e.clientX - rect.left) * (canvas.width / rect.width);\n    let y = (e.clientY - rect.top) * (canvas.height / rect.height);\n    const hit = getHitAt(x, y);\n    if (!hit) return;\n    if (hit.type === \"slot\" && selectedMode === \"gear\") {\n      // Place selected gear into this slot\n      if (availableGears[selectedIndex] == null) {\n        messageText = \"You selected an empty gear spot.\";\n        announce(messageText);\n        playWrong();\n        return;\n      }\n      loadGearToSlot(selectedIndex, hit.index);\n    } else if (hit.type === \"gear\" && selectedMode === \"slot\") {\n      // If a slot is selected and gear is clicked, swap\n      const targetSlot = selectedIndex;\n      if (slots[targetSlot] == null) {\n        // place gear into slot\n        loadGearToSlot(hit.index, targetSlot);\n      } else {\n        // swap\n        const tmp = slots[targetSlot];\n        slots[targetSlot] = availableGears[hit.index];\n        availableGears[hit.index] = tmp;\n        compactAvailableGears();\n        playTone(640, 0.08, \"sine\", 0, 0.06);\n      }\n    }\n  });\n\n  // Keyboard controls\n  window.addEventListener(\"keydown\", (e) => {\n    if (gameWon && level > MAX_LEVEL) {\n      // if fully completed, allow R to restart\n      if (e.key.toLowerCase() === \"r\") resetGame();\n      return;\n    }\n    switch (e.key) {\n      case \"ArrowLeft\":\n        // move selection left inside current mode\n        if (selectedMode === \"gear\") {\n          selectedIndex = Math.max(0, selectedIndex - 1);\n        } else {\n          selectedIndex = Math.max(0, selectedIndex - 1);\n        }\n        announceSelection();\n        break;\n      case \"ArrowRight\":\n        if (selectedMode === \"gear\") {\n          selectedIndex = Math.min(availableGears.length - 1, selectedIndex + 1);\n        } else {\n          selectedIndex = Math.min(slots.length - 1, selectedIndex + 1);\n        }\n        announceSelection();\n        break;\n      case \"ArrowUp\":\n        // switch to gear mode\n        selectedMode = \"gear\";\n        selectedIndex = Math.min(selectedIndex, Math.max(0, availableGears.length - 1));\n        announceSelection();\n        break;\n      case \"ArrowDown\":\n        selectedMode = \"slot\";\n        selectedIndex = Math.min(selectedIndex, Math.max(0, slots.length - 1));\n        announceSelection();\n        break;\n      case \" \":\n      case \"Enter\":\n        // act: if gear selected and slot selection exists, try placing in currently highlighted slot\n        if (selectedMode === \"gear\") {\n          // place into first empty slot or currently selected slot\n          let targetSlot = slots.findIndex((s) => s === null);\n          if (targetSlot === -1) targetSlot = 0;\n          loadGearToSlot(selectedIndex, targetSlot);\n        } else {\n          // slot selected: if slot has gear, remove it; if empty, try fill with selected gear if any (none)\n          if (slots[selectedIndex] !== null) {\n            removeFromSlot(selectedIndex);\n          } else {\n            // try to put currently highlighted gear (if any) into this slot\n            const gearIdx = availableGears.findIndex((g) => g !== null && g !== undefined);\n            if (gearIdx !== -1) {\n              loadGearToSlot(gearIdx, selectedIndex);\n            } else {\n              messageText = \"No available gears to place.\";\n              playWrong();\n              announce(messageText);\n            }\n          }\n        }\n        break;\n      case \"s\":\n      case \"S\":\n        startMachine();\n        break;\n      case \"r\":\n      case \"R\":\n        resetLevel();\n        break;\n      case \"h\":\n      case \"H\":\n        provideHint();\n        break;\n      case \"m\":\n      case \"M\":\n        toggleAudio();\n        muteVisual = !audioEnabled;\n        break;\n      case \"1\":\n      case \"2\":\n      case \"3\":\n      case \"4\":\n      case \"5\":\n      case \"6\":\n      case \"7\":\n      case \"8\":\n      case \"9\":\n        // quick select gear by number 1..9 mapping to index\n        {\n          const idx = parseInt(e.key, 10) - 1;\n          if (idx >= 0 && idx < availableGears.length) {\n            selectedMode = \"gear\";\n            selectedIndex = idx;\n            announceSelection();\n          }\n        }\n        break;\n      default:\n        break;\n    }\n  });\n\n  function announceSelection() {\n    if (selectedMode === \"gear\") {\n      const val = availableGears[selectedIndex];\n      announce(val ? `Selected gear ${val}` : \"Selected empty gear spot\");\n    } else {\n      const val = slots[selectedIndex];\n      announce(val ? `Selected slot ${selectedIndex + 1} with value ${val}` : `Selected empty slot ${selectedIndex + 1}`);\n    }\n  }\n\n  // ---------- Drawing Utilities ----------\n  function drawRoundedRect(x, y, w, h, r = 10, fill = true, stroke = false) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  function drawGear(cx, cy, radius, teeth = 8, holeRadius = 10, baseColor = COLORS.gear, accent = COLORS.gearAccent) {\n    // Draw gear using arcs and spikes\n    ctx.save();\n    ctx.translate(cx, cy);\n    // rim with teeth\n    for (let i = 0; i < teeth; i++) {\n      const angle = (i / teeth) * Math.PI * 2;\n      const nextAngle = ((i + 0.6) / teeth) * Math.PI * 2;\n      ctx.beginPath();\n      ctx.moveTo(Math.cos(angle) * (radius - 6), Math.sin(angle) * (radius - 6));\n      ctx.lineTo(Math.cos(nextAngle) * (radius + 6), Math.sin(nextAngle) * (radius + 6));\n      ctx.lineTo(Math.cos((i + 1) / teeth * Math.PI * 2) * (radius - 6), Math.sin((i + 1) / teeth * Math.PI * 2) * (radius - 6));\n      ctx.closePath();\n      ctx.fillStyle = accent;\n      ctx.fill();\n    }\n    // body\n    ctx.beginPath();\n    ctx.arc(0, 0, radius - 6, 0, Math.PI * 2);\n    ctx.fillStyle = baseColor;\n    ctx.fill();\n    // center hole\n    ctx.beginPath();\n    ctx.arc(0, 0, holeRadius, 0, Math.PI * 2);\n    ctx.fillStyle = COLORS.machine;\n    ctx.fill();\n    // small screws\n    ctx.fillStyle = \"rgba(0,0,0,0.08)\";\n    for (let i = 0; i < 3; i++) {\n      const a = (i / 3) * Math.PI * 2;\n      ctx.beginPath();\n      ctx.arc(Math.cos(a) * (radius - 20), Math.sin(a) * (radius - 20), 2, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    ctx.restore();\n  }\n\n  function getStartButtonRect() {\n    const w = 130,\n      h = 46;\n    const x = WIDTH - w - 20;\n    const y = HEIGHT - h - 20;\n    return { x, y, w, h };\n  }\n\n  function getAudioIconRect() {\n    const w = 36,\n      h = 36;\n    const x = 20;\n    const y = 20;\n    return { x, y, w, h };\n  }\n\n  // ---------- Main Render Loop ----------\n  let lastTick = performance.now();\n  let shake = 0;\n  function render() {\n    const now = performance.now();\n    const dt = (now - lastTick) / 1000;\n    lastTick = now;\n\n    // Update simple animations\n    if (shake > 0) shake = Math.max(0, shake - dt * 4);\n\n    // Clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // background calming gradient with wacky clouds\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, COLORS.bg);\n    g.addColorStop(1, \"#F6FAFB\");\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Light pattern - diagonal stripes\n    ctx.save();\n    ctx.globalAlpha = 0.06;\n    ctx.fillStyle = \"#FFF\";\n    for (let i = -HEIGHT; i < WIDTH; i += 80) {\n      ctx.fillRect(i, 0, 40, HEIGHT);\n    }\n    ctx.restore();\n\n    // big machine panel\n    ctx.save();\n    const panelX = 60,\n      panelY = 40,\n      panelW = WIDTH - 120,\n      panelH = 240;\n    ctx.fillStyle = COLORS.panel;\n    drawRoundedRect(panelX, panelY, panelW, panelH, 18, true, false);\n    // decorative pipes\n    ctx.fillStyle = \"#CFEDE6\";\n    ctx.fillRect(panelX + 14, panelY + panelH - 26, panelW - 28, 12);\n    ctx.fillRect(panelX + 18, panelY + 20, 12, panelH - 48);\n    ctx.fillRect(panelX + panelW - 30, panelY + 20, 12, panelH - 48);\n    ctx.restore();\n\n    // Robot friendly face on top-left\n    ctx.save();\n    ctx.translate(panelX + 20, panelY + 20);\n    ctx.fillStyle = \"#EDE7FF\";\n    drawRoundedRect(-6, -6, 92, 60, 12, true);\n    ctx.fillStyle = \"#BFC9FF\";\n    ctx.beginPath();\n    ctx.arc(32, 24, 8, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(60, 24, 8, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n\n    // Target display\n    ctx.save();\n    ctx.fillStyle = COLORS.machine;\n    ctx.strokeStyle = \"#BBD6D2\";\n    ctx.lineWidth = 2;\n    const targetX = WIDTH / 2 - 120;\n    const targetY = 90;\n    drawRoundedRect(targetX - 8, targetY - 18, 240, 72, 10, true, true);\n    ctx.fillStyle = COLORS.text;\n    ctx.font = \"22px Arial\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(`Target: ${target}`, targetX + 120, targetY + 30);\n    ctx.restore();\n\n    // Slots area with slight shake\n    ctx.save();\n    const shakeX = Math.sin(performance.now() / 60) * shake * 6;\n    ctx.translate(shakeX, 0);\n    const sx = WIDTH / 2 - (slots.length * 80 + (slots.length - 1) * 20) / 2;\n    const sy = 170;\n    for (let i = 0; i < slots.length; i++) {\n      const x = sx + i * 100;\n      const y = sy;\n      // slot background\n      ctx.fillStyle = \"#EDF7F5\";\n      drawRoundedRect(x, y, 80, 80, 10, true, false);\n      // border highlight if selected\n      if (selectedMode === \"slot\" && selectedIndex === i) {\n        ctx.strokeStyle = COLORS.highlight;\n        ctx.lineWidth = 4;\n        ctx.strokeRect(x + 2, y + 2, 76, 76);\n      }\n      // if it has a gear, draw\n      if (slots[i] !== null && slots[i] !== undefined) {\n        drawGear(x + 40, y + 40, 30, 8, 8, COLORS.gear, COLORS.gearAccent);\n        ctx.fillStyle = COLORS.text;\n        ctx.font = \"16px Arial\";\n        ctx.textAlign = \"center\";\n        ctx.fillText(String(slots[i]), x + 40, y + 48);\n      } else {\n        // hint ghost or placeholder\n        ctx.fillStyle = \"#F3FFFB\";\n        ctx.beginPath();\n        ctx.arc(x + 40, y + 40, 18, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n    ctx.restore();\n\n    // Available gears - bottom area\n    ctx.save();\n    const baseX = 60;\n    const baseY = 340;\n    ctx.fillStyle = \"#F7FBFE\";\n    drawRoundedRect(40, 316, 640, 140, 12, true);\n    // draw each available gear\n    let drawn = 0;\n    for (let i = 0; i < availableGears.length; i++) {\n      const val = availableGears[i];\n      if (val === null || val === undefined) {\n        // leave empty slot placeholder\n        const gx = baseX + drawn * 104;\n        ctx.fillStyle = \"#EEEEF0\";\n        drawRoundedRect(gx, baseY, 88, 88, 14, true);\n        drawn++;\n        continue;\n      }\n      const gx = baseX + drawn * 104;\n      const gy = baseY;\n      // draw gear\n      drawGear(gx + 44, gy + 44, 36, 10, 8, COLORS.gear, COLORS.gearAccent);\n      // number\n      ctx.fillStyle = COLORS.text;\n      ctx.font = \"18px Arial\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(String(val), gx + 44, gy + 52);\n      // highlight if selected\n      if (selectedMode === \"gear\" && selectedIndex === i) {\n        ctx.strokeStyle = COLORS.highlight;\n        ctx.lineWidth = 3;\n        ctx.strokeRect(gx + 2, gy + 2, 84, 84);\n      }\n      drawn++;\n    }\n    ctx.restore();\n\n    // Start button\n    const btn = getStartButtonRect();\n    ctx.save();\n    ctx.fillStyle = COLORS.highlight;\n    drawRoundedRect(btn.x, btn.y, btn.w, btn.h, 8, true);\n    ctx.fillStyle = \"#072A2A\";\n    ctx.font = \"18px Arial\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"Start Machine\", btn.x + btn.w / 2, btn.y + btn.h / 2 + 7);\n    ctx.restore();\n\n    // Audio icon\n    const aud = getAudioIconRect();\n    ctx.save();\n    ctx.fillStyle = muteVisual ? COLORS.muted : COLORS.highlight;\n    drawRoundedRect(aud.x, aud.y, aud.w, aud.h, 8, true);\n    ctx.fillStyle = muteVisual ? \"#FFFFFF\" : \"#052727\";\n    // speaker triangle\n    ctx.beginPath();\n    ctx.moveTo(aud.x + 8, aud.y + 10);\n    ctx.lineTo(aud.x + 18, aud.y + 18);\n    ctx.lineTo(aud.x + 8, aud.y + 26);\n    ctx.closePath();\n    ctx.fill();\n    if (!audioEnabled) {\n      // draw cross\n      ctx.strokeStyle = \"#FFFFFF\";\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(aud.x + 22, aud.y + 12);\n      ctx.lineTo(aud.x + 30, aud.y + 24);\n      ctx.moveTo(aud.x + 30, aud.y + 12);\n      ctx.lineTo(aud.x + 22, aud.y + 24);\n      ctx.stroke();\n    } else {\n      // sound waves\n      ctx.strokeStyle = muteVisual ? \"#FFFFFF\" : \"#073737\";\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.arc(aud.x + 28, aud.y + 18, 6, -0.6, 0.6);\n      ctx.stroke();\n    }\n    ctx.restore();\n\n    // Message panel\n    ctx.save();\n    ctx.fillStyle = \"#FFFFFFAA\";\n    drawRoundedRect(60, 260, 600, 40, 8, true);\n    ctx.fillStyle = COLORS.text;\n    ctx.font = \"14px Arial\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(messageText, 76, 285);\n    ctx.restore();\n\n    // Hint area\n    ctx.save();\n    const hintX = 60;\n    const hintY = 300;\n    ctx.fillStyle = \"#F9FFFB\";\n    ctx.font = \"13px Arial\";\n    ctx.textAlign = \"left\";\n    if (showHint) {\n      ctx.fillStyle = \"#F8FFEE\";\n      drawRoundedRect(hintX, hintY, 280, 28, 6, true);\n      ctx.fillStyle = \"#075A4A\";\n      ctx.fillText(\"Hint shown above. Press H for another hint.\", hintX + 10, hintY + 18);\n    } else {\n      ctx.fillStyle = \"#F3F7F9\";\n      drawRoundedRect(hintX, hintY, 280, 28, 6, true);\n      ctx.fillStyle = \"#07424C\";\n      ctx.fillText(\"Tip: Press H for a gentle hint. Press M to mute/unmute.\", hintX + 10, hintY + 18);\n    }\n    ctx.restore();\n\n    // Level indicator and progress\n    ctx.save();\n    ctx.fillStyle = COLORS.text;\n    ctx.font = \"16px Arial\";\n    ctx.textAlign = \"right\";\n    ctx.fillText(`Level ${level} / ${MAX_LEVEL}`, WIDTH - 20, 30);\n    ctx.restore();\n\n    // If game fully won show confetti-ish shapes\n    if (level > MAX_LEVEL) {\n      ctx.save();\n      ctx.globalAlpha = 0.9;\n      ctx.fillStyle = COLORS.correct;\n      for (let i = 0; i < 60; i++) {\n        const rx = (Math.sin(i * 12.3 + now / 500) + 1) * WIDTH * Math.random() * 0.5 + WIDTH * 0.25;\n        const ry = Math.random() * HEIGHT;\n        ctx.fillRect(rx % WIDTH, ry, 4, 8);\n      }\n      ctx.fillStyle = \"#FFFFFF\";\n      ctx.font = \"28px Arial\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(\"Great job! The Great Machine is fixed!\", WIDTH / 2, HEIGHT / 2);\n      ctx.font = \"16px Arial\";\n      ctx.fillText(\"Press R to play again.\", WIDTH / 2, HEIGHT / 2 + 32);\n      ctx.restore();\n    }\n\n    requestAnimationFrame(render);\n  }\n\n  requestAnimationFrame(render);\n\n  // ---------- Error Handling Notes and Robustness ----------\n  // Attempt to ensure graceful behavior if audio context lost or restricted\n  window.addEventListener(\"unhandledrejection\", (e) => {\n    console.warn(\"Unhandled promise rejection in game:\", e.reason);\n  });\n\n  window.addEventListener(\"error\", (err) => {\n    console.warn(\"Game error:\", err.message);\n  });\n\n  // ---------- Initial instructions and accessibility ----------\n  announce(\n    \"Machine Math: Use left/right arrows to choose items, up/down to switch between gears and slots, space to place or remove. Press S to start, H for a hint, M to mute.\"\n  );\n\n  // Expose minimal debug controls on the stage element for screen readers (visually hidden)\n  const srControls = document.createElement(\"div\");\n  srControls.style.position = \"absolute\";\n  srControls.style.left = \"-9999px\";\n  srControls.innerHTML =\n    \"Controls: Arrow keys to navigate. Space or Enter to place. S to start. H for hint. R to reset. M to toggle sound.\";\n  stage.appendChild(srControls);\n\n  // For usability, ensure initial audio context user gesture requirement handled on first pointerdown\n  function ensureAudioOnGesture() {\n    if (!audioCtx) safeCreateAudioContext();\n    if (audioCtx && audioCtx.state === \"suspended\") {\n      audioCtx.resume().catch(() => {});\n    }\n    window.removeEventListener(\"pointerdown\", ensureAudioOnGesture);\n  }\n  window.addEventListener(\"pointerdown\", ensureAudioOnGesture);\n\n  // Expose a small API for testing in console (not required)\n  window._machineMath = {\n    resetGame,\n    resetLevel,\n    generateLevel,\n    toggleAudio,\n    getState: () => ({ level, target, slots, availableGears }),\n  };\n})();\n---\n",
  "improve_response_tokens": 22485,
  "formatted_code": true,
  "formatting_response_tokens": 24666,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}