# Game of the Day - 2025-10-18

## Metadata
- **Generated Date:** 2025-10-18
- **Generated Time:** 2025-10-18T00:25:36.604650
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-10-18.js
- **File Size:** 23520 bytes
- **Tokens Used:** 8779

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-10-18.js` - The playable game
- `2025-10-18.meta.json` - Machine-readable metadata
- `2025-10-18.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 17974

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 20168

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Drone Math Adventure
  // Game for ages 7-9. Renders inside #game-of-the-day-stage in a 720x480 canvas.
  // Uses Web Audio API for sounds. Keyboard accessible. Clear win/loss conditions.

  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const TARGET_CORRECT = 10;
  const MAX_LIVES = 3;
  const PACKAGE_COUNT = 5;
  const DRONE_RADIUS = 22;
  const PACKAGE_SIZE = { w: 70, h: 40 };
  const UI_PADDING = 10;
  const MIN_BODY_FONT = 16;
  const IMPORTANT_FONT = 22;

  // Get container
  const container = document.getElementById("game-of-the-day-stage");
  if (!container) {
    console.error("Container element #game-of-the-day-stage not found.");
    return;
  }

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.tabIndex = 0; // allow keyboard focus
  canvas.style.outline = "none";
  container.innerHTML = "";
  container.appendChild(canvas);

  const ctx = canvas.getContext("2d");
  if (!ctx) {
    console.error("Canvas 2D context unavailable.");
    return;
  }

  // Audio setup with error handling
  let audioCtx = null;
  let masterGain = null;
  let bgGain = null;
  let bgOsc = null;
  let audioAllowed = true; // will be false if audio context creation fails
  let audioMuted = false;

  try {
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) throw new Error("Web Audio API not supported");
    audioCtx = new AC();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.9;
    masterGain.connect(audioCtx.destination);

    // Gentle background hum
    bgGain = audioCtx.createGain();
    bgGain.gain.value = 0.06;
    bgGain.connect(masterGain);
    bgOsc = audioCtx.createOscillator();
    bgOsc.type = "sine";
    bgOsc.frequency.value = 180;
    const bgFilter = audioCtx.createBiquadFilter();
    bgFilter.type = "lowpass";
    bgFilter.frequency.value = 700;
    bgOsc.connect(bgFilter);
    bgFilter.connect(bgGain);
    try {
      bgOsc.start();
    } catch (e) {
      // Some browsers require user gesture to start; allow starting later
    }
  } catch (err) {
    console.warn("Audio unavailable:", err);
    audioAllowed = false;
    audioMuted = true;
  }

  // Utility: ensure audio context resumed on first user gesture
  function ensureAudioStarted() {
    if (!audioCtx) return;
    if (audioCtx.state === "suspended") {
      audioCtx.resume().catch((e) => {
        console.warn("Audio resume failed:", e);
      });
    }
    try {
      if (bgOsc && bgOsc.start) {
        // starting twice throws; only call if not started
      }
    } catch (e) {}
  }

  // Sound effects using oscillators
  function playSuccessChime() {
    if (!audioAllowed || audioMuted) return;
    try {
      const now = audioCtx.currentTime;
      const g = audioCtx.createGain();
      g.gain.value = 0.0001;
      g.connect(masterGain);
      const o = audioCtx.createOscillator();
      o.type = "triangle";
      o.frequency.value = 880;
      const o2 = audioCtx.createOscillator();
      o2.type = "sine";
      o2.frequency.value = 660;
      const f = audioCtx.createBiquadFilter();
      f.type = "lowpass";
      f.frequency.value = 1500;
      o.connect(f);
      o2.connect(f);
      f.connect(g);
      o.start(now);
      o2.start(now);
      // envelope
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.12, now + 0.05);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);
      o.stop(now + 0.7);
      o2.stop(now + 0.7);
    } catch (e) {
      console.warn("playSuccessChime failed:", e);
    }
  }

  function playWrongBuzzer() {
    if (!audioAllowed || audioMuted) return;
    try {
      const now = audioCtx.currentTime;
      const g = audioCtx.createGain();
      g.gain.value = 0.0001;
      g.connect(masterGain);
      const o = audioCtx.createOscillator();
      o.type = "sawtooth";
      o.frequency.value = 220;
      const f = audioCtx.createBiquadFilter();
      f.type = "lowpass";
      f.frequency.value = 900;
      o.connect(f);
      f.connect(g);
      o.start(now);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.08, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);
      o.frequency.exponentialRampToValueAtTime(80, now + 0.4);
      o.stop(now + 0.45);
    } catch (e) {
      console.warn("playWrongBuzzer failed:", e);
    }
  }

  // Accessible text area for screen readers? We cannot add extra DOM per instruction.
  // Provide clear canvas instructions and keyboard controls on-screen.

  // Game state
  let state = "playing"; // 'playing', 'won', 'lost'
  let score = 0;
  let lives = MAX_LIVES;
  let question = null; // { left, right, op, answer }
  let packages = []; // array of package objects
  let keys = {};
  let mouse = { x: 0, y: 0 };
  let drone = { x: WIDTH / 2, y: HEIGHT / 2, vx: 0, vy: 0, speed: 3.5 };
  let lastTime = performance.now();

  // Restart function
  function resetGame() {
    score = 0;
    lives = MAX_LIVES;
    state = "playing";
    drone.x = WIDTH / 2;
    drone.y = HEIGHT / 2;
    generateQuestionAndPackages();
    ensureAudioStarted();
  }

  // Generate a simple math question (addition/subtraction, answers 0-20)
  function makeQuestion() {
    const ops = ["+" , "-"];
    const op = ops[Math.floor(Math.random() * ops.length)];
    let a, b;
    if (op === "+") {
      a = Math.floor(Math.random() * 11); // 0..10
      b = Math.floor(Math.random() * 11); // 0..10
    } else {
      // subtraction ensure non-negative
      a = Math.floor(Math.random() * 11); // 0..10
      b = Math.floor(Math.random() * (a + 1)); // 0..a
    }
    const answer = op === "+" ? a + b : a - b;
    return { a, b, op, answer };
  }

  // Generate packages with one correct answer and others incorrect
  function generateQuestionAndPackages() {
    question = makeQuestion();
    packages = [];
    const correctValue = question.answer;
    const incorrectSet = new Set();
    // create 4 incorrect distinct values
    while (incorrectSet.size < PACKAGE_COUNT - 1) {
      let val = correctValue + (Math.floor(Math.random() * 11) - 5);
      if (val < 0 || val === correctValue || val > 20) {
        val = Math.floor(Math.random() * 21);
      }
      if (val !== correctValue) incorrectSet.add(val);
    }
    const values = [correctValue, ...Array.from(incorrectSet)];
    // Shuffle values
    for (let i = values.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [values[i], values[j]] = [values[j], values[i]];
    }
    // Place packages in non-overlapping positions, top 3/4 of screen
    const margin = 40;
    const rows = PACKAGE_COUNT;
    for (let i = 0; i < PACKAGE_COUNT; i++) {
      const x = margin + (i % PACKAGE_COUNT) * ((WIDTH - margin * 2) / PACKAGE_COUNT) + Math.random() * 30 - 15;
      const y = 80 + Math.random() * (HEIGHT - 220);
      const vx = (Math.random() - 0.5) * 0.8;
      const vy = (Math.random() - 0.5) * 0.8;
      packages.push({
        id: i + "_" + Date.now(),
        x,
        y,
        vx,
        vy,
        w: PACKAGE_SIZE.w,
        h: PACKAGE_SIZE.h,
        value: values[i],
        collected: false,
        wobble: Math.random() * Math.PI * 2,
      });
    }
  }

  // Initialize
  generateQuestionAndPackages();

  // Controls
  window.addEventListener("keydown", (e) => {
    keys[e.key.toLowerCase()] = true;
    // Start audio on any key as many browsers require gesture
    ensureAudioStarted();

    if (state !== "playing") {
      if (e.key.toLowerCase() === "r") {
        resetGame();
      }
    } else {
      // M to mute
      if (e.key.toLowerCase() === "m") {
        audioMuted = !audioMuted;
      }
    }
  });

  window.addEventListener("keyup", (e) => {
    keys[e.key.toLowerCase()] = false;
  });

  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
    mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
  });

  canvas.addEventListener("click", (e) => {
    const rect = canvas.getBoundingClientRect();
    const cx = (e.clientX - rect.left) * (canvas.width / rect.width);
    const cy = (e.clientY - rect.top) * (canvas.height / rect.height);
    // If in end state, clicking restart button will restart game
    if (state === "won" || state === "lost") {
      const btn = getRestartButtonRect();
      if (cx >= btn.x && cx <= btn.x + btn.w && cy >= btn.y && cy <= btn.y + btn.h) {
        resetGame();
        return;
      }
    }
    // Clicking also toggles audio if clicked near audio toggle
    const audioRect = getAudioTextRect();
    if (cx >= audioRect.x && cx <= audioRect.x + audioRect.w && cy >= audioRect.y && cy <= audioRect.y + audioRect.h) {
      audioMuted = !audioMuted;
      ensureAudioStarted();
    }
  });

  // Restart button layout
  function getRestartButtonRect() {
    const btnW = 260;
    const btnH = 48;
    return { x: WIDTH / 2 - btnW / 2, y: HEIGHT / 2 + 80, w: btnW, h: btnH };
  }

  // Audio text rect (top center)
  function getAudioTextRect() {
    ctx.font = `${MIN_BODY_FONT}px Arial`;
    const txt = audioMuted ? "Audio: Off (M)" : "Audio: On (M)";
    const m = ctx.measureText(txt);
    const w = m.width + UI_PADDING * 2;
    const h = MIN_BODY_FONT + UI_PADDING * 2;
    const x = WIDTH / 2 - w / 2;
    const y = UI_PADDING;
    return { x, y, w, h, txt };
  }

  // Draw helper: draw text with background using measureText to compute size
  function drawTextBox(text, font, x, y, align = "left", fillStyle = "#000", bgStyle = "rgba(255,255,255,0.7)", padding = UI_PADDING) {
    ctx.save();
    ctx.font = font;
    let metrics = ctx.measureText(text);
    let textWidth = metrics.width;
    const textHeight = parseInt(font, 10) || MIN_BODY_FONT;
    let boxW = textWidth + padding * 2;
    let boxH = textHeight + padding * 2;

    let drawX = x;
    if (align === "center") drawX = x - boxW / 2;
    if (align === "right") drawX = x - boxW;

    ctx.fillStyle = bgStyle;
    ctx.strokeStyle = "rgba(0,0,0,0.08)";
    roundRect(ctx, drawX, y, boxW, boxH, 6, true, false);
    ctx.fillStyle = fillStyle;
    ctx.textBaseline = "top";
    ctx.fillText(text, drawX + padding, y + padding);
    ctx.restore();
    return { x: drawX, y, w: boxW, h: boxH, textWidth, textHeight };
  }

  // Round rectangle utility
  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    if (typeof r === "undefined") r = 5;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // Collision detection: circle vs rect
  function circleRectCollision(cx, cy, r, rx, ry, rw, rh) {
    const closestX = Math.max(rx, Math.min(cx, rx + rw));
    const closestY = Math.max(ry, Math.min(cy, ry + rh));
    const dx = cx - closestX;
    const dy = cy - closestY;
    return dx * dx + dy * dy < r * r;
  }

  // Update loop
  function update(dt) {
    if (state !== "playing") return;
    // Input handling: arrow keys or WASD
    let moveX = 0;
    let moveY = 0;
    if (keys["arrowleft"] || keys["a"]) moveX = -1;
    if (keys["arrowright"] || keys["d"]) moveX = 1;
    if (keys["arrowup"] || keys["w"]) moveY = -1;
    if (keys["arrowdown"] || keys["s"]) moveY = 1;

    // Smooth movement
    const sp = drone.speed;
    drone.vx += (moveX * sp - drone.vx) * 0.25;
    drone.vy += (moveY * sp - drone.vy) * 0.25;
    drone.x += drone.vx;
    drone.y += drone.vy;
    // Keep inside bounds
    drone.x = Math.max(DRONE_RADIUS + 2, Math.min(WIDTH - DRONE_RADIUS - 2, drone.x));
    drone.y = Math.max(DRONE_RADIUS + 2, Math.min(HEIGHT - DRONE_RADIUS - 2, drone.y));

    // Update packages positions
    for (const p of packages) {
      p.x += p.vx;
      p.y += p.vy;
      p.wobble += 0.02;
      // bounce on edges
      if (p.x < 10) p.vx = Math.abs(p.vx) + 0.2;
      if (p.x + p.w > WIDTH - 10) p.vx = -Math.abs(p.vx) - 0.2;
      if (p.y < 60) p.vy = Math.abs(p.vy) + 0.2;
      if (p.y + p.h > HEIGHT - 80) p.vy = -Math.abs(p.vy) - 0.2;
    }

    // Collision with packages
    for (const p of packages) {
      if (p.collected) continue;
      if (circleRectCollision(drone.x, drone.y, DRONE_RADIUS, p.x, p.y, p.w, p.h)) {
        p.collected = true;
        if (p.value === question.answer) {
          // Correct
          score += 1;
          playSuccessChime();
          if (score >= TARGET_CORRECT) {
            state = "won";
          } else {
            // small celebration, then new question
            setTimeout(() => {
              generateQuestionAndPackages();
            }, 400);
          }
        } else {
          // Wrong
          lives -= 1;
          playWrongBuzzer();
          if (lives <= 0) {
            state = "lost";
          } else {
            // remove wrong package and continue
            setTimeout(() => {
              // keep same question but generate a new set of packages so player has fresh try
              generateQuestionAndPackages();
            }, 400);
          }
        }
      }
    }
  }

  // Draw loop
  function draw() {
    // clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    // calming sky gradient background
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, "#eaf6ff");
    g.addColorStop(1, "#f7fff9");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Wacky background elements: floating cloud-like circles and geometric shapes
    drawWackyBackground();

    // Draw packages
    for (const p of packages) {
      drawPackage(p);
    }

    // Draw drone
    drawDrone(drone);

    // Draw UI: Score (top-left), audio toggle (top-center), lives (top-right)
    // Score box
    ctx.font = `${IMPORTANT_FONT}px Arial`;
    const scoreText = `Correct: ${score}/${TARGET_CORRECT}`;
    const scoreBox = drawTextBox(scoreText, `${IMPORTANT_FONT}px Arial`, UI_PADDING, UI_PADDING, "left", "#113", "rgba(255,255,255,0.85)", UI_PADDING);

    // Audio toggle (top center)
    const audioRect = getAudioTextRect();
    // Check overlap between scoreBox and audioRect; if overlap, move audio down
    const maybeAudioY = audioRect.y;
    let audioY = maybeAudioY;
    if (scoreBox.x + scoreBox.w + 10 > audioRect.x && scoreBox.y + scoreBox.h > audioRect.y) {
      audioY = maybeAudioY + scoreBox.h + 12;
    }
    const audioText = audioMuted ? "Audio: Off (M)" : audioAllowed ? "Audio: On (M)" : "Audio: Unavailable";
    drawTextBox(audioText, `${MIN_BODY_FONT}px Arial`, WIDTH / 2, audioY, "center", "#114", "rgba(255,255,255,0.85)", UI_PADDING);

    // Lives (top-right)
    ctx.font = `${IMPORTANT_FONT}px Arial`;
    const livesText = `Lives: ${"❤".repeat(lives)}${"♡".repeat(MAX_LIVES - lives)}`;
    const livesMetrics = ctx.measureText(livesText);
    const livesW = livesMetrics.width + UI_PADDING * 2;
    const livesX = WIDTH - livesW - UI_PADDING;
    drawTextBox(livesText, `${IMPORTANT_FONT}px Arial`, livesX + livesW, UI_PADDING, "right", "#711", "rgba(255,255,255,0.85)", UI_PADDING);

    // Draw current question near top center (below audio if audio moved down)
    ctx.font = `${IMPORTANT_FONT + 4}px Arial`;
    const qText = `Solve: ${question.a} ${question.op} ${question.b} = ?`;
    // place it below audio area, ensure spacing
    let qY = audioY + MIN_BODY_FONT + UI_PADDING * 2 + 6;
    // Check for overlapping with score or lives; if overlapping push lower
    const qMetrics = ctx.measureText(qText);
    const qBoxH = IMPORTANT_FONT + 4 + UI_PADDING * 2;
    // ensure at least 10px gap from top UI elements
    qY = Math.max(qY, scoreBox.y + scoreBox.h + 12);
    const qBox = drawTextBox(qText, `${IMPORTANT_FONT + 4}px Arial`, WIDTH / 2, qY, "center", "#004", "rgba(255,255,255,0.92)", UI_PADDING);

    // Draw instructions bottom-center (multi-line)
    const instructions = [
      "Controls: Arrow keys or WASD to fly the drone.",
      "Goal: Collect the package with the correct answer 10 times.",
      "Wrong package = lose a life. 3 wrong answers → Game Over.",
      "Press M to toggle audio. Press R or click Restart to play again.",
    ];
    drawMultilineBox(instructions, `${MIN_BODY_FONT}px Arial`, WIDTH / 2, HEIGHT - 110, "center");

    // If game over or won, overlay end screen
    if (state === "won") {
      drawEndScreen(true);
    } else if (state === "lost") {
      drawEndScreen(false);
    }
  }

  // Helper to draw multiline instruction box
  function drawMultilineBox(lines, font, xCenter, yStart) {
    ctx.save();
    ctx.font = font;
    const lineHeight = parseInt(font, 10) + 6;
    // compute max width
    let maxW = 0;
    for (const line of lines) {
      const m = ctx.measureText(line).width;
      if (m > maxW) maxW = m;
    }
    const boxW = maxW + UI_PADDING * 2;
    const boxH = lineHeight * lines.length + UI_PADDING * 2;
    const x = xCenter - boxW / 2;
    const y = yStart;
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    roundRect(ctx, x, y, boxW, boxH, 8, true, false);
    ctx.fillStyle = "#003";
    ctx.textBaseline = "top";
    for (let i = 0; i < lines.length; i++) {
      ctx.fillText(lines[i], x + UI_PADDING, y + UI_PADDING + i * lineHeight);
    }
    ctx.restore();
  }

  // Draw package box
  function drawPackage(p) {
    ctx.save();
    // wobble small hover
    const wob = Math.sin(p.wobble) * 4;
    const x = p.x;
    const y = p.y + wob;
    // shadow
    ctx.fillStyle = "rgba(0,0,0,0.08)";
    ctx.beginPath();
    ctx.ellipse(x + p.w / 2, y + p.h + 8, p.w / 2, 8, 0, 0, Math.PI * 2);
    ctx.fill();

    // body
    ctx.fillStyle = p.collected ? "rgba(200,200,200,0.6)" : "#ffd36b";
    roundRect(ctx, x, y, p.w, p.h, 8, true, false);
    // label border
    ctx.strokeStyle = "rgba(0,0,0,0.12)";
    ctx.lineWidth = 1;
    roundRect(ctx, x, y, p.w, p.h, 8, false, true);

    // number text
    ctx.font = `20px Arial`;
    ctx.fillStyle = "#112";
    ctx.textBaseline = "middle";
    const txt = String(p.value);
    // measure
    const tw = ctx.measureText(txt).width;
    ctx.fillText(txt, x + (p.w - tw) / 2, y + p.h / 2);
    // small icon to hint collectability
    ctx.fillStyle = "rgba(0,0,0,0.06)";
    ctx.fillRect(x + p.w - 12, y - 10, 8, 6);
    ctx.restore();
  }

  // Draw drone
  function drawDrone(d) {
    ctx.save();
    // shadow
    ctx.fillStyle = "rgba(0,0,0,0.12)";
    ctx.beginPath();
    ctx.ellipse(d.x, d.y + DRONE_RADIUS + 8, DRONE_RADIUS * 1.2, DRONE_RADIUS / 2, 0, 0, Math.PI * 2);
    ctx.fill();

    // body
    ctx.fillStyle = "#6ec8f0";
    ctx.beginPath();
    ctx.ellipse(d.x, d.y, DRONE_RADIUS + 6, DRONE_RADIUS - 2, 0, 0, Math.PI * 2);
    ctx.fill();

    // cockpit
    ctx.fillStyle = "#114451";
    ctx.beginPath();
    ctx.arc(d.x, d.y - 4, DRONE_RADIUS - 10, 0, Math.PI * 2);
    ctx.fill();

    // wacky propellers - four
    const propOffsets = [
      { dx: -28, dy: -18 },
      { dx: 28, dy: -18 },
      { dx: -28, dy: 18 },
      { dx: 28, dy: 18 },
    ];
    let t = performance.now() / 200;
    for (let i = 0; i < propOffsets.length; i++) {
      const p = propOffsets[i];
      const cx = d.x + p.dx;
      const cy = d.y + p.dy;
      // shaft
      ctx.fillStyle = "#333";
      ctx.fillRect(cx - 2, cy - 2, 4, 12);
      // blades (rotating)
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(t * (i % 2 === 0 ? 1 : -1));
      ctx.fillStyle = "rgba(0,0,0,0.12)";
      ctx.fillRect(-22, -4, 44, 8);
      ctx.restore();
    }

    // cheerful eyes
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.arc(d.x - 8, d.y - 6, 4, 0, Math.PI * 2);
    ctx.arc(d.x + 8, d.y - 6, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.arc(d.x - 8, d.y - 6, 2, 0, Math.PI * 2);
    ctx.arc(d.x + 8, d.y - 6, 2, 0, Math.PI * 2);
    ctx.fill();

    // subtle glow when overlapping correct package nearby
    let nearCorrect = packages.some((p) => {
      if (p.collected) return false;
      const dx = p.x + p.w / 2 - d.x;
      const dy = p.y + p.h / 2 - d.y;
      return Math.sqrt(dx * dx + dy * dy) < 100 && p.value === question.answer;
    });
    if (nearCorrect) {
      ctx.fillStyle = "rgba(150,255,180,0.08)";
      ctx.beginPath();
      ctx.ellipse(d.x, d.y, DRONE_RADIUS * 2.2, DRONE_RADIUS * 2, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.restore();
  }

  // Wacky background drawing
  function drawWackyBackground() {
    ctx.save();
    // polygons like buildings
    for (let i = 0; i < 6; i++) {
      const x = i * 140 + 20;
      ctx.fillStyle = `rgba(${150 + (i * 10) % 100}, ${200 - i * 12}, ${230 - i * 6}, 0.06)`;
      ctx.beginPath();
      ctx.moveTo(x, HEIGHT - 40);
      ctx.lineTo(x + 40, HEIGHT - 120 - (i % 3) * 8);
      ctx.lineTo(x + 80, HEIGHT - 40);
      ctx.closePath();
      ctx.fill();
    }
    // floating bubbles
    for (let i = 0; i < 10; i++) {
      const rr = 10 + (i * 7) % 30;
      const x = (i * 73) % WIDTH + ((i * 13) % 30);
      const y = (i * 53) % (HEIGHT - 150) + 30;
      ctx.fillStyle = `rgba(200,230,255,${0.03 + (i % 3) * 0.02})`;
      ctx.beginPath();
      ctx.arc(x, y, rr, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  // Draw end screens
  function drawEndScreen(won) {
    ctx.save();
    ctx.fillStyle = "rgba(10,10,20,0.5)";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = `36px Arial`;
    if (won) {
      ctx.fillStyle = "#0a4";
      ctx.fillText("Victory! You are a Drone Math Hero!", WIDTH / 2, HEIGHT / 2 - 60);
    } else {
      ctx.fillStyle = "#f44";
      ctx.fillText("Game Over — The sky gets tricky!", WIDTH / 2, HEIGHT / 2 - 60);
    }
    ctx.font = `20px Arial`;
    ctx.fillStyle = "#fff";
    const msg = won ? `You collected ${score} correct answers!` : `You collected ${score} correct answers.`;
    ctx.fillText(msg, WIDTH / 2, HEIGHT / 2 - 20);

    // Restart button
    const btn = getRestartButtonRect();
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    roundRect(ctx, btn.x, btn.y, btn.w, btn.h, 10, true, false);
    ctx.fillStyle = "#003";
    ctx.font = `20px Arial`;
    ctx.fillText("Restart (R) / Click Here", WIDTH / 2, btn.y + btn.h / 2);
    ctx.restore();
  }

  // Main loop
  function loop(now) {
    const dt = (now - lastTime) / 1000;
    lastTime = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);

  // Initial focus and hint
  canvas.focus();
  // Expose some state for debugging (not required, but helpful)
  window.__droneMathGame = {
    reset: resetGame,
    mute: () => (audioMuted = true),
    unmute: () => (audioMuted = false),
  };

  // Ensure Audio context start on first interaction
  function handleFirstInteraction() {
    ensureAudioStarted();
    window.removeEventListener("mousedown", handleFirstInteraction);
    window.removeEventListener("touchstart", handleFirstInteraction);
    window.removeEventListener("keydown", handleFirstInteraction);
  }
  window.addEventListener("mousedown", handleFirstInteraction);
  window.addEventListener("touchstart", handleFirstInteraction);
  window.addEventListener("keydown", handleFirstInteraction);
})();
---

