{
  "generated_date": "2025-11-16",
  "generated_timestamp": "2025-11-16T00:31:17.557217",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9920,
  "game_filename": "2025-11-16.js",
  "game_size_bytes": 28341,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Drone Math Game for ages 7-9\n  // Renders inside element with id \"game-of-the-day-stage\"\n  // All visuals drawn on canvas. Sounds via Web Audio API.\n  // Clear win: 10 correct answers. Clear loss: 3 wrong answers.\n  // Accessible: keyboard controls, number-key answers, aria-live text updates.\n\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const TARGET_CORRECT = 10;\n  const MAX_WRONG = 3;\n  const DRONE_SPEED = 180; // pixels per second\n  const ANSWER_RADIUS = 36;\n  const MIN_UI_PADDING = 10;\n\n  // Locate container\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Container element with id \"game-of-the-day-stage\" not found.');\n    return;\n  }\n\n  // Create a visually hidden live region for screen readers (text alternative)\n  let liveRegion = document.createElement('div');\n  liveRegion.setAttribute('aria-live', 'polite');\n  liveRegion.style.position = 'absolute';\n  liveRegion.style.left = '-9999px';\n  liveRegion.style.width = '1px';\n  liveRegion.style.height = '1px';\n  liveRegion.style.overflow = 'hidden';\n  container.appendChild(liveRegion);\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.tabIndex = 0; // make focusable for keyboard input\n  canvas.style.outline = 'none';\n  container.style.position = 'relative';\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Fonts\n  const SMALL_FONT = '16px sans-serif'; // >=14px\n  const BODY_FONT = '18px sans-serif'; // >=18px for important\n  const TITLE_FONT = '28px sans-serif';\n\n  // Game state\n  let gameState = 'start'; // start, playing, win, gameover\n  let correctCount = 0;\n  let wrongCount = 0;\n  let currentQuestion = null;\n  let answers = [];\n  let drone = null;\n  let lastTime = performance.now();\n  let keys = {};\n  let audioAllowed = false;\n  let audioEnabled = true;\n  let audio = null;\n  let ambientGain = null;\n  let sounds = {};\n  let questionId = 0;\n\n  // Pre-calculate positions for UI to avoid overlap using ctx.measureText\n  function measureTextWidth(text, font) {\n    ctx.save();\n    ctx.font = font;\n    const w = ctx.measureText(text).width;\n    ctx.restore();\n    return w;\n  }\n\n  // Initialize audio context with error handling\n  function initAudio() {\n    if (audio) return;\n    try {\n      const AudioCtx = window.AudioContext || window.webkitAudioContext;\n      if (!AudioCtx) throw new Error('Web Audio API not supported.');\n      audio = new AudioCtx();\n      // create master gain\n      const masterGain = audio.createGain();\n      masterGain.gain.value = 0.9;\n      masterGain.connect(audio.destination);\n\n      // ambient hum\n      const osc = audio.createOscillator();\n      ambientGain = audio.createGain();\n      osc.type = 'sine';\n      osc.frequency.value = 80; // low hum\n      ambientGain.gain.value = 0.02;\n      osc.connect(ambientGain);\n      ambientGain.connect(masterGain);\n      osc.start();\n\n      // sound: correct (rising arpeggio)\n      sounds.correct = function () {\n        if (!audioEnabled) return;\n        const now = audio.currentTime;\n        const g = audio.createGain();\n        g.connect(masterGain);\n        g.gain.value = 0;\n        const freqs = [880, 1320, 1760];\n        freqs.forEach((f, i) => {\n          const o = audio.createOscillator();\n          const a = audio.createGain();\n          o.type = 'triangle';\n          o.frequency.value = f;\n          o.connect(a);\n          a.connect(g);\n          const t = now + 0.02 * i;\n          a.gain.setValueAtTime(0, t);\n          a.gain.linearRampToValueAtTime(0.12, t + 0.06);\n          a.gain.linearRampToValueAtTime(0, t + 0.26);\n          o.start(t);\n          o.stop(t + 0.3);\n        });\n        // Master envelope\n        g.gain.setValueAtTime(0.001, now);\n        g.gain.linearRampToValueAtTime(1.0, now + 0.02);\n        g.gain.linearRampToValueAtTime(0.001, now + 0.5);\n      };\n\n      // sound: incorrect (descending buzzer)\n      sounds.incorrect = function () {\n        if (!audioEnabled) return;\n        const now = audio.currentTime;\n        const o = audio.createOscillator();\n        const g = audio.createGain();\n        o.type = 'sawtooth';\n        o.frequency.value = 500;\n        o.connect(g);\n        g.connect(masterGain);\n        g.gain.setValueAtTime(0.001, now);\n        g.gain.linearRampToValueAtTime(0.18, now + 0.02);\n        g.gain.linearRampToValueAtTime(0.001, now + 0.4);\n        o.frequency.setValueAtTime(500, now);\n        o.frequency.exponentialRampToValueAtTime(120, now + 0.4);\n        o.start(now);\n        o.stop(now + 0.45);\n      };\n\n      // sound: collect (short ping)\n      sounds.collect = function () {\n        if (!audioEnabled) return;\n        const now = audio.currentTime;\n        const o = audio.createOscillator();\n        const g = audio.createGain();\n        o.type = 'square';\n        o.frequency.value = 1200;\n        o.connect(g);\n        g.connect(masterGain);\n        g.gain.setValueAtTime(0.001, now);\n        g.gain.linearRampToValueAtTime(0.12, now + 0.01);\n        g.gain.linearRampToValueAtTime(0.001, now + 0.18);\n        o.start(now);\n        o.stop(now + 0.2);\n      };\n\n      // Visual cue if audio available\n      audioAllowed = true;\n    } catch (e) {\n      console.warn('Audio initialization failed:', e);\n      audioAllowed = false;\n      audio = null;\n      sounds = {};\n      ambientGain = null;\n    }\n  }\n\n  // Toggle audio on/off\n  function toggleAudio() {\n    audioEnabled = !audioEnabled;\n    if (!audio) return;\n    if (ambientGain) ambientGain.gain.setValueAtTime(audioEnabled ? 0.02 : 0, audio.currentTime);\n    // Play a small sound to indicate toggle if enabled\n    if (audioEnabled && sounds.collect) sounds.collect();\n  }\n\n  // Accessibility announcements\n  function announce(text) {\n    try {\n      liveRegion.textContent = text;\n    } catch (e) {\n      console.warn('Failed to update live region', e);\n    }\n  }\n\n  // Question generator for early ages\n  function generateQuestion() {\n    // mix: addition, subtraction, missing addend\n    const kind = Math.random();\n    if (kind < 0.45) {\n      // addition up to 20\n      const a = Math.floor(Math.random() * 12) + 1;\n      const b = Math.floor(Math.random() * 12) + 1;\n      const answer = a + b;\n      return {\n        text: `${a} + ${b} = ?`,\n        correct: answer,\n      };\n    } else if (kind < 0.9) {\n      // subtraction non-negative\n      const a = Math.floor(Math.random() * 15) + 5;\n      const b = Math.floor(Math.random() * (a - 2)) + 1;\n      const answer = a - b;\n      return {\n        text: `${a} - ${b} = ?`,\n        correct: answer,\n      };\n    } else {\n      // missing addend: a + ? = b\n      const a = Math.floor(Math.random() * 10) + 1;\n      const b = a + Math.floor(Math.random() * 10) + 1;\n      const answer = b - a;\n      return {\n        text: `${a} + ? = ${b}`,\n        correct: answer,\n      };\n    }\n  }\n\n  // Generate answer options, ensure plausible distractors\n  function generateAnswers(correct) {\n    const set = new Set([correct]);\n    while (set.size < 4) {\n      // near misses\n      const delta = Math.floor(Math.random() * 7) - 3;\n      let val = correct + delta;\n      if (Math.random() < 0.2) val = correct + (Math.random() < 0.5 ? 5 : -5);\n      if (val < 0) val = Math.abs(val) + 1;\n      set.add(val);\n    }\n    const arr = Array.from(set);\n    // shuffle\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    return arr;\n  }\n\n  // Place answer bubbles (ensure non-overlapping with safe attempts)\n  function placeAnswerBubbles(values) {\n    const positions = [];\n    const attemptsLimit = 200;\n    for (let val of values) {\n      let tries = 0;\n      let placed = false;\n      while (!placed && tries < attemptsLimit) {\n        tries++;\n        // place within upper 60% of canvas, avoid center bottom area (for drone)\n        const x = Math.floor(Math.random() * (WIDTH - ANSWER_RADIUS * 2)) + ANSWER_RADIUS;\n        const y = Math.floor(Math.random() * (HEIGHT * 0.6 - ANSWER_RADIUS * 2)) + ANSWER_RADIUS + 60;\n        let ok = true;\n        for (let p of positions) {\n          const dx = p.x - x;\n          const dy = p.y - y;\n          if (Math.sqrt(dx * dx + dy * dy) < ANSWER_RADIUS * 2 + 10) {\n            ok = false;\n            break;\n          }\n        }\n        // avoid top UI area (top 70px)\n        if (y < 70) ok = false;\n        if (ok) {\n          positions.push({ x, y, val });\n          placed = true;\n        }\n      }\n      if (!placed) {\n        // fallback grid\n        positions.push({\n          x: ANSWER_RADIUS + (positions.length * ANSWER_RADIUS * 3) % (WIDTH - ANSWER_RADIUS * 2),\n          y: 120 + Math.floor(positions.length / 3) * ANSWER_RADIUS * 3,\n          val,\n        });\n      }\n    }\n    // add label numbers 1..4\n    return positions.map((p, i) => ({ ...p, label: i + 1 }));\n  }\n\n  // Initialize or reset game\n  function startNewGame() {\n    correctCount = 0;\n    wrongCount = 0;\n    questionId = 0;\n    drone = {\n      x: WIDTH / 2,\n      y: HEIGHT - 110,\n      vx: 0,\n      vy: 0,\n      w: 56,\n      h: 28,\n      colorHue: Math.floor(Math.random() * 360),\n    };\n    gameState = 'playing';\n    spawnQuestion();\n    announce('Game started. Answer math questions by flying the drone to the correct bubble or press number keys 1 to 4.');\n    // try to initialize audio on start interaction\n    if (!audio && audioAllowed === false) {\n      // try to init audio on user start\n      initAudio();\n    }\n  }\n\n  // Spawn a new question\n  function spawnQuestion() {\n    questionId++;\n    currentQuestion = generateQuestion();\n    answers = placeAnswerBubbles(generateAnswers(currentQuestion.correct));\n    // Ensure one answer is the correct one (it should be)\n    announce(`Question ${questionId}: ${currentQuestion.text}. Answers: ${answers.map(a => a.val).join(', ')}. Use arrow keys to fly or press number 1 to 4 to answer.`);\n  }\n\n  // Check collision between drone rectangle and circle (answer)\n  function droneHitsAnswer(answer) {\n    const nearestX = Math.max(answer.x - ANSWER_RADIUS, Math.min(drone.x, answer.x + ANSWER_RADIUS));\n    const nearestY = Math.max(answer.y - ANSWER_RADIUS, Math.min(drone.y, answer.y + ANSWER_RADIUS));\n    const dx = drone.x - nearestX;\n    const dy = drone.y - nearestY;\n    return dx * dx + dy * dy <= (drone.w / 2 + ANSWER_RADIUS) * (drone.w / 2 + ANSWER_RADIUS);\n  }\n\n  // Handle selecting an answer (either via collision or via number key)\n  function selectAnswerByIndex(index) {\n    if (gameState !== 'playing') return;\n    const answer = answers[index];\n    if (!answer) return;\n    handleAnswerSelected(answer);\n  }\n\n  function handleAnswerSelected(answer) {\n    if (gameState !== 'playing') return;\n    if (answer.val === currentQuestion.correct) {\n      correctCount++;\n      if (sounds && sounds.correct) sounds.correct();\n      if (sounds && sounds.collect) sounds.collect();\n      announce(`Correct! ${currentQuestion.text} Answer ${answer.val}. Correct count: ${correctCount} of ${TARGET_CORRECT}.`);\n      // small pop effect: move answer offscreen\n      answer.collected = true;\n      setTimeout(() => {\n        // check win\n        if (correctCount >= TARGET_CORRECT) {\n          gameState = 'win';\n          announce('Victory! You answered ten questions correctly. Press R or click Restart to play again.');\n        } else {\n          spawnQuestion();\n        }\n      }, 300);\n    } else {\n      wrongCount++;\n      if (sounds && sounds.incorrect) sounds.incorrect();\n      // shake drone\n      drone.shake = 12;\n      announce(`Oops! That's ${answer.val}. The correct answer was ${currentQuestion.correct}. Wrong answers: ${wrongCount} of ${MAX_WRONG}.`);\n      if (wrongCount >= MAX_WRONG) {\n        gameState = 'gameover';\n        announce('Game over. You had three wrong answers. Press R or click Restart to try again.');\n      } else {\n        // move to next question\n        setTimeout(spawnQuestion, 800);\n      }\n    }\n  }\n\n  // Draw UI rectangles with measured widths and padding, ensuring no overlap\n  function drawUI() {\n    ctx.save();\n\n    // Score top-left\n    ctx.font = BODY_FONT;\n    const scoreText = `Correct: ${correctCount}/${TARGET_CORRECT}`;\n    const scoreW = ctx.measureText(scoreText).width;\n    const scorePadding = MIN_UI_PADDING;\n    const scoreBoxWidth = scoreW + scorePadding * 2;\n    const scoreBoxHeight = 28;\n    const scoreX = MIN_UI_PADDING;\n    const scoreY = MIN_UI_PADDING;\n    ctx.fillStyle = 'rgba(255,255,255,0.75)';\n    ctx.fillRect(scoreX, scoreY, scoreBoxWidth, scoreBoxHeight);\n    ctx.strokeStyle = '#111';\n    ctx.strokeRect(scoreX, scoreY, scoreBoxWidth, scoreBoxHeight);\n    ctx.fillStyle = '#111';\n    ctx.textBaseline = 'middle';\n    ctx.font = BODY_FONT;\n    ctx.fillText(scoreText, scoreX + scorePadding, scoreY + scoreBoxHeight / 2);\n\n    // Audio indicator top-center (ensure not overlapping)\n    const audioText = audio ? (audioEnabled ? 'Audio: ON (M to mute)' : 'Audio: OFF (M to unmute)') : 'Audio: unavailable';\n    ctx.font = SMALL_FONT;\n    const audioW = ctx.measureText(audioText).width;\n    const audioBoxWidth = audioW + scorePadding * 2;\n    const audioBoxHeight = 24;\n    const audioX = Math.max((WIDTH - audioBoxWidth) / 2, scoreX + scoreBoxWidth + MIN_UI_PADDING);\n    const audioY = MIN_UI_PADDING;\n    ctx.fillStyle = 'rgba(240,240,255,0.9)';\n    ctx.fillRect(audioX, audioY, audioBoxWidth, audioBoxHeight);\n    ctx.strokeStyle = '#113';\n    ctx.strokeRect(audioX, audioY, audioBoxWidth, audioBoxHeight);\n    ctx.fillStyle = '#113';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(audioText, audioX + scorePadding, audioY + audioBoxHeight / 2);\n\n    // Lives top-right\n    const livesText = `Wrong: ${wrongCount}/${MAX_WRONG}`;\n    ctx.font = BODY_FONT;\n    const livesW = ctx.measureText(livesText).width;\n    const livesBoxWidth = livesW + scorePadding * 2;\n    const livesBoxHeight = 28;\n    const livesX = WIDTH - livesBoxWidth - MIN_UI_PADDING;\n    const livesY = MIN_UI_PADDING;\n    // Ensure not overlapping audio box\n    if (livesX < audioX + audioBoxWidth + MIN_UI_PADDING) {\n      // shift audio box left if possible\n      // we won't attempt complex relocation; keep minimum spacing\n    }\n    ctx.fillStyle = 'rgba(255,240,240,0.9)';\n    ctx.fillRect(livesX, livesY, livesBoxWidth, livesBoxHeight);\n    ctx.strokeStyle = '#311';\n    ctx.strokeRect(livesX, livesY, livesBoxWidth, livesBoxHeight);\n    ctx.fillStyle = '#311';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(livesText, livesX + scorePadding, livesY + livesBoxHeight / 2);\n\n    ctx.restore();\n  }\n\n  // Draw instructions bottom-center with background rectangle and ensure multi-line spacing\n  function drawInstructions(lines) {\n    ctx.save();\n    ctx.font = SMALL_FONT;\n    const padding = 10;\n    const lineHeight = 20;\n    // compute max width\n    let maxW = 0;\n    for (let line of lines) {\n      const w = ctx.measureText(line).width;\n      if (w > maxW) maxW = w;\n    }\n    const boxW = maxW + padding * 2;\n    const boxH = lines.length * lineHeight + padding * 2;\n    const boxX = (WIDTH - boxW) / 2;\n    const boxY = HEIGHT - boxH - MIN_UI_PADDING;\n    ctx.fillStyle = 'rgba(250,250,230,0.9)';\n    ctx.fillRect(boxX, boxY, boxW, boxH);\n    ctx.strokeStyle = '#444';\n    ctx.strokeRect(boxX, boxY, boxW, boxH);\n    ctx.fillStyle = '#000';\n    ctx.textBaseline = 'top';\n    ctx.font = SMALL_FONT;\n    for (let i = 0; i < lines.length; i++) {\n      ctx.fillText(lines[i], boxX + padding, boxY + padding + i * lineHeight);\n    }\n    ctx.restore();\n  }\n\n  // Draw answer bubbles\n  function drawAnswers() {\n    ctx.save();\n    for (let a of answers) {\n      // background circle\n      ctx.beginPath();\n      // color friendly and wacky\n      const hue = 180 + (a.label * 40);\n      ctx.fillStyle = a.collected ? 'rgba(200,200,200,0.3)' : `hsl(${hue} 80% 65%)`;\n      ctx.strokeStyle = '#222';\n      ctx.lineWidth = 2;\n      ctx.arc(a.x, a.y, ANSWER_RADIUS, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n\n      // number label small\n      ctx.fillStyle = '#111';\n      ctx.font = '14px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(a.label.toString(), a.x - ANSWER_RADIUS + 12, a.y - ANSWER_RADIUS + 12);\n\n      // value text centered\n      ctx.font = '18px bold sans-serif';\n      ctx.fillStyle = '#042';\n      ctx.fillText(a.val.toString(), a.x, a.y + 2);\n    }\n    ctx.restore();\n  }\n\n  // Draw drone\n  function drawDrone(dt) {\n    ctx.save();\n    // shaking effect\n    const shake = drone.shake || 0;\n    if (drone.shake) {\n      drone.shake = Math.max(0, drone.shake - 20 * dt);\n    }\n    const shakeX = (Math.random() - 0.5) * shake;\n    const shakeY = (Math.random() - 0.5) * shake;\n    ctx.translate(shakeX, shakeY);\n\n    // main body\n    ctx.save();\n    ctx.translate(drone.x, drone.y);\n    ctx.rotate(Math.atan2(drone.vy, Math.max(1e-4, drone.vx + 0.0001)) * 0.05);\n    // body\n    ctx.fillStyle = `hsl(${drone.colorHue} 70% 50%)`;\n    ctx.strokeStyle = '#222';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.ellipse(0, 0, drone.w / 2, drone.h / 2, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n\n    // windows\n    ctx.fillStyle = 'rgba(255,255,255,0.9)';\n    ctx.beginPath();\n    ctx.ellipse(-6, -2, 8, 6, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = 'rgba(0,0,0,0.15)';\n    ctx.beginPath();\n    ctx.ellipse(-6, -2, 5, 3, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // goofy antenna\n    ctx.strokeStyle = '#111';\n    ctx.beginPath();\n    ctx.moveTo(drone.w / 4, -drone.h / 2);\n    ctx.lineTo(drone.w / 4 + 10, -drone.h / 2 - 18);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.arc(drone.w / 4 + 10, -drone.h / 2 - 18, 4, 0, Math.PI * 2);\n    ctx.fillStyle = '#f55';\n    ctx.fill();\n    ctx.restore();\n\n    // rotors (wacky shapes)\n    const rotorCount = 3;\n    for (let i = 0; i < rotorCount; i++) {\n      const rx = drone.x + Math.cos((i / rotorCount) * Math.PI * 2 + performance.now() / 600) * 26;\n      const ry = drone.y + Math.sin((i / rotorCount) * Math.PI * 2 + performance.now() / 600) * 12 - 14;\n      // rotor shadow\n      ctx.fillStyle = 'rgba(0,0,0,0.12)';\n      ctx.beginPath();\n      ctx.ellipse(rx + 2, ry + 6, 22, 6, 0, 0, Math.PI * 2);\n      ctx.fill();\n\n      // rotor blades (drawn as arcs)\n      ctx.strokeStyle = 'rgba(30,30,30,0.9)';\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.arc(rx, ry, 14, 0, Math.PI * 2);\n      ctx.stroke();\n    }\n\n    ctx.restore();\n  }\n\n  // Draw question text at center-top\n  function drawQuestion() {\n    ctx.save();\n    ctx.font = TITLE_FONT;\n    const text = currentQuestion ? currentQuestion.text : 'Get ready!';\n    const textW = ctx.measureText(text).width;\n    const boxW = textW + MIN_UI_PADDING * 2;\n    const boxH = 40;\n    const boxX = (WIDTH - boxW) / 2;\n    const boxY = 48;\n    ctx.fillStyle = 'rgba(230,248,255,0.94)';\n    ctx.fillRect(boxX, boxY, boxW, boxH);\n    ctx.strokeStyle = '#064';\n    ctx.strokeRect(boxX, boxY, boxW, boxH);\n    ctx.fillStyle = '#023';\n    ctx.textBaseline = 'middle';\n    ctx.font = TITLE_FONT;\n    ctx.fillText(text, boxX + MIN_UI_PADDING, boxY + boxH / 2);\n    ctx.restore();\n  }\n\n  // Draw overlay screens: start, win, gameover\n  function drawOverlay() {\n    ctx.save();\n    if (gameState === 'start') {\n      // draw calm background and instructions\n      ctx.fillStyle = '#eaf6ff';\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n      // big title\n      const title = 'Drone Math Adventure';\n      ctx.font = '32px sans-serif';\n      const tw = ctx.measureText(title).width;\n      ctx.fillStyle = '#023';\n      ctx.fillText(title, (WIDTH - tw) / 2, 120);\n\n      const lines = [\n        'Welcome, pilot! Help the friendly drone collect the correct math bubbles.',\n        `Goal: Answer ${TARGET_CORRECT} questions correctly.`,\n        `You can make ${MAX_WRONG} mistakes before the game ends.`,\n        'Controls: Arrow keys to fly, numbers 1-4 to pick an answer,',\n        'Press M to toggle audio, press Enter or click to start.',\n      ];\n      drawInstructions(lines);\n    } else if (gameState === 'win' || gameState === 'gameover') {\n      // dim background\n      ctx.fillStyle = 'rgba(10,10,30,0.35)';\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n      const boxW = WIDTH * 0.8;\n      const boxH = 220;\n      const boxX = (WIDTH - boxW) / 2;\n      const boxY = (HEIGHT - boxH) / 2;\n      ctx.fillStyle = 'rgba(255,255,255,0.96)';\n      ctx.fillRect(boxX, boxY, boxW, boxH);\n      ctx.strokeStyle = '#333';\n      ctx.strokeRect(boxX, boxY, boxW, boxH);\n      ctx.font = '28px sans-serif';\n      ctx.fillStyle = '#022';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'top';\n      const title = gameState === 'win' ? 'You Win! \ud83c\udf89' : 'Game Over';\n      ctx.fillText(title, WIDTH / 2, boxY + 20);\n\n      ctx.font = '18px sans-serif';\n      ctx.fillStyle = '#111';\n      ctx.textBaseline = 'top';\n      if (gameState === 'win') {\n        ctx.fillText(`Great flying! You answered ${correctCount} questions correctly.`, WIDTH / 2, boxY + 70);\n      } else {\n        ctx.fillText(`You answered ${correctCount} correct and made ${wrongCount} mistakes.`, WIDTH / 2, boxY + 70);\n      }\n\n      ctx.font = '16px sans-serif';\n      ctx.fillText('Press R to Restart or click the Restart button below.', WIDTH / 2, boxY + 110);\n\n      // draw restart button\n      const btnW = 160;\n      const btnH = 44;\n      const btnX = WIDTH / 2 - btnW / 2;\n      const btnY = boxY + boxH - 70;\n      ctx.fillStyle = '#0a7';\n      ctx.fillRect(btnX, btnY, btnW, btnH);\n      ctx.strokeStyle = '#063';\n      ctx.strokeRect(btnX, btnY, btnW, btnH);\n      ctx.fillStyle = '#003';\n      ctx.font = '18px sans-serif';\n      ctx.textBaseline = 'middle';\n      ctx.fillText('Restart (R)', WIDTH / 2, btnY + btnH / 2);\n\n      // store button bounds for click detection\n      overlayButton = { x: btnX, y: btnY, w: btnW, h: btnH };\n    }\n    ctx.restore();\n  }\n\n  let overlayButton = null;\n\n  // Main render\n  function render(now) {\n    const dt = Math.min((now - lastTime) / 1000, 0.05);\n    lastTime = now;\n\n    // Clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // gentle sky background with wacky shapes\n    // gradient\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, '#e6f7ff');\n    g.addColorStop(1, '#f6fbff');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    // floating cloud doodles\n    for (let i = 0; i < 5; i++) {\n      ctx.beginPath();\n      const cx = (i * 173 + (now / 50)) % (WIDTH + 200) - 100;\n      const cy = 40 + (i % 2) * 18;\n      ctx.fillStyle = 'rgba(255,255,255,0.8)';\n      ctx.ellipse(cx, cy, 60, 22, 0, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    if (gameState === 'start') {\n      drawOverlay();\n      requestAnimationFrame(render);\n      return;\n    }\n\n    // Update drone physics\n    if (gameState === 'playing') {\n      const acc = { x: 0, y: 0 };\n      if (keys['ArrowLeft']) acc.x -= 1;\n      if (keys['ArrowRight']) acc.x += 1;\n      if (keys['ArrowUp']) acc.y -= 1;\n      if (keys['ArrowDown']) acc.y += 1;\n\n      // normalize acceleration\n      if (acc.x !== 0 || acc.y !== 0) {\n        const mag = Math.sqrt(acc.x * acc.x + acc.y * acc.y);\n        acc.x /= mag;\n        acc.y /= mag;\n        drone.vx = acc.x * DRONE_SPEED;\n        drone.vy = acc.y * DRONE_SPEED;\n      } else {\n        // slow down gradually\n        drone.vx *= 0.9;\n        drone.vy *= 0.9;\n      }\n\n      drone.x += drone.vx * dt;\n      drone.y += drone.vy * dt;\n\n      // constrain within canvas\n      drone.x = Math.max(16, Math.min(WIDTH - 16, drone.x));\n      drone.y = Math.max(70, Math.min(HEIGHT - 40, drone.y));\n\n      // collision with answers\n      for (let i = 0; i < answers.length; i++) {\n        const a = answers[i];\n        if (!a.collected && droneHitsAnswer(a)) {\n          handleAnswerSelected(a);\n          break;\n        }\n      }\n    }\n\n    // draw answers and drone\n    drawAnswers();\n    drawDrone(1 / 60);\n\n    // question UI\n    drawQuestion();\n\n    // UI\n    drawUI();\n\n    // instructions bottom\n    if (gameState === 'playing') {\n      drawInstructions([\n        'Fly to the bubble with the correct answer, or press 1-4.',\n        'Goal: answer 10 correctly. Three wrong answers = game over.',\n        'Press M to toggle audio. Press R to restart anytime.',\n      ]);\n    }\n\n    // overlay screens drawn last to ensure visibility\n    if ((gameState === 'win' || gameState === 'gameover')) {\n      drawOverlay();\n    }\n\n    requestAnimationFrame(render);\n  }\n\n  // Input handling\n  canvas.addEventListener('keydown', (e) => {\n    if (e.key === 'Tab') return; // allow tab navigation outside\n    e.preventDefault();\n    keys[e.key] = true;\n\n    // initialize audio on first user gesture\n    if (!audio && (e.key === 'Enter' || e.key === ' ' || e.key.startsWith('Arrow') || /^[1-4]$/.test(e.key))) {\n      initAudio();\n      if (audio && ambientGain) ambientGain.gain.setValueAtTime(audioEnabled ? 0.02 : 0, audio.currentTime);\n    }\n\n    if (gameState === 'start' && (e.key === 'Enter' || e.key === ' ')) {\n      // start game\n      startNewGame();\n    } else if (gameState === 'playing') {\n      if (/^[1-4]$/.test(e.key)) {\n        const idx = Number(e.key) - 1;\n        selectAnswerByIndex(idx);\n      } else if (e.key === 'm' || e.key === 'M') {\n        toggleAudio();\n      } else if (e.key === 'r' || e.key === 'R') {\n        startNewGame();\n      }\n    } else if ((gameState === 'win' || gameState === 'gameover')) {\n      if (e.key === 'r' || e.key === 'R') {\n        startNewGame();\n      } else if (e.key === 'm' || e.key === 'M') {\n        toggleAudio();\n      }\n    }\n  });\n\n  canvas.addEventListener('keyup', (e) => {\n    keys[e.key] = false;\n  });\n\n  // Pointer input for clicking answer bubbles and UI\n  canvas.addEventListener('pointerdown', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = (e.clientX - rect.left) * (canvas.width / rect.width);\n    const y = (e.clientY - rect.top) * (canvas.height / rect.height);\n\n    // start audio context on first user pointer\n    initAudio();\n    if (audio && ambientGain) ambientGain.gain.setValueAtTime(audioEnabled ? 0.02 : 0, audio.currentTime);\n\n    if (gameState === 'start') {\n      startNewGame();\n      return;\n    } else if (gameState === 'playing') {\n      // check answer bubbles\n      for (let i = 0; i < answers.length; i++) {\n        const a = answers[i];\n        const dx = x - a.x;\n        const dy = y - a.y;\n        if (dx * dx + dy * dy <= ANSWER_RADIUS * ANSWER_RADIUS) {\n          handleAnswerSelected(a);\n          return;\n        }\n      }\n      // allow clicking anywhere to move drone (set velocity towards click)\n      // simple immediate reposition: set drone velocity toward point\n      const dx = x - drone.x;\n      const dy = y - drone.y;\n      const mag = Math.sqrt(dx * dx + dy * dy);\n      if (mag > 5) {\n        drone.vx = (dx / mag) * DRONE_SPEED * 0.8;\n        drone.vy = (dy / mag) * DRONE_SPEED * 0.8;\n      }\n    } else if (gameState === 'win' || gameState === 'gameover') {\n      if (overlayButton) {\n        if (x >= overlayButton.x && x <= overlayButton.x + overlayButton.w &&\n          y >= overlayButton.y && y <= overlayButton.y + overlayButton.h) {\n          startNewGame();\n          return;\n        }\n      }\n      // click in overlay area triggers restart instruction too\n      startNewGame();\n    }\n  });\n\n  // resizing & focus\n  canvas.addEventListener('blur', () => {\n    keys = {}; // stop movement on blur\n  });\n  // ensure keyboard focus instructions\n  canvas.addEventListener('focus', () => {\n    announce('Canvas focused. Use arrow keys to fly. Press Enter to start.');\n  });\n\n  // Start rendering loop\n  lastTime = performance.now();\n  requestAnimationFrame(render);\n\n  // initial overlay\n  gameState = 'start';\n\n  // Announce initial instructions\n  announce('Press Enter to start Drone Math Adventure. Use arrow keys to fly, 1-4 to answer, M to toggle audio, R to restart.');\n\n  // Provide some error handling for unexpected exceptions\n  window.addEventListener('error', (ev) => {\n    console.error('Unexpected error in game:', ev.message);\n    announce('An error occurred in the game. Please reload the page.');\n  });\n})();\n---\n",
  "improve_response_tokens": 19586,
  "formatted_code": true,
  "formatting_response_tokens": 21577,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}