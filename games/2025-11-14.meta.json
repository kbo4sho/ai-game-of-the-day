{
  "generated_date": "2025-11-14",
  "generated_timestamp": "2025-11-14T00:28:28.972801",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8656,
  "game_filename": "2025-11-14.js",
  "game_size_bytes": 24241,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Drone Math Rescue - JavaScript Game\n// Renders inside element with ID \"game-of-the-day-stage\"\n// Canvas size: 720x480\n// No external assets. Sounds generated via Web Audio API oscillators.\n// Accessible: keyboard controls, offscreen text alternatives, visual audio cues.\n// Clear win/loss: Reach 10 correct answers to win. 3 wrong answers = game over.\n\n// Immediately-invoked function to avoid polluting global scope\n(function () {\n  // Constants and configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const PADDING = 12; // minimum padding between UI elements\n  const GOAL = 10;\n  const MAX_WRONG = 3;\n  const DRONE_Y = 260;\n  const DRONE_COUNT = 3;\n  const DRONE_X_SPACING = WIDTH / (DRONE_COUNT + 1);\n  const QUESTION_FONT = \"26px Arial\";\n  const INFO_FONT = \"18px Arial\";\n  const BODY_FONT = \"16px Arial\";\n  const BUTTON_FONT = \"20px Arial\";\n  const BATTERY_ICON_RADIUS = 10;\n\n  // Game state\n  let stage = document.getElementById(\"game-of-the-day-stage\");\n  if (!stage) {\n    throw new Error('Missing container element with id \"game-of-the-day-stage\".');\n  }\n  stage.style.position = \"relative\";\n\n  // Create canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute(\"role\", \"img\");\n  canvas.setAttribute(\"aria-label\", \"Drone Math Rescue game. Use number keys 1-3 or click to answer.\");\n  canvas.style.display = \"block\";\n  canvas.style.outline = \"none\";\n  stage.appendChild(canvas);\n\n  // Offscreen accessible status region for screen readers\n  const srStatus = document.createElement(\"div\");\n  srStatus.setAttribute(\"role\", \"status\");\n  srStatus.setAttribute(\"aria-live\", \"polite\");\n  srStatus.style.position = \"absolute\";\n  srStatus.style.left = \"-9999px\";\n  srStatus.style.width = \"1px\";\n  srStatus.style.height = \"1px\";\n  stage.appendChild(srStatus);\n\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    throw new Error(\"Canvas 2D context not available\");\n  }\n\n  // Audio setup with error handling\n  let audioCtx = null;\n  let audioAvailable = false;\n  let bgOsc = null;\n  let bgGain = null;\n  try {\n    const AudioContext = window.AudioContext || window.webkitAudioContext;\n    if (AudioContext) {\n      audioCtx = new AudioContext();\n      audioAvailable = true;\n    } else {\n      audioAvailable = false;\n    }\n  } catch (e) {\n    console.warn(\"AudioContext unavailable:\", e);\n    audioAvailable = false;\n  }\n\n  function resumeAudioOnGesture() {\n    // due to browser policies, resume audio context on user gesture\n    if (!audioAvailable || !audioCtx) return;\n    if (audioCtx.state === \"suspended\") {\n      audioCtx.resume().catch((e) => {\n        console.warn(\"Audio resume failed:\", e);\n      });\n    }\n  }\n\n  // Start gentle background hum\n  function startBackgroundHum() {\n    if (!audioAvailable || !audioCtx) return;\n    stopBackgroundHum();\n    try {\n      bgOsc = audioCtx.createOscillator();\n      const lfo = audioCtx.createOscillator();\n      const lfoGain = audioCtx.createGain();\n      bgGain = audioCtx.createGain();\n\n      bgOsc.type = \"sine\";\n      bgOsc.frequency.value = 80; // low drone hum\n      bgGain.gain.value = 0.02; // gentle\n\n      lfo.type = \"sine\";\n      lfo.frequency.value = 0.15; // slow wobble\n      lfoGain.gain.value = 30; // modulate frequency a bit\n\n      lfo.connect(lfoGain);\n      lfoGain.connect(bgOsc.frequency);\n      bgOsc.connect(bgGain);\n      bgGain.connect(audioCtx.destination);\n\n      bgOsc.start();\n      lfo.start();\n    } catch (e) {\n      console.warn(\"Failed to start background hum:\", e);\n    }\n  }\n\n  function stopBackgroundHum() {\n    try {\n      if (bgOsc) {\n        bgOsc.stop();\n        bgOsc.disconnect();\n        bgOsc = null;\n      }\n      if (bgGain) {\n        bgGain.disconnect();\n        bgGain = null;\n      }\n    } catch (e) {\n      console.warn(\"Error stopping background hum:\", e);\n    }\n  }\n\n  // Sound effects: correct (pleasant ascending arpeggio), wrong (buzz)\n  function playCorrect() {\n    if (!audioAvailable || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const g = audioCtx.createGain();\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(0.08, now + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);\n      g.connect(audioCtx.destination);\n\n      const freqs = [440, 660, 880];\n      freqs.forEach((f, i) => {\n        const o = audioCtx.createOscillator();\n        o.type = \"sine\";\n        o.frequency.value = f;\n        o.connect(g);\n        o.start(now + i * 0.06);\n        o.stop(now + 0.1 + i * 0.06);\n      });\n    } catch (e) {\n      console.warn(\"playCorrect failed:\", e);\n    }\n  }\n\n  function playWrong() {\n    if (!audioAvailable || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = \"sawtooth\";\n      o.frequency.setValueAtTime(120, now);\n      o.frequency.exponentialRampToValueAtTime(60, now + 0.4);\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(0.08, now + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);\n      o.connect(g);\n      g.connect(audioCtx.destination);\n      o.start(now);\n      o.stop(now + 0.5);\n    } catch (e) {\n      console.warn(\"playWrong failed:\", e);\n    }\n  }\n\n  // Utility functions\n  function randomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  // Generate a simple math question suitable for ages 7-9\n  function generateQuestion() {\n    // mix addition, subtraction, and small multiplication occasionally\n    const typeRoll = Math.random();\n    if (typeRoll < 0.5) {\n      // addition within 20\n      const a = randomInt(1, 15);\n      const b = randomInt(1, Math.max(3, 20 - a));\n      return {\n        text: `${a} + ${b} = ?`,\n        answer: a + b,\n      };\n    } else if (typeRoll < 0.85) {\n      // subtraction without negative\n      const a = randomInt(5, 20);\n      const b = randomInt(1, Math.min(10, a - 1));\n      return {\n        text: `${a} - ${b} = ?`,\n        answer: a - b,\n      };\n    } else {\n      // small multiplication (2-5)\n      const a = randomInt(2, 6);\n      const b = randomInt(2, 5);\n      return {\n        text: `${a} \u00d7 ${b} = ?`,\n        answer: a * b,\n      };\n    }\n  }\n\n  // Game variables\n  let correctCount = 0;\n  let wrongCount = 0;\n  let currentQuestion = null;\n  let options = []; // three numbers\n  let selectedIndex = 0;\n  let animating = []; // animations to draw\n  let gameState = \"playing\"; // \"playing\", \"won\", \"lost\", \"menu\"\n  let soundOn = audioAvailable; // visual indicator and toggle via 'M' key\n  let lastActionTime = 0;\n\n  // Positioning for drone options\n  function dronePositions() {\n    const positions = [];\n    for (let i = 1; i <= DRONE_COUNT; i++) {\n      const x = DRONE_X_SPACING * i;\n      positions.push({ x, y: DRONE_Y });\n    }\n    return positions;\n  }\n  const drones = dronePositions();\n\n  // Create initial question\n  function nextQuestion() {\n    currentQuestion = generateQuestion();\n    // create three options: include correct answer and two plausible wrong ones\n    const correct = currentQuestion.answer;\n    const wrongs = new Set();\n    while (wrongs.size < 2) {\n      const delta = randomInt(1, Math.max(2, Math.floor(correct / 2) + 2));\n      const direction = Math.random() < 0.5 ? -1 : 1;\n      let val = correct + direction * delta;\n      if (val < 0) val = Math.abs(val) + 1;\n      if (val === correct) continue;\n      wrongs.add(val);\n    }\n    const arr = Array.from(wrongs);\n    arr.push(correct);\n    // shuffle\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    options = arr;\n    // selected index default to 0\n    selectedIndex = 0;\n    announceToSR(`New question: ${currentQuestion.text}`);\n  }\n\n  // Accessibility announcements\n  function announceToSR(text) {\n    try {\n      srStatus.innerText = text;\n    } catch (e) {\n      // ignore\n    }\n  }\n\n  // Drawing helpers with measured background rectangles to avoid overlap\n  function drawTextWithBackground(text, x, y, align = \"left\", font = BODY_FONT, textColor = \"#022\", bgColor = \"rgba(255,255,255,0.7)\", padding = 8) {\n    ctx.font = font;\n    const metrics = ctx.measureText(text);\n    const textWidth = metrics.width;\n    const textHeight = parseInt(font, 10) || 16;\n    let drawX = x;\n    if (align === \"center\") {\n      drawX = x - textWidth / 2;\n    } else if (align === \"right\") {\n      drawX = x - textWidth;\n    }\n    const rectX = drawX - padding / 2;\n    const rectY = y - textHeight + -4; // adjust baseline\n    const rectW = textWidth + padding;\n    const rectH = textHeight + padding / 2;\n    // ensure rect within canvas boundaries\n    ctx.fillStyle = bgColor;\n    roundRect(ctx, rectX, rectY, rectW, rectH, 6, true, false);\n    ctx.fillStyle = textColor;\n    ctx.textBaseline = \"top\";\n    ctx.fillText(text, drawX, rectY + (padding / 4));\n  }\n\n  // Rounded rectangle helper\n  function roundRect(ctx, x, y, width, height, radius, fill, stroke) {\n    if (typeof radius === \"number\") {\n      radius = { tl: radius, tr: radius, br: radius, bl: radius };\n    } else {\n      const defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };\n      for (const side in defaultRadius) {\n        radius[side] = radius[side] || 0;\n      }\n    }\n    ctx.beginPath();\n    ctx.moveTo(x + radius.tl, y);\n    ctx.lineTo(x + width - radius.tr, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);\n    ctx.lineTo(x + width, y + height - radius.br);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);\n    ctx.lineTo(x + radius.bl, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);\n    ctx.lineTo(x, y + radius.tl);\n    ctx.quadraticCurveTo(x, y, x + radius.tl, y);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  // Draw calm, wacky background with floating clouds and fun shapes\n  function drawBackground(time) {\n    // Sky gradient\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, \"#eaf6ff\");\n    g.addColorStop(1, \"#e6fff4\");\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Soft hills\n    ctx.fillStyle = \"#d7f3e8\";\n    ctx.beginPath();\n    ctx.moveTo(0, HEIGHT * 0.75);\n    ctx.quadraticCurveTo(WIDTH * 0.25, HEIGHT * 0.60, WIDTH * 0.5, HEIGHT * 0.75);\n    ctx.quadraticCurveTo(WIDTH * 0.75, HEIGHT * 0.90, WIDTH, HEIGHT * 0.75);\n    ctx.lineTo(WIDTH, HEIGHT);\n    ctx.lineTo(0, HEIGHT);\n    ctx.closePath();\n    ctx.fill();\n\n    // Floating silly clouds\n    const cloudCount = 4;\n    for (let i = 0; i < cloudCount; i++) {\n      const cx = ((time / 800 + i * 0.3) * 120 + i * 180) % (WIDTH + 160) - 80;\n      const cy = 60 + (i % 2) * 30;\n      drawCloud(cx, cy, 40 + (i % 3) * 8, `rgba(255,255,255,0.9)`);\n    }\n\n    // Wacky wind socks and markers\n    ctx.fillStyle = \"#fff4e6\";\n    ctx.strokeStyle = \"#ffdca8\";\n    roundRect(ctx, 10, HEIGHT * 0.6 + 10, 160, 40, 10, true, true);\n    ctx.fillStyle = \"#ffdca8\";\n    ctx.font = \"14px Arial\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(\"Drone Rescue Zone: Solve math to collect batteries!\", 18, HEIGHT * 0.6 + 30);\n  }\n\n  function drawCloud(x, y, size, color) {\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.arc(x, y, size * 0.6, 0, Math.PI * 2);\n    ctx.arc(x + size * 0.6, y - size * 0.1, size * 0.7, 0, Math.PI * 2);\n    ctx.arc(x + size * 1.1, y + size * 0.1, size * 0.5, 0, Math.PI * 2);\n    ctx.arc(x + size * 0.4, y + size * 0.3, size * 0.55, 0, Math.PI * 2);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  // Draw a drone at position with option number / label\n  function drawDrone(x, y, label, isSelected, index) {\n    // Shadow\n    ctx.fillStyle = \"rgba(0,0,0,0.12)\";\n    ctx.beginPath();\n    ctx.ellipse(x, y + 36, 48, 12, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Body\n    ctx.fillStyle = isSelected ? \"#ffd26a\" : \"#ffefc0\";\n    roundRect(ctx, x - 48, y - 20, 96, 44, 12, true, false);\n\n    // Dome\n    ctx.fillStyle = isSelected ? \"#7ed7ff\" : \"#aee9ff\";\n    ctx.beginPath();\n    ctx.ellipse(x, y - 8, 32, 22, 0, Math.PI, 0);\n    ctx.fill();\n\n    // Propellers (wacky)\n    for (let i = -1; i <= 1; i += 2) {\n      const px = x + i * 40;\n      const py = y - 18;\n      ctx.fillStyle = \"#ddd\";\n      ctx.beginPath();\n      ctx.ellipse(px, py, 8, 18, i * 0.6, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.fillStyle = \"#bbb\";\n      ctx.beginPath();\n      ctx.ellipse(px + i * 3, py, 4, 10, 0, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // Face / sticker\n    ctx.fillStyle = \"#ffffff\";\n    ctx.beginPath();\n    ctx.arc(x - 18, y - 6, 8, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Option label on body\n    ctx.fillStyle = \"#022\";\n    ctx.font = \"bold 18px Arial\";\n    ctx.textBaseline = \"middle\";\n    const labelText = label.toString();\n    const m = ctx.measureText(labelText);\n    ctx.fillText(labelText, x - m.width / 2, y + 22 - 8);\n\n    // Small battery icon above returning drones if selected\n    if (isSelected) {\n      ctx.fillStyle = \"#ffb703\";\n      ctx.beginPath();\n      ctx.rect(x + 36, y - 28, 8, 12);\n      ctx.fill();\n      ctx.fillStyle = \"#fff\";\n      ctx.fillRect(x + 36, y - 28, 2, 12);\n    }\n\n    // Index number small\n    ctx.font = \"14px Arial\";\n    ctx.fillStyle = \"#444\";\n    ctx.fillText((index + 1).toString(), x - 4, y - 36);\n  }\n\n  // Draw UI elements: score top-left, lives top-right, audio indicator top-center, instructions bottom-center\n  function drawUI() {\n    // Score top-left\n    const scoreText = `Batteries: ${correctCount} / ${GOAL}`;\n    ctx.font = INFO_FONT;\n    const scoreWidth = ctx.measureText(scoreText).width;\n    drawTextWithBackground(scoreText, PADDING, PADDING + 6, \"left\", INFO_FONT, \"#023\", \"rgba(255,255,255,0.85)\", 10);\n\n    // Lives / wrong top-right\n    const livesText = `Wrong: ${wrongCount} / ${MAX_WRONG}`;\n    ctx.font = INFO_FONT;\n    const livesWidth = ctx.measureText(livesText).width;\n    drawTextWithBackground(livesText, WIDTH - PADDING, PADDING + 6, \"right\", INFO_FONT, \"#023\", \"rgba(255,255,255,0.85)\", 10);\n\n    // Audio indicator top-center\n    const audioText = soundOn ? \"Sound: ON (press M to mute)\" : \"Sound: OFF (press M to unmute)\";\n    ctx.font = \"14px Arial\";\n    drawTextWithBackground(audioText, WIDTH / 2, PADDING + 6, \"center\", \"14px Arial\", \"#044\", \"rgba(255,255,255,0.85)\", 8);\n\n    // Question area center top\n    if (gameState === \"playing\") {\n      const questionText = currentQuestion ? currentQuestion.text : \"\";\n      ctx.font = QUESTION_FONT;\n      const metrics = ctx.measureText(questionText);\n      drawTextWithBackground(questionText, WIDTH / 2, 120, \"center\", QUESTION_FONT, \"#022\", \"rgba(255,255,255,0.9)\", 12);\n    }\n\n    // Instructions bottom-center (keyboard controls)\n    const instructions = [\n      \"Controls: Click a drone or press 1-3 to answer.\",\n      \"Use \u2190 \u2192 to change selection, Enter to confirm.\",\n      \"Goal: collect 10 batteries. 3 wrong = game over.\",\n    ];\n    ctx.font = BODY_FONT;\n    const lineHeight = 20;\n    let baseY = HEIGHT - PADDING - instructions.length * lineHeight - 6;\n    for (let i = 0; i < instructions.length; i++) {\n      const text = instructions[i];\n      drawTextWithBackground(text, WIDTH / 2, baseY + i * lineHeight, \"center\", BODY_FONT, \"#043\", \"rgba(255,255,255,0.9)\", 12);\n    }\n  }\n\n  // Animation tick and rendering\n  let lastTime = performance.now();\n  function gameLoop(time) {\n    const dt = time - lastTime;\n    lastTime = time;\n\n    // Clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // Background and scenery\n    drawBackground(time);\n\n    // UI and question/drones\n    drawUI();\n\n    // Drones and options\n    for (let i = 0; i < DRONE_COUNT; i++) {\n      const pos = drones[i];\n      const label = options[i] !== undefined ? options[i] : \"\";\n      const isSel = selectedIndex === i && gameState === \"playing\";\n      drawDrone(pos.x, pos.y, label, isSel, i);\n    }\n\n    // Animating floating collected batteries\n    const now = performance.now();\n    animating = animating.filter((a) => {\n      const t = (now - a.start) / a.duration;\n      if (t >= 1) return false;\n      // draw\n      const alpha = 1 - t;\n      ctx.globalAlpha = alpha;\n      ctx.fillStyle = \"#ffb703\";\n      ctx.beginPath();\n      ctx.arc(a.x, a.y - t * 80, 10 + t * 8, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.globalAlpha = 1;\n      return true;\n    });\n\n    // Draw victory/loss overlays if needed\n    if (gameState === \"won\") {\n      drawEndScreen(\"Victory! Drones saved the batteries!\", \"You collected all batteries!\", \"#d6f6e0\");\n    } else if (gameState === \"lost\") {\n      drawEndScreen(\"Game Over\", \"Too many wrong answers. Try again!\", \"#ffe6e6\");\n    }\n\n    // Loop\n    if (gameState !== \"menu\") {\n      requestAnimationFrame(gameLoop);\n    }\n  }\n\n  function drawEndScreen(title, subtitle, bgColor) {\n    ctx.fillStyle = bgColor;\n    roundRect(ctx, WIDTH * 0.1, HEIGHT * 0.2, WIDTH * 0.8, HEIGHT * 0.55, 14, true, false);\n\n    // Title\n    ctx.fillStyle = \"#023\";\n    ctx.font = \"28px Arial\";\n    const titleY = HEIGHT * 0.32;\n    drawTextWithBackground(title, WIDTH / 2, titleY, \"center\", \"28px Arial\", \"#023\", \"rgba(255,255,255,0)\", 12);\n\n    // Subtitle\n    ctx.font = \"20px Arial\";\n    const subY = HEIGHT * 0.4;\n    drawTextWithBackground(subtitle, WIDTH / 2, subY, \"center\", \"20px Arial\", \"#033\", \"rgba(255,255,255,0)\", 12);\n\n    // Stats\n    ctx.font = BODY_FONT;\n    drawTextWithBackground(`Batteries: ${correctCount} / ${GOAL}`, WIDTH / 2, HEIGHT * 0.48, \"center\", BODY_FONT, \"#023\", \"rgba(255,255,255,0)\", 12);\n    drawTextWithBackground(`Wrong answers: ${wrongCount} / ${MAX_WRONG}`, WIDTH / 2, HEIGHT * 0.52, \"center\", BODY_FONT, \"#023\", \"rgba(255,255,255,0)\", 12);\n\n    // Restart button\n    const btnW = 220;\n    const btnH = 48;\n    const btnX = WIDTH / 2 - btnW / 2;\n    const btnY = HEIGHT * 0.62;\n    ctx.fillStyle = \"#6fcf97\";\n    roundRect(ctx, btnX, btnY, btnW, btnH, 10, true, false);\n    ctx.fillStyle = \"#022\";\n    ctx.font = BUTTON_FONT;\n    ctx.textBaseline = \"middle\";\n    const btnText = \"Restart (R or Enter)\";\n    const bw = ctx.measureText(btnText).width;\n    ctx.fillText(btnText, WIDTH / 2 - bw / 2, btnY + btnH / 2 - 2);\n\n    // Instruction to press keys\n    ctx.font = \"14px Arial\";\n    drawTextWithBackground(\"Press R or click the button to play again. Press M to toggle sound.\", WIDTH / 2, btnY + btnH + 36, \"center\", \"14px Arial\", \"#033\", \"rgba(255,255,255,0)\", 10);\n  }\n\n  // Input handling\n  function onCanvasClick(e) {\n    resumeAudioOnGesture();\n    if (gameState === \"won\" || gameState === \"lost\") {\n      // Check if click on restart button\n      const rect = canvas.getBoundingClientRect();\n      const mx = e.clientX - rect.left;\n      const my = e.clientY - rect.top;\n      const btnW = 220;\n      const btnH = 48;\n      const btnX = WIDTH / 2 - btnW / 2;\n      const btnY = HEIGHT * 0.62;\n      if (mx >= btnX && mx <= btnX + btnW && my >= btnY && my <= btnY + btnH) {\n        restartGame();\n      }\n      return;\n    }\n\n    if (gameState !== \"playing\") return;\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n\n    // Check drone hitboxes\n    for (let i = 0; i < DRONE_COUNT; i++) {\n      const d = drones[i];\n      const dx = mx - d.x;\n      const dy = my - d.y;\n      if (dx * dx + dy * dy <= 48 * 48) {\n        // clicked drone i\n        handleAnswer(i);\n        break;\n      }\n    }\n  }\n\n  function handleAnswer(i) {\n    if (gameState !== \"playing\") return;\n    selectedIndex = i;\n    const chosen = options[i];\n    if (chosen === currentQuestion.answer) {\n      // Correct\n      correctCount++;\n      animating.push({\n        start: performance.now(),\n        duration: 900,\n        x: drones[i].x,\n        y: drones[i].y - 10,\n      });\n      if (soundOn) playCorrect();\n      announceToSR(`Correct! ${currentQuestion.text} = ${chosen}. Batteries collected ${correctCount} of ${GOAL}.`);\n      if (correctCount >= GOAL) {\n        gameState = \"won\";\n        announceToSR(\"You won! Press R to play again.\");\n        stopBackgroundHum();\n      } else {\n        nextQuestion();\n      }\n    } else {\n      // Wrong\n      wrongCount++;\n      if (soundOn) playWrong();\n      announceToSR(`Oops! ${chosen} is not correct. Wrong count ${wrongCount} of ${MAX_WRONG}.`);\n      // small shake animation: track as animating with negative movement\n      animating.push({\n        start: performance.now(),\n        duration: 600,\n        x: drones[i].x,\n        y: drones[i].y,\n        shake: true,\n      });\n      if (wrongCount >= MAX_WRONG) {\n        gameState = \"lost\";\n        announceToSR(\"Game over. Too many wrong answers. Press R to try again.\");\n        stopBackgroundHum();\n      } else {\n        // present new question after a brief delay\n        setTimeout(() => {\n          nextQuestion();\n        }, 600);\n      }\n    }\n    lastActionTime = performance.now();\n  }\n\n  function onKeyDown(e) {\n    resumeAudioOnGesture();\n    if (gameState === \"won\" || gameState === \"lost\") {\n      if (e.key === \"r\" || e.key === \"R\" || e.key === \"Enter\") {\n        restartGame();\n      }\n      if (e.key === \"m\" || e.key === \"M\") {\n        toggleSound();\n      }\n      return;\n    }\n\n    if (gameState !== \"playing\") return;\n\n    if (e.key === \"ArrowRight\") {\n      selectedIndex = (selectedIndex + 1) % DRONE_COUNT;\n      announceToSR(`Selected option ${selectedIndex + 1}: ${options[selectedIndex]}`);\n    } else if (e.key === \"ArrowLeft\") {\n      selectedIndex = (selectedIndex - 1 + DRONE_COUNT) % DRONE_COUNT;\n      announceToSR(`Selected option ${selectedIndex + 1}: ${options[selectedIndex]}`);\n    } else if (e.key === \"1\" || e.key === \"2\" || e.key === \"3\") {\n      const idx = parseInt(e.key, 10) - 1;\n      handleAnswer(idx);\n    } else if (e.key === \"Enter\") {\n      handleAnswer(selectedIndex);\n    } else if (e.key === \"m\" || e.key === \"M\") {\n      toggleSound();\n    }\n  }\n\n  function toggleSound() {\n    soundOn = !soundOn;\n    announceToSR(soundOn ? \"Sound on\" : \"Sound off\");\n    if (soundOn) {\n      if (!audioAvailable) {\n        announceToSR(\"Audio not available in this browser.\");\n      } else {\n        startBackgroundHum();\n      }\n    } else {\n      stopBackgroundHum();\n    }\n  }\n\n  // Restart game\n  function restartGame() {\n    correctCount = 0;\n    wrongCount = 0;\n    gameState = \"playing\";\n    // reset question and start hum\n    nextQuestion();\n    if (soundOn && audioAvailable) startBackgroundHum();\n    announceToSR(\"Game restarted. Good luck!\");\n    // restart loop\n    lastTime = performance.now();\n    requestAnimationFrame(gameLoop);\n  }\n\n  // Initialize input listeners\n  canvas.addEventListener(\"click\", onCanvasClick);\n  window.addEventListener(\"keydown\", onKeyDown);\n\n  // Make canvas keyboard-focusable for accessibility\n  canvas.tabIndex = 0;\n  canvas.addEventListener(\"focus\", () => {\n    // Show hint in screen reader\n    announceToSR(\"Canvas focused. Use number keys or click to answer.\");\n  });\n\n  // Start the game initially\n  function init() {\n    try {\n      nextQuestion();\n      if (soundOn && audioAvailable) {\n        startBackgroundHum();\n      }\n      // Kick off rendering\n      lastTime = performance.now();\n      requestAnimationFrame(gameLoop);\n      announceToSR(\"Welcome to Drone Math Rescue! Answer questions to collect batteries.\");\n    } catch (e) {\n      console.error(\"Initialization failed:\", e);\n      ctx.clearRect(0, 0, WIDTH, HEIGHT);\n      ctx.fillStyle = \"#fff\";\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n      drawTextWithBackground(\"An error occurred while loading the game.\", WIDTH / 2, HEIGHT / 2 - 20, \"center\", \"18px Arial\", \"#900\", \"rgba(255,255,255,0.9)\", 12);\n      drawTextWithBackground(\"Please reload the page.\", WIDTH / 2, HEIGHT / 2 + 16, \"16px Arial\", \"center\", \"#900\", \"rgba(255,255,255,0.9)\", 12);\n      announceToSR(\"Game could not be loaded. Please reload the page.\");\n    }\n  }\n\n  // Expose a friendly control to ensure audio resumes on mobile when tapping anywhere in the stage\n  stage.addEventListener(\"pointerdown\", () => {\n    resumeAudioOnGesture();\n  }, { once: true });\n\n  init();\n})();\n---\n",
  "improve_response_tokens": 17391,
  "formatted_code": true,
  "formatting_response_tokens": 19134,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}