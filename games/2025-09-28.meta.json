{
  "generated_date": "2025-09-28",
  "generated_timestamp": "2025-09-28T00:30:00.515506",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9290,
  "game_filename": "2025-09-28.js",
  "game_size_bytes": 27500,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Machine Math - Canvas Game for ages 7-9\n  // Renders inside element with ID 'game-of-the-day-stage'\n  // All visuals drawn on canvas. Sounds generated with Web Audio API.\n  // Accessible: keyboard controls, aria-live text, clear instructions.\n  'use strict';\n\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const BG_COLOR = '#F6FBFF';\n  const MAX_LEVEL = 5;\n\n  // Utility helpers\n  function clamp(v, a, b) {\n    return Math.max(a, Math.min(b, v));\n  }\n\n  // Find container\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Game container element with ID \"game-of-the-day-stage\" not found.');\n    return;\n  }\n  // Clear container\n  container.innerHTML = '';\n  container.style.position = 'relative';\n  container.style.width = WIDTH + 'px';\n  container.style.height = HEIGHT + 'px';\n  container.style.outline = 'none';\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.width = WIDTH + 'px';\n  canvas.style.height = HEIGHT + 'px';\n  canvas.setAttribute('role', 'application');\n  canvas.setAttribute('aria-label', 'Machine Math game. Use mouse or keyboard to place gears to make the target number.');\n  canvas.tabIndex = 0; // focusable for keyboard\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Create invisible live region for screen readers\n  const liveRegion = document.createElement('div');\n  liveRegion.setAttribute('aria-live', 'assertive');\n  liveRegion.style.position = 'absolute';\n  liveRegion.style.left = '-9999px';\n  liveRegion.style.width = '1px';\n  liveRegion.style.height = '1px';\n  container.appendChild(liveRegion);\n\n  // Audio setup with error handling\n  let audioCtx = null;\n  let audioEnabled = false;\n  let bgGain = null;\n  let bgOsc = null;\n\n  function initAudio() {\n    if (audioCtx) return true;\n    try {\n      const AC = window.AudioContext || window.webkitAudioContext;\n      if (!AC) throw new Error('Web Audio API not supported');\n      audioCtx = new AC();\n      // Create gentle background hum\n      bgOsc = audioCtx.createOscillator();\n      const bgFilter = audioCtx.createBiquadFilter();\n      bgFilter.type = 'lowpass';\n      bgFilter.frequency.value = 600;\n      bgOsc.type = 'sine';\n      bgOsc.frequency.value = 110;\n      bgGain = audioCtx.createGain();\n      bgGain.gain.value = 0; // start silent; ramp when enabled\n      bgOsc.connect(bgFilter);\n      bgFilter.connect(bgGain);\n      bgGain.connect(audioCtx.destination);\n      bgOsc.start(0);\n      audioEnabled = true;\n      console.log('Audio initialized');\n      return true;\n    } catch (e) {\n      console.warn('Audio unavailable:', e);\n      audioEnabled = false;\n      audioCtx = null;\n      return false;\n    }\n  }\n\n  function resumeAudioOnGesture() {\n    // Try to create/resume on user gesture\n    if (!initAudio()) return false;\n    if (audioCtx.state === 'suspended' && typeof audioCtx.resume === 'function') {\n      audioCtx.resume().then(() => {\n        startBackgroundHum();\n      }).catch(err => {\n        console.warn('Audio resume error', err);\n      });\n    } else {\n      startBackgroundHum();\n    }\n    return true;\n  }\n\n  function startBackgroundHum() {\n    if (!audioEnabled) return;\n    if (!bgGain) return;\n    // gentle pulsing\n    bgGain.gain.cancelScheduledValues(audioCtx.currentTime);\n    bgGain.gain.setValueAtTime(0, audioCtx.currentTime);\n    bgGain.gain.linearRampToValueAtTime(0.05, audioCtx.currentTime + 1.2);\n  }\n\n  function stopBackgroundHum() {\n    if (!audioEnabled || !bgGain) return;\n    bgGain.gain.cancelScheduledValues(audioCtx.currentTime);\n    bgGain.gain.setValueAtTime(bgGain.gain.value, audioCtx.currentTime);\n    bgGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.8);\n  }\n\n  // Sound effects using oscillators and envelopes\n  function playTone({ frequency = 440, duration = 0.2, type = 'sine', volume = 0.12, attack = 0.01, release = 0.06, filterFreq = 1200 } = {}) {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const osc = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n      const filter = audioCtx.createBiquadFilter();\n      osc.type = type;\n      osc.frequency.value = frequency;\n      filter.type = 'lowpass';\n      filter.frequency.value = filterFreq;\n      gain.gain.setValueAtTime(0.0001, now);\n      gain.gain.exponentialRampToValueAtTime(volume, now + attack);\n      gain.gain.exponentialRampToValueAtTime(0.0001, now + duration + release);\n      osc.connect(filter);\n      filter.connect(gain);\n      gain.connect(audioCtx.destination);\n      osc.start(now);\n      osc.stop(now + duration + release + 0.02);\n    } catch (e) {\n      console.warn('playTone error', e);\n    }\n  }\n\n  function playCorrectSound() {\n    if (!audioEnabled) return;\n    // Pleasant little arpeggio\n    playTone({ frequency: 660, duration: 0.12, type: 'sine', volume: 0.06 });\n    setTimeout(() => playTone({ frequency: 880, duration: 0.16, type: 'sine', volume: 0.08 }), 120);\n    setTimeout(() => playTone({ frequency: 1320, duration: 0.24, type: 'sine', volume: 0.1 }), 260);\n  }\n\n  function playIncorrectSound() {\n    if (!audioEnabled) return;\n    // Soft buzz\n    playTone({ frequency: 120, duration: 0.28, type: 'sawtooth', volume: 0.12, filterFreq: 500 });\n  }\n\n  function playClickSound() {\n    if (!audioEnabled) return;\n    playTone({ frequency: 1200, duration: 0.06, type: 'square', volume: 0.05, filterFreq: 3000 });\n  }\n\n  // Game state\n  let levelIndex = 0;\n  const levels = [\n    // Simple two-slot sums\n    { target: 7, slots: 2, cogs: [2, 5, 3, 1] },\n    { target: 10, slots: 2, cogs: [4, 6, 3, 2] },\n    { target: 12, slots: 3, cogs: [5, 4, 3, 2, 1] },\n    { target: 15, slots: 3, cogs: [7, 5, 3, 2] },\n    { target: 9, slots: 2, cogs: [1, 8, 4, 2] }\n  ];\n\n  // Game objects: Cogs and Slots\n  class Cog {\n    constructor(id, value, x, y) {\n      this.id = id;\n      this.value = value;\n      this.x = x;\n      this.y = y;\n      this.radius = 34;\n      this.rotation = Math.random() * Math.PI * 2;\n      this.isDragging = false;\n      this.placedSlot = null;\n      this.offset = { x: 0, y: 0 };\n      this.hover = false;\n    }\n  }\n\n  class Slot {\n    constructor(id, x, y) {\n      this.id = id;\n      this.x = x;\n      this.y = y;\n      this.radius = 40;\n      this.filledBy = null;\n    }\n  }\n\n  let cogs = [];\n  let slots = [];\n  let selectedCog = null;\n  let hoveredCog = null;\n  let isPointerDown = false;\n  let pointerIdDown = null;\n  let pointerPos = { x: 0, y: 0 };\n  let message = 'Click or press S to enable sound. Drag gears into machine slots to reach the target. Use keyboard: Tab to select, arrows to move, Enter to pick/place, Space to test.';\n  updateLiveRegion(message);\n\n  // Initialize level\n  function setupLevel(index) {\n    levelIndex = clamp(index, 0, levels.length - 1);\n    const level = levels[levelIndex];\n    cogs = [];\n    slots = [];\n    selectedCog = null;\n    hoveredCog = null;\n    // Place slots on machine area (right side)\n    const slotAreaX = WIDTH * 0.65;\n    const slotYStart = HEIGHT * 0.35;\n    const slotSpacing = 90;\n    for (let i = 0; i < level.slots; i++) {\n      const sx = slotAreaX;\n      const sy = slotYStart + i * slotSpacing;\n      slots.push(new Slot(i, sx, sy));\n    }\n    // Shuffle cog positions on left\n    const startX = WIDTH * 0.15;\n    const startY = HEIGHT * 0.22;\n    const gapX = 120;\n    const gapY = 120;\n    for (let i = 0; i < level.cogs.length; i++) {\n      const v = level.cogs[i];\n      const row = Math.floor(i / 3);\n      const col = i % 3;\n      const x = startX + col * gapX + (Math.random() * 18 - 9);\n      const y = startY + row * gapY + (Math.random() * 14 - 7);\n      cogs.push(new Cog('c' + i, v, x, y));\n    }\n    message = `Level ${levelIndex + 1} - Make ${level.target}. Place ${level.slots} gears into slots.`;\n    updateLiveRegion(message);\n    render();\n  }\n\n  // Check win condition\n  function checkSolution() {\n    const level = levels[levelIndex];\n    let sum = 0;\n    for (let s of slots) {\n      if (!s.filledBy) {\n        // slot empty -> not correct yet\n        return false;\n      }\n      sum += s.filledBy.value;\n    }\n    if (sum === level.target) {\n      playCorrectSound();\n      message = `Nice! You made ${level.target}.`;\n      updateLiveRegion(message);\n      // animate success and advance after short delay\n      setTimeout(() => {\n        levelIndex++;\n        if (levelIndex >= levels.length) {\n          // victory\n          message = 'You fixed all the wacky machines! Great job!';\n          updateLiveRegion(message);\n          stopBackgroundHum();\n          renderVictory();\n        } else {\n          setupLevel(levelIndex);\n        }\n      }, 900);\n      return true;\n    } else {\n      // wrong sum\n      playIncorrectSound();\n      message = `That makes ${sum}. Try again to make ${level.target}.`;\n      updateLiveRegion(message);\n      return false;\n    }\n  }\n\n  // Place/Remove logic\n  function tryPlaceCogInSlot(cog, slot) {\n    if (!cog || !slot) return false;\n    if (slot.filledBy && slot.filledBy !== cog) {\n      // can't place; slot already filled\n      return false;\n    }\n    // If cog currently placed elsewhere, clear old slot\n    for (const s of slots) {\n      if (s.filledBy === cog) s.filledBy = null;\n    }\n    // Snap cog to slot\n    cog.x = slot.x;\n    cog.y = slot.y;\n    cog.placedSlot = slot;\n    slot.filledBy = cog;\n    playClickSound();\n    return true;\n  }\n\n  function removeCogFromSlot(cog) {\n    if (!cog) return;\n    if (cog.placedSlot) {\n      cog.placedSlot.filledBy = null;\n      cog.placedSlot = null;\n    }\n  }\n\n  // Input handling: pointer events\n  function getPointerPos(e) {\n    const rect = canvas.getBoundingClientRect();\n    let clientX, clientY;\n    if (e.touches && e.touches.length > 0) {\n      clientX = e.touches[0].clientX;\n      clientY = e.touches[0].clientY;\n    } else {\n      clientX = e.clientX;\n      clientY = e.clientY;\n    }\n    const x = (clientX - rect.left) * (canvas.width / rect.width);\n    const y = (clientY - rect.top) * (canvas.height / rect.height);\n    return { x, y };\n  }\n\n  function pointerDown(e) {\n    try {\n      // Ensure audio resume on first gesture\n      resumeAudioOnGesture();\n    } catch (err) {\n      console.warn('Audio resume on gesture error', err);\n    }\n    e.preventDefault();\n    isPointerDown = true;\n    const p = getPointerPos(e);\n    pointerPos = p;\n    // find topmost cog under pointer\n    let hit = null;\n    for (let i = cogs.length - 1; i >= 0; i--) {\n      const c = cogs[i];\n      const dx = p.x - c.x;\n      const dy = p.y - c.y;\n      if (Math.hypot(dx, dy) <= c.radius + 6) {\n        hit = c;\n        break;\n      }\n    }\n    if (hit) {\n      // Bring to top\n      const idx = cogs.indexOf(hit);\n      if (idx >= 0) {\n        cogs.splice(idx, 1);\n        cogs.push(hit);\n      }\n      selectedCog = hit;\n      hit.isDragging = true;\n      hit.offset.x = p.x - hit.x;\n      hit.offset.y = p.y - hit.y;\n      removeCogFromSlot(hit);\n      playClickSound();\n      updateLiveRegion(`Picked up gear ${hit.value}. Use mouse or arrow keys to move it, press Enter to place in a slot.`);\n    } else {\n      // If clicked on slot, try to pick up its cog\n      for (const s of slots) {\n        const dx = p.x - s.x;\n        const dy = p.y - s.y;\n        if (Math.hypot(dx, dy) <= s.radius + 6) {\n          if (s.filledBy) {\n            selectedCog = s.filledBy;\n            removeCogFromSlot(selectedCog);\n            selectedCog.isDragging = true;\n            selectedCog.offset.x = 0;\n            selectedCog.offset.y = 0;\n            playClickSound();\n            updateLiveRegion(`Removed gear ${selectedCog.value} from slot.`);\n            break;\n          }\n        }\n      }\n    }\n    render();\n  }\n\n  function pointerMove(e) {\n    if (!isPointerDown) {\n      // highlight hovered cog\n      const p = getPointerPos(e);\n      let hover = null;\n      for (let i = cogs.length - 1; i >= 0; i--) {\n        const c = cogs[i];\n        const dx = p.x - c.x;\n        const dy = p.y - c.y;\n        if (Math.hypot(dx, dy) <= c.radius + 6) {\n          hover = c;\n          break;\n        }\n      }\n      hoveredCog = hover;\n      render();\n      return;\n    }\n    const p = getPointerPos(e);\n    pointerPos = p;\n    if (selectedCog && selectedCog.isDragging) {\n      selectedCog.x = p.x - selectedCog.offset.x;\n      selectedCog.y = p.y - selectedCog.offset.y;\n      render();\n    }\n  }\n\n  function pointerUp(e) {\n    isPointerDown = false;\n    const p = getPointerPos(e);\n    // If dragging a cog, try to drop into slot if near\n    if (selectedCog && selectedCog.isDragging) {\n      let placed = false;\n      for (const s of slots) {\n        const dx = p.x - s.x;\n        const dy = p.y - s.y;\n        if (Math.hypot(dx, dy) <= s.radius + 16) {\n          // place in this slot, if free or occupied by same cog\n          if (!s.filledBy || s.filledBy === selectedCog) {\n            tryPlaceCogInSlot(selectedCog, s);\n            placed = true;\n            break;\n          }\n        }\n      }\n      if (!placed) {\n        // leave at dropped position\n        selectedCog.isDragging = false;\n        selectedCog.placedSlot = null;\n      } else {\n        selectedCog.isDragging = false;\n      }\n      playClickSound();\n    }\n    selectedCog = null;\n    render();\n  }\n\n  // Keyboard controls: Tab to cycle cogs, arrows to move selected, Enter to pick/place, Space to test, S to enable sound, R to reset\n  function keyDown(e) {\n    if (e.key === 's' || e.key === 'S') {\n      // enable audio\n      const ok = resumeAudioOnGesture();\n      if (ok) {\n        message = 'Sound enabled.';\n        updateLiveRegion(message);\n      } else {\n        message = 'Sound unavailable in this browser.';\n        updateLiveRegion(message);\n      }\n      render();\n      e.preventDefault();\n      return;\n    }\n    if (e.key === 'Tab') {\n      // cycle selection among cogs\n      e.preventDefault();\n      if (cogs.length === 0) return;\n      const idx = selectedCog ? cogs.indexOf(selectedCog) : -1;\n      const next = (idx + 1) % cogs.length;\n      selectedCog = cogs[next];\n      // bring to top visually\n      const sc = cogs.splice(next, 1)[0];\n      cogs.push(sc);\n      sc.isDragging = false;\n      message = `Selected gear ${sc.value}. Use arrow keys to move. Enter to pick/place.`;\n      updateLiveRegion(message);\n      render();\n      return;\n    }\n    if (!selectedCog) return;\n    let moved = false;\n    if (e.key === 'ArrowLeft') {\n      selectedCog.x -= 8;\n      moved = true;\n    } else if (e.key === 'ArrowRight') {\n      selectedCog.x += 8;\n      moved = true;\n    } else if (e.key === 'ArrowUp') {\n      selectedCog.y -= 8;\n      moved = true;\n    } else if (e.key === 'ArrowDown') {\n      selectedCog.y += 8;\n      moved = true;\n    } else if (e.key === 'Enter') {\n      // If near a slot, place. If already placed, remove.\n      let placed = false;\n      for (const s of slots) {\n        const dx = selectedCog.x - s.x;\n        const dy = selectedCog.y - s.y;\n        if (Math.hypot(dx, dy) <= s.radius + 12) {\n          tryPlaceCogInSlot(selectedCog, s);\n          placed = true;\n          break;\n        }\n      }\n      if (!placed) {\n        removeCogFromSlot(selectedCog);\n      }\n      playClickSound();\n      message = `Gear ${selectedCog.value} placed/adjusted.`;\n      updateLiveRegion(message);\n      render();\n    } else if (e.key === ' ') {\n      // test machine\n      e.preventDefault();\n      checkSolution();\n      render();\n    } else if (e.key === 'r' || e.key === 'R') {\n      // reset level\n      setupLevel(levelIndex);\n      message = 'Level reset.';\n      updateLiveRegion(message);\n    }\n    if (moved) {\n      // keep selectedCog within bounds\n      selectedCog.x = clamp(selectedCog.x, 20, WIDTH - 20);\n      selectedCog.y = clamp(selectedCog.y, 20, HEIGHT - 20);\n      render();\n    }\n  }\n\n  // Rendering functions\n  function drawRoundedRect(x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function drawMachineBackground() {\n    // calming gradient sky\n    const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    grad.addColorStop(0, '#F9FEFF');\n    grad.addColorStop(1, '#E9F8FF');\n    ctx.fillStyle = grad;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Wacky pipes\n    ctx.save();\n    ctx.globalAlpha = 0.9;\n    ctx.fillStyle = '#D1EFFF';\n    for (let i = 0; i < 6; i++) {\n      const y = 40 + i * 70;\n      ctx.fillRect(40 + (i % 2) * 20, y, WIDTH - 80 - (i % 2) * 40, 14);\n    }\n    ctx.restore();\n\n    // Control panel\n    ctx.fillStyle = '#F0F5FF';\n    drawRoundedRect(420, 40, 260, 120, 12);\n    ctx.fillStyle = '#CFE6FF';\n    ctx.fillRect(432, 60, 120, 16);\n    ctx.fillStyle = '#BEE0FF';\n    ctx.fillRect(432, 86, 80, 10);\n\n    // Decorative nuts and bolts\n    for (let i = 0; i < 8; i++) {\n      const x = 480 + i * 28;\n      const y = 160;\n      drawBolt(x, y, 6, '#D0D7E6', '#A8B4C8');\n    }\n  }\n\n  function drawBolt(cx, cy, radius, fill, stroke) {\n    ctx.beginPath();\n    for (let i = 0; i < 6; i++) {\n      const angle = (i / 6) * Math.PI * 2;\n      const rx = cx + Math.cos(angle) * radius;\n      const ry = cy + Math.sin(angle) * radius;\n      if (i === 0) ctx.moveTo(rx, ry); else ctx.lineTo(rx, ry);\n    }\n    ctx.closePath();\n    ctx.fillStyle = fill;\n    ctx.fill();\n    ctx.strokeStyle = stroke;\n    ctx.lineWidth = 1;\n    ctx.stroke();\n\n    // center screw\n    ctx.beginPath();\n    ctx.arc(cx, cy, radius * 0.5, 0, Math.PI * 2);\n    ctx.fillStyle = '#EEF4FF';\n    ctx.fill();\n  }\n\n  function drawSlots() {\n    for (const s of slots) {\n      // soft glowing slot background\n      ctx.save();\n      ctx.beginPath();\n      ctx.arc(s.x, s.y, s.radius + 6, 0, Math.PI * 2);\n      ctx.fillStyle = '#FFF8E1';\n      ctx.globalAlpha = 0.6;\n      ctx.fill();\n      ctx.restore();\n\n      // actual slot ring\n      ctx.beginPath();\n      ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);\n      ctx.fillStyle = '#FFF';\n      ctx.fill();\n      ctx.lineWidth = 4;\n      ctx.strokeStyle = '#C9DFF5';\n      ctx.stroke();\n\n      // label area for placeholder\n      ctx.fillStyle = '#A8C8FF';\n      ctx.font = '14px Verdana, Arial';\n      ctx.textAlign = 'center';\n      ctx.fillText(' slot ', s.x, s.y - s.radius - 10);\n\n      // highlight when filled\n      if (s.filledBy) {\n        // draw connecting bolts\n        ctx.beginPath();\n        ctx.moveTo(s.x - s.radius - 8, s.y + s.radius + 4);\n        ctx.lineTo(s.x + s.radius + 8, s.y + s.radius + 4);\n        ctx.strokeStyle = '#E0F0FF';\n        ctx.lineWidth = 2;\n        ctx.stroke();\n      }\n    }\n  }\n\n  function drawCog(cog) {\n    // Gear body\n    const cx = cog.x;\n    const cy = cog.y;\n    const r = cog.radius;\n    ctx.save();\n    ctx.translate(cx, cy);\n    ctx.rotate(cog.rotation);\n    // Draw gear teeth\n    const teeth = 12;\n    for (let i = 0; i < teeth; i++) {\n      const angle = (i / teeth) * Math.PI * 2;\n      const tx = Math.cos(angle);\n      const ty = Math.sin(angle);\n      ctx.beginPath();\n      ctx.fillStyle = '#FDEBD3';\n      const toothWidth = 8;\n      const ToothOuter = r + 8;\n      ctx.moveTo(tx * (r + 2), ty * (r + 2));\n      ctx.lineTo(tx * (ToothOuter), ty * (ToothOuter));\n      ctx.lineTo(Math.cos(angle + 0.08) * (r + 2), Math.sin(angle + 0.08) * (r + 2));\n      ctx.closePath();\n      ctx.fill();\n    }\n    // gear circle\n    ctx.beginPath();\n    ctx.arc(0, 0, r, 0, Math.PI * 2);\n    ctx.fillStyle = '#FFFBF1';\n    ctx.fill();\n    ctx.lineWidth = 4;\n    ctx.strokeStyle = '#F2D6A8';\n    ctx.stroke();\n\n    // center hole\n    ctx.beginPath();\n    ctx.arc(0, 0, r * 0.42, 0, Math.PI * 2);\n    ctx.fillStyle = '#FFEFC9';\n    ctx.fill();\n\n    // number\n    ctx.fillStyle = '#6B4F23';\n    ctx.font = 'bold 22px Verdana, Arial';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(String(cog.value), 0, 0);\n\n    // subtle highlight\n    ctx.beginPath();\n    ctx.arc(-r * 0.3, -r * 0.4, r * 0.18, 0, Math.PI * 2);\n    ctx.fillStyle = 'rgba(255,255,255,0.35)';\n    ctx.fill();\n\n    // hover/focus ring\n    if (cog === selectedCog) {\n      ctx.beginPath();\n      ctx.arc(0, 0, r + 6, 0, Math.PI * 2);\n      ctx.strokeStyle = '#77C0FF';\n      ctx.lineWidth = 3;\n      ctx.stroke();\n    } else if (cog.hover) {\n      ctx.beginPath();\n      ctx.arc(0, 0, r + 4, 0, Math.PI * 2);\n      ctx.strokeStyle = '#BDE6FF';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  function drawPanelInfo() {\n    // Target display and instructions\n    const level = levels[levelIndex];\n    // target box\n    ctx.fillStyle = '#FFF7E8';\n    drawRoundedRect(36, 18, 300, 84, 10);\n    ctx.fillStyle = '#FFEDD8';\n    drawRoundedRect(42, 24, 288, 72, 8);\n\n    ctx.fillStyle = '#5B6C80';\n    ctx.font = '18px Verdana, Arial';\n    ctx.textAlign = 'left';\n    ctx.fillText('Machine Math Lab', 60, 46);\n\n    ctx.font = '32px Verdana, Arial';\n    ctx.fillStyle = '#4A4A4A';\n    ctx.textAlign = 'left';\n    ctx.fillText('Target: ' + level.target, 60, 82);\n\n    // Buttons drawn for sound on/off\n    ctx.fillStyle = '#FFFFFF';\n    drawRoundedRect(560, 18, 140, 36, 8);\n    ctx.fillStyle = audioEnabled ? '#DFF7E6' : '#FFF1F1';\n    drawRoundedRect(564, 22, 132, 28, 6);\n    ctx.fillStyle = audioEnabled ? '#197A3A' : '#9F2B2B';\n    ctx.font = '14px Verdana, Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText(audioEnabled ? 'Sound: ON (S to toggle)' : 'Sound: OFF (S to enable)', 640, 44);\n\n    // Mini instructions\n    ctx.fillStyle = '#63707B';\n    ctx.font = '12px Verdana, Arial';\n    ctx.textAlign = 'left';\n    ctx.fillText('Controls: Drag gears or use keyboard. Space to test. R to reset.', 60, 106);\n  }\n\n  function render() {\n    // Clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    drawMachineBackground();\n    drawPanelInfo();\n    drawSlots();\n\n    // Draw machine slider/pipe connection\n    ctx.beginPath();\n    ctx.moveTo(420, 220);\n    ctx.quadraticCurveTo(480, 260, 540, 240);\n    ctx.strokeStyle = '#DCEEFF';\n    ctx.lineWidth = 22;\n    ctx.lineCap = 'round';\n    ctx.stroke();\n\n    // Draw cogs\n    // update hover flags\n    for (const c of cogs) c.hover = (c === hoveredCog);\n    for (const c of cogs) {\n      drawCog(c);\n    }\n\n    // Draw message panel bottom\n    ctx.fillStyle = '#F6FAFF';\n    drawRoundedRect(28, 360, 664, 96, 10);\n    ctx.fillStyle = '#EAF4FF';\n    drawRoundedRect(34, 366, 652, 84, 8);\n    ctx.fillStyle = '#4C5E71';\n    ctx.font = '14px Verdana, Arial';\n    ctx.textAlign = 'left';\n    wrapText(ctx, message, 50, 398, 620, 18);\n\n    // Visual cue for audio state\n    ctx.save();\n    ctx.fillStyle = audioEnabled ? '#5DE08A' : '#FF9A9A';\n    ctx.beginPath();\n    ctx.arc(680, 428, 10, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n\n    // If hovered or selected, draw hint arrow\n    if (hoveredCog || selectedCog) {\n      const c = hoveredCog || selectedCog;\n      ctx.beginPath();\n      ctx.moveTo(c.x + c.radius + 12, c.y - c.radius - 8);\n      ctx.lineTo(c.x + c.radius + 36, c.y - c.radius - 26);\n      ctx.strokeStyle = '#9FCBFF';\n      ctx.lineWidth = 3;\n      ctx.stroke();\n    }\n  }\n\n  function renderVictory() {\n    // celebration screen\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    const grad = ctx.createLinearGradient(0, 0, WIDTH, HEIGHT);\n    grad.addColorStop(0, '#FFF7E9');\n    grad.addColorStop(1, '#E9FFF3');\n    ctx.fillStyle = grad;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    ctx.fillStyle = '#2E5D6E';\n    ctx.font = 'bold 36px Verdana, Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText('You fixed all the machines!', WIDTH / 2, HEIGHT / 2 - 30);\n    ctx.font = '20px Verdana, Arial';\n    ctx.fillText('Thanks for playing \u2014 Great job!', WIDTH / 2, HEIGHT / 2 + 8);\n\n    // Draw confetti gears\n    for (let i = 0; i < 12; i++) {\n      const x = 80 + i * 55;\n      const y = 320 + (i % 3) * 18;\n      drawTinyGear(x, y, (i % 4) + 3, ['#FFCC66', '#C8F2FF', '#FFECF0'][i % 3]);\n    }\n    // Stop background hum gradually\n    stopBackgroundHum();\n    updateLiveRegion('Victory! You fixed all the machines. Refresh to play again.');\n  }\n\n  function drawTinyGear(cx, cy, r, color) {\n    ctx.save();\n    ctx.translate(cx, cy);\n    ctx.rotate((cx + cy) * 0.02);\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    for (let i = 0; i < 8; i++) {\n      const angle = (i / 8) * Math.PI * 2;\n      ctx.lineTo(Math.cos(angle) * (r + 1.8), Math.sin(angle) * (r + 1.8));\n      ctx.lineTo(Math.cos(angle + 0.1) * r, Math.sin(angle + 0.1) * r);\n    }\n    ctx.closePath();\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(0, 0, r - 1, 0, Math.PI * 2);\n    ctx.fillStyle = '#FFF';\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function wrapText(context, text, x, y, maxWidth, lineHeight) {\n    const words = text.split(' ');\n    let line = '';\n    for (let n = 0; n < words.length; n++) {\n      const testLine = line + words[n] + ' ';\n      const metrics = context.measureText(testLine);\n      const testWidth = metrics.width;\n      if (testWidth > maxWidth && n > 0) {\n        context.fillText(line, x, y);\n        line = words[n] + ' ';\n        y += lineHeight;\n      } else {\n        line = testLine;\n      }\n    }\n    context.fillText(line, x, y);\n  }\n\n  // Accessibility live region update\n  function updateLiveRegion(text) {\n    if (!liveRegion) return;\n    liveRegion.textContent = text;\n  }\n\n  // Animation loop for gentle cog rotation\n  let lastTime = performance.now();\n  function animate(t) {\n    const dt = (t - lastTime) / 1000;\n    lastTime = t;\n    for (const c of cogs) {\n      // rotate slightly\n      c.rotation += dt * 0.6 * (c.value % 3 + 1) * 0.02;\n      // settle back if not dragging\n      if (!c.isDragging && !c.placedSlot) {\n        // subtle bob\n        c.y += Math.sin(t / 800 + c.value) * 0.02;\n      }\n    }\n    // update hover/selected visuals\n    render();\n    requestAnimationFrame(animate);\n  }\n\n  // Event listeners\n  canvas.addEventListener('pointerdown', pointerDown, { passive: false });\n  canvas.addEventListener('pointermove', pointerMove, { passive: false });\n  window.addEventListener('pointerup', pointerUp, { passive: false });\n\n  canvas.addEventListener('mousemove', (e) => {\n    // update hoveredCog\n    const p = getPointerPos(e);\n    let hover = null;\n    for (let i = cogs.length - 1; i >= 0; i--) {\n      const c = cogs[i];\n      const dx = p.x - c.x;\n      const dy = p.y - c.y;\n      if (Math.hypot(dx, dy) <= c.radius + 6) {\n        hover = c;\n        break;\n      }\n    }\n    hoveredCog = hover;\n    render();\n  });\n\n  canvas.addEventListener('keydown', keyDown, false);\n  // Also allow keyboard interaction on container\n  container.addEventListener('keydown', keyDown, false);\n\n  // Make sure audio toggles on click too (for mobile)\n  canvas.addEventListener('click', () => {\n    try {\n      resumeAudioOnGesture();\n    } catch (e) {\n      console.warn('Audio resume click error', e);\n    }\n  });\n\n  // Setup initial level and start\n  setupLevel(0);\n  requestAnimationFrame(animate);\n\n  // Provide some public error handling if audio unavailable\n  if (!initAudio()) {\n    // draw a small notice on canvas and update live region\n    message = 'Audio unavailable. The game will still work without sound. Click to attempt enabling sound.';\n    updateLiveRegion(message);\n    render();\n  }\n})();\n---\n",
  "improve_response_tokens": 19971,
  "formatted_code": true,
  "formatting_response_tokens": 22440,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}