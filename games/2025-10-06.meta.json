{
  "generated_date": "2025-10-06",
  "generated_timestamp": "2025-10-06T00:27:07.556257",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9880,
  "game_filename": "2025-10-06.js",
  "game_size_bytes": 30567,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Machine Math - Playable educational game for ages 7-9\n// Renders into the element with ID \"game-of-the-day-stage\"\n// All visuals drawn on canvas. Sounds via Web Audio API oscillators/filters.\n// Accessible: keyboard controls, aria-live text updates, audio visual cue.\n// No external assets. Modern, readable JS with comments and error handling.\n\n(() => {\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const ROUNDS = 6;\n  const MAX_PIECES = 6; // number of selectable pieces shown around machine\n\n  // Colors and style (calming, wacky)\n  const COLORS = {\n    bg: \"#E9F3F2\",\n    machine: \"#A7D3D1\",\n    accent: \"#F6C28B\",\n    gear: \"#C9E3E0\",\n    text: \"#233B3B\",\n    piece: \"#F7F6E7\",\n    pieceStroke: \"#4A6B6B\",\n    correctGlow: \"#B8F7D4\",\n    wrongGlow: \"#F7C0C0\",\n    slot: \"#EFF7F6\",\n    confetti: [\"#F6C28B\", \"#F7E9A1\", \"#A7D3D1\", \"#C9E3E0\", \"#D6B8F6\"],\n  };\n\n  // Get stage\n  const stage = document.getElementById(\"game-of-the-day-stage\");\n  if (!stage) {\n    console.error(\"Container with ID 'game-of-the-day-stage' not found.\");\n    return;\n  }\n\n  // Clear stage and set attributes for accessibility\n  stage.innerHTML = \"\";\n  stage.setAttribute(\"role\", \"application\");\n  stage.setAttribute(\"aria-label\", \"Machine Math: a math puzzle game for kids.\");\n  stage.style.touchAction = \"none\";\n\n  // Create aria-live region for descriptive text updates\n  const ariaLive = document.createElement(\"div\");\n  ariaLive.setAttribute(\"aria-live\", \"polite\");\n  ariaLive.style.position = \"absolute\";\n  ariaLive.style.left = \"-9999px\";\n  ariaLive.style.width = \"1px\";\n  ariaLive.style.height = \"1px\";\n  ariaLive.style.overflow = \"hidden\";\n  stage.appendChild(ariaLive);\n\n  // Create canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.width = WIDTH + \"px\";\n  canvas.style.height = HEIGHT + \"px\";\n  canvas.setAttribute(\"role\", \"img\");\n  canvas.setAttribute(\"aria-label\", \"Interactive machine math canvas.\");\n  canvas.tabIndex = 0; // focusable for keyboard controls\n  stage.appendChild(canvas);\n  const ctx = canvas.getContext(\"2d\");\n\n  // Audio setup with error handling\n  let audioContext = null;\n  let audioAvailable = false;\n  let bgGain = null;\n  let bgOsc = null;\n\n  async function initAudio() {\n    if (audioContext) return;\n    try {\n      const AC = window.AudioContext || window.webkitAudioContext;\n      if (!AC) throw new Error(\"Web Audio API not supported in this browser.\");\n      audioContext = new AC();\n\n      // Create gentle background hum using oscillator + lowpass + gain\n      bgOsc = audioContext.createOscillator();\n      const humFreq = 110; // gentle low hum\n      bgOsc.type = \"sine\";\n      bgOsc.frequency.value = humFreq;\n\n      const bgFilter = audioContext.createBiquadFilter();\n      bgFilter.type = \"lowpass\";\n      bgFilter.frequency.value = 400;\n\n      bgGain = audioContext.createGain();\n      bgGain.gain.value = 0.02; // gentle\n\n      bgOsc.connect(bgFilter).connect(bgGain).connect(audioContext.destination);\n\n      // Start background oscillator only when context is resumed/allowed\n      try {\n        if (audioContext.state === \"suspended\") {\n          await audioContext.resume();\n        }\n        bgOsc.start();\n      } catch (e) {\n        // If starting causes issues, report but continue without audio\n        console.warn(\"Audio could not be started immediately:\", e);\n      }\n\n      audioAvailable = true;\n      setAudioVisual(true);\n    } catch (err) {\n      console.warn(\"Audio initialization failed:\", err);\n      audioAvailable = false;\n      audioContext = null;\n      setAudioVisual(false);\n      // Provide text feedback for accessibility\n      announce(\"Audio not available. You can still play the game with on-screen cues.\");\n    }\n  }\n\n  // Toggle audio on/off visually\n  let audioOn = true;\n  function setAudioVisual(state) {\n    audioOn = !!state && audioAvailable;\n    // Draw will reflect audioOn via small speaker icon\n  }\n\n  // Play correct sound \u2014 pleasant chord using multiple oscillators\n  function playCorrect() {\n    if (!audioOn || !audioContext) return;\n    try {\n      const now = audioContext.currentTime;\n      const master = audioContext.createGain();\n      master.gain.value = 0.0001;\n      master.gain.setValueAtTime(0.0001, now);\n      master.gain.exponentialRampToValueAtTime(0.08, now + 0.02);\n      master.gain.exponentialRampToValueAtTime(0.0001, now + 0.8);\n      master.connect(audioContext.destination);\n\n      const freqs = [440, 660, 880]; // simple major-ish chord\n      freqs.forEach((f) => {\n        const osc = audioContext.createOscillator();\n        osc.type = Math.random() > 0.5 ? \"sine\" : \"triangle\";\n        osc.frequency.value = f + (Math.random() * 8 - 4);\n        const filt = audioContext.createBiquadFilter();\n        filt.type = \"lowpass\";\n        filt.frequency.value = 2000;\n        osc.connect(filt).connect(master);\n        osc.start(now);\n        osc.stop(now + 0.8 + Math.random() * 0.2);\n      });\n    } catch (e) {\n      console.warn(\"Play correct sound failed:\", e);\n    }\n  }\n\n  // Play incorrect sound \u2014 soft buzz\n  function playIncorrect() {\n    if (!audioOn || !audioContext) return;\n    try {\n      const now = audioContext.currentTime;\n      const osc = audioContext.createOscillator();\n      osc.type = \"sawtooth\";\n      osc.frequency.value = 220;\n      const gain = audioContext.createGain();\n      gain.gain.value = 0.0001;\n      gain.gain.setValueAtTime(0.0001, now);\n      gain.gain.exponentialRampToValueAtTime(0.05, now + 0.02);\n      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);\n      const filter = audioContext.createBiquadFilter();\n      filter.type = \"highpass\";\n      filter.frequency.value = 200;\n      osc.connect(filter).connect(gain).connect(audioContext.destination);\n      osc.start(now);\n      osc.frequency.setValueAtTime(220, now);\n      osc.frequency.exponentialRampToValueAtTime(880, now + 0.2);\n      osc.stop(now + 0.4);\n    } catch (e) {\n      console.warn(\"Play incorrect sound failed:\", e);\n    }\n  }\n\n  // Utility: announce text for screen readers\n  function announce(text) {\n    ariaLive.textContent = text;\n  }\n\n  // Game state\n  const state = {\n    round: 0,\n    roundsTotal: ROUNDS,\n    puzzles: [], // each puzzle: {target, op, slots, choices}\n    selectedPieceIndex: 0,\n    chosenSlot: 0,\n    placed: [], // values in slots or null\n    pieces: [], // pieces array with {value,x,y,r,dragging}\n    draggingPiece: null,\n    solvedRounds: 0,\n    feedback: null, // {type: 'correct'|'wrong', t: timestamp}\n    confetti: [],\n    finished: false,\n    awaitingAudioGesture: true, // encourage first gesture to init audio\n  };\n\n  // Generate puzzles\n  function generatePuzzles() {\n    const puzzles = [];\n    const ops = [\"+\",\"-\"]; // addition and subtraction, kid-friendly\n    for (let i = 0; i < ROUNDS; i++) {\n      // Alternate ops for variety; ensure subtraction has positive answers\n      const op = i % 3 === 2 ? \"-\" : \"+\";\n      if (op === \"+\") {\n        // pick two or three numbers depending on difficulty\n        const slotCount = i < 3 ? 2 : 3;\n        const values = [];\n        for (let s = 0; s < slotCount; s++) {\n          values.push(randInt(1, 9));\n        }\n        const target = values.reduce((a,b)=>a+b,0);\n        puzzles.push({op, slots: slotCount, solution: values, target});\n      } else {\n        // subtraction: pick two numbers where minuend > subtrahend\n        const a = randInt(5, 12);\n        const b = randInt(1, Math.min(8, a-1));\n        const target = a - b;\n        puzzles.push({op, slots: 2, solution: [a,b], target});\n      }\n    }\n    return puzzles;\n  }\n\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  // Initialize puzzle pieces and placement for current round\n  function startRound() {\n    const idx = state.round;\n    if (idx >= state.roundsTotal) {\n      // all done\n      state.finished = true;\n      announce(\"All machines fixed! Great job!\");\n      startConfetti();\n      return;\n    }\n    const p = state.puzzles[idx];\n    state.placed = new Array(p.slots).fill(null);\n    state.selectedPieceIndex = 0;\n    state.chosenSlot = 0;\n    state.feedback = null;\n\n    // Build pieces: include solution numbers and distractors (small numbers)\n    const pieces = [];\n    // Solution numbers for addition/subtraction might be larger than 9; split if needed\n    const baseSolution = p.solution.slice();\n    // For subtraction, solution is [a,b] where a might be >9; present pieces as numbers maybe >9 allowed\n    baseSolution.forEach((v) => pieces.push(v));\n    // Add distractors until we have MAX_PIECES\n    while (pieces.length < MAX_PIECES) {\n      let cand;\n      if (p.op === \"-\") {\n        // encourage numbers around target\n        cand = randInt(1, Math.max(9, Math.max(...p.solution)));\n      } else {\n        cand = randInt(1, 9);\n      }\n      // avoid exact copy of solution more times than needed\n      if (pieces.filter(x=>x===cand).length > 2) continue;\n      pieces.push(cand);\n    }\n    // Shuffle pieces\n    shuffleArray(pieces);\n\n    // Layout pieces in a semicircle bottom-left\n    const centerX = 360;\n    const centerY = 380;\n    const radius = 220;\n    const angleStart = Math.PI * 0.25;\n    const angleEnd = Math.PI * 0.75;\n    const pieceObjs = [];\n    const r = 26;\n    for (let i = 0; i < pieces.length; i++) {\n      const t = i / (pieces.length - 1 || 1);\n      const angle = angleStart + t * (angleEnd - angleStart);\n      const x = centerX - Math.cos(angle) * radius;\n      const y = centerY - Math.sin(angle) * (radius * 0.6) + 40;\n      pieceObjs.push({\n        id: \"p\" + i,\n        value: pieces[i],\n        x, y, r,\n        homeX: x, homeY: y,\n        dragging: false,\n        placedInSlot: -1,\n      });\n    }\n\n    state.pieces = pieceObjs;\n    state.draggingPiece = null;\n    announce(`Round ${idx+1}. Machine asks for ${p.op} to make ${p.target}. Use mouse or keyboard to place pieces.`);\n  }\n\n  // Shuffle helper\n  function shuffleArray(arr) {\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n  }\n\n  // Main initialization\n  function init() {\n    state.puzzles = generatePuzzles();\n    state.round = 0;\n    state.solvedRounds = 0;\n    state.finished = false;\n    state.confetti = [];\n    generateControls(); // keyboard & pointer handlers\n    startRound();\n    lastTime = performance.now();\n    requestAnimationFrame(loop);\n  }\n\n  // Game input handlers\n  function generateControls() {\n    // Pointer events (mouse/touch)\n    canvas.addEventListener(\"pointerdown\", onPointerDown);\n    window.addEventListener(\"pointermove\", onPointerMove);\n    window.addEventListener(\"pointerup\", onPointerUp);\n    canvas.addEventListener(\"click\", onCanvasClick);\n\n    // Keyboard controls\n    canvas.addEventListener(\"keydown\", (e) => {\n      // Initialize audio on first gesture\n      if (state.awaitingAudioGesture) {\n        initAudio().catch(()=>{});\n        state.awaitingAudioGesture = false;\n      }\n      const key = e.key;\n      if (state.finished) {\n        if (key === \"Enter\") {\n          // restart\n          restartGame();\n        }\n        if (key.toLowerCase() === \"m\") {\n          toggleAudio();\n        }\n        return;\n      }\n      // Navigation among pieces: left/right arrows move selection\n      if (key === \"ArrowLeft\") {\n        e.preventDefault();\n        state.selectedPieceIndex = (state.selectedPieceIndex - 1 + state.pieces.length) % state.pieces.length;\n      } else if (key === \"ArrowRight\") {\n        e.preventDefault();\n        state.selectedPieceIndex = (state.selectedPieceIndex + 1) % state.pieces.length;\n      } else if (key === \"ArrowUp\") {\n        e.preventDefault();\n        state.chosenSlot = (state.chosenSlot - 1 + state.placed.length) % state.placed.length;\n      } else if (key === \"ArrowDown\") {\n        e.preventDefault();\n        state.chosenSlot = (state.chosenSlot + 1) % state.placed.length;\n      } else if (key === \"Enter\" || key === \" \") {\n        e.preventDefault();\n        // Place selected piece into chosen slot (or remove if already placed)\n        const piece = state.pieces[state.selectedPieceIndex];\n        if (!piece) return;\n        if (piece.placedInSlot >= 0) {\n          // remove\n          const oldSlot = piece.placedInSlot;\n          piece.placedInSlot = -1;\n          state.placed[oldSlot] = null;\n          announce(`Removed piece ${piece.value} from slot ${oldSlot+1}.`);\n        } else {\n          // if slot occupied, swap or reject; we'll swap\n          const slot = state.chosenSlot;\n          // find placed piece in that slot\n          const otherIdx = state.pieces.findIndex(pp => pp.placedInSlot === slot);\n          if (otherIdx >= 0) {\n            state.pieces[otherIdx].placedInSlot = -1;\n          }\n          piece.placedInSlot = slot;\n          state.placed[slot] = piece.value;\n          announce(`Placed piece ${piece.value} into slot ${slot+1}.`);\n        }\n      } else if (key === \"Backspace\" || key === \"Delete\") {\n        e.preventDefault();\n        // remove any piece from chosen slot\n        const slot = state.chosenSlot;\n        const idx = state.pieces.findIndex(pp => pp.placedInSlot === slot);\n        if (idx >= 0) {\n          const val = state.pieces[idx].value;\n          state.pieces[idx].placedInSlot = -1;\n          state.placed[slot] = null;\n          announce(`Removed piece ${val} from slot ${slot+1}.`);\n        }\n      } else if (key.toLowerCase() === \"m\") {\n        toggleAudio();\n      } else if (key === \"s\") {\n        // Submit attempt\n        attemptSolve();\n      }\n    });\n\n    // Focus canvas for keyboard\n    canvas.addEventListener(\"focus\", () => {\n      // ensure audio init on focus if first gesture pending\n      if (state.awaitingAudioGesture) {\n        initAudio().catch(()=>{});\n        state.awaitingAudioGesture = false;\n      }\n    });\n\n    // Also add pointer event to init audio on first gesture\n    canvas.addEventListener(\"pointerdown\", async () => {\n      if (state.awaitingAudioGesture) {\n        try { await initAudio(); } catch(e){/*ignore*/ }\n        state.awaitingAudioGesture = false;\n      }\n    });\n  }\n\n  // Pointer handlers for dragging\n  function onPointerDown(e) {\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    // Check if clicked on audio icon area (top-right)\n    if (x > WIDTH - 60 && y < 40) {\n      toggleAudio();\n      return;\n    }\n    // Check pieces\n    for (let i = 0; i < state.pieces.length; i++) {\n      const p = state.pieces[i];\n      if (distance(p.x, p.y, x, y) <= p.r + 6) {\n        p.dragging = true;\n        state.draggingPiece = p;\n        p.offsetX = x - p.x;\n        p.offsetY = y - p.y;\n        canvas.setPointerCapture(e.pointerId);\n        return;\n      }\n    }\n    // Check if clicked on submit button area\n    if (x > 560 && x < 700 && y > 380 && y < 440) {\n      attemptSolve();\n    }\n  }\n\n  function onPointerMove(e) {\n    if (!state.draggingPiece) return;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    state.draggingPiece.x = x - state.draggingPiece.offsetX;\n    state.draggingPiece.y = y - state.draggingPiece.offsetY;\n  }\n\n  function onPointerUp(e) {\n    if (!state.draggingPiece) return;\n    const p = state.draggingPiece;\n    p.dragging = false;\n    // If released over a slot area, snap into slot\n    const slotIdx = slotIndexAtPoint(p.x, p.y);\n    if (slotIdx >= 0) {\n      // if another piece is in that slot, send it home\n      const other = state.pieces.find(pp => pp.placedInSlot === slotIdx);\n      if (other) other.placedInSlot = -1;\n      p.placedInSlot = slotIdx;\n      state.placed[slotIdx] = p.value;\n      announce(`Placed piece ${p.value} into slot ${slotIdx+1}.`);\n    } else {\n      // return to home spot\n      p.x = p.homeX;\n      p.y = p.homeY;\n      if (p.placedInSlot >= 0) {\n        // if it was placed in a slot but dragged out, remove\n        state.placed[p.placedInSlot] = null;\n        p.placedInSlot = -1;\n      }\n    }\n    state.draggingPiece = null;\n  }\n\n  function onCanvasClick(e) {\n    // Click on a piece toggles selection; click on piece while not dragging toggles place in chosen slot\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    for (let i = 0; i < state.pieces.length; i++) {\n      const p = state.pieces[i];\n      if (distance(p.x, p.y, x, y) <= p.r + 6) {\n        state.selectedPieceIndex = i;\n        // click places into current chosen slot (swap if occupied)\n        const slot = state.chosenSlot;\n        const otherIdx = state.pieces.findIndex(pp => pp.placedInSlot === slot);\n        if (p.placedInSlot >= 0) {\n          // remove\n          state.placed[p.placedInSlot] = null;\n          p.placedInSlot = -1;\n          announce(`Removed piece ${p.value}.`);\n        } else {\n          if (otherIdx >= 0) {\n            state.pieces[otherIdx].placedInSlot = -1;\n          }\n          p.placedInSlot = slot;\n          state.placed[slot] = p.value;\n          announce(`Placed piece ${p.value} in slot ${slot+1}.`);\n        }\n        return;\n      }\n    }\n    // Click on submit area tries solve\n    if (x > 560 && x < 700 && y > 380 && y < 440) {\n      attemptSolve();\n    }\n    // Click on machine slots to change chosen slot\n    const sl = slotIndexAtPoint(x, y);\n    if (sl >= 0) {\n      state.chosenSlot = sl;\n      announce(`Selected slot ${sl+1}.`);\n    }\n  }\n\n  function slotIndexAtPoint(x, y) {\n    // compute slot positions and test\n    const slotPositions = getSlotPositions();\n    for (let i = 0; i < slotPositions.length; i++) {\n      const sp = slotPositions[i];\n      if (x >= sp.x - sp.w/2 && x <= sp.x + sp.w/2 && y >= sp.y - sp.h/2 && y <= sp.y + sp.h/2) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  // Attempt to check placed pieces\n  function attemptSolve() {\n    if (state.finished) return;\n    const puzzle = state.puzzles[state.round];\n    // Check if all slots filled\n    if (state.placed.some(v => v === null)) {\n      announce(\"Fill all slots before submitting.\");\n      state.feedback = {type: \"wrong\", t: performance.now()};\n      playIncorrect();\n      return;\n    }\n    const values = state.placed.slice();\n    let result;\n    if (puzzle.op === \"+\") {\n      result = values.reduce((a,b)=>a+b,0);\n    } else {\n      // subtraction: assume two slots, compute first - second - (third?) For safety, compute left-to-right\n      result = values.reduce((a,b)=>a-b);\n    }\n    if (result === puzzle.target) {\n      // correct\n      state.feedback = {type: \"correct\", t: performance.now()};\n      playCorrect();\n      announce(\"Correct! Machine is fixed.\");\n      state.solvedRounds++;\n      // animate solved machine then next round after short delay\n      setTimeout(() => {\n        state.round++;\n        if (state.round >= state.roundsTotal) {\n          state.finished = true;\n          announce(\"All machines fixed! You win!\");\n          startConfetti();\n        } else {\n          startRound();\n        }\n      }, 1100);\n    } else {\n      // incorrect\n      state.feedback = {type: \"wrong\", t: performance.now()};\n      playIncorrect();\n      announce(`Not quite. Try again. Your result was ${result}.`);\n    }\n  }\n\n  // Toggle audio on/off\n  function toggleAudio() {\n    if (!audioAvailable) {\n      announce(\"Audio not available on this device.\");\n      return;\n    }\n    audioOn = !audioOn;\n    if (bgGain) {\n      bgGain.gain.value = audioOn ? 0.02 : 0.00001;\n    }\n    setAudioVisual(audioOn);\n    announce(audioOn ? \"Audio on.\" : \"Audio muted.\");\n  }\n\n  // Utility: distance\n  function distance(x1,y1,x2,y2) {\n    const dx = x1 - x2;\n    const dy = y1 - y2;\n    return Math.sqrt(dx*dx + dy*dy);\n  }\n\n  // Drawing helpers\n  function drawRoundedRect(ctx, x,y,w,h,r) {\n    ctx.beginPath();\n    ctx.moveTo(x+r, y);\n    ctx.arcTo(x+w, y, x+w, y+h, r);\n    ctx.arcTo(x+w, y+h, x, y+h, r);\n    ctx.arcTo(x, y+h, x, y, r);\n    ctx.arcTo(x, y, x+w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  // Draw gear (wacky element) at (cx,cy)\n  function drawGear(cx, cy, outerR, teeth, innerR, color) {\n    ctx.save();\n    ctx.translate(cx, cy);\n    ctx.rotate(Math.sin((Date.now()/1000)+cx+cy) * 0.05);\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    for (let i = 0; i < teeth; i++) {\n      const angle = (i / teeth) * Math.PI * 2;\n      const angle2 = ((i + 0.5) / teeth) * Math.PI * 2;\n      const x1 = Math.cos(angle) * outerR;\n      const y1 = Math.sin(angle) * outerR;\n      const x2 = Math.cos(angle2) * (outerR - 8);\n      const y2 = Math.sin(angle2) * (outerR - 8);\n      if (i === 0) ctx.moveTo(x1, y1);\n      ctx.lineTo(x1, y1);\n      ctx.lineTo(x2, y2);\n    }\n    ctx.closePath();\n    ctx.fill();\n    // inner circle\n    ctx.fillStyle = \"#fff\";\n    ctx.beginPath();\n    ctx.arc(0,0,innerR,0,Math.PI*2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  // Get slot positions for current machine\n  function getSlotPositions() {\n    const baseX = 360;\n    const baseY = 210;\n    const spacing = 110;\n    const p = state.puzzles[state.round];\n    const slots = [];\n    const total = p.slots;\n    const startX = baseX - (total - 1) * spacing / 2;\n    for (let i = 0; i < total; i++) {\n      slots.push({x: startX + i * spacing, y: baseY + 10, w: 84, h: 84});\n    }\n    return slots;\n  }\n\n  // Confetti for win\n  function startConfetti() {\n    state.confetti = [];\n    for (let i = 0; i < 60; i++) {\n      state.confetti.push({\n        x: randInt(0, WIDTH),\n        y: randInt(-200, 0),\n        vx: (Math.random() - 0.5) * 1.5,\n        vy: 1 + Math.random()*2,\n        size: randInt(6, 12),\n        color: COLORS.confetti[Math.floor(Math.random()*COLORS.confetti.length)],\n        rot: Math.random()*Math.PI,\n        angVel: (Math.random() - 0.5) * 0.1,\n      });\n    }\n  }\n\n  // Restart game\n  function restartGame() {\n    state.puzzles = generatePuzzles();\n    state.round = 0;\n    state.solvedRounds = 0;\n    state.finished = false;\n    startRound();\n    announce(\"Game restarted. Fix the machines!\");\n  }\n\n  // Rendering loop\n  let lastTime = 0;\n  function loop(now) {\n    const dt = (now - lastTime) / 1000;\n    lastTime = now;\n    update(dt);\n    render();\n    requestAnimationFrame(loop);\n  }\n\n  function update(dt) {\n    // Animate confetti\n    if (state.confetti.length) {\n      state.confetti.forEach(c => {\n        c.x += c.vx;\n        c.y += c.vy;\n        c.rot += c.angVel;\n        if (c.y > HEIGHT + 20) {\n          c.y = -20;\n          c.x = randInt(0, WIDTH);\n        }\n      });\n    }\n  }\n\n  function render() {\n    // Clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // Background\n    ctx.fillStyle = COLORS.bg;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Decorative wavy stripes (calming)\n    ctx.save();\n    ctx.fillStyle = \"rgba(167,211,209,0.12)\";\n    for (let i = 0; i < 3; i++) {\n      ctx.beginPath();\n      ctx.ellipse(140 + i*220, 130 + Math.sin(Date.now()/1000 + i)*6, 260, 80, Math.sin(i)*0.2, 0, Math.PI*2);\n      ctx.fill();\n    }\n    ctx.restore();\n\n    // Draw machine body\n    const machineX = 160;\n    const machineY = 120;\n    ctx.save();\n    ctx.fillStyle = COLORS.machine;\n    drawRoundedRect(ctx, machineX, machineY, 380, 220, 20);\n\n    // Machine faceplate details\n    ctx.fillStyle = COLORS.slot;\n    drawRoundedRect(ctx, machineX + 16, machineY + 16, 350, 70, 12);\n    ctx.fillStyle = COLORS.accent;\n    drawRoundedRect(ctx, machineX + 20, machineY + 24, 120, 42, 10);\n    ctx.fillStyle = \"#ffffff88\";\n    ctx.fillRect(machineX + 160, machineY + 24, 140, 42);\n\n    ctx.restore();\n\n    // Decorative gears\n    drawGear(110, 100, 32, 10, 12, COLORS.gear);\n    drawGear(610, 80, 20, 8, 8, COLORS.gear);\n    drawGear(620, 260, 28, 9, 10, COLORS.gear);\n\n    // Machine display: target + operation\n    const puzzle = state.puzzles[state.round];\n    ctx.fillStyle = COLORS.text;\n    ctx.font = \"22px sans-serif\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(\"Machine Goal:\", machineX + 24, machineY + 48);\n    ctx.font = \"bold 36px sans-serif\";\n    ctx.fillStyle = COLORS.text;\n    ctx.fillText(`${puzzle.op}  \u2192  ${puzzle.target}`, machineX + 160, machineY + 56);\n\n    // Draw conveyor belt / slot area\n    ctx.fillStyle = \"#DDEDEB\";\n    drawRoundedRect(ctx, machineX + 40, machineY + 110, 300, 84, 12);\n\n    // Draw slots\n    const slots = getSlotPositions();\n    for (let i = 0; i < slots.length; i++) {\n      const sp = slots[i];\n      ctx.save();\n      // Glow if chosen\n      if (state.chosenSlot === i) {\n        ctx.shadowColor = state.feedback && state.feedback.type === \"correct\" ? COLORS.correctGlow : \"#ffffffAA\";\n        ctx.shadowBlur = 12;\n      } else {\n        ctx.shadowBlur = 0;\n      }\n      // Fill slot background\n      ctx.fillStyle = COLORS.slot;\n      drawRoundedRect(ctx, sp.x - sp.w/2, sp.y - sp.h/2, sp.w, sp.h, 10);\n      // If placed show piece inside\n      const placedValue = state.placed[i];\n      if (placedValue !== null && placedValue !== undefined) {\n        ctx.fillStyle = COLORS.piece;\n        drawRoundedRect(ctx, sp.x - sp.w/2 + 6, sp.y - sp.h/2 + 6, sp.w - 12, sp.h - 12, 8);\n        ctx.strokeStyle = COLORS.pieceStroke;\n        ctx.lineWidth = 2;\n        ctx.stroke();\n        ctx.fillStyle = COLORS.text;\n        ctx.font = \"bold 28px sans-serif\";\n        ctx.textAlign = \"center\";\n        ctx.fillText(String(placedValue), sp.x, sp.y + 10);\n      } else {\n        ctx.fillStyle = \"#FFFFFF22\";\n        ctx.beginPath();\n        ctx.arc(sp.x, sp.y, 8, 0, Math.PI*2);\n        ctx.fill();\n        ctx.fillStyle = \"#5D7D7D44\";\n        ctx.font = \"14px sans-serif\";\n        ctx.textAlign = \"center\";\n        ctx.fillText(\"drop\", sp.x, sp.y + 6);\n      }\n      ctx.restore();\n    }\n\n    // Draw pieces\n    state.pieces.forEach((p, idx) => {\n      ctx.save();\n      // Shadow or glow if selected\n      if (idx === state.selectedPieceIndex) {\n        ctx.shadowColor = \"#FFFFFF88\";\n        ctx.shadowBlur = 12;\n      } else {\n        ctx.shadowBlur = 0;\n      }\n      ctx.fillStyle = COLORS.piece;\n      ctx.beginPath();\n      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);\n      ctx.fill();\n      ctx.lineWidth = 2;\n      ctx.strokeStyle = COLORS.pieceStroke;\n      ctx.stroke();\n\n      // Number\n      ctx.fillStyle = COLORS.text;\n      ctx.font = \"bold 18px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(String(p.value), p.x, p.y + 6);\n\n      // If placed, draw small tag\n      if (p.placedInSlot >= 0) {\n        ctx.fillStyle = \"#7FD7C6\";\n        ctx.beginPath();\n        ctx.arc(p.x + p.r - 6, p.y - p.r + 6, 8, 0, Math.PI*2);\n        ctx.fill();\n      }\n\n      ctx.restore();\n    });\n\n    // Draw submit button\n    ctx.save();\n    ctx.fillStyle = \"#FFFFFF\";\n    drawRoundedRect(ctx, 560, 380, 140, 60, 12);\n    ctx.strokeStyle = \"#7DA59E\";\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    ctx.fillStyle = \"#2E4D4C\";\n    ctx.font = \"bold 20px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"Fix Machine\", 630, 418);\n    ctx.restore();\n\n    // Draw HUD: round, score, instructions\n    ctx.fillStyle = COLORS.text;\n    ctx.font = \"16px sans-serif\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(`Round ${state.round + 1} / ${state.roundsTotal}`, 20, 28);\n    ctx.fillText(`Solved: ${state.solvedRounds}`, 20, 52);\n\n    // Small instructions\n    ctx.font = \"13px sans-serif\";\n    ctx.fillStyle = \"#335353\";\n    ctx.fillText(\"Use mouse drag or keyboard arrows + Enter to place pieces. Press 'S' to submit.\", 20, HEIGHT - 20);\n\n    // Audio icon and visual cue\n    drawAudioIcon(WIDTH - 56, 12, audioOn);\n\n    // Feedback overlay (correct/wrong)\n    if (state.feedback) {\n      const age = (performance.now() - state.feedback.t) / 1000;\n      if (age < 1.0) {\n        ctx.save();\n        ctx.globalAlpha = 0.9 - age;\n        if (state.feedback.type === \"correct\") {\n          ctx.fillStyle = COLORS.correctGlow;\n        } else {\n          ctx.fillStyle = COLORS.wrongGlow;\n        }\n        ctx.fillRect(0, 0, WIDTH, HEIGHT);\n        ctx.restore();\n      }\n    }\n\n    // Confetti if finished\n    if (state.finished) {\n      ctx.save();\n      state.confetti.forEach(c => {\n        ctx.fillStyle = c.color;\n        ctx.beginPath();\n        ctx.ellipse(c.x, c.y, c.size, c.size*0.6, c.rot, 0, Math.PI*2);\n        ctx.fill();\n      });\n      ctx.restore();\n\n      // Victory text\n      ctx.save();\n      ctx.fillStyle = \"#1f3a3a\";\n      ctx.font = \"bold 42px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(\"Machines Fixed! Well done!\", WIDTH/2, 120);\n      ctx.font = \"18px sans-serif\";\n      ctx.fillText(\"Press Enter to play again. Press M to toggle audio.\", WIDTH/2, 160);\n      ctx.restore();\n    }\n\n    // Draw small accessibility cue: text of current selected piece and slot\n    ctx.save();\n    ctx.fillStyle = \"#334747\";\n    ctx.font = \"13px sans-serif\";\n    ctx.textAlign = \"left\";\n    const sel = state.pieces[state.selectedPieceIndex];\n    ctx.fillText(`Selected piece: ${sel ? sel.value : \"-\"} \u2014 Slot: ${state.chosenSlot+1}`, 20, HEIGHT - 40);\n    ctx.restore();\n  }\n\n  function drawAudioIcon(x, y, on) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.strokeStyle = \"#2F4D4D\";\n    ctx.fillStyle = on ? \"#7FD7C6\" : \"#D7EDEC\";\n    ctx.lineWidth = 2;\n    // speaker body\n    ctx.beginPath();\n    ctx.moveTo(-12, -8);\n    ctx.lineTo(-4, -8);\n    ctx.lineTo(0, -12);\n    ctx.lineTo(8, -12);\n    ctx.lineTo(8, 12);\n    ctx.lineTo(0, 12);\n    ctx.lineTo(-4, 8);\n    ctx.lineTo(-12, 8);\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n    // sound waves\n    if (audioAvailable) {\n      ctx.beginPath();\n      ctx.arc(14, 0, 8, -0.6, 0.6);\n      ctx.strokeStyle = on ? \"#2F4D4D\" : \"#B0CFCF\";\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.arc(14, 0, 12, -0.6, 0.6);\n      ctx.strokeStyle = on ? \"#2F4D4D\" : \"#B0CFCF\";\n      ctx.stroke();\n    } else {\n      // show cross for unavailable\n      ctx.strokeStyle = \"#E06A6A\";\n      ctx.beginPath();\n      ctx.moveTo(12, -8);\n      ctx.lineTo(20, 0);\n      ctx.moveTo(20, -8);\n      ctx.lineTo(12, 0);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  // Start audio on first user gesture attempt (to cope with autoplay restrictions)\n  canvas.addEventListener(\"pointerdown\", async () => {\n    if (state.awaitingAudioGesture) {\n      try {\n        await initAudio();\n      } catch (e) {\n        console.warn(e);\n      }\n      state.awaitingAudioGesture = false;\n    }\n  }, {once: true});\n\n  // Start the game\n  init();\n\n})();\n---\n",
  "improve_response_tokens": 19872,
  "formatted_code": true,
  "formatting_response_tokens": 21576,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}