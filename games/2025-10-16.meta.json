{
  "generated_date": "2025-10-16",
  "generated_timestamp": "2025-10-16T00:28:42.438329",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9078,
  "game_filename": "2025-10-16.js",
  "game_size_bytes": 25596,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Drone Math Adventure\n  // Designed for children ages 7-9. Renders inside element with ID \"game-of-the-day-stage\".\n  // All visuals are canvas-drawn. Sounds using Web Audio API oscillators/filters.\n  // Goal: Answer 10 questions correctly. 3 wrong answers = Game Over.\n  // Controls: Mouse or number keys 1-4 to pick answers. M to toggle audio. R to restart.\n\n  // Retrieve container\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Container element with ID \"game-of-the-day-stage\" not found.');\n    return;\n  }\n\n  // Clear container and create canvas\n  container.innerHTML = '';\n  const canvas = document.createElement('canvas');\n  canvas.width = 720;\n  canvas.height = 480;\n  canvas.setAttribute('role', 'img');\n  canvas.setAttribute(\n    'aria-label',\n    'Drone Math Adventure. Answer math questions by clicking or pressing keys 1 to 4. Press M to toggle audio. Press R to restart.'\n  );\n  canvas.style.display = 'block';\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d', { alpha: false });\n\n  // Layout constants and reserved zones to prevent overlap\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const PADDING = 12; // min 10px padding\n  const TOP_UI_HEIGHT = 56;\n  const BOTTOM_UI_HEIGHT = 96;\n  const GAME_AREA = {\n    x: 0,\n    y: TOP_UI_HEIGHT,\n    w: WIDTH,\n    h: HEIGHT - TOP_UI_HEIGHT - BOTTOM_UI_HEIGHT,\n  };\n\n  // Fonts\n  const FONT_BODY = '16px sans-serif';\n  const FONT_IMPORTANT = '22px sans-serif';\n  const FONT_TITLE = '28px sans-serif';\n\n  // Game parameters\n  const TARGET_CORRECT = 10;\n  const MAX_WRONG = 3;\n\n  // State\n  let correctCount = 0;\n  let wrongCount = 0;\n  let currentQuestion = null;\n  let choices = []; // [{text, x,y,r}]\n  let gameState = 'start'; // 'start', 'playing', 'victory', 'gameover'\n  let focusedChoiceIndex = 0;\n  let lastAnswerResult = null; // 'correct' | 'wrong' | null\n  let shakeTime = 0;\n  let droneX = WIDTH / 2;\n  let droneY = TOP_UI_HEIGHT + GAME_AREA.h - 60;\n  let droneTargetX = droneX;\n  let droneTargetY = droneY;\n  let bgHumOn = true;\n  let lastTick = performance.now();\n\n  // Audio setup with error handling\n  let audioCtx = null;\n  let bgGain = null;\n  let bgOsc = null;\n\n  function createAudioContextSafe() {\n    try {\n      const Ctx = window.AudioContext || window.webkitAudioContext;\n      if (!Ctx) return null;\n      const ac = new Ctx();\n      // Initialize background hum\n      const gain = ac.createGain();\n      gain.gain.value = 0.03; // gentle\n      gain.connect(ac.destination);\n      const osc = ac.createOscillator();\n      osc.type = 'sine';\n      osc.frequency.value = 110;\n      const filter = ac.createBiquadFilter();\n      filter.type = 'lowpass';\n      filter.frequency.value = 300;\n      osc.connect(filter);\n      filter.connect(gain);\n      osc.start();\n      audioCtx = ac;\n      bgGain = gain;\n      bgOsc = osc;\n      return ac;\n    } catch (e) {\n      console.warn('AudioContext creation failed:', e);\n      return null;\n    }\n  }\n\n  audioCtx = createAudioContextSafe();\n  if (!audioCtx) {\n    bgHumOn = false;\n  }\n\n  // Sound effects via oscillators + envelope\n  function playTone({ frequency = 440, duration = 0.2, type = 'sine', volume = 0.08, detune = 0 } = {}) {\n    if (!audioCtx || !bgGain) return;\n    try {\n      const ac = audioCtx;\n      const now = ac.currentTime;\n      const osc = ac.createOscillator();\n      const gain = ac.createGain();\n      const filter = ac.createBiquadFilter();\n      osc.type = type;\n      osc.frequency.value = frequency;\n      osc.detune.value = detune;\n      filter.type = 'lowpass';\n      filter.frequency.value = Math.max(300, frequency * 2);\n      gain.gain.value = 0;\n      osc.connect(filter);\n      filter.connect(gain);\n      gain.connect(ac.destination);\n      osc.start(now);\n      // Envelope\n      gain.gain.cancelScheduledValues(now);\n      gain.gain.setValueAtTime(0, now);\n      gain.gain.linearRampToValueAtTime(volume, now + 0.01);\n      gain.gain.exponentialRampToValueAtTime(0.001, now + duration);\n      osc.stop(now + duration + 0.02);\n    } catch (e) {\n      console.warn('Audio playTone error:', e);\n    }\n  }\n\n  function playCorrectSound() {\n    if (!audioCtx || !bgGain) return;\n    // joyful ascending chime\n    playTone({ frequency: 660, duration: 0.08, type: 'sine', volume: 0.06 });\n    setTimeout(() => playTone({ frequency: 880, duration: 0.12, type: 'sine', volume: 0.05 }), 90);\n    setTimeout(() => playTone({ frequency: 1100, duration: 0.16, type: 'triangle', volume: 0.04 }), 210);\n  }\n\n  function playWrongSound() {\n    if (!audioCtx || !bgGain) return;\n    // low buzz\n    playTone({ frequency: 200, duration: 0.18, type: 'sawtooth', volume: 0.08 });\n    setTimeout(() => playTone({ frequency: 140, duration: 0.12, type: 'sawtooth', volume: 0.06 }), 120);\n  }\n\n  function toggleBackgroundHum(on) {\n    if (!audioCtx || !bgGain) return;\n    try {\n      bgGain.gain.setTargetAtTime(on ? 0.03 : 0, audioCtx.currentTime, 0.05);\n      bgHumOn = on;\n    } catch (e) {\n      console.warn('toggleBackgroundHum error:', e);\n    }\n  }\n\n  // Math question generator - simple addition/subtraction up to 20\n  function generateQuestion() {\n    const a = Math.floor(Math.random() * 11); // 0..10\n    const b = Math.floor(Math.random() * 11); // 0..10\n    const add = Math.random() < 0.6; // more addition\n    const op = add ? '+' : '-';\n    let questionText = `${a} ${op} ${b}`;\n    let answer = add ? a + b : a - b;\n    // ensure non-negative answer for this age\n    if (answer < 0) {\n      // flip to addition\n      questionText = `${a + b} - ${a}`;\n      answer = b;\n    }\n    // generate 3 distractors within small range, ensure unique\n    const distractors = new Set();\n    while (distractors.size < 3) {\n      let delta = Math.floor(Math.random() * 7) - 3; // -3..3\n      if (delta === 0) delta = 4; // avoid correct\n      let cand = answer + delta;\n      if (cand < 0) cand = Math.abs(cand) + 1;\n      distractors.add(cand);\n    }\n    const options = [answer, ...Array.from(distractors)];\n    // shuffle\n    for (let i = options.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [options[i], options[j]] = [options[j], options[i]];\n    }\n    currentQuestion = { text: questionText, answer };\n    choices = []; // place four circular choice buttons inside GAME_AREA, non-overlapping\n    const positions = [];\n    const cols = 2;\n    const rows = 2;\n    const marginX = 40;\n    const marginY = 20;\n    const cellW = (GAME_AREA.w - marginX * 2) / cols;\n    const cellH = (GAME_AREA.h - marginY * 2) / rows;\n    for (let r = 0; r < rows; r++) {\n      for (let c = 0; c < cols; c++) {\n        const cx = marginX + c * cellW + cellW / 2;\n        const cy = GAME_AREA.y + marginY + r * cellH + cellH / 2;\n        positions.push({ x: cx, y: cy });\n      }\n    }\n    // small shuffle of positions to produce wackiness\n    for (let i = positions.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [positions[i], positions[j]] = [positions[j], positions[i]];\n    }\n    const baseR = Math.min(cellW, cellH) / 3.2;\n    for (let i = 0; i < options.length; i++) {\n      const pos = positions[i];\n      const jitterX = (Math.random() - 0.5) * 30;\n      const jitterY = (Math.random() - 0.5) * 20;\n      choices.push({\n        text: String(options[i]),\n        value: options[i],\n        x: pos.x + jitterX,\n        y: pos.y + jitterY,\n        r: baseR + (Math.random() * 6 - 3),\n      });\n    }\n    focusedChoiceIndex = 0;\n  }\n\n  // UI helpers\n  function drawRoundedRect(x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function drawTopUI() {\n    // Score top-left\n    ctx.font = FONT_BODY;\n    ctx.textBaseline = 'middle';\n    ctx.fillStyle = '#000';\n    const scoreText = `Stars: ${correctCount}/${TARGET_CORRECT}`;\n    const scoreMetrics = ctx.measureText(scoreText);\n    const scoreW = scoreMetrics.width + PADDING * 2;\n    const scoreH = 34;\n    const scoreX = PADDING;\n    const scoreY = PADDING;\n    // background\n    ctx.fillStyle = '#d0f0ff';\n    drawRoundedRect(scoreX, scoreY, scoreW, scoreH, 8);\n    // text\n    ctx.fillStyle = '#00334d';\n    ctx.font = FONT_IMPORTANT;\n    ctx.fillText(scoreText, scoreX + PADDING, scoreY + scoreH / 2);\n\n    // Lives top-right\n    const livesText = `Lives: ${Math.max(MAX_WRONG - wrongCount, 0)}`;\n    ctx.font = FONT_IMPORTANT;\n    const livesMetrics = ctx.measureText(livesText);\n    const livesW = livesMetrics.width + PADDING * 2;\n    const livesH = 34;\n    const livesX = WIDTH - livesW - PADDING;\n    const livesY = PADDING;\n    ctx.fillStyle = '#ffe0e0';\n    drawRoundedRect(livesX, livesY, livesW, livesH, 8);\n    ctx.fillStyle = '#660000';\n    ctx.fillText(livesText, livesX + PADDING, livesY + livesH / 2);\n\n    // Audio indicator next to lives\n    const audioText = bgHumOn ? 'Audio: On (M)' : 'Audio: Off (M)';\n    ctx.font = FONT_BODY;\n    const audioMetrics = ctx.measureText(audioText);\n    const audioW = audioMetrics.width + PADDING * 2;\n    const audioH = 26;\n    const audioX = livesX - audioW - PADDING;\n    const audioY = PADDING + (livesH - audioH) / 2;\n    ctx.fillStyle = bgHumOn ? '#e8ffd8' : '#f0f0f0';\n    drawRoundedRect(audioX, audioY, audioW, audioH, 6);\n    ctx.fillStyle = bgHumOn ? '#225500' : '#333';\n    ctx.fillText(audioText, audioX + PADDING, audioY + audioH / 2);\n  }\n\n  function drawBottomUI() {\n    // Instructions centered bottom\n    const instructions = [\n      'Control: Click a cloud or press keys 1-4 to answer.',\n      'Goal: Collect 10 stars by answering correctly. 3 wrong answers and the drones must rest (game over).',\n      'Press R to restart at any time.',\n    ];\n    ctx.font = FONT_BODY;\n    ctx.textBaseline = 'top';\n    const combined = instructions.join('   ');\n    // We'll draw a rounded background box centered\n    const padding = 12;\n    // Measure widest text line\n    let maxWidth = 0;\n    instructions.forEach((line) => {\n      const m = ctx.measureText(line).width;\n      if (m > maxWidth) maxWidth = m;\n    });\n    const boxW = Math.min(WIDTH - PADDING * 4, maxWidth + padding * 2);\n    const boxH = instructions.length * 20 + padding * 2;\n    const boxX = (WIDTH - boxW) / 2;\n    const boxY = HEIGHT - BOTTOM_UI_HEIGHT + (BOTTOM_UI_HEIGHT - boxH) / 2;\n    ctx.fillStyle = '#fff9da';\n    drawRoundedRect(boxX, boxY, boxW, boxH, 10);\n    ctx.fillStyle = '#333';\n    ctx.font = FONT_BODY;\n    for (let i = 0; i < instructions.length; i++) {\n      const line = instructions[i];\n      ctx.fillText(line, boxX + padding, boxY + padding + i * 20);\n    }\n  }\n\n  // Drawing the drone\n  function drawDrone(x, y, wobble = 0) {\n    // Drone body\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(Math.sin(wobble) * 0.05);\n    // body\n    ctx.fillStyle = '#e6f7ff';\n    drawRoundedRect(-40, -16, 80, 32, 12);\n    ctx.fillStyle = '#336b87';\n    ctx.fillText('DR', -14, -3); // fun marking\n    // rotors: four circles with little arms\n    const rotorOffsets = [\n      { dx: -42, dy: -28 },\n      { dx: 42, dy: -28 },\n      { dx: -42, dy: 28 },\n      { dx: 42, dy: 28 },\n    ];\n    for (let i = 0; i < rotorOffsets.length; i++) {\n      const ro = rotorOffsets[i];\n      ctx.beginPath();\n      ctx.fillStyle = '#f7f7f7';\n      ctx.strokeStyle = '#aaa';\n      ctx.lineWidth = 2;\n      // arm\n      ctx.moveTo(ro.dx, ro.dy);\n      ctx.lineTo(ro.dx + (ro.dx < 0 ? -12 : 12), ro.dy + (i < 2 ? -8 : 8));\n      ctx.stroke();\n      // rotor circle\n      ctx.beginPath();\n      ctx.ellipse(ro.dx + (ro.dx < 0 ? -20 : 20), ro.dy + (i < 2 ? -12 : 12), 14, 8, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n      // rotor blade as rotated arc\n      ctx.beginPath();\n      ctx.strokeStyle = 'rgba(0,0,0,0.15)';\n      ctx.lineWidth = 3;\n      ctx.moveTo(ro.dx + (ro.dx < 0 ? -34 : 34), ro.dy + (i < 2 ? -12 : 12));\n      ctx.lineTo(ro.dx + (ro.dx < 0 ? -6 : 6), ro.dy + (i < 2 ? -12 : 12));\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  // Draw answer clouds (wacky)\n  function drawChoice(choice, index) {\n    // Circle with a cloud-like border using multiple arcs\n    const { x, y, r, text } = choice;\n    ctx.save();\n    // cloud body\n    ctx.beginPath();\n    ctx.fillStyle = '#fff';\n    ctx.strokeStyle = '#8fbfe6';\n    ctx.lineWidth = 3;\n    // multi-arc cloud\n    ctx.arc(x - r * 0.6, y, r * 0.55, Math.PI * 0.5, Math.PI * 1.5);\n    ctx.arc(x - r * 0.15, y - r * 0.5, r * 0.7, Math.PI * 1.0, Math.PI * 1.9);\n    ctx.arc(x + r * 0.4, y - r * 0.4, r * 0.6, Math.PI * 1.2, Math.PI * 2.0);\n    ctx.arc(x + r * 0.85, y, r * 0.45, Math.PI * 1.5, Math.PI * 0.5);\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n\n    // Number text inside\n    ctx.fillStyle = '#004466';\n    ctx.font = FONT_IMPORTANT;\n    ctx.textBaseline = 'middle';\n    ctx.textAlign = 'center';\n    // compute width and ensure it fits, adjust font size if needed\n    let fontSize = 22;\n    ctx.font = `${fontSize}px sans-serif`;\n    let tw = ctx.measureText(text).width;\n    while (tw > r * 1.4 && fontSize > 14) {\n      fontSize -= 1;\n      ctx.font = `${fontSize}px sans-serif`;\n      tw = ctx.measureText(text).width;\n    }\n    ctx.fillText(text, x, y);\n\n    // index label small\n    ctx.fillStyle = '#666';\n    ctx.font = FONT_BODY;\n    ctx.textAlign = 'left';\n    ctx.fillText(`${index + 1}`, x - r - 6, y - r - 6);\n\n    // focus highlight if keyboard focused\n    if (focusedChoiceIndex === index && gameState === 'playing') {\n      ctx.strokeStyle = '#ff9800';\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.ellipse(x, y, r + 8, r + 6, 0, 0, Math.PI * 2);\n      ctx.stroke();\n    }\n\n    ctx.restore();\n  }\n\n  // Handle answer attempt\n  function handleAnswerChoice(index) {\n    if (gameState !== 'playing') return;\n    const choice = choices[index];\n    if (!choice) return;\n    if (choice.value === currentQuestion.answer) {\n      correctCount++;\n      lastAnswerResult = 'correct';\n      playCorrectSound();\n      // animate drone to chosen cloud\n      droneTargetX = choice.x;\n      droneTargetY = choice.y - 40;\n      // small celebration indicator\n      shakeTime = 16;\n    } else {\n      wrongCount++;\n      lastAnswerResult = 'wrong';\n      playWrongSound();\n      // shake\n      shakeTime = 22;\n      // nudge drone away\n      droneTargetX = WIDTH / 2 + (Math.random() - 0.5) * 80;\n      droneTargetY = TOP_UI_HEIGHT + GAME_AREA.h - 60;\n    }\n    // check end conditions\n    if (correctCount >= TARGET_CORRECT) {\n      gameState = 'victory';\n      // celebratory sound\n      setTimeout(() => {\n        playTone({ frequency: 880, duration: 0.12, type: 'sine', volume: 0.07 });\n        playTone({ frequency: 1320, duration: 0.18, type: 'triangle', volume: 0.05 });\n      }, 100);\n    } else if (wrongCount >= MAX_WRONG) {\n      gameState = 'gameover';\n    } else {\n      // prepare next question after a short delay\n      setTimeout(() => {\n        generateQuestion();\n        lastAnswerResult = null;\n      }, 700);\n    }\n  }\n\n  // Input handling\n  canvas.addEventListener('click', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);\n    const my = (e.clientY - rect.top) * (canvas.height / rect.height);\n    if (gameState === 'start') {\n      // Start the game when clicking anywhere on canvas\n      startGame();\n      return;\n    }\n    if (gameState === 'victory' || gameState === 'gameover') {\n      // Restart if clicked\n      const restartClicked = true; // simple: any click restarts\n      if (restartClicked) startGame();\n      return;\n    }\n    // Check choices clicked\n    for (let i = 0; i < choices.length; i++) {\n      const c = choices[i];\n      const dx = mx - c.x;\n      const dy = my - c.y;\n      if (Math.sqrt(dx * dx + dy * dy) <= c.r + 8) {\n        handleAnswerChoice(i);\n        return;\n      }\n    }\n  });\n\n  window.addEventListener('keydown', (e) => {\n    if (e.key === 'M' || e.key === 'm') {\n      // toggle audio\n      if (!audioCtx) {\n        // try to create on demand\n        audioCtx = createAudioContextSafe();\n        if (!audioCtx) {\n          bgHumOn = false;\n          return;\n        } else {\n          toggleBackgroundHum(true);\n        }\n      } else {\n        toggleBackgroundHum(!bgHumOn);\n      }\n    } else if (e.key === 'R' || e.key === 'r') {\n      startGame();\n    } else if (gameState === 'start') {\n      if (e.key === 'Enter' || e.key === ' ') startGame();\n    } else if (gameState === 'victory' || gameState === 'gameover') {\n      if (e.key === 'Enter' || e.key === ' ' || e.key === 'r' || e.key === 'R') startGame();\n    } else if (gameState === 'playing') {\n      // number keys 1-4\n      if (/^[1-4]$/.test(e.key)) {\n        const idx = Number(e.key) - 1;\n        focusedChoiceIndex = idx;\n        handleAnswerChoice(idx);\n      } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {\n        focusedChoiceIndex = (focusedChoiceIndex + 1) % choices.length;\n      } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {\n        focusedChoiceIndex = (focusedChoiceIndex - 1 + choices.length) % choices.length;\n      } else if (e.key === 'Enter' || e.key === ' ') {\n        handleAnswerChoice(focusedChoiceIndex);\n      }\n    }\n  });\n\n  // Game flow\n  function startGame() {\n    correctCount = 0;\n    wrongCount = 0;\n    focusedChoiceIndex = 0;\n    lastAnswerResult = null;\n    shakeTime = 0;\n    droneX = WIDTH / 2;\n    droneY = TOP_UI_HEIGHT + GAME_AREA.h - 60;\n    droneTargetX = droneX;\n    droneTargetY = droneY;\n    gameState = 'playing';\n    generateQuestion();\n    // ensure audio context resumed on user gesture\n    if (audioCtx && audioCtx.state === 'suspended') {\n      audioCtx.resume().catch((e) => {\n        console.warn('Audio resume failed:', e);\n      });\n    }\n    toggleBackgroundHum(bgHumOn);\n  }\n\n  // Draw start screen\n  function drawStartScreen() {\n    ctx.fillStyle = '#eaf6ff';\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    // Title\n    ctx.fillStyle = '#00334d';\n    ctx.font = FONT_TITLE;\n    ctx.textBaseline = 'top';\n    const title = 'Drone Math Adventure';\n    const tw = ctx.measureText(title).width;\n    ctx.fillStyle = '#00334d';\n    // background rectangle for title\n    const boxW = tw + PADDING * 2;\n    const boxH = 48;\n    const boxX = (WIDTH - boxW) / 2;\n    const boxY = PADDING * 2;\n    ctx.fillStyle = '#dff7ff';\n    drawRoundedRect(boxX, boxY, boxW, boxH, 8);\n    ctx.fillStyle = '#00334d';\n    ctx.font = FONT_TITLE;\n    ctx.fillText(title, boxX + PADDING, boxY + 8);\n\n    // Fun drone drawing\n    drawDrone(WIDTH / 2, HEIGHT / 2 - 20, performance.now() / 200);\n\n    // Instructions\n    ctx.font = FONT_IMPORTANT;\n    ctx.fillStyle = '#223';\n    const instr = 'Click to launch! Answer 10 questions correctly. 3 mistakes and the game ends.';\n    const metrics = ctx.measureText(instr);\n    const instrW = Math.min(metrics.width, WIDTH - PADDING * 4);\n    const instrX = (WIDTH - instrW) / 2;\n    const instrY = HEIGHT - 140;\n    ctx.fillStyle = '#fff7d9';\n    drawRoundedRect(instrX - 12, instrY - 8, instrW + 24, 56, 10);\n    ctx.fillStyle = '#333';\n    ctx.font = FONT_BODY;\n    wrapText(instr, instrX, instrY, WIDTH - PADDING * 4, 18);\n    // small hint\n    ctx.font = FONT_BODY;\n    ctx.fillStyle = '#555';\n    ctx.fillText('Controls: Click clouds or press keys 1-4. M toggles audio.', instrX, instrY + 44);\n  }\n\n  function drawVictoryScreen() {\n    ctx.fillStyle = '#fffbe6';\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.fillStyle = '#225500';\n    ctx.font = FONT_TITLE;\n    ctx.fillText('You did it! Drone Champion!', PADDING * 2, PADDING * 2);\n    // show confetti-like bursts\n    for (let i = 0; i < 30; i++) {\n      ctx.fillStyle = `hsl(${(i * 37) % 360}, 70%, 60%)`;\n      const x = (i * 53) % WIDTH + Math.sin((i + performance.now() / 200) / 4) * 12;\n      const y = HEIGHT / 2 + Math.cos((i + performance.now() / 300) / 3) * 40 - Math.abs(Math.sin(performance.now() / 600 + i)) * 40;\n      ctx.beginPath();\n      ctx.arc(x, y, 6 + (i % 3), 0, Math.PI * 2);\n      ctx.fill();\n    }\n    // Summary box centered\n    ctx.fillStyle = '#e6fff0';\n    const stext = `Stars collected: ${correctCount}/${TARGET_CORRECT}`;\n    ctx.font = FONT_IMPORTANT;\n    const sm = ctx.measureText(stext);\n    const bw = sm.width + PADDING * 2;\n    const bh = 44;\n    const bx = (WIDTH - bw) / 2;\n    const by = HEIGHT / 2 - 20;\n    drawRoundedRect(bx, by, bw, bh, 10);\n    ctx.fillStyle = '#073b2f';\n    ctx.fillText(stext, bx + PADDING, by + bh / 2);\n\n    ctx.font = FONT_BODY;\n    ctx.fillStyle = '#333';\n    const hint = 'Press R or click to play again.';\n    ctx.fillText(hint, bx, by + bh + 18);\n  }\n\n  function drawGameOverScreen() {\n    ctx.fillStyle = '#fff0f0';\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.fillStyle = '#660000';\n    ctx.font = FONT_TITLE;\n    ctx.fillText('Game Over - Drones need rest', PADDING * 2, PADDING * 2);\n\n    // Sad drone\n    drawDrone(WIDTH / 2, HEIGHT / 2 - 10, performance.now() / 500);\n\n    ctx.fillStyle = '#fff';\n    ctx.font = FONT_IMPORTANT;\n    const stext = `Stars collected: ${correctCount}/${TARGET_CORRECT}`;\n    const sm = ctx.measureText(stext);\n    const bw = sm.width + PADDING * 2;\n    const bh = 44;\n    const bx = (WIDTH - bw) / 2;\n    const by = HEIGHT / 2 + 60;\n    ctx.fillStyle = '#ffecec';\n    drawRoundedRect(bx, by, bw, bh, 10);\n    ctx.fillStyle = '#660000';\n    ctx.fillText(stext, bx + PADDING, by + bh / 2);\n\n    ctx.font = FONT_BODY;\n    ctx.fillStyle = '#333';\n    const hint = 'Press R to try again.';\n    ctx.fillText(hint, bx, by + bh + 18);\n  }\n\n  // Utility to wrap text within width (canvas)\n  function wrapText(text, x, y, maxWidth, lineHeight) {\n    const words = text.split(' ');\n    let line = '';\n    ctx.font = FONT_BODY;\n    for (let n = 0; n < words.length; n++) {\n      const testLine = line + words[n] + ' ';\n      const metrics = ctx.measureText(testLine);\n      const testWidth = metrics.width;\n      if (testWidth > maxWidth && n > 0) {\n        ctx.fillText(line, x, y);\n        line = words[n] + ' ';\n        y += lineHeight;\n      } else {\n        line = testLine;\n      }\n    }\n    ctx.fillText(line, x, y);\n  }\n\n  // Main draw loop\n  function draw() {\n    // clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    // background calming sky with subtle gradient\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, '#e8f8ff');\n    g.addColorStop(1, '#f7fcff');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Top and bottom UI always present (even on start/victory/gameover) but adjusted\n    drawTopUI();\n    drawBottomUI();\n\n    if (gameState === 'start') {\n      drawStartScreen();\n      return;\n    }\n    if (gameState === 'victory') {\n      drawVictoryScreen();\n      return;\n    }\n    if (gameState === 'gameover') {\n      drawGameOverScreen();\n      return;\n    }\n\n    // playing state\n    // Draw the current question in the upper part of game area\n    ctx.font = FONT_IMPORTANT;\n    ctx.fillStyle = '#053b4a';\n    ctx.textBaseline = 'top';\n    const qText = currentQuestion ? `Solve: ${currentQuestion.text}` : 'Preparing...';\n    const qMetrics = ctx.measureText(qText);\n    const qW = qMetrics.width + PADDING * 2;\n    const qH = 40;\n    const qX = (WIDTH - qW) / 2;\n    const qY = PADDING + TOP_UI_HEIGHT - 40;\n    ctx.fillStyle = '#fff8e6';\n    drawRoundedRect(qX, qY, qW, qH, 10);\n    ctx.fillStyle = '#003a4d';\n    ctx.fillText(qText, qX + PADDING, qY + 10);\n\n    // Draw choices\n    for (let i = 0; i < choices.length; i++) {\n      drawChoice(choices[i], i);\n    }\n\n    // Draw drone\n    // apply simple smoothing towards target\n    droneX += (droneTargetX - droneX) * 0.08;\n    droneY += (droneTargetY - droneY) * 0.08;\n    // add wobble when correct/wrong\n    const wobble = Math.sin(performance.now() / 200) * 0.6;\n    drawDrone(droneX + (Math.random() - 0.5) * (shakeTime > 0 ? 8 : 0), droneY + (Math.random() - 0.5) * (shakeTime > 0 ? 6 : 0), wobble);\n\n    // show last answer feedback near drone\n    if (lastAnswerResult === 'correct') {\n      ctx.fillStyle = '#e8ffea';\n      const t = '+1 star!';\n      ctx.font = FONT_BODY;\n      ctx.fillText(t, droneX - 20, droneY - 70);\n    } else if (lastAnswerResult === 'wrong') {\n      ctx.fillStyle = '#fff0f0';\n      const t = 'Oops!';\n      ctx.font = FONT_BODY;\n      ctx.fillText(t, droneX - 10, droneY - 70);\n    }\n\n    // Draw little trajectory line from drone to target\n    ctx.strokeStyle = '#b3e6ff';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(WIDTH / 2, TOP_UI_HEIGHT + GAME_AREA.h);\n    ctx.quadraticCurveTo((WIDTH / 2 + droneX) / 2, droneY - 80, droneX, droneY);\n    ctx.stroke();\n\n    // reserved bottom area will show instructions and prevents overlap\n\n    // Decrement shake time\n    if (shakeTime > 0) shakeTime--;\n\n    // Accessibility: focus highlight note\n    ctx.font = FONT_BODY;\n    ctx.fillStyle = '#444';\n    ctx.fillText('Focus with arrows, select with Enter, or press 1-4.', PADDING, HEIGHT - BOTTOM_UI_HEIGHT + 8);\n  }\n\n  // Game loop\n  function loop(ts) {\n    const dt = ts - lastTick;\n    lastTick = ts;\n    draw();\n    requestAnimationFrame(loop);\n  }\n\n  // Start rendering\n  requestAnimationFrame(loop);\n\n  // Start page initially\n  gameState = 'start';\n  draw();\n\n  // Expose minimal debug in window for testing (non-intrusive)\n  window.__droneMathGame = {\n    startGame,\n    getState: () => ({ gameState, correctCount, wrongCount }),\n  };\n})();\n---\n",
  "improve_response_tokens": 19536,
  "formatted_code": true,
  "formatting_response_tokens": 22287,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}