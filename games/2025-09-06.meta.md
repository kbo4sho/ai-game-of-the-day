# Game of the Day - 2025-09-06

## Metadata
- **Generated Date:** 2025-09-06
- **Generated Time:** 2025-09-06T00:25:36.632986
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-06.js
- **File Size:** 25792 bytes
- **Tokens Used:** 8564

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-06.js` - The playable game
- `2025-09-06.meta.json` - Machine-readable metadata
- `2025-09-06.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 18243

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 20258

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Machine Math — Canvas Game for ages 7-9
  // Renders inside #game-of-the-day-stage, canvas size 720x480
  // Uses Web Audio API for sounds (created with oscillators)
  // Accessible: keyboard controls, focusable canvas, aria-live status region
  // Author: Generated by assistant (example code)

  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const STAGE_ID = "game-of-the-day-stage";

  // Game parameters
  const TOTAL_LEVELS = 6;
  const GEAR_MIN = 1;
  const GEAR_MAX = 9; // numbers on gears
  const MAX_GEARS = 6; // number of gears placed per level
  const PLAYER_SPEED = 4;
  const PICK_RANGE = 40;

  // Colors and style (calming, wacky palette)
  const COLORS = {
    background: "#F0F7F6",
    panel: "#E8F1EF",
    machine: "#D6E9E6",
    accent: "#7FB7B0",
    accent2: "#F6C1C1",
    text: "#2E3B3A",
    gearFill: "#FFFFFF",
    gearStroke: "#B2D6D1",
    robotBody: "#F7D9A7",
    highlight: "#C3F0E8",
    wrong: "#F6B6B6",
    success: "#BEE7D8",
  };

  // Utility: clamp
  function clamp(v, a, b) {
    return Math.max(a, Math.min(b, v));
  }

  // Get stage element
  const stage = document.getElementById(STAGE_ID);
  if (!stage) {
    console.error("Stage element with id '" + STAGE_ID + "' not found.");
    return;
  }

  // Clear stage and create canvas and accessibility region
  stage.innerHTML = "";
  stage.style.position = "relative";
  stage.style.width = WIDTH + "px";
  stage.style.height = HEIGHT + "px";

  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.display = "block";
  canvas.style.outline = "none";
  canvas.setAttribute("role", "application");
  canvas.setAttribute("aria-label", "Machine Math game area. Use left and right arrows to move. Press space to pick up a gear. Press N for next level or R to restart.");
  canvas.tabIndex = 0; // make focusable for keyboard controls
  stage.appendChild(canvas);

  // Create a small visible audio control and an aria-live status region (for screen readers)
  const audioControl = document.createElement("button");
  audioControl.textContent = "Enable sound";
  audioControl.style.position = "absolute";
  audioControl.style.right = "8px";
  audioControl.style.top = "8px";
  audioControl.style.padding = "6px 10px";
  audioControl.style.borderRadius = "6px";
  audioControl.style.border = "none";
  audioControl.style.background = COLORS.accent;
  audioControl.style.color = COLORS.text;
  audioControl.style.fontWeight = "600";
  audioControl.style.cursor = "pointer";
  audioControl.title = "Click to allow sound (some browsers require a gesture)";
  stage.appendChild(audioControl);

  const statusRegion = document.createElement("div");
  statusRegion.setAttribute("aria-live", "polite"); // screen readers
  statusRegion.style.position = "absolute";
  statusRegion.style.left = "-9999px";
  statusRegion.style.width = "1px";
  statusRegion.style.height = "1px";
  statusRegion.style.overflow = "hidden";
  stage.appendChild(statusRegion);

  // Canvas context
  const ctx = canvas.getContext("2d");

  // Audio setup
  let audioContext = null;
  let masterGain = null;
  let backgroundOsc = null;
  let audioEnabled = false;
  let audioAllowed = false; // whether user has enabled audio via button
  let audioInitialized = false;

  function initAudio() {
    if (audioInitialized) return;
    audioInitialized = true;
    try {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      if (!AudioContext) {
        throw new Error("Web Audio API not supported.");
      }
      audioContext = new AudioContext();
      masterGain = audioContext.createGain();
      masterGain.gain.value = 0.15; // gentle overall volume
      masterGain.connect(audioContext.destination);

      // Background hum (low, gentle)
      backgroundOsc = audioContext.createOscillator();
      const bgGain = audioContext.createGain();
      backgroundOsc.type = "sine";
      backgroundOsc.frequency.value = 110; // low hum
      bgGain.gain.value = 0.02;
      // subtle filter for warmth
      const bgFilter = audioContext.createBiquadFilter();
      bgFilter.type = "lowpass";
      bgFilter.frequency.value = 800;
      backgroundOsc.connect(bgFilter);
      bgFilter.connect(bgGain);
      bgGain.connect(masterGain);

      // Do not start background until user allows audio.
      audioEnabled = false;
    } catch (e) {
      audioContext = null;
      audioEnabled = false;
      console.warn("Audio disabled due to error:", e);
      statusRegion.textContent = "Audio is not available in this browser.";
    }
  }

  // Play a success melody (pleasant arpeggio)
  function playSuccess() {
    if (!audioContext || !audioAllowed) return;
    const now = audioContext.currentTime;
    const notes = [660, 880, 990]; // a short ascending arpeggio
    notes.forEach((freq, i) => {
      try {
        const o = audioContext.createOscillator();
        o.type = "sine";
        o.frequency.value = freq;
        const g = audioContext.createGain();
        g.gain.value = 0;
        o.connect(g);
        g.connect(masterGain);
        g.gain.setValueAtTime(0, now + i * 0.12);
        g.gain.linearRampToValueAtTime(0.12, now + i * 0.12 + 0.04);
        g.gain.exponentialRampToValueAtTime(0.0001, now + i * 0.12 + 0.24);
        o.start(now + i * 0.12);
        o.stop(now + i * 0.12 + 0.26);
      } catch (e) {
        console.warn("Audio node error", e);
      }
    });
  }

  // Play incorrect buzz (gentle)
  function playIncorrect() {
    if (!audioContext || !audioAllowed) return;
    const now = audioContext.currentTime;
    try {
      const o = audioContext.createOscillator();
      o.type = "triangle";
      o.frequency.value = 240;
      const g = audioContext.createGain();
      g.gain.value = 0;
      o.connect(g);
      g.connect(masterGain);
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(0.12, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.28);
      o.start(now);
      o.frequency.exponentialRampToValueAtTime(120, now + 0.28);
      o.stop(now + 0.3);
    } catch (e) {
      console.warn("Audio node error", e);
    }
  }

  // Small pluck for pickup
  function playPick() {
    if (!audioContext || !audioAllowed) return;
    const now = audioContext.currentTime;
    try {
      const o = audioContext.createOscillator();
      o.type = "sine";
      o.frequency.value = 880;
      const g = audioContext.createGain();
      const filter = audioContext.createBiquadFilter();
      filter.type = "highpass";
      filter.frequency.value = 600;
      o.connect(filter);
      filter.connect(g);
      g.connect(masterGain);
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(0.18, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.2);
      o.start(now);
      o.stop(now + 0.22);
    } catch (e) {
      console.warn("Audio node error", e);
    }
  }

  // Start background hum when user allows audio
  function startBackground() {
    if (!audioContext || !audioAllowed) return;
    try {
      if (backgroundOsc) {
        backgroundOsc.start();
      }
    } catch (e) {
      // Could be already started — ignore
    }
  }

  // Stop background gracefully (when audio disabled)
  function stopBackground() {
    if (!audioContext) return;
    if (backgroundOsc) {
      try {
        backgroundOsc.stop();
      } catch (e) {
        // ignore
      }
      // recreate a fresh oscillator for next time
      backgroundOsc = audioContext.createOscillator();
      const bgGain = audioContext.createGain();
      backgroundOsc.type = "sine";
      backgroundOsc.frequency.value = 110;
      bgGain.gain.value = 0.02;
      const bgFilter = audioContext.createBiquadFilter();
      bgFilter.type = "lowpass";
      bgFilter.frequency.value = 800;
      backgroundOsc.connect(bgFilter);
      bgFilter.connect(bgGain);
      bgGain.connect(masterGain);
    }
  }

  audioControl.addEventListener("click", function () {
    initAudio();
    if (!audioContext) {
      audioControl.textContent = "Audio unavailable";
      audioControl.disabled = true;
      return;
    }
    // resume audio context if suspended (some browsers require user gesture)
    audioContext
      .resume()
      .then(() => {
        audioAllowed = true;
        audioEnabled = true;
        startBackground();
        audioControl.textContent = "Sound on";
        audioControl.style.background = COLORS.accent2;
        statusRegion.textContent = "Audio enabled.";
      })
      .catch((e) => {
        audioAllowed = false;
        audioControl.textContent = "Enable sound";
        statusRegion.textContent = "Audio failed to start.";
        console.warn("Audio resume failed:", e);
      });
  });

  // Game state
  let level = 1;
  let target = 0;
  let gears = []; // gear objects
  let player = {
    x: WIDTH / 2,
    y: HEIGHT - 110,
    radius: 22,
    carrying: [], // collected gears
  };
  let keys = {};
  let message = ""; // temporary feedback
  let messageTimer = 0;
  let levelComplete = false;
  let gameComplete = false;
  let moves = 0;

  // Accessibility announcement
  function announce(text) {
    statusRegion.textContent = text;
  }

  // Utility: random int inclusive
  function randInt(a, b) {
    return Math.floor(Math.random() * (b - a + 1)) + a;
  }

  // Generate a solvable set of gears that can sum to target
  function generateLevel(lv) {
    // scale difficulty: higher levels have larger targets and more gears
    const gearCount = Math.min(MAX_GEARS, Math.max(3, 2 + lv));
    // produce a target between 5 and maybe 15+ depending on level
    const baseMax = GEAR_MAX + Math.min(5, lv);
    target = randInt(5 + lv, 8 + baseMax);
    gears = [];
    // Guarantee solvability: create some numbers that sum to target then add distractors
    // First create a solution: split target into 2-3 parts within GEAR_MIN..GEAR_MAX
    const partsCount = randInt(2, Math.min(3, gearCount));
    let remaining = target;
    let solutionParts = [];
    for (let i = 0; i < partsCount - 1; i++) {
      // ensure remaining can be split
      const maxPart = Math.min(GEAR_MAX, remaining - (partsCount - i - 1) * GEAR_MIN);
      const minPart = Math.max(GEAR_MIN, remaining - (partsCount - i - 1) * GEAR_MAX);
      const part = randInt(minPart, maxPart);
      solutionParts.push(part);
      remaining -= part;
    }
    solutionParts.push(remaining); // last part

    // Place solution gears
    for (let v of solutionParts) {
      gears.push({
        x: randInt(80, WIDTH - 80),
        y: randInt(140, HEIGHT - 220),
        val: v,
        taken: false,
        id: cryptoRandomId(),
      });
    }

    // Add distractor gears
    while (gears.length < gearCount) {
      const v = randInt(GEAR_MIN, Math.max(GEAR_MAX, Math.floor(target / 2) + 2));
      // avoid creating duplicates of solution too often
      gears.push({
        x: randInt(80, WIDTH - 80),
        y: randInt(140, HEIGHT - 220),
        val: v,
        taken: false,
        id: cryptoRandomId(),
      });
    }

    // Slightly nudge positions to avoid overlap
    for (let i = 0; i < gears.length; i++) {
      for (let j = i + 1; j < gears.length; j++) {
        const a = gears[i], b = gears[j];
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 60) {
          b.x += (dx / dist) * 40 + randInt(-10, 10);
          b.y += (dy / dist) * 40 + randInt(-10, 10);
        }
      }
    }

    // Reset player and state
    player.x = WIDTH / 2;
    player.carrying = [];
    levelComplete = false;
    gameComplete = false;
    moves = 0;
    announce(`Level ${level}. Fix the machine by collecting gears that add to ${target}. Use left and right arrows, press space to pick up a gear.`);
  }

  // Generate a short random id
  function cryptoRandomId() {
    try {
      return Math.random().toString(36).slice(2, 9);
    } catch (e) {
      return Date.now().toString(36);
    }
  }

  // Input handling
  window.addEventListener("keydown", function (e) {
    if (e.repeat) return;
    keys[e.key] = true;
    // Acceptable keys: ArrowLeft, ArrowRight, Space, Enter, r, R, n, N
    if (e.key === " " || e.key === "Spacebar") {
      e.preventDefault();
      attemptPick();
    } else if (e.key === "Enter") {
      attemptPick();
    } else if (e.key === "r" || e.key === "R") {
      resetGame();
    } else if (e.key === "n" || e.key === "N") {
      nextLevel();
    } else if (e.key === "ArrowLeft" || e.key === "ArrowRight") {
      // nothing extra
    }
  });

  window.addEventListener("keyup", function (e) {
    delete keys[e.key];
  });

  // Make canvas clickable for mouse interactions
  canvas.addEventListener("click", function (ev) {
    const rect = canvas.getBoundingClientRect();
    const mx = ev.clientX - rect.left;
    const my = ev.clientY - rect.top;
    // Click near a gear picks it
    let clicked = false;
    for (let g of gears) {
      if (!g.taken) {
        const d = Math.hypot(g.x - mx, g.y - my);
        if (d < 40) {
          // Move player to gear instantly and pick
          player.x = clamp(g.x + randInt(-10, 10), 40, WIDTH - 40);
          attemptPick();
          clicked = true;
          break;
        }
      }
    }
    if (!clicked) {
      // toggle audio control if clicking its visible area
      // ignore; no action
    }
  });

  // Attempt to pick up gears when near
  function attemptPick() {
    if (levelComplete || gameComplete) return;
    // find nearest untaken gear within PICK_RANGE
    let nearest = null;
    let nearestDist = Infinity;
    for (let g of gears) {
      if (g.taken) continue;
      const d = Math.hypot(g.x - player.x, g.y - player.y);
      if (d < nearestDist) {
        nearestDist = d;
        nearest = g;
      }
    }
    if (nearest && nearestDist <= PICK_RANGE) {
      // pick it
      nearest.taken = true;
      player.carrying.push(nearest);
      moves++;
      playPick();
      announce(`Picked gear ${nearest.val}. Current sum is ${currentSum()}.`);
      // Check sum
      const sum = currentSum();
      if (sum === target) {
        onLevelSuccess();
      } else if (sum > target) {
        // incorrect: sum too high — allow player to reset or continue (can't drop gears in this simple game)
        message = "Too many! Try again (press R to reset).";
        messageTimer = 240;
        playIncorrect();
        announce("Too many. Press R to try again.");
      } else {
        // still under target — encourage
        message = "Nice! You're not there yet.";
        messageTimer = 80;
      }
    } else {
      // no gear in range
      message = "No gear nearby. Move closer to pick a gear.";
      messageTimer = 80;
      playIncorrect();
      announce("No gear nearby.");
    }
  }

  function currentSum() {
    return player.carrying.reduce((s, g) => s + g.val, 0);
  }

  function onLevelSuccess() {
    levelComplete = true;
    playSuccess();
    message = "Machine fixed! Nice work.";
    messageTimer = 240;
    announce(`Level ${level} complete! You fixed the machine.`);
    // If last level reached, mark game complete
    if (level >= TOTAL_LEVELS) {
      gameComplete = true;
      announce("Congratulations! You repaired all the machines. Press R to play again.");
    }
  }

  function nextLevel() {
    if (levelComplete && level < TOTAL_LEVELS) {
      level++;
      generateLevel(level);
    } else if (!levelComplete) {
      // allow skipping? No. We can encourage finishing
      message = "Finish the current level before moving on.";
      messageTimer = 120;
      announce("Finish the current level first.");
    } else if (gameComplete) {
      // restart fresh
      level = 1;
      generateLevel(level);
    }
  }

  function resetGame() {
    // Reset current level: return all taken gears
    for (let g of gears) {
      g.taken = false;
    }
    player.carrying = [];
    message = "Level reset. Try a new combination!";
    messageTimer = 120;
    announce("Level reset.");
  }

  // Drawing helpers
  function drawRoundedRect(ctx, x, y, w, h, r, fillStyle, strokeStyle) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fillStyle) {
      ctx.fillStyle = fillStyle;
      ctx.fill();
    }
    if (strokeStyle) {
      ctx.strokeStyle = strokeStyle;
      ctx.stroke();
    }
  }

  function drawGear(ctx, x, y, radius, teeth, colorFill, colorStroke, rotation = 0) {
    // Draw a simple gear by creating radial teeth
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rotation);
    // teeth parameters
    const inner = radius * 0.7;
    const toothWidth = Math.PI * 2 / (teeth * 2);
    ctx.beginPath();
    for (let i = 0; i < teeth * 2; i++) {
      const angle = i * toothWidth;
      const r = i % 2 === 0 ? radius : inner;
      const px = Math.cos(angle) * r;
      const py = Math.sin(angle) * r;
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fillStyle = colorFill;
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = colorStroke;
    ctx.stroke();

    // center hole
    ctx.beginPath();
    ctx.arc(0, 0, radius * 0.35, 0, Math.PI * 2);
    ctx.fillStyle = "#F5F7F7";
    ctx.fill();
    ctx.stroke();

    ctx.restore();
  }

  function drawRobot(ctx, x, y, carrying) {
    // Simple friendly robot with round body and eyes
    ctx.save();
    ctx.translate(x, y);
    // body
    drawRoundedRect(ctx, -24, -28, 48, 48, 8, COLORS.robotBody, "#A37A49");
    // head
    drawRoundedRect(ctx, -18, -56, 36, 34, 6, COLORS.robotBody, "#A37A49");
    // eyes
    ctx.fillStyle = "#2E3B3A";
    ctx.beginPath();
    ctx.arc(-6, -44, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(6, -44, 4, 0, Math.PI * 2);
    ctx.fill();
    // mouth
    ctx.strokeStyle = "#2E3B3A";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, -36, 6, 0, Math.PI, false);
    ctx.stroke();

    // arm holding gears: draw small stack of carried gears
    const startX = 18;
    let sy = -4;
    for (let i = 0; i < carrying.length; i++) {
      const g = carrying[i];
      drawGear(ctx, startX + (i % 2) * 10, sy - i * 6, 10, 8, COLORS.gearFill, COLORS.gearStroke, (i * 0.3) % 6);
      ctx.fillStyle = COLORS.text;
      ctx.font = "10px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(g.val, startX + (i % 2) * 10, sy - i * 6 + 4);
    }

    ctx.restore();
  }

  // Main draw loop
  let lastTime = 0;
  function loop(ts) {
    const dt = (ts - lastTime) || 16;
    lastTime = ts;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  function update(dt) {
    // Input movement
    if (keys["ArrowLeft"]) {
      player.x -= PLAYER_SPEED;
    }
    if (keys["ArrowRight"]) {
      player.x += PLAYER_SPEED;
    }
    player.x = clamp(player.x, 40, WIDTH - 40);

    // handle message timer
    if (messageTimer > 0) {
      messageTimer--;
      if (messageTimer === 0) {
        message = "";
      }
    }
  }

  function draw() {
    // clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // background
    ctx.fillStyle = COLORS.background;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // top panel (instructions)
    drawRoundedRect(ctx, 12, 12, WIDTH - 24, 96, 12, COLORS.panel, COLORS.accent);
    ctx.fillStyle = COLORS.text;
    ctx.font = "20px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText(`Machine Math — Level ${level} of ${TOTAL_LEVELS}`, 28, 38);
    ctx.font = "14px sans-serif";
    ctx.fillStyle = COLORS.text;
    ctx.fillText(`Fix the machine by collecting gears that add to:`, 28, 60);
    ctx.font = "28px monospace";
    ctx.fillStyle = COLORS.accent2;
    ctx.fillText(`${target}`, 320, 72);

    // sub-instructions
    ctx.font = "12px sans-serif";
    ctx.fillStyle = "#4F6B6A";
    ctx.fillText("Use left/right arrows. Press Space or Enter to pick up a gear when you're close.", 28, 84);

    // machine area (big rounded)
    drawRoundedRect(ctx, 36, 120, WIDTH - 72, HEIGHT - 170, 14, COLORS.machine, COLORS.accent);

    // conveyor belt background
    ctx.fillStyle = "#E6F2F1";
    ctx.fillRect(36, HEIGHT - 160, WIDTH - 72, 24);

    // decorative piping and dials (wacky)
    ctx.strokeStyle = "#C9E7E3";
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(60, 160);
    ctx.bezierCurveTo(120, 130, 240, 200, 380, 160);
    ctx.bezierCurveTo(500, 120, 620, 200, 660, 160);
    ctx.stroke();

    // Draw gears
    for (let g of gears) {
      ctx.save();
      // subtle bobbing
      const rot = ((Date.now() / 800) % (Math.PI * 2)) * 0.6;
      const bob = Math.sin((g.x + g.y + Date.now() / 200) / 150) * 6;
      const x = g.x;
      const y = g.y + bob;
      // highlight if near player
      const dist = Math.hypot(player.x - x, player.y - y);
      const near = dist < PICK_RANGE;
      ctx.globalAlpha = g.taken ? 0.3 : 1;
      // gear body
      drawGear(ctx, x, y, 28, 12, COLORS.gearFill, near ? COLORS.accent2 : COLORS.gearStroke, rot);
      // number label
      ctx.fillStyle = COLORS.text;
      ctx.font = "20px monospace";
      ctx.textAlign = "center";
      ctx.fillText(g.val, x, y + 6);
      ctx.restore();
    }

    // Draw robot (player)
    drawRobot(ctx, player.x, player.y, player.carrying);

    // Draw player foot/shadow
    ctx.fillStyle = "rgba(0,0,0,0.05)";
    ctx.beginPath();
    ctx.ellipse(player.x, player.y + 30, 28, 8, 0, 0, Math.PI * 2);
    ctx.fill();

    // Display current sum and moves
    ctx.font = "16px sans-serif";
    ctx.fillStyle = COLORS.text;
    ctx.textAlign = "left";
    ctx.fillText(`Current sum: ${currentSum()}`, 48, HEIGHT - 28);
    ctx.fillText(`Moves: ${moves}`, WIDTH - 120, HEIGHT - 28);

    // Message box
    if (message) {
      const boxW = WIDTH - 120;
      drawRoundedRect(ctx, 60, HEIGHT - 110, boxW, 36, 8, message.includes("Too") ? COLORS.wrong : COLORS.success, "#B7D9D0");
      ctx.fillStyle = COLORS.text;
      ctx.font = "16px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(message, 60 + boxW / 2, HEIGHT - 84);
    }

    // Visual cue for audio status near control
    ctx.save();
    ctx.textAlign = "right";
    ctx.font = "12px sans-serif";
    ctx.fillStyle = COLORS.text;
    if (audioAllowed) {
      ctx.fillStyle = COLORS.accent2;
      ctx.fillText("Audio: ON", WIDTH - 20, 30);
      // draw small sound wave icon
      ctx.strokeStyle = COLORS.accent2;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(WIDTH - 60, 20);
      ctx.quadraticCurveTo(WIDTH - 55, 12, WIDTH - 50, 20);
      ctx.quadraticCurveTo(WIDTH - 45, 28, WIDTH - 40, 20);
      ctx.stroke();
    } else {
      ctx.fillStyle = "#A7BFB9";
      ctx.fillText("Audio: OFF", WIDTH - 20, 30);
      ctx.strokeStyle = "#A7BFB9";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(WIDTH - 60, 20);
      ctx.lineTo(WIDTH - 40, 20);
      ctx.stroke();
    }
    ctx.restore();

    // If level complete overlay
    if (levelComplete) {
      ctx.save();
      ctx.globalAlpha = 0.92;
      drawRoundedRect(ctx, WIDTH / 2 - 180, HEIGHT / 2 - 70, 360, 140, 12, "#FFFFFF", "#BCEEDD");
      ctx.fillStyle = COLORS.text;
      ctx.font = "22px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(level >= TOTAL_LEVELS ? "Well done!" : "Machine repaired!", WIDTH / 2, HEIGHT / 2 - 18);
      ctx.font = "16px sans-serif";
      ctx.fillStyle = "#4F6B6A";
      ctx.fillText(level >= TOTAL_LEVELS ? "You fixed all the machines." : "Press N to move to the next machine.", WIDTH / 2, HEIGHT / 2 + 12);
      ctx.restore();
    }

    // If game complete overlay
    if (gameComplete) {
      ctx.save();
      ctx.globalAlpha = 0.96;
      drawRoundedRect(ctx, WIDTH / 2 - 200, HEIGHT / 2 - 80, 400, 160, 16, "#F8FFFB", "#A7EAC6");
      ctx.fillStyle = COLORS.text;
      ctx.font = "24px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("All Machines Fixed!", WIDTH / 2, HEIGHT / 2 - 10);
      ctx.font = "16px sans-serif";
      ctx.fillStyle = "#4F6B6A";
      ctx.fillText("Great job! Press R to play again.", WIDTH / 2, HEIGHT / 2 + 20);
      ctx.restore();
    }

    // small caption for help
    ctx.font = "11px sans-serif";
    ctx.fillStyle = "#6D8B88";
    ctx.textAlign = "left";
    ctx.fillText("Keyboard: ← → to move • Space/Enter to pick • R reset • N next", 40, HEIGHT - 8);
  }

  // Initialize first level
  generateLevel(level);
  initAudio();

  // Start loop
  requestAnimationFrame(loop);

  // Expose some helpful console functions (optional)
  window.machineMathGame = {
    nextLevel: function () {
      nextLevel();
    },
    resetLevel: function () {
      resetGame();
    },
    enableAudio: function () {
      audioControl.click();
    },
    getState: function () {
      return {
        level,
        target,
        sum: currentSum(),
        moves,
        audioAllowed,
      };
    },
  };

  // Safety: if audio not enabled within a while, show hint
  setTimeout(() => {
    if (!audioAllowed && audioContext) {
      statusRegion.textContent = "Tip: Click 'Enable sound' to hear friendly game sounds.";
    }
  }, 4000);

  // Error handling for visibility: if canvas context lost
  canvas.addEventListener("webglcontextlost", function (e) {
    e.preventDefault();
    alert("Canvas context lost — please reload the page.");
  });

  // Focus canvas to allow keyboard immediately (best effort)
  try {
    canvas.focus();
  } catch (e) {
    // ignore
  }

})();
---

