# Game of the Day - 2025-10-05

## Metadata
- **Generated Date:** 2025-10-05
- **Generated Time:** 2025-10-05T00:30:00.154171
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-10-05.js
- **File Size:** 26127 bytes
- **Tokens Used:** 9138

## Functionality Score
- **Score:** 7/8 (87.5%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- ⚠️  No game state management found

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-10-05.js` - The playable game
- `2025-10-05.meta.json` - Machine-readable metadata
- `2025-10-05.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 18152

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 19836

### Final Functionality Score After Improvement
- **Score:** 7/8 (87.5%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- ⚠️  No game state management found

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(() => {
  // MACHINE MATH GAME
  // For ages 7-9. Renders inside element with ID 'game-of-the-day-stage'.
  // Creates a 720x480 canvas and uses Web Audio API oscillators for sounds.
  // Accessible via keyboard, includes audio on/off visual, clear instructions,
  // and error handling for audio creation and resume.

  // Utility helpers
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const randInt = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;

  // Find container
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Game container with ID "game-of-the-day-stage" not found.');
    return;
  }
  // Clear container
  container.innerHTML = '';
  container.style.position = 'relative';
  container.style.userSelect = 'none';

  // Create ARIA live region for screen readers (offscreen)
  const liveRegion = document.createElement('div');
  liveRegion.setAttribute('aria-live', 'polite');
  liveRegion.setAttribute('role', 'status');
  liveRegion.style.position = 'absolute';
  liveRegion.style.left = '-9999px';
  liveRegion.style.width = '1px';
  liveRegion.style.height = '1px';
  liveRegion.style.overflow = 'hidden';
  container.appendChild(liveRegion);

  // Create canvas exactly 720x480
  const canvas = document.createElement('canvas');
  canvas.width = 720;
  canvas.height = 480;
  canvas.tabIndex = 0; // make focusable for keyboard
  canvas.style.outline = 'none';
  canvas.style.display = 'block';
  canvas.style.background = '#f3f8fb';
  container.appendChild(canvas);

  const ctx = canvas.getContext('2d', { alpha: false });

  // Global settings
  const GAME_WIDTH = 720;
  const GAME_HEIGHT = 480;

  // Colors and design
  const palette = {
    bg: '#eaf2f7',
    machine: '#d2e9f8',
    accent: '#6aa7d8',
    accent2: '#f4b183',
    tile: '#ffffff',
    tileText: '#223',
    gear: '#cfe8f6',
    wrong: '#e27a7a',
    correct: '#7ad28f',
    text: '#123',
    dim: '#8aa1b8',
  };

  // Audio manager with error handling
  class AudioManager {
    constructor() {
      this.enabled = true;
      this.supported = true;
      this.ctx = null;
      this.bgGain = null;
      this.bgOsc = null;
      this.masterGain = null;
      this.initialized = false;
      try {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (!AudioContext) throw new Error('Web Audio API not supported');
        this.ctx = new AudioContext();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.9;
        this.masterGain.connect(this.ctx.destination);

        // background ambient oscillator (gentle)
        this.bgOsc = this.ctx.createOscillator();
        this.bgOsc.type = 'sine';
        this.bgOsc.frequency.value = 110; // low hum
        this.bgGain = this.ctx.createGain();
        this.bgGain.gain.value = 0.02;
        this.bgOsc.connect(this.bgGain);
        this.bgGain.connect(this.masterGain);
        this.bgOsc.start();

        // We'll keep background muted until user toggles
        this.bgPlaying = false;
        this.initialized = true;
      } catch (e) {
        console.warn('Audio initialization failed:', e);
        this.supported = false;
        this.enabled = false;
      }
    }

    async resumeIfNeeded() {
      if (!this.initialized || !this.ctx) return;
      if (this.ctx.state === 'suspended') {
        try {
          await this.ctx.resume();
        } catch (e) {
          console.warn('AudioContext resume failed', e);
        }
      }
    }

    toggleBackground(on) {
      if (!this.supported) return;
      this.bgPlaying = !!on;
      if (this.bgGain) this.bgGain.gain.value = this.bgPlaying ? 0.02 : 0;
      this.resumeIfNeeded().catch(() => {});
    }

    playTone(frequency = 660, duration = 0.2, type = 'sine', when = 0) {
      if (!this.supported) return;
      try {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.value = frequency;
        gain.gain.value = 0.0001;
        osc.connect(gain);
        gain.connect(this.masterGain);
        const t0 = this.ctx.currentTime + when;
        gain.gain.setValueAtTime(0.0001, t0);
        gain.gain.exponentialRampToValueAtTime(0.05, t0 + 0.01);
        osc.start(t0);
        gain.gain.exponentialRampToValueAtTime(0.0001, t0 + duration);
        osc.stop(t0 + duration + 0.02);
      } catch (e) {
        console.warn('playTone error', e);
      }
    }

    beepCorrect() {
      // Pleasant arpeggio
      if (!this.supported) return;
      this.resumeIfNeeded().catch(() => {});
      this.playTone(880, 0.12, 'sine', 0);
      this.playTone(1100, 0.12, 'sine', 0.12);
      this.playTone(1320, 0.18, 'sine', 0.24);
    }

    beepWrong() {
      if (!this.supported) return;
      this.resumeIfNeeded().catch(() => {});
      this.playTone(220, 0.18, 'sawtooth', 0);
      this.playTone(180, 0.12, 'sine', 0.12);
    }
  }

  const audio = new AudioManager();

  // Game logic
  class MachineMathGame {
    constructor(ctx, audio) {
      this.ctx = ctx;
      this.audio = audio;
      this.round = 0;
      this.maxRounds = 6;
      this.state = 'intro'; // intro, playing, success, finished
      this.tiles = Array.from({ length: 10 }, (_, i) => i); // 0-9
      this.slotA = null;
      this.slotB = null;
      this.cursor = 0; // keyboard selection index among tiles
      this.message = 'Press Enter or Click a number tile to feed the machine';
      this.msgTimer = 0;
      this.animTime = 0;
      this.roundData = [];
      this.failedAttempts = 0;
      this.generateRounds();
      this.onAction = null; // optional callback
      this.focused = false;
      this.audioOn = !!(this.audio && this.audio.supported && this.audio.bgPlaying);
      this.audioAvailable = !!(this.audio && this.audio.supported);
      this.initAccessibility();
      this.announce('Welcome to Machine Math! Press Enter to begin.');
    }

    generateRounds() {
      // Generate solvable rounds by picking two numbers and operation
      // Beginner: addition first 3 rounds, then subtraction, then mixed.
      this.roundData = [];
      for (let i = 0; i < this.maxRounds; i++) {
        let op = '+';
        if (i < 3) op = '+';
        else if (i < 5) op = '-';
        else op = Math.random() < 0.5 ? '+' : '-';
        // For subtraction, ensure non-negative
        let a = randInt(0, 9);
        let b = randInt(0, 9);
        if (op === '-' && a < b) [a, b] = [b, a];
        const target = op === '+' ? a + b : a - b;
        this.roundData.push({ op, a, b, target });
      }
    }

    initAccessibility() {
      // Update live region with instructions
      const instr = `Machine Math. Use Arrow keys to move selection. Press Enter to place a number. Press Backspace to clear a slot.
        Press A to toggle audio. Press R to restart. Click the speaker in top-right to toggle audio.`;
      liveRegion.textContent = instr;
    }

    start() {
      this.state = 'playing';
      this.round = 0;
      this.slotA = null;
      this.slotB = null;
      this.cursor = 0;
      this.failedAttempts = 0;
      this.audioOn = !!(this.audio && this.audio.supported && this.audio.bgPlaying);
      this.announce('Round 1. Solve the machine!');
    }

    currentRound() {
      return this.roundData[this.round];
    }

    placeTile(index) {
      const value = this.tiles[index];
      if (this.slotA === null) {
        this.slotA = { index, value };
      } else if (this.slotB === null) {
        // prevent placing same tile index twice? Allow since tiles are reusable
        this.slotB = { index, value };
      } else {
        // both slots full: clicking cycles replace second
        this.slotB = { index, value };
      }
      this.msg('Placed ' + value);
      this.checkIfReady();
    }

    removeLastSlot() {
      if (this.slotB !== null) {
        this.msg('Removed ' + this.slotB.value);
        this.slotB = null;
      } else if (this.slotA !== null) {
        this.msg('Removed ' + this.slotA.value);
        this.slotA = null;
      } else {
        this.msg('No slots to clear');
      }
    }

    clearSlots() {
      this.slotA = null;
      this.slotB = null;
    }

    msg(text) {
      this.message = text;
      this.msgTimer = 180; // show for some frames
      liveRegion.textContent = text;
    }

    announce(text) {
      // Use live region for announcements
      liveRegion.textContent = text;
    }

    checkIfReady() {
      if (this.slotA && this.slotB) {
        // compute
        const round = this.currentRound();
        if (!round) return;
        const computed = round.op === '+' ? (this.slotA.value + this.slotB.value) : (this.slotA.value - this.slotB.value);
        const target = round.target;
        if (computed === target) {
          // success for this round
          this.audio.beepCorrect();
          this.msg('Correct! Machine accepted the input.');
          this.celebrate(() => {
            this.round++;
            if (this.round >= this.maxRounds) {
              this.state = 'finished';
              this.announce('All rounds complete! Great job! Press R to play again.');
            } else {
              this.clearSlots();
              this.state = 'playing';
              this.msg(`Round ${this.round + 1}. Next machine ready.`);
              this.announce(`Round ${this.round + 1}.`);
            }
            if (this.onAction) this.onAction();
          });
        } else {
          // wrong
          this.audio.beepWrong();
          this.failedAttempts++;
          this.msg('That did not match the target. Try again.');
          this.shake();
          // keep slots so child can see; but clear B to let try again
          this.slotB = null;
          if (this.failedAttempts >= 5) {
            // give hint by revealing one of the numbers that will work
            this.revealHint();
            this.failedAttempts = 0;
          }
        }
      }
    }

    revealHint() {
      const round = this.currentRound();
      if (!round) return;
      // Reveal one of the original numbers by filling slotA with the correct a
      this.slotA = { index: round.a, value: round.a };
      this.slotB = null;
      this.msg(`Hint: one slot filled with ${round.a}`);
      this.announce('Hint provided.');
    }

    celebrate(done) {
      this.state = 'celebrating';
      // simple delay then callback
      setTimeout(() => {
        this.state = 'playing';
        if (done) done();
      }, 1000);
    }

    shake() {
      this.animTime = 18;
    }

    toggleAudio() {
      if (!this.audioAvailable) {
        this.msg('Audio not available in this browser.');
        return;
      }
      this.audioOn = !this.audioOn;
      this.audio.toggleBackground(this.audioOn);
      this.msg(this.audioOn ? 'Audio on' : 'Audio off');
      this.announce(this.audioOn ? 'Audio enabled' : 'Audio disabled');
    }

    restart() {
      this.generateRounds();
      this.round = 0;
      this.clearSlots();
      this.state = 'playing';
      this.msg('Game restarted. Good luck!');
      this.announce('Game restarted.');
    }

    keyboardMove(dir) {
      // dir: -1 left, 1 right
      this.cursor = (this.cursor + dir + this.tiles.length) % this.tiles.length;
    }

    handleKey(e) {
      if (this.state === 'intro' && (e.key === 'Enter' || e.key === ' ')) {
        this.start();
        return;
      }
      if (e.key === 'a' || e.key === 'A') {
        // toggle audio; resume audio context if needed after gesture
        if (this.audioAvailable) this.audio.resumeIfNeeded().catch(() => {});
        this.toggleAudio();
      } else if (e.key === 'r' || e.key === 'R') {
        this.restart();
      } else if (e.key === 'ArrowLeft') {
        this.keyboardMove(-1);
      } else if (e.key === 'ArrowRight') {
        this.keyboardMove(1);
      } else if (e.key === 'Enter') {
        this.placeTile(this.cursor);
      } else if (e.key === 'Backspace') {
        this.removeLastSlot();
      } else if (e.key === ' ') {
        // space acts as place
        this.placeTile(this.cursor);
      }
    }

    handleMouseClick(x, y) {
      // coordinates inside canvas
      // Speaker icon in top-right toggle audio
      if (x >= GAME_WIDTH - 46 && x <= GAME_WIDTH - 10 && y >= 10 && y <= 46) {
        this.toggleAudio();
        return;
      }

      // Tiles region bottom: determine which tile clicked
      const tileY = GAME_HEIGHT - 120;
      if (y >= tileY && y <= GAME_HEIGHT - 20) {
        const tileCount = this.tiles.length;
        const spacing = 60;
        const startX = (GAME_WIDTH - (spacing * tileCount - 10)) / 2;
        for (let i = 0; i < tileCount; i++) {
          const cx = startX + i * spacing;
          const cy = tileY + 40;
          const r = 24;
          if ((x - cx) ** 2 + (y - cy) ** 2 <= r * r) {
            this.cursor = i;
            this.placeTile(i);
            return;
          }
        }
      }

      // clicking on slots to remove
      const slotABox = { x: 180, y: 170, w: 90, h: 90 };
      const slotBBox = { x: 360, y: 170, w: 90, h: 90 };
      if (x >= slotABox.x && x <= slotABox.x + slotABox.w && y >= slotABox.y && y <= slotABox.y + slotABox.h) {
        if (this.slotA) {
          this.msg(`Removed ${this.slotA.value}`);
          this.slotA = null;
          return;
        }
      }
      if (x >= slotBBox.x && x <= slotBBox.x + slotBBox.w && y >= slotBBox.y && y <= slotBBox.y + slotBBox.h) {
        if (this.slotB) {
          this.msg(`Removed ${this.slotB.value}`);
          this.slotB = null;
          return;
        }
      }
    }

    update() {
      if (this.msgTimer > 0) this.msgTimer--;
      if (this.animTime > 0) this.animTime--;
    }

    draw() {
      const c = this.ctx;
      // clear
      c.fillStyle = palette.bg;
      c.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

      // gentle background wacky elements: clouds and floating bolts
      this.drawBackground(c);

      // machine body
      this.drawMachine(c);

      // slots
      this.drawSlots(c);

      // tiles row
      this.drawTiles(c);

      // UI top info: round, operation, target
      this.drawTopInfo(c);

      // message bar
      this.drawMessage(c);

      // audio visual indicator (speaker)
      this.drawAudioIcon(c);

      // accessibility hint text (small)
      this.drawHints(c);
    }

    drawBackground(c) {
      // subtle waves
      for (let i = 0; i < 3; i++) {
        c.beginPath();
        c.fillStyle = ['#eef7fb', '#f6fbff', '#eaf2f7'][i % 3];
        const y = 60 + i * 30;
        c.ellipse(GAME_WIDTH - i * 180 - 40, y, 120, 26, 0, 0, Math.PI * 2);
        c.fill();
      }
      // wacky floating robot head in corner
      const x = 60, y = 70;
      c.fillStyle = '#fff';
      c.beginPath();
      c.ellipse(x, y, 50, 40, 0, 0, Math.PI * 2);
      c.fill();
      c.fillStyle = '#dfeff8';
      c.fillRect(x - 38, y + 10, 76, 12);
      c.fillStyle = '#123';
      c.beginPath();
      c.arc(x - 18, y - 4, 5, 0, Math.PI * 2);
      c.fill();
      c.beginPath();
      c.arc(x + 18, y - 4, 5, 0, Math.PI * 2);
      c.fill();
      c.strokeStyle = '#8aa1b8';
      c.lineWidth = 2;
      c.beginPath();
      c.arc(x, y + 6, 12, 0, Math.PI);
      c.stroke();
    }

    drawMachine(c) {
      // Machine frame
      c.save();
      // shake effect
      const shakeOffset = this.animTime > 0 ? Math.sin(this.animTime * 0.7) * 6 : 0;
      c.translate(shakeOffset, 0);

      const mX = 120;
      const mY = 120;
      const mW = 480;
      const mH = 200;
      c.fillStyle = palette.machine;
      c.fillRect(mX, mY, mW, mH);
      c.strokeStyle = palette.dim;
      c.lineWidth = 3;
      c.strokeRect(mX, mY, mW, mH);

      // control panel (wacky knobs)
      c.fillStyle = '#fff';
      c.fillRect(mX + 20, mY + 16, 140, 54);
      c.strokeStyle = palette.dim;
      c.strokeRect(mX + 20, mY + 16, 140, 54);
      c.fillStyle = palette.accent;
      c.beginPath();
      c.arc(mX + 90, mY + 44, 12, 0, Math.PI * 2);
      c.fill();

      // Target display (round screen)
      const screenX = mX + mW - 140;
      const screenY = mY + 26;
      c.fillStyle = '#123';
      c.fillRect(screenX, screenY, 120, 56);
      c.fillStyle = '#eaf6ff';
      c.font = '28px "Arial"';
      c.textAlign = 'center';
      c.textBaseline = 'middle';
      const round = this.currentRound() || { target: '--', op: '?' };
      c.fillText(`${round.target}`, screenX + 60, screenY + 28);

      // machine window with gears
      const winX = mX + 80;
      const winY = mY + 90;
      const winW = 320;
      const winH = 88;
      c.fillStyle = '#d9f0ff';
      c.fillRect(winX, winY, winW, winH);
      c.strokeStyle = '#bcd9ea';
      c.strokeRect(winX, winY, winW, winH);

      // draw gears (animated)
      const time = Date.now() / 400;
      this.drawGear(c, winX + 60, winY + 44, 28, 10, time, '#c3e2f4');
      this.drawGear(c, winX + 160, winY + 44, 22, 8, -time * 1.2, '#b8dff0');
      this.drawGear(c, winX + 260, winY + 44, 16, 8, time * 1.8, '#d7effc');

      c.restore();
    }

    drawGear(c, cx, cy, radius, teeth, angle, color) {
      // simple stylized gear
      c.save();
      c.translate(cx, cy);
      c.rotate(angle);
      c.fillStyle = color;
      c.beginPath();
      const inner = radius * 0.65;
      for (let i = 0; i < teeth; i++) {
        const a1 = (i / teeth) * Math.PI * 2;
        const a2 = ((i + 0.5) / teeth) * Math.PI * 2;
        const a3 = ((i + 1) / teeth) * Math.PI * 2;
        c.lineTo(Math.cos(a1) * radius, Math.sin(a1) * radius);
        c.lineTo(Math.cos(a2) * (radius + 6), Math.sin(a2) * (radius + 6));
        c.lineTo(Math.cos(a3) * radius, Math.sin(a3) * radius);
      }
      c.closePath();
      c.fill();
      c.fillStyle = '#fff';
      c.beginPath();
      c.arc(0, 0, inner, 0, Math.PI * 2);
      c.fill();
      c.restore();
    }

    drawSlots(c) {
      // Draw two input slots
      c.font = '20px Arial';
      c.textAlign = 'center';
      c.textBaseline = 'middle';

      const slotABox = { x: 180, y: 170, w: 90, h: 90 };
      const slotBBox = { x: 360, y: 170, w: 90, h: 90 };

      // labels
      c.fillStyle = palette.text;
      c.fillText('Input A', slotABox.x + slotABox.w / 2, slotABox.y - 12);
      c.fillText('Input B', slotBBox.x + slotBBox.w / 2, slotBBox.y - 12);

      // slot backgrounds
      c.fillStyle = '#fff';
      c.strokeStyle = '#cfe8f6';
      c.lineWidth = 3;
      c.fillRect(slotABox.x, slotABox.y, slotABox.w, slotABox.h);
      c.strokeRect(slotABox.x, slotABox.y, slotABox.w, slotABox.h);
      c.fillRect(slotBBox.x, slotBBox.y, slotBBox.w, slotBBox.h);
      c.strokeRect(slotBBox.x, slotBBox.y, slotBBox.w, slotBBox.h);

      // values
      if (this.slotA) {
        this.drawTileOnSlot(c, slotABox.x + slotABox.w / 2, slotABox.y + slotABox.h / 2, this.slotA.value);
      } else {
        c.fillStyle = '#f7fbff';
        c.font = '18px Arial';
        c.fillText('choose', slotABox.x + slotABox.w / 2, slotABox.y + slotABox.h / 2);
      }

      if (this.slotB) {
        this.drawTileOnSlot(c, slotBBox.x + slotBBox.w / 2, slotBBox.y + slotBBox.h / 2, this.slotB.value);
      } else {
        c.fillStyle = '#f7fbff';
        c.font = '18px Arial';
        c.fillText('choose', slotBBox.x + slotBBox.w / 2, slotBBox.y + slotBBox.h / 2);
      }

      // operation display between slots
      const op = (this.currentRound() && this.currentRound().op) || '?';
      c.fillStyle = palette.accent2;
      c.beginPath();
      c.arc(300, 210, 22, 0, Math.PI * 2);
      c.fill();
      c.fillStyle = '#123';
      c.font = '20px Arial';
      c.fillText(op, 300, 210);
    }

    drawTileOnSlot(c, x, y, val) {
      c.fillStyle = palette.tile;
      c.strokeStyle = palette.dim;
      c.lineWidth = 2;
      c.beginPath();
      c.arc(x, y - 4, 28, 0, Math.PI * 2);
      c.fill();
      c.stroke();
      c.fillStyle = palette.tileText;
      c.font = '22px Arial';
      c.fillText(val, x, y - 6);
    }

    drawTiles(c) {
      // bottom row of number tiles 0-9
      const tileCount = this.tiles.length;
      const spacing = 60;
      const startX = (GAME_WIDTH - (spacing * tileCount - 10)) / 2;
      const baseY = GAME_HEIGHT - 120;
      for (let i = 0; i < tileCount; i++) {
        const cx = startX + i * spacing;
        const cy = baseY + 40;
        const r = 24;
        // tile background
        c.beginPath();
        c.fillStyle = palette.tile;
        c.strokeStyle = this.cursor === i ? palette.accent : palette.dim;
        c.lineWidth = this.cursor === i ? 4 : 2;
        c.arc(cx, cy, r, 0, Math.PI * 2);
        c.fill();
        c.stroke();
        // number
        c.fillStyle = palette.tileText;
        c.font = '20px Arial';
        c.textAlign = 'center';
        c.textBaseline = 'middle';
        c.fillText(this.tiles[i], cx, cy - 4);
      }
    }

    drawTopInfo(c) {
      c.fillStyle = palette.text;
      c.font = '16px Arial';
      c.textAlign = 'left';
      c.fillText(`Round ${this.round + 1} / ${this.maxRounds}`, 20, 28);
      const round = this.currentRound();
      c.fillText(`Operation: ${round ? round.op : '-'}`, 20, 54);
      c.textAlign = 'right';
      c.fillText(`Target: ${round ? round.target : '--'}`, GAME_WIDTH - 20, 36);
    }

    drawMessage(c) {
      // bottom message bar
      c.fillStyle = '#ffffff';
      c.fillRect(0, GAME_HEIGHT - 64, GAME_WIDTH, 64);
      c.strokeStyle = '#d6e8f2';
      c.strokeRect(0, GAME_HEIGHT - 64, GAME_WIDTH, 64);
      c.fillStyle = palette.text;
      c.font = '16px Arial';
      c.textAlign = 'center';
      c.textBaseline = 'middle';
      c.fillText(this.message || '', GAME_WIDTH / 2, GAME_HEIGHT - 32);
    }

    drawAudioIcon(c) {
      const x = GAME_WIDTH - 24;
      const y = 28;
      // box
      c.fillStyle = '#fff';
      c.strokeStyle = '#d6e8f2';
      c.fillRect(GAME_WIDTH - 58, 10, 48, 36);
      c.strokeRect(GAME_WIDTH - 58, 10, 48, 36);

      // speaker icon
      c.fillStyle = this.audioOn ? palette.accent : palette.dim;
      c.beginPath();
      c.moveTo(x - 10, y - 6);
      c.lineTo(x - 2, y - 6);
      c.lineTo(x + 6, y - 14);
      c.lineTo(x + 6, y + 14);
      c.lineTo(x - 2, y + 6);
      c.lineTo(x - 10, y + 6);
      c.closePath();
      c.fill();

      // waves
      if (this.audioOn) {
        c.strokeStyle = palette.accent;
        c.lineWidth = 2;
        c.beginPath();
        c.arc(x + 8, y - 2, 8, -0.8, 0.8);
        c.stroke();
      } else {
        c.strokeStyle = palette.dim;
        c.lineWidth = 2;
        c.beginPath();
        c.moveTo(x + 6, y - 10);
        c.lineTo(x + 14, y + 8);
        c.stroke();
      }
    }

    drawHints(c) {
      c.fillStyle = '#6a8196';
      c.font = '12px Arial';
      c.textAlign = 'left';
      c.fillText('Keys: ← → to move, Enter to place, Backspace to remove, A audio, R restart', 12, GAME_HEIGHT - 8);
    }
  }

  // Instantiate game
  const game = new MachineMathGame(ctx, audio);

  // Focus canvas for keyboard
  canvas.addEventListener('focus', () => {
    game.focused = true;
  });
  canvas.addEventListener('blur', () => {
    game.focused = false;
  });

  // Mouse handling
  canvas.addEventListener('mousedown', (ev) => {
    const rect = canvas.getBoundingClientRect();
    const x = ((ev.clientX - rect.left) / rect.width) * canvas.width;
    const y = ((ev.clientY - rect.top) / rect.height) * canvas.height;
    try {
      // User gesture: resume audio context if needed
      if (audio && audio.supported) audio.resumeIfNeeded().catch(() => {});
    } catch (e) {
      console.warn('Audio resume on click failed', e);
    }
    game.handleMouseClick(x, y);
  });

  // Keyboard handling
  canvas.addEventListener('keydown', (ev) => {
    // Prevent page scrolling for arrow keys and space
    if (['ArrowLeft', 'ArrowRight', ' ', 'Spacebar', 'Backspace'].includes(ev.key)) {
      ev.preventDefault();
    }
    try {
      game.handleKey(ev);
    } catch (e) {
      console.error('Key handling error', e);
    }
  });

  // Also capture global keydown when canvas is focused to help accessibility
  window.addEventListener('keydown', (ev) => {
    if (document.activeElement !== canvas) return;
    if (['ArrowLeft', 'ArrowRight', 'Enter', 'Backspace', ' ', 'a', 'A', 'r', 'R'].includes(ev.key)) {
      // forward to canvas handler
      const event = new KeyboardEvent('keydown', ev);
      canvas.dispatchEvent(event);
    }
  });

  // Resize observer not needed since we have fixed size

  // Game loop
  function loop() {
    game.update();
    game.draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Provide a friendly intro overlay drawn for a moment
  let introFrames = 240;
  function introAnimate() {
    if (introFrames <= 0) return;
    const c = ctx;
    c.save();
    c.fillStyle = 'rgba(255,255,255,0.6)';
    c.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    c.fillStyle = '#123';
    c.font = '28px Arial';
    c.textAlign = 'center';
    c.textBaseline = 'middle';
    c.fillText('Machine Math', GAME_WIDTH / 2, GAME_HEIGHT / 2 - 40);
    c.font = '18px Arial';
    c.fillText('Feed numbers to the machine to reach the target number', GAME_WIDTH / 2, GAME_HEIGHT / 2);
    c.fillText('Use arrows + Enter, or click tiles. Press A to toggle audio.', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 30);
    c.restore();
    introFrames--;
    if (introFrames > 0) requestAnimationFrame(introAnimate);
  }
  introAnimate();

  // Provide small instructions to screen readers
  liveRegion.textContent = 'Machine Math ready. Use arrow keys to move, Enter to place numbers, Backspace to remove. Press A to toggle audio, R to restart. Click the canvas and interact to enable audio.';

  // Ensure audio toggle button can be activated by click via canvas area (handled in mousedown)
  // Expose simple API for testing (optional)
  window._machineMathGame = {
    restart: () => game.restart(),
    toggleAudio: () => game.toggleAudio(),
  };
})();
---

