{
  "generated_date": "2025-09-17",
  "generated_timestamp": "2025-09-17T00:27:08.927586",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 10072,
  "game_filename": "2025-09-17.js",
  "game_size_bytes": 30254,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Machines Math Game\n  // Designed for children ages 7-9. Rendered inside element with ID \"game-of-the-day-stage\".\n  // All visuals are drawn on a canvas. Sounds are generated with Web Audio API oscillators/filters.\n  // Accessible via keyboard and mouse. Clean, commented code.\n\n  // --- Setup container and canvas ---\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Game container with ID \"game-of-the-day-stage\" not found.');\n    return;\n  }\n  // Clear container\n  container.innerHTML = '';\n  container.style.position = 'relative';\n  container.style.width = '720px';\n  container.style.height = '480px';\n  container.setAttribute('role', 'application');\n  container.setAttribute('aria-label', 'Machines Math Game. Press Enter to begin.');\n\n  const canvas = document.createElement('canvas');\n  canvas.width = 720;\n  canvas.height = 480;\n  canvas.setAttribute('aria-hidden', 'false');\n  canvas.style.display = 'block';\n  canvas.style.outline = 'none';\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Accessible text area and controls (live region)\n  const liveRegion = document.createElement('div');\n  liveRegion.setAttribute('aria-live', 'polite');\n  liveRegion.style.position = 'absolute';\n  liveRegion.style.left = '0';\n  liveRegion.style.top = '0';\n  liveRegion.style.width = '1px';\n  liveRegion.style.height = '1px';\n  liveRegion.style.overflow = 'hidden';\n  liveRegion.style.clip = 'rect(1px, 1px, 1px, 1px)';\n  container.appendChild(liveRegion);\n\n  // On-screen instructions area so players can read controls\n  const instructionsBox = document.createElement('div');\n  instructionsBox.style.position = 'absolute';\n  instructionsBox.style.left = '8px';\n  instructionsBox.style.top = '8px';\n  instructionsBox.style.padding = '6px 8px';\n  instructionsBox.style.background = 'rgba(255,255,255,0.85)';\n  instructionsBox.style.borderRadius = '8px';\n  instructionsBox.style.fontFamily = 'sans-serif';\n  instructionsBox.style.fontSize = '12px';\n  instructionsBox.style.color = '#222';\n  instructionsBox.style.maxWidth = '340px';\n  instructionsBox.innerHTML =\n    '<strong>Machines Math</strong><br>Use \u2190 \u2192 or A/D to move. Press Space or Enter to pick a tile. Click tiles to pick. Press M to mute/unmute audio. Press Enter to start.';\n  container.appendChild(instructionsBox);\n\n  // Audio state and Web Audio API setup\n  let audioEnabled = true;\n  let audioContext = null;\n  let masterGain = null;\n  let backgroundOsc = null;\n  let backgroundLFO = null;\n  let audioAvailable = false;\n\n  function initAudio() {\n    try {\n      // Some browsers require user gesture to resume; handle gracefully\n      const AudioCtx = window.AudioContext || window.webkitAudioContext;\n      if (!AudioCtx) {\n        throw new Error('Web Audio API not supported.');\n      }\n      audioContext = new AudioCtx();\n      masterGain = audioContext.createGain();\n      masterGain.gain.value = 0.12; // default low volume\n      masterGain.connect(audioContext.destination);\n\n      // Background gentle hum\n      backgroundOsc = audioContext.createOscillator();\n      backgroundOsc.type = 'sine';\n      backgroundOsc.frequency.value = 110; // low hum\n      const bgFilter = audioContext.createBiquadFilter();\n      bgFilter.type = 'lowpass';\n      bgFilter.frequency.value = 500;\n      backgroundOsc.connect(bgFilter);\n\n      backgroundLFO = audioContext.createOscillator();\n      backgroundLFO.type = 'sine';\n      backgroundLFO.frequency.value = 0.08;\n      const lfoGain = audioContext.createGain();\n      lfoGain.gain.value = 10;\n\n      backgroundLFO.connect(lfoGain);\n      lfoGain.connect(bgFilter.frequency);\n\n      bgFilter.connect(masterGain);\n\n      backgroundOsc.start();\n      backgroundLFO.start();\n\n      audioAvailable = true;\n      audioEnabled = true;\n    } catch (e) {\n      console.warn('Audio initialization failed:', e);\n      audioAvailable = false;\n      audioEnabled = false;\n    }\n  }\n\n  function tryResumeAudio() {\n    if (!audioContext) return;\n    if (typeof audioContext.resume === 'function') {\n      audioContext.resume().catch((e) => {\n        console.warn('Audio resume failed:', e);\n      });\n    }\n  }\n\n  // Utility to play a short tone/pulse\n  function playTone({ freq = 440, type = 'sine', duration = 0.2, volume = 0.18, attack = 0.01, release = 0.05 }) {\n    if (!audioAvailable || !audioEnabled) return;\n    try {\n      const now = audioContext.currentTime;\n      const osc = audioContext.createOscillator();\n      const gain = audioContext.createGain();\n      const filter = audioContext.createBiquadFilter();\n      filter.type = 'lowpass';\n      filter.frequency.value = Math.max(800, freq * 2);\n\n      osc.type = type;\n      osc.frequency.setValueAtTime(freq, now);\n      gain.gain.setValueAtTime(0.0001, now);\n      gain.gain.linearRampToValueAtTime(volume, now + attack);\n      gain.gain.linearRampToValueAtTime(0.0001, now + duration - release);\n\n      osc.connect(filter);\n      filter.connect(gain);\n      gain.connect(masterGain);\n\n      osc.start(now);\n      osc.stop(now + duration + 0.05);\n    } catch (e) {\n      console.warn('playTone error', e);\n    }\n  }\n\n  function playSuccess() {\n    // Harmonious burst\n    playTone({ freq: 660, type: 'sine', duration: 0.18, volume: 0.16 });\n    setTimeout(() => playTone({ freq: 880, type: 'triangle', duration: 0.14, volume: 0.12 }), 70);\n    setTimeout(() => playTone({ freq: 1100, type: 'sine', duration: 0.12, volume: 0.08 }), 150);\n    announce('Correct! Machine powered up.');\n  }\n\n  function playFail() {\n    // Gentle buzzer in lower octave\n    playTone({ freq: 180, type: 'square', duration: 0.28, volume: 0.14 });\n    setTimeout(() => playTone({ freq: 120, type: 'square', duration: 0.15, volume: 0.10 }), 80);\n    announce('Not quite. Try again.');\n  }\n\n  function announce(text) {\n    liveRegion.textContent = text;\n  }\n\n  // Start audio on user gesture to satisfy browsers\n  function ensureAudioOnUserGesture() {\n    function userGesture() {\n      tryResumeAudio();\n      window.removeEventListener('keydown', userGesture);\n      window.removeEventListener('pointerdown', userGesture);\n    }\n    window.addEventListener('keydown', userGesture);\n    window.addEventListener('pointerdown', userGesture);\n  }\n\n  // Initialize audio but allow for browsers blocking until gesture\n  initAudio();\n  ensureAudioOnUserGesture();\n\n  // --- Game state ---\n  const GAME_WIDTH = 720;\n  const GAME_HEIGHT = 480;\n\n  let running = true;\n  let lastTime = 0;\n  let frame = 0;\n\n  const levels = [\n    { target: 8, tiles: 4, maxNum: 9 }, // easy\n    { target: 12, tiles: 4, maxNum: 12 },\n    { target: 15, tiles: 5, maxNum: 15 },\n    { target: 18, tiles: 5, maxNum: 20 },\n    { target: 21, tiles: 6, maxNum: 20 }\n  ];\n  let currentLevelIndex = -1;\n  let tiles = []; // {value, x, y, w, h, picked}\n  let selectorIndex = 0;\n  let picks = []; // indices of picked tiles for current attempt\n  let attempts = 0;\n  let maxAttemptsBeforeHint = 2;\n  let showOverlay = true;\n  let gameMessage = 'Press Enter to Start!';\n  let victory = false;\n  let audioMutedVisual = false;\n\n  // Floating gears for background animation\n  const floatingGears = [];\n  for (let i = 0; i < 8; i++) {\n    floatingGears.push({\n      x: Math.random() * GAME_WIDTH,\n      y: Math.random() * GAME_HEIGHT,\n      r: 12 + Math.random() * 28,\n      speed: 0.1 + Math.random() * 0.35,\n      angle: Math.random() * Math.PI * 2,\n      color: `hsla(${120 + Math.random() * 80}, 60%, ${60 - Math.random() * 10}%, 0.15)`\n    });\n  }\n\n  // --- Helper functions for level generation ---\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  function generateLevel(index) {\n    const def = levels[index];\n    const count = def.tiles;\n    const maxNum = def.maxNum;\n    const target = def.target;\n    const optionCount = count;\n\n    // Ensure there exists at least one solution of two numbers adding to target\n    // We'll construct options guaranteeing at least one correct pair.\n    const options = [];\n    // choose one correct pair (a,b)\n    let a = randInt(1, Math.min(maxNum, target - 1));\n    let b = target - a;\n    if (b < 1) {\n      a = 1;\n      b = target - a;\n    }\n    options.push(a, b);\n\n    // fill the rest with distractors (random numbers)\n    while (options.length < optionCount) {\n      let n = randInt(1, maxNum);\n      // avoid duplicates too many times\n      if (options.includes(n) && Math.random() > 0.5) continue;\n      // avoid accidentally creating an extra correct pair too often\n      // but it's ok if multiple solutions exist\n      options.push(n);\n    }\n\n    // Shuffle options\n    for (let i = options.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [options[i], options[j]] = [options[j], options[i]];\n    }\n\n    // Place tiles along a conveyor belt area\n    tiles = [];\n    const beltLeft = 60;\n    const beltRight = GAME_WIDTH - 60;\n    const beltTop = 320;\n    const availableWidth = beltRight - beltLeft;\n    const tileWidth = Math.min(110, Math.floor(availableWidth / optionCount) - 10);\n    for (let i = 0; i < options.length; i++) {\n      const w = tileWidth;\n      const h = 60;\n      const spacing = (availableWidth - optionCount * w) / (optionCount - 1 || 1);\n      const x = beltLeft + i * (w + spacing);\n      const y = beltTop + 20 + (Math.sin(i * 0.8) * 4);\n      tiles.push({\n        value: options[i],\n        x,\n        y,\n        w,\n        h,\n        picked: false,\n        hover: false\n      });\n    }\n    selectorIndex = 0;\n    picks = [];\n    attempts = 0;\n    victory = false;\n    gameMessage = `Make ${target} by selecting two tiles that add to it.`;\n    announce(gameMessage);\n    return { target };\n  }\n\n  let currentLevel = null;\n\n  function startNextLevel() {\n    currentLevelIndex++;\n    if (currentLevelIndex >= levels.length) {\n      // Victory!\n      victory = true;\n      showOverlay = true;\n      gameMessage = 'You fixed all the machines! Great job!';\n      announce(gameMessage);\n      return;\n    }\n    currentLevel = generateLevel(currentLevelIndex);\n    showOverlay = false;\n  }\n\n  // --- Drawing functions ---\n  function drawBackground(delta) {\n    // Soft gradient\n    const g = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);\n    g.addColorStop(0, '#EAF8FF');\n    g.addColorStop(1, '#F7FFF7');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);\n\n    // Floating gears (wacky shapes)\n    floatingGears.forEach((gear, i) => {\n      gear.y -= gear.speed * delta * 0.06;\n      gear.angle += 0.003 * (i % 3 === 0 ? 1 : -1) * delta * 0.02;\n      if (gear.y + gear.r < -20) {\n        gear.y = GAME_HEIGHT + 40;\n        gear.x = Math.random() * GAME_WIDTH;\n      }\n      ctx.save();\n      ctx.translate(gear.x, gear.y);\n      ctx.rotate(gear.angle);\n      ctx.fillStyle = gear.color;\n      drawGear(0, 0, gear.r, 8, 0.45);\n      ctx.restore();\n    });\n\n    // Light piston motion shapes as subtle stripes\n    ctx.save();\n    ctx.globalAlpha = 0.06;\n    ctx.fillStyle = '#000';\n    for (let i = -1; i < GAME_WIDTH / 60 + 2; i++) {\n      ctx.beginPath();\n      ctx.ellipse(40 + i * 60 - (frame % 200) / 8, GAME_HEIGHT - 40, 60, 16, 0, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    ctx.restore();\n  }\n\n  function drawGear(cx, cy, r, teeth = 8, innerRatio = 0.5) {\n    // Draw a gear shape\n    const outer = r;\n    const inner = r * innerRatio;\n    ctx.beginPath();\n    for (let i = 0; i < teeth; i++) {\n      const a = (i / teeth) * Math.PI * 2;\n      const a2 = ((i + 0.5) / teeth) * Math.PI * 2;\n      const ax = Math.cos(a) * outer;\n      const ay = Math.sin(a) * outer;\n      ctx.lineTo(ax, ay);\n      const bx = Math.cos(a2) * inner;\n      const by = Math.sin(a2) * inner;\n      ctx.lineTo(bx, by);\n    }\n    ctx.closePath();\n    ctx.fill();\n    // center hole\n    ctx.fillStyle = '#FFF';\n    ctx.beginPath();\n    ctx.arc(0, 0, inner * 0.45, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  function drawMachineArea() {\n    // Central machine with two slots\n    const mx = GAME_WIDTH / 2;\n    const my = 160;\n    const mw = 420;\n    const mh = 180;\n\n    // Machine body\n    ctx.save();\n    // Body shadow\n    ctx.fillStyle = '#000';\n    ctx.globalAlpha = 0.06;\n    ctx.fillRect(mx - mw / 2 + 10, my - mh / 2 + 10, mw, mh);\n    ctx.globalAlpha = 1;\n    // Body\n    const grad = ctx.createLinearGradient(mx - mw / 2, my - mh / 2, mx + mw / 2, my + mh / 2);\n    grad.addColorStop(0, '#FFFBEE');\n    grad.addColorStop(1, '#E8F7FF');\n    roundRect(ctx, mx - mw / 2, my - mh / 2, mw, mh, 18, true, false);\n    ctx.fillStyle = grad;\n    ctx.globalAlpha = 1;\n    ctx.fill();\n\n    // Pipes and dials\n    ctx.fillStyle = '#D5EAF1';\n    roundRect(ctx, mx - mw / 2 + 12, my - mh / 2 + 12, mw - 24, mh - 24, 12, true, false);\n    // Slots for numbers\n    const slotW = 110;\n    const slotH = 60;\n    const leftSlotX = mx - 80 - slotW / 2;\n    const rightSlotX = mx + 80 - slotW / 2;\n    const slotY = my - slotH / 2;\n    // left slot\n    ctx.fillStyle = '#FFF';\n    roundRect(ctx, leftSlotX, slotY, slotW, slotH, 10, true, false);\n    ctx.fillStyle = '#BFDDE9';\n    ctx.fillRect(leftSlotX, slotY + slotH - 10, slotW, 8);\n    // right slot\n    ctx.fillStyle = '#FFF';\n    roundRect(ctx, rightSlotX, slotY, slotW, slotH, 10, true, false);\n    ctx.fillStyle = '#BFDDE9';\n    ctx.fillRect(rightSlotX, slotY + slotH - 10, slotW, 8);\n\n    // Target display\n    ctx.fillStyle = '#111';\n    ctx.font = '700 26px \"Segoe UI\", Roboto, Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText(`Target: ${currentLevel ? currentLevel.target : '-'}`, mx, my - mh / 2 + 36);\n\n    // Fill the picks visually\n    ctx.fillStyle = '#222';\n    ctx.font = '700 34px \"Segoe UI\", Roboto, Arial';\n    if (picks.length > 0) {\n      const val = tiles[picks[0]] ? tiles[picks[0]].value : '';\n      ctx.fillText(val, leftSlotX + slotW / 2, slotY + slotH / 2 + 11);\n    } else {\n      ctx.fillStyle = '#888';\n      ctx.font = '600 18px \"Segoe UI\", Roboto, Arial';\n      ctx.fillText('Add first tile', leftSlotX + slotW / 2, slotY + slotH / 2 + 8);\n    }\n    if (picks.length > 1) {\n      ctx.fillStyle = '#222';\n      ctx.font = '700 34px \"Segoe UI\", Roboto, Arial';\n      const val = tiles[picks[1]] ? tiles[picks[1]].value : '';\n      ctx.fillText(val, rightSlotX + slotW / 2, slotY + slotH / 2 + 11);\n    } else {\n      ctx.fillStyle = '#888';\n      ctx.font = '600 18px \"Segoe UI\", Roboto, Arial';\n      ctx.fillText('Add second tile', rightSlotX + slotW / 2, slotY + slotH / 2 + 8);\n    }\n\n    // Power meter\n    const meterX = mx + mw / 2 - 46;\n    const meterY = my - mh / 2 + 12;\n    const meterH = 100;\n    ctx.fillStyle = '#EEE';\n    roundRect(ctx, meterX, meterY, 28, meterH, 6, true, false);\n    // compute current power if picks 2\n    let powerRatio = 0;\n    if (picks.length === 2) {\n      const sum = tiles[picks[0]].value + tiles[picks[1]].value;\n      powerRatio = Math.max(0, Math.min(1, sum / (currentLevel.target * 1.2)));\n    } else {\n      powerRatio = 0.1;\n    }\n    const filledH = meterH * powerRatio;\n    ctx.fillStyle = '#9EE493';\n    roundRect(ctx, meterX + 2, meterY + meterH - filledH + 2, 24, filledH - 4, 6, true, false);\n\n    // Labels for machine\n    ctx.fillStyle = '#2B3A42';\n    ctx.font = '600 14px \"Segoe UI\", Roboto, Arial';\n    ctx.fillText('Power', meterX + 14, meterY + meterH + 16);\n\n    ctx.restore();\n  }\n\n  function drawTiles() {\n    // Conveyor belt\n    const beltX = 40;\n    const beltY = 340;\n    const beltW = GAME_WIDTH - 80;\n    const beltH = 92;\n\n    ctx.save();\n    ctx.fillStyle = '#DDEFF3';\n    roundRect(ctx, beltX, beltY, beltW, beltH, 12, true, false);\n\n    // moving stripes\n    ctx.globalAlpha = 0.08;\n    ctx.fillStyle = '#000';\n    for (let i = 0; i < 6; i++) {\n      ctx.fillRect(beltX + ((frame * 0.7 + i * 80) % beltW), beltY + 12, 40, beltH - 24);\n    }\n    ctx.globalAlpha = 1;\n\n    // Draw each tile\n    tiles.forEach((tile, i) => {\n      const x = tile.x;\n      const y = tile.y;\n      const w = tile.w;\n      const h = tile.h;\n      // detect selector\n      const isSelected = selectorIndex === i;\n      // tile body\n      ctx.save();\n      // shadow\n      ctx.fillStyle = 'rgba(0,0,0,0.08)';\n      roundRect(ctx, x + 4, y + 8, w, h, 10, true, false);\n      // main\n      const base = `hsl(${190 + (i * 40) % 120}, 70%, ${55 - (i % 3) * 6}%)`;\n      ctx.fillStyle = tile.picked ? '#EAEEF2' : base;\n      roundRect(ctx, x, y, w, h, 10, true, false);\n\n      // if hovered or selected highlight\n      if (isSelected || tile.hover) {\n        ctx.lineWidth = 3;\n        ctx.strokeStyle = 'rgba(255,215,120,0.95)';\n        roundedRectStroke(ctx, x - 2, y - 2, w + 4, h + 4, 12);\n      } else {\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = 'rgba(0,0,0,0.06)';\n        roundedRectStroke(ctx, x, y, w, h, 10);\n      }\n\n      // tile number\n      ctx.fillStyle = tile.picked ? '#888' : '#143';\n      ctx.font = tile.picked ? '600 22px \"Segoe UI\", Roboto' : '700 28px \"Segoe UI\", Roboto';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(tile.value, x + w / 2, y + h / 2);\n\n      // little machine icon on tile\n      ctx.fillStyle = 'rgba(255,255,255,0.35)';\n      ctx.beginPath();\n      ctx.arc(x + 20, y + 18, 10 + Math.sin((frame + i * 40) * 0.06) * 2, 0, Math.PI * 2);\n      ctx.fill();\n\n      ctx.restore();\n    });\n\n    ctx.restore();\n  }\n\n  function drawSelector() {\n    // Draw a wrench pointing at selected tile\n    const tile = tiles[selectorIndex];\n    if (!tile) return;\n    const x = tile.x + tile.w / 2;\n    const y = tile.y - 24;\n    ctx.save();\n    // Shaft\n    ctx.strokeStyle = '#333';\n    ctx.lineWidth = 6;\n    ctx.lineCap = 'round';\n    ctx.beginPath();\n    ctx.moveTo(x - 40, y + 20 + Math.sin(frame * 0.05) * 1.5);\n    ctx.lineTo(x, y);\n    ctx.stroke();\n\n    // Wrench head\n    ctx.fillStyle = '#465861';\n    ctx.beginPath();\n    ctx.arc(x, y, 14, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = '#FFF';\n    ctx.font = '700 12px \"Segoe UI\", Roboto';\n    ctx.textAlign = 'center';\n    ctx.fillText('Grab', x, y + 4);\n\n    // Focus ring on tile (for keyboard)\n    ctx.strokeStyle = 'rgba(64, 160, 255, 0.9)';\n    ctx.lineWidth = 3;\n    roundedRectStroke(ctx, tile.x - 4, tile.y - 4, tile.w + 8, tile.h + 8, 12);\n\n    ctx.restore();\n  }\n\n  function drawHUD() {\n    // top right small controls: level, attempts, audio icon\n    ctx.save();\n    ctx.fillStyle = 'rgba(255,255,255,0.9)';\n    roundRect(ctx, GAME_WIDTH - 200, 12, 188, 44, 10, true, false);\n    ctx.fillStyle = '#344';\n    ctx.font = '600 14px \"Segoe UI\", Roboto';\n    ctx.textAlign = 'left';\n    ctx.fillText(`Level ${Math.min(currentLevelIndex + 1, levels.length)}/${levels.length}`, GAME_WIDTH - 188, 30);\n\n    ctx.font = '600 14px \"Segoe UI\", Roboto';\n    ctx.fillStyle = '#666';\n    ctx.textAlign = 'right';\n    ctx.fillText(`Attempts: ${attempts}`, GAME_WIDTH - 18, 30);\n\n    // Audio icon\n    ctx.fillStyle = audioEnabled ? '#4CAF50' : '#D9534F';\n    ctx.beginPath();\n    ctx.roundRect = ctx.roundRect || function (x, y, w, h, r) {\n      // polyfill if not present\n      ctx.moveTo(x + r, y);\n      ctx.arcTo(x + w, y, x + w, y + h, r);\n      ctx.arcTo(x + w, y + h, x, y + h, r);\n      ctx.arcTo(x, y + h, x, y, r);\n      ctx.arcTo(x, y, x + w, y, r);\n    };\n    // draw a simple speaker box\n    const sx = GAME_WIDTH - 58;\n    const sy = 18;\n    ctx.fillRect(sx, sy, 14, 12);\n    ctx.beginPath();\n    ctx.moveTo(sx + 14, sy);\n    ctx.lineTo(sx + 22, sy + 6);\n    ctx.lineTo(sx + 14, sy + 12);\n    ctx.closePath();\n    ctx.fill();\n\n    if (!audioEnabled) {\n      // draw a line across\n      ctx.strokeStyle = '#FFF';\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(sx - 4, sy + 2);\n      ctx.lineTo(sx + 30, sy + 14);\n      ctx.stroke();\n    }\n\n    ctx.restore();\n\n    // bottom left message\n    ctx.save();\n    ctx.fillStyle = 'rgba(255,255,255,0.9)';\n    roundRect(ctx, 12, GAME_HEIGHT - 64, 360, 52, 10, true, false);\n    ctx.fillStyle = '#234';\n    ctx.font = '600 14px \"Segoe UI\", Roboto';\n    ctx.textAlign = 'left';\n    ctx.fillText(gameMessage, 22, GAME_HEIGHT - 36);\n    ctx.restore();\n  }\n\n  function drawOverlay() {\n    if (!showOverlay) return;\n    ctx.save();\n    // dim background\n    ctx.fillStyle = 'rgba(12,22,28,0.55)';\n    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);\n    // centered box\n    ctx.fillStyle = '#FFF';\n    roundRect(ctx, GAME_WIDTH / 2 - 260, GAME_HEIGHT / 2 - 80, 520, 160, 14, true, false);\n    ctx.fillStyle = '#314658';\n    ctx.font = '700 20px \"Segoe UI\", Roboto';\n    ctx.textAlign = 'center';\n    ctx.fillText(victory ? 'Machine Master!' : 'Machines Math', GAME_WIDTH / 2, GAME_HEIGHT / 2 - 36);\n    ctx.font = '600 16px \"Segoe UI\", Roboto';\n    ctx.fillStyle = '#2B3A42';\n    ctx.fillText(gameMessage, GAME_WIDTH / 2, GAME_HEIGHT / 2 - 2);\n    ctx.font = '600 14px \"Segoe UI\", Roboto';\n    ctx.fillStyle = '#436';\n    ctx.fillText('Controls: \u2190 \u2192 / A D to move, Space or Enter to pick, Click to pick tiles, M to mute', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 28);\n\n    // big start/continue button visual\n    ctx.fillStyle = '#6DD3B4';\n    roundRect(ctx, GAME_WIDTH / 2 - 80, GAME_HEIGHT / 2 + 40, 160, 36, 8, true, false);\n    ctx.fillStyle = '#053';\n    ctx.font = '700 16px \"Segoe UI\", Roboto';\n    ctx.fillText(victory ? 'Play Again' : 'Start', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 66);\n\n    ctx.restore();\n  }\n\n  // Utility drawing helpers\n  function roundRect(ctx, x, y, w, h, r, fill, stroke) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  function roundedRectStroke(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.stroke();\n  }\n\n  // --- Game logic interactions ---\n  function pickTile(index) {\n    if (!tiles[index] || tiles[index].picked) {\n      return;\n    }\n    // pick the tile\n    tiles[index].picked = true;\n    picks.push(index);\n    playTone({ freq: 420 + tiles[index].value * 6, type: 'sine', duration: 0.12, volume: 0.12 });\n    announce(`Picked ${tiles[index].value}`);\n\n    if (picks.length === 2) {\n      attempts++;\n      const val1 = tiles[picks[0]].value;\n      const val2 = tiles[picks[1]].value;\n      const sum = val1 + val2;\n      if (sum === currentLevel.target) {\n        // correct\n        playSuccess();\n        // animate power up (simple)\n        setTimeout(() => {\n          // prepare next level\n          if (currentLevelIndex + 1 >= levels.length) {\n            victory = true;\n            showOverlay = true;\n            gameMessage = 'You fixed all the machines! Great job!';\n            announce(gameMessage);\n          } else {\n            gameMessage = 'Great! Machine repaired. Next machine incoming...';\n            announce(gameMessage);\n            setTimeout(() => {\n              startNextLevel();\n            }, 900);\n          }\n        }, 200);\n      } else {\n        // incorrect\n        playFail();\n        // visual shake and unpick after short delay\n        gameMessage = `Oops! ${val1} + ${val2} = ${sum}. Try again.`;\n        announce(gameMessage);\n        setTimeout(() => {\n          // put tiles back\n          picks.forEach((pi) => {\n            if (tiles[pi]) tiles[pi].picked = false;\n          });\n          picks = [];\n          // hint if many attempts\n          if (attempts >= maxAttemptsBeforeHint) {\n            const hint = findHint(currentLevel.target, tiles.map((t) => t.value));\n            if (hint) {\n              gameMessage = `Hint: Try ${hint[0]} and ${hint[1]}.`;\n              announce(gameMessage);\n            } else {\n              gameMessage = 'No matching pair among the tiles. Try different combination.';\n              announce(gameMessage);\n            }\n          }\n        }, 700);\n      }\n    }\n  }\n\n  function findHint(target, values) {\n    for (let i = 0; i < values.length; i++) {\n      for (let j = i + 1; j < values.length; j++) {\n        if (values[i] + values[j] === target) return [values[i], values[j]];\n      }\n    }\n    return null;\n  }\n\n  // Reset game\n  function resetGame() {\n    currentLevelIndex = -1;\n    victory = false;\n    startNextLevel();\n  }\n\n  // --- Input handling (keyboard & mouse) ---\n  window.addEventListener('keydown', (e) => {\n    if (!running) return;\n    const key = e.key;\n    if (showOverlay) {\n      if (key === 'Enter' || key === ' ') {\n        // start or continue\n        e.preventDefault();\n        if (victory) {\n          // restart\n          resetGame();\n        } else {\n          startNextLevel();\n        }\n        tryResumeAudio();\n        return;\n      }\n    }\n\n    if (key === 'ArrowLeft' || key === 'a' || key === 'A') {\n      selectorIndex = Math.max(0, selectorIndex - 1);\n      announce(`Selected tile ${selectorIndex + 1}`);\n    } else if (key === 'ArrowRight' || key === 'd' || key === 'D') {\n      selectorIndex = Math.min(tiles.length - 1, selectorIndex + 1);\n      announce(`Selected tile ${selectorIndex + 1}`);\n    } else if (key === ' ' || key === 'Enter') {\n      // pick current\n      e.preventDefault();\n      pickTile(selectorIndex);\n    } else if (/^[1-9]$/.test(key)) {\n      // quick pick by number key (1..9) maps to tile indices\n      const idx = parseInt(key, 10) - 1;\n      if (tiles[idx]) {\n        selectorIndex = idx;\n        pickTile(idx);\n      }\n    } else if (key === 'm' || key === 'M') {\n      audioEnabled = !audioEnabled;\n      announce(audioEnabled ? 'Audio on' : 'Audio muted');\n    } else if (key === 'Escape') {\n      // Show overlay/instructions\n      showOverlay = true;\n      gameMessage = 'Paused. Press Enter to continue.';\n      announce(gameMessage);\n    }\n  });\n\n  canvas.addEventListener('mousemove', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    tiles.forEach((t, i) => {\n      const over = mx >= t.x && mx <= t.x + t.w && my >= t.y && my <= t.y + t.h;\n      t.hover = over;\n      if (over) {\n        selectorIndex = i;\n      }\n    });\n  });\n\n  canvas.addEventListener('mouseleave', (e) => {\n    tiles.forEach((t) => (t.hover = false));\n  });\n\n  canvas.addEventListener('click', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    if (showOverlay) {\n      // If click inside start button area\n      const bx = GAME_WIDTH / 2 - 80;\n      const by = GAME_HEIGHT / 2 + 40;\n      const bw = 160;\n      const bh = 36;\n      if (mx >= bx && mx <= bx + bw && my >= by && my <= by + bh) {\n        if (victory) resetGame();\n        else startNextLevel();\n        tryResumeAudio();\n      }\n      return;\n    }\n    // Click tiles\n    for (let i = 0; i < tiles.length; i++) {\n      const t = tiles[i];\n      if (mx >= t.x && mx <= t.x + t.w && my >= t.y && my <= t.y + t.h) {\n        selectorIndex = i;\n        pickTile(i);\n        break;\n      }\n    }\n    // Click audio icon region\n    const sx = GAME_WIDTH - 58;\n    const sy = 18;\n    if (mx >= sx - 6 && mx <= sx + 36 && my >= sy - 6 && my <= sy + 20) {\n      audioEnabled = !audioEnabled;\n      announce(audioEnabled ? 'Audio on' : 'Audio muted');\n    }\n  });\n\n  // Touch support taps -> click logic\n  canvas.addEventListener('touchstart', (e) => {\n    if (e.touches.length > 0) {\n      const t = e.touches[0];\n      const rect = canvas.getBoundingClientRect();\n      const mx = t.clientX - rect.left;\n      const my = t.clientY - rect.top;\n      // emulate click\n      canvas.dispatchEvent(new MouseEvent('click', { clientX: t.clientX, clientY: t.clientY }));\n    }\n    e.preventDefault();\n  }, { passive: false });\n\n  // --- Main loop ---\n  function update(dt) {\n    // gear animations updated in drawBackground via frame/time\n  }\n\n  function render(timestamp) {\n    if (!lastTime) lastTime = timestamp;\n    const dt = timestamp - lastTime;\n    lastTime = timestamp;\n    frame++;\n\n    try {\n      // draw scene\n      drawBackground(dt);\n      if (!currentLevel) {\n        // show a simple central machine placeholder\n        ctx.save();\n        ctx.fillStyle = '#FDFDFD';\n        roundRect(ctx, GAME_WIDTH / 2 - 220, 80, 440, 220, 16, true, false);\n        ctx.fillStyle = '#2C3B46';\n        ctx.font = '700 26px \"Segoe UI\", Roboto';\n        ctx.textAlign = 'center';\n        ctx.fillText('Welcome to the Machine Lab', GAME_WIDTH / 2, 140);\n        ctx.font = '600 16px \"Segoe UI\", Roboto';\n        ctx.fillStyle = '#456';\n        ctx.fillText('Solve puzzles to power the machines. Press Enter to begin.', GAME_WIDTH / 2, 180);\n        ctx.restore();\n      } else {\n        drawMachineArea();\n        drawTiles();\n        drawSelector();\n      }\n      drawHUD();\n      drawOverlay();\n    } catch (e) {\n      // drawing error handling\n      console.error('Render error', e);\n      ctx.save();\n      ctx.fillStyle = '#FBE9E7';\n      ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);\n      ctx.fillStyle = '#C62828';\n      ctx.font = '700 16px \"Segoe UI\", Roboto';\n      ctx.fillText('Rendering error. Please reload the page.', 20, 60);\n      ctx.restore();\n      running = false;\n    }\n\n    if (running) requestAnimationFrame(render);\n  }\n\n  // Start initial overlay\n  showOverlay = true;\n  gameMessage = 'Press Enter to Start!';\n\n  // Begin loop\n  requestAnimationFrame(render);\n\n  // Accessibility: focus canvas for keyboard interaction\n  canvas.tabIndex = 0;\n  canvas.style.cursor = 'pointer';\n  canvas.addEventListener('focus', () => {\n    announce('Canvas focused. Use arrow keys to play.');\n  });\n\n  // Focus on container so keys work immediately\n  setTimeout(() => {\n    try {\n      canvas.focus();\n    } catch (e) {}\n  }, 500);\n\n  // Safe defaults\n  resetGame();\n\n  // Expose some controls for testing (non-global)\n  // Error handling summary visible in console if audio not available\n  if (!audioAvailable) {\n    announce('Audio unavailable. Game will play without sound.');\n  }\n\n  // End of IIFE\n})();\n---\n",
  "improve_response_tokens": 19502,
  "formatted_code": true,
  "formatting_response_tokens": 20033,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}