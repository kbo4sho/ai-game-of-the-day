# Game of the Day - 2025-09-08

## Metadata
- **Generated Date:** 2025-09-08
- **Generated Time:** 2025-09-08T00:28:24.900569
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-08.js
- **File Size:** 29832 bytes
- **Tokens Used:** 9895

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-08.js` - The playable game
- `2025-09-08.meta.json` - Machine-readable metadata
- `2025-09-08.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 19463

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 20500

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Machine Math — JavaScript game for ages 7-9
// Renders into the element with ID "game-of-the-day-stage"
// All visuals drawn on canvas. Sounds generated with Web Audio API.
// Accessible: keyboard controls, aria live text, audio on/off, instructions.
// Author: educational game designer (example)

(function () {
  'use strict';

  // ------- Configuration -------
  const WIDTH = 720;
  const HEIGHT = 480;
  const BG_COLOR = '#E9F5F5'; // calming
  const MACHINE_COLOR = '#D1E8E2';
  const TILE_COLOR = '#F7E9E1';
  const TILE_BORDER = '#C9B8A8';
  const TEXT_COLOR = '#2B3A30';
  const ACCENT = '#7FB069';
  const LEVELS = 5;
  const TILE_COUNT = 9;
  const MACHINE_COUNT = 3;

  // ------- DOM Setup -------
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Container element with id "game-of-the-day-stage" not found.');
    return;
  }
  // Clear container
  container.innerHTML = '';
  container.style.userSelect = 'none';
  container.style.position = 'relative';

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute('role', 'img');
  canvas.setAttribute('aria-label', 'Machine Math game. Solve simple addition and subtraction to fix the machines.');
  canvas.style.display = 'block';
  canvas.style.background = BG_COLOR;
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Create hidden live region for screen reader messages
  const liveRegion = document.createElement('div');
  liveRegion.setAttribute('aria-live', 'polite');
  liveRegion.style.position = 'absolute';
  liveRegion.style.left = '-10000px';
  liveRegion.style.width = '1px';
  liveRegion.style.height = '1px';
  liveRegion.style.overflow = 'hidden';
  container.appendChild(liveRegion);

  // ------- Audio Setup -------
  let audioAllowed = true;
  let audioContext = null;
  let masterGain = null;
  let backgroundOsc = null;
  let backgroundLFO = null;
  let audioEnabled = true;

  function safeCreateAudioContext() {
    if (!audioAllowed) return null;
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) {
        console.warn('Web Audio API not supported in this browser.');
        audioAllowed = false;
        return null;
      }
      const ctx = new AC();
      masterGain = ctx.createGain();
      masterGain.gain.value = 0.2;
      masterGain.connect(ctx.destination);
      // Background hum
      backgroundOsc = ctx.createOscillator();
      backgroundOsc.type = 'sine';
      backgroundOsc.frequency.value = 110; // gentle
      backgroundLFO = ctx.createOscillator();
      backgroundLFO.type = 'sine';
      backgroundLFO.frequency.value = 0.2;
      const lfoGain = ctx.createGain();
      lfoGain.gain.value = 10;
      backgroundLFO.connect(lfoGain);
      lfoGain.connect(backgroundOsc.frequency);
      backgroundOsc.connect(masterGain);
      backgroundOsc.start();
      backgroundLFO.start();
      return ctx;
    } catch (e) {
      console.error('Error creating AudioContext:', e);
      audioAllowed = false;
      return null;
    }
  }

  // Create audio context on first user interaction (to satisfy browser autoplay policies)
  function ensureAudioContext() {
    if (audioContext) return;
    audioContext = safeCreateAudioContext();
    if (!audioContext) audioEnabled = false;
  }

  function stopBackground() {
    if (!audioContext || !backgroundOsc || !backgroundLFO) return;
    try {
      backgroundOsc.stop();
      backgroundLFO.stop();
    } catch (e) {
      // ignore already stopped
    }
    backgroundOsc.disconnect();
    backgroundLFO.disconnect();
    backgroundOsc = null;
    backgroundLFO = null;
  }

  function toggleAudio() {
    if (!audioAllowed) {
      announce('Audio not available on this device.');
      audioEnabled = false;
      return;
    }
    if (!audioContext) ensureAudioContext();
    audioEnabled = !audioEnabled;
    if (audioEnabled) {
      if (masterGain) masterGain.gain.value = 0.2;
      announce('Audio on');
    } else {
      if (masterGain) masterGain.gain.value = 0.0;
      announce('Audio off');
    }
  }

  function playCorrectSound() {
    if (!audioEnabled || !audioContext) return;
    try {
      const o = audioContext.createOscillator();
      const g = audioContext.createGain();
      o.type = 'triangle';
      const now = audioContext.currentTime;
      o.frequency.setValueAtTime(440, now);
      o.frequency.exponentialRampToValueAtTime(880, now + 0.15);
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(0.12, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
      o.connect(g);
      g.connect(masterGain);
      o.start();
      o.stop(now + 0.32);
    } catch (e) {
      console.error('Error playing correct sound', e);
    }
  }

  function playIncorrectSound() {
    if (!audioEnabled || !audioContext) return;
    try {
      const o = audioContext.createOscillator();
      const g = audioContext.createGain();
      o.type = 'sawtooth';
      const now = audioContext.currentTime;
      o.frequency.setValueAtTime(220, now);
      o.frequency.exponentialRampToValueAtTime(110, now + 0.12);
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(0.12, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
      o.connect(g);
      g.connect(masterGain);
      o.start();
      o.stop(now + 0.26);
    } catch (e) {
      console.error('Error playing incorrect sound', e);
    }
  }

  // ------- Utility -------
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  function announce(text) {
    liveRegion.textContent = text;
    // also console for debugging
    console.log('ANNOUNCE:', text);
  }

  // ------- Game State -------
  let level = 1;
  let machines = [];
  let tiles = [];
  let selectedTiles = []; // indices of selected tiles
  let solvedCount = 0;
  let focusIndex = 0; // keyboard focus among interactive elements (tiles then machines then controls)
  let focusList = []; // computed each frame
  let confettiParticles = [];
  let lastTick = performance.now();
  let animations = []; // generic animations

  // ------- Layout -------
  const machineArea = { x: 40, y: 60, w: WIDTH - 80, h: 220 };
  const conveyorArea = { x: 20, y: 320, w: WIDTH - 40, h: 140 };

  // ------- Create Level Data -------
  function buildLevel(lvl) {
    // ensure audio context exists lazily
    // We'll build MACHINE_COUNT machine requirements (operation and target)
    machines = [];
    tiles = [];
    solvedCount = 0;
    selectedTiles = [];
    confettiParticles = [];
    animations = [];

    // pick operations: early levels only addition, later include subtraction
    const ops = [];
    for (let i = 0; i < MACHINE_COUNT; i++) {
      if (lvl <= 2) ops.push('+');
      else if (lvl === 3) ops.push(Math.random() < 0.5 ? '+' : '-');
      else ops.push(Math.random() < 0.6 ? '+' : '-');
    }

    // For each machine, pick a valid pair (a,b) consistent with op and reasonable ranges
    const pairs = [];
    for (let i = 0; i < MACHINE_COUNT; i++) {
      let a, b;
      const op = ops[i];
      if (op === '+') {
        const maxSum = lvl < 3 ? 10 : 20;
        const target = randInt(Math.max(2, lvl * 3 - 1), Math.min(maxSum, lvl * 5 + 5));
        // pick a and b between 1 and 9 (or up to 12 in later levels) such that a + b = target
        const minVal = 1;
        const maxVal = lvl < 4 ? 9 : 12;
        let attempts = 0;
        while (attempts < 200) {
          a = randInt(minVal, Math.min(maxVal, target - 1));
          b = target - a;
          if (b >= minVal && b <= maxVal) break;
          attempts++;
        }
        pairs.push({ op, a, b, target });
      } else {
        // subtraction: a - b = target, ensure a> b >=1, keep within ranges
        const maxA = lvl < 4 ? 15 : 19;
        const bMax = Math.min(9, maxA - 1);
        let attempts = 0;
        while (attempts < 200) {
          b = randInt(1, bMax);
          const aMin = b + 1;
          a = randInt(aMin, Math.min(maxA, b + (lvl * 4)));
          const target = a - b;
          if (target >= 1 && target <= (lvl < 3 ? 10 : 15)) {
            pairs.push({ op, a, b, target });
            break;
          }
          attempts++;
        }
      }
    }

    // Build the machines positions
    const gap = machineArea.w / MACHINE_COUNT;
    for (let i = 0; i < MACHINE_COUNT; i++) {
      const mX = machineArea.x + i * gap + gap / 8;
      const mY = machineArea.y;
      const mW = gap - gap / 4;
      const mH = machineArea.h;
      const pair = pairs[i];
      machines.push({
        x: mX,
        y: mY,
        w: mW,
        h: mH,
        op: pair.op,
        target: pair.target,
        required: [pair.a, pair.b],
        placed: [], // tile indices
        solved: false,
        rotate: 0 // for gear animation
      });
    }

    // Build tiles: ensure tiles include required numbers for each machine, plus random numbers
    const needed = [];
    for (const p of pairs) {
      needed.push(p.a);
      needed.push(p.b);
    }
    // Fill remaining tile slots
    const pool = needed.slice();
    while (pool.length < TILE_COUNT) {
      // numbers reasonable for level
      const maxVal = level < 4 ? 12 : 15;
      pool.push(randInt(1, Math.min(12, maxVal)));
    }
    shuffle(pool);
    // create tile objects positioned on conveyor
    const tileWidth = 80;
    const tileHeight = 64;
    const spacing = (conveyorArea.w - TILE_COUNT * tileWidth) / (TILE_COUNT + 1);
    for (let i = 0; i < TILE_COUNT; i++) {
      const x = conveyorArea.x + spacing + i * (tileWidth + spacing);
      const y = conveyorArea.y + (conveyorArea.h - tileHeight) / 2;
      tiles.push({
        id: i,
        value: pool[i],
        x,
        y,
        w: tileWidth,
        h: tileHeight,
        taken: false,
        grabbed: false,
        original: { x, y }
      });
    }

    announce(`Level ${lvl}. Fix all machines. Use math to make each machine's result equal to the number shown.`);
    focusIndex = 0;
  }

  // ------- Input Handling -------
  let mouse = { x: 0, y: 0, down: false };
  canvas.tabIndex = 0; // make focusable
  canvas.style.outline = 'none';

  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
    mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
  });

  canvas.addEventListener('mousedown', (e) => {
    ensureAudioContext(); // allow audio after user interaction
    mouse.down = true;
    // pick tile if clicked
    const t = hitTestTile(mouse.x, mouse.y);
    if (t && !t.taken) {
      t.grabbed = true;
      t.offsetX = mouse.x - t.x;
      t.offsetY = mouse.y - t.y;
      // select by pointer: add to selectedTiles but enforce up to 2 selections
      if (!selectedTiles.includes(t.id)) {
        if (selectedTiles.length < 2) selectedTiles.push(t.id);
        else {
          // rotate selections: drop first then add new
          selectedTiles.shift();
          selectedTiles.push(t.id);
        }
      }
    } else {
      // if click on a machine and have selected tiles, attempt place
      const mIndex = hitTestMachine(mouse.x, mouse.y);
      if (mIndex !== -1) {
        attemptPlaceOnMachine(mIndex);
      }
    }
  });

  canvas.addEventListener('mouseup', (e) => {
    mouse.down = false;
    // drop grabbed tiles
    for (const t of tiles) {
      if (t.grabbed) {
        // if dropped over a machine, attempt immediate place using this and any selected other tile
        t.grabbed = false;
        const mIndex = hitTestMachine(mouse.x, mouse.y);
        if (mIndex !== -1) {
          // ensure t.id in selectedTiles
          if (!selectedTiles.includes(t.id)) {
            if (selectedTiles.length < 2) selectedTiles.push(t.id);
            else {
              selectedTiles.shift();
              selectedTiles.push(t.id);
            }
          }
          attemptPlaceOnMachine(mIndex);
        } else {
          // return to original if not placed
          t.x = t.original.x;
          t.y = t.original.y;
          t.taken = false;
          // keep selection if clicked
        }
      }
    }
  });

  // Keyboard Controls
  window.addEventListener('keydown', (e) => {
    if (e.key === 'm' || e.key === 'M') {
      e.preventDefault();
      toggleAudio();
      return;
    }
    if (e.key === 'r' || e.key === 'R') {
      e.preventDefault();
      buildLevel(level);
      return;
    }
    // Focus cycling: Tab custom behavior
    if (e.key === 'Tab') {
      e.preventDefault();
      // compute focus list
      computeFocusList();
      focusIndex = (focusIndex + (e.shiftKey ? -1 : 1) + focusList.length) % focusList.length;
      announceFocus();
      return;
    }
    // Activation
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      activateFocused();
      return;
    }
    // Arrow navigation: move focus among tiles/machines
    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
      computeFocusList();
      const dir = e.key;
      if (focusList.length === 0) return;
      // Try to move focus near elements spatially
      const current = focusList[focusIndex];
      let bestIndex = focusIndex;
      let bestScore = Infinity;
      for (let i = 0; i < focusList.length; i++) {
        if (i === focusIndex) continue;
        const a = current.rect;
        const b = focusList[i].rect;
        // score based on direction and distance
        const dx = b.cx - a.cx;
        const dy = b.cy - a.cy;
        let score = Math.hypot(dx, dy);
        if (dir === 'ArrowLeft' && dx >= 0) score += 1000;
        if (dir === 'ArrowRight' && dx <= 0) score += 1000;
        if (dir === 'ArrowUp' && dy >= 0) score += 1000;
        if (dir === 'ArrowDown' && dy <= 0) score += 1000;
        if (score < bestScore) {
          bestScore = score;
          bestIndex = i;
        }
      }
      focusIndex = bestIndex;
      announceFocus();
    }
  });

  function computeFocusList() {
    focusList = [];
    // Add tiles not taken, then machines, then audio control
    for (const t of tiles) {
      focusList.push({
        kind: 'tile',
        id: t.id,
        rect: { cx: t.x + t.w / 2, cy: t.y + t.h / 2 }
      });
    }
    machines.forEach((m, idx) => {
      focusList.push({
        kind: 'machine',
        id: idx,
        rect: { cx: m.x + m.w / 2, cy: m.y + m.h / 2 }
      });
    });
    focusList.push({
      kind: 'audio',
      id: 0,
      rect: { cx: WIDTH - 60, cy: 28 }
    });
  }

  function announceFocus() {
    if (!focusList.length) return;
    const f = focusList[focusIndex];
    if (f.kind === 'tile') {
      const t = tiles.find((x) => x.id === f.id);
      announce(`Tile ${t.value}. Press Enter to select.`);
    } else if (f.kind === 'machine') {
      const m = machines[f.id];
      announce(`Machine ${f.id + 1}. Operation ${m.op} target ${m.target}. Press Enter to place selected tiles.`);
    } else if (f.kind === 'audio') {
      announce(`Audio control. Press Enter to toggle audio.`);
    }
  }

  function activateFocused() {
    if (!focusList.length) computeFocusList();
    const f = focusList[focusIndex];
    if (!f) return;
    if (f.kind === 'tile') {
      // toggle selection
      const tileId = f.id;
      const idx = selectedTiles.indexOf(tileId);
      if (idx === -1) {
        if (selectedTiles.length < 2) selectedTiles.push(tileId);
        else {
          selectedTiles.shift();
          selectedTiles.push(tileId);
        }
      } else {
        selectedTiles.splice(idx, 1);
      }
      const t = tiles.find((x) => x.id === tileId);
      announce(`Tile ${t.value} ${selectedTiles.includes(tileId) ? 'selected' : 'deselected'}.`);
    } else if (f.kind === 'machine') {
      attemptPlaceOnMachine(f.id);
    } else if (f.kind === 'audio') {
      toggleAudio();
    }
  }

  // ------- Hit Testing -------
  function hitTestTile(x, y) {
    for (let i = tiles.length - 1; i >= 0; i--) {
      const t = tiles[i];
      if (
        x >= t.x &&
        x <= t.x + t.w &&
        y >= t.y &&
        y <= t.y + t.h
      ) {
        return t;
      }
    }
    return null;
  }

  function hitTestMachine(x, y) {
    for (let i = 0; i < machines.length; i++) {
      const m = machines[i];
      if (
        x >= m.x &&
        x <= m.x + m.w &&
        y >= m.y &&
        y <= m.y + m.h
      ) return i;
    }
    return -1;
  }

  // ------- Game Logic -------
  function attemptPlaceOnMachine(mIndex) {
    const m = machines[mIndex];
    if (m.solved) {
      announce('This machine is already fixed.');
      return;
    }
    if (selectedTiles.length < 2) {
      announce('Select two tiles to place in the machine.');
      playIncorrectSound();
      return;
    }
    const t1 = tiles.find((t) => t.id === selectedTiles[0]);
    const t2 = tiles.find((t) => t.id === selectedTiles[1]);
    if (!t1 || !t2) {
      announce('Selected tiles not available.');
      selectedTiles = [];
      playIncorrectSound();
      return;
    }
    const a = t1.value;
    const b = t2.value;
    let result = 0;
    if (m.op === '+') result = a + b;
    else result = a - b;
    if (result === m.target) {
      // success
      m.solved = true;
      m.placed = [t1.id, t2.id];
      t1.taken = true;
      t2.taken = true;
      selectedTiles = [];
      solvedCount++;
      announce('Great! Machine fixed.');
      playCorrectSound();
      spawnConfetti(m.x + m.w / 2, m.y + m.h / 2);
      animations.push({ type: 'gear-spin', machineIndex: mIndex, time: performance.now(), duration: 1200 });
      // if solved all, next level or win
      if (solvedCount >= machines.length) {
        // Win animation and advance after short pause
        announce(`All machines fixed! Level ${level} complete.`);
        setTimeout(() => {
          level++;
          if (level > LEVELS) {
            announce('You completed all levels. Well done!');
            // reset to level 1 optionally
            setTimeout(() => {
              level = 1;
              buildLevel(level);
            }, 3000);
          } else {
            buildLevel(level);
          }
        }, 1000);
      }
    } else {
      // incorrect - return tiles to originals and allow retry
      announce('That did not fix the machine. Try different tiles.');
      playIncorrectSound();
      // small shake animation on machine
      animations.push({ type: 'shake', machineIndex: mIndex, time: performance.now(), duration: 600 });
      // return tiles visually to conveyors
      t1.x = t1.original.x;
      t1.y = t1.original.y;
      t2.x = t2.original.x;
      t2.y = t2.original.y;
      selectedTiles = [];
    }
  }

  // ------- Visual Effects -------
  function spawnConfetti(cx, cy) {
    for (let i = 0; i < 16; i++) {
      confettiParticles.push({
        x: cx,
        y: cy,
        vx: (Math.random() - 0.5) * 3,
        vy: -Math.random() * 3 - 1,
        r: randInt(3, 7),
        color: ['#FFB6B9', '#FAE3D9', '#BBDED6', '#8AC6D1', '#FDE2E4'][Math.floor(Math.random() * 5)],
        life: 0,
        ttl: randInt(800, 1400)
      });
    }
  }

  // ------- Drawing -------
  function draw() {
    // Clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    // Background with gentle pattern
    ctx.fillStyle = BG_COLOR;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Title and header
    ctx.fillStyle = TEXT_COLOR;
    ctx.font = '20px "Segoe UI", Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Machine Math', 18, 28);
    ctx.font = '12px "Segoe UI", Arial';
    ctx.fillStyle = '#53725B';
    ctx.fillText(`Level ${level} — Fix ${machines.length} machines`, 18, 48);
    ctx.fillStyle = ACCENT;
    ctx.fillRect(WIDTH - 120, 12, 96, 28);
    ctx.fillStyle = '#fff';
    ctx.font = '12px "Segoe UI", Arial';
    ctx.textAlign = 'center';
    ctx.fillText(audioEnabled ? 'Audio: On (M)' : 'Audio: Off (M)', WIDTH - 72, 32);
    ctx.textAlign = 'left';

    // Instructions area
    ctx.fillStyle = '#DDEDEA';
    roundRect(ctx, 18, 52, WIDTH - 36, 36, 8);
    ctx.fillStyle = '#2F4F4F';
    ctx.font = '13px "Segoe UI", Arial';
    ctx.fillText('Select two tiles (click or use keyboard) and place them into a machine. Match the machine\'s target number to fix it. R to restart level.', 26, 77);

    // Draw machines
    machines.forEach((m, idx) => {
      // compute shake or spin modifications from animations
      let dx = 0;
      let dy = 0;
      let spin = 0;
      for (const a of animations) {
        if (a.machineIndex !== idx) continue;
        const t = performance.now() - a.time;
        if (t > a.duration) continue;
        if (a.type === 'shake') {
          const intensity = Math.sin((t / a.duration) * Math.PI * 6) * 6 * (1 - t / a.duration);
          dx += intensity;
        } else if (a.type === 'gear-spin') {
          spin += (t / a.duration) * Math.PI * 6;
        }
      }

      // Machine casing
      ctx.save();
      ctx.translate(m.x + dx, m.y + dy);
      roundRect(ctx, 0, 0, m.w, m.h, 16);
      ctx.fillStyle = MACHINE_COLOR;
      ctx.fill();
      ctx.strokeStyle = '#C3D7D3';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Wacky elements: a pair of googly eyes on top-left
      ctx.fillStyle = '#FFF';
      ctx.beginPath();
      ctx.ellipse(26, 30, 12, 16, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(54, 30, 12, 16, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#333';
      ctx.beginPath();
      ctx.arc(32 + Math.sin((Date.now() / 600) + idx) * 2, 32, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(60 + Math.sin((Date.now() / 700) + idx) * 2, 32, 5, 0, Math.PI * 2);
      ctx.fill();

      // Machine display for target and operation
      ctx.fillStyle = '#FFF';
      roundRect(ctx, m.w - 120, 18, 92, 42, 8);
      ctx.fillStyle = '#F6F9F8';
      ctx.fill();
      ctx.strokeStyle = '#BFD0CB';
      ctx.stroke();
      ctx.fillStyle = '#2E4D44';
      ctx.font = 'bold 22px "Segoe UI", Arial';
      ctx.textAlign = 'center';
      ctx.fillText(`${m.op} ${m.target}`, m.w - 120 + 46, 48);
      ctx.textAlign = 'left';

      // Gears area showing required slots
      const slotX = 40;
      const slotY = 90;
      // draw two gear circles
      for (let i = 0; i < 2; i++) {
        const gx = slotX + i * 120;
        const gy = slotY;
        ctx.save();
        ctx.translate(gx + 24, gy + 24);
        ctx.rotate((m.rotate + spin / 8) + (idx * 0.2));
        drawGear(ctx, 24, i === 0 ? '#F7E9E1' : '#EDE7F6', i === 0 ? '#C9B8A8' : '#CBB4E6');
        ctx.restore();
        // slot background for tile number (if placed)
        ctx.fillStyle = '#FFF';
        roundRect(ctx, gx + 10, gy + 50, 88, 46, 9);
        ctx.fillStyle = '#FAFAFA';
        ctx.fill();
        ctx.strokeStyle = '#D8E7E3';
        ctx.stroke();
        // if tile placed, show its value
        const placedId = m.placed[i];
        if (placedId !== undefined) {
          const tile = tiles.find((t) => t.id === placedId);
          ctx.fillStyle = TEXT_COLOR;
          ctx.font = '20px "Segoe UI", Arial';
          ctx.textAlign = 'center';
          ctx.fillText(tile.value, gx + 54, gy + 82);
          ctx.textAlign = 'left';
        } else {
          ctx.fillStyle = '#AABBB6';
          ctx.font = '14px "Segoe UI", Arial';
          ctx.fillText('place tile', gx + 28, gy + 82);
        }
      }

      // If solved, show green glow and small "fixed" label
      if (m.solved) {
        ctx.fillStyle = 'rgba(127,176,105,0.18)';
        roundRect(ctx, 6, 6, m.w - 12, m.h - 12, 14);
        ctx.fill();
        ctx.fillStyle = '#2F7B48';
        ctx.font = 'bold 18px "Segoe UI", Arial';
        ctx.fillText('FIXED', m.w - 80, m.h - 18);
      }

      ctx.restore();

      // update rotate
      m.rotate += 0.01 + (m.solved ? 0.15 : 0.01);
    });

    // Conveyor and tiles
    roundRect(ctx, conveyorArea.x, conveyorArea.y, conveyorArea.w, conveyorArea.h, 14);
    ctx.fillStyle = '#EFF8F6';
    ctx.fill();
    ctx.strokeStyle = '#D1E6E3';
    ctx.stroke();

    // Draw a playful robot arm at left
    ctx.save();
    ctx.translate(20, conveyorArea.y - 30);
    drawRobotArm(ctx, 0, 0);
    ctx.restore();

    // Tiles drawing (dragged ones drawn last)
    const drawn = [];
    for (const t of tiles) {
      if (t.grabbed) continue;
      drawTile(t);
      drawn.push(t.id);
    }
    // grabbed tiles follow mouse
    for (const t of tiles) {
      if (!t.grabbed) continue;
      t.x = mouse.x - t.offsetX;
      t.y = mouse.y - t.offsetY;
      drawTile(t, true);
    }

    // Highlight selections
    for (const tid of selectedTiles) {
      const t = tiles.find((x) => x.id === tid);
      if (!t) continue;
      ctx.save();
      ctx.strokeStyle = '#6FAF86';
      ctx.lineWidth = 3;
      roundRect(ctx, t.x - 4, t.y - 4, t.w + 8, t.h + 8, 10);
      ctx.stroke();
      ctx.restore();
    }

    // Confetti
    confettiParticles = confettiParticles.filter((p) => p.life < p.ttl);
    for (const p of confettiParticles) {
      p.life += (performance.now() - lastTick);
      p.vy += 0.05;
      p.x += p.vx;
      p.y += p.vy;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
    }

    // small footer controls text for accessibility and keyboard
    ctx.fillStyle = '#3A4C44';
    ctx.font = '12px "Segoe UI", Arial';
    ctx.fillText('Keyboard: Tab to move, Enter to select/place, M to toggle audio, R to restart.', 18, HEIGHT - 14);

    lastTick = performance.now();
  }

  function drawTile(t, floating = false) {
    // rect with rounded corners
    ctx.save();
    // subtle shadow if floating
    if (floating) {
      ctx.shadowColor = 'rgba(0,0,0,0.15)';
      ctx.shadowBlur = 8;
      ctx.shadowOffsetY = 4;
    } else {
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
    }
    ctx.fillStyle = TILE_COLOR;
    roundRect(ctx, t.x, t.y, t.w, t.h, 10);
    ctx.fill();
    ctx.strokeStyle = TILE_BORDER;
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillStyle = TEXT_COLOR;
    ctx.font = '22px "Segoe UI", Arial';
    ctx.textAlign = 'center';
    ctx.fillText(String(t.value), t.x + t.w / 2, t.y + t.h / 2 + 8);
    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  function drawGear(ctx, radius, fill, stroke) {
    // simple gear-like circle with teeth
    ctx.beginPath();
    for (let i = 0; i < 12; i++) {
      const a = (i / 12) * Math.PI * 2;
      const r = i % 2 === 0 ? radius : radius * 0.78;
      const x = Math.cos(a) * r;
      const y = Math.sin(a) * r;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fillStyle = fill;
    ctx.fill();
    ctx.strokeStyle = stroke;
    ctx.lineWidth = 2;
    ctx.stroke();
    // center hole
    ctx.beginPath();
    ctx.arc(0, 0, radius * 0.35, 0, Math.PI * 2);
    ctx.fillStyle = '#FFFFFF';
    ctx.fill();
    ctx.strokeStyle = '#C9D9CF';
    ctx.stroke();
  }

  function drawRobotArm(ctx, x, y) {
    ctx.save();
    ctx.translate(x, y);
    // base
    ctx.fillStyle = '#E6EEF0';
    roundRect(ctx, 0, 24, 58, 40, 8);
    ctx.fill();
    ctx.strokeStyle = '#C9D6D6';
    ctx.stroke();
    // arm segments
    ctx.fillStyle = '#C9E3DE';
    roundRect(ctx, 20, -10, 18, 50, 6);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(38, 10);
    ctx.lineTo(60, -8);
    ctx.lineTo(72, 4);
    ctx.lineTo(50, 22);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = '#8DB6AB';
    ctx.beginPath();
    ctx.arc(74, 6, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  // ------- Animation Loop -------
  function gameLoop() {
    // update any animations
    const now = performance.now();
    // remove expired animations
    animations = animations.filter((a) => (now - a.time) < a.duration + 200);
    draw();
    requestAnimationFrame(gameLoop);
  }

  // ------- Initialization -------
  function init() {
    try {
      // attempt to create audio context now (may be blocked until user gesture)
      audioContext = null; // delay until gesture
      if (audioEnabled) {
        // try but will be created on first interaction
      }
      buildLevel(level);
      computeFocusList();
      gameLoop();
    } catch (e) {
      console.error('Initialization error', e);
      announce('An error occurred while starting the game.');
    }
  }

  // Start on user interaction to enable audio according to browsers
  function resumeOnUserGesture() {
    if (!audioContext && audioAllowed) {
      try {
        ensureAudioContext();
        // lower gain until user explicitly toggles
        if (!audioEnabled && masterGain) masterGain.gain.value = 0.0;
      } catch (e) {
        console.warn('Audio resume failed', e);
        audioEnabled = false;
      }
    }
    // remove this listener
    window.removeEventListener('pointerdown', resumeOnUserGesture);
    window.removeEventListener('keydown', resumeOnUserGesture);
  }
  window.addEventListener('pointerdown', resumeOnUserGesture);
  window.addEventListener('keydown', resumeOnUserGesture);

  // Start game
  init();
})();
---

