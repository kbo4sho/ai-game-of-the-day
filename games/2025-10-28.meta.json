{
  "generated_date": "2025-10-28",
  "generated_timestamp": "2025-10-28T00:26:57.136389",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8613,
  "game_filename": "2025-10-28.js",
  "game_size_bytes": 24132,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Drone Math Adventure\n  // Renders inside element with id \"game-of-the-day-stage\"\n  // All graphics drawn on canvas, sounds via Web Audio API\n  // Accessible text placed inside the same container for screen readers\n\n  // Config\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const GOAL_CORRECT = 10;\n  const MAX_WRONG = 3;\n  const PADDING = 12; // min spacing / padding for UI elements\n\n  // Get container\n  const container = document.getElementById(\"game-of-the-day-stage\");\n  if (!container) {\n    console.error(\"Container with id 'game-of-the-day-stage' not found.\");\n    return;\n  }\n  // Clear and set up container styles (keeps render inside)\n  container.innerHTML = \"\";\n  container.style.position = \"relative\";\n  container.style.width = WIDTH + \"px\";\n  container.style.height = HEIGHT + \"px\";\n  container.tabIndex = 0; // allow keyboard focus\n\n  // Create canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.width = WIDTH + \"px\";\n  canvas.style.height = HEIGHT + \"px\";\n  canvas.style.outline = \"none\";\n  container.appendChild(canvas);\n  const ctx = canvas.getContext(\"2d\");\n\n  // Accessibility: ARIA live region for screen readers and instructions\n  const live = document.createElement(\"div\");\n  live.setAttribute(\"role\", \"status\");\n  live.setAttribute(\"aria-live\", \"polite\");\n  live.style.position = \"absolute\";\n  live.style.left = \"8px\";\n  live.style.top = (HEIGHT + 5) + \"px\"; // placed inside container? We set just below \u2014 but must stay inside. Instead hide visually but keep for screen readers.\n  live.style.height = \"1px\";\n  live.style.width = \"1px\";\n  live.style.overflow = \"hidden\";\n  live.style.clip = \"rect(1px, 1px, 1px, 1px)\";\n  live.style.whiteSpace = \"nowrap\";\n  container.appendChild(live);\n\n  // Game state\n  let score = 0;\n  let wrong = 0;\n  let question = null; // { text, correct, choices: [..] }\n  let selectedIndex = 0;\n  let answeredCount = 0;\n  let stage = \"playing\"; // playing, won, lost\n  let hoverIndex = -1;\n  let audioEnabled = true;\n  let audioAvailable = true;\n  let lastActionMessage = \"\";\n\n  // Drone position\n  const drone = {\n    x: WIDTH / 2,\n    y: HEIGHT - 120,\n    targetX: WIDTH / 2,\n    targetY: HEIGHT - 120,\n    speed: 6\n  };\n\n  // Answer bubble positions (4 around center)\n  const answerPositions = [\n    { x: WIDTH / 2 - 180, y: HEIGHT / 2 - 10 },\n    { x: WIDTH / 2 + 180, y: HEIGHT / 2 - 10 },\n    { x: WIDTH / 2 - 90, y: HEIGHT / 2 + 120 },\n    { x: WIDTH / 2 + 90, y: HEIGHT / 2 + 120 }\n  ];\n\n  // Colors (calming pastels)\n  const palette = {\n    bg: \"#f6fbff\",\n    panel: \"#ffffff\",\n    soft: \"#cfeaf0\",\n    accent: \"#8ecae6\",\n    correct: \"#9be7a8\",\n    wrong: \"#ffb4a2\",\n    text: \"#073b4c\",\n    drone: \"#ffd166\",\n    prop: \"#a7c5bd\",\n    star: \"#ffe066\"\n  };\n\n  // Fonts\n  const fonts = {\n    important: \"20px sans-serif\",\n    body: \"16px sans-serif\",\n    small: \"14px sans-serif\",\n    title: \"24px sans-serif\"\n  };\n\n  // Web Audio setup with error handling\n  let audioCtx;\n  let masterGain;\n  let ambientOsc;\n  try {\n    const AudioCtx = window.AudioContext || window.webkitAudioContext;\n    if (!AudioCtx) throw new Error(\"Web Audio API not supported\");\n    audioCtx = new AudioCtx();\n    masterGain = audioCtx.createGain();\n    masterGain.gain.value = 0.7;\n    masterGain.connect(audioCtx.destination);\n    // gentle ambient hum (very low)\n    ambientOsc = audioCtx.createOscillator();\n    const ambientGain = audioCtx.createGain();\n    ambientOsc.type = \"sine\";\n    ambientOsc.frequency.value = 120; // low hum\n    ambientGain.gain.value = 0.0035; // very subtle\n    ambientOsc.connect(ambientGain);\n    ambientGain.connect(masterGain);\n    ambientOsc.start(0);\n  } catch (e) {\n    console.warn(\"Audio unavailable:\", e);\n    audioAvailable = false;\n    audioEnabled = false;\n  }\n\n  function tryResumeAudio() {\n    if (!audioAvailable || !audioCtx) return;\n    if (audioCtx.state === \"suspended\") {\n      audioCtx.resume().catch(() => {});\n    }\n  }\n\n  // Sound helpers using oscillators and envelopes\n  function playBeep(freq = 880, type = \"sine\", duration = 0.18, volume = 0.18) {\n    if (!audioAvailable || !audioEnabled) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = type;\n      o.frequency.value = freq;\n      o.connect(g);\n      g.connect(masterGain);\n      const now = audioCtx.currentTime;\n      g.gain.setValueAtTime(0, now);\n      g.gain.exponentialRampToValueAtTime(volume, now + 0.01);\n      o.start(now);\n      g.gain.exponentialRampToValueAtTime(0.001, now + duration);\n      o.stop(now + duration + 0.02);\n    } catch (e) {\n      console.warn(\"playBeep error\", e);\n    }\n  }\n\n  function playCorrectSound() {\n    // Pleasant triad quick melody\n    if (!audioAvailable || !audioEnabled) return;\n    try {\n      const now = audioCtx.currentTime;\n      playToneAt(660, 0.09, now);\n      playToneAt(880, 0.09, now + 0.09);\n      playToneAt(990, 0.12, now + 0.18);\n    } catch (e) {\n      console.warn(\"correct sound error\", e);\n    }\n  }\n  function playWrongSound() {\n    if (!audioAvailable || !audioEnabled) return;\n    try {\n      const now = audioCtx.currentTime;\n      playToneAt(220, 0.2, now, \"sawtooth\", 0.12);\n    } catch (e) {\n      console.warn(\"wrong sound error\", e);\n    }\n  }\n  function playMoveSound() {\n    if (!audioAvailable || !audioEnabled) return;\n    playBeep(450, \"triangle\", 0.08, 0.06);\n  }\n  function playToneAt(freq, dur = 0.1, when = 0, type = \"sine\", vol = 0.12) {\n    const o = audioCtx.createOscillator();\n    const g = audioCtx.createGain();\n    o.type = type;\n    o.frequency.value = freq;\n    o.connect(g);\n    g.connect(masterGain);\n    g.gain.setValueAtTime(0.001, when);\n    g.gain.exponentialRampToValueAtTime(vol, when + 0.01);\n    g.gain.exponentialRampToValueAtTime(0.001, when + dur);\n    o.start(when);\n    o.stop(when + dur + 0.02);\n  }\n\n  // Game logic: generate question suitable for ages 7-9\n  function generateQuestion() {\n    // Types: addition/subtraction within 0-20, simple multiplication by 2-5\n    const type = Math.random();\n    let a, b, text, correct;\n    if (type < 0.45) {\n      // addition\n      a = randInt(1, 20);\n      b = randInt(1, Math.min(20, 20 - a));\n      correct = a + b;\n      text = `${a} + ${b} = ?`;\n    } else if (type < 0.85) {\n      // subtraction\n      a = randInt(2, 20);\n      b = randInt(1, a - 1);\n      correct = a - b;\n      text = `${a} - ${b} = ?`;\n    } else {\n      // multiplication small\n      a = randInt(2, 7);\n      b = randInt(2, 5);\n      correct = a * b;\n      text = `${a} \u00d7 ${b} = ?`;\n    }\n\n    // Generate 3 distractors\n    const choices = new Set([correct]);\n    while (choices.size < 4) {\n      let delta = randInt(-5, 5);\n      if (delta === 0) delta = 1;\n      let val = correct + delta;\n      if (val < 0) val = correct + Math.abs(delta) + 1;\n      choices.add(val);\n    }\n    const arr = shuffle(Array.from(choices));\n    return { text, correct, choices: arr };\n  }\n\n  // Utility functions\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n  function shuffle(a) {\n    for (let i = a.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [a[i], a[j]] = [a[j], a[i]];\n    }\n    return a;\n  }\n\n  // Initialize first question\n  function nextQuestion() {\n    question = generateQuestion();\n    selectedIndex = 0;\n    hoverIndex = -1;\n    // announce for accessibility\n    announce(`New question: ${question.text}. Use arrow keys or click an answer. Press Enter to choose.`);\n  }\n\n  function announce(text) {\n    lastActionMessage = text;\n    tryResumeAudio();\n    live.textContent = text;\n  }\n\n  // Drawing helpers that ensure no overlap using measureText for backgrounds\n  function drawTextWithPanel(text, x, y, font, textColor, bgColor, padding = 10, align = \"left\") {\n    ctx.font = font;\n    const metrics = ctx.measureText(text);\n    const w = Math.ceil(metrics.width);\n    const h = parseInt(font, 10) || 16;\n    let rectX = x;\n    if (align === \"center\") rectX = x - (w / 2) - padding;\n    if (align === \"right\") rectX = x - (w + padding * 2);\n    const rectY = y - h - padding / 2;\n    ctx.fillStyle = bgColor;\n    roundRect(ctx, rectX, rectY, w + padding * 2, h + padding, 6).fill();\n    ctx.fillStyle = textColor;\n    ctx.textAlign = align;\n    ctx.textBaseline = \"top\";\n    ctx.fillText(text, align === \"center\" ? x : (rectX + padding), rectY + (padding / 4));\n    // return dims to allow spacing checks\n    return { x: rectX, y: rectY, w: w + padding * 2, h: h + padding };\n  }\n\n  // Round rect helper returning ctx for chaining\n  function roundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    return ctx;\n  }\n\n  // Draw calming background and wacky clouds/whimsical props\n  function drawBackground() {\n    // soft gradient sky\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, \"#f0fbff\");\n    g.addColorStop(1, \"#f6fbff\");\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // floating bubbly shapes\n    for (let i = 0; i < 6; i++) {\n      const cx = (i * 123 + 40) % WIDTH;\n      const cy = 40 + (i % 3) * 30;\n      ctx.fillStyle = `rgba(140,202,230,0.08)`;\n      ctx.beginPath();\n      ctx.ellipse(cx, cy, 60, 28, Math.sin((i + Date.now() / 2000)), 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // distant wacky mountains\n    ctx.fillStyle = palette.soft;\n    ctx.beginPath();\n    ctx.moveTo(0, HEIGHT - 160);\n    ctx.quadraticCurveTo(100, HEIGHT - 260, 180, HEIGHT - 160);\n    ctx.quadraticCurveTo(280, HEIGHT - 80, 360, HEIGHT - 160);\n    ctx.quadraticCurveTo(460, HEIGHT - 260, 540, HEIGHT - 160);\n    ctx.quadraticCurveTo(620, HEIGHT - 80, WIDTH, HEIGHT - 160);\n    ctx.lineTo(WIDTH, HEIGHT);\n    ctx.lineTo(0, HEIGHT);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  // Draw drone\n  function drawDrone(x, y) {\n    // shadow\n    ctx.fillStyle = \"rgba(0,0,0,0.08)\";\n    ctx.beginPath();\n    ctx.ellipse(x, y + 24, 44, 10, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // body\n    ctx.fillStyle = palette.drone;\n    roundRect(ctx, x - 40, y - 18, 80, 36, 12).fill();\n    // cockpit window\n    ctx.fillStyle = palette.panel;\n    roundRect(ctx, x - 20, y - 14, 40, 28, 8).fill();\n    // antenna\n    ctx.strokeStyle = palette.text;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(x + 18, y - 8);\n    ctx.lineTo(x + 30, y - 28);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.arc(x + 30, y - 28, 3, 0, Math.PI * 2);\n    ctx.fillStyle = palette.accent;\n    ctx.fill();\n\n    // propellers (wacky rounded discs)\n    const props = [\n      { dx: -42, dy: -28 },\n      { dx: 42, dy: -28 },\n      { dx: -42, dy: 28 },\n      { dx: 42, dy: 28 }\n    ];\n    props.forEach((p, i) => {\n      const angle = ((Date.now() / 80) + i * 90) % 360;\n      ctx.save();\n      ctx.translate(x + p.dx, y + p.dy);\n      ctx.rotate((angle * Math.PI) / 180);\n      ctx.fillStyle = palette.prop;\n      ctx.beginPath();\n      ctx.ellipse(0, 0, 26, 8, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n    });\n\n    // small wacky sticker\n    ctx.font = \"12px sans-serif\";\n    ctx.fillStyle = palette.text;\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"DR\u00d8N\", x, y + 4);\n  }\n\n  // Draw answer bubbles\n  function drawAnswerBubble(idx, text, isSelected, isHover) {\n    const pos = answerPositions[idx];\n    // measure text\n    ctx.font = fonts.body;\n    const m = ctx.measureText(String(text));\n    const w = Math.max(60, m.width + 28);\n    const h = 44;\n    const radius = Math.max(36, Math.ceil(Math.max(w, h) / 2));\n    // bubble\n    ctx.beginPath();\n    ctx.fillStyle = isSelected ? \"#fff7e6\" : \"#ffffff\";\n    ctx.strokeStyle = isHover ? palette.accent : \"#d6eaf0\";\n    ctx.lineWidth = isSelected ? 4 : 2;\n    roundRect(ctx, pos.x - radius, pos.y - radius, radius * 2, radius * 2, 18).fill();\n    roundRect(ctx, pos.x - radius, pos.y - radius, radius * 2, radius * 2, 18).stroke();\n    // wacky icon: little crate/star\n    ctx.fillStyle = palette.star;\n    ctx.beginPath();\n    ctx.moveTo(pos.x - radius + 14, pos.y - 6);\n    ctx.lineTo(pos.x - radius + 20, pos.y - 14);\n    ctx.lineTo(pos.x - radius + 26, pos.y - 6);\n    ctx.lineTo(pos.x - radius + 18, pos.y - 2);\n    ctx.closePath();\n    ctx.fill();\n    // text\n    ctx.fillStyle = palette.text;\n    ctx.font = fonts.important;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(String(text), pos.x, pos.y);\n    return { x: pos.x - radius, y: pos.y - radius, w: radius * 2, h: radius * 2 };\n  }\n\n  // UI Draw ensuring non-overlap\n  function drawUI() {\n    // Score top-left\n    const scoreText = `Correct: ${score}/${GOAL_CORRECT}`;\n    const scorePanel = drawTextWithPanel(scoreText, PADDING + 8, PADDING + 26, fonts.title, palette.text, palette.panel, 12, \"left\");\n\n    // Lives top-right\n    const livesText = `Lives: ${Math.max(0, MAX_WRONG - wrong)}`;\n    ctx.textAlign = \"right\";\n    const livesPanel = drawTextWithPanel(livesText, WIDTH - (PADDING + 8), PADDING + 26, fonts.title, palette.text, palette.panel, 12, \"right\");\n\n    // Audio icon small panel next to lives (right side)\n    const audioWidth = 130;\n    const audioX = WIDTH - (livesPanel.w + PADDING * 2 + 10) - audioWidth;\n    ctx.fillStyle = palette.panel;\n    roundRect(ctx, audioX, 8, audioWidth, 36, 8).fill();\n    ctx.fillStyle = palette.text;\n    ctx.font = fonts.small;\n    ctx.textAlign = \"left\";\n    ctx.textBaseline = \"middle\";\n    const audioLabel = audioAvailable ? (audioEnabled ? \"Audio: On (M)\" : \"Audio: Off (M)\") : \"Audio: Unavailable\";\n    ctx.fillText(audioLabel, audioX + 12, 26);\n\n    // Question top-center (important)\n    ctx.font = fonts.title;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"top\";\n    // ensure not overlapping with top UI elements: measure width\n    const qMetrics = ctx.measureText(question ? question.text : \"Loading...\");\n    const qW = qMetrics.width;\n    const qX = WIDTH / 2;\n    const qY = 70;\n    // draw panel behind\n    roundRect(ctx, qX - qW / 2 - 18, qY - 8, qW + 36, 44, 10).fillStyle = palette.panel;\n    ctx.fillStyle = palette.panel;\n    roundRect(ctx, qX - qW / 2 - 18, qY - 8, qW + 36, 44, 10).fill();\n    ctx.fillStyle = palette.text;\n    ctx.fillText(question ? question.text : \"Loading...\", qX, qY);\n\n    // Instructions bottom-center\n    const instr = \"Use Arrow Keys to move, Enter to pick, Click a bubble, M toggles audio, R restarts\";\n    ctx.font = fonts.small;\n    const im = ctx.measureText(instr);\n    const ipW = im.width;\n    const ipX = WIDTH / 2 - ipW / 2 - 12;\n    const ipY = HEIGHT - 56;\n    ctx.fillStyle = palette.panel;\n    roundRect(ctx, ipX, ipY, ipW + 24, 38, 8).fill();\n    ctx.fillStyle = palette.text;\n    ctx.textAlign = \"center\";\n    ctx.fillText(instr, WIDTH / 2, ipY + 9);\n\n    // Last action message (accessibility) above instructions\n    ctx.font = fonts.small;\n    const am = ctx.measureText(lastActionMessage);\n    if (lastActionMessage) {\n      const amW = am.width;\n      const amX = WIDTH / 2 - amW / 2 - 12;\n      const amY = HEIGHT - 100;\n      ctx.fillStyle = palette.panel;\n      roundRect(ctx, amX, amY, amW + 24, 32, 8).fill();\n      ctx.fillStyle = palette.text;\n      ctx.fillText(lastActionMessage, WIDTH / 2, amY + 6);\n    }\n  }\n\n  // Main render\n  function render() {\n    // Clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    drawBackground();\n\n    // Draw question area and bubbles\n    // Panel behind answers\n    ctx.fillStyle = \"rgba(255,255,255,0.85)\";\n    roundRect(ctx, WIDTH / 2 - 320, HEIGHT / 2 - 140, 640, 260, 14).fill();\n\n    // Draw choices\n    let bubbleRects = [];\n    if (question) {\n      for (let i = 0; i < 4; i++) {\n        const isSelected = i === selectedIndex;\n        const isHover = i === hoverIndex;\n        bubbleRects.push(drawAnswerBubble(i, question.choices[i], isSelected, isHover));\n      }\n    }\n\n    // Move drone toward target\n    const dx = drone.targetX - drone.x;\n    const dy = drone.targetY - drone.y;\n    const dist = Math.hypot(dx, dy);\n    if (dist > 1) {\n      drone.x += (dx / dist) * Math.min(drone.speed, dist);\n      drone.y += (dy / dist) * Math.min(drone.speed, dist);\n    } else {\n      drone.x = drone.targetX;\n      drone.y = drone.targetY;\n    }\n\n    // Draw drone\n    drawDrone(drone.x, drone.y);\n\n    // Draw UI\n    drawUI();\n\n    // Draw score progress bar center-bottom\n    const progressW = 300;\n    const progressX = WIDTH / 2 - progressW / 2;\n    const progressY = HEIGHT - 140;\n    ctx.fillStyle = \"#eaf6f9\";\n    roundRect(ctx, progressX, progressY, progressW, 18, 10).fill();\n    const pct = Math.min(1, score / GOAL_CORRECT);\n    ctx.fillStyle = palette.accent;\n    roundRect(ctx, progressX, progressY, Math.max(6, progressW * pct), 18, 10).fill();\n\n    // Victory or Game Over screen overlays\n    if (stage === \"won\") {\n      drawEndScreen(true);\n    } else if (stage === \"lost\") {\n      drawEndScreen(false);\n    }\n  }\n\n  function drawEndScreen(won) {\n    // translucent overlay\n    ctx.fillStyle = \"rgba(7,59,76,0.28)\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    // panel\n    const panelW = 520;\n    const panelH = 260;\n    const px = WIDTH / 2 - panelW / 2;\n    const py = HEIGHT / 2 - panelH / 2;\n    ctx.fillStyle = \"#ffffff\";\n    roundRect(ctx, px, py, panelW, panelH, 18).fill();\n    // Text\n    ctx.fillStyle = palette.text;\n    ctx.font = fonts.title;\n    ctx.textAlign = \"center\";\n    ctx.fillText(won ? \"Victory! Drone Mission Complete\" : \"Game Over \u2014 Drone Landed\", WIDTH / 2, py + 26);\n\n    ctx.font = fonts.important;\n    ctx.fillText(won ? `You answered ${score} correct!` : `You answered ${score} correct and had ${wrong} wrong.`, WIDTH / 2, py + 70);\n\n    // tip or encouragement\n    ctx.font = fonts.body;\n    ctx.fillText(won ? \"Great flying! Press R or click Restart to fly again.\" : \"Try again! Press R or click Restart to retry.\", WIDTH / 2, py + 108);\n\n    // Draw restart button\n    const btnW = 160;\n    const btnH = 44;\n    const bx = WIDTH / 2 - btnW / 2;\n    const by = py + panelH - 76;\n    ctx.fillStyle = palette.accent;\n    roundRect(ctx, bx, by, btnW, btnH, 10).fill();\n    ctx.fillStyle = \"#072a2a\";\n    ctx.font = fonts.important;\n    ctx.fillText(\"Restart (R)\", WIDTH / 2, by + 12);\n\n    // Save restart button rect for clicks\n    endButtonRect = { x: bx, y: by, w: btnW, h: btnH };\n  }\n\n  // Interaction handlers\n  let endButtonRect = null;\n\n  canvas.addEventListener(\"mousemove\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    // hover detection on answer bubbles\n    hoverIndex = -1;\n    for (let i = 0; i < answerPositions.length; i++) {\n      const p = answerPositions[i];\n      const dx = mx - p.x;\n      const dy = my - p.y;\n      if (Math.hypot(dx, dy) <= 48) {\n        hoverIndex = i;\n        break;\n      }\n    }\n    canvas.style.cursor = hoverIndex >= 0 ? \"pointer\" : \"default\";\n  });\n\n  canvas.addEventListener(\"click\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n\n    // If end screen showing, check restart button\n    if (stage === \"won\" || stage === \"lost\") {\n      if (endButtonRect && mx >= endButtonRect.x && mx <= endButtonRect.x + endButtonRect.w && my >= endButtonRect.y && my <= endButtonRect.y + endButtonRect.h) {\n        restartGame();\n        return;\n      }\n    }\n\n    // if clicking on answer bubble, select that index and confirm\n    for (let i = 0; i < answerPositions.length; i++) {\n      const p = answerPositions[i];\n      if (Math.hypot(mx - p.x, my - p.y) <= 48) {\n        // move drone to it\n        selectIndex(i);\n        confirmSelection();\n        return;\n      }\n    }\n  });\n\n  function selectIndex(i) {\n    selectedIndex = i;\n    const pos = answerPositions[i];\n    drone.targetX = pos.x;\n    drone.targetY = pos.y - 90; // hover above bubble\n    playMoveSound();\n  }\n\n  window.addEventListener(\"keydown\", (e) => {\n    // provide keyboard controls; container must be focused\n    const key = e.key;\n    if (stage === \"playing\") {\n      if (key === \"ArrowLeft\" || key === \"ArrowUp\") {\n        selectedIndex = (selectedIndex + 3) % 4;\n        selectIndex(selectedIndex);\n        e.preventDefault();\n      } else if (key === \"ArrowRight\" || key === \"ArrowDown\") {\n        selectedIndex = (selectedIndex + 1) % 4;\n        selectIndex(selectedIndex);\n        e.preventDefault();\n      } else if (key === \"Enter\" || key === \" \") {\n        confirmSelection();\n        e.preventDefault();\n      } else if (key.toLowerCase() === \"m\") {\n        audioEnabled = !audioEnabled;\n        if (audioEnabled) tryResumeAudio();\n        announce(`Audio ${audioEnabled ? \"enabled\" : \"muted\"}.`);\n      } else if (key.toLowerCase() === \"r\") {\n        restartGame();\n      }\n    } else {\n      // ended: allow restart\n      if (key.toLowerCase() === \"r\" || key === \"Enter\") {\n        restartGame();\n      }\n      if (key.toLowerCase() === \"m\") {\n        audioEnabled = !audioEnabled;\n        announce(`Audio ${audioEnabled ? \"enabled\" : \"muted\"}.`);\n      }\n    }\n  });\n\n  function confirmSelection() {\n    if (!question || stage !== \"playing\") return;\n    const chosen = question.choices[selectedIndex];\n    answeredCount++;\n    // Visual feedback: move drone to bubble and small bounce\n    drone.targetX = answerPositions[selectedIndex].x;\n    drone.targetY = answerPositions[selectedIndex].y - 90;\n\n    if (chosen === question.correct) {\n      score++;\n      playCorrectSound();\n      announce(`Correct! ${question.correct}. ${score} out of ${GOAL_CORRECT}.`);\n    } else {\n      wrong++;\n      playWrongSound();\n      announce(`Oops! ${chosen} is not correct. The right answer was ${question.correct}. Lives left: ${Math.max(0, MAX_WRONG - wrong)}.`);\n    }\n\n    // brief delay before next question to allow feedback\n    if (score >= GOAL_CORRECT) {\n      setTimeout(() => {\n        stage = \"won\";\n        announce(\"Victory! You completed the mission. Press R to play again.\");\n      }, 600);\n    } else if (wrong >= MAX_WRONG) {\n      setTimeout(() => {\n        stage = \"lost\";\n        announce(\"Game Over. Press R to try again.\");\n      }, 600);\n    } else {\n      setTimeout(() => {\n        nextQuestion();\n      }, 700);\n    }\n  }\n\n  function restartGame() {\n    score = 0;\n    wrong = 0;\n    answeredCount = 0;\n    stage = \"playing\";\n    selectedIndex = 0;\n    drone.x = WIDTH / 2;\n    drone.y = HEIGHT - 120;\n    drone.targetX = drone.x;\n    drone.targetY = drone.y;\n    announce(\"Game restarted. Good luck!\");\n    nextQuestion();\n  }\n\n  // Initialize\n  try {\n    nextQuestion();\n  } catch (e) {\n    console.error(\"Question generation failed\", e);\n    announce(\"Error initializing the game. Try reloading the page.\");\n    stage = \"lost\";\n  }\n\n  // Animation loop\n  let lastRender = 0;\n  function loop(ts) {\n    render();\n    lastRender = ts;\n    requestAnimationFrame(loop);\n  }\n  requestAnimationFrame(loop);\n\n  // Ensure container focus for keyboard controls accessibility\n  container.addEventListener(\"click\", () => {\n    container.focus();\n    tryResumeAudio();\n  });\n\n  // Expose some debug to console (not necessary)\n  window.__droneMathGame = {\n    restart: restartGame,\n    getState: () => ({ score, wrong, stage, question }),\n    toggleAudio: () => { audioEnabled = !audioEnabled; }\n  };\n\n  // Error handling for resource issues (audio context state change)\n  if (audioAvailable && audioCtx) {\n    audioCtx.onstatechange = () => {\n      if (audioCtx.state === \"suspended\") {\n        audioEnabled = false;\n        announce(\"Audio suspended by browser. Press any key to enable sounds.\");\n      } else {\n        audioEnabled = true;\n      }\n    };\n  }\n\n  // Announce initial instructions\n  announce(\"Welcome to Drone Math Adventure! Answer 10 questions correctly. You can make 3 mistakes. Click to focus. Use arrows and Enter or click answers. Press M to toggle audio. Good luck!\");\n})();\n---\n",
  "improve_response_tokens": 16867,
  "formatted_code": true,
  "formatting_response_tokens": 17981,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}