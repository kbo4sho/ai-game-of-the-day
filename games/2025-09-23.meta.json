{
  "generated_date": "2025-09-23",
  "generated_timestamp": "2025-09-23T00:27:00.699172",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9400,
  "game_filename": "2025-09-23.js",
  "game_size_bytes": 28781,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Machine Math Game for ages 7-9\n  // Renders into the existing element with ID 'game-of-the-day-stage'\n  // Uses Canvas-only graphics and Web Audio API for sounds\n  // Accessible: keyboard controls, aria-live status, visual audio indicator\n  // All resources generated in code; no external files\n\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const ROUNDS = 8; // Beat after completing ROUNDS targets\n\n  // Helper: get container element\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Game container element with ID \"game-of-the-day-stage\" not found.');\n    return;\n  }\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute('role', 'application');\n  canvas.setAttribute('aria-label', 'Machine Math Game canvas');\n  canvas.tabIndex = 0; // Make focusable for keyboard controls\n  container.innerHTML = '';\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Responsive font smoothing\n  ctx.imageSmoothingEnabled = true;\n\n  // Accessibility: live region for screen readers\n  const liveRegion = document.createElement('div');\n  liveRegion.style.position = 'absolute';\n  liveRegion.style.left = '-9999px';\n  liveRegion.style.width = '1px';\n  liveRegion.style.height = '1px';\n  liveRegion.style.overflow = 'hidden';\n  liveRegion.setAttribute('aria-live', 'assertive');\n  container.appendChild(liveRegion);\n\n  // Audio setup with error handling\n  let audioCtx = null;\n  let bgGain = null;\n  let bgOsc = null;\n  let audioAvailable = false;\n  let audioMuted = false;\n\n  async function createAudio() {\n    try {\n      const AC = window.AudioContext || window.webkitAudioContext;\n      if (!AC) throw new Error('Web Audio API not supported in this browser.');\n      audioCtx = new AC();\n      // Create background hum\n      bgGain = audioCtx.createGain();\n      bgGain.gain.value = 0.03; // gentle\n      bgGain.connect(audioCtx.destination);\n\n      bgOsc = audioCtx.createOscillator();\n      bgOsc.type = 'sine';\n      bgOsc.frequency.value = 110; // low hum\n      // subtle vibrato via LFO\n      const lfo = audioCtx.createOscillator();\n      lfo.type = 'sine';\n      lfo.frequency.value = 0.25;\n      const lfoGain = audioCtx.createGain();\n      lfoGain.gain.value = 3; // small frequency modulation\n      lfo.connect(lfoGain);\n      lfoGain.connect(bgOsc.frequency);\n\n      bgOsc.connect(bgGain);\n      bgOsc.start();\n      lfo.start();\n\n      audioAvailable = true;\n    } catch (err) {\n      console.warn('Audio unavailable:', err);\n      audioAvailable = false;\n      audioCtx = null;\n    }\n  }\n\n  // Ensure audio context resumed on user gesture\n  async function ensureAudioRunning() {\n    if (!audioAvailable || !audioCtx) return;\n    if (audioCtx.state === 'suspended') {\n      try {\n        await audioCtx.resume();\n      } catch (e) {\n        console.warn('Failed to resume AudioContext:', e);\n      }\n    }\n  }\n\n  // Sound effects using Oscillator + filters + envelopes\n  function playCorrect() {\n    if (!audioAvailable || audioMuted) return;\n    try {\n      const t = audioCtx.currentTime;\n      const osc = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n      const filter = audioCtx.createBiquadFilter();\n      filter.type = 'lowpass';\n      filter.frequency.value = 1200;\n\n      osc.type = 'sine';\n      osc.frequency.setValueAtTime(600, t);\n      osc.frequency.exponentialRampToValueAtTime(1200, t + 0.18);\n\n      gain.gain.setValueAtTime(0, t);\n      gain.gain.linearRampToValueAtTime(0.08, t + 0.02);\n      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.4);\n\n      osc.connect(filter);\n      filter.connect(gain);\n      gain.connect(audioCtx.destination);\n\n      osc.start(t);\n      osc.stop(t + 0.45);\n    } catch (e) {\n      console.warn('playCorrect error', e);\n    }\n  }\n\n  function playIncorrect() {\n    if (!audioAvailable || audioMuted) return;\n    try {\n      const t = audioCtx.currentTime;\n      const osc = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n      const filter = audioCtx.createBiquadFilter();\n      filter.type = 'highpass';\n      filter.frequency.value = 800;\n\n      osc.type = 'sawtooth';\n      osc.frequency.setValueAtTime(180, t);\n      osc.frequency.exponentialRampToValueAtTime(80, t + 0.12);\n\n      gain.gain.setValueAtTime(0.0001, t);\n      gain.gain.linearRampToValueAtTime(0.08, t + 0.01);\n      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.22);\n\n      osc.connect(filter);\n      filter.connect(gain);\n      gain.connect(audioCtx.destination);\n\n      osc.start(t);\n      osc.stop(t + 0.25);\n    } catch (e) {\n      console.warn('playIncorrect error', e);\n    }\n  }\n\n  function playPlace() {\n    if (!audioAvailable || audioMuted) return;\n    try {\n      const t = audioCtx.currentTime;\n      const osc = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n\n      osc.type = 'triangle';\n      osc.frequency.setValueAtTime(800, t);\n      osc.frequency.exponentialRampToValueAtTime(500, t + 0.1);\n      gain.gain.setValueAtTime(0.0001, t);\n      gain.gain.linearRampToValueAtTime(0.06, t + 0.01);\n      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.18);\n\n      osc.connect(gain);\n      gain.connect(audioCtx.destination);\n\n      osc.start(t);\n      osc.stop(t + 0.22);\n    } catch (e) {\n      console.warn('playPlace error', e);\n    }\n  }\n\n  // Game state\n  const game = {\n    round: 0,\n    score: 0,\n    target: 0,\n    gears: [], // each gear: {x, y, r, value, picked, id}\n    selectedGearId: null,\n    slots: [null, null], // gear ids placed\n    dragging: false,\n    dragOffset: { x: 0, y: 0 },\n    finished: false,\n    muted: false,\n    message: 'Click a gear to pick it, then place in Slot A or B. Use arrow keys and Enter for keyboard play.',\n    focusIndex: 0, // for keyboard navigation across gears and slots\n    activeElement: 'gear', // 'gear' or 'slot' for keyboard\n    roundsToWin: ROUNDS,\n  };\n\n  // Utility: announce to screen reader\n  function announce(text) {\n    liveRegion.textContent = '';\n    // Small timeout to ensure screen readers register update\n    setTimeout(() => (liveRegion.textContent = text), 50);\n  }\n\n  // Initialize game\n  function initGame() {\n    // Create audio (but do not resume until user gesture)\n    createAudio().catch((e) => console.warn('createAudio catch', e));\n\n    resetRounds();\n    attachEvents();\n    draw();\n    announce('Machine Math ready. Press Space to start. ' + game.message);\n  }\n\n  function resetRounds() {\n    game.round = 0;\n    game.score = 0;\n    game.finished = false;\n    startNewRound();\n  }\n\n  // Generate gears for a round\n  function spawnGears() {\n    const gears = [];\n    // We'll generate a set of numbers that includes at least one valid pair for the target.\n    // Choose target between 3 and 15\n    const minTarget = 3;\n    const maxTarget = 15;\n    game.target = Math.floor(Math.random() * (maxTarget - minTarget + 1)) + minTarget;\n\n    // Generate a valid pair first\n    const a = Math.floor(Math.random() * Math.min(9, game.target - 1)) + 1;\n    const b = game.target - a;\n    const values = [a, b];\n\n    // Fill more gears with random numbers 1..12\n    while (values.length < 8) {\n      const v = Math.floor(Math.random() * 12) + 1;\n      // small chance to include duplicates\n      values.push(v);\n    }\n\n    // Shuffle values\n    for (let i = values.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [values[i], values[j]] = [values[j], values[i]];\n    }\n\n    // Place gears on a conveyor belt\n    const startX = 110;\n    const gap = 70;\n    const y = 380;\n    for (let i = 0; i < values.length; i++) {\n      gears.push({\n        id: `g${Date.now()}_${i}`,\n        x: startX + i * gap,\n        y,\n        r: 24,\n        value: values[i],\n        picked: false,\n        restingX: startX + i * gap,\n        restingY: y,\n      });\n    }\n    return gears;\n  }\n\n  function startNewRound() {\n    if (game.round >= game.roundsToWin) {\n      game.finished = true;\n      announce('You have completed all rounds! Press Space to play again.');\n      return;\n    }\n\n    game.round += 1;\n    game.gears = spawnGears();\n    game.selectedGearId = null;\n    game.slots = [null, null];\n    game.dragging = false;\n    game.focusIndex = 0;\n    game.activeElement = 'gear';\n    game.finished = false;\n    announce(`Round ${game.round} of ${game.roundsToWin}. Target number ${game.target}. Pick two gears that add up to ${game.target}.`);\n  }\n\n  // Drawing helpers\n  function clearBG() {\n    ctx.fillStyle = '#F2F8FF'; // soft sky\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n  }\n\n  function drawMachine() {\n    // Wacky machine body\n    // Main box\n    ctx.save();\n    ctx.translate(20, 20);\n    // Machine base\n    ctx.fillStyle = '#DDEFF7';\n    roundRect(ctx, 60, 30, 540, 320, 20);\n    ctx.fill();\n\n    // Highlights\n    ctx.fillStyle = '#FFFFFFAA';\n    roundRect(ctx, 70, 40, 200, 40, 8);\n    ctx.fill();\n\n    // Control panel\n    ctx.fillStyle = '#2E6B8A';\n    roundRect(ctx, 280, 50, 180, 80, 12);\n    ctx.fill();\n\n    // Opening where slots are\n    ctx.fillStyle = '#EAF6FF';\n    roundRect(ctx, 110, 120, 400, 140, 10);\n    ctx.fill();\n\n    // Decorative tubes\n    ctx.strokeStyle = '#A2C6D9';\n    ctx.lineWidth = 6;\n    ctx.beginPath();\n    ctx.moveTo(480, 80);\n    ctx.lineTo(560, 40);\n    ctx.stroke();\n\n    ctx.restore();\n\n    // Draw target display\n    ctx.fillStyle = '#3A6B89';\n    ctx.fillRect(520, 60, 160, 60);\n    ctx.fillStyle = '#FFF';\n    ctx.font = '20px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('TARGET', 600, 78);\n    ctx.font = '34px serif';\n    ctx.fillText(String(game.target), 600, 108);\n\n    // Draw two slots A and B\n    drawSlot('A', 200, 190, 70, 70, game.slots[0]);\n    drawSlot('B', 350, 190, 70, 70, game.slots[1]);\n  }\n\n  function drawSlot(letter, x, y, w, h, gearId) {\n    ctx.save();\n    // slot background\n    ctx.fillStyle = '#CCDFF0';\n    roundRect(ctx, x - w / 2 - 4, y - h / 2 - 4, w + 8, h + 8, 10);\n    ctx.fill();\n\n    ctx.fillStyle = '#FFFFFF';\n    roundRect(ctx, x - w / 2, y - h / 2, w, h, 8);\n    ctx.fill();\n\n    // Label\n    ctx.fillStyle = '#556B78';\n    ctx.font = '16px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText(letter, x - w / 2 + 14, y - h / 2 + 20);\n\n    // If gear placed, draw it inside\n    if (gearId) {\n      const gear = game.gears.find((g) => g.id === gearId);\n      if (gear) {\n        drawGear(x + 10, y, gear.r, gear.value, true);\n      }\n    } else {\n      // placeholder small cog\n      drawGear(x + 10, y, 16, '-', true, 0.15);\n    }\n    ctx.restore();\n  }\n\n  function drawConveyor() {\n    // Conveyor belt at bottom for gears\n    ctx.fillStyle = '#2B3E4E';\n    roundRect(ctx, 60, 340, 600, 100, 14);\n    ctx.fill();\n\n    // Decorative bolts\n    ctx.fillStyle = '#7FA3B8';\n    for (let i = 0; i < 12; i++) {\n      ctx.beginPath();\n      ctx.arc(90 + i * 48, 380, 8, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n\n  // Draw a gear with teeth and number\n  function drawGear(x, y, r, value, flat = false, wobble = 0) {\n    ctx.save();\n    // Base circle\n    ctx.translate(x, y);\n    // Wobble rotation to look wacky\n    const wobRot = wobble ? Math.sin(Date.now() / 300 + x) * wobble : 0;\n    ctx.rotate(wobRot);\n\n    // Teeth\n    const teeth = Math.max(8, Math.round(r / 4 + 6));\n    for (let i = 0; i < teeth; i++) {\n      const angle = (i / teeth) * Math.PI * 2;\n      const tx = Math.cos(angle) * (r + 8);\n      const ty = Math.sin(angle) * (r + 8);\n      ctx.fillStyle = '#B7DEFF';\n      ctx.beginPath();\n      ctx.ellipse(tx, ty, 6, 8, angle, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // Main circle\n    ctx.beginPath();\n    ctx.fillStyle = '#7EC6FF';\n    ctx.arc(0, 0, r, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Inner circle\n    ctx.beginPath();\n    ctx.fillStyle = '#E9F8FF';\n    ctx.arc(0, 0, r - 8, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Number\n    ctx.fillStyle = '#1B4050';\n    ctx.font = `${r}px serif`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(String(value), 0, 0);\n\n    ctx.restore();\n  }\n\n  // UI overlay: score, round, instructions, audio icon\n  function drawHUD() {\n    // Top bar\n    ctx.fillStyle = '#EAF6FF';\n    ctx.fillRect(0, 0, WIDTH, 28);\n\n    ctx.fillStyle = '#2D4C57';\n    ctx.font = '14px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText(`Round: ${Math.min(game.round, game.roundsToWin)} / ${game.roundsToWin}`, 12, 18);\n    ctx.fillText(`Score: ${game.score}`, 140, 18);\n\n    // Instructions\n    ctx.textAlign = 'center';\n    ctx.fillText('Pick two gears that add up to the target. Click/Drag or use keyboard. Press M to mute/unmute.', WIDTH / 2, 18);\n\n    // Audio visual cue (speaker icon)\n    drawAudioIcon(WIDTH - 60, 6, audioMuted);\n  }\n\n  function drawAudioIcon(x, y, muted) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.fillStyle = muted ? '#D9534F' : '#4CAF50';\n    ctx.beginPath();\n    ctx.moveTo(0, 8);\n    ctx.lineTo(8, 8);\n    ctx.lineTo(14, 2);\n    ctx.lineTo(14, 22);\n    ctx.lineTo(8, 16);\n    ctx.lineTo(0, 16);\n    ctx.closePath();\n    ctx.fill();\n\n    if (muted) {\n      ctx.strokeStyle = '#FFF';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(-2, 2);\n      ctx.lineTo(18, 26);\n      ctx.stroke();\n    } else {\n      ctx.strokeStyle = '#FFF';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.arc(20, 12, 6, -0.6, 0.6);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  // Draw gears on conveyor\n  function drawGears() {\n    for (const g of game.gears) {\n      let x = g.x;\n      let y = g.y;\n      // If placed in slot, draw at slot position instead\n      if (game.slots.includes(g.id)) {\n        // handled in slot drawing\n        continue;\n      }\n      drawGear(x, y, g.r, g.value, false, 0.04);\n      // outline if selected\n      if (game.selectedGearId === g.id) {\n        ctx.strokeStyle = '#FFD54F';\n        ctx.lineWidth = 3;\n        ctx.beginPath();\n        ctx.arc(x, y, g.r + 10, 0, Math.PI * 2);\n        ctx.stroke();\n      }\n      // Keyboard focus highlight for first run\n      if (game.activeElement === 'gear') {\n        const idx = game.gears.indexOf(g);\n        if (idx === game.focusIndex) {\n          ctx.strokeStyle = '#8EE5A1';\n          ctx.lineWidth = 2;\n          ctx.beginPath();\n          ctx.arc(x, y, g.r + 14, 0, Math.PI * 2);\n          ctx.stroke();\n        }\n      }\n    }\n  }\n\n  // Render everything\n  function draw() {\n    clearBG();\n    drawMachine();\n    drawConveyor();\n    drawGears();\n    drawHUD();\n\n    // Draw slot labels text for clarity\n    ctx.fillStyle = '#264653';\n    ctx.font = '18px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText('Slot A', 150, 170);\n    ctx.fillText('Slot B', 300, 170);\n\n    // Draw messages\n    ctx.fillStyle = '#235A6B';\n    ctx.font = '16px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText(game.message, 12, HEIGHT - 12);\n\n    // If finished show overlay\n    if (game.finished) {\n      ctx.save();\n      ctx.fillStyle = 'rgba(10, 20, 30, 0.6)';\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n      ctx.fillStyle = '#FFF';\n      ctx.font = '34px serif';\n      ctx.textAlign = 'center';\n      if (game.score >= game.roundsToWin) {\n        ctx.fillText('Machine Master! You win!', WIDTH / 2, HEIGHT / 2 - 20);\n        ctx.font = '20px sans-serif';\n        ctx.fillText('Press Space to play again.', WIDTH / 2, HEIGHT / 2 + 20);\n      } else {\n        ctx.fillText('All rounds complete', WIDTH / 2, HEIGHT / 2 - 20);\n        ctx.font = '20px sans-serif';\n        ctx.fillText('Press Space to play again.', WIDTH / 2, HEIGHT / 2 + 20);\n      }\n      ctx.restore();\n    }\n\n    requestAnimationFrame(draw);\n  }\n\n  // Geometry helpers\n  function pointInRect(px, py, rx, ry, rw, rh) {\n    return px >= rx && px <= rx + rw && py >= ry && py <= ry + rh;\n  }\n\n  function roundRect(ctx, x, y, w, h, r) {\n    const radius = r || 5;\n    ctx.beginPath();\n    ctx.moveTo(x + radius, y);\n    ctx.arcTo(x + w, y, x + w, y + h, radius);\n    ctx.arcTo(x + w, y + h, x, y + h, radius);\n    ctx.arcTo(x, y + h, x, y, radius);\n    ctx.arcTo(x, y, x + w, y, radius);\n    ctx.closePath();\n  }\n\n  // Input handling: mouse/keyboard\n  function attachEvents() {\n    // Focus canvas for keyboard\n    canvas.addEventListener('click', async (e) => {\n      canvas.focus();\n      await ensureAudioRunning();\n      const rect = canvas.getBoundingClientRect();\n      const mx = e.clientX - rect.left;\n      const my = e.clientY - rect.top;\n      // Check if clicked on audio icon\n      if (mx >= WIDTH - 80 && mx <= WIDTH - 40 && my >= 0 && my <= 28) {\n        toggleMute();\n        return;\n      }\n      // If finished overlay clicked, restart\n      if (game.finished) {\n        resetRounds();\n        startNewRound();\n        return;\n      }\n      // Check gears\n      for (const g of game.gears) {\n        // skip if already placed in slot\n        if (game.slots.includes(g.id)) continue;\n        const dx = mx - g.x;\n        const dy = my - g.y;\n        if (Math.hypot(dx, dy) <= g.r + 8) {\n          // pick this gear\n          pickGear(g.id);\n          // set drag offset\n          game.dragging = true;\n          game.dragOffset.x = dx;\n          game.dragOffset.y = dy;\n          return;\n        }\n      }\n\n      // If clicked on slot A or B\n      // slot A coords we used earlier: center at (200+10,190) (since drawSlot drew gear at x+10)\n      const slotACenter = { x: 210, y: 190, r: 40 };\n      const slotBCenter = { x: 360, y: 190, r: 40 };\n      if (pointInsideCircle(mx, my, slotACenter.x, slotACenter.y, slotACenter.r)) {\n        placeSelectedInSlot(0);\n      } else if (pointInsideCircle(mx, my, slotBCenter.x, slotBCenter.y, slotBCenter.r)) {\n        placeSelectedInSlot(1);\n      }\n    });\n\n    // Mouse move for dragging\n    canvas.addEventListener('mousemove', (e) => {\n      if (!game.dragging || !game.selectedGearId) return;\n      const rect = canvas.getBoundingClientRect();\n      const mx = e.clientX - rect.left;\n      const my = e.clientY - rect.top;\n      const g = game.gears.find((x) => x.id === game.selectedGearId);\n      if (g) {\n        g.x = mx - game.dragOffset.x;\n        g.y = my - game.dragOffset.y;\n      }\n    });\n\n    // Mouse up to drop\n    canvas.addEventListener('mouseup', () => {\n      if (!game.dragging) return;\n      game.dragging = false;\n      // If released over a slot, place it\n      // compute gear center\n      const g = game.gears.find((x) => x.id === game.selectedGearId);\n      if (!g) return;\n      const mx = g.x;\n      const my = g.y;\n      // slot centers as before\n      const slotACenter = { x: 210, y: 190, r: 40 };\n      const slotBCenter = { x: 360, y: 190, r: 40 };\n      if (pointInsideCircle(mx, my, slotACenter.x, slotACenter.y, slotACenter.r)) {\n        placeSelectedInSlot(0);\n      } else if (pointInsideCircle(mx, my, slotBCenter.x, slotBCenter.y, slotBCenter.r)) {\n        placeSelectedInSlot(1);\n      } else {\n        // snap back to conveyor resting position\n        if (g.restingX && g.restingY) {\n          g.x = g.restingX;\n          g.y = g.restingY;\n        }\n      }\n    });\n\n    // Keyboard controls\n    canvas.addEventListener('keydown', async (e) => {\n      await ensureAudioRunning();\n      if (e.key === ' ' || e.key === 'Spacebar') {\n        e.preventDefault();\n        if (game.finished) {\n          resetRounds();\n          startNewRound();\n          return;\n        }\n        // Space toggles start/resume round by announcing goal\n        announce(`Round ${game.round} target ${game.target}. Pick two gears that sum to ${game.target}.`);\n        return;\n      }\n\n      if (e.key === 'm' || e.key === 'M') {\n        toggleMute();\n        return;\n      }\n\n      // Navigation: left/right/up/down, Enter to pick/place, Escape to cancel selection\n      if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {\n        handleArrowKey(e.key);\n        return;\n      }\n      if (e.key === 'Enter') {\n        handleEnterKey();\n        return;\n      }\n      if (e.key === 'Escape') {\n        cancelSelection();\n        return;\n      }\n      // Numbers 1-8 correspond to gears for quick selection\n      if (/^[1-8]$/.test(e.key)) {\n        const idx = parseInt(e.key, 10) - 1;\n        if (game.gears[idx]) {\n          pickGear(game.gears[idx].id);\n        }\n      }\n    });\n\n    // Touch support minimal: emulate mouse\n    canvas.addEventListener('touchstart', (e) => {\n      e.preventDefault();\n      const touch = e.touches[0];\n      const rect = canvas.getBoundingClientRect();\n      const mx = touch.clientX - rect.left;\n      const my = touch.clientY - rect.top;\n      // same as click\n      for (const g of game.gears) {\n        if (game.slots.includes(g.id)) continue;\n        const dx = mx - g.x;\n        const dy = my - g.y;\n        if (Math.hypot(dx, dy) <= g.r + 8) {\n          pickGear(g.id);\n          game.dragging = true;\n          game.dragOffset.x = dx;\n          game.dragOffset.y = dy;\n          return;\n        }\n      }\n    });\n    canvas.addEventListener('touchmove', (e) => {\n      e.preventDefault();\n      if (!game.dragging || !game.selectedGearId) return;\n      const touch = e.touches[0];\n      const rect = canvas.getBoundingClientRect();\n      const mx = touch.clientX - rect.left;\n      const my = touch.clientY - rect.top;\n      const g = game.gears.find((x) => x.id === game.selectedGearId);\n      if (g) {\n        g.x = mx - game.dragOffset.x;\n        g.y = my - game.dragOffset.y;\n      }\n    });\n    canvas.addEventListener('touchend', (e) => {\n      e.preventDefault();\n      if (!game.dragging) return;\n      game.dragging = false;\n      const g = game.gears.find((x) => x.id === game.selectedGearId);\n      if (!g) return;\n      const mx = g.x;\n      const my = g.y;\n      const slotACenter = { x: 210, y: 190, r: 40 };\n      const slotBCenter = { x: 360, y: 190, r: 40 };\n      if (pointInsideCircle(mx, my, slotACenter.x, slotACenter.y, slotACenter.r)) {\n        placeSelectedInSlot(0);\n      } else if (pointInsideCircle(mx, my, slotBCenter.x, slotBCenter.y, slotBCenter.r)) {\n        placeSelectedInSlot(1);\n      } else {\n        if (g.restingX && g.restingY) {\n          g.x = g.restingX;\n          g.y = g.restingY;\n        }\n      }\n    });\n\n    // Ensure initial focus\n    canvas.addEventListener('focus', () => {\n      // Visual focus captured in draw loop via keyboard events\n    });\n  }\n\n  // Input helpers\n  function handleArrowKey(key) {\n    if (game.activeElement === 'gear') {\n      // Move focus across gears\n      const count = game.gears.length;\n      if (key === 'ArrowLeft') {\n        game.focusIndex = Math.max(0, game.focusIndex - 1);\n      } else if (key === 'ArrowRight') {\n        game.focusIndex = Math.min(count - 1, game.focusIndex + 1);\n      } else if (key === 'ArrowUp' || key === 'ArrowDown') {\n        // switch to slots\n        game.activeElement = 'slot';\n        game.focusIndex = 0; // slot A focus\n      }\n    } else if (game.activeElement === 'slot') {\n      // Toggle between slot A and B with left/right\n      if (key === 'ArrowLeft' || key === 'ArrowRight') {\n        game.focusIndex = game.focusIndex === 0 ? 1 : 0;\n      } else if (key === 'ArrowUp' || key === 'ArrowDown') {\n        // back to gears\n        game.activeElement = 'gear';\n        game.focusIndex = 0;\n      }\n    }\n    // Announce current focus\n    if (game.activeElement === 'gear') {\n      const g = game.gears[game.focusIndex];\n      if (g) announce(`Focused gear ${game.focusIndex + 1}, value ${g.value}`);\n    } else {\n      announce(`Focused slot ${game.focusIndex === 0 ? 'A' : 'B'}`);\n    }\n  }\n\n  function handleEnterKey() {\n    if (game.activeElement === 'gear') {\n      const g = game.gears[game.focusIndex];\n      if (g && !game.slots.includes(g.id)) {\n        pickGear(g.id);\n      } else {\n        announce('No gear to pick here.');\n      }\n    } else {\n      // Place currently selected gear into focused slot\n      placeSelectedInSlot(game.focusIndex);\n    }\n  }\n\n  function pointInsideCircle(px, py, cx, cy, r) {\n    return (px - cx) * (px - cx) + (py - cy) * (py - cy) <= r * r;\n  }\n\n  function pickGear(gearId) {\n    // If already selected, deselect\n    if (game.selectedGearId === gearId) {\n      game.selectedGearId = null;\n      announce('Gear deselected');\n      return;\n    }\n    const gear = game.gears.find((g) => g.id === gearId);\n    if (!gear) return;\n    game.selectedGearId = gearId;\n    // bring to front by moving to end of array\n    const idx = game.gears.indexOf(gear);\n    if (idx >= 0) {\n      game.gears.splice(idx, 1);\n      game.gears.push(gear);\n    }\n    announce(`Picked gear with value ${gear.value}. Place it in Slot A or B.`);\n    playPlace();\n  }\n\n  function placeSelectedInSlot(slotIndex) {\n    if (!game.selectedGearId) {\n      announce('No gear selected to place.');\n      return;\n    }\n    if (game.slots[slotIndex]) {\n      announce(`Slot ${slotIndex === 0 ? 'A' : 'B'} already occupied. Remove gear first.`);\n      return;\n    }\n    // Place gear\n    const gear = game.gears.find((g) => g.id === game.selectedGearId);\n    if (!gear) return;\n    game.slots[slotIndex] = gear.id;\n    // set gear coords to slot center visually\n    const slotCenter = slotIndex === 0 ? { x: 210, y: 190 } : { x: 360, y: 190 };\n    gear.x = slotCenter.x + 10;\n    gear.y = slotCenter.y;\n    game.selectedGearId = null;\n    playPlace();\n    announce(`Placed gear with value ${gear.value} into Slot ${slotIndex === 0 ? 'A' : 'B'}.`);\n\n    // If both slots filled, evaluate\n    if (game.slots[0] && game.slots[1]) {\n      setTimeout(evaluateSlots, 250);\n    }\n  }\n\n  function cancelSelection() {\n    if (game.selectedGearId) {\n      const g = game.gears.find((x) => x.id === game.selectedGearId);\n      if (g && g.restingX && g.restingY) {\n        g.x = g.restingX;\n        g.y = g.restingY;\n      }\n      game.selectedGearId = null;\n      game.dragging = false;\n      announce('Selection cancelled.');\n    }\n  }\n\n  function evaluateSlots() {\n    const gidA = game.slots[0];\n    const gidB = game.slots[1];\n    const gearA = game.gears.find((g) => g.id === gidA);\n    const gearB = game.gears.find((g) => g.id === gidB);\n    if (!gearA || !gearB) {\n      announce('Error: missing gear in slot.');\n      return;\n    }\n    const sum = gearA.value + gearB.value;\n    if (sum === game.target) {\n      // success!\n      playCorrect();\n      game.score += 1;\n      game.message = `Nice! ${gearA.value} + ${gearB.value} = ${game.target}.`;\n      announce(`Correct! ${gearA.value} + ${gearB.value} equals ${game.target}.`);\n      // Light up machine animation: we'll animate by temporarily showing success message and then next round\n      setTimeout(() => {\n        // Clear placed gears by removing them from list to avoid duplicates\n        game.gears = game.gears.filter((g) => ![gidA, gidB].includes(g.id));\n        game.slots = [null, null];\n        if (game.round >= game.roundsToWin) {\n          game.finished = true;\n          announce(`You finished all ${game.roundsToWin} rounds. Score ${game.score}. Press Space to play again.`);\n        } else {\n          startNewRound();\n        }\n      }, 800);\n    } else {\n      // incorrect\n      playIncorrect();\n      game.message = `Oops: ${gearA.value} + ${gearB.value} = ${sum}, not ${game.target}. Try again.`;\n      announce(`Incorrect. ${gearA.value} plus ${gearB.value} makes ${sum}. Remove a gear or try different ones.`);\n      // Unset one slot (B) and snap back A to conveyor for retry to encourage different combos\n      setTimeout(() => {\n        // Snap both back to conveyor but keep values; they stay in gears array\n        for (const sid of [gidA, gidB]) {\n          const gg = game.gears.find((x) => x.id === sid);\n          if (gg) {\n            // Place back at resting pos or nearest slot replaced\n            gg.x = gg.restingX || gg.x;\n            gg.y = gg.restingY || gg.y;\n          }\n        }\n        game.slots = [null, null];\n      }, 600);\n    }\n  }\n\n  function toggleMute() {\n    audioMuted = !audioMuted;\n    if (bgGain) bgGain.gain.value = audioMuted ? 0 : 0.03;\n    game.message = audioMuted ? 'Sound muted' : 'Sound on';\n    announce(game.message);\n  }\n\n  // Start the game initialization\n  initGame();\n\n  // Expose minimal debug controls to window (safe)\n  window.__MachineMathGame = {\n    restart: () => {\n      resetRounds();\n      startNewRound();\n    },\n    mute: () => {\n      audioMuted = true;\n      if (bgGain) bgGain.gain.value = 0;\n    },\n    unmute: () => {\n      audioMuted = false;\n      if (bgGain) bgGain.gain.value = 0.03;\n    },\n  };\n\n  // Start the first round after a user gesture requirement, but allow manual start\n  // Provide instructions visually; already included.\n\n})();\n---\n",
  "improve_response_tokens": 19213,
  "formatted_code": true,
  "formatting_response_tokens": 20846,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}