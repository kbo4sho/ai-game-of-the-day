{
  "generated_date": "2025-10-19",
  "generated_timestamp": "2025-10-19T00:29:44.047956",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8772,
  "game_filename": "2025-10-19.js",
  "game_size_bytes": 26497,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Drone Math Adventure\n  // Designed for children 7-9. Renders inside element with id \"game-of-the-day-stage\".\n  // Strict requirements: canvas sized 720x480, all visuals drawn with canvas, Web Audio API for generated sounds,\n  // clear win/loss conditions: win = 10 correct answers, lose = 3 wrong answers,\n  // accessible keyboard controls, visual audio cues, text alternatives, proper UI layout with no overlapping text.\n\n  // -------------------------\n  // Helper and constants\n  // -------------------------\n  const STAGE_ID = 'game-of-the-day-stage';\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const PADDING = 12; // minimal spacing for UI elements\n  const TARGET_CORRECT = 10;\n  const MAX_WRONG = 3;\n  const MIN_BODY_FONT = 14;\n  const IMPORTANT_FONT = 20;\n\n  // Colors and styles (calming + wacky)\n  const COLORS = {\n    bg: '#eaf6ff',\n    panel: '#ffffffcc',\n    text: '#103c58',\n    accent: '#ff9f1c',\n    good: '#2ecc71',\n    bad: '#ff6b6b',\n    pad: '#9ad3bc',\n    drone: '#6c5ce7',\n    padOutline: '#2b6f6f',\n    shadow: '#00000033',\n    audioIcon: '#333',\n  };\n\n  // -------------------------\n  // Setup DOM and Canvas\n  // -------------------------\n  const container = document.getElementById(STAGE_ID);\n  if (!container) {\n    console.error('Game container not found:', STAGE_ID);\n    return;\n  }\n  container.innerHTML = ''; // Clear any existing content\n\n  // Create a live region for screen readers (text alternative)\n  const liveRegion = document.createElement('div');\n  liveRegion.setAttribute('aria-live', 'polite');\n  liveRegion.setAttribute('role', 'status');\n  liveRegion.style.position = 'absolute';\n  liveRegion.style.left = '-9999px';\n  container.appendChild(liveRegion);\n\n  // Create canvas inside container\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute('role', 'img');\n  canvas.setAttribute('aria-label', 'Drone Math Adventure. Answer math questions with the drone.');\n  canvas.style.display = 'block';\n  canvas.style.background = COLORS.bg;\n  canvas.style.outline = 'none';\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext('2d');\n\n  // Ensure focusable for keyboard controls\n  canvas.tabIndex = 0;\n  canvas.style.cursor = 'pointer';\n\n  // -------------------------\n  // Audio: Web Audio API\n  // -------------------------\n  let audioContext = null;\n  let audioEnabled = true;\n  let ambientGain = null;\n  let ambientOsc1 = null;\n  let ambientOsc2 = null;\n\n  function initAudioContext() {\n    if (audioContext) return;\n    try {\n      const AC = window.AudioContext || window.webkitAudioContext;\n      if (!AC) throw new Error('Web Audio API not supported');\n      audioContext = new AC();\n    } catch (err) {\n      console.warn('Audio context creation failed:', err);\n      audioEnabled = false;\n      audioContext = null;\n      updateLiveRegion('Audio unavailable. The game will run without sound.');\n      return;\n    }\n    // Create ambient sound (gentle hum)\n    try {\n      ambientGain = audioContext.createGain();\n      ambientGain.gain.value = 0.02; // gentle\n      ambientGain.connect(audioContext.destination);\n\n      ambientOsc1 = audioContext.createOscillator();\n      ambientOsc1.type = 'sine';\n      ambientOsc1.frequency.value = 120;\n      const gain1 = audioContext.createGain();\n      gain1.gain.value = 0.02;\n      ambientOsc1.connect(gain1);\n      gain1.connect(ambientGain);\n\n      ambientOsc2 = audioContext.createOscillator();\n      ambientOsc2.type = 'sine';\n      ambientOsc2.frequency.value = 180;\n      const gain2 = audioContext.createGain();\n      gain2.gain.value = 0.015;\n      ambientOsc2.connect(gain2);\n      gain2.connect(ambientGain);\n\n      ambientOsc1.start();\n      ambientOsc2.start();\n    } catch (err) {\n      console.warn('Ambient audio failed:', err);\n      // Continue without ambient\n      try {\n        if (ambientOsc1) ambientOsc1.disconnect();\n        if (ambientOsc2) ambientOsc2.disconnect();\n      } catch (e) {}\n    }\n  }\n\n  function safeResumeAudio() {\n    if (!audioContext || typeof audioContext.resume !== 'function') return;\n    audioContext.resume().catch((err) => {\n      console.warn('Audio resume failed:', err);\n    });\n  }\n\n  // Play a short feedback sound\n  function playTone(type = 'correct') {\n    if (!audioEnabled) return;\n    try {\n      if (!audioContext) initAudioContext();\n      if (!audioContext) return;\n      safeResumeAudio();\n\n      const now = audioContext.currentTime;\n      const osc = audioContext.createOscillator();\n      const gain = audioContext.createGain();\n      const filter = audioContext.createBiquadFilter();\n\n      osc.type = type === 'correct' ? 'sine' : 'sawtooth';\n      if (type === 'correct') osc.frequency.value = 880;\n      else if (type === 'wrong') osc.frequency.value = 120;\n      else osc.frequency.value = 440;\n\n      filter.type = 'lowpass';\n      filter.frequency.value = type === 'correct' ? 2200 : 800;\n\n      gain.gain.setValueAtTime(0, now);\n      gain.gain.linearRampToValueAtTime(type === 'correct' ? 0.08 : 0.09, now + 0.01);\n      gain.gain.exponentialRampToValueAtTime(0.0001, now + (type === 'correct' ? 0.35 : 0.45));\n\n      osc.connect(filter);\n      filter.connect(gain);\n      gain.connect(audioContext.destination);\n\n      osc.start(now);\n      osc.stop(now + (type === 'correct' ? 0.5 : 0.6));\n\n      // Cleanup nodes when finished\n      osc.onended = () => {\n        try {\n          osc.disconnect();\n          filter.disconnect();\n          gain.disconnect();\n        } catch (e) {}\n      };\n    } catch (err) {\n      console.warn('playTone error:', err);\n    }\n  }\n\n  function toggleAudio() {\n    audioEnabled = !audioEnabled;\n    if (audioEnabled) {\n      try {\n        if (!audioContext) initAudioContext();\n        if (ambientGain) ambientGain.gain.value = 0.02;\n        updateLiveRegion('Audio on');\n      } catch (err) {\n        audioEnabled = false;\n        updateLiveRegion('Audio unavailable.');\n      }\n    } else {\n      try {\n        if (ambientGain) ambientGain.gain.value = 0;\n      } catch (err) {}\n      updateLiveRegion('Audio muted');\n    }\n  }\n\n  // -------------------------\n  // Game State\n  // -------------------------\n  const state = {\n    running: true,\n    correctCount: 0,\n    wrongCount: 0,\n    question: null,\n    options: [], // array of numbers\n    selectedIndex: 0, // 0-3\n    message: '',\n    anim: {\n      // drone animation\n      x: WIDTH / 2,\n      y: 120,\n      targetX: WIDTH / 2,\n      targetY: 120,\n      vx: 0,\n      vy: 0,\n      wobble: 0,\n    },\n    phase: 'playing', // playing, win, lose\n    lastInteractionTime: 0,\n    hudSpacing: {\n      score: { x: PADDING, y: PADDING },\n      lives: { x: WIDTH - PADDING, y: PADDING },\n      instructions: { x: WIDTH / 2, y: HEIGHT - PADDING - 10 },\n    },\n    audioAvailable: true,\n    announced: '',\n  };\n\n  // -------------------------\n  // Math question generator\n  // -------------------------\n  function generateQuestion() {\n    // For ages 7-9: mainly addition/subtraction within 20, sometimes small multiplication\n    const types = ['add', 'sub', 'add', 'add', 'mul']; // weighted\n    const t = types[Math.floor(Math.random() * types.length)];\n    let a, b, answer, text;\n    if (t === 'add') {\n      a = randInt(1, 12);\n      b = randInt(1, 12);\n      answer = a + b;\n      text = `${a} + ${b} = ?`;\n    } else if (t === 'sub') {\n      a = randInt(2, 20);\n      b = randInt(1, a - 1);\n      answer = a - b;\n      text = `${a} - ${b} = ?`;\n    } else {\n      a = randInt(2, 6);\n      b = randInt(2, 6);\n      answer = a * b;\n      text = `${a} \u00d7 ${b} = ?`;\n    }\n    // generate 4 options\n    const options = new Set();\n    options.add(answer);\n    while (options.size < 4) {\n      // generate plausible wrong answers\n      let delta = randInt(-4, 6);\n      if (delta === 0) delta = randInt(1, 3);\n      let val = answer + delta;\n      if (val < 0) val = Math.abs(val) + 1;\n      // avoid duplicates\n      if (options.has(val)) continue;\n      options.add(val);\n    }\n    const optionsArr = shuffle(Array.from(options));\n    return { text, answer, options: optionsArr };\n  }\n\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n  function shuffle(arr) {\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    return arr;\n  }\n\n  // -------------------------\n  // UI Layout helpers\n  // -------------------------\n  function drawRoundedRect(x, y, w, h, r = 8, fill = true, stroke = false) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  // Measure text and draw background to avoid overlap\n  function drawTextPanel(text, x, y, options = {}) {\n    const lines = Array.isArray(text) ? text : String(text).split('\\n');\n    const fontSize = options.fontSize || MIN_BODY_FONT;\n    const font = `${fontSize}px sans-serif`;\n    ctx.font = font;\n    let maxWidth = 0;\n    for (const line of lines) {\n      const m = ctx.measureText(line);\n      if (m.width > maxWidth) maxWidth = m.width;\n    }\n    const pad = options.padding || 8;\n    const h = fontSize * lines.length + pad * 2 + (lines.length - 1) * 6;\n    let w = maxWidth + pad * 2;\n    let drawX = x;\n    let drawY = y;\n    if (options.center) {\n      drawX = x - w / 2;\n    } else if (options.right) {\n      drawX = x - w;\n    }\n    if (options.bottom) {\n      drawY = y - h;\n    }\n    // Background\n    ctx.fillStyle = options.bg || COLORS.panel;\n    ctx.strokeStyle = options.border || 'transparent';\n    ctx.lineWidth = options.borderWidth || 0;\n    drawRoundedRect(drawX, drawY, w, h, 8, true, options.borderWidth > 0);\n    // Text\n    ctx.fillStyle = options.color || COLORS.text;\n    ctx.textBaseline = 'top';\n    let ty = drawY + pad;\n    for (const line of lines) {\n      ctx.fillText(line, drawX + pad, ty);\n      ty += fontSize + 6;\n    }\n    return { x: drawX, y: drawY, w, h };\n  }\n\n  // -------------------------\n  // Drawing: drone, pads, UI\n  // -------------------------\n  const padsY = 320;\n  const padRadius = 44;\n  const padSlots = 4;\n  const padPositions = [];\n  for (let i = 0; i < padSlots; i++) {\n    const spacing = WIDTH / (padSlots + 1);\n    padPositions.push({ x: spacing * (i + 1), y: padsY });\n  }\n\n  function drawScene() {\n    // Background\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    ctx.fillStyle = COLORS.bg;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Soft clouds/wacky elements (draw some arcs)\n    drawClouds();\n\n    // Draw central play field (area where drone flies)\n    ctx.fillStyle = '#dff3ff';\n    ctx.fillRect(40, 70, WIDTH - 80, 210);\n\n    // Draw pads\n    for (let i = 0; i < padSlots; i++) {\n      drawPad(padPositions[i].x, padPositions[i].y, state.options[i], i === state.selectedIndex);\n    }\n\n    // Draw drone\n    drawDrone(state.anim.x, state.anim.y, state.anim.wobble);\n\n    // UI: Score (top-left)\n    ctx.textBaseline = 'top';\n    ctx.font = `${IMPORTANT_FONT}px sans-serif`;\n    const scoreText = `Stars: ${state.correctCount}/${TARGET_CORRECT}`;\n    drawTextPanel(scoreText, PADDING, PADDING, {\n      fontSize: IMPORTANT_FONT,\n      padding: 10,\n      bg: COLORS.panel,\n      color: COLORS.text,\n    });\n\n    // UI: Lives (top-right)\n    const livesText = `Lives: ${MAX_WRONG - state.wrongCount}`;\n    drawTextPanel(livesText, WIDTH - PADDING, PADDING, {\n      fontSize: IMPORTANT_FONT,\n      padding: 10,\n      bg: COLORS.panel,\n      color: state.wrongCount >= MAX_WRONG ? COLORS.bad : COLORS.text,\n      right: true,\n    });\n\n    // UI: Audio icon (top-center-right)\n    drawAudioIcon();\n\n    // Question panel at center-top (inside play field)\n    ctx.font = `${IMPORTANT_FONT + 2}px sans-serif`;\n    const qText = state.question ? state.question.text : '';\n    drawTextPanel(qText, WIDTH / 2, 90, {\n      fontSize: IMPORTANT_FONT + 2,\n      padding: 12,\n      bg: COLORS.panel,\n      color: COLORS.text,\n      center: true,\n    });\n\n    // Instructions bottom-center\n    const instrLines = [\n      'Select the correct answer pad.',\n      'Keys: 1\u20134 to pick, \u2190 \u2192 to move, Enter to confirm, M to mute, Space to restart after end.',\n    ];\n    drawTextPanel(instrLines, WIDTH / 2, HEIGHT - PADDING, {\n      fontSize: MIN_BODY_FONT,\n      padding: 10,\n      bg: COLORS.panel,\n      color: COLORS.text,\n      center: true,\n      bottom: true,\n    });\n\n    // Message near center (feedback)\n    if (state.message) {\n      ctx.font = `${IMPORTANT_FONT}px sans-serif`;\n      drawTextPanel(state.message, WIDTH / 2, padsY - 60, {\n        fontSize: IMPORTANT_FONT,\n        padding: 10,\n        bg: COLORS.panel,\n        color: COLORS.accent,\n        center: true,\n      });\n    }\n\n    // If win/lose, show end screen overlay\n    if (state.phase === 'win' || state.phase === 'lose') {\n      drawEndScreen();\n    }\n  }\n\n  function drawClouds() {\n    // Draw a few soft ellipses / clouds for calming wacky effect\n    ctx.save();\n    ctx.globalAlpha = 0.4;\n    ctx.fillStyle = '#ffffff';\n    drawCloud(100, 40, 80, 30);\n    drawCloud(200, 30, 120, 40);\n    drawCloud(520, 50, 100, 35);\n    drawCloud(620, 40, 70, 25);\n    ctx.restore();\n  }\n\n  function drawCloud(cx, cy, w, h) {\n    ctx.beginPath();\n    ctx.ellipse(cx - w * 0.2, cy, w * 0.3, h * 0.5, 0, 0, Math.PI * 2);\n    ctx.ellipse(cx + w * 0.1, cy - 6, w * 0.35, h * 0.5, 0, 0, Math.PI * 2);\n    ctx.ellipse(cx + w * 0.45, cy + 2, w * 0.25, h * 0.45, 0, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  function drawPad(x, y, label, selected) {\n    // draw shadow\n    ctx.save();\n    ctx.fillStyle = COLORS.shadow;\n    ctx.beginPath();\n    ctx.ellipse(x + 6, y + 18, padRadius + 8, padRadius / 2, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n\n    // pad base\n    ctx.fillStyle = COLORS.pad;\n    ctx.strokeStyle = COLORS.padOutline;\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.arc(x, y, padRadius, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n\n    // highlight if selected\n    if (selected) {\n      ctx.beginPath();\n      ctx.arc(x, y, padRadius + 6, 0, Math.PI * 2);\n      ctx.strokeStyle = COLORS.accent;\n      ctx.lineWidth = 4;\n      ctx.stroke();\n    }\n\n    // label number inside\n    const fontSize = 18;\n    ctx.font = `${fontSize}px sans-serif`;\n    ctx.fillStyle = COLORS.text;\n    ctx.textBaseline = 'middle';\n    ctx.textAlign = 'center';\n    ctx.fillText(String(label), x, y);\n  }\n\n  function drawDrone(cx, cy, wobble = 0) {\n    // Draw a cute wacky drone using arcs and rectangles\n    ctx.save();\n    ctx.shadowColor = COLORS.shadow;\n    ctx.shadowBlur = 6;\n    ctx.translate(cx, cy);\n    ctx.rotate(Math.sin(wobble) * 0.05);\n\n    // body\n    ctx.fillStyle = COLORS.drone;\n    ctx.strokeStyle = '#2b1a6f';\n    ctx.lineWidth = 3;\n    drawRoundedRect(-48, -18, 96, 36, 18, true, true);\n\n    // rotor arms and rotors\n    const arms = [-40, 40];\n    arms.forEach((ax) => {\n      ctx.beginPath();\n      ctx.moveTo(ax, -12);\n      ctx.lineTo(ax * 1.5, -44);\n      ctx.strokeStyle = '#2b1a6f';\n      ctx.lineWidth = 4;\n      ctx.stroke();\n\n      // rotor circle\n      ctx.beginPath();\n      ctx.arc(ax * 1.5, -44, 14, 0, Math.PI * 2);\n      ctx.fillStyle = '#ffffff';\n      ctx.fill();\n      ctx.stroke();\n      // rotor blades (wacky)\n      ctx.beginPath();\n      ctx.fillStyle = '#222222';\n      ctx.ellipse(ax * 1.5, -44, 18, 3 + Math.abs(Math.sin(wobble) * 2), Math.sin(wobble), 0, Math.PI * 2);\n      ctx.fill();\n    });\n\n    // window\n    ctx.beginPath();\n    ctx.fillStyle = '#bfe9ff';\n    ctx.arc(0, 0, 18, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n\n    // little star (if needed)\n    if (state.correctCount > 0) {\n      ctx.fillStyle = COLORS.accent;\n      drawStar(-38, 0, 5, 6, 3);\n    }\n\n    ctx.restore();\n  }\n\n  function drawStar(cx, cy, spikes, outerRadius, innerRadius) {\n    let rot = Math.PI / 2 * 3;\n    let x = cx;\n    let y = cy;\n    ctx.beginPath();\n    ctx.moveTo(cx, cy - outerRadius);\n    for (let i = 0; i < spikes; i++) {\n      x = cx + Math.cos(rot) * outerRadius;\n      y = cy + Math.sin(rot) * outerRadius;\n      ctx.lineTo(x, y);\n      rot += Math.PI / spikes;\n      x = cx + Math.cos(rot) * innerRadius;\n      y = cy + Math.sin(rot) * innerRadius;\n      ctx.lineTo(x, y);\n      rot += Math.PI / spikes;\n    }\n    ctx.lineTo(cx, cy - outerRadius);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function drawAudioIcon() {\n    const x = WIDTH - 120;\n    const y = PADDING + 6;\n    const iconText = audioEnabled ? '\ud83d\udd0a' : '\ud83d\udd08';\n    ctx.font = `${20}px sans-serif`;\n    ctx.fillStyle = COLORS.audioIcon;\n    ctx.textBaseline = 'top';\n    const m = ctx.measureText(iconText);\n    // background\n    drawTextPanel(iconText, x + 10, y, {\n      fontSize: 20,\n      padding: 8,\n      bg: COLORS.panel,\n      color: COLORS.audioIcon,\n    });\n    // small label\n    ctx.font = `${12}px sans-serif`;\n    ctx.fillStyle = COLORS.text;\n    ctx.fillText('Press M to toggle sound', x - 50, y + 40);\n  }\n\n  function drawEndScreen() {\n    // semi-transparent overlay\n    ctx.save();\n    ctx.fillStyle = '#00000080';\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.restore();\n\n    const title = state.phase === 'win' ? 'Mission Complete!' : 'Drone Grounded';\n    const message =\n      state.phase === 'win'\n        ? `You delivered ${state.correctCount} stars! Great piloting!`\n        : `Too many oops. You got ${state.correctCount} correct. Try again!`;\n\n    ctx.font = `${28}px sans-serif`;\n    drawTextPanel(title, WIDTH / 2, HEIGHT / 2 - 60, {\n      fontSize: 28,\n      padding: 14,\n      bg: COLORS.panel,\n      color: state.phase === 'win' ? COLORS.good : COLORS.bad,\n      center: true,\n    });\n\n    ctx.font = `${16}px sans-serif`;\n    drawTextPanel(message, WIDTH / 2, HEIGHT / 2 - 10, {\n      fontSize: 16,\n      padding: 12,\n      bg: COLORS.panel,\n      color: COLORS.text,\n      center: true,\n    });\n\n    const restartMsg = ['Press Space or click to restart'];\n    drawTextPanel(restartMsg, WIDTH / 2, HEIGHT / 2 + 50, {\n      fontSize: 16,\n      padding: 10,\n      bg: COLORS.panel,\n      color: COLORS.text,\n      center: true,\n    });\n  }\n\n  // -------------------------\n  // Game Logic\n  // -------------------------\n  function newQuestion() {\n    state.question = generateQuestion();\n    state.options = state.question.options;\n    state.selectedIndex = 0;\n    state.message = '';\n    // position drone to center\n    state.anim.targetX = WIDTH / 2;\n    state.anim.targetY = 120;\n    updateLiveRegion(`New question: ${state.question.text}`);\n  }\n\n  function selectIndex(index) {\n    if (state.phase !== 'playing') return;\n    state.selectedIndex = Math.max(0, Math.min(padSlots - 1, index));\n    updateLiveRegion(`Selected option ${index + 1}: ${state.options[state.selectedIndex]}`);\n  }\n\n  function confirmSelection() {\n    if (state.phase !== 'playing') return;\n    const chosen = state.options[state.selectedIndex];\n    const correct = state.question.answer;\n    state.lastInteractionTime = Date.now();\n    if (chosen === correct) {\n      // correct\n      state.correctCount++;\n      state.message = 'Nice! Correct!';\n      playTone('correct');\n      moveDroneToPad(state.selectedIndex, true);\n      updateLiveRegion('Correct! Good job.');\n    } else {\n      // wrong\n      state.wrongCount++;\n      state.message = 'Oops! Try again!';\n      playTone('wrong');\n      wobbleDrone();\n      updateLiveRegion('Incorrect answer.');\n    }\n    // Check win/lose\n    if (state.correctCount >= TARGET_CORRECT) {\n      state.phase = 'win';\n      state.message = '';\n      updateLiveRegion('You win! Mission complete!');\n      playTone('correct');\n    } else if (state.wrongCount >= MAX_WRONG) {\n      state.phase = 'lose';\n      state.message = '';\n      updateLiveRegion('Game over. Drone grounded.');\n      playTone('wrong');\n    } else {\n      // schedule next question after short animation\n      setTimeout(() => {\n        if (state.phase === 'playing') newQuestion();\n      }, 800);\n    }\n  }\n\n  function moveDroneToPad(index, collect = false) {\n    const target = padPositions[index];\n    // Set drone target to above the pad\n    state.anim.targetX = target.x;\n    state.anim.targetY = target.y - padRadius - 20;\n    // Slight vertical drop if collect\n    if (collect) {\n      // animate: go down and up, then back to center\n      const originalY = state.anim.y;\n      const dropY = target.y - padRadius - 6;\n      // Using simple timed tween\n      const start = performance.now();\n      const duration = 500;\n      const startX = state.anim.x;\n      const startY = state.anim.y;\n\n      // We'll still use the global animation loop but mark vx/vy\n      // Directly set target values; animate via update loop smoothing\n    }\n  }\n\n  function wobbleDrone() {\n    state.anim.wobble = 6;\n  }\n\n  // -------------------------\n  // Animation loop\n  // -------------------------\n  let lastTime = performance.now();\n  function update(dt) {\n    // Simple smoothing towards target for drone\n    const ax = state.anim.targetX - state.anim.x;\n    const ay = state.anim.targetY - state.anim.y;\n    state.anim.vx = state.anim.vx * 0.85 + ax * 0.08;\n    state.anim.vy = state.anim.vy * 0.85 + ay * 0.06;\n    state.anim.x += state.anim.vx * dt * 0.06;\n    state.anim.y += state.anim.vy * dt * 0.06;\n\n    // wobble decay\n    state.anim.wobble *= 0.92;\n    if (Math.abs(state.anim.wobble) < 0.01) state.anim.wobble = 0;\n  }\n\n  function loop(now) {\n    const dt = (now - lastTime) / 16.67; // roughly 60fps units\n    lastTime = now;\n    update(dt);\n    drawScene();\n    requestAnimationFrame(loop);\n  }\n\n  // -------------------------\n  // Input: keyboard and mouse\n  // -------------------------\n  function onKeyDown(e) {\n    // Ensure audio context starts on first user interaction\n    if (!audioContext && audioEnabled) {\n      try {\n        initAudioContext();\n        safeResumeAudio();\n      } catch (err) {\n        console.warn('Audio init on interaction failed', err);\n      }\n    }\n    if (state.phase === 'playing') {\n      if (e.key >= '1' && e.key <= '4') {\n        const idx = parseInt(e.key, 10) - 1;\n        selectIndex(idx);\n        e.preventDefault();\n      } else if (e.key === 'ArrowLeft') {\n        selectIndex(state.selectedIndex - 1);\n        e.preventDefault();\n      } else if (e.key === 'ArrowRight') {\n        selectIndex(state.selectedIndex + 1);\n        e.preventDefault();\n      } else if (e.key === 'Enter' || e.key === ' ') {\n        // Space/Enter confirm when playing\n        confirmSelection();\n        e.preventDefault();\n      }\n    } else {\n      // End screens: Space or Enter to restart\n      if (e.key === ' ' || e.key === 'Spacebar' || e.key === 'Enter') {\n        restartGame();\n        e.preventDefault();\n      }\n    }\n    if (e.key.toLowerCase() === 'm') {\n      toggleAudio();\n      e.preventDefault();\n    }\n  }\n\n  function onClick(e) {\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    // If in end screen, restart\n    if (state.phase !== 'playing') {\n      restartGame();\n      return;\n    }\n    // Click on pads?\n    for (let i = 0; i < padSlots; i++) {\n      const p = padPositions[i];\n      const dx = x - p.x;\n      const dy = y - p.y;\n      if (dx * dx + dy * dy <= (padRadius + 8) * (padRadius + 8)) {\n        selectIndex(i);\n        confirmSelection();\n        return;\n      }\n    }\n    // click audio icon region roughly\n    // (we can toggle audio if clicked near top-right area)\n    if (x > WIDTH - 160 && x < WIDTH - 40 && y < 80) {\n      toggleAudio();\n    }\n  }\n\n  // -------------------------\n  // Restart and helpers\n  // -------------------------\n  function restartGame() {\n    state.phase = 'playing';\n    state.correctCount = 0;\n    state.wrongCount = 0;\n    state.message = '';\n    state.selectedIndex = 0;\n    state.anim.x = WIDTH / 2;\n    state.anim.y = 120;\n    state.anim.targetX = WIDTH / 2;\n    state.anim.targetY = 120;\n    newQuestion();\n    updateLiveRegion('Game restarted. Good luck!');\n    // Ensure audio resumed if enabled\n    if (audioEnabled) {\n      try {\n        initAudioContext();\n        safeResumeAudio();\n      } catch (err) {}\n    }\n  }\n\n  function updateLiveRegion(text) {\n    liveRegion.textContent = text;\n    state.announced = text;\n  }\n\n  // -------------------------\n  // Initialization\n  // -------------------------\n  function start() {\n    // Fonts and initial measurement check\n    ctx.textBaseline = 'top';\n    ctx.font = `${MIN_BODY_FONT}px sans-serif`;\n\n    // Create initial question\n    newQuestion();\n\n    // Attach events\n    canvas.addEventListener('keydown', onKeyDown);\n    canvas.addEventListener('click', onClick);\n    // Also allow container to receive clicks for accessibility\n    container.addEventListener('click', () => {\n      canvas.focus();\n    });\n\n    // Try to init audio, but handle failures gracefully\n    try {\n      initAudioContext();\n    } catch (err) {\n      console.warn('Audio init error on start', err);\n    }\n\n    // Kick off render loop\n    lastTime = performance.now();\n    requestAnimationFrame(loop);\n    // Focus canvas to allow keyboard immediately\n    setTimeout(() => {\n      try {\n        canvas.focus();\n      } catch (e) {}\n    }, 50);\n\n    updateLiveRegion('Welcome to Drone Math Adventure! Use keys 1 to 4 to answer.');\n  }\n\n  // Error handling for audio context creation on user gesture\n  function resumeAudioOnFirstGesture() {\n    function resume() {\n      if (audioEnabled && audioContext) {\n        audioContext.resume().catch(() => {});\n      }\n      window.removeEventListener('pointerdown', resume);\n      window.removeEventListener('keydown', resume);\n    }\n    window.addEventListener('pointerdown', resume, { once: true });\n    window.addEventListener('keydown', resume, { once: true });\n  }\n\n  // Start the game\n  try {\n    start();\n    resumeAudioOnFirstGesture();\n  } catch (err) {\n    console.error('Game initialization error', err);\n    // Draw an error message on canvas\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    drawTextPanel('An error occurred initializing the game.', WIDTH / 2, HEIGHT / 2, {\n      fontSize: 18,\n      padding: 12,\n      bg: '#fff4f4',\n      color: COLORS.bad,\n      center: true,\n    });\n    updateLiveRegion('An error occurred initializing the game. Please try reloading the page.');\n  }\n})();\n---\n",
  "improve_response_tokens": 17573,
  "formatted_code": true,
  "formatting_response_tokens": 18840,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}