{
  "generated_date": "2025-11-15",
  "generated_timestamp": "2025-11-15T00:27:50.232321",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9119,
  "game_filename": "2025-11-15.js",
  "game_size_bytes": 27757,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function() {\n  // Drone Math Game for ages 7-9\n  // Renders entirely inside #game-of-the-day-stage\n  // All visuals via canvas, all sounds via Web Audio API oscillators/filters\n  // Goal: Answer 10 questions correctly to win\n  // Lose: 3 wrong answers -> Game Over\n  // Accessible: keyboard controls, clear instructions, audio visual cues\n  // Written with error handling and clean structure\n\n  // Ensure container exists\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Container element with id \"game-of-the-day-stage\" not found.');\n    return;\n  }\n\n  // Clear container and create canvas\n  container.innerHTML = '';\n  const canvas = document.createElement('canvas');\n  canvas.width = 720;\n  canvas.height = 480;\n  canvas.style.width = '720px';\n  canvas.style.height = '480px';\n  canvas.setAttribute('role', 'application');\n  canvas.setAttribute('aria-label', 'Drone Math Game: answer questions to collect stars');\n  canvas.tabIndex = 0; // make focusable for keyboard\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Constants for UI layout - ensure padding and non-overlapping\n  const WIDTH = canvas.width;\n  const HEIGHT = canvas.height;\n  const PADDING = 12; // >=10px\n  const SCORE_X = PADDING;\n  const SCORE_Y = PADDING;\n  const LIVES_X = WIDTH - PADDING;\n  const LIVES_Y = PADDING;\n  const INSTRUCTIONS_Y = HEIGHT - 60; // bottom-center instructions\n  const BODY_FONT = '16px -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial';\n  const TITLE_FONT = '22px \"Segoe UI\", Roboto, Arial';\n  const IMPORTANT_FONT = '20px \"Segoe UI\", Roboto, Arial';\n\n  // Game settings\n  const TARGET_CORRECT = 10;\n  const MAX_WRONG = 3;\n  const OPTION_COUNT = 3;\n\n  // Audio manager\n  class AudioManager {\n    constructor() {\n      this.enabled = true;\n      this.context = null;\n      this.gain = null;\n      this.bgOsc = null;\n      this.bgLfo = null;\n      this._initError = null;\n      this._initAttempted = false;\n    }\n\n    async init() {\n      if (this._initAttempted) return;\n      this._initAttempted = true;\n      try {\n        // Cross-browser AudioContext\n        const Ctx = window.AudioContext || window.webkitAudioContext;\n        if (!Ctx) throw new Error('Web Audio API not supported in this browser.');\n        this.context = new Ctx();\n        this.gain = this.context.createGain();\n        this.gain.gain.value = 0.08;\n        this.gain.connect(this.context.destination);\n\n        // Gentle background hum using oscillator + LFO for subtle movement\n        this.bgOsc = this.context.createOscillator();\n        this.bgOsc.type = 'sine';\n        this.bgOsc.frequency.value = 200;\n        const bgFilter = this.context.createBiquadFilter();\n        bgFilter.type = 'lowpass';\n        bgFilter.frequency.value = 900;\n        this.bgOsc.connect(bgFilter);\n\n        // LFO to modulate gain slightly\n        this.bgLfo = this.context.createOscillator();\n        this.bgLfo.type = 'sine';\n        this.bgLfo.frequency.value = 0.08;\n        const lfoGain = this.context.createGain();\n        lfoGain.gain.value = 0.02;\n        this.bgLfo.connect(lfoGain);\n        lfoGain.connect(this.gain.gain);\n\n        bgFilter.connect(this.gain);\n\n        this.bgOsc.start();\n        this.bgLfo.start();\n      } catch (e) {\n        console.warn('Audio initialization failed:', e);\n        this._initError = e;\n        this.context = null;\n      }\n    }\n\n    // Visual cue to show audio status\n    isAvailable() {\n      return !!this.context && !this._initError;\n    }\n\n    toggle() {\n      this.enabled = !this.enabled;\n    }\n\n    // Play a short chime for correct answer\n    playCorrect() {\n      if (!this.enabled) return;\n      try {\n        if (!this.context) return;\n        const ctx = this.context;\n        const osc = ctx.createOscillator();\n        const gain = ctx.createGain();\n        const filter = ctx.createBiquadFilter();\n        osc.type = 'triangle';\n        osc.frequency.value = 880;\n        filter.type = 'highpass';\n        filter.frequency.value = 400;\n        gain.gain.value = 0;\n        osc.connect(filter);\n        filter.connect(gain);\n        gain.connect(this.gain);\n\n        const now = ctx.currentTime;\n        gain.gain.cancelScheduledValues(now);\n        gain.gain.setValueAtTime(0.0001, now);\n        gain.gain.exponentialRampToValueAtTime(0.25, now + 0.02);\n        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.45);\n\n        osc.frequency.setValueAtTime(880, now);\n        osc.frequency.exponentialRampToValueAtTime(660, now + 0.45);\n\n        osc.start(now);\n        osc.stop(now + 0.5);\n      } catch (e) {\n        console.warn('playCorrect error', e);\n      }\n    }\n\n    // Play a buzz for incorrect answer\n    playIncorrect() {\n      if (!this.enabled) return;\n      try {\n        if (!this.context) return;\n        const ctx = this.context;\n        const osc = ctx.createOscillator();\n        const gain = ctx.createGain();\n        const filter = ctx.createBiquadFilter();\n        osc.type = 'sawtooth';\n        osc.frequency.value = 220;\n        filter.type = 'lowpass';\n        filter.frequency.value = 800;\n        gain.gain.value = 0;\n        osc.connect(filter);\n        filter.connect(gain);\n        gain.connect(this.gain);\n\n        const now = ctx.currentTime;\n        gain.gain.cancelScheduledValues(now);\n        gain.gain.setValueAtTime(0.0001, now);\n        gain.gain.exponentialRampToValueAtTime(0.18, now + 0.01);\n        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);\n\n        osc.frequency.setValueAtTime(220, now);\n        osc.frequency.exponentialRampToValueAtTime(160, now + 0.3);\n\n        osc.start(now);\n        osc.stop(now + 0.4);\n      } catch (e) {\n        console.warn('playIncorrect error', e);\n      }\n    }\n\n    // Click/selection sound\n    playClick() {\n      if (!this.enabled) return;\n      try {\n        if (!this.context) return;\n        const ctx = this.context;\n        const osc = ctx.createOscillator();\n        const gain = ctx.createGain();\n        osc.type = 'square';\n        osc.frequency.value = 600;\n        osc.connect(gain);\n        gain.connect(this.gain);\n        const now = ctx.currentTime;\n        gain.gain.setValueAtTime(0.0001, now);\n        gain.gain.exponentialRampToValueAtTime(0.12, now + 0.01);\n        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);\n        osc.start();\n        osc.stop(now + 0.15);\n      } catch (e) {\n        console.warn('playClick error', e);\n      }\n    }\n  }\n\n  const audio = new AudioManager();\n\n  // Question generator for ages 7-9\n  class QuestionGenerator {\n    static generate(difficultyLevel = 1) {\n      // difficultyLevel increases slightly over time (1..)\n      // Mix addition, subtraction, and simple multiplication (2-5)\n      const types = ['add', 'sub', 'mul'];\n      const type = types[Math.floor(Math.random() * types.length)];\n      let a, b, answer;\n      if (type === 'add') {\n        const max = 10 + Math.min(10, difficultyLevel * 2);\n        a = QuestionGenerator.randInt(1, max);\n        b = QuestionGenerator.randInt(1, max);\n        answer = a + b;\n      } else if (type === 'sub') {\n        const max = 15 + Math.min(10, difficultyLevel * 2);\n        a = QuestionGenerator.randInt(1, max);\n        b = QuestionGenerator.randInt(1, Math.min(a, Math.max(1, Math.floor(max / 2))));\n        answer = a - b;\n      } else { // mul\n        a = QuestionGenerator.randInt(2, 6);\n        b = QuestionGenerator.randInt(2, 6);\n        answer = a * b;\n      }\n      // generate unique options\n      const options = new Set();\n      options.add(answer);\n      while (options.size < OPTION_COUNT) {\n        let delta = QuestionGenerator.randInt(1, Math.max(2, Math.floor(answer * 0.4) + 2));\n        if (Math.random() < 0.5) delta = -delta;\n        const opt = Math.max(0, answer + delta);\n        options.add(opt);\n      }\n      const optionArray = Array.from(options);\n      // shuffle\n      for (let i = optionArray.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [optionArray[i], optionArray[j]] = [optionArray[j], optionArray[i]];\n      }\n      const text = (type === 'add') ? `${a} + ${b}` : (type === 'sub') ? `${a} - ${b}` : `${a} \u00d7 ${b}`;\n      return { text, answer, options: optionArray };\n    }\n\n    static randInt(min, max) {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n  }\n\n  // Game state and rendering\n  const GameState = {\n    running: true,\n    score: 0,\n    wrong: 0,\n    target: TARGET_CORRECT,\n    maxWrong: MAX_WRONG,\n    question: null,\n    difficulty: 1,\n    selectedIndex: 0,\n    droneX: WIDTH / 2,\n    droneY: HEIGHT / 2,\n    droneTargetX: WIDTH / 2,\n    droneTargetY: HEIGHT / 2,\n    animationTime: 0,\n    state: 'playing', // 'playing', 'victory', 'gameover', 'title'\n  };\n\n  // Option areas for hit testing and layout\n  let optionAreas = []; // array of {x,y,w,h,index}\n\n  // Accessibility: last action text for screen readers (we set it as hidden aria-live text via DOM)\n  let ariaLive = document.createElement('div');\n  ariaLive.style.position = 'absolute';\n  ariaLive.style.left = '-9999px';\n  ariaLive.setAttribute('aria-live', 'polite');\n  container.appendChild(ariaLive);\n\n  // Initialize question\n  function nextQuestion() {\n    GameState.question = QuestionGenerator.generate(GameState.difficulty);\n    GameState.selectedIndex = 0;\n    // scale difficulty slowly\n    if (GameState.score > 0 && GameState.score % 3 === 0) {\n      GameState.difficulty = Math.min(8, GameState.difficulty + 1);\n    }\n    // pick drone target x based on selected index - center initially\n    GameState.droneTargetX = WIDTH / 2;\n    GameState.droneTargetY = HEIGHT / 2 - 30;\n  }\n\n  nextQuestion();\n\n  // Input handling\n  const keysDown = new Set();\n  canvas.addEventListener('keydown', (e) => {\n    // Ensure audio context is resumed on first user interaction\n    if (!audio.context) {\n      audio.init().then(() => {\n        // Try to resume if suspended\n        try {\n          if (audio.context && audio.context.state === 'suspended') audio.context.resume();\n        } catch (err) {\n          console.warn('Audio resume error', err);\n        }\n      }).catch(() => {});\n    }\n    if (GameState.state === 'playing') {\n      handleGameplayKey(e);\n    } else if (GameState.state === 'victory' || GameState.state === 'gameover' || GameState.state === 'title') {\n      if (e.key.toLowerCase() === 'r') {\n        restartGame();\n      }\n    }\n    if (e.key === 'm' || e.key === 'M') {\n      audio.toggle();\n      audio.playClick();\n    }\n  });\n\n  function handleGameplayKey(e) {\n    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {\n      e.preventDefault();\n      audio.playClick();\n      if (e.key === 'ArrowLeft') {\n        GameState.selectedIndex = (GameState.selectedIndex - 1 + OPTION_COUNT) % OPTION_COUNT;\n      } else if (e.key === 'ArrowRight') {\n        GameState.selectedIndex = (GameState.selectedIndex + 1) % OPTION_COUNT;\n      } else if (e.key === 'ArrowUp') {\n        GameState.selectedIndex = 0;\n      } else if (e.key === 'ArrowDown') {\n        GameState.selectedIndex = OPTION_COUNT - 1;\n      }\n      // move drone target to the currently selected option (will be updated next frame)\n      const area = optionAreas[GameState.selectedIndex];\n      if (area) {\n        GameState.droneTargetX = area.x + area.w / 2;\n        GameState.droneTargetY = area.y - 34;\n      }\n      ariaLive.textContent = `Selected option ${GameState.selectedIndex + 1}`;\n    } else if (e.key === 'Enter' || e.key === ' ') {\n      e.preventDefault();\n      attemptAnswer(GameState.selectedIndex);\n    } else if (/^[1-9]$/.test(e.key)) {\n      // number keys 1..3\n      const n = parseInt(e.key, 10);\n      if (n >= 1 && n <= OPTION_COUNT) {\n        attemptAnswer(n - 1);\n      }\n    }\n  }\n\n  canvas.addEventListener('click', (e) => {\n    // Click coordinates relative to canvas\n    const rect = canvas.getBoundingClientRect();\n    const x = (e.clientX - rect.left) * (canvas.width / rect.width);\n    const y = (e.clientY - rect.top) * (canvas.height / rect.height);\n    if (GameState.state === 'playing') {\n      // Check if clicking an option\n      for (let i = 0; i < optionAreas.length; i++) {\n        const a = optionAreas[i];\n        if (x >= a.x && x <= a.x + a.w && y >= a.y && y <= a.y + a.h) {\n          GameState.selectedIndex = i;\n          attemptAnswer(i);\n          return;\n        }\n      }\n      // Check audio icon area click (top-left of lives area)\n      const audRect = getAudioIconRect();\n      if (x >= audRect.x && x <= audRect.x + audRect.w && y >= audRect.y && y <= audRect.y + audRect.h) {\n        audio.toggle();\n        audio.playClick();\n        return;\n      }\n    } else {\n      // if on end screens, clicking anywhere restarts\n      restartGame();\n    }\n  });\n\n  function attemptAnswer(index) {\n    audio.playClick();\n    const chosen = GameState.question.options[index];\n    if (chosen === GameState.question.answer) {\n      GameState.score += 1;\n      audio.playCorrect();\n      ariaLive.textContent = `Correct! Score ${GameState.score} of ${GameState.target}`;\n      // animate drone to chosen option\n      const area = optionAreas[index];\n      if (area) {\n        GameState.droneTargetX = area.x + area.w / 2;\n        GameState.droneTargetY = area.y - 34;\n      }\n      // check victory\n      if (GameState.score >= GameState.target) {\n        GameState.state = 'victory';\n        ariaLive.textContent = `Victory! You collected ${GameState.score} stars. Press R to restart.`;\n      } else {\n        // Small delay before next question\n        setTimeout(() => {\n          nextQuestion();\n        }, 600);\n      }\n    } else {\n      GameState.wrong += 1;\n      audio.playIncorrect();\n      ariaLive.textContent = `Oops! That's not right. Wrong ${GameState.wrong} of ${GameState.maxWrong}`;\n      if (GameState.wrong >= GameState.maxWrong) {\n        GameState.state = 'gameover';\n        ariaLive.textContent = `Game over. You answered ${GameState.score} correctly. Press R to try again.`;\n      } else {\n        // Slight shake animation\n        GameState.animationTime = 0.2;\n      }\n    }\n  }\n\n  function restartGame() {\n    GameState.score = 0;\n    GameState.wrong = 0;\n    GameState.difficulty = 1;\n    GameState.state = 'playing';\n    nextQuestion();\n    GameState.selectedIndex = 0;\n    ariaLive.textContent = 'Game restarted';\n    // re-init audio on restart attempt\n    audio.init().catch(() => {});\n  }\n\n  // Utility: get rect for audio icon area (top-left near lives)\n  function getAudioIconRect() {\n    const w = 28;\n    const h = 20;\n    return { x: LIVES_X - w - 46, y: LIVES_Y, w, h };\n  }\n\n  // Drawing routines\n  function clear() {\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    // Calm background gradient\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, '#e8f6ff');\n    g.addColorStop(1, '#f7fbff');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n  }\n\n  function drawCloud(x, y, scale = 1, offset = 0) {\n    // wacky but calming cloud shape with arcs\n    ctx.save();\n    ctx.translate(x + offset, y);\n    ctx.scale(scale, scale);\n    ctx.fillStyle = '#ffffff';\n    ctx.beginPath();\n    ctx.arc(-30, 0, 20, 0, Math.PI * 2);\n    ctx.arc(0, -6, 26, 0, Math.PI * 2);\n    ctx.arc(30, 0, 22, 0, Math.PI * 2);\n    ctx.rect(-50, 0, 100, 22);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function drawDrone(x, y, wobble = 0, selected = false) {\n    ctx.save();\n    ctx.translate(x, y);\n    // shadow\n    ctx.fillStyle = 'rgba(0,0,0,0.12)';\n    ctx.beginPath();\n    ctx.ellipse(0, 36, 32, 12, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // body\n    ctx.rotate(Math.sin(wobble) * 0.06);\n    ctx.fillStyle = '#90caf9';\n    roundRect(ctx, -28, -18, 56, 28, 6);\n    ctx.fill();\n\n    // window\n    ctx.fillStyle = '#e1f5fe';\n    roundRect(ctx, -12, -10, 24, 18, 5);\n    ctx.fill();\n\n    // propellers - playful\n    ctx.fillStyle = '#4fc3f7';\n    for (let i = -1; i <= 1; i += 2) {\n      ctx.save();\n      ctx.translate(i * 34, -6);\n      ctx.rotate(Math.cos(wobble * 5 + i) * 0.8);\n      ctx.fillStyle = selected ? '#ffcc80' : '#4fc3f7';\n      ctx.beginPath();\n      ctx.ellipse(0, 0, 14, 4, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n    }\n\n    // goofy antenna\n    ctx.fillStyle = '#0288d1';\n    ctx.fillRect(-2, -26, 4, 8);\n    ctx.fillStyle = '#ffab40';\n    ctx.beginPath();\n    ctx.arc(0, -28, 4, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  function roundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n  }\n\n  // Main render loop\n  let lastTime = performance.now();\n  function loop(now) {\n    const dt = Math.min(0.06, (now - lastTime) / 1000);\n    lastTime = now;\n    update(dt);\n    render();\n    requestAnimationFrame(loop);\n  }\n\n  function update(dt) {\n    // animate drone movement toward target\n    const dx = GameState.droneTargetX - GameState.droneX;\n    const dy = GameState.droneTargetY - GameState.droneY;\n    GameState.droneX += dx * Math.min(1, dt * 6);\n    GameState.droneY += dy * Math.min(1, dt * 6);\n    // animationTime decay\n    if (GameState.animationTime > 0) GameState.animationTime = Math.max(0, GameState.animationTime - dt);\n\n    // wobble\n    GameState.wobble = (GameState.wobble || 0) + dt * 3;\n  }\n\n  function render() {\n    clear();\n    // gentle drifting clouds (wacky positions)\n    drawCloud(80 + Math.sin(GameState.wobble) * 8, 60, 1.1, Math.cos(GameState.wobble) * 6);\n    drawCloud(420 - Math.cos(GameState.wobble * 0.7) * 10, 40, 0.9);\n    drawCloud(600 + Math.sin(GameState.wobble * 0.6) * 6, 80, 1.2, -8);\n\n    // floating geometric stars or shapes (calming)\n    for (let i = 0; i < 6; i++) {\n      ctx.save();\n      const xx = 60 + i * 110 + Math.sin(GameState.wobble + i) * 6;\n      const yy = 130 + Math.cos(GameState.wobble * 0.8 + i) * 6;\n      ctx.globalAlpha = 0.9;\n      ctx.fillStyle = ['#ffd54f', '#b39ddb', '#a5d6a7', '#ffab91'][i % 4];\n      ctx.beginPath();\n      ctx.moveTo(xx, yy - 8);\n      ctx.lineTo(xx + 6, yy);\n      ctx.lineTo(xx, yy + 8);\n      ctx.lineTo(xx - 6, yy);\n      ctx.closePath();\n      ctx.fill();\n      ctx.restore();\n    }\n\n    // Draw drone\n    const wobbleAmount = GameState.animationTime > 0 ? 0.8 : GameState.wobble;\n    const isSelected = false;\n    drawDrone(GameState.droneX, GameState.droneY, wobbleAmount, isSelected);\n\n    // Draw UI: score top-left with background rectangle\n    ctx.font = IMPORTANT_FONT;\n    ctx.textBaseline = 'top';\n    const scoreText = `Stars: ${GameState.score} / ${GameState.target}`;\n    const scoreMetrics = ctx.measureText(scoreText);\n    const scoreW = scoreMetrics.width + 2 * PADDING;\n    const scoreH = 34;\n    ctx.fillStyle = 'rgba(255,255,255,0.9)';\n    roundRect(ctx, SCORE_X, SCORE_Y, scoreW, scoreH, 8);\n    ctx.fillStyle = '#1565c0';\n    roundRect(ctx, SCORE_X + 2, SCORE_Y + 2, scoreW - 4, scoreH - 4, 6);\n    ctx.fill();\n    ctx.fillStyle = '#fff';\n    ctx.fillText(scoreText, SCORE_X + PADDING, SCORE_Y + 8);\n\n    // Lives top-right\n    ctx.font = IMPORTANT_FONT;\n    const livesText = `Fails left: ${Math.max(0, GameState.maxWrong - GameState.wrong)}`;\n    const livesMetrics = ctx.measureText(livesText);\n    const livesW = livesMetrics.width + 2 * PADDING + 44; // space for audio icon\n    const livesH = 34;\n    const livesX = LIVES_X - livesW;\n    ctx.fillStyle = 'rgba(255,255,255,0.9)';\n    roundRect(ctx, livesX, LIVES_Y, livesW, livesH, 8);\n    ctx.fillStyle = '#f48fb1';\n    roundRect(ctx, livesX + 2, LIVES_Y + 2, livesW - 4, livesH - 4, 6);\n    ctx.fill();\n    ctx.fillStyle = '#fff';\n    ctx.fillText(livesText, livesX + PADDING, LIVES_Y + 8);\n\n    // Audio icon and status\n    const audRect = getAudioIconRect();\n    ctx.fillStyle = audio.enabled ? '#fff' : '#fff';\n    // small background\n    ctx.fillStyle = 'rgba(255,255,255,0.06)';\n    ctx.fillRect(audRect.x, audRect.y, audRect.w, audRect.h);\n    ctx.strokeStyle = '#fff';\n    ctx.lineWidth = 1;\n    // draw speaker icon\n    ctx.beginPath();\n    ctx.moveTo(audRect.x + 3, audRect.y + 5);\n    ctx.lineTo(audRect.x + 9, audRect.y + 5);\n    ctx.lineTo(audRect.x + 13, audRect.y + 2);\n    ctx.lineTo(audRect.x + 13, audRect.y + 18);\n    ctx.lineTo(audRect.x + 9, audRect.y + 15);\n    ctx.lineTo(audRect.x + 3, audRect.y + 15);\n    ctx.closePath();\n    ctx.fillStyle = audio.enabled ? '#fff' : '#aaa';\n    ctx.fill();\n    if (!audio.enabled) {\n      ctx.strokeStyle = '#ff8a80';\n      ctx.beginPath();\n      ctx.moveTo(audRect.x + 2, audRect.y + 2);\n      ctx.lineTo(audRect.x + audRect.w - 2, audRect.y + audRect.h - 2);\n      ctx.stroke();\n    }\n\n    // Draw the question area centrally\n    ctx.font = TITLE_FONT;\n    ctx.textBaseline = 'top';\n    const qText = `What is ${GameState.question.text}?`;\n    const qMetrics = ctx.measureText(qText);\n    const qW = Math.min(WIDTH - 2 * PADDING, qMetrics.width + 2 * PADDING);\n    const qX = (WIDTH - qW) / 2;\n    const qY = 170;\n    ctx.fillStyle = 'rgba(255,255,255,0.95)';\n    roundRect(ctx, qX, qY, qW, 52, 10);\n    ctx.fillStyle = '#0277bd';\n    roundRect(ctx, qX + 2, qY + 2, qW - 4, 48, 8);\n    ctx.fill();\n    ctx.fillStyle = '#fff';\n    ctx.font = IMPORTANT_FONT;\n    // ensure text doesn't overflow: measure and if too wide reduce font\n    let fontToUse = IMPORTANT_FONT;\n    ctx.font = fontToUse;\n    let textWidth = ctx.measureText(qText).width;\n    if (textWidth > qW - 2 * PADDING) {\n      fontToUse = '18px \"Segoe UI\", Roboto, Arial';\n      ctx.font = fontToUse;\n      textWidth = ctx.measureText(qText).width;\n    }\n    ctx.fillText(qText, qX + PADDING, qY + 12);\n\n    // Draw options below, spaced and measured to avoid overlap\n    const optionY = qY + 72;\n    const areaPadding = 12;\n    optionAreas = [];\n    // compute equal widths but also use measureText to ensure enough\n    ctx.font = BODY_FONT;\n    let widths = GameState.question.options.map(opt => ctx.measureText(String(opt)).width + 2 * areaPadding + 40);\n    // minimum width and spacing\n    const totalMinWidth = widths.reduce((a, b) => a + b, 0);\n    const gap = Math.max(12, Math.floor((WIDTH - 2 * PADDING - totalMinWidth) / (OPTION_COUNT + 1)));\n    let curX = PADDING + gap;\n    for (let i = 0; i < GameState.question.options.length; i++) {\n      const opt = GameState.question.options[i];\n      const w = widths[i];\n      const h = 52;\n      // draw background\n      const selected = (GameState.selectedIndex === i);\n      ctx.fillStyle = selected ? 'rgba(255, 243, 224, 0.95)' : 'rgba(255,255,255,0.95)';\n      roundRect(ctx, curX, optionY, w, h, 8);\n      ctx.fillStyle = selected ? '#ff8f00' : '#607d8b';\n      roundRect(ctx, curX + 2, optionY + 2, w - 4, h - 4, 6);\n      ctx.fill();\n      // number label\n      ctx.fillStyle = '#fff';\n      ctx.font = 'bold 16px Arial';\n      ctx.fillText(`${i + 1}.`, curX + 12, optionY + 14);\n      ctx.font = BODY_FONT;\n      ctx.fillText(String(opt), curX + 44, optionY + 14);\n\n      optionAreas.push({ x: curX, y: optionY, w, h, index: i });\n      curX += w + gap;\n    }\n\n    // Instructions bottom-center\n    ctx.font = BODY_FONT;\n    ctx.textBaseline = 'top';\n    const instructions = 'Use arrow keys or 1-3 to choose. Press Enter to confirm. Press M to toggle sound. Press R to restart.';\n    const maxWidth = WIDTH - 2 * PADDING;\n    // split instructions into two lines if too wide\n    ctx.font = BODY_FONT;\n    const instrWidth = ctx.measureText(instructions).width;\n    let instrLines = [];\n    if (instrWidth > maxWidth) {\n      // naive split near middle space\n      const words = instructions.split(' ');\n      let line = '';\n      for (let w of words) {\n        const trial = line ? (line + ' ' + w) : w;\n        if (ctx.measureText(trial).width > maxWidth && line) {\n          instrLines.push(line);\n          line = w;\n        } else {\n          line = trial;\n        }\n      }\n      if (line) instrLines.push(line);\n    } else {\n      instrLines = [instructions];\n    }\n    // draw background rectangle\n    const instrH = instrLines.length * 20 + 12;\n    const instrW = maxWidth;\n    const instrX = (WIDTH - instrW) / 2;\n    const instrY = INSTRUCTIONS_Y;\n    ctx.fillStyle = 'rgba(255,255,255,0.9)';\n    roundRect(ctx, instrX, instrY, instrW, instrH, 10);\n    ctx.fillStyle = '#455a64';\n    roundRect(ctx, instrX + 2, instrY + 2, instrW - 4, instrH - 4, 8);\n    ctx.fill();\n    ctx.fillStyle = '#fff';\n    for (let i = 0; i < instrLines.length; i++) {\n      ctx.fillText(instrLines[i], instrX + PADDING, instrY + 8 + i * 20);\n    }\n\n    // If the game is won or over, overlay victory/gameover screens\n    if (GameState.state === 'victory') {\n      drawEndScreen(true);\n    } else if (GameState.state === 'gameover') {\n      drawEndScreen(false);\n    }\n\n    // draw small help for audio availability if audio failed\n    if (!audio.isAvailable()) {\n      ctx.font = '14px Arial';\n      const warn = 'Audio unavailable. Press M to toggle (visual only).';\n      const m = ctx.measureText(warn).width;\n      ctx.fillStyle = 'rgba(255,255,255,0.9)';\n      roundRect(ctx, WIDTH - m - 2 * PADDING - 8, HEIGHT - 34, m + 2 * PADDING + 8, 30, 6);\n      ctx.fillStyle = '#6d4c41';\n      roundRect(ctx, WIDTH - m - 2 * PADDING - 6, HEIGHT - 32, m + 2 * PADDING + 4, 26, 5);\n      ctx.fill();\n      ctx.fillStyle = '#fff';\n      ctx.fillText(warn, WIDTH - m - PADDING - 4, HEIGHT - 28);\n    }\n  }\n\n  function drawEndScreen(victory) {\n    // overlay a translucent panel\n    ctx.fillStyle = 'rgba(5, 20, 40, 0.65)';\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // main box\n    const boxW = WIDTH - 120;\n    const boxH = 220;\n    const boxX = 60;\n    const boxY = (HEIGHT - boxH) / 2;\n    ctx.fillStyle = 'rgba(255,255,255,0.95)';\n    roundRect(ctx, boxX, boxY, boxW, boxH, 12);\n    ctx.fillStyle = victory ? '#2e7d32' : '#b71c1c';\n    roundRect(ctx, boxX + 4, boxY + 4, boxW - 8, boxH - 8, 10);\n    ctx.fill();\n\n    ctx.fillStyle = '#fff';\n    ctx.font = '28px \"Segoe UI\", Roboto, Arial';\n    const title = victory ? 'You did it! Drone delivered the stars!' : 'Oh no! The drone ran out of battery!';\n    const titleWidth = ctx.measureText(title).width;\n    ctx.fillText(title, boxX + (boxW - titleWidth) / 2, boxY + 26);\n\n    ctx.font = '18px \"Segoe UI\", Roboto, Arial';\n    const sub = victory ? `You collected ${GameState.score} stars!` : `You collected ${GameState.score} stars.`;\n    const subWidth = ctx.measureText(sub).width;\n    ctx.fillText(sub, boxX + (boxW - subWidth) / 2, boxY + 70);\n\n    ctx.font = '16px Arial';\n    const instr = 'Click anywhere or press R to restart.';\n    const instrW = ctx.measureText(instr).width;\n    ctx.fillText(instr, boxX + (boxW - instrW) / 2, boxY + boxH - 46);\n\n    // friendly drone drawing on the end screen\n    drawDrone(boxX + 100, boxY + 130, GameState.wobble, true);\n  }\n\n  // Start the loop\n  requestAnimationFrame(loop);\n\n  // Ensure focus for keyboard controls\n  canvas.focus();\n\n  // Error handling for audio context on user gesture failure\n  // Try to initialize audio on first pointerdown as well (some browsers require gesture)\n  function tryInitAudioOnGesture() {\n    audio.init().then(() => {\n      // resume if suspended\n      try { if (audio.context && audio.context.state === 'suspended') audio.context.resume(); }\n      catch (e) { /* ignore */ }\n    }).catch(() => {});\n    window.removeEventListener('pointerdown', tryInitAudioOnGesture);\n    window.removeEventListener('keydown', tryInitAudioOnGesture);\n  }\n  window.addEventListener('pointerdown', tryInitAudioOnGesture);\n  window.addEventListener('keydown', tryInitAudioOnGesture);\n})();\n---\n",
  "improve_response_tokens": 20239,
  "formatted_code": true,
  "formatting_response_tokens": 22801,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}