{
  "generated_date": "2025-10-29",
  "generated_timestamp": "2025-10-29T00:28:15.466733",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8589,
  "game_filename": "2025-10-29.js",
  "game_size_bytes": 24949,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Drone Math Adventure\n  // Renders game inside element with ID 'game-of-the-day-stage'\n  // Only canvas and Web Audio API used. No external assets.\n\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const PADDING = 12; // minimum spacing for UI elements\n  const TARGET_CORRECT = 10; // win condition\n  const MAX_WRONG = 3; // lose condition\n  const BG_COLOR = '#eaf3ff'; // calming sky-blue\n  const DRONE_COLOR = '#7aa2ff';\n  const DRONE_ACCENT = '#ffd166';\n  const BUTTON_COLOR = '#ffffff';\n  const BUTTON_BORDER = '#4d6fa9';\n  const TEXT_COLOR = '#0b2d4a';\n  const FONT_BODY = '16px \"Segoe UI\", Roboto, Arial, sans-serif';\n  const FONT_BIG = '22px \"Segoe UI\", Roboto, Arial, sans-serif';\n  const FONT_TITLE = '28px \"Segoe UI\", Roboto, Arial, sans-serif';\n  const BUTTON_PADDING = 10;\n\n  // State\n  let container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Container with id \"game-of-the-day-stage\" not found.');\n    return;\n  }\n\n  // Clear container\n  container.innerHTML = '';\n  container.style.position = 'relative';\n  container.style.width = WIDTH + 'px';\n  container.style.height = HEIGHT + 'px';\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute('role', 'img');\n  canvas.setAttribute('aria-label', 'Drone Math Adventure for ages 7 to 9. Use number keys or click to answer. Press M to mute, R to restart.');\n  canvas.style.display = 'block';\n  canvas.style.outline = 'none';\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Accessibility: hidden description element for screen readers\n  const desc = document.createElement('div');\n  desc.style.position = 'absolute';\n  desc.style.left = '-9999px';\n  desc.style.top = '-9999px';\n  desc.setAttribute('aria-hidden', 'false');\n  desc.textContent = 'Drone Math Adventure. Answer 10 math questions correctly to win. Three wrong answers ends the game. Controls: number keys 1-3 to choose answers, Enter to confirm, arrow keys to navigate choices, M to mute, R to restart.';\n  container.appendChild(desc);\n\n  // Audio setup with error handling\n  let audioCtx = null;\n  let bgOsc = null;\n  let bgGain = null;\n  let soundOn = true;\n  function tryCreateAudioContext() {\n    if (audioCtx) return;\n    try {\n      const AC = window.AudioContext || window.webkitAudioContext;\n      audioCtx = new AC();\n      // create gentle background hum (but do not start until user gesture)\n      bgOsc = audioCtx.createOscillator();\n      bgOsc.type = 'sine';\n      bgOsc.frequency.value = 120; // low humming\n      bgGain = audioCtx.createGain();\n      bgGain.gain.value = 0.02;\n      const filter = audioCtx.createBiquadFilter();\n      filter.type = 'lowpass';\n      filter.frequency.value = 800;\n      bgOsc.connect(filter);\n      filter.connect(bgGain);\n      bgGain.connect(audioCtx.destination);\n      // don't start automatically; will start/resume on user gesture\n    } catch (e) {\n      console.warn('AudioContext unavailable:', e);\n      audioCtx = null;\n      soundOn = false;\n    }\n  }\n\n  // Sound primitives\n  function playTone(freq, duration = 0.2, type = 'sine', volume = 0.08) {\n    if (!audioCtx || !soundOn) return;\n    try {\n      const osc = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n      osc.type = type;\n      osc.frequency.value = freq;\n      gain.gain.value = volume;\n      osc.connect(gain);\n      gain.connect(audioCtx.destination);\n      const t = audioCtx.currentTime;\n      gain.gain.setValueAtTime(volume, t);\n      gain.gain.exponentialRampToValueAtTime(0.0001, t + duration);\n      osc.start(t);\n      osc.stop(t + duration + 0.01);\n    } catch (e) {\n      console.warn('playTone error', e);\n    }\n  }\n  function playCorrect() {\n    playTone(880, 0.12, 'triangle', 0.08);\n    setTimeout(() => playTone(1320, 0.08, 'sine', 0.06), 120);\n  }\n  function playWrong() {\n    playTone(220, 0.25, 'sawtooth', 0.12);\n  }\n  function startBackground() {\n    if (!audioCtx || !soundOn || !bgOsc) return;\n    try {\n      // If suspended, resume\n      if (audioCtx.state === 'suspended') {\n        audioCtx.resume().catch((e) => console.warn('Audio resume failed', e));\n      }\n      // Start oscillator if not already started\n      try {\n        bgOsc.start();\n      } catch (e) {\n        // already started\n      }\n      // Fade in gently\n      bgGain.gain.cancelScheduledValues(audioCtx.currentTime);\n      bgGain.gain.setValueAtTime(0.0001, audioCtx.currentTime);\n      bgGain.gain.linearRampToValueAtTime(0.02, audioCtx.currentTime + 1.0);\n    } catch (e) {\n      console.warn('startBackground error', e);\n    }\n  }\n  function stopBackground() {\n    if (!audioCtx || !bgGain) return;\n    try {\n      bgGain.gain.cancelScheduledValues(audioCtx.currentTime);\n      bgGain.gain.linearRampToValueAtTime(0.0001, audioCtx.currentTime + 0.6);\n    } catch (e) {\n      console.warn('stopBackground error', e);\n    }\n  }\n\n  // Game variables\n  let correctCount = 0;\n  let wrongCount = 0;\n  let currentQuestion = null;\n  let choices = [];\n  let selectedIndex = 0;\n  let gameState = 'playing'; // 'playing', 'won', 'lost', 'start' (start for first time)\n  let shakeTimer = 0;\n  let animationTick = 0;\n  let awaitingFirstGesture = true; // audio policy: wait for gesture\n  let lastActionMsg = ''; // for screen reader / small log\n\n  // Utility functions\n  function randInt(a, b) {\n    return Math.floor(Math.random() * (b - a + 1)) + a;\n  }\n\n  function generateQuestion() {\n    // For ages 7-9: addition/subtraction, simple multiplication maybe\n    const typeRoll = Math.random();\n    let a, b, op, answer, text;\n    if (typeRoll < 0.5) {\n      // addition\n      a = randInt(1, 20);\n      b = randInt(1, 20);\n      op = '+';\n      answer = a + b;\n      text = `${a} + ${b} = ?`;\n    } else if (typeRoll < 0.85) {\n      // subtraction ensuring positive\n      a = randInt(5, 25);\n      b = randInt(1, a - 1);\n      op = '\u2212';\n      answer = a - b;\n      text = `${a} \u2212 ${b} = ?`;\n    } else {\n      // simple multiplication up to 5x7\n      a = randInt(2, 7);\n      b = randInt(2, 6);\n      op = '\u00d7';\n      answer = a * b;\n      text = `${a} \u00d7 ${b} = ?`;\n    }\n\n    // generate 3 choices including answer, within reasonable distractors\n    const opts = new Set();\n    opts.add(answer);\n    while (opts.size < 3) {\n      let delta = randInt(1, Math.max(3, Math.floor(answer * 0.5) + 1));\n      if (Math.random() < 0.5) delta = -delta;\n      const candidate = answer + delta;\n      if (candidate >= 0 && !opts.has(candidate)) opts.add(candidate);\n    }\n    const optArray = Array.from(opts);\n    // shuffle\n    for (let i = optArray.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [optArray[i], optArray[j]] = [optArray[j], optArray[i]];\n    }\n    return { text, answer, choices: optArray };\n  }\n\n  function startNewQuestion() {\n    const q = generateQuestion();\n    currentQuestion = q.text;\n    choices = q.choices;\n    correctAnswer = q.answer;\n    selectedIndex = 0;\n  }\n\n  // Initialize first question\n  startNewQuestion();\n\n  // Input handling\n  function ensureAudioOnUserGesture() {\n    if (!awaitingFirstGesture) return;\n    tryCreateAudioContext();\n    if (audioCtx) {\n      // start or resume background\n      if (audioCtx.state === 'suspended') {\n        audioCtx.resume().catch((e) => console.warn('Audio resume failed', e));\n      }\n      startBackground();\n    }\n    awaitingFirstGesture = false;\n  }\n\n  canvas.tabIndex = 0;\n  canvas.addEventListener('keydown', (e) => {\n    // ensure audio created on gesture\n    if (awaitingFirstGesture) ensureAudioOnUserGesture();\n    if (gameState === 'won' || gameState === 'lost') {\n      if (e.key.toLowerCase() === 'r') {\n        restartGame();\n      }\n      return;\n    }\n    if (e.key === 'ArrowLeft') {\n      selectedIndex = (selectedIndex + choices.length - 1) % choices.length;\n      lastActionMsg = `Selected choice ${selectedIndex + 1}`;\n    } else if (e.key === 'ArrowRight') {\n      selectedIndex = (selectedIndex + 1) % choices.length;\n      lastActionMsg = `Selected choice ${selectedIndex + 1}`;\n    } else if (e.key === 'Enter') {\n      submitAnswer(selectedIndex);\n    } else if (['1', '2', '3'].includes(e.key)) {\n      const idx = parseInt(e.key, 10) - 1;\n      if (idx >= 0 && idx < choices.length) {\n        selectedIndex = idx;\n        submitAnswer(idx);\n      }\n    } else if (e.key.toLowerCase() === 'm') {\n      toggleSound();\n    } else if (e.key.toLowerCase() === 'r') {\n      restartGame();\n    }\n  });\n\n  // Mouse/touch interactions - clickable buttons drawn on canvas\n  canvas.addEventListener('mousedown', (e) => {\n    if (awaitingFirstGesture) ensureAudioOnUserGesture();\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    if (gameState === 'won' || gameState === 'lost') {\n      // Check restart button area\n      const restartRect = getRestartButtonRect();\n      if (pointInRect(x, y, restartRect)) {\n        restartGame();\n        return;\n      }\n      return;\n    }\n\n    // Check sound toggle area\n    const speakerRect = getSpeakerRect();\n    if (pointInRect(x, y, speakerRect)) {\n      toggleSound();\n      return;\n    }\n\n    // Check choice buttons\n    const btnRects = getChoiceButtonRects();\n    for (let i = 0; i < btnRects.length; i++) {\n      if (pointInRect(x, y, btnRects[i])) {\n        selectedIndex = i;\n        submitAnswer(i);\n        return;\n      }\n    }\n  });\n\n  // Helpers for rects\n  function pointInRect(px, py, r) {\n    return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;\n  }\n\n  function getSpeakerRect() {\n    const size = 34;\n    return { x: WIDTH - PADDING - size, y: PADDING, w: size, h: size };\n  }\n\n  function getScoreRect() {\n    // top-left\n    return { x: PADDING, y: PADDING, w: 200, h: 38 };\n  }\n  function getLivesRect() {\n    return { x: WIDTH - PADDING - 160, y: PADDING, w: 160, h: 38 };\n  }\n  function getQuestionRect() {\n    // center top-ish\n    const w = WIDTH - 2 * PADDING - 160;\n    return { x: (WIDTH - w) / 2, y: 70, w, h: 70 };\n  }\n  function getChoiceButtonRects() {\n    const btnW = (WIDTH - PADDING * 2 - 40) / 3;\n    const btnH = 60;\n    const y = 270;\n    const rects = [];\n    for (let i = 0; i < 3; i++) {\n      rects.push({ x: PADDING + i * (btnW + 20), y, w: btnW, h: btnH });\n    }\n    return rects;\n  }\n  function getInstructionsRect() {\n    const h = 60;\n    return { x: PADDING, y: HEIGHT - PADDING - h, w: WIDTH - 2 * PADDING, h };\n  }\n  function getRestartButtonRect() {\n    const w = 180;\n    const h = 48;\n    return { x: (WIDTH - w) / 2, y: HEIGHT / 2 + 60, w, h };\n  }\n\n  // Submission logic\n  let correctAnswer = null;\n  function submitAnswer(idx) {\n    if (gameState !== 'playing') return;\n    if (idx < 0 || idx >= choices.length) return;\n    const chosen = choices[idx];\n    if (chosen === correctAnswer) {\n      correctCount++;\n      lastActionMsg = `Correct! ${chosen}`;\n      playCorrect();\n      // small celebration\n      shakeTimer = 12;\n      if (correctCount >= TARGET_CORRECT) {\n        gameState = 'won';\n        stopBackground();\n      } else {\n        startNewQuestion();\n      }\n    } else {\n      wrongCount++;\n      lastActionMsg = `Wrong. You picked ${chosen}`;\n      playWrong();\n      shakeTimer = 18;\n      if (wrongCount >= MAX_WRONG) {\n        gameState = 'lost';\n        stopBackground();\n      } else {\n        // make a new question but keep challenge increasing slightly\n        startNewQuestion();\n      }\n    }\n  }\n\n  function restartGame() {\n    correctCount = 0;\n    wrongCount = 0;\n    startNewQuestion();\n    gameState = 'playing';\n    shakeTimer = 0;\n    awaitingFirstGesture = true;\n    lastActionMsg = 'Game restarted';\n    try {\n      if (audioCtx && audioCtx.state === 'running' && soundOn) {\n        startBackground();\n      }\n    } catch (e) {\n      console.warn(e);\n    }\n  }\n\n  function toggleSound() {\n    tryCreateAudioContext();\n    soundOn = !soundOn;\n    if (soundOn) {\n      startBackground();\n    } else {\n      stopBackground();\n    }\n  }\n\n  // Drawing functions with layout constraints and measureText usage\n  function clearScreen() {\n    ctx.fillStyle = BG_COLOR;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n  }\n\n  function drawRoundedRect(x, y, w, h, r = 8, fill = true, stroke = true) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  function drawUI() {\n    // Score top-left\n    ctx.font = FONT_BODY;\n    ctx.textBaseline = 'middle';\n    ctx.fillStyle = '#ffffff';\n    ctx.strokeStyle = '#cfe4ff';\n    ctx.lineWidth = 2;\n    const scoreRect = getScoreRect();\n    // Compute dynamic width based on text\n    const scoreText = `Score: ${correctCount}/${TARGET_CORRECT}`;\n    ctx.font = FONT_BIG;\n    const scoreW = Math.max(scoreRect.w, ctx.measureText(scoreText).width + 2 * PADDING);\n    const sr = { x: scoreRect.x, y: scoreRect.y, w: scoreW, h: scoreRect.h };\n    ctx.fillStyle = '#ffffff';\n    ctx.strokeStyle = '#b8d4ff';\n    ctx.lineWidth = 2;\n    ctx.fillStyle = '#ffffff';\n    drawRoundedRect(sr.x, sr.y, sr.w, sr.h, 8, true, true);\n    ctx.fillStyle = TEXT_COLOR;\n    ctx.font = FONT_BIG;\n    ctx.fillText(scoreText, sr.x + PADDING, sr.y + sr.h / 2);\n\n    // Lives top-right\n    const livesRect = getLivesRect();\n    const livesText = `Lives: ${Math.max(0, MAX_WRONG - wrongCount)} / ${MAX_WRONG}`;\n    ctx.font = FONT_BIG;\n    const lw = Math.max(livesRect.w, ctx.measureText(livesText).width + 2 * PADDING);\n    const lr = { x: WIDTH - PADDING - lw, y: livesRect.y, w: lw, h: livesRect.h };\n    ctx.fillStyle = '#ffffff';\n    ctx.strokeStyle = '#ffd6a5';\n    ctx.lineWidth = 2;\n    drawRoundedRect(lr.x, lr.y, lr.w, lr.h, 8, true, true);\n    ctx.fillStyle = TEXT_COLOR;\n    ctx.fillText(livesText, lr.x + PADDING, lr.y + lr.h / 2);\n\n    // Speaker icon (sound toggle) top-right corner above lives area\n    const sp = getSpeakerRect();\n    ctx.fillStyle = '#ffffff';\n    ctx.strokeStyle = '#cfe4ff';\n    ctx.lineWidth = 2;\n    drawRoundedRect(sp.x, sp.y, sp.w, sp.h, 6, true, true);\n    // Draw speaker glyph\n    ctx.fillStyle = TEXT_COLOR;\n    const centerX = sp.x + sp.w * 0.35;\n    const centerY = sp.y + sp.h / 2;\n    // speaker box\n    ctx.fillRect(centerX - 6, centerY - 8, 12, 16);\n    // speaker cone\n    ctx.beginPath();\n    ctx.moveTo(centerX + 6, centerY - 10);\n    ctx.lineTo(centerX + 18, centerY);\n    ctx.lineTo(centerX + 6, centerY + 10);\n    ctx.closePath();\n    ctx.fill();\n    // sound bars if on\n    if (soundOn) {\n      ctx.strokeStyle = '#2b6cb0';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(sp.x + sp.w - 10, sp.y + sp.h / 2 - 10);\n      ctx.lineTo(sp.x + sp.w - 4, sp.y + sp.h / 2 - 4);\n      ctx.moveTo(sp.x + sp.w - 10, sp.y + sp.h / 2 + 0);\n      ctx.lineTo(sp.x + sp.w - 4, sp.y + sp.h / 2 + 6);\n      ctx.stroke();\n    } else {\n      // draw muted X\n      ctx.strokeStyle = '#a0a0a0';\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(sp.x + 6, sp.y + 6);\n      ctx.lineTo(sp.x + sp.w - 6, sp.y + sp.h - 6);\n      ctx.moveTo(sp.x + sp.w - 6, sp.y + 6);\n      ctx.lineTo(sp.x + 6, sp.y + sp.h - 6);\n      ctx.stroke();\n    }\n\n    // Question box center\n    const qRect = getQuestionRect();\n    ctx.fillStyle = '#ffffff';\n    ctx.strokeStyle = '#cfe4ff';\n    ctx.lineWidth = 2;\n    drawRoundedRect(qRect.x, qRect.y, qRect.w, qRect.h, 10, true, true);\n    ctx.fillStyle = TEXT_COLOR;\n    ctx.font = FONT_TITLE;\n\n    // Word-wrap question if necessary: use ctx.measureText\n    const qText = currentQuestion || '';\n    let maxWidth = qRect.w - 2 * PADDING;\n    // since question is short, single line likely fine\n    const qWidth = ctx.measureText(qText).width;\n    if (qWidth <= maxWidth) {\n      ctx.fillText(qText, qRect.x + (qRect.w - qWidth) / 2, qRect.y + qRect.h / 2 + 4);\n    } else {\n      // wrap into two lines\n      const words = qText.split(' ');\n      let line = '';\n      let lines = [];\n      for (let w of words) {\n        const test = line ? line + ' ' + w : w;\n        if (ctx.measureText(test).width <= maxWidth) {\n          line = test;\n        } else {\n          lines.push(line);\n          line = w;\n        }\n      }\n      if (line) lines.push(line);\n      const lineHeight = 28;\n      const startY = qRect.y + (qRect.h - lines.length * lineHeight) / 2;\n      for (let i = 0; i < lines.length; i++) {\n        ctx.fillText(lines[i], qRect.x + (qRect.w - ctx.measureText(lines[i]).width) / 2, startY + i * lineHeight + 20);\n      }\n    }\n\n    // Draw drone graphic (wacky) left of question box center\n    drawDrone(qRect.x - 140, qRect.y - 10, 120, 80);\n\n    // Choice buttons\n    const btnRects = getChoiceButtonRects();\n    ctx.font = FONT_BODY;\n    ctx.textBaseline = 'middle';\n    for (let i = 0; i < btnRects.length; i++) {\n      const r = btnRects[i];\n      // background\n      ctx.fillStyle = BUTTON_COLOR;\n      ctx.strokeStyle = BUTTON_BORDER;\n      ctx.lineWidth = selectedIndex === i ? 4 : 2;\n      drawRoundedRect(r.x, r.y, r.w, r.h, 10, true, true);\n      // label number (1/2/3)\n      ctx.fillStyle = '#6b87b2';\n      ctx.font = '18px \"Segoe UI\", Roboto, Arial, sans-serif';\n      const prefix = `${i + 1}. `;\n      ctx.fillText(prefix, r.x + BUTTON_PADDING, r.y + r.h / 2);\n      // value\n      ctx.fillStyle = TEXT_COLOR;\n      ctx.font = FONT_BIG;\n      const valueText = String(choices[i]);\n      const valueWidth = ctx.measureText(valueText).width;\n      // ensure no overlap between prefix and value: position value centered relative to button\n      const valueX = r.x + (r.w - valueWidth) / 2 + 6;\n      ctx.fillText(valueText, valueX, r.y + r.h / 2);\n      // small visual cue for selected\n      if (selectedIndex === i) {\n        ctx.strokeStyle = '#ffd166';\n        ctx.lineWidth = 3;\n        ctx.strokeRect(r.x + 6, r.y + 6, r.w - 12, r.h - 12);\n      }\n    }\n\n    // Instructions bottom-center\n    const instrRect = getInstructionsRect();\n    ctx.fillStyle = '#ffffff';\n    ctx.strokeStyle = '#cfe4ff';\n    ctx.lineWidth = 2;\n    drawRoundedRect(instrRect.x, instrRect.y, instrRect.w, instrRect.h, 8, true, true);\n    ctx.fillStyle = TEXT_COLOR;\n    ctx.font = FONT_BODY;\n    ctx.textBaseline = 'top';\n    const instr = 'Controls: Click a choice or press 1-3. Use \u2190 \u2192 to change selection. Enter to submit. M to toggle sound. R to restart.';\n    // wrap instructions text across two lines if needed\n    const maxInstrW = instrRect.w - 2 * PADDING;\n    const instrWords = instr.split(' ');\n    let lines = [];\n    let cur = '';\n    for (let w of instrWords) {\n      const test = cur ? cur + ' ' + w : w;\n      if (ctx.measureText(test).width <= maxInstrW) {\n        cur = test;\n      } else {\n        lines.push(cur);\n        cur = w;\n      }\n    }\n    if (cur) lines.push(cur);\n    // ensure spacing >=10px between bottom elements\n    for (let i = 0; i < lines.length; i++) {\n      ctx.fillText(lines[i], instrRect.x + PADDING, instrRect.y + PADDING + i * 20);\n    }\n\n    // tiny lastAction message for SR and feedback\n    ctx.font = '14px \"Segoe UI\", Roboto, Arial, sans-serif';\n    ctx.fillStyle = '#4a4a4a';\n    const msg = lastActionMsg || '';\n    ctx.fillText(msg, instrRect.x + PADDING, instrRect.y + PADDING + lines.length * 20 + 4);\n  }\n\n  function drawDrone(x, y, w, h) {\n    // Wacky calming drone drawn with canvas primitives\n    const cx = x + w / 2;\n    const cy = y + h / 2;\n    // body\n    ctx.save();\n    ctx.translate(cx, cy);\n    if (shakeTimer > 0) {\n      const shakeOffset = Math.sin(animationTick / 3) * 4;\n      ctx.translate(shakeOffset, 0);\n    }\n    ctx.fillStyle = DRONE_COLOR;\n    ctx.strokeStyle = '#33588a';\n    ctx.lineWidth = 3;\n    // main oval body\n    ctx.beginPath();\n    ctx.ellipse(0, 0, w * 0.45, h * 0.38, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n    // face (windows)\n    ctx.fillStyle = '#ffffff';\n    ctx.beginPath();\n    ctx.ellipse(-w * 0.12, -4, w * 0.13, h * 0.12, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.ellipse(w * 0.18, -2, w * 0.09, h * 0.09, 0, 0, Math.PI * 2);\n    ctx.fill();\n    // accent stripe\n    ctx.fillStyle = DRONE_ACCENT;\n    ctx.fillRect(-w * 0.45, h * 0.12, w * 0.9, h * 0.12);\n    // propellers: three small circles connected with arcs (wacky)\n    const pr = Math.min(w, h) * 0.12;\n    const armLen = w * 0.65;\n    for (let i = 0; i < 3; i++) {\n      const angle = (i / 3) * Math.PI * 2 - Math.PI / 6;\n      const ax = Math.cos(angle) * armLen / 2;\n      const ay = Math.sin(angle) * armLen / 2 - 8;\n      // arm\n      ctx.strokeStyle = '#2a5578';\n      ctx.lineWidth = 4;\n      ctx.beginPath();\n      ctx.moveTo(0, 0);\n      ctx.lineTo(ax, ay);\n      ctx.stroke();\n      // propeller disc\n      ctx.fillStyle = '#ffffff';\n      ctx.beginPath();\n      ctx.arc(ax, ay, pr, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n      // little blades - rotated animation\n      ctx.save();\n      ctx.translate(ax, ay);\n      ctx.rotate(animationTick / 10 + i);\n      ctx.fillStyle = '#a7c2e8';\n      for (let b = 0; b < 3; b++) {\n        ctx.beginPath();\n        ctx.ellipse(0, -pr * 0.4 - b * 2, pr * 0.25, pr * 0.6, (Math.PI / 6) * b, 0, Math.PI * 2);\n        ctx.fill();\n      }\n      ctx.restore();\n    }\n    // tiny smiley\n    ctx.fillStyle = '#2a3b4d';\n    ctx.beginPath();\n    ctx.arc(-w * 0.12, -2, 2.6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(w * 0.18, 0, 1.8, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.strokeStyle = '#2a3b4d';\n    ctx.lineWidth = 1.5;\n    ctx.arc(0, h * 0.02, 8, 0.1 * Math.PI, 0.9 * Math.PI);\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  // End screens\n  function drawEndScreen() {\n    // overlay\n    ctx.fillStyle = 'rgba(5,10,20,0.5)';\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.font = FONT_TITLE;\n    ctx.fillStyle = '#ffffff';\n    ctx.textBaseline = 'middle';\n\n    let title = '';\n    if (gameState === 'won') {\n      title = 'Victory! Drone Fleet Celebrates!';\n    } else if (gameState === 'lost') {\n      title = 'Game Over. Grounded for now.';\n    } else {\n      title = 'Time';\n    }\n    const titleW = ctx.measureText(title).width;\n    ctx.fillText(title, (WIDTH - titleW) / 2, HEIGHT / 2 - 40);\n\n    ctx.font = FONT_BIG;\n    let message = '';\n    if (gameState === 'won') {\n      message = `You answered ${correctCount} questions correctly!`;\n    } else {\n      message = `You got ${wrongCount} wrong. Correct answers: ${correctCount}.`;\n    }\n    const msgW = ctx.measureText(message).width;\n    ctx.fillText(message, (WIDTH - msgW) / 2, HEIGHT / 2);\n\n    // Restart button\n    const r = getRestartButtonRect();\n    ctx.fillStyle = '#ffffff';\n    ctx.strokeStyle = '#9ad1ff';\n    ctx.lineWidth = 2;\n    drawRoundedRect(r.x, r.y, r.w, r.h, 10, true, true);\n    ctx.fillStyle = '#1b3f6b';\n    ctx.font = '18px \"Segoe UI\", Roboto, Arial, sans-serif';\n    const btnText = 'Restart (R)';\n    const bw = ctx.measureText(btnText).width;\n    ctx.fillText(btnText, r.x + (r.w - bw) / 2, r.y + r.h / 2);\n    // small instruction for audio\n    ctx.font = FONT_BODY;\n    ctx.fillStyle = '#ffffff';\n    const audioHint = 'Press M to toggle sound.';\n    ctx.fillText(audioHint, (WIDTH - ctx.measureText(audioHint).width) / 2, r.y + r.h + 30);\n  }\n\n  // Main loop\n  function update() {\n    animationTick++;\n    if (shakeTimer > 0) shakeTimer--;\n    // gentle auto-selection bounce\n    // re-render\n    clearScreen();\n    if (gameState === 'playing') {\n      drawUI();\n    } else {\n      // still draw UI behind the overlay for context\n      drawUI();\n      drawEndScreen();\n    }\n    requestAnimationFrame(update);\n  }\n\n  // Start background on first user interaction for audio policies\n  function onFirstInteraction() {\n    if (!awaitingFirstGesture) return;\n    ensureAudioOnUserGesture();\n  }\n  ['mousedown', 'touchstart', 'keydown'].forEach((ev) => {\n    window.addEventListener(ev, onFirstInteraction, { once: true });\n  });\n\n  // Start update loop\n  tryCreateAudioContext();\n  if (audioCtx && !awaitingFirstGesture && soundOn) {\n    startBackground();\n  }\n  canvas.focus();\n  requestAnimationFrame(update);\n\n  // Expose minimal debugging on container\n  container.addEventListener('keydown', (e) => {\n    // ensure canvas gets focus for keyboard control\n    if (document.activeElement !== canvas) canvas.focus();\n  });\n\n  // Error handling for resource issues: wrap critical operations\n  window.addEventListener('error', (ev) => {\n    console.error('Error in Drone Math Adventure:', ev.message);\n  });\n\n  // Public reveal for tests (not necessary but harmless)\n  window.__droneMathGame = {\n    restart: restartGame,\n    toggleSound,\n    getState: () => ({ correctCount, wrongCount, gameState }),\n  };\n})();\n---\n",
  "improve_response_tokens": 17668,
  "formatted_code": true,
  "formatting_response_tokens": 19554,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}