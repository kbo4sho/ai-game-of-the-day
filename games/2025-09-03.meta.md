# Game of the Day - 2025-09-03

## Metadata
- **Generated Date:** 2025-09-03
- **Generated Time:** 2025-09-03T00:25:53.164465
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-03.js
- **File Size:** 27320 bytes
- **Tokens Used:** 9458

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-03.js` - The playable game
- `2025-09-03.meta.json` - Machine-readable metadata
- `2025-09-03.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 18897

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 20026

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function() {
  // Machine Math - Playable educational game for ages 7-9
  // Renders inside element with ID 'game-of-the-day-stage'
  // Uses Canvas for graphics and Web Audio API for sound (generated).
  // Controls: Left/Right arrows or A/D to move selector. Enter/Space to pick/place.
  // Click/tap parts to pick/place. 'H' for hint. 'M' to toggle sound (also click speaker icon).
  // Accessible text readouts are provided via offscreen ARIA elements.

  // ---- Config ----
  const WIDTH = 720;
  const HEIGHT = 480;
  const STAGE_ID = 'game-of-the-day-stage';
  const MAX_LEVELS = 6;
  const GENTLE_BG_VOLUME = 0.03;
  const CORRECT_VOLUME = 0.18;
  const INCORRECT_VOLUME = 0.18;

  // ---- Utility ----
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a, b) => a + Math.random() * (b - a);
  const pick = arr => arr[Math.floor(Math.random() * arr.length)];

  // ---- Stage and Accessibility ----
  const stage = document.getElementById(STAGE_ID);
  if (!stage) {
    console.error(`Element with id "${STAGE_ID}" not found. Game cannot start.`);
    return;
  }
  stage.style.position = 'relative';
  stage.style.width = WIDTH + 'px';
  stage.style.height = HEIGHT + 'px';
  stage.setAttribute('tabindex', '0'); // make focusable

  // Create ARIA friendly offscreen instructions for screen readers
  const srInstructions = document.createElement('div');
  srInstructions.setAttribute('aria-live', 'polite');
  srInstructions.style.position = 'absolute';
  srInstructions.style.left = '-9999px';
  srInstructions.style.top = 'auto';
  srInstructions.style.width = '1px';
  srInstructions.style.height = '1px';
  srInstructions.style.overflow = 'hidden';
  srInstructions.textContent = 'Machine Math game loaded. Use arrow keys to move, Enter to pick or place parts. Press H for a hint. Press M to toggle sound.';
  stage.appendChild(srInstructions);

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.display = 'block';
  canvas.style.outline = 'none';
  canvas.setAttribute('role', 'img');
  canvas.setAttribute('aria-label', 'Machine Math game canvas');
  stage.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Create a small visible speaker button for audio toggle (drawn on canvas too, but a DOM button for accessibility)
  const speakerBtn = document.createElement('button');
  speakerBtn.style.position = 'absolute';
  speakerBtn.style.right = '10px';
  speakerBtn.style.top = '10px';
  speakerBtn.style.padding = '6px 8px';
  speakerBtn.style.borderRadius = '6px';
  speakerBtn.style.border = '1px solid rgba(0,0,0,0.15)';
  speakerBtn.style.background = 'rgba(255,255,255,0.9)';
  speakerBtn.style.cursor = 'pointer';
  speakerBtn.setAttribute('aria-pressed', 'true');
  speakerBtn.textContent = 'Sound: On';
  stage.appendChild(speakerBtn);

  // Hidden live region for gameplay announcements
  const srAnnounce = document.createElement('div');
  srAnnounce.setAttribute('aria-live', 'polite');
  srAnnounce.style.position = 'absolute';
  srAnnounce.style.left = '-9999px';
  stage.appendChild(srAnnounce);

  // ---- Audio Setup ----
  let audioEnabled = true;
  let audioContext = null;
  let bgGain = null;
  let bgOsc = null;
  let audioReady = false;
  let audioAllowedByUser = false;

  function initAudioOnUserGesture() {
    if (audioReady || !audioEnabled) return;
    try {
      // create or resume AudioContext
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) {
        console.warn('Web Audio API not supported in this browser.');
        audioEnabled = false;
        speakerBtn.textContent = 'Sound: Off';
        speakerBtn.setAttribute('aria-pressed', 'false');
        return;
      }
      audioContext = new AC();

      // Background gentle hum
      bgGain = audioContext.createGain();
      bgGain.gain.value = GENTLE_BG_VOLUME;
      bgGain.connect(audioContext.destination);

      bgOsc = audioContext.createOscillator();
      bgOsc.type = 'sine';
      bgOsc.frequency.value = 110; // low hum
      // Add gentle slow vibrato via oscillator detune
      const lfo = audioContext.createOscillator();
      lfo.type = 'sine';
      lfo.frequency.value = 0.18; // slow
      const lfoGain = audioContext.createGain();
      lfoGain.gain.value = 20; // cents
      lfo.connect(lfoGain);
      lfoGain.connect(bgOsc.detune);
      bgOsc.connect(bgGain);

      bgOsc.start();
      lfo.start();

      audioReady = true;
      audioAllowedByUser = true;
      srAnnounce.textContent = 'Audio enabled.';
    } catch (e) {
      console.warn('Audio initialization failed:', e);
      audioEnabled = false;
      speakerBtn.textContent = 'Sound: Off';
      speakerBtn.setAttribute('aria-pressed', 'false');
      srAnnounce.textContent = 'Audio unavailable.';
    }
  }

  function stopBackground() {
    if (bgOsc) {
      try {
        bgOsc.stop();
      } catch (e) {}
      bgOsc.disconnect();
      bgOsc = null;
    }
    if (bgGain) {
      try { bgGain.disconnect(); } catch (e) {}
      bgGain = null;
    }
  }

  function toggleAudio() {
    audioEnabled = !audioEnabled;
    if (audioEnabled) {
      speakerBtn.textContent = 'Sound: On';
      speakerBtn.setAttribute('aria-pressed', 'true');
      // Wait for a user gesture to start audio
      srAnnounce.textContent = 'Sound will start on next interaction.';
    } else {
      speakerBtn.textContent = 'Sound: Off';
      speakerBtn.setAttribute('aria-pressed', 'false');
      stopBackground();
      audioReady = false;
      audioAllowedByUser = false;
    }
  }

  speakerBtn.addEventListener('click', () => {
    toggleAudio();
    canvas.focus();
  });

  // Play a short tone - returns Promise that resolves when done
  function playTone({freq = 440, dur = 0.18, type = 'sine', volume = 0.15, when = 0, detune = 0}) {
    if (!audioEnabled) return Promise.resolve();
    if (!audioContext) return Promise.resolve();
    return new Promise((resolve) => {
      try {
        const now = audioContext.currentTime + when;
        const osc = audioContext.createOscillator();
        osc.type = type;
        osc.frequency.value = freq;
        osc.detune.value = detune;

        const gain = audioContext.createGain();
        gain.gain.value = 0.0001;

        osc.connect(gain);
        gain.connect(audioContext.destination);

        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(volume, now + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + dur);

        osc.start(now);
        osc.stop(now + dur + 0.02);

        osc.onended = () => {
          try { gain.disconnect(); } catch (e) {}
          try { osc.disconnect(); } catch (e) {}
          resolve();
        };
      } catch (e) {
        console.warn('playTone error', e);
        resolve();
      }
    });
  }

  function playCorrectMelody() {
    if (!audioEnabled) return;
    if (!audioContext) return;
    // ascending triad
    const freqs = [440, 550, 660];
    freqs.forEach((f, i) => playTone({freq: f, dur: 0.15, when: i * 0.12, type: 'sine', volume: CORRECT_VOLUME}));
  }

  function playIncorrectBuzz() {
    if (!audioEnabled) return;
    if (!audioContext) return;
    // short buzzer
    const now = audioContext.currentTime;
    try {
      const osc = audioContext.createOscillator();
      osc.type = 'square';
      osc.frequency.value = 180;
      const gain = audioContext.createGain();
      gain.gain.value = 0.0001;
      osc.connect(gain);
      gain.connect(audioContext.destination);
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(INCORRECT_VOLUME, now + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);
      osc.start(now);
      osc.stop(now + 0.26);
      osc.onended = () => {
        try { gain.disconnect(); } catch (e) {}
        try { osc.disconnect(); } catch (e) {}
      };
    } catch (e) {
      console.warn('playIncorrectBuzz error', e);
    }
  }

  // ---- Game State ----
  let running = true;
  let lastTime = 0;
  let parts = []; // conveyor parts
  let selector = { x: WIDTH / 2, y: HEIGHT - 90, width: 52, height: 28, holding: null };
  let placedParts = []; // parts placed into machine (values)
  let level = 1;
  let target = 5;
  let attemptsLeft = 3;
  let levelCompleted = false;
  let confetti = [];
  let showHint = false;

  // Generate level targets (increasing difficulty)
  function computeTargets() {
    const arr = [];
    for (let i = 0; i < MAX_LEVELS; i++) {
      arr.push(5 + i + Math.floor(i / 2) * 2); // 5,6,7,9,10,12 etc.
    }
    return arr;
  }
  const targetsList = computeTargets();

  // ---- Parts/Conveyor ----
  function createPart(x, value) {
    return {
      x,
      y: 110 + Math.sin(x * 0.02) * 6,
      r: 22,
      value,
      picked: false,
      wobble: Math.random() * Math.PI * 2
    };
  }

  function populateConveyor(levelNum) {
    parts = [];
    const count = 9;
    const startX = -60;
    for (let i = 0; i < count; i++) {
      const x = startX + i * 90;
      // values between 1..(level+4)
      const maxVal = clamp(6 + levelNum + 2, 6, 12);
      const value = Math.floor(rand(1, Math.min(9, maxVal) + 1));
      parts.push(createPart(x, value));
    }
  }

  // ---- Game Flow ----
  function startLevel(lvl) {
    level = lvl;
    target = targetsList[clamp(level - 1, 0, targetsList.length - 1)];
    attemptsLeft = 3;
    placedParts = [];
    levelCompleted = false;
    confetti = [];
    populateConveyor(level);
    srAnnounce.textContent = `Level ${level}. Make ${target} using parts from the conveyor. Use arrow keys to move and press Enter to pick or place.`;
  }

  // ---- Interaction ----
  const keys = {};
  function handleKeyDown(e) {
    // Guarantee audio on user gesture
    if (!audioAllowedByUser && audioEnabled) {
      initAudioOnUserGesture();
    }
    keys[e.key] = true;
    if (e.key === 'm' || e.key === 'M') {
      toggleAudio();
      e.preventDefault();
    }
    if (e.key === 'h' || e.key === 'H') {
      requestHint();
      e.preventDefault();
    }
    // Allow picking with Enter or Space
    if (e.key === 'Enter' || e.key === ' ') {
      if (!selector.holding) {
        // attempt pick at selector x
        pickPartAtSelector();
      } else {
        // place into machine
        placeIntoMachine();
      }
      e.preventDefault();
    }
    if ((e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A')) {
      e.preventDefault();
    }
    if ((e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D')) {
      e.preventDefault();
    }
  }
  function handleKeyUp(e) {
    keys[e.key] = false;
  }

  window.addEventListener('keydown', handleKeyDown);
  window.addEventListener('keyup', handleKeyUp);

  // Mouse/touch interactions
  canvas.addEventListener('click', (ev) => {
    // start audio if needed
    if (!audioAllowedByUser && audioEnabled) {
      initAudioOnUserGesture();
    }
    const rect = canvas.getBoundingClientRect();
    const mx = ev.clientX - rect.left;
    const my = ev.clientY - rect.top;
    canvas.focus();

    // If clicked on speaker button area? Speaker button is DOM so ignore.

    // If clicked on part, toggle pick/place
    const part = parts.find(p => {
      const dx = mx - p.x;
      const dy = my - p.y;
      return Math.hypot(dx, dy) <= p.r + 6;
    });
    if (part) {
      // move selector to that part and pick
      selector.x = clamp(part.x, 40, WIDTH - 40);
      pickPartAtSelector();
      return;
    }

    // If clicked near machine place zone, attempt to place
    if (mx > WIDTH - 240 && my > 60 && my < HEIGHT - 120) {
      if (selector.holding) placeIntoMachine();
      return;
    }

    // Click elsewhere: move selector
    selector.x = clamp(mx, 40, WIDTH - 40);
  });

  // Pick part near selector
  function pickPartAtSelector() {
    if (selector.holding) return;
    // find nearest part within picking range
    let nearest = null;
    let nearestDist = 9999;
    for (const p of parts) {
      if (p.picked) continue;
      const d = Math.abs(p.x - selector.x) + Math.abs(p.y - selector.y);
      if (d < nearestDist && d < 80) {
        nearest = p;
        nearestDist = d;
      }
    }
    if (nearest) {
      nearest.picked = true;
      selector.holding = nearest;
      // Visual cue and small sound
      playTone({freq: 660, dur: 0.08, type: 'sine', volume: 0.08});
      srAnnounce.textContent = `Picked a part: ${nearest.value}. Current held: ${nearest.value}.`;
    } else {
      // gentle denied sound
      playTone({freq: 240, dur: 0.08, type: 'sine', volume: 0.06});
      srAnnounce.textContent = 'No part nearby to pick. Move closer to the conveyor.';
    }
  }

  function placeIntoMachine() {
    if (!selector.holding) return;
    // place into machine area (right side)
    const value = selector.holding.value;
    placedParts.push(value);
    selector.holding = null;
    srAnnounce.textContent = `Placed ${value}. Current total: ${placedParts.reduce((a,b)=>a+b,0)} of ${target}.`;
    // check result
    const sum = placedParts.reduce((a,b)=>a+b,0);
    if (sum === target) {
      // success
      levelCompleted = true;
      playCorrectMelody();
      createConfettiBurst();
      srAnnounce.textContent = `Correct! Level ${level} complete.`;
      setTimeout(() => {
        if (level < MAX_LEVELS) startLevel(level + 1);
        else finishGame();
      }, 1200);
    } else if (sum > target) {
      // overshoot
      attemptsLeft -= 1;
      playIncorrectBuzz();
      flashError();
      srAnnounce.textContent = `Oops! That's too many. You have ${attemptsLeft} attempts left. Current total: ${sum} of ${target}.`;
      if (attemptsLeft <= 0) {
        // reset the level gently
        setTimeout(() => {
          srAnnounce.textContent = `Let's try that level again.`;
          startLevel(level);
        }, 900);
      } else {
        // allow removing last part (we'll remove it automatically to keep it beatable)
        // remove last placed part and return it to the conveyor near selector
        const removed = placedParts.pop();
        // create a returned part near selector.x
        const newPart = createPart(selector.x, removed);
        newPart.picked = false;
        parts.push(newPart);
      }
    } else {
      // continue, small ding
      playTone({freq: 520, dur: 0.08, type: 'triangle', volume: 0.06});
    }
  }

  // Hint system: suggest a part that helps reach target
  function requestHint() {
    showHint = true;
    // Find a part on conveyor that could be helpful (value <= remaining)
    const remaining = target - placedParts.reduce((a,b)=>a+b,0);
    const candidates = parts.filter(p => !p.picked && p.value <= remaining);
    if (candidates.length === 0) {
      srAnnounce.textContent = 'No helpful parts available. Try picking a small number or reset the level.';
      playTone({freq: 220, dur: 0.12, type: 'sine', volume: 0.06});
      return;
    }
    const chosen = pick(candidates);
    // move selector to chosen so player can easily pick
    selector.x = clamp(chosen.x, 40, WIDTH - 40);
    srAnnounce.textContent = `Hint: Try the part with value ${chosen.value} near the conveyor.`;
    playTone({freq: 660, dur: 0.12, type: 'sine', volume: 0.08});
  }

  // Finish the game
  function finishGame() {
    srAnnounce.textContent = 'Fantastic! You finished all the machine levels. Well done!';
    // Celebrate visually and with sound
    for (let i = 0; i < 40; i++) createConfettiBurst();
    playCorrectMelody();
    // allow restart
    setTimeout(() => {
      startLevel(1);
    }, 4000);
  }

  // ---- Visual helpers ----
  function drawBackground() {
    // Soft vertical gradient sky
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#EAF2FF');
    g.addColorStop(1, '#F7F9FF');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Random gentle clouds
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    for (let i = 0; i < 6; i++) {
      const cx = (i * 130 + 60 + (Date.now() * 0.02 * (i%3 - 1))) % WIDTH;
      const cy = 40 + (i % 3) * 20;
      drawCloud(cx, cy, 38 + (i % 3) * 8);
    }
  }
  function drawCloud(cx, cy, size) {
    ctx.beginPath();
    ctx.arc(cx, cy, size, 0, Math.PI * 2);
    ctx.arc(cx + size * 0.8, cy + 8, size * 0.8, 0, Math.PI * 2);
    ctx.arc(cx - size * 0.9, cy + 6, size * 0.7, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawConveyor() {
    // conveyor belt base
    ctx.fillStyle = '#DDE7F9';
    ctx.fillRect(0, 80, WIDTH - 220, 140);
    // belt pattern
    ctx.fillStyle = '#C7D8F0';
    for (let i = 0; i < 20; i++) {
      ctx.fillRect((i * 80 + (Date.now() * 0.02 % 80)), 150, 40, 14);
    }
    // left machine arm
    drawWackyMachineArm(60, 120, 1.0);
    // Right machine (receiving)
    drawReceivingMachine(WIDTH - 200, 40);
  }

  function drawWackyMachineArm(x, y, scale) {
    // base
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    ctx.fillStyle = '#D2EAF1';
    roundRect(ctx, -12, 12, 60, 20, 6);
    ctx.fill();
    // arm
    ctx.fillStyle = '#9FC8D6';
    roundRect(ctx, 0, -6, 12, 46, 6);
    ctx.fill();
    // claw
    ctx.beginPath();
    ctx.fillStyle = '#6BB0C4';
    ctx.arc(36, 18, 12, 0, Math.PI * 2);
    ctx.fill();
    // eye decal
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath();
    ctx.arc(8, 24, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#334';
    ctx.fillRect(5, 26, 4, 3);
    ctx.restore();
  }

  function drawReceivingMachine(x, y) {
    // main box
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = '#F7EAD9';
    roundRect(ctx, 0, 0, 200, 240, 12);
    ctx.fill();
    // machine face
    ctx.fillStyle = '#F2D7BA';
    roundRect(ctx, 14, 24, 172, 80, 10);
    ctx.fill();
    // eyes
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(52, 66, 12, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(148, 66, 12, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#334';
    ctx.beginPath();
    ctx.arc(52, 68, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(148, 68, 6, 0, Math.PI * 2);
    ctx.fill();
    // slot where parts go
    ctx.fillStyle = '#ECD5B8';
    roundRect(ctx, 18, 120, 164, 34, 8);
    ctx.fill();
    // target display as a digital label
    ctx.fillStyle = '#0E4C6C';
    ctx.font = '26px "Arial", sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`Target: ${target}`, 100, 32);
    // display placed parts as little gears
    for (let i = 0; i < placedParts.length; i++) {
      const vx = 36 + i * 40;
      drawGear(24 + vx, 138, 14, '#F8C77E', '#D98B4B', placedParts[i]);
    }
    ctx.restore();
  }

  function drawParts() {
    // draw each part on conveyor
    for (const p of parts) {
      // move
      p.x += 0.6 + Math.sin(Date.now() * 0.001 + p.wobble) * 0.1;
      p.wobble += 0.01;
      if (p.x > WIDTH - 240) {
        p.x = -40;
      }
      p.y = 120 + Math.sin(p.x * 0.02 + p.wobble) * 8;
      // if picked by selector, follow it
      if (selector.holding === p) {
        p.x = selector.x;
        p.y = selector.y - 26;
      }
      ctx.save();
      // shadow
      ctx.fillStyle = 'rgba(40,40,40,0.08)';
      ctx.beginPath();
      ctx.ellipse(p.x, p.y + 24, 24, 8, 0, 0, Math.PI * 2);
      ctx.fill();

      drawGear(p.x, p.y, p.r, '#E8F1FF', '#6AA5D8', p.value, p.picked);
      ctx.restore();
    }
  }

  function drawGear(cx, cy, radius, fillColor, strokeColor, label, dimmed=false) {
    ctx.save();
    ctx.strokeStyle = strokeColor;
    ctx.fillStyle = fillColor;
    ctx.lineWidth = 2;
    // simple gear-like disc with teeth
    const teeth = 8;
    ctx.beginPath();
    for (let i = 0; i < teeth; i++) {
      const a = (i / teeth) * Math.PI * 2;
      const r1 = radius - 2;
      const r2 = radius + 6;
      const x1 = cx + Math.cos(a) * r1;
      const y1 = cy + Math.sin(a) * r1;
      const x2 = cx + Math.cos(a + 0.06) * r2;
      const y2 = cy + Math.sin(a + 0.06) * r2;
      ctx.lineTo(x1, y1);
      ctx.lineTo(x2, y2);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // center circle
    ctx.beginPath();
    ctx.fillStyle = dimmed ? 'rgba(255,255,255,0.4)' : '#fff';
    ctx.arc(cx, cy, radius - 8, 0, Math.PI * 2);
    ctx.fill();

    // label
    ctx.fillStyle = '#334';
    ctx.font = 'bold 14px "Arial", sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(String(label), cx, cy);
    ctx.restore();
  }

  function drawSelector() {
    // selector bar
    ctx.save();
    ctx.translate(selector.x, selector.y);
    // base plate
    ctx.fillStyle = '#FFF9EA';
    roundRect(ctx, -selector.width/2, -selector.height/2, selector.width, selector.height, 6);
    ctx.fill();
    // handle
    ctx.fillStyle = '#A7C8D9';
    roundRect(ctx, -10, -selector.height/2 - 12, 20, 12, 6);
    ctx.fill();
    // holding part preview
    if (selector.holding) {
      drawGear(0, -34, 16, '#FFF0D6', '#E7A85D', selector.holding.value);
    }
    // small label
    ctx.fillStyle = '#334';
    ctx.font = '12px "Arial", sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Grabber', 0, 16);
    ctx.restore();

    // visual guide: if audio is off, show speaker-off icon
    ctx.save();
    ctx.translate(WIDTH - 80, 20);
    ctx.fillStyle = audioEnabled ? '#3B8EA5' : '#888';
    ctx.beginPath();
    ctx.arc(0, 0, 12, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = '10px "Arial", sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(audioEnabled ? '♫' : '✕', 0, 0);
    ctx.restore();
  }

  function drawHUD() {
    // top left level/attempts
    ctx.fillStyle = '#334';
    ctx.font = '18px "Arial", sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`Level ${level}/${MAX_LEVELS}`, 12, 30);
    ctx.font = '14px "Arial", sans-serif';
    ctx.fillText(`Attempts: ${attemptsLeft}`, 12, 52);

    // instructions
    ctx.fillStyle = '#334';
    ctx.font = '12px "Arial", sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Move with ← → or A/D. Pick/place with Enter or Space. Press H for a hint. M toggles sound.', WIDTH / 2, HEIGHT - 10);

    // target badge left of machine for clarity
    ctx.save();
    ctx.fillStyle = '#FDE4B2';
    roundRect(ctx, WIDTH - 265, 12, 120, 34, 8);
    ctx.fill();
    ctx.fillStyle = '#0D3E57';
    ctx.font = '20px "Arial", sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`${target}`, WIDTH - 205, 36);
    ctx.restore();
  }

  // Confetti for celebration
  function createConfettiBurst() {
    for (let i = 0; i < 12; i++) {
      confetti.push({
        x: WIDTH - 100 + rand(-40, 40),
        y: 80 + rand(0, 40),
        vx: rand(-2.3, 2.3),
        vy: rand(-6.5, -2.0),
        size: rand(4, 8),
        color: pick(['#FFB86B', '#FF7FA7', '#8BD36C', '#7FC8FF', '#FFD86B']),
        life: rand(1.6, 2.6)
      });
    }
    playTone({freq: 880, dur: 0.12, volume: 0.14});
  }

  function updateConfetti(dt) {
    for (const c of confetti) {
      c.vy += 9.8 * dt;
      c.x += c.vx;
      c.y += c.vy;
      c.life -= dt;
    }
    // remove expired
    confetti = confetti.filter(c => c.life > 0);
  }

  function drawConfetti() {
    for (const c of confetti) {
      ctx.fillStyle = c.color;
      ctx.fillRect(c.x, c.y, c.size, c.size * 1.6);
    }
  }

  // Flashing border on error
  let flashTimer = 0;
  function flashError() {
    flashTimer = 0.5; // seconds
  }

  // ---- Helpers for drawing rounded rects ----
  function roundRect(ctx, x, y, w, h, r) {
    const radius = r || 6;
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.arcTo(x + w, y, x + w, y + h, radius);
    ctx.arcTo(x + w, y + h, x, y + h, radius);
    ctx.arcTo(x, y + h, x, y, radius);
    ctx.arcTo(x, y, x + w, y, radius);
    ctx.closePath();
  }

  // ---- Main Loop ----
  function update(dt) {
    // Input handling
    if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
      selector.x -= 220 * dt;
    } else if (keys['ArrowRight'] || keys['d'] || keys['D']) {
      selector.x += 220 * dt;
    }
    selector.x = clamp(selector.x, 40, WIDTH - 40);

    // update parts positions done in drawParts()

    updateConfetti(dt);

    if (flashTimer > 0) flashTimer -= dt;
  }

  function draw() {
    // Clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    // Background & environment
    drawBackground();
    drawConveyor();
    drawParts();
    drawSelector();
    drawHUD();
    drawConfetti();

    // overlay flash for error
    if (flashTimer > 0) {
      const alpha = Math.sin(flashTimer * 20) * 0.15 + 0.12;
      ctx.fillStyle = `rgba(255,90,80,${alpha})`;
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
    }

    // Show hint highlight momentarily
    if (showHint) {
      ctx.save();
      ctx.strokeStyle = '#FF7FA7';
      ctx.lineWidth = 3;
      ctx.setLineDash([6, 4]);
      ctx.strokeRect(selector.x - 50, selector.y - 70, 100, 80);
      ctx.restore();
      // hide after a moment
      setTimeout(() => showHint = false, 1000);
    }
  }

  function loop(t) {
    if (!running) return;
    if (!lastTime) lastTime = t;
    const dt = Math.min(0.05, (t - lastTime) / 1000);
    lastTime = t;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // ---- Initialize ----
  function init() {
    // Basic error handling: ensure canvas context exists
    if (!ctx) {
      console.error('Canvas rendering context not available.');
      stage.appendChild(document.createTextNode('Unable to start the game: canvas not supported.'));
      return;
    }

    // Focus canvas for keyboard control
    canvas.setAttribute('tabindex', '0');
    canvas.focus();

    // Begin at level 1
    startLevel(1);

    // Start game loop
    requestAnimationFrame(loop);
  }

  // Start audio on first mousedown or key press to satisfy browser policies
  function firstUserGestureHandler() {
    if (!audioAllowedByUser && audioEnabled) {
      initAudioOnUserGesture();
    }
    // remove listeners (we only need to capture first)
    window.removeEventListener('mousedown', firstUserGestureHandler);
    window.removeEventListener('touchstart', firstUserGestureHandler);
    window.removeEventListener('keydown', firstUserGestureHandler);
  }
  window.addEventListener('mousedown', firstUserGestureHandler);
  window.addEventListener('touchstart', firstUserGestureHandler);
  window.addEventListener('keydown', firstUserGestureHandler);

  // Keyboard accessibility: ensure stage gains focus on click
  stage.addEventListener('click', () => canvas.focus());

  // Prevent accidental text selection during play
  stage.addEventListener('selectstart', (e) => e.preventDefault());

  // Start everything
  try {
    init();
  } catch (err) {
    console.error('Game initialization error:', err);
    srAnnounce.textContent = 'An error occurred while starting the game. Please try reloading the page.';
  }

  // Expose a simple API for testing/debugging via window (non-essential)
  window._machineMathGame = {
    startLevel,
    toggleAudio,
    get state() {
      return { level, target, attemptsLeft, placedParts, partsCount: parts.length };
    }
  };
})();
---

