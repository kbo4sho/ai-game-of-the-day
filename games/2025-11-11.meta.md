# Game of the Day - 2025-11-11

## Metadata
- **Generated Date:** 2025-11-11
- **Generated Time:** 2025-11-11T00:29:05.568050
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-11-11.js
- **File Size:** 31540 bytes
- **Tokens Used:** 10687

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ‚úÖ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ‚úÖ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
‚Ä¢ Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
‚Ä¢ Use visually calming and interesting and wacky elements.
‚Ä¢ Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
‚Ä¢ Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
‚Ä¢ Have a game area exactly 720px wide by 480px tall.
‚Ä¢ Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
‚Ä¢ Use modern JavaScript practices and avoid minification.
‚Ä¢ Include proper error handling for audio and resource loading.
‚Ä¢ Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
‚Ä¢ Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
‚Ä¢ Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
‚Ä¢ Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
‚Ä¢ Generate all sounds using Web Audio API oscillators and filters.
‚Ä¢ Include proper error handling for audio context creation.
‚Ä¢ Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
‚Ä¢ Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-11-11.js` - The playable game
- `2025-11-11.meta.json` - Machine-readable metadata
- `2025-11-11.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 22190

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 24220

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ‚úÖ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Drone Math Delivery - JavaScript-only game
  // Renders into element with id "game-of-the-day-stage"
  // Designed for children 7-9. Goal: answer 10 questions correctly. 3 wrong answers = game over.
  // Uses Canvas and Web Audio API (no external assets).
  // Accessible controls: keyboard and mouse; visual cues and clear UI layout.
  "use strict";

  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const TARGET_CORRECT = 10;
  const MAX_LIVES = 3;
  const FONT_FAMILY = "Arial, sans-serif";

  // Attempt to find the stage element
  const stage = document.getElementById("game-of-the-day-stage");
  if (!stage) {
    console.error("Missing container element with id 'game-of-the-day-stage'.");
    return;
  }

  // Clean stage contents and create canvas
  stage.innerHTML = "";
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.width = WIDTH + "px";
  canvas.style.height = HEIGHT + "px";
  canvas.setAttribute("tabindex", "0"); // make focusable for keyboard events
  stage.appendChild(canvas);
  const ctx = canvas.getContext("2d");

  // Global state
  let gameState = {
    running: true,
    correctCount: 0,
    wrongCount: 0,
    lives: MAX_LIVES,
    currentProblem: null,
    inputText: "",
    message: "",
    timeSinceLastCorrect: 0,
    droneX: 100,
    droneY: HEIGHT / 2,
    droneTargetX: 100,
    droneWobble: 0,
    animations: [],
    soundEnabled: true,
    audioReady: false,
    audioError: null,
    bgHumGain: null,
    lastTick: null,
    endState: null, // null | "win" | "lose"
  };

  // Layout constants to avoid overlapping text
  const PADDING = 12;
  const TOP_UI_HEIGHT = 64; // reserved top area for score/lives
  const BOTTOM_UI_HEIGHT = 84; // instructions area bottom
  const CENTER_AREA = {
    x: PADDING,
    y: TOP_UI_HEIGHT + PADDING,
    w: WIDTH - PADDING * 2,
    h: HEIGHT - TOP_UI_HEIGHT - BOTTOM_UI_HEIGHT - PADDING * 2,
  };

  // Button regions for click detection
  const regions = {
    okButton: null,
    restartButton: null,
    soundToggle: null,
    keypadButtons: [], // each has x,y,w,h,value
  };

  // Utility: measure text width with given font size and weight
  function measureText(text, size = 16, weight = "normal") {
    ctx.save();
    ctx.font = `${weight} ${size}px ${FONT_FAMILY}`;
    const m = ctx.measureText(text);
    ctx.restore();
    return m.width;
  }

  // Audio setup with error handling
  let audioCtx = null;
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (AudioContext) {
      audioCtx = new AudioContext();
    } else {
      throw new Error("Web Audio API not supported");
    }
  } catch (err) {
    audioCtx = null;
    gameState.audioError = err.message || String(err);
    console.warn("AudioContext creation failed:", err);
  }

  function ensureAudio() {
    if (!audioCtx) return false;
    // Some browsers require resume on user gesture
    if (audioCtx.state === "suspended") {
      audioCtx.resume().catch((e) => {
        console.warn("Audio resume failed", e);
      });
    }
    return true;
  }

  // Start gentle background hum if audio ready
  function startBackgroundHum() {
    if (!audioCtx) return;
    try {
      if (gameState.bgHumGain) return; // already running
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "sine";
      osc.frequency.value = 120; // low hum
      gain.gain.value = gameState.soundEnabled ? 0.0018 : 0.0; // subtle
      osc.connect(gain);
      const filter = audioCtx.createBiquadFilter();
      filter.type = "lowpass";
      filter.frequency.value = 800;
      gain.connect(filter);
      filter.connect(audioCtx.destination);
      osc.start();
      // store a reference; we can't stop oscillator unless we keep it; so we'll keep it running and adjust gain
      gameState.bgHumGain = gain;
      gameState.bgHumOsc = osc;
      gameState.audioReady = true;
    } catch (e) {
      console.warn("Background hum setup failed", e);
      gameState.audioError = e.message || String(e);
    }
  }

  // Toggle sound on/off
  function setSoundEnabled(enabled) {
    gameState.soundEnabled = enabled;
    if (gameState.bgHumGain) {
      gameState.bgHumGain.gain.setTargetAtTime(enabled ? 0.0018 : 0.0, audioCtx.currentTime, 0.02);
    }
  }

  // Play short chime for correct
  function playCorrect() {
    if (!audioCtx || !gameState.soundEnabled) return;
    try {
      const o1 = audioCtx.createOscillator();
      const o2 = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      o1.type = "sine";
      o2.type = "triangle";
      o1.frequency.value = 880;
      o2.frequency.value = 660;
      g.gain.value = 0;
      filter.type = "lowpass";
      filter.frequency.value = 1400;
      o1.connect(g);
      o2.connect(g);
      g.connect(filter);
      filter.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(0.08, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
      o1.start(now);
      o2.start(now);
      o1.stop(now + 0.55);
      o2.stop(now + 0.45);
    } catch (e) {
      console.warn("playCorrect error", e);
    }
  }

  // Play buzz for wrong answer
  function playWrong() {
    if (!audioCtx || !gameState.soundEnabled) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "sawtooth";
      o.frequency.value = 220;
      o.connect(g);
      g.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.06, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);
      o.start(now);
      o.stop(now + 0.42);
    } catch (e) {
      console.warn("playWrong error", e);
    }
  }

  // Play click/hover
  function playClick() {
    if (!audioCtx || !gameState.soundEnabled) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "square";
      o.frequency.value = 1200;
      o.connect(g);
      g.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.04, now + 0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.08);
      o.start(now);
      o.stop(now + 0.09);
    } catch (e) {
      console.warn("playClick error", e);
    }
  }

  // Helper: create a new math problem suitable for ages 7-9
  function makeProblem(correctCount) {
    // Increase difficulty slowly as player gets more correct
    const level = Math.min(4, Math.floor(correctCount / 3) + 1);
    // Level 1: + within 10, Level 2: +/-, Level 3: +,- within 20, Level4: simple times (2-5)
    let a, b, op, answer;
    if (level === 1) {
      op = "+";
      a = randInt(0, 10);
      b = randInt(0, 10);
      answer = a + b;
    } else if (level === 2) {
      op = Math.random() < 0.6 ? "+" : "-";
      a = randInt(0, 12);
      b = randInt(0, a); // ensure non-negative result if subtraction
      answer = op === "+" ? a + b : a - b;
    } else if (level === 3) {
      op = Math.random() < 0.5 ? "+" : "-";
      a = randInt(0, 20);
      b = op === "-" ? randInt(0, a) : randInt(0, 20);
      answer = op === "+" ? a + b : a - b;
    } else {
      // simple multiplication or mixed
      if (Math.random() < 0.5) {
        op = "√ó";
        a = randInt(2, 6);
        b = randInt(2, 6);
        answer = a * b;
      } else {
        op = "+";
        a = randInt(0, 30);
        b = randInt(0, 30);
        answer = a + b;
      }
    }
    return { a, b, op, answer };
  }

  // Utility random int inclusive
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // Reset and start new game
  function resetGame() {
    gameState.running = true;
    gameState.correctCount = 0;
    gameState.wrongCount = 0;
    gameState.lives = MAX_LIVES;
    gameState.inputText = "";
    gameState.animations = [];
    gameState.message = "Welcome! Type your answer and press Enter or click OK.";
    gameState.currentProblem = makeProblem(0);
    gameState.droneX = 100;
    gameState.droneY = CENTER_AREA.y + CENTER_AREA.h / 2;
    gameState.droneTargetX = gameState.droneX;
    gameState.droneWobble = 0;
    gameState.endState = null;
    if (ensureAudio()) startBackgroundHum();
    gameLoopResetTime();
  }

  // Game Over handling
  function finishGame(state) {
    // state: "win" or "lose"
    gameState.running = false;
    gameState.endState = state;
    if (state === "win") {
      gameState.message = `Hooray! You delivered ${TARGET_CORRECT} packages! Press R to restart.`;
      playCorrect();
    } else {
      gameState.message = `Oh no! You lost all lives. Press R to try again.`;
      playWrong();
    }
  }

  // Submit answer logic
  function submitAnswer() {
    if (!gameState.running) return;
    const raw = gameState.inputText.trim();
    if (raw.length === 0) {
      gameState.message = "Please enter a number answer.";
      return;
    }
    // Parse integer
    const parsed = parseInt(raw, 10);
    if (isNaN(parsed)) {
      gameState.message = "Invalid number. Use digits and press Enter or OK.";
      return;
    }
    const correct = parsed === gameState.currentProblem.answer;
    if (correct) {
      gameState.correctCount += 1;
      gameState.message = "Correct! The drone happily flies to deliver the package.";
      gameState.inputText = "";
      // animate drone to right then back
      animateDroneDeliver();
      playCorrect();
      gameState.timeSinceLastCorrect = 0;
      if (gameState.correctCount >= TARGET_CORRECT) {
        finishGame("win");
      } else {
        // prepare next problem after short delay via animation callback
      }
    } else {
      gameState.wrongCount += 1;
      gameState.lives -= 1;
      gameState.message = "Oops! Wrong answer. Try the next one.";
      gameState.inputText = "";
      gameState.droneWobble = 1.0;
      playWrong();
      if (gameState.lives <= 0) {
        finishGame("lose");
      } else {
        gameState.currentProblem = makeProblem(gameState.correctCount);
      }
    }
  }

  // Drone delivery animation: drone goes to a 'package' (right side), a star appears, then returns.
  function animateDroneDeliver() {
    const startX = gameState.droneX;
    const targetX = CENTER_AREA.x + CENTER_AREA.w - 120;
    const duration = 900; // ms to go right
    const returnDuration = 600;
    const startTime = performance.now();
    // push animation into animations array
    const anim = {
      type: "deliver",
      startTime,
      duration,
      returnDuration,
      startX,
      targetX,
      phase: "going",
      done: false,
    };
    gameState.animations.push(anim);
  }

  // Main loop and rendering
  function gameLoopResetTime() {
    gameState.lastTick = performance.now();
  }

  function update(dt) {
    // dt in ms
    if (gameState.running) {
      gameState.timeSinceLastCorrect += dt;
      // Update animations
      const now = performance.now();
      for (let i = gameState.animations.length - 1; i >= 0; i--) {
        const a = gameState.animations[i];
        if (a.type === "deliver") {
          const elapsed = now - a.startTime;
          if (a.phase === "going") {
            const t = Math.min(1, elapsed / a.duration);
            // ease out
            const ease = 1 - Math.pow(1 - t, 3);
            gameState.droneX = a.startX + (a.targetX - a.startX) * ease;
            gameState.droneWobble = (1 - t) * 0.6;
            if (t >= 1) {
              // create sparkle
              spawnSparkles(a.targetX + 40, gameState.droneY - 30, 12);
              // prepare return
              a.phase = "returning";
              a.returnStart = now + 120;
            }
          } else if (a.phase === "returning") {
            const t2 = Math.min(1, (now - a.returnStart) / a.returnDuration);
            const ease2 = t2 < 0 ? 0 : 1 - Math.pow(1 - t2, 3);
            gameState.droneX = a.targetX - (a.targetX - a.startX) * ease2;
            gameState.droneWobble = Math.max(0, 0.6 * (1 - t2));
            if (t2 >= 1) {
              // finished
              a.done = true;
              gameState.animations.splice(i, 1);
              // new problem
              gameState.currentProblem = makeProblem(gameState.correctCount);
            }
          }
        }
      }

      // Update sparkles or other small animations
      for (let i = gameState.animations.length - 1; i >= 0; i--) {
        if (gameState.animations[i].done) {
          gameState.animations.splice(i, 1);
        }
      }
    } else {
      // not running, but keep subtle idle animations
      gameState.droneWobble *= 0.95;
    }

    // Update drone vertical bobbing
    const bob = Math.sin((performance.now() / 600) + gameState.droneX / 80) * 6;
    gameState.droneY = CENTER_AREA.y + CENTER_AREA.h / 2 + bob;
  }

  // Sparkle animation spawn
  function spawnSparkles(x, y, count) {
    for (let i = 0; i < count; i++) {
      const a = {
        type: "spark",
        x,
        y,
        vx: (Math.random() - 0.5) * 1.8,
        vy: -Math.random() * 1.6 - 0.6,
        life: 800 + Math.random() * 600,
        born: performance.now(),
      };
      gameState.animations.push(a);
    }
  }

  // Draw helper: rounded rect
  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }

  // Draw main frame
  function render() {
    // Clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Calming pastel sky background with wacky clouds
    drawBackground();

    // Draw top UI: score left, lives right, sound toggle near top-center
    drawTopUI();

    // Draw center play area border
    drawPlayArea();

    // Draw drone and package
    drawSceneObjects();

    // Draw problem and input UI in center area (non-overlapping)
    drawProblemArea();

    // Draw instructions bottom center
    drawBottomInstructions();

    // If not running (end screens)
    if (!gameState.running && gameState.endState) {
      drawEndScreen();
    }
  }

  function drawBackground() {
    // gradient sky
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, "#E8F8FF");
    g.addColorStop(1, "#F6FCFF");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // gentle layered hills at bottom
    ctx.fillStyle = "#E8F6EF";
    roundRect(ctx, 0, HEIGHT - 80, WIDTH, 80, 0);
    ctx.fill();

    // wacky clouds
    drawCloud(120, 60, 60, 28, "#FFFFFF", "#EAF6FF");
    drawCloud(420, 40, 80, 34, "#FFFFFF", "#F8F9FF");
    drawCloud(600, 90, 50, 24, "#FFFFFF", "#F1F7FF");
    drawCloud(260, 110, 70, 30, "#FFFFFF", "#F7FFFF");

    // soft grid of tiny tiny stars to make it whimsical
    ctx.globalAlpha = 0.15;
    for (let i = 0; i < 10; i++) {
      const x = 40 + i * 64 + ((i % 2) * 12);
      const y = 60 + ((i * 27) % 80);
      drawTinyWackyStar(x, y, 6 + (i % 3));
    }
    ctx.globalAlpha = 1.0;
  }

  function drawCloud(cx, cy, w, h, color, shade) {
    const grad = ctx.createLinearGradient(cx - w, cy - h, cx + w, cy + h);
    grad.addColorStop(0, color);
    grad.addColorStop(1, shade);
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.ellipse(cx, cy, w * 0.8, h, 0, 0, Math.PI * 2);
    ctx.ellipse(cx - w * 0.45, cy + 6, w * 0.5, h * 0.8, 0, 0, Math.PI * 2);
    ctx.ellipse(cx + w * 0.45, cy + 4, w * 0.45, h * 0.75, 0, 0, Math.PI * 2);
    ctx.closePath();
    ctx.fill();
    // outline
    ctx.strokeStyle = "rgba(0,0,0,0.04)";
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  function drawTinyWackyStar(x, y, r) {
    ctx.fillStyle = "#FFF8E1";
    ctx.beginPath();
    for (let i = 0; i < 5; i++) {
      const a = (i * Math.PI * 2) / 5;
      const rx = Math.cos(a) * r;
      const ry = Math.sin(a) * r;
      ctx.lineTo(x + rx, y + ry);
    }
    ctx.closePath();
    ctx.fill();
  }

  function drawTopUI() {
    // score at top-left
    const scoreText = `Delivered: ${gameState.correctCount}/${TARGET_CORRECT}`;
    ctx.font = `bold 18px ${FONT_FAMILY}`;
    const sw = ctx.measureText(scoreText).width;
    const boxW = sw + 20;
    const boxH = 34;
    const x = PADDING;
    const y = PADDING;
    ctx.fillStyle = "rgba(255,255,255,0.75)";
    roundRect(ctx, x, y, boxW, boxH, 8);
    ctx.fill();
    ctx.fillStyle = "#0B3954";
    ctx.fillText(scoreText, x + 10, y + 22);

    // lives top-right
    const livesText = `Lives: ${gameState.lives}`;
    ctx.font = `bold 18px ${FONT_FAMILY}`;
    const lw = ctx.measureText(livesText).width;
    const lx = WIDTH - PADDING - (lw + 20);
    const ly = PADDING;
    ctx.fillStyle = "rgba(255,255,255,0.75)";
    roundRect(ctx, lx, ly, lw + 20, 34, 8);
    ctx.fill();
    ctx.fillStyle = "#B22222";
    ctx.fillText(livesText, lx + 10, ly + 22);

    // sound toggle center top
    const soundText = gameState.soundEnabled ? "üîä Sound (S)" : "üîà Sound (S)";
    ctx.font = `16px ${FONT_FAMILY}`;
    const swt = ctx.measureText(soundText).width;
    const sx = (WIDTH - swt) / 2 - 8;
    const sy = PADDING;
    ctx.fillStyle = "rgba(255,255,255,0.75)";
    roundRect(ctx, sx - 8, sy, swt + 16, 34, 8);
    ctx.fill();
    ctx.fillStyle = "#073B4C";
    ctx.fillText(soundText, sx, sy + 22);
    // register region for clicks
    regions.soundToggle = { x: sx - 8, y: sy, w: swt + 16, h: 34 };
  }

  function drawPlayArea() {
    // border for play area
    ctx.save();
    ctx.strokeStyle = "rgba(11,57,80,0.08)";
    ctx.lineWidth = 2;
    roundRect(ctx, CENTER_AREA.x, CENTER_AREA.y, CENTER_AREA.w, CENTER_AREA.h, 12);
    ctx.stroke();
    ctx.restore();

    // Draw a visual "delivery zone" on the right side
    const dzx = CENTER_AREA.x + CENTER_AREA.w - 140;
    const dzy = CENTER_AREA.y + 40;
    ctx.fillStyle = "rgba(255,255,255,0.6)";
    roundRect(ctx, dzx, dzy, 120, CENTER_AREA.h - 80, 8);
    ctx.fill();
    // a little landing pad icon
    ctx.fillStyle = "#F9E79F";
    roundRect(ctx, dzx + 12, CENTER_AREA.y + CENTER_AREA.h - 120, 96, 36, 6);
    ctx.fill();
    ctx.fillStyle = "#8E44AD";
    ctx.font = `bold 16px ${FONT_FAMILY}`;
    ctx.fillText("Delivery Zone", dzx + 18, CENTER_AREA.y + CENTER_AREA.h - 94);

    // Draw some playful landmarks (trees/houses) left side to avoid overlap with UI
    ctx.fillStyle = "#C8E6C9";
    roundRect(ctx, CENTER_AREA.x + 12, CENTER_AREA.y + CENTER_AREA.h - 90, 70, 60, 8);
    ctx.fill();
    ctx.fillStyle = "#6A994E";
    roundRect(ctx, CENTER_AREA.x + 20, CENTER_AREA.y + CENTER_AREA.h - 120, 30, 30, 6);
    ctx.fill();
  }

  function drawSceneObjects() {
    // Draw package near delivery zone
    const pkgX = CENTER_AREA.x + CENTER_AREA.w - 110;
    const pkgY = CENTER_AREA.y + CENTER_AREA.h / 2 - 40;
    drawPackage(pkgX, pkgY, 60, 40);

    // Draw drone at gameState.droneX, droneY
    drawDrone(gameState.droneX, gameState.droneY, gameState.droneWobble);

    // Draw sparkles
    for (const a of gameState.animations) {
      if (a.type === "spark") {
        const age = performance.now() - a.born;
        if (age > a.life) continue;
        const t = age / a.life;
        ctx.globalAlpha = 1 - t;
        ctx.fillStyle = "#FFF59D";
        ctx.beginPath();
        ctx.arc(a.x + a.vx * t * 120, a.y + a.vy * t * 120, 2 + (1 - t) * 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }
  }

  function drawPackage(x, y, w, h) {
    ctx.save();
    ctx.fillStyle = "#FFDAB9";
    roundRect(ctx, x, y, w, h, 6);
    ctx.fill();
    ctx.strokeStyle = "#CC9966";
    ctx.lineWidth = 2;
    ctx.stroke();
    // ribbon
    ctx.fillStyle = "#FF6F61";
    ctx.fillRect(x + w / 2 - 4, y + 4, 8, h - 8);
    ctx.fillRect(x + 6, y + h / 2 - 4, w - 12, 8);
    ctx.restore();
  }

  function drawDrone(x, y, wobble) {
    ctx.save();
    ctx.translate(x, y);

    // bob / tilt based on wobble
    const tilt = wobble * 0.8;
    ctx.rotate(Math.sin(y / 50) * 0.02 - tilt);

    // body
    ctx.fillStyle = "#89CFF0";
    roundRect(ctx, -36, -18, 72, 36, 10);
    ctx.fill();

    // canopy
    ctx.beginPath();
    ctx.ellipse(0, -10, 28, 12, 0, Math.PI, 0);
    ctx.fillStyle = "#D9F1FF";
    ctx.fill();

    // face: wacky eyes
    ctx.fillStyle = "#073B4C";
    ctx.beginPath();
    ctx.arc(-12, -2, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(12, -2, 4, 0, Math.PI * 2);
    ctx.fill();

    // propellers (wacky squiggly)
    drawProp(-34, -18, wobble, 12);
    drawProp(34, -18, wobble, 12);
    drawProp(-34, 18, wobble, 12);
    drawProp(34, 18, wobble, 12);

    // legs
    ctx.strokeStyle = "#073B4C";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-14, 18);
    ctx.lineTo(-20, 28);
    ctx.moveTo(14, 18);
    ctx.lineTo(20, 28);
    ctx.stroke();

    ctx.restore();
  }

  function drawProp(cx, cy, wobble, r) {
    ctx.save();
    ctx.translate(cx, cy);
    const spin = performance.now() / 80 + Math.random() * 0.2;
    ctx.rotate(spin);
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "#F6F8FF";
    ctx.beginPath();
    ctx.ellipse(0, 0, r * (1 + wobble * 0.6), r / 3, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1.0;
    ctx.restore();
  }

  function drawProblemArea() {
    // Problem text centered in the play area (not overlapping top or bottom)
    const probText = `${gameState.currentProblem.a} ${gameState.currentProblem.op} ${gameState.currentProblem.b} = ?`;
    ctx.font = `bold 32px ${FONT_FAMILY}`;
    const pw = measureText(probText, 32, "bold");
    const px = CENTER_AREA.x + (CENTER_AREA.w - pw) / 2;
    const py = CENTER_AREA.y + 60;
    // background box
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    const pad = 16;
    roundRect(ctx, px - pad, py - 36, pw + pad * 2, 56, 10);
    ctx.fill();
    // text
    ctx.fillStyle = "#052A3A";
    ctx.fillText(probText, px, py);

    // Input box
    const inputW = 160;
    const inputH = 44;
    const ix = CENTER_AREA.x + (CENTER_AREA.w - inputW) / 2;
    const iy = py + 36;
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    roundRect(ctx, ix, iy, inputW, inputH, 8);
    ctx.fill();
    ctx.strokeStyle = "#A3D5FF";
    ctx.stroke();

    // Text inside input
    ctx.font = `20px ${FONT_FAMILY}`;
    ctx.fillStyle = "#073B4C";
    const inputDisplay = gameState.inputText.length ? gameState.inputText : "Type answer...";
    ctx.fillText(inputDisplay, ix + 12, iy + 28);

    // OK button to the right
    const okW = 80;
    const okH = inputH;
    const okx = ix + inputW + 12;
    const oky = iy;
    ctx.fillStyle = "#6EE7B7";
    roundRect(ctx, okx, oky, okW, okH, 8);
    ctx.fill();
    ctx.fillStyle = "#05386B";
    ctx.font = `bold 18px ${FONT_FAMILY}`;
    ctx.fillText("OK", okx + okW / 2 - 12, oky + 28);
    regions.okButton = { x: okx, y: oky, w: okW, h: okH };

    // Message under input
    ctx.font = `16px ${FONT_FAMILY}`;
    ctx.fillStyle = "#073B4C";
    const msg = gameState.message;
    const mw = measureText(msg, 16);
    const mx = CENTER_AREA.x + (CENTER_AREA.w - mw) / 2;
    const my = iy + inputH + 22;
    ctx.fillText(msg, mx, my);

    // Draw keypad as optional clickable area below to assist children
    drawKeypad(ix, iy + inputH + 36);
  }

  function drawKeypad(x, y) {
    // grid 3x4 for digits 1-9, 0, backspace
    const btnW = 56;
    const btnH = 44;
    const gap = 10;
    ctx.font = `18px ${FONT_FAMILY}`;
    regions.keypadButtons = [];
    const numbers = [
      ["1", "2", "3"],
      ["4", "5", "6"],
      ["7", "8", "9"],
      ["‚Üê", "0", "‚Üµ"],
    ];
    for (let r = 0; r < numbers.length; r++) {
      for (let c = 0; c < numbers[r].length; c++) {
        const bx = x + c * (btnW + gap);
        const by = y + r * (btnH + gap);
        ctx.fillStyle = "rgba(255,255,255,0.92)";
        roundRect(ctx, bx, by, btnW, btnH, 8);
        ctx.fill();
        ctx.strokeStyle = "#E6EEF3";
        ctx.stroke();
        ctx.fillStyle = "#075985";
        ctx.fillText(numbers[r][c], bx + btnW / 2 - measureText(numbers[r][c], 18) / 2, by + 28);
        regions.keypadButtons.push({ x: bx, y: by, w: btnW, h: btnH, value: numbers[r][c] });
      }
    }
    // ensure enough spacing between keypad and bottom instructions
  }

  function drawBottomInstructions() {
    const instrLines = [
      "Controls: Type digits, Backspace to delete, Enter/OK to submit.",
      "Keyboard shortcuts: S = toggle sound, R = restart after game ends.",
      "Goal: Deliver 10 packages. Fail after 3 wrong answers.",
    ];
    ctx.font = `16px ${FONT_FAMILY}`;
    // compute total height and center
    const lineHeight = 20;
    const totalH = instrLines.length * lineHeight;
    let startY = HEIGHT - BOTTOM_UI_HEIGHT + (BOTTOM_UI_HEIGHT - totalH) / 2;
    for (let i = 0; i < instrLines.length; i++) {
      const txt = instrLines[i];
      const tw = measureText(txt, 16);
      const tx = (WIDTH - tw) / 2;
      // draw background rectangle for readability
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      roundRect(ctx, tx - 10, startY - 14, tw + 20, lineHeight + 6, 8);
      ctx.fill();
      ctx.fillStyle = "#052A3A";
      ctx.fillText(txt, tx, startY + lineHeight - 4);
      startY += lineHeight;
    }
  }

  function drawEndScreen() {
    // draw translucent overlay
    ctx.fillStyle = "rgba(5,42,58,0.5)";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // big central card
    const cardW = 520;
    const cardH = 260;
    const cx = (WIDTH - cardW) / 2;
    const cy = (HEIGHT - cardH) / 2;
    ctx.fillStyle = "rgba(255,255,255,0.98)";
    roundRect(ctx, cx, cy, cardW, cardH, 12);
    ctx.fill();

    // title
    ctx.font = `bold 28px ${FONT_FAMILY}`;
    ctx.fillStyle = "#052A3A";
    const title = gameState.endState === "win" ? "Victory!" : "Game Over";
    const tw = measureText(title, 28, "bold");
    ctx.fillText(title, cx + (cardW - tw) / 2, cy + 54);

    // message
    ctx.font = `18px ${FONT_FAMILY}`;
    ctx.fillStyle = "#073B4C";
    const msg = gameState.message;
    const mw = measureText(msg, 18);
    ctx.fillText(msg, cx + (cardW - mw) / 2, cy + 92);

    // score summary
    const summary = `Delivered: ${gameState.correctCount}. Mistakes: ${gameState.wrongCount}.`;
    ctx.fillText(summary, cx + (cardW - measureText(summary, 18)) / 2, cy + 126);

    // restart button
    const btnW = 160;
    const btnH = 44;
    const bx = cx + (cardW - btnW) / 2;
    const by = cy + cardH - 84;
    ctx.fillStyle = "#6EE7B7";
    roundRect(ctx, bx, by, btnW, btnH, 10);
    ctx.fill();
    ctx.fillStyle = "#05386B";
    ctx.font = `bold 18px ${FONT_FAMILY}`;
    const label = "Restart (R)";
    ctx.fillText(label, bx + (btnW - measureText(label, 18, "bold")) / 2, by + 28);

    regions.restartButton = { x: bx, y: by, w: btnW, h: btnH };
  }

  // Input handling
  canvas.addEventListener("keydown", (e) => {
    // Make sure canvas has focus.
    // Allow number keys, backspace, enter, s, r
    if (!e.key) return;
    if (e.key >= "0" && e.key <= "9") {
      if (!gameState.running && gameState.endState) return; // ignore input in end screen
      if (gameState.inputText.length < 6) {
        gameState.inputText += e.key;
        playClick();
      }
      e.preventDefault();
    } else if (e.key === "Backspace") {
      gameState.inputText = gameState.inputText.slice(0, -1);
      playClick();
      e.preventDefault();
    } else if (e.key === "Enter") {
      submitAnswer();
      e.preventDefault();
    } else if (e.key.toLowerCase() === "s") {
      // toggle sound
      setSoundEnabled(!gameState.soundEnabled);
      playClick();
      e.preventDefault();
    } else if (e.key.toLowerCase() === "r") {
      if (!gameState.running && gameState.endState) {
        resetGame();
        playClick();
      } else {
        // also allow restart anytime
        resetGame();
        playClick();
      }
    } else if (e.key === "-" || e.key === "+") {
      // allow negative sign if needed
      if (gameState.inputText.length === 0) {
        gameState.inputText = e.key;
        playClick();
      }
    }
  });

  // Mouse / pointer input
  canvas.addEventListener("click", function (ev) {
    const rect = canvas.getBoundingClientRect();
    const mx = (ev.clientX - rect.left) * (canvas.width / rect.width);
    const my = (ev.clientY - rect.top) * (canvas.height / rect.height);
    // sound toggle region
    if (regions.soundToggle && pointInRect(mx, my, regions.soundToggle)) {
      setSoundEnabled(!gameState.soundEnabled);
      playClick();
      return;
    }
    // ok button
    if (regions.okButton && pointInRect(mx, my, regions.okButton)) {
      submitAnswer();
      playClick();
      return;
    }
    // keypad buttons
    for (const b of regions.keypadButtons) {
      if (pointInRect(mx, my, b)) {
        if (b.value === "‚Üê") {
          gameState.inputText = gameState.inputText.slice(0, -1);
        } else if (b.value === "‚Üµ") {
          submitAnswer();
        } else {
          if (gameState.inputText.length < 6) gameState.inputText += b.value;
        }
        playClick();
        return;
      }
    }
    // restart button
    if (regions.restartButton && pointInRect(mx, my, regions.restartButton)) {
      resetGame();
      playClick();
      return;
    }

    // Click on canvas elsewhere focuses canvas for keyboard control and optionally toggles audio resume
    canvas.focus();
    // try to resume audio if suspended
    if (ensureAudio()) startBackgroundHum();
  });

  function pointInRect(px, py, r) {
    return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;
  }

  // Input accessibility: display audio error message if audio blocked
  function drawAudioErrorInfo() {
    if (!audioCtx && gameState.audioError) {
      ctx.font = `14px ${FONT_FAMILY}`;
      const msg = "Audio not available: " + gameState.audioError;
      const w = measureText(msg, 14);
      const x = WIDTH - w - 12;
      const y = HEIGHT - 20;
      ctx.fillStyle = "rgba(255,255,255,0.8)";
      roundRect(ctx, x - 8, y - 16, w + 16, 20, 6);
      ctx.fill();
      ctx.fillStyle = "#4A4A4A";
      ctx.fillText(msg, x, y);
    }
  }

  // Main animation frame
  function frame(now) {
    if (!gameState.lastTick) gameState.lastTick = now;
    const dt = now - gameState.lastTick;
    gameState.lastTick = now;
    try {
      update(dt);
      render();
      drawAudioErrorInfo();
    } catch (e) {
      console.error("Render/update error", e);
      // stop the loop on unexpected errors
      return;
    }
    requestAnimationFrame(frame);
  }

  // Initialize
  canvas.style.outline = "none";
  canvas.focus();
  resetGame();
  if (ensureAudio()) startBackgroundHum();
  requestAnimationFrame(frame);

  // Utility: expose some handy console control (for debugging only)
  window._droneMathGame = {
    state: gameState,
    reset: resetGame,
  };

  // Proper error handling for resource loading: none external used; audio errors handled.

})();
---

