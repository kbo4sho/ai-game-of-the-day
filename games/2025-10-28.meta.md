# Game of the Day - 2025-10-28

## Metadata
- **Generated Date:** 2025-10-28
- **Generated Time:** 2025-10-28T00:26:57.136389
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-10-28.js
- **File Size:** 24132 bytes
- **Tokens Used:** 8613

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-10-28.js` - The playable game
- `2025-10-28.meta.json` - Machine-readable metadata
- `2025-10-28.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 16867

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 17981

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Drone Math Adventure
  // Renders inside element with id "game-of-the-day-stage"
  // All graphics drawn on canvas, sounds via Web Audio API
  // Accessible text placed inside the same container for screen readers

  // Config
  const WIDTH = 720;
  const HEIGHT = 480;
  const GOAL_CORRECT = 10;
  const MAX_WRONG = 3;
  const PADDING = 12; // min spacing / padding for UI elements

  // Get container
  const container = document.getElementById("game-of-the-day-stage");
  if (!container) {
    console.error("Container with id 'game-of-the-day-stage' not found.");
    return;
  }
  // Clear and set up container styles (keeps render inside)
  container.innerHTML = "";
  container.style.position = "relative";
  container.style.width = WIDTH + "px";
  container.style.height = HEIGHT + "px";
  container.tabIndex = 0; // allow keyboard focus

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.width = WIDTH + "px";
  canvas.style.height = HEIGHT + "px";
  canvas.style.outline = "none";
  container.appendChild(canvas);
  const ctx = canvas.getContext("2d");

  // Accessibility: ARIA live region for screen readers and instructions
  const live = document.createElement("div");
  live.setAttribute("role", "status");
  live.setAttribute("aria-live", "polite");
  live.style.position = "absolute";
  live.style.left = "8px";
  live.style.top = (HEIGHT + 5) + "px"; // placed inside container? We set just below — but must stay inside. Instead hide visually but keep for screen readers.
  live.style.height = "1px";
  live.style.width = "1px";
  live.style.overflow = "hidden";
  live.style.clip = "rect(1px, 1px, 1px, 1px)";
  live.style.whiteSpace = "nowrap";
  container.appendChild(live);

  // Game state
  let score = 0;
  let wrong = 0;
  let question = null; // { text, correct, choices: [..] }
  let selectedIndex = 0;
  let answeredCount = 0;
  let stage = "playing"; // playing, won, lost
  let hoverIndex = -1;
  let audioEnabled = true;
  let audioAvailable = true;
  let lastActionMessage = "";

  // Drone position
  const drone = {
    x: WIDTH / 2,
    y: HEIGHT - 120,
    targetX: WIDTH / 2,
    targetY: HEIGHT - 120,
    speed: 6
  };

  // Answer bubble positions (4 around center)
  const answerPositions = [
    { x: WIDTH / 2 - 180, y: HEIGHT / 2 - 10 },
    { x: WIDTH / 2 + 180, y: HEIGHT / 2 - 10 },
    { x: WIDTH / 2 - 90, y: HEIGHT / 2 + 120 },
    { x: WIDTH / 2 + 90, y: HEIGHT / 2 + 120 }
  ];

  // Colors (calming pastels)
  const palette = {
    bg: "#f6fbff",
    panel: "#ffffff",
    soft: "#cfeaf0",
    accent: "#8ecae6",
    correct: "#9be7a8",
    wrong: "#ffb4a2",
    text: "#073b4c",
    drone: "#ffd166",
    prop: "#a7c5bd",
    star: "#ffe066"
  };

  // Fonts
  const fonts = {
    important: "20px sans-serif",
    body: "16px sans-serif",
    small: "14px sans-serif",
    title: "24px sans-serif"
  };

  // Web Audio setup with error handling
  let audioCtx;
  let masterGain;
  let ambientOsc;
  try {
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if (!AudioCtx) throw new Error("Web Audio API not supported");
    audioCtx = new AudioCtx();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.7;
    masterGain.connect(audioCtx.destination);
    // gentle ambient hum (very low)
    ambientOsc = audioCtx.createOscillator();
    const ambientGain = audioCtx.createGain();
    ambientOsc.type = "sine";
    ambientOsc.frequency.value = 120; // low hum
    ambientGain.gain.value = 0.0035; // very subtle
    ambientOsc.connect(ambientGain);
    ambientGain.connect(masterGain);
    ambientOsc.start(0);
  } catch (e) {
    console.warn("Audio unavailable:", e);
    audioAvailable = false;
    audioEnabled = false;
  }

  function tryResumeAudio() {
    if (!audioAvailable || !audioCtx) return;
    if (audioCtx.state === "suspended") {
      audioCtx.resume().catch(() => {});
    }
  }

  // Sound helpers using oscillators and envelopes
  function playBeep(freq = 880, type = "sine", duration = 0.18, volume = 0.18) {
    if (!audioAvailable || !audioEnabled) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      o.connect(g);
      g.connect(masterGain);
      const now = audioCtx.currentTime;
      g.gain.setValueAtTime(0, now);
      g.gain.exponentialRampToValueAtTime(volume, now + 0.01);
      o.start(now);
      g.gain.exponentialRampToValueAtTime(0.001, now + duration);
      o.stop(now + duration + 0.02);
    } catch (e) {
      console.warn("playBeep error", e);
    }
  }

  function playCorrectSound() {
    // Pleasant triad quick melody
    if (!audioAvailable || !audioEnabled) return;
    try {
      const now = audioCtx.currentTime;
      playToneAt(660, 0.09, now);
      playToneAt(880, 0.09, now + 0.09);
      playToneAt(990, 0.12, now + 0.18);
    } catch (e) {
      console.warn("correct sound error", e);
    }
  }
  function playWrongSound() {
    if (!audioAvailable || !audioEnabled) return;
    try {
      const now = audioCtx.currentTime;
      playToneAt(220, 0.2, now, "sawtooth", 0.12);
    } catch (e) {
      console.warn("wrong sound error", e);
    }
  }
  function playMoveSound() {
    if (!audioAvailable || !audioEnabled) return;
    playBeep(450, "triangle", 0.08, 0.06);
  }
  function playToneAt(freq, dur = 0.1, when = 0, type = "sine", vol = 0.12) {
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.value = freq;
    o.connect(g);
    g.connect(masterGain);
    g.gain.setValueAtTime(0.001, when);
    g.gain.exponentialRampToValueAtTime(vol, when + 0.01);
    g.gain.exponentialRampToValueAtTime(0.001, when + dur);
    o.start(when);
    o.stop(when + dur + 0.02);
  }

  // Game logic: generate question suitable for ages 7-9
  function generateQuestion() {
    // Types: addition/subtraction within 0-20, simple multiplication by 2-5
    const type = Math.random();
    let a, b, text, correct;
    if (type < 0.45) {
      // addition
      a = randInt(1, 20);
      b = randInt(1, Math.min(20, 20 - a));
      correct = a + b;
      text = `${a} + ${b} = ?`;
    } else if (type < 0.85) {
      // subtraction
      a = randInt(2, 20);
      b = randInt(1, a - 1);
      correct = a - b;
      text = `${a} - ${b} = ?`;
    } else {
      // multiplication small
      a = randInt(2, 7);
      b = randInt(2, 5);
      correct = a * b;
      text = `${a} × ${b} = ?`;
    }

    // Generate 3 distractors
    const choices = new Set([correct]);
    while (choices.size < 4) {
      let delta = randInt(-5, 5);
      if (delta === 0) delta = 1;
      let val = correct + delta;
      if (val < 0) val = correct + Math.abs(delta) + 1;
      choices.add(val);
    }
    const arr = shuffle(Array.from(choices));
    return { text, correct, choices: arr };
  }

  // Utility functions
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  function shuffle(a) {
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  // Initialize first question
  function nextQuestion() {
    question = generateQuestion();
    selectedIndex = 0;
    hoverIndex = -1;
    // announce for accessibility
    announce(`New question: ${question.text}. Use arrow keys or click an answer. Press Enter to choose.`);
  }

  function announce(text) {
    lastActionMessage = text;
    tryResumeAudio();
    live.textContent = text;
  }

  // Drawing helpers that ensure no overlap using measureText for backgrounds
  function drawTextWithPanel(text, x, y, font, textColor, bgColor, padding = 10, align = "left") {
    ctx.font = font;
    const metrics = ctx.measureText(text);
    const w = Math.ceil(metrics.width);
    const h = parseInt(font, 10) || 16;
    let rectX = x;
    if (align === "center") rectX = x - (w / 2) - padding;
    if (align === "right") rectX = x - (w + padding * 2);
    const rectY = y - h - padding / 2;
    ctx.fillStyle = bgColor;
    roundRect(ctx, rectX, rectY, w + padding * 2, h + padding, 6).fill();
    ctx.fillStyle = textColor;
    ctx.textAlign = align;
    ctx.textBaseline = "top";
    ctx.fillText(text, align === "center" ? x : (rectX + padding), rectY + (padding / 4));
    // return dims to allow spacing checks
    return { x: rectX, y: rectY, w: w + padding * 2, h: h + padding };
  }

  // Round rect helper returning ctx for chaining
  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    return ctx;
  }

  // Draw calming background and wacky clouds/whimsical props
  function drawBackground() {
    // soft gradient sky
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, "#f0fbff");
    g.addColorStop(1, "#f6fbff");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // floating bubbly shapes
    for (let i = 0; i < 6; i++) {
      const cx = (i * 123 + 40) % WIDTH;
      const cy = 40 + (i % 3) * 30;
      ctx.fillStyle = `rgba(140,202,230,0.08)`;
      ctx.beginPath();
      ctx.ellipse(cx, cy, 60, 28, Math.sin((i + Date.now() / 2000)), 0, Math.PI * 2);
      ctx.fill();
    }

    // distant wacky mountains
    ctx.fillStyle = palette.soft;
    ctx.beginPath();
    ctx.moveTo(0, HEIGHT - 160);
    ctx.quadraticCurveTo(100, HEIGHT - 260, 180, HEIGHT - 160);
    ctx.quadraticCurveTo(280, HEIGHT - 80, 360, HEIGHT - 160);
    ctx.quadraticCurveTo(460, HEIGHT - 260, 540, HEIGHT - 160);
    ctx.quadraticCurveTo(620, HEIGHT - 80, WIDTH, HEIGHT - 160);
    ctx.lineTo(WIDTH, HEIGHT);
    ctx.lineTo(0, HEIGHT);
    ctx.closePath();
    ctx.fill();
  }

  // Draw drone
  function drawDrone(x, y) {
    // shadow
    ctx.fillStyle = "rgba(0,0,0,0.08)";
    ctx.beginPath();
    ctx.ellipse(x, y + 24, 44, 10, 0, 0, Math.PI * 2);
    ctx.fill();

    // body
    ctx.fillStyle = palette.drone;
    roundRect(ctx, x - 40, y - 18, 80, 36, 12).fill();
    // cockpit window
    ctx.fillStyle = palette.panel;
    roundRect(ctx, x - 20, y - 14, 40, 28, 8).fill();
    // antenna
    ctx.strokeStyle = palette.text;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x + 18, y - 8);
    ctx.lineTo(x + 30, y - 28);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(x + 30, y - 28, 3, 0, Math.PI * 2);
    ctx.fillStyle = palette.accent;
    ctx.fill();

    // propellers (wacky rounded discs)
    const props = [
      { dx: -42, dy: -28 },
      { dx: 42, dy: -28 },
      { dx: -42, dy: 28 },
      { dx: 42, dy: 28 }
    ];
    props.forEach((p, i) => {
      const angle = ((Date.now() / 80) + i * 90) % 360;
      ctx.save();
      ctx.translate(x + p.dx, y + p.dy);
      ctx.rotate((angle * Math.PI) / 180);
      ctx.fillStyle = palette.prop;
      ctx.beginPath();
      ctx.ellipse(0, 0, 26, 8, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    });

    // small wacky sticker
    ctx.font = "12px sans-serif";
    ctx.fillStyle = palette.text;
    ctx.textAlign = "center";
    ctx.fillText("DRØN", x, y + 4);
  }

  // Draw answer bubbles
  function drawAnswerBubble(idx, text, isSelected, isHover) {
    const pos = answerPositions[idx];
    // measure text
    ctx.font = fonts.body;
    const m = ctx.measureText(String(text));
    const w = Math.max(60, m.width + 28);
    const h = 44;
    const radius = Math.max(36, Math.ceil(Math.max(w, h) / 2));
    // bubble
    ctx.beginPath();
    ctx.fillStyle = isSelected ? "#fff7e6" : "#ffffff";
    ctx.strokeStyle = isHover ? palette.accent : "#d6eaf0";
    ctx.lineWidth = isSelected ? 4 : 2;
    roundRect(ctx, pos.x - radius, pos.y - radius, radius * 2, radius * 2, 18).fill();
    roundRect(ctx, pos.x - radius, pos.y - radius, radius * 2, radius * 2, 18).stroke();
    // wacky icon: little crate/star
    ctx.fillStyle = palette.star;
    ctx.beginPath();
    ctx.moveTo(pos.x - radius + 14, pos.y - 6);
    ctx.lineTo(pos.x - radius + 20, pos.y - 14);
    ctx.lineTo(pos.x - radius + 26, pos.y - 6);
    ctx.lineTo(pos.x - radius + 18, pos.y - 2);
    ctx.closePath();
    ctx.fill();
    // text
    ctx.fillStyle = palette.text;
    ctx.font = fonts.important;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(String(text), pos.x, pos.y);
    return { x: pos.x - radius, y: pos.y - radius, w: radius * 2, h: radius * 2 };
  }

  // UI Draw ensuring non-overlap
  function drawUI() {
    // Score top-left
    const scoreText = `Correct: ${score}/${GOAL_CORRECT}`;
    const scorePanel = drawTextWithPanel(scoreText, PADDING + 8, PADDING + 26, fonts.title, palette.text, palette.panel, 12, "left");

    // Lives top-right
    const livesText = `Lives: ${Math.max(0, MAX_WRONG - wrong)}`;
    ctx.textAlign = "right";
    const livesPanel = drawTextWithPanel(livesText, WIDTH - (PADDING + 8), PADDING + 26, fonts.title, palette.text, palette.panel, 12, "right");

    // Audio icon small panel next to lives (right side)
    const audioWidth = 130;
    const audioX = WIDTH - (livesPanel.w + PADDING * 2 + 10) - audioWidth;
    ctx.fillStyle = palette.panel;
    roundRect(ctx, audioX, 8, audioWidth, 36, 8).fill();
    ctx.fillStyle = palette.text;
    ctx.font = fonts.small;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    const audioLabel = audioAvailable ? (audioEnabled ? "Audio: On (M)" : "Audio: Off (M)") : "Audio: Unavailable";
    ctx.fillText(audioLabel, audioX + 12, 26);

    // Question top-center (important)
    ctx.font = fonts.title;
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    // ensure not overlapping with top UI elements: measure width
    const qMetrics = ctx.measureText(question ? question.text : "Loading...");
    const qW = qMetrics.width;
    const qX = WIDTH / 2;
    const qY = 70;
    // draw panel behind
    roundRect(ctx, qX - qW / 2 - 18, qY - 8, qW + 36, 44, 10).fillStyle = palette.panel;
    ctx.fillStyle = palette.panel;
    roundRect(ctx, qX - qW / 2 - 18, qY - 8, qW + 36, 44, 10).fill();
    ctx.fillStyle = palette.text;
    ctx.fillText(question ? question.text : "Loading...", qX, qY);

    // Instructions bottom-center
    const instr = "Use Arrow Keys to move, Enter to pick, Click a bubble, M toggles audio, R restarts";
    ctx.font = fonts.small;
    const im = ctx.measureText(instr);
    const ipW = im.width;
    const ipX = WIDTH / 2 - ipW / 2 - 12;
    const ipY = HEIGHT - 56;
    ctx.fillStyle = palette.panel;
    roundRect(ctx, ipX, ipY, ipW + 24, 38, 8).fill();
    ctx.fillStyle = palette.text;
    ctx.textAlign = "center";
    ctx.fillText(instr, WIDTH / 2, ipY + 9);

    // Last action message (accessibility) above instructions
    ctx.font = fonts.small;
    const am = ctx.measureText(lastActionMessage);
    if (lastActionMessage) {
      const amW = am.width;
      const amX = WIDTH / 2 - amW / 2 - 12;
      const amY = HEIGHT - 100;
      ctx.fillStyle = palette.panel;
      roundRect(ctx, amX, amY, amW + 24, 32, 8).fill();
      ctx.fillStyle = palette.text;
      ctx.fillText(lastActionMessage, WIDTH / 2, amY + 6);
    }
  }

  // Main render
  function render() {
    // Clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    drawBackground();

    // Draw question area and bubbles
    // Panel behind answers
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    roundRect(ctx, WIDTH / 2 - 320, HEIGHT / 2 - 140, 640, 260, 14).fill();

    // Draw choices
    let bubbleRects = [];
    if (question) {
      for (let i = 0; i < 4; i++) {
        const isSelected = i === selectedIndex;
        const isHover = i === hoverIndex;
        bubbleRects.push(drawAnswerBubble(i, question.choices[i], isSelected, isHover));
      }
    }

    // Move drone toward target
    const dx = drone.targetX - drone.x;
    const dy = drone.targetY - drone.y;
    const dist = Math.hypot(dx, dy);
    if (dist > 1) {
      drone.x += (dx / dist) * Math.min(drone.speed, dist);
      drone.y += (dy / dist) * Math.min(drone.speed, dist);
    } else {
      drone.x = drone.targetX;
      drone.y = drone.targetY;
    }

    // Draw drone
    drawDrone(drone.x, drone.y);

    // Draw UI
    drawUI();

    // Draw score progress bar center-bottom
    const progressW = 300;
    const progressX = WIDTH / 2 - progressW / 2;
    const progressY = HEIGHT - 140;
    ctx.fillStyle = "#eaf6f9";
    roundRect(ctx, progressX, progressY, progressW, 18, 10).fill();
    const pct = Math.min(1, score / GOAL_CORRECT);
    ctx.fillStyle = palette.accent;
    roundRect(ctx, progressX, progressY, Math.max(6, progressW * pct), 18, 10).fill();

    // Victory or Game Over screen overlays
    if (stage === "won") {
      drawEndScreen(true);
    } else if (stage === "lost") {
      drawEndScreen(false);
    }
  }

  function drawEndScreen(won) {
    // translucent overlay
    ctx.fillStyle = "rgba(7,59,76,0.28)";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    // panel
    const panelW = 520;
    const panelH = 260;
    const px = WIDTH / 2 - panelW / 2;
    const py = HEIGHT / 2 - panelH / 2;
    ctx.fillStyle = "#ffffff";
    roundRect(ctx, px, py, panelW, panelH, 18).fill();
    // Text
    ctx.fillStyle = palette.text;
    ctx.font = fonts.title;
    ctx.textAlign = "center";
    ctx.fillText(won ? "Victory! Drone Mission Complete" : "Game Over — Drone Landed", WIDTH / 2, py + 26);

    ctx.font = fonts.important;
    ctx.fillText(won ? `You answered ${score} correct!` : `You answered ${score} correct and had ${wrong} wrong.`, WIDTH / 2, py + 70);

    // tip or encouragement
    ctx.font = fonts.body;
    ctx.fillText(won ? "Great flying! Press R or click Restart to fly again." : "Try again! Press R or click Restart to retry.", WIDTH / 2, py + 108);

    // Draw restart button
    const btnW = 160;
    const btnH = 44;
    const bx = WIDTH / 2 - btnW / 2;
    const by = py + panelH - 76;
    ctx.fillStyle = palette.accent;
    roundRect(ctx, bx, by, btnW, btnH, 10).fill();
    ctx.fillStyle = "#072a2a";
    ctx.font = fonts.important;
    ctx.fillText("Restart (R)", WIDTH / 2, by + 12);

    // Save restart button rect for clicks
    endButtonRect = { x: bx, y: by, w: btnW, h: btnH };
  }

  // Interaction handlers
  let endButtonRect = null;

  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    // hover detection on answer bubbles
    hoverIndex = -1;
    for (let i = 0; i < answerPositions.length; i++) {
      const p = answerPositions[i];
      const dx = mx - p.x;
      const dy = my - p.y;
      if (Math.hypot(dx, dy) <= 48) {
        hoverIndex = i;
        break;
      }
    }
    canvas.style.cursor = hoverIndex >= 0 ? "pointer" : "default";
  });

  canvas.addEventListener("click", (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    // If end screen showing, check restart button
    if (stage === "won" || stage === "lost") {
      if (endButtonRect && mx >= endButtonRect.x && mx <= endButtonRect.x + endButtonRect.w && my >= endButtonRect.y && my <= endButtonRect.y + endButtonRect.h) {
        restartGame();
        return;
      }
    }

    // if clicking on answer bubble, select that index and confirm
    for (let i = 0; i < answerPositions.length; i++) {
      const p = answerPositions[i];
      if (Math.hypot(mx - p.x, my - p.y) <= 48) {
        // move drone to it
        selectIndex(i);
        confirmSelection();
        return;
      }
    }
  });

  function selectIndex(i) {
    selectedIndex = i;
    const pos = answerPositions[i];
    drone.targetX = pos.x;
    drone.targetY = pos.y - 90; // hover above bubble
    playMoveSound();
  }

  window.addEventListener("keydown", (e) => {
    // provide keyboard controls; container must be focused
    const key = e.key;
    if (stage === "playing") {
      if (key === "ArrowLeft" || key === "ArrowUp") {
        selectedIndex = (selectedIndex + 3) % 4;
        selectIndex(selectedIndex);
        e.preventDefault();
      } else if (key === "ArrowRight" || key === "ArrowDown") {
        selectedIndex = (selectedIndex + 1) % 4;
        selectIndex(selectedIndex);
        e.preventDefault();
      } else if (key === "Enter" || key === " ") {
        confirmSelection();
        e.preventDefault();
      } else if (key.toLowerCase() === "m") {
        audioEnabled = !audioEnabled;
        if (audioEnabled) tryResumeAudio();
        announce(`Audio ${audioEnabled ? "enabled" : "muted"}.`);
      } else if (key.toLowerCase() === "r") {
        restartGame();
      }
    } else {
      // ended: allow restart
      if (key.toLowerCase() === "r" || key === "Enter") {
        restartGame();
      }
      if (key.toLowerCase() === "m") {
        audioEnabled = !audioEnabled;
        announce(`Audio ${audioEnabled ? "enabled" : "muted"}.`);
      }
    }
  });

  function confirmSelection() {
    if (!question || stage !== "playing") return;
    const chosen = question.choices[selectedIndex];
    answeredCount++;
    // Visual feedback: move drone to bubble and small bounce
    drone.targetX = answerPositions[selectedIndex].x;
    drone.targetY = answerPositions[selectedIndex].y - 90;

    if (chosen === question.correct) {
      score++;
      playCorrectSound();
      announce(`Correct! ${question.correct}. ${score} out of ${GOAL_CORRECT}.`);
    } else {
      wrong++;
      playWrongSound();
      announce(`Oops! ${chosen} is not correct. The right answer was ${question.correct}. Lives left: ${Math.max(0, MAX_WRONG - wrong)}.`);
    }

    // brief delay before next question to allow feedback
    if (score >= GOAL_CORRECT) {
      setTimeout(() => {
        stage = "won";
        announce("Victory! You completed the mission. Press R to play again.");
      }, 600);
    } else if (wrong >= MAX_WRONG) {
      setTimeout(() => {
        stage = "lost";
        announce("Game Over. Press R to try again.");
      }, 600);
    } else {
      setTimeout(() => {
        nextQuestion();
      }, 700);
    }
  }

  function restartGame() {
    score = 0;
    wrong = 0;
    answeredCount = 0;
    stage = "playing";
    selectedIndex = 0;
    drone.x = WIDTH / 2;
    drone.y = HEIGHT - 120;
    drone.targetX = drone.x;
    drone.targetY = drone.y;
    announce("Game restarted. Good luck!");
    nextQuestion();
  }

  // Initialize
  try {
    nextQuestion();
  } catch (e) {
    console.error("Question generation failed", e);
    announce("Error initializing the game. Try reloading the page.");
    stage = "lost";
  }

  // Animation loop
  let lastRender = 0;
  function loop(ts) {
    render();
    lastRender = ts;
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Ensure container focus for keyboard controls accessibility
  container.addEventListener("click", () => {
    container.focus();
    tryResumeAudio();
  });

  // Expose some debug to console (not necessary)
  window.__droneMathGame = {
    restart: restartGame,
    getState: () => ({ score, wrong, stage, question }),
    toggleAudio: () => { audioEnabled = !audioEnabled; }
  };

  // Error handling for resource issues (audio context state change)
  if (audioAvailable && audioCtx) {
    audioCtx.onstatechange = () => {
      if (audioCtx.state === "suspended") {
        audioEnabled = false;
        announce("Audio suspended by browser. Press any key to enable sounds.");
      } else {
        audioEnabled = true;
      }
    };
  }

  // Announce initial instructions
  announce("Welcome to Drone Math Adventure! Answer 10 questions correctly. You can make 3 mistakes. Click to focus. Use arrows and Enter or click answers. Press M to toggle audio. Good luck!");
})();
---

