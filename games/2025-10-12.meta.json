{
  "generated_date": "2025-10-12",
  "generated_timestamp": "2025-10-12T00:28:21.093672",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9445,
  "game_filename": "2025-10-12.js",
  "game_size_bytes": 27716,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Machine Math \u2014 a cheerful, calm math game for ages 7-9\n  // Renders inside #game-of-the-day-stage and uses canvas + WebAudio API\n  // Only canvas drawing, no external files. Keyboard accessible.\n\n  // CONFIG\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const ROUNDS_TO_WIN = 3;\n  const MAX_GEARS = 4;\n  const SLOT_COUNT = 3;\n\n  // Get container\n  const container = document.getElementById(\"game-of-the-day-stage\");\n  if (!container) {\n    console.error(\"Container element #game-of-the-day-stage not found.\");\n    return;\n  }\n  // Clear container and prepare\n  container.innerHTML = \"\";\n  container.style.position = \"relative\";\n\n  // Create canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.width = WIDTH + \"px\";\n  canvas.style.height = HEIGHT + \"px\";\n  canvas.tabIndex = 0; // make focusable for keyboard controls\n  canvas.setAttribute(\"role\", \"application\");\n  canvas.setAttribute(\n    \"aria-label\",\n    \"Machine Math: drag or use keyboard to place gears to sum to the target number. Press Tab to cycle gears, Enter to pick/place, Space to restart.\"\n  );\n  container.appendChild(canvas);\n  const ctx = canvas.getContext(\"2d\");\n\n  // Audio setup with error handling\n  let audioContext = null;\n  let masterGain = null;\n  let bgOsc = null;\n  let bgGain = null;\n  let audioAvailable = false;\n  try {\n    const AudioContext = window.AudioContext || window.webkitAudioContext;\n    if (AudioContext) {\n      audioContext = new AudioContext();\n      masterGain = audioContext.createGain();\n      masterGain.gain.value = 0.8;\n      masterGain.connect(audioContext.destination);\n      audioAvailable = true;\n    } else {\n      console.warn(\"Web Audio API not supported in this browser.\");\n    }\n  } catch (e) {\n    console.warn(\"AudioContext creation failed:\", e);\n    audioAvailable = false;\n  }\n\n  // In many browsers audio must be resumed within a user gesture\n  async function ensureAudioStarted() {\n    if (!audioAvailable || !audioContext) return false;\n    try {\n      if (audioContext.state === \"suspended\") {\n        await audioContext.resume();\n      }\n      return true;\n    } catch (e) {\n      console.warn(\"AudioContext resume failed:\", e);\n      return false;\n    }\n  }\n\n  // Background hum setup\n  let soundEnabled = true;\n  function startBackgroundHum() {\n    if (!audioAvailable || !soundEnabled) return;\n    try {\n      stopBackgroundHum();\n      bgOsc = audioContext.createOscillator();\n      bgOsc.type = \"sine\";\n      bgOsc.frequency.value = 80; // low hum\n      const lfo = audioContext.createOscillator();\n      lfo.frequency.value = 0.2; // slow wobble\n      const lfoGain = audioContext.createGain();\n      lfoGain.gain.value = 12;\n      lfo.connect(lfoGain);\n      lfoGain.connect(bgOsc.frequency);\n      bgGain = audioContext.createGain();\n      bgGain.gain.value = 0.035; // very gentle\n      bgOsc.connect(bgGain);\n      bgGain.connect(masterGain);\n      lfo.start();\n      bgOsc.start();\n    } catch (e) {\n      console.warn(\"Failed to start background hum:\", e);\n    }\n  }\n  function stopBackgroundHum() {\n    try {\n      if (bgOsc) {\n        bgOsc.stop();\n        bgOsc.disconnect();\n        bgOsc = null;\n      }\n      if (bgGain) {\n        bgGain.disconnect();\n        bgGain = null;\n      }\n    } catch (e) {\n      // ignore\n    }\n  }\n\n  // Simple sound generator\n  function playTone({ freq = 440, duration = 0.12, type = \"sine\", gain = 0.25, when = 0 } = {}) {\n    if (!audioAvailable || !soundEnabled) return;\n    try {\n      const ctx = audioContext;\n      const osc = ctx.createOscillator();\n      const g = ctx.createGain();\n      const filter = ctx.createBiquadFilter();\n      filter.type = \"lowpass\";\n      filter.frequency.value = Math.max(500, freq * 2);\n\n      osc.type = type;\n      osc.frequency.value = freq;\n      g.gain.value = 0.0001;\n\n      osc.connect(filter);\n      filter.connect(g);\n      g.connect(masterGain);\n\n      const now = ctx.currentTime + when;\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(gain, now + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);\n\n      osc.start(now);\n      osc.stop(now + duration + 0.02);\n    } catch (e) {\n      console.warn(\"playTone failed:\", e);\n    }\n  }\n\n  // Distinct feedback sounds\n  function playPickSound() {\n    playTone({ freq: 880, duration: 0.08, type: \"triangle\", gain: 0.08 });\n  }\n  function playPlaceSound() {\n    playTone({ freq: 660, duration: 0.12, type: \"sine\", gain: 0.12 });\n  }\n  function playCorrectSound() {\n    // cheerful arpeggio\n    playTone({ freq: 660, duration: 0.12, type: \"sine\", gain: 0.12 });\n    playTone({ freq: 880, duration: 0.12, type: \"sine\", gain: 0.12, when: 0.12 });\n    playTone({ freq: 990, duration: 0.18, type: \"sine\", gain: 0.12, when: 0.26 });\n  }\n  function playIncorrectSound() {\n    playTone({ freq: 220, duration: 0.18, type: \"sawtooth\", gain: 0.12 });\n  }\n\n  // Data structures\n  let round = 1;\n  let wins = 0;\n  let targetNumber = 0;\n  let gears = []; // gear objects\n  let slots = []; // slot objects\n  let dragging = null;\n  let dragOffset = { x: 0, y: 0 };\n  let selectedGearIndex = 0; // for keyboard selection\n  let notification = \"\"; // small text feedback\n  let notificationTimer = 0;\n  let roundSolved = false;\n  let gameOver = false;\n\n  // Setup slots (positions in machine)\n  function setupSlots() {\n    slots = [];\n    const startX = 160;\n    const gap = 120;\n    const y = 260;\n    for (let i = 0; i < SLOT_COUNT; i++) {\n      slots.push({\n        x: startX + i * gap,\n        y: y,\n        r: 34,\n        gearIndex: -1, // which gear is placed\n      });\n    }\n  }\n\n  // Utility: shuffle array\n  function shuffleArr(arr) {\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n  }\n\n  // Start a round: create three numbers that sum to target, plus one decoy\n  function startRound() {\n    roundSolved = false;\n    notification = \"\";\n    notificationTimer = 0;\n    // Create three small integers 1..9 that sum up to target between 6 and 20\n    const a = Math.floor(Math.random() * 8) + 1; // 1..8\n    const b = Math.floor(Math.random() * 8) + 1;\n    // ensure c is within 1..9\n    let c = Math.max(1, Math.min(9, Math.floor((a + b) / 2 + Math.random() * 8)));\n    let sum = a + b + c;\n    // Adjust target if out of desired range\n    if (sum < 6 || sum > 20) {\n      sum = Math.floor(6 + Math.random() * 15);\n      // pick c to match target\n      c = sum - a - b;\n      if (c < 1) c = 1 + Math.floor(Math.random() * 6);\n      if (c > 9) c = 9;\n    }\n    // Now ensure sum is updated\n    const values = [a, b, c];\n    // Recalculate target\n    targetNumber = values.reduce((s, v) => s + v, 0);\n    // Add decoy gear that is different or a duplicate sometimes\n    let decoy = Math.floor(Math.random() * 9) + 1;\n    // Ensure not trivial: decoy not equal to any if possible\n    if (values.includes(decoy)) {\n      decoy = (decoy % 9) + 1;\n    }\n    values.push(decoy);\n    shuffleArr(values);\n\n    // Construct gear objects positioned on left conveyor\n    gears = [];\n    const startX = 60;\n    const baseY = 360;\n    const gapX = 120;\n    for (let i = 0; i < MAX_GEARS; i++) {\n      const gx = startX + i * gapX;\n      const gy = baseY + (i % 2 === 0 ? -6 : 6);\n      const val = values[i];\n      gears.push({\n        value: val,\n        x: gx,\n        y: gy,\n        r: 28,\n        original: { x: gx, y: gy },\n        placed: false,\n        slotIndex: -1,\n        wobble: Math.random() * Math.PI * 2,\n      });\n    }\n\n    setupSlots();\n    selectedGearIndex = 0;\n    roundSolved = false;\n  }\n\n  function resetGame() {\n    round = 1;\n    wins = 0;\n    gameOver = false;\n    startRound();\n  }\n\n  // Detect gear index under coordinates\n  function gearAtPoint(x, y) {\n    for (let i = gears.length - 1; i >= 0; i--) {\n      const g = gears[i];\n      const dx = x - g.x;\n      const dy = y - g.y;\n      if (Math.sqrt(dx * dx + dy * dy) <= g.r + 6) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  // Detect slot at point\n  function slotAtPoint(x, y) {\n    for (let i = 0; i < slots.length; i++) {\n      const s = slots[i];\n      const dx = x - s.x;\n      const dy = y - s.y;\n      if (Math.sqrt(dx * dx + dy * dy) <= s.r + 6) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  // Place gear into slot\n  function placeGearInSlot(gearIndex, slotIndex) {\n    const gear = gears[gearIndex];\n    const slot = slots[slotIndex];\n    if (!gear || !slot) return false;\n    if (slot.gearIndex !== -1) return false; // already filled\n    // Snap gear to slot\n    gear.x = slot.x;\n    gear.y = slot.y;\n    gear.placed = true;\n    gear.slotIndex = slotIndex;\n    slot.gearIndex = gearIndex;\n    playPlaceSound();\n    checkSolution();\n    return true;\n  }\n\n  // Remove gear from slot back to original position\n  function removeGearFromSlot(slotIndex) {\n    const slot = slots[slotIndex];\n    if (!slot) return;\n    const gi = slot.gearIndex;\n    if (gi === -1) return;\n    const gear = gears[gi];\n    slot.gearIndex = -1;\n    gear.placed = false;\n    gear.slotIndex = -1;\n    // animate back to original spot\n    gear.x = gear.original.x;\n    gear.y = gear.original.y;\n  }\n\n  // Check if current slots sum equals target\n  function checkSolution() {\n    // Only check when all slots are filled\n    for (let s of slots) {\n      if (s.gearIndex === -1) return;\n    }\n    const sum = slots.reduce((acc, s) => acc + gears[s.gearIndex].value, 0);\n    if (sum === targetNumber) {\n      // success\n      wins++;\n      roundSolved = true;\n      notification = \"Perfect! Machine fixed.\";\n      notificationTimer = 160; // frames\n      playCorrectSound();\n      // celebrate animation: slightly pop gears\n      for (let s of slots) {\n        const g = gears[s.gearIndex];\n        g.wobble = 0;\n      }\n      // Small delay then advance round or end\n      setTimeout(() => {\n        round++;\n        if (wins >= ROUNDS_TO_WIN) {\n          gameOver = true;\n          notification = \"You win! All machines humming!\";\n          notificationTimer = 9999;\n        } else {\n          startRound();\n        }\n      }, 900);\n    } else {\n      // incorrect\n      notification = \"Not quite \u2014 try again!\";\n      notificationTimer = 140;\n      playIncorrectSound();\n      // Un-snap after brief delay so children can see\n      setTimeout(() => {\n        for (let s = 0; s < slots.length; s++) {\n          if (slots[s].gearIndex !== -1) {\n            const gi = slots[s].gearIndex;\n            gears[gi].x = gears[gi].original.x;\n            gears[gi].y = gears[gi].original.y;\n            gears[gi].placed = false;\n            gears[gi].slotIndex = -1;\n            slots[s].gearIndex = -1;\n          }\n        }\n      }, 700);\n    }\n  }\n\n  // Mouse/touch interactions\n  canvas.addEventListener(\"mousedown\", async (e) => {\n    try {\n      await ensureAudioStarted();\n      if (audioAvailable && soundEnabled) startBackgroundHum();\n    } catch (ex) {}\n    const rect = canvas.getBoundingClientRect();\n    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);\n    const my = (e.clientY - rect.top) * (canvas.height / rect.height);\n    const gi = gearAtPoint(mx, my);\n    if (gi !== -1) {\n      dragging = gi;\n      const g = gears[gi];\n      dragOffset.x = mx - g.x;\n      dragOffset.y = my - g.y;\n      // If gear was in a slot, free slot\n      if (g.placed) {\n        const sidx = g.slotIndex;\n        if (sidx !== -1) {\n          slots[sidx].gearIndex = -1;\n        }\n        g.placed = false;\n        g.slotIndex = -1;\n      }\n      selectedGearIndex = gi;\n      playPickSound();\n    } else {\n      // Maybe click speaker icon - detect top-right area\n      const speakerRect = { x: WIDTH - 72, y: 14, w: 56, h: 34 };\n      if (\n        e.clientX - rect.left >= speakerRect.x &&\n        e.clientX - rect.left <= speakerRect.x + speakerRect.w &&\n        e.clientY - rect.top >= speakerRect.y &&\n        e.clientY - rect.top <= speakerRect.y + speakerRect.h\n      ) {\n        toggleSound();\n      }\n    }\n  });\n\n  canvas.addEventListener(\"mousemove\", (e) => {\n    if (dragging === null) return;\n    const rect = canvas.getBoundingClientRect();\n    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);\n    const my = (e.clientY - rect.top) * (canvas.height / rect.height);\n    const g = gears[dragging];\n    g.x = mx - dragOffset.x;\n    g.y = my - dragOffset.y;\n  });\n\n  canvas.addEventListener(\"mouseup\", (e) => {\n    if (dragging === null) return;\n    const rect = canvas.getBoundingClientRect();\n    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);\n    const my = (e.clientY - rect.top) * (canvas.height / rect.height);\n    const sidx = slotAtPoint(mx, my);\n    if (sidx !== -1) {\n      // attempt place\n      const placed = placeGearInSlot(dragging, sidx);\n      if (!placed) {\n        // return to original\n        const g = gears[dragging];\n        g.x = g.original.x;\n        g.y = g.original.y;\n      }\n    } else {\n      // return to original\n      const g = gears[dragging];\n      g.x = g.original.x;\n      g.y = g.original.y;\n    }\n    dragging = null;\n  });\n\n  // Touch support (translate to mouse)\n  canvas.addEventListener(\"touchstart\", (e) => {\n    e.preventDefault();\n    const touch = e.changedTouches[0];\n    const rect = canvas.getBoundingClientRect();\n    const fakeEvent = {\n      clientX: touch.clientX,\n      clientY: touch.clientY,\n    };\n    canvas.dispatchEvent(new MouseEvent(\"mousedown\", fakeEvent));\n  });\n  canvas.addEventListener(\"touchmove\", (e) => {\n    e.preventDefault();\n    const touch = e.changedTouches[0];\n    const rect = canvas.getBoundingClientRect();\n    const fakeEvent = {\n      clientX: touch.clientX,\n      clientY: touch.clientY,\n    };\n    canvas.dispatchEvent(new MouseEvent(\"mousemove\", fakeEvent));\n  });\n  canvas.addEventListener(\"touchend\", (e) => {\n    e.preventDefault();\n    const touch = e.changedTouches[0];\n    const rect = canvas.getBoundingClientRect();\n    const fakeEvent = {\n      clientX: touch.clientX,\n      clientY: touch.clientY,\n    };\n    canvas.dispatchEvent(new MouseEvent(\"mouseup\", fakeEvent));\n  });\n\n  // Keyboard controls for accessibility\n  canvas.addEventListener(\"keydown\", async (e) => {\n    const key = e.key;\n    // Try to start audio on user gesture\n    try {\n      await ensureAudioStarted();\n      if (audioAvailable && soundEnabled) startBackgroundHum();\n    } catch (ex) {}\n\n    if (gameOver) {\n      if (key === \" \" || key === \"Enter\") {\n        resetGame();\n      }\n      return;\n    }\n\n    // Tab cycles selection\n    if (key === \"Tab\") {\n      e.preventDefault();\n      selectedGearIndex = (selectedGearIndex + 1) % gears.length;\n      playPickSound();\n      return;\n    }\n\n    const selectedGear = gears[selectedGearIndex];\n    if (!selectedGear) return;\n\n    if (key === \"Enter\" || key === \" \") {\n      // If picked up (simulate dragging) then place in first empty slot, else pick up\n      if (!selectedGear.placed) {\n        // pick up and place to first empty slot\n        const emptySlot = slots.findIndex((s) => s.gearIndex === -1);\n        if (emptySlot !== -1) {\n          placeGearInSlot(selectedGearIndex, emptySlot);\n        } else {\n          // no slots free \u2014 quickly swap with first slot\n          // swap with slot 0\n          const s0 = slots[0];\n          const oldGearIndex = s0.gearIndex;\n          if (oldGearIndex !== -1) {\n            // put old gear back to original\n            gears[oldGearIndex].x = gears[oldGearIndex].original.x;\n            gears[oldGearIndex].placed = false;\n            gears[oldGearIndex].slotIndex = -1;\n          }\n          placeGearInSlot(selectedGearIndex, 0);\n        }\n      } else {\n        // remove from its slot\n        const sidx = selectedGear.slotIndex;\n        if (sidx !== -1) {\n          removeGearFromSlot(sidx);\n        }\n      }\n      return;\n    }\n\n    // Arrow keys to move selection (change selectedGearIndex)\n    if (key === \"ArrowRight\") {\n      selectedGearIndex = (selectedGearIndex + 1) % gears.length;\n      playPickSound();\n      return;\n    }\n    if (key === \"ArrowLeft\") {\n      selectedGearIndex = (selectedGearIndex - 1 + gears.length) % gears.length;\n      playPickSound();\n      return;\n    }\n\n    // Number keys to place into particular slots (1..3)\n    if (/^[1-3]$/.test(key)) {\n      const slotNumber = parseInt(key, 10) - 1;\n      // If gear is already placed, remove; else place into that slot if empty\n      if (!selectedGear.placed) {\n        if (slots[slotNumber].gearIndex === -1) {\n          placeGearInSlot(selectedGearIndex, slotNumber);\n        } else {\n          // swap\n          const previousGearIndex = slots[slotNumber].gearIndex;\n          removeGearFromSlot(slotNumber);\n          placeGearInSlot(selectedGearIndex, slotNumber);\n          // return swapped gear to its original spot\n          if (previousGearIndex !== -1) {\n            gears[previousGearIndex].x = gears[previousGearIndex].original.x;\n          }\n        }\n      } else {\n        // remove if selecting same slot\n        if (selectedGear.slotIndex === slotNumber) {\n          removeGearFromSlot(slotNumber);\n        } else {\n          // place to that slot if empty\n          if (slots[slotNumber].gearIndex === -1) {\n            const oldSlot = selectedGear.slotIndex;\n            if (oldSlot !== -1) {\n              slots[oldSlot].gearIndex = -1;\n            }\n            placeGearInSlot(selectedGearIndex, slotNumber);\n          }\n        }\n      }\n      return;\n    }\n\n    // Backspace/Delete resets selected gear\n    if (key === \"Backspace\" || key === \"Delete\") {\n      if (selectedGear.placed) {\n        const sidx = selectedGear.slotIndex;\n        if (sidx !== -1) removeGearFromSlot(sidx);\n      } else {\n        // return to original\n        selectedGear.x = selectedGear.original.x;\n        selectedGear.y = selectedGear.original.y;\n        selectedGear.placed = false;\n        selectedGear.slotIndex = -1;\n      }\n      return;\n    }\n\n    // H key toggles help tooltip\n    if (key.toLowerCase() === \"h\") {\n      notification = \"Tip: You need to place three gears so their numbers add to the target.\";\n      notificationTimer = 180;\n      return;\n    }\n\n    // S toggles sound\n    if (key.toLowerCase() === \"s\") {\n      toggleSound();\n      return;\n    }\n  });\n\n  // Toggle sound and background hum\n  function toggleSound() {\n    soundEnabled = !soundEnabled;\n    if (!soundEnabled) {\n      stopBackgroundHum();\n    } else {\n      ensureAudioStarted().then(() => {\n        if (audioAvailable) startBackgroundHum();\n      });\n    }\n    notification = soundEnabled ? \"Sound on\" : \"Sound off\";\n    notificationTimer = 80;\n  }\n\n  // Drawing helpers\n  function drawRoundedRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  // Draw cog (gear) shape with teeth\n  function drawGear(ctx, x, y, radius, teeth, color, rotation = 0) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(rotation);\n    // body\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.arc(0, 0, radius * 0.62, 0, Math.PI * 2);\n    ctx.fill();\n    // teeth\n    for (let i = 0; i < teeth; i++) {\n      const ang = (i / teeth) * Math.PI * 2;\n      const tx = Math.cos(ang) * (radius * 0.9);\n      const ty = Math.sin(ang) * (radius * 0.9);\n      ctx.beginPath();\n      ctx.moveTo(tx, ty);\n      ctx.lineTo(Math.cos(ang) * radius, Math.sin(ang) * radius);\n      ctx.lineWidth = 3;\n      ctx.strokeStyle = color;\n      ctx.stroke();\n    }\n    // center hole\n    ctx.fillStyle = \"#333\";\n    ctx.beginPath();\n    ctx.arc(0, 0, radius * 0.22, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  // Main draw loop\n  let frame = 0;\n  function draw() {\n    frame++;\n\n    // background\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    // gentle sky gradient\n    const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    grad.addColorStop(0, \"#f7fbff\");\n    grad.addColorStop(1, \"#e7f1f7\");\n    ctx.fillStyle = grad;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Top banner / machine header\n    ctx.fillStyle = \"#dfeef6\";\n    drawRoundedRect(ctx, 16, 12, WIDTH - 32, 88, 12);\n\n    // Title\n    ctx.fillStyle = \"#1b3b5a\";\n    ctx.font = \"bold 22px system-ui, Arial\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(\"Machine Math \u2014 Fix the Friendly Factory\", 36, 42);\n\n    // Round and instructions\n    ctx.font = \"14px system-ui, Arial\";\n    ctx.fillStyle = \"#234d67\";\n    ctx.fillText(`Round ${round} of ${ROUNDS_TO_WIN}`, 36, 66);\n    ctx.fillStyle = \"#2d5d78\";\n    ctx.font = \"13px system-ui, Arial\";\n    ctx.fillText(\"Drag gears into the slots so their numbers add to the target.\", 36, 86);\n\n    // Draw target panel (big number)\n    ctx.fillStyle = \"#fff\";\n    drawRoundedRect(ctx, WIDTH - 220, 24, 180, 72, 10);\n    ctx.fillStyle = \"#264a63\";\n    ctx.font = \"14px system-ui, Arial\";\n    ctx.fillText(\"Target\", WIDTH - 220 + 16, 46);\n    ctx.font = \"bold 36px system-ui, Arial\";\n    ctx.fillStyle = \"#0a3a55\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(String(targetNumber), WIDTH - 220 + 90, 86);\n    ctx.textAlign = \"left\";\n\n    // Draw a wacky machine illustration in the center\n    drawMachineBackground();\n\n    // Draw slots\n    for (let i = 0; i < slots.length; i++) {\n      const s = slots[i];\n      // slot base\n      ctx.fillStyle = \"#cde6f3\";\n      drawRoundedRect(ctx, s.x - 46, s.y - 46, 92, 92, 12);\n      // hole\n      ctx.fillStyle = \"#eef8fb\";\n      ctx.beginPath();\n      ctx.arc(s.x, s.y, s.r + 6, 0, Math.PI * 2);\n      ctx.fill();\n      // slot number\n      ctx.fillStyle = \"#2b5370\";\n      ctx.font = \"bold 14px system-ui, Arial\";\n      ctx.fillText(`Slot ${i + 1}`, s.x - 24, s.y + 52);\n    }\n\n    // Conveyor belt for gears\n    ctx.fillStyle = \"#203748\";\n    drawRoundedRect(ctx, 18, 320, 420, 120, 18);\n    // belt stripes\n    for (let i = 0; i < 8; i++) {\n      ctx.fillStyle = i % 2 === 0 ? \"rgba(255,255,255,0.03)\" : \"rgba(0,0,0,0.03)\";\n      const bx = 36 + i * 50 + (frame % 50);\n      ctx.fillRect(bx % 420 + 20, 348, 40, 6);\n    }\n\n    // Draw gears (draggable)\n    for (let i = 0; i < gears.length; i++) {\n      const g = gears[i];\n      // wobble for life\n      g.wobble += 0.04;\n      const rot = Math.sin(frame * 0.02 + i) * 0.08 + (g.placed ? 0 : Math.sin(g.wobble) * 0.02);\n      // highlight if selected\n      if (i === selectedGearIndex) {\n        ctx.save();\n        ctx.shadowColor = \"rgba(60,120,160,0.35)\";\n        ctx.shadowBlur = 12;\n      }\n      // draw gear\n      drawGear(ctx, g.x, g.y, g.r, 10, i === selectedGearIndex ? \"#78c0d6\" : \"#8bd1e8\", rot);\n      // number\n      ctx.fillStyle = \"#043748\";\n      ctx.font = \"bold 16px system-ui, Arial\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(String(g.value), g.x, g.y + 6);\n      if (i === selectedGearIndex) ctx.restore();\n    }\n\n    // Draw small animated gears in machine\n    drawMachineGears(frame);\n\n    // Draw UI: notification\n    if (notificationTimer > 0) {\n      notificationTimer--;\n      ctx.globalAlpha = Math.min(1, notificationTimer / 80);\n      ctx.fillStyle = \"#ffd36b\";\n      drawRoundedRect(ctx, WIDTH / 2 - 180, 12 + 88, 360, 36, 10);\n      ctx.fillStyle = \"#2b3b4a\";\n      ctx.font = \"bold 15px system-ui, Arial\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(notification, WIDTH / 2, 140);\n      ctx.globalAlpha = 1;\n      ctx.textAlign = \"left\";\n    }\n\n    // Draw speaker icon and sound status\n    drawSpeakerIcon();\n\n    // If game over, overlay messages\n    if (gameOver) {\n      ctx.fillStyle = \"rgba(4,20,28,0.6)\";\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n      ctx.fillStyle = \"#fffdf6\";\n      ctx.font = \"bold 32px system-ui, Arial\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(\"Hooray! You fixed all the machines!\", WIDTH / 2, HEIGHT / 2 - 12);\n      ctx.font = \"18px system-ui, Arial\";\n      ctx.fillText(\"Press Space or Enter to play again.\", WIDTH / 2, HEIGHT / 2 + 24);\n      ctx.textAlign = \"left\";\n    }\n\n    requestAnimationFrame(draw);\n  }\n\n  // Machine decoration\n  function drawMachineBackground() {\n    // central machine body\n    ctx.fillStyle = \"#cde6f6\";\n    drawRoundedRect(ctx, 120, 120, 480, 180, 16);\n    // vents\n    for (let i = 0; i < 10; i++) {\n      ctx.fillStyle = i % 2 ? \"#dff1fa\" : \"#bfe4ef\";\n      ctx.fillRect(140 + i * 44, 140, 28, 10);\n    }\n    // pipe\n    ctx.fillStyle = \"#9ec7d8\";\n    drawRoundedRect(ctx, 90, 170, 40, 60, 8);\n    drawRoundedRect(ctx, 560, 170, 40, 60, 8);\n    // label\n    ctx.fillStyle = \"#1b3b5a\";\n    ctx.font = \"14px system-ui, Arial\";\n    ctx.fillText(\"Friendly Factory Machine\", 320, 140);\n  }\n\n  // Animated small gears on machine to make it lively\n  function drawMachineGears(frame) {\n    const cx = 360;\n    const cy = 200;\n    const gearPositions = [\n      { x: cx - 80, y: cy - 10, r: 18, speed: 0.02, color: \"#f6a77a\" },\n      { x: cx - 10, y: cy + 20, r: 12, speed: -0.03, color: \"#c9f0e1\" },\n      { x: cx + 60, y: cy - 6, r: 22, speed: 0.015, color: \"#f3d36b\" },\n    ];\n    for (let i = 0; i < gearPositions.length; i++) {\n      const p = gearPositions[i];\n      const rot = frame * p.speed;\n      drawGear(ctx, p.x, p.y, p.r, 8 + i, p.color, rot);\n    }\n  }\n\n  // Speaker icon\n  function drawSpeakerIcon() {\n    const x = WIDTH - 72;\n    const y = 14;\n    ctx.fillStyle = soundEnabled ? \"#2b6f8f\" : \"#7a8c97\";\n    drawRoundedRect(ctx, x, y, 56, 34, 8);\n    // speaker symbol\n    ctx.save();\n    ctx.translate(x + 14, y + 17);\n    ctx.fillStyle = \"#fff\";\n    ctx.beginPath();\n    ctx.moveTo(-6, -8);\n    ctx.lineTo(0, -8);\n    ctx.lineTo(8, -2);\n    ctx.lineTo(8, 2);\n    ctx.lineTo(0, 8);\n    ctx.lineTo(-6, 8);\n    ctx.closePath();\n    ctx.fill();\n    if (soundEnabled) {\n      ctx.beginPath();\n      ctx.arc(10, 0, 8, -0.6, 0.6);\n      ctx.strokeStyle = \"rgba(255,255,255,0.85)\";\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    } else {\n      ctx.strokeStyle = \"rgba(255,255,255,0.85)\";\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(2, -10);\n      ctx.lineTo(14, 10);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  // Start the game\n  resetGame();\n  requestAnimationFrame(draw);\n\n  // Make sure audio starts after first user gesture\n  function resumeAudioOnGesture() {\n    if (!audioAvailable || !audioContext) return;\n    const resume = async () => {\n      try {\n        await audioContext.resume();\n        if (soundEnabled) startBackgroundHum();\n      } catch (e) {\n        // ignore\n      } finally {\n        window.removeEventListener(\"click\", resume);\n        window.removeEventListener(\"keydown\", resume);\n      }\n    };\n    window.addEventListener(\"click\", resume);\n    window.addEventListener(\"keydown\", resume);\n  }\n  resumeAudioOnGesture();\n\n  // Provide a small help text outside canvas for screen readers (hidden visually)\n  const srHelp = document.createElement(\"div\");\n  srHelp.style.position = \"absolute\";\n  srHelp.style.left = \"-9999px\";\n  srHelp.style.width = \"1px\";\n  srHelp.style.height = \"1px\";\n  srHelp.style.overflow = \"hidden\";\n  srHelp.setAttribute(\n    \"aria-hidden\",\n    \"false\"\n  );\n  srHelp.innerText =\n    \"Machine Math: Place three gears so the sum equals the target number. Use mouse or touch to drag. Use Tab to cycle gears, Enter to place/remove. Press S to toggle sound. Press H for a tip.\";\n  container.appendChild(srHelp);\n\n  // Expose a small API for testing (non-intrusive)\n  window._machineMath = {\n    restart: resetGame,\n    toggleSound: toggleSound,\n    isSoundEnabled: () => soundEnabled,\n    currentTarget: () => targetNumber,\n  };\n})();\n---\n",
  "improve_response_tokens": 19380,
  "formatted_code": true,
  "formatting_response_tokens": 21548,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}