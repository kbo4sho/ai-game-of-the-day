{
  "generated_date": "2025-10-12",
  "generated_timestamp": "2025-10-12T14:56:24.388524",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8771,
  "game_filename": "2025-10-12.js",
  "game_size_bytes": 25411,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Machine Math Game for ages 7-9\n  // Renders in element with id \"game-of-the-day-stage\"\n  // All drawing via canvas, sounds via Web Audio API oscillators\n\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const GOAL_CORRECT = 10;\n  const MAX_WRONG = 3;\n  const BUTTON_PADDING = 12;\n  const UI_PADDING = 10;\n  const BG_COLOR = \"#eaf6ff\";\n  const MACHINE_COLOR = \"#cfe7ff\";\n  const GEAR_COLOR = \"#8fb3d2\";\n  const TEXT_COLOR = \"#123\";\n  const ACCENT = \"#ff9f1c\";\n  const BAD_ACCENT = \"#ff6b6b\";\n\n  // State\n  let canvas, ctx, container;\n  let audioCtx = null;\n  let audioAvailable = false;\n  let bgGainNode = null;\n  let bgOsc = null;\n  let isMuted = false;\n  let gameState = \"menu\"; // menu, playing, win, lose\n  let correctCount = 0;\n  let wrongCount = 0;\n  let question = null;\n  let choices = [];\n  let selectedIndex = -1;\n  let buttons = [];\n  let lastInteractionTime = 0;\n  let keyboardSelection = 0;\n  let animationId = null;\n\n  // Make sure target element exists\n  container = document.getElementById(\"game-of-the-day-stage\");\n  if (!container) {\n    console.error('Element with id \"game-of-the-day-stage\" not found.');\n    return;\n  }\n\n  // Create canvas\n  canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.width = WIDTH + \"px\";\n  canvas.style.height = HEIGHT + \"px\";\n  canvas.style.display = \"block\";\n  canvas.style.background = BG_COLOR;\n  canvas.setAttribute(\"tabindex\", \"0\"); // focusable for keyboard\n  canvas.setAttribute(\"role\", \"img\");\n  canvas.setAttribute(\"aria-label\", \"Machine Math game. Solve addition and subtraction to fix the machine. Press Enter to start.\");\n  // Avoid overlapping content inside container\n  container.innerHTML = \"\";\n  container.appendChild(canvas);\n\n  ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    console.error(\"Canvas 2D context not available.\");\n    return;\n  }\n\n  // Utility functions\n  function safeMeasureText(text, font) {\n    ctx.save();\n    if (font) ctx.font = font;\n    const metrics = ctx.measureText(String(text));\n    ctx.restore();\n    return metrics;\n  }\n\n  function clamp(v, a, b) {\n    return Math.max(a, Math.min(b, v));\n  }\n\n  // Audio initialization with error handling. Must be called in response to user gesture for some browsers.\n  function initAudio() {\n    if (audioCtx) return;\n    try {\n      const AudioCtx = window.AudioContext || window.webkitAudioContext;\n      if (!AudioCtx) {\n        audioAvailable = false;\n        console.warn(\"Web Audio API not supported in this browser.\");\n        return;\n      }\n      audioCtx = new AudioCtx();\n      // Create gentle background hum\n      bgGainNode = audioCtx.createGain();\n      bgGainNode.gain.value = 0.02;\n      bgGainNode.connect(audioCtx.destination);\n\n      bgOsc = audioCtx.createOscillator();\n      bgOsc.type = \"sine\";\n      bgOsc.frequency.value = 110; // low hum\n      const lfo = audioCtx.createOscillator();\n      lfo.frequency.value = 0.25;\n      const lfoGain = audioCtx.createGain();\n      lfoGain.gain.value = 10;\n      lfo.connect(lfoGain);\n      lfoGain.connect(bgOsc.frequency);\n      bgOsc.connect(bgGainNode);\n      bgOsc.start();\n      lfo.start();\n\n      audioAvailable = true;\n      isMuted = false;\n    } catch (err) {\n      console.error(\"Audio initialization failed:\", err);\n      audioAvailable = false;\n    }\n  }\n\n  function toggleMute() {\n    if (!audioAvailable) return;\n    isMuted = !isMuted;\n    if (bgGainNode) bgGainNode.gain.value = isMuted ? 0 : 0.02;\n  }\n\n  function resumeAudioIfNeeded() {\n    if (!audioAvailable || !audioCtx) return;\n    if (audioCtx.state === \"suspended\") {\n      audioCtx.resume().catch((e) => {\n        console.warn(\"Audio resume failed:\", e);\n      });\n    }\n  }\n\n  // Sound effects using Web Audio API (no files)\n  function playCorrectSound() {\n    if (!audioAvailable) return;\n    resumeAudioIfNeeded();\n    try {\n      const t = audioCtx.currentTime;\n      const o1 = audioCtx.createOscillator();\n      const o2 = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n\n      o1.type = \"sine\";\n      o2.type = \"triangle\";\n      o1.frequency.setValueAtTime(880, t);\n      o2.frequency.setValueAtTime(1320, t);\n\n      g.gain.setValueAtTime(0, t);\n      g.gain.linearRampToValueAtTime(0.12, t + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.6);\n\n      o1.connect(g);\n      o2.connect(g);\n      g.connect(audioCtx.destination);\n\n      o1.start(t);\n      o2.start(t);\n      o1.stop(t + 0.7);\n      o2.stop(t + 0.7);\n    } catch (err) {\n      console.warn(\"Error playing correct sound:\", err);\n    }\n  }\n\n  function playIncorrectSound() {\n    if (!audioAvailable) return;\n    resumeAudioIfNeeded();\n    try {\n      const t = audioCtx.currentTime;\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      const f = audioCtx.createBiquadFilter();\n      o.type = \"square\";\n      o.frequency.setValueAtTime(220, t);\n      f.type = \"lowpass\";\n      f.frequency.setValueAtTime(600, t);\n      g.gain.setValueAtTime(0, t);\n      g.gain.linearRampToValueAtTime(0.18, t + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.5);\n\n      o.connect(f);\n      f.connect(g);\n      g.connect(audioCtx.destination);\n\n      o.start(t);\n      o.stop(t + 0.5);\n    } catch (err) {\n      console.warn(\"Error playing incorrect sound:\", err);\n    }\n  }\n\n  // Game logic: generate simple addition/subtraction questions suitable for ages 7-9\n  function generateQuestion() {\n    // Mix addition and subtraction; ensure non-negative results for subtraction\n    const operation = Math.random() < 0.6 ? \"+\" : \"-\";\n    let a, b;\n    if (operation === \"+\") {\n      a = Math.floor(Math.random() * 20) + 1; // 1..20\n      b = Math.floor(Math.random() * 20) + 0; // 0..19\n    } else {\n      a = Math.floor(Math.random() * 20) + 5; // 5..24 to ensure not negative\n      b = Math.floor(Math.random() * 10) + 0; // 0..9\n      if (b > a) [a, b] = [b, a];\n    }\n    const correct = operation === \"+\" ? a + b : a - b;\n    // Generate three plausible distractors\n    const distractors = new Set();\n    while (distractors.size < 3) {\n      let delta = Math.floor(Math.random() * 7) - 3; // -3..3\n      let candidate = correct + delta;\n      if (candidate !== correct && candidate >= 0 && candidate <= 40) {\n        distractors.add(candidate);\n      }\n    }\n    choices = shuffleArray([correct, ...Array.from(distractors)]);\n    question = {\n      text: `${a} ${operation} ${b} = ?`,\n      answer: correct,\n    };\n    selectedIndex = -1;\n    keyboardSelection = 0;\n    buildButtonsForChoices();\n  }\n\n  function shuffleArray(arr) {\n    const a = arr.slice();\n    for (let i = a.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [a[i], a[j]] = [a[j], a[i]];\n    }\n    return a;\n  }\n\n  // Build button objects laid out for choices; ensures no overlap with UI\n  function buildButtonsForChoices() {\n    buttons = [];\n    const cols = 2;\n    const rows = 2;\n    const btnWidth = 300;\n    const btnHeight = 60;\n    const startX = (WIDTH - (btnWidth * cols + UI_PADDING * (cols - 1))) / 2;\n    const startY = HEIGHT / 2 + 20;\n    let idx = 0;\n    for (let r = 0; r < rows; r++) {\n      for (let c = 0; c < cols; c++) {\n        const x = startX + c * (btnWidth + UI_PADDING);\n        const y = startY + r * (btnHeight + UI_PADDING);\n        buttons.push({\n          x,\n          y,\n          w: btnWidth,\n          h: btnHeight,\n          text: String(choices[idx]),\n          index: idx,\n        });\n        idx++;\n      }\n    }\n  }\n\n  function handleAnswer(index) {\n    if (gameState !== \"playing\" || index < 0 || index >= choices.length) return;\n    lastInteractionTime = performance.now();\n    const chosen = choices[index];\n    if (chosen === question.answer) {\n      correctCount++;\n      playCorrectSound();\n    } else {\n      wrongCount++;\n      playIncorrectSound();\n    }\n    // Delay small animation, then next question or end\n    if (correctCount >= GOAL_CORRECT) {\n      gameState = \"win\";\n    } else if (wrongCount >= MAX_WRONG) {\n      gameState = \"lose\";\n    } else {\n      // Prepare next question\n      generateQuestion();\n    }\n  }\n\n  function startGame() {\n    correctCount = 0;\n    wrongCount = 0;\n    gameState = \"playing\";\n    generateQuestion();\n    resumeAudioIfNeeded();\n  }\n\n  function restartGame() {\n    startGame();\n  }\n\n  // Drawing helpers\n  function clear() {\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n  }\n\n  function drawBackgroundWackyMachine(t) {\n    // calming gradient\n    const grad = ctx.createLinearGradient(0, 0, WIDTH, HEIGHT);\n    grad.addColorStop(0, \"#f0fbff\");\n    grad.addColorStop(1, \"#e8f3fb\");\n    ctx.fillStyle = grad;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // big machine body\n    ctx.fillStyle = MACHINE_COLOR;\n    ctx.strokeStyle = \"#9bb\";\n    roundRect(ctx, 40, 60, WIDTH - 80, HEIGHT - 160, 20, true, false);\n\n    // Wacky gears (drawn as arcs with teeth)\n    function drawGear(cx, cy, r, teeth, phase, fill) {\n      ctx.save();\n      ctx.translate(cx, cy);\n      ctx.rotate(phase + (t % 6000) / 6000 * Math.PI * 2);\n      ctx.beginPath();\n      for (let i = 0; i < teeth; i++) {\n        const angle = (i / teeth) * Math.PI * 2;\n        const outer = r * 1.18;\n        const inner = r * 0.78;\n        const x1 = Math.cos(angle) * outer;\n        const y1 = Math.sin(angle) * outer;\n        const x2 = Math.cos(angle + (Math.PI * 2) / (teeth * 2)) * inner;\n        const y2 = Math.sin(angle + (Math.PI * 2) / (teeth * 2)) * inner;\n        if (i === 0) ctx.moveTo(x1, y1);\n        ctx.lineTo(x1, y1);\n        ctx.lineTo(x2, y2);\n      }\n      ctx.closePath();\n      ctx.fillStyle = fill || GEAR_COLOR;\n      ctx.fill();\n      ctx.restore();\n    }\n\n    drawGear(150, 160, 44, 12, 0, \"#bfe0ee\");\n    drawGear(320, 240, 60, 16, 1.2, \"#9fc2d8\");\n    drawGear(540, 170, 36, 10, -0.6, \"#b7dbe6\");\n\n    // Pipes and bolts\n    ctx.fillStyle = \"#b3d4e6\";\n    roundRect(ctx, 80, 220, 560, 18, 8, true, false);\n    roundRect(ctx, 120, 260, 420, 14, 7, true, false);\n    for (let i = 0; i < 8; i++) {\n      ctx.beginPath();\n      ctx.fillStyle = \"#9fb0bd\";\n      ctx.arc(100 + i * 70, 220 + 9, 6, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // Wacky arm that points to the question area\n    ctx.save();\n    ctx.translate(600, 330);\n    ctx.rotate(Math.sin(t / 1000) * 0.2);\n    ctx.fillStyle = \"#e8f7ff\";\n    roundRect(ctx, -8, -60, 16, 120, 8, true, false);\n    ctx.fillStyle = ACCENT;\n    ctx.beginPath();\n    ctx.moveTo(-8, -60);\n    ctx.lineTo(8, -60);\n    ctx.lineTo(20, -80);\n    ctx.lineTo(-20, -80);\n    ctx.closePath();\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function roundRect(ctx, x, y, w, h, r, fill, stroke) {\n    if (typeof r === \"undefined\") r = 5;\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  function drawUI() {\n    // Score top-left\n    ctx.save();\n    ctx.font = \"18px sans-serif\";\n    ctx.fillStyle = TEXT_COLOR;\n    const scoreText = `Fixed: ${correctCount}/${GOAL_CORRECT}`;\n    const scoreMetrics = safeMeasureText(scoreText, ctx.font);\n    const scoreX = UI_PADDING;\n    const scoreY = 28;\n    // Background rectangle\n    ctx.fillStyle = \"rgba(255,255,255,0.8)\";\n    const scoreRectW = Math.ceil(scoreMetrics.width) + 20;\n    roundRect(ctx, scoreX, scoreY - 18, scoreRectW, 26, 6, true, false);\n    ctx.fillStyle = TEXT_COLOR;\n    ctx.fillText(scoreText, scoreX + 10, scoreY);\n    ctx.restore();\n\n    // Lives top-right\n    ctx.save();\n    ctx.font = \"18px sans-serif\";\n    const livesText = `Faults: ${wrongCount}/${MAX_WRONG}`;\n    const livesMetrics = safeMeasureText(livesText, ctx.font);\n    const livesW = Math.ceil(livesMetrics.width) + 20;\n    const livesX = WIDTH - livesW - UI_PADDING;\n    const livesY = 28;\n    ctx.fillStyle = \"rgba(255,255,255,0.8)\";\n    roundRect(ctx, livesX, livesY - 18, livesW, 26, 6, true, false);\n    ctx.fillStyle = TEXT_COLOR;\n    ctx.fillText(livesText, livesX + 10, livesY);\n    ctx.restore();\n\n    // Audio icon near lives (non-overlapping)\n    const audioIconSize = 22;\n    const iconX = livesX - audioIconSize - 8;\n    const iconY = 12;\n    ctx.save();\n    ctx.fillStyle = \"rgba(255,255,255,0.8)\";\n    roundRect(ctx, iconX - 6, iconY - 6, audioIconSize + 12, audioIconSize + 12, 6, true, false);\n    ctx.fillStyle = TEXT_COLOR;\n    // Draw simple speaker icon\n    ctx.beginPath();\n    ctx.rect(iconX, iconY + 5, 8, 12);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.moveTo(iconX + 8, iconY + 5);\n    ctx.lineTo(iconX + 18, iconY);\n    ctx.lineTo(iconX + 18, iconY + 24);\n    ctx.closePath();\n    ctx.fill();\n    if (isMuted || !audioAvailable) {\n      ctx.strokeStyle = BAD_ACCENT;\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(iconX + 2, iconY + 2);\n      ctx.lineTo(iconX + audioIconSize + 6, iconY + audioIconSize + 10);\n      ctx.stroke();\n    } else {\n      ctx.strokeStyle = ACCENT;\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.arc(iconX + 20, iconY + 12, 6, -0.6, 0.6);\n      ctx.stroke();\n    }\n    ctx.restore();\n\n    // Instructions bottom-center\n    ctx.save();\n    ctx.font = \"14px sans-serif\";\n    ctx.fillStyle = TEXT_COLOR;\n    const instructions = \"Answer 10 questions correctly to fix the machine. 3 wrong answers and the machine fails. Click or press 1-4 keys to choose. Press M to toggle sound.\";\n    const maxWidth = WIDTH - 40;\n    const lines = wrapTextToLines(instructions, maxWidth, ctx.font);\n    // Measure overall text height and place bottom-center above bottom padding\n    const lineHeight = 18;\n    const totalHeight = lines.length * lineHeight;\n    const startY = HEIGHT - UI_PADDING - totalHeight;\n    // background rectangle\n    const widest = Math.max(...lines.map((ln) => safeMeasureText(ln, ctx.font).width));\n    ctx.fillStyle = \"rgba(255,255,255,0.85)\";\n    roundRect(ctx, (WIDTH - widest) / 2 - 12, startY - 14, widest + 24, totalHeight + 16, 8, true, false);\n    ctx.fillStyle = TEXT_COLOR;\n    for (let i = 0; i < lines.length; i++) {\n      ctx.fillText(lines[i], (WIDTH - widest) / 2, startY + i * lineHeight + 12);\n    }\n    ctx.restore();\n  }\n\n  function wrapTextToLines(text, maxWidth, font) {\n    ctx.save();\n    ctx.font = font;\n    const words = text.split(\" \");\n    const lines = [];\n    let current = \"\";\n    for (const w of words) {\n      const test = current ? current + \" \" + w : w;\n      const m = ctx.measureText(test).width;\n      if (m > maxWidth && current) {\n        lines.push(current);\n        current = w;\n      } else {\n        current = test;\n      }\n    }\n    if (current) lines.push(current);\n    ctx.restore();\n    return lines;\n  }\n\n  function drawQuestionArea() {\n    if (!question) return;\n    // Draw question box centered top-mid\n    ctx.save();\n    ctx.font = \"24px sans-serif\";\n    const qText = question.text;\n    const metrics = safeMeasureText(qText, ctx.font);\n    const boxW = Math.ceil(metrics.width) + 40;\n    const boxH = 56;\n    const x = (WIDTH - boxW) / 2;\n    const y = HEIGHT / 2 - 100;\n    ctx.fillStyle = \"rgba(255,255,255,0.95)\";\n    roundRect(ctx, x, y, boxW, boxH, 10, true, false);\n    ctx.fillStyle = TEXT_COLOR;\n    ctx.fillText(qText, x + 20, y + 36);\n    // small subtext hint\n    ctx.font = \"14px sans-serif\";\n    ctx.fillStyle = \"#456\";\n    ctx.fillText(\"Solve to power the machine!\", x + 20, y + 56);\n    ctx.restore();\n  }\n\n  function drawChoiceButtons() {\n    ctx.save();\n    ctx.font = \"20px sans-serif\";\n    for (let i = 0; i < buttons.length; i++) {\n      const b = buttons[i];\n      // Background\n      ctx.fillStyle = \"rgba(255,255,255,0.95)\";\n      roundRect(ctx, b.x, b.y, b.w, b.h, 10, true, false);\n      // Outline highlight for selected\n      if (i === selectedIndex || i === keyboardSelection) {\n        ctx.strokeStyle = ACCENT;\n        ctx.lineWidth = 4;\n        roundRect(ctx, b.x, b.y, b.w, b.h, 10, false, true);\n      } else {\n        ctx.strokeStyle = \"#d0e6f2\";\n        ctx.lineWidth = 2;\n        roundRect(ctx, b.x, b.y, b.w, b.h, 10, false, true);\n      }\n      // Text centered\n      ctx.fillStyle = TEXT_COLOR;\n      const text = `${i + 1}. ${b.text}`;\n      const metrics = safeMeasureText(text, ctx.font);\n      ctx.fillText(text, b.x + (b.w - metrics.width) / 2, b.y + b.h / 2 + 8);\n    }\n    ctx.restore();\n  }\n\n  function drawEndScreen() {\n    ctx.save();\n    ctx.fillStyle = \"rgba(0,0,0,0.45)\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.font = \"28px sans-serif\";\n    ctx.fillStyle = \"white\";\n    let title = gameState === \"win\" ? \"Victory!\" : \"Machine Failed\";\n    let message =\n      gameState === \"win\"\n        ? \"You powered up the machine! Great engineering!\"\n        : \"Too many faults. The machine stopped working.\";\n    const titleMetrics = safeMeasureText(title, ctx.font);\n    const titleX = (WIDTH - titleMetrics.width) / 2;\n    const titleY = HEIGHT / 2 - 40;\n    // title background\n    ctx.fillStyle = ACCENT;\n    roundRect(ctx, titleX - 14, titleY - 34, titleMetrics.width + 28, 48, 8, true, false);\n    ctx.fillStyle = \"white\";\n    ctx.fillText(title, titleX, titleY);\n    // message box\n    ctx.font = \"18px sans-serif\";\n    const msgMetrics = safeMeasureText(message, ctx.font);\n    const msgX = (WIDTH - msgMetrics.width) / 2;\n    const msgY = HEIGHT / 2;\n    ctx.fillStyle = \"rgba(255,255,255,0.95)\";\n    roundRect(ctx, msgX - 14, msgY - 26, msgMetrics.width + 28, 44, 8, true, false);\n    ctx.fillStyle = TEXT_COLOR;\n    ctx.fillText(message, msgX, msgY);\n    // restart button\n    const btnText = \"Restart\";\n    ctx.font = \"20px sans-serif\";\n    const btnMetrics = safeMeasureText(btnText, ctx.font);\n    const btnW = btnMetrics.width + 40;\n    const btnH = 42;\n    const btnX = (WIDTH - btnW) / 2;\n    const btnY = HEIGHT / 2 + 60;\n    ctx.fillStyle = \"#fff\";\n    roundRect(ctx, btnX, btnY, btnW, btnH, 10, true, false);\n    ctx.fillStyle = \"#123\";\n    ctx.fillText(btnText, btnX + (btnW - btnMetrics.width) / 2, btnY + 28);\n    // Provide instructions to restart by keyboard for accessibility\n    ctx.font = \"14px sans-serif\";\n    ctx.fillStyle = \"rgba(255,255,255,0.8)\";\n    const instr = \"Press Enter or click Restart to play again.\";\n    const instrMetrics = safeMeasureText(instr, ctx.font);\n    ctx.fillText(instr, (WIDTH - instrMetrics.width) / 2, btnY + btnH + 28);\n    ctx.restore();\n    // Store restart button rect for input handling\n    endButtonRect = { x: btnX, y: btnY, w: btnW, h: btnH };\n  }\n\n  let endButtonRect = null;\n\n  function draw(timestamp) {\n    clear();\n    drawBackgroundWackyMachine(timestamp || 0);\n    drawUI();\n    if (gameState === \"menu\") {\n      drawMainMenu();\n    } else if (gameState === \"playing\") {\n      drawQuestionArea();\n      drawChoiceButtons();\n    } else if (gameState === \"win\" || gameState === \"lose\") {\n      drawQuestionArea();\n      drawChoiceButtons();\n      drawEndScreen();\n    }\n  }\n\n  function drawMainMenu() {\n    ctx.save();\n    ctx.fillStyle = \"rgba(255,255,255,0.95)\";\n    const title = \"Machine Math\";\n    ctx.font = \"36px sans-serif\";\n    const metrics = safeMeasureText(title, ctx.font);\n    const x = (WIDTH - metrics.width) / 2;\n    const y = HEIGHT / 2 - 40;\n    roundRect(ctx, x - 20, y - 44, metrics.width + 40, 68, 12, true, false);\n    ctx.fillStyle = TEXT_COLOR;\n    ctx.fillText(title, x, y);\n    ctx.font = \"18px sans-serif\";\n    const text = \"Help the wacky machine by answering 10 math questions. 3 mistakes and the machine stops.\";\n    const lines = wrapTextToLines(text, 520, ctx.font);\n    const lineHeight = 22;\n    for (let i = 0; i < lines.length; i++) {\n      ctx.fillText(lines[i], (WIDTH - safeMeasureText(lines[i], ctx.font).width) / 2, y + 36 + i * lineHeight);\n    }\n    // Start button\n    ctx.font = \"20px sans-serif\";\n    const btnText = \"Start\";\n    const btnMetrics = safeMeasureText(btnText, ctx.font);\n    const btnW = btnMetrics.width + 40;\n    const btnH = 44;\n    const btnX = (WIDTH - btnW) / 2;\n    const btnY = y + 120;\n    ctx.fillStyle = ACCENT;\n    roundRect(ctx, btnX, btnY, btnW, btnH, 10, true, false);\n    ctx.fillStyle = \"white\";\n    ctx.fillText(btnText, btnX + (btnW - btnMetrics.width) / 2, btnY + 28);\n    ctx.restore();\n    // Store start button rect\n    endButtonRect = { x: btnX, y: btnY, w: btnW, h: btnH };\n  }\n\n  // Input handling\n  canvas.addEventListener(\"click\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    lastInteractionTime = performance.now();\n    // Initialize audio on first user gesture (some browsers require)\n    if (!audioCtx) {\n      initAudio();\n    }\n    // If click is within audio icon\n    // audio icon located at computed position in drawUI; we can compute similarly\n    const livesFont = \"18px sans-serif\";\n    ctx.font = livesFont;\n    const livesText = `Faults: ${wrongCount}/${MAX_WRONG}`;\n    const livesMetrics = safeMeasureText(livesText, ctx.font);\n    const livesW = Math.ceil(livesMetrics.width) + 20;\n    const livesX = WIDTH - livesW - UI_PADDING;\n    const iconX = livesX - 22 - 8;\n    const iconY = 12;\n    if (mx >= iconX - 6 && mx <= iconX + 22 && my >= iconY - 6 && my <= iconY + 28) {\n      if (audioAvailable) {\n        toggleMute();\n      } else {\n        initAudio();\n      }\n      return;\n    }\n\n    if (gameState === \"menu\") {\n      if (isPointInRect(mx, my, endButtonRect)) {\n        startGame();\n      }\n    } else if (gameState === \"playing\") {\n      // Check choice buttons\n      for (const b of buttons) {\n        if (isPointInRect(mx, my, b)) {\n          handleAnswer(b.index);\n          return;\n        }\n      }\n    } else if (gameState === \"win\" || gameState === \"lose\") {\n      if (isPointInRect(mx, my, endButtonRect)) {\n        restartGame();\n      }\n    }\n  });\n\n  function isPointInRect(px, py, rect) {\n    if (!rect) return false;\n    return px >= rect.x && px <= rect.x + rect.w && py >= rect.y && py <= rect.y + rect.h;\n  }\n\n  // Keyboard controls: 1-4 to select answers, Enter to confirm, arrow keys to move, M to mute/unmute, Space/Enter to restart from end.\n  canvas.addEventListener(\"keydown\", (e) => {\n    lastInteractionTime = performance.now();\n    if (!audioCtx) {\n      initAudio();\n    }\n    const key = e.key;\n    if (gameState === \"menu\") {\n      if (key === \"Enter\" || key === \" \") {\n        startGame();\n        e.preventDefault();\n      }\n    } else if (gameState === \"playing\") {\n      if ([\"1\", \"2\", \"3\", \"4\"].includes(key)) {\n        const idx = parseInt(key, 10) - 1;\n        handleAnswer(idx);\n        e.preventDefault();\n      } else if (key === \"ArrowLeft\" || key === \"ArrowUp\") {\n        keyboardSelection = (keyboardSelection - 1 + buttons.length) % buttons.length;\n        e.preventDefault();\n      } else if (key === \"ArrowRight\" || key === \"ArrowDown\") {\n        keyboardSelection = (keyboardSelection + 1) % buttons.length;\n        e.preventDefault();\n      } else if (key === \"Enter\") {\n        handleAnswer(keyboardSelection);\n        e.preventDefault();\n      }\n    } else if (gameState === \"win\" || gameState === \"lose\") {\n      if (key === \"Enter\" || key === \" \") {\n        restartGame();\n        e.preventDefault();\n      }\n    }\n    if (key.toLowerCase() === \"m\") {\n      if (!audioAvailable) initAudio();\n      toggleMute();\n      e.preventDefault();\n    }\n  });\n\n  // Also allow global keypresses (when canvas not focused)\n  document.addEventListener(\"keydown\", (e) => {\n    // forward to canvas handler if not focused\n    if (document.activeElement !== canvas) {\n      canvas.focus();\n    }\n  });\n\n  // Visual focus cursor: highlight keyboardSelection\n  function updateSelectionHighlight() {\n    // simply set selectedIndex to keyboardSelection for drawing\n    if (gameState === \"playing\") {\n      selectedIndex = keyboardSelection;\n    } else {\n      selectedIndex = -1;\n    }\n  }\n\n  // Animation loop\n  function loop(ts) {\n    updateSelectionHighlight();\n    draw(ts);\n    animationId = requestAnimationFrame(loop);\n  }\n\n  // Start animation\n  animationId = requestAnimationFrame(loop);\n\n  // Ensure canvas gets focus for keyboard accessibility\n  canvas.addEventListener(\"mousedown\", () => {\n    canvas.focus();\n  });\n\n  // Fallback touch support: set focus on touch\n  canvas.addEventListener(\"touchstart\", () => {\n    canvas.focus();\n    if (!audioCtx) initAudio();\n  });\n\n  // Start with menu state, offer initAudio on first user gesture\n  gameState = \"menu\";\n  // Pre-generate a question for preview in menu so that drawQuestionArea won't error\n  generateQuestion();\n\n  // Expose some functions for debugging (in case)\n  window.__machineMath = {\n    restart: restartGame,\n    startAudio: initAudio,\n  };\n\n  // Ensure resources are closed on unload\n  window.addEventListener(\"beforeunload\", () => {\n    try {\n      if (bgOsc) bgOsc.stop();\n      if (audioCtx && audioCtx.close) audioCtx.close();\n    } catch (e) {}\n  });\n\n  // Ensure graceful error handling for audio context creation on first user gesture\n  // Already handled in initAudio with try/catch\n\n  // Ensure that during drawing, text does not overlap UI elements: we used fixed positions and measured text widths.\n  // Place initial focus to canvas for keyboard players\n  setTimeout(() => {\n    try {\n      canvas.focus();\n    } catch (e) {}\n  }, 100);\n\n})();\n---\n",
  "improve_response_tokens": 18297,
  "formatted_code": true,
  "formatting_response_tokens": 20250,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}