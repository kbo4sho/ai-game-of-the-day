{
  "generated_date": "2025-08-25",
  "generated_timestamp": "2025-08-25T00:29:10.155044",
  "model": "gpt-5-mini",
  "theme": "electricity",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 11669,
  "game_filename": "2025-08-25.js",
  "game_size_bytes": 34740,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function() {\n  // Electricity-themed Math Game for ages 7-9\n  // Renders into the element with ID \"game-of-the-day-stage\".\n  // All visuals are canvas-drawn. Sounds use the Web Audio API.\n  // Accessible instructions and controls are provided as DOM text inside the container.\n\n  // --- Configuration ---\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const CONTAINER_ID = \"game-of-the-day-stage\";\n  const MAX_ROUNDS = 6;\n\n  // --- Utility Functions ---\n  function clamp(v, a, b) {\n    return Math.max(a, Math.min(b, v));\n  }\n\n  function rand(min, max) {\n    return Math.random() * (max - min) + min;\n  }\n\n  function choose(array) {\n    return array[Math.floor(Math.random() * array.length)];\n  }\n\n  // --- Setup DOM and Canvas ---\n  const container = document.getElementById(CONTAINER_ID);\n  if (!container) {\n    console.error(`Container element with id \"${CONTAINER_ID}\" not found.`);\n    return;\n  }\n  // Clear container\n  container.innerHTML = \"\";\n  container.style.position = \"relative\";\n  container.setAttribute(\"role\", \"application\");\n  container.setAttribute(\"aria-label\", \"Power Planet math game. Use mouse or keyboard controls.\");\n  container.tabIndex = 0;\n\n  // Instruction / status area for accessibility (text, not visual)\n  const infoBox = document.createElement(\"div\");\n  infoBox.style.fontFamily = \"sans-serif\";\n  infoBox.style.fontSize = \"13px\";\n  infoBox.style.color = \"#0b0b0b\";\n  infoBox.style.margin = \"6px 0\";\n  infoBox.setAttribute(\"aria-live\", \"polite\");\n  container.appendChild(infoBox);\n\n  // Canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.width = WIDTH + \"px\";\n  canvas.style.height = HEIGHT + \"px\";\n  canvas.style.display = \"block\";\n  canvas.style.cursor = \"pointer\";\n  canvas.setAttribute(\"role\", \"img\");\n  canvas.setAttribute(\"aria-label\", \"Electric playground game canvas\");\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    infoBox.textContent = \"Sorry \u2014 your browser does not support canvas required for this game.\";\n    return;\n  }\n\n  // --- Audio Setup ---\n  let audioCtx = null;\n  let audioAvailable = false;\n  let humOsc = null;\n  let humGain = null;\n\n  function tryCreateAudioContext() {\n    if (audioCtx) return;\n    try {\n      window.AudioContext = window.AudioContext || window.webkitAudioContext;\n      audioCtx = new AudioContext();\n      audioAvailable = true;\n    } catch (e) {\n      console.warn(\"AudioContext cannot be created:\", e);\n      audioAvailable = false;\n      audioCtx = null;\n    }\n  }\n\n  tryCreateAudioContext();\n\n  // Because AudioContext often needs resume after user gesture, we resume on first interaction\n  function ensureAudioOnUserGesture() {\n    if (!audioCtx) tryCreateAudioContext();\n    if (!audioCtx) return;\n    if (audioCtx.state === \"suspended\") {\n      audioCtx.resume().catch((e) => {\n        console.warn(\"AudioContext resume failed:\", e);\n      });\n    }\n  }\n\n  function startHum() {\n    if (!audioAvailable) return;\n    stopHum();\n    try {\n      humOsc = audioCtx.createOscillator();\n      humGain = audioCtx.createGain();\n      const filter = audioCtx.createBiquadFilter();\n      humOsc.type = \"sine\";\n      humOsc.frequency.value = 120; // gentle hum low freq\n      filter.type = \"lowpass\";\n      filter.frequency.value = 800;\n      humGain.gain.value = 0.02;\n      humOsc.connect(filter);\n      filter.connect(humGain);\n      humGain.connect(audioCtx.destination);\n      humOsc.start();\n    } catch (e) {\n      console.warn(\"Failed to start hum:\", e);\n    }\n  }\n\n  function stopHum() {\n    try {\n      if (humOsc) {\n        humOsc.stop();\n        humOsc.disconnect();\n      }\n      if (humGain) humGain.disconnect();\n    } catch (e) {\n      // ignore\n    } finally {\n      humOsc = null;\n      humGain = null;\n    }\n  }\n\n  function playTone({ freq = 440, duration = 0.2, type = \"sine\", volume = 0.08, detune = 0 } = {}) {\n    if (!audioAvailable) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = type;\n      o.frequency.value = freq;\n      o.detune.value = detune;\n      g.gain.value = volume;\n      const filter = audioCtx.createBiquadFilter();\n      filter.type = \"lowpass\";\n      filter.frequency.value = freq * 3;\n      o.connect(filter);\n      filter.connect(g);\n      g.connect(audioCtx.destination);\n\n      const now = audioCtx.currentTime;\n      g.gain.setValueAtTime(0, now);\n      g.gain.linearRampToValueAtTime(volume, now + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);\n      o.start(now);\n      o.stop(now + duration + 0.02);\n    } catch (e) {\n      console.warn(\"playTone error\", e);\n    }\n  }\n\n  function playSuccessMelody() {\n    if (!audioAvailable) return;\n    // simple short melody\n    const notes = [660, 880, 990];\n    notes.forEach((n, i) => {\n      setTimeout(() => playTone({ freq: n, duration: 0.12, type: \"triangle\", volume: 0.08 }), i * 120);\n    });\n  }\n\n  function playErrorSound() {\n    if (!audioAvailable) return;\n    // buzz with distortion effect by quick frequency modulation\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      const filter = audioCtx.createBiquadFilter();\n      o.type = \"square\";\n      o.frequency.value = 120;\n      filter.type = \"lowpass\";\n      filter.frequency.value = 800;\n      g.gain.value = 0.12;\n      o.connect(filter);\n      filter.connect(g);\n      g.connect(audioCtx.destination);\n      const now = audioCtx.currentTime;\n      g.gain.setValueAtTime(0, now);\n      g.gain.linearRampToValueAtTime(0.12, now + 0.005);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.28);\n      o.start(now);\n      o.frequency.setValueAtTime(120, now);\n      o.frequency.linearRampToValueAtTime(40, now + 0.15);\n      o.stop(now + 0.3);\n    } catch (e) {\n      console.warn(\"playErrorSound error\", e);\n    }\n  }\n\n  // --- Game Data Structures ---\n  const electrons = [];\n  const devices = []; // bulbs that need a target sum\n  let selectedDeviceIndex = 0;\n  let round = 1;\n  let score = 0;\n  let lastActionMsg = \"\";\n  let animations = [];\n  let isPaused = false;\n  let audioEnabled = true;\n\n  // Characters (drawn in canvas)\n  const characters = {\n    DrVolt: { color: \"#f2c94c\", name: \"Dr. Volt\" },\n    Sparky: { color: \"#8bd3ff\", name: \"Sparky\" },\n    Bulby: { color: \"#ffd1dc\", name: \"Bulby\" }\n  };\n\n  // --- Create initial game state ---\n  function resetGameState() {\n    electrons.length = 0;\n    devices.length = 0;\n    selectedDeviceIndex = 0;\n    round = 1;\n    score = 0;\n    animations.length = 0;\n    spawnRound(round);\n  }\n\n  function spawnRound(r) {\n    electrons.length = 0;\n    devices.length = 0;\n    animations.length = 0;\n\n    // Create 3 target devices (bulbs) with target sums appropriate to round\n    const targets = [];\n    // as rounds progress, targets can grow\n    for (let i = 0; i < 3; i++) {\n      const base = clamp(4 + r + i, 4, 14);\n      // add variety\n      targets.push(base + (Math.random() < 0.4 ? 1 : 0));\n    }\n\n    // make device positions\n    const padding = 40;\n    const areaWidth = WIDTH - padding * 2;\n    for (let i = 0; i < 3; i++) {\n      const x = padding + (i + 0.5) * (areaWidth / 3);\n      const y = 110;\n      const device = {\n        x,\n        y,\n        target: targets[i],\n        collected: [],\n        active: true,\n        id: `bulb-${r}-${i}`\n      };\n      devices.push(device);\n    }\n\n    // spawn electrons with random values 1-9; ensure there are combinations to satisfy targets.\n    // We'll create a pool biased to sums: include explicit needed numbers by decomposing targets.\n    const neededPool = [];\n    devices.forEach(dev => {\n      let remaining = dev.target;\n      // break target into 1-4 parts to ensure possible combinations\n      const parts = Math.min(3, Math.max(1, Math.round(rand(1, 3))));\n      for (let p = 0; p < parts - 1; p++) {\n        const v = Math.max(1, Math.min(9, Math.round(rand(1, remaining - (parts - p - 1)))));\n        neededPool.push(v);\n        remaining -= v;\n      }\n      neededPool.push(Math.max(1, Math.min(9, remaining)));\n    });\n\n    // Add some random values too\n    for (let i = 0; i < 8; i++) {\n      neededPool.push(Math.ceil(rand(1, 9)));\n    }\n\n    // shuffle and create electrons\n    for (let i = 0; i < neededPool.length; i++) {\n      const v = neededPool[i];\n      electrons.push(makeElectron(rand(80, WIDTH - 80), rand(200, HEIGHT - 80), v));\n    }\n\n    // Add some animated decorative sparks\n    for (let i = 0; i < 12; i++) {\n      animations.push(makeFloatingSpark(rand(40, WIDTH - 40), rand(40, HEIGHT - 40)));\n    }\n\n    lastActionMsg = `Round ${r}: Help Bulby, Sparky and Dr. Volt reach their charge! Select a bulb, then tap electrons to add numbers until the bulb reaches its target.`;\n    updateInfoBox();\n  }\n\n  function makeElectron(x, y, value) {\n    return {\n      x,\n      y,\n      baseY: y,\n      vx: rand(-0.3, 0.3),\n      vy: rand(-0.2, 0.2),\n      r: 18,\n      value,\n      id: Math.random().toString(36).slice(2),\n      collected: false,\n      angle: rand(0, Math.PI * 2),\n      bob: rand(0, Math.PI * 2)\n    };\n  }\n\n  function makeFloatingSpark(x, y) {\n    return {\n      type: \"spark\",\n      x,\n      y,\n      r: rand(2, 6),\n      phase: rand(0, Math.PI * 2)\n    };\n  }\n\n  // --- Input Handling ---\n  let mouse = { x: 0, y: 0, down: false };\n\n  canvas.addEventListener(\"mousemove\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);\n    mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);\n  });\n\n  canvas.addEventListener(\"mousedown\", (e) => {\n    mouse.down = true;\n    ensureAudioOnUserGesture();\n    if (!audioCtx) audioAvailable = false;\n    // Also resume hum\n    if (audioEnabled && audioAvailable && !humOsc) startHum();\n    handlePointerDown(mouse.x, mouse.y);\n  });\n\n  canvas.addEventListener(\"mouseup\", (e) => {\n    mouse.down = false;\n  });\n\n  canvas.addEventListener(\"click\", (e) => {\n    // also ensure audio context is resumed on click\n    ensureAudioOnUserGesture();\n  });\n\n  // Touch support: map touch -> mouse\n  canvas.addEventListener(\"touchstart\", (e) => {\n    e.preventDefault();\n    const touch = e.changedTouches[0];\n    const rect = canvas.getBoundingClientRect();\n    mouse.x = (touch.clientX - rect.left) * (canvas.width / rect.width);\n    mouse.y = (touch.clientY - rect.top) * (canvas.height / rect.height);\n    mouse.down = true;\n    ensureAudioOnUserGesture();\n    handlePointerDown(mouse.x, mouse.y);\n  }, { passive: false });\n\n  canvas.addEventListener(\"touchend\", (e) => {\n    e.preventDefault();\n    mouse.down = false;\n  }, { passive: false });\n\n  // Keyboard controls\n  container.addEventListener(\"keydown\", (e) => {\n    // ensure key controls resume audio\n    ensureAudioOnUserGesture();\n    if (e.key === \"ArrowLeft\") {\n      selectedDeviceIndex = (selectedDeviceIndex - 1 + devices.length) % devices.length;\n      lastActionMsg = `${devices[selectedDeviceIndex].id} selected.`;\n      updateInfoBox();\n      playTone({ freq: 300, duration: 0.06, volume: 0.03, type: \"sine\" });\n      e.preventDefault();\n    } else if (e.key === \"ArrowRight\") {\n      selectedDeviceIndex = (selectedDeviceIndex + 1) % devices.length;\n      lastActionMsg = `${devices[selectedDeviceIndex].id} selected.`;\n      updateInfoBox();\n      playTone({ freq: 360, duration: 0.06, volume: 0.03, type: \"sine\" });\n      e.preventDefault();\n    } else if (e.key === \"Enter\" || e.key === \" \") {\n      // toggle selection message\n      lastActionMsg = `Selected ${devices[selectedDeviceIndex].id}. Tap an electron to add it or press number keys 1-9.`;\n      updateInfoBox();\n      playTone({ freq: 480, duration: 0.06, volume: 0.04, type: \"triangle\" });\n      e.preventDefault();\n    } else if (e.key === \"Backspace\" || e.key === \"Delete\" || e.key === \"Undo\") {\n      undoLastElectron();\n      e.preventDefault();\n    } else if (e.key >= \"1\" && e.key <= \"9\") {\n      // pick nearest electron with that value\n      const val = parseInt(e.key, 10);\n      pickElectronByValue(val);\n      e.preventDefault();\n    } else if (e.key === \"m\" || e.key === \"M\") {\n      toggleAudio();\n      e.preventDefault();\n    } else if (e.key === \"p\" || e.key === \"P\") {\n      togglePause();\n      e.preventDefault();\n    }\n  });\n\n  // --- Interaction logic ---\n  function handlePointerDown(x, y) {\n    // Check audio toggle area top-left (we draw speaker icon there)\n    if (x >= 12 && x <= 56 && y >= 12 && y <= 56) {\n      toggleAudio();\n      return;\n    }\n\n    // Check if clicked a device (bulb)\n    for (let i = 0; i < devices.length; i++) {\n      const d = devices[i];\n      const dx = x - d.x;\n      const dy = y - d.y;\n      if (Math.sqrt(dx * dx + dy * dy) < 48) {\n        selectedDeviceIndex = i;\n        lastActionMsg = `Selected ${characters.Bulby.name} device ${i + 1}. Now add electrons to reach ${d.target}.`;\n        updateInfoBox();\n        playTone({ freq: 420, duration: 0.08, type: \"triangle\", volume: 0.05 });\n        return;\n      }\n    }\n\n    // Else check electrons\n    for (let e of electrons) {\n      if (e.collected) continue;\n      const dx = x - e.x;\n      const dy = y - e.y;\n      if (Math.sqrt(dx * dx + dy * dy) < e.r + 6) {\n        collectElectron(e);\n        return;\n      }\n    }\n  }\n\n  function collectElectron(electron) {\n    const dev = devices[selectedDeviceIndex];\n    if (!dev || !dev.active) {\n      lastActionMsg = \"Select a device first by clicking on a bulb.\";\n      updateInfoBox();\n      playErrorSound();\n      return;\n    }\n\n    // compute sum if added\n    const currentSum = dev.collected.reduce((a, b) => a + b.value, 0);\n    const newSum = currentSum + electron.value;\n\n    if (newSum > dev.target) {\n      // incorrect: overload\n      lastActionMsg = `Oh no! Overload: ${currentSum} + ${electron.value} = ${newSum} (target ${dev.target}). Try a smaller electron.`;\n      updateInfoBox();\n      playErrorSound();\n      // show small explosion animation\n      animations.push(makeOverloadAnim(electron.x, electron.y));\n      return;\n    }\n\n    // successful pick\n    electron.collected = true;\n    electron.collectedAt = { x: electron.x, y: electron.y };\n    electron.collectTime = performance.now();\n    dev.collected.push(electron);\n\n    // small visual attach animation: animate electron to device\n    animations.push(makeAttachAnim(electron, dev));\n\n    lastActionMsg = `Added ${electron.value} to device (${currentSum} -> ${newSum}/${dev.target})`;\n    updateInfoBox();\n    playTone({ freq: 520 + electron.value * 15, duration: 0.12, type: \"sine\", volume: 0.06 });\n\n    // If exact\n    if (newSum === dev.target) {\n      dev.active = false;\n      score += 10;\n      lastActionMsg = `Great! Device reached ${dev.target}. The bulb lights up!`;\n      updateInfoBox();\n      playSuccessMelody();\n      animations.push(makeLightUpAnim(dev.x, dev.y));\n      // check if all done -> next round\n      if (devices.every(d => !d.active)) {\n        setTimeout(() => {\n          round++;\n          if (round <= MAX_ROUNDS) {\n            lastActionMsg = `Round complete! Get ready for round ${round}.`;\n            updateInfoBox();\n            spawnRound(round);\n          } else {\n            lastActionMsg = `You finished all rounds! Final score: ${score}. Press R to replay.`;\n            updateInfoBox();\n            // listen for R to reset\n            const onR = (ev) => {\n              if (ev.key === \"r\" || ev.key === \"R\") {\n                resetGameState();\n                container.removeEventListener(\"keydown\", onR);\n              }\n            };\n            container.addEventListener(\"keydown\", onR);\n          }\n        }, 900);\n      }\n    }\n  }\n\n  function undoLastElectron() {\n    const dev = devices[selectedDeviceIndex];\n    if (!dev) return;\n    const removed = dev.collected.pop();\n    if (!removed) {\n      lastActionMsg = \"Nothing to undo for this device.\";\n      updateInfoBox();\n      playErrorSound();\n      return;\n    }\n    // return electron to active\n    removed.collected = false;\n    removed.collectTime = null;\n    lastActionMsg = `Removed ${removed.value} from device.`;\n    updateInfoBox();\n    playTone({ freq: 240, duration: 0.08, type: \"sine\", volume: 0.04 });\n  }\n\n  function pickElectronByValue(val) {\n    // choose nearest electron to selected device with that value that is not collected\n    const candidates = electrons.filter(e => !e.collected && e.value === val);\n    if (candidates.length === 0) {\n      lastActionMsg = `No available electron with value ${val}.`;\n      updateInfoBox();\n      playErrorSound();\n      return;\n    }\n    const dev = devices[selectedDeviceIndex];\n    const chosen = candidates.reduce((best, c) => {\n      const d = Math.hypot(c.x - dev.x, c.y - dev.y);\n      if (!best || d < best.d) return { c, d };\n      return best;\n    }, null).c;\n    collectElectron(chosen);\n  }\n\n  // --- Animations / Visual effects ---\n  function makeAttachAnim(electron, device) {\n    const start = { x: electron.x, y: electron.y };\n    const end = { x: device.x + rand(-18, 18), y: device.y + rand(24, 40) };\n    const startTime = performance.now();\n    const duration = 470;\n    return {\n      type: \"attach\",\n      electron,\n      start,\n      end,\n      startTime,\n      duration\n    };\n  }\n\n  function makeOverloadAnim(x, y) {\n    return { type: \"overload\", x, y, t: performance.now(), life: 520 };\n  }\n\n  function makeLightUpAnim(x, y) {\n    return { type: \"light\", x, y, t: performance.now(), life: 900 };\n  }\n\n  // --- Drawing ---\n  function draw() {\n    // background\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    drawBackground();\n    drawCharacters();\n    drawDevices();\n    drawElectrons();\n    drawAnimations();\n    drawHUD();\n    drawAudioIcon();\n  }\n\n  function drawBackground() {\n    // gradient sky\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, \"#e8f7ff\");\n    g.addColorStop(1, \"#f6fbff\");\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // wacky clouds using arcs\n    for (let i = 0; i < 5; i++) {\n      const cx = (i / 5) * WIDTH + ((i % 2) * 80) - 60;\n      const cy = 50 + (i % 2) * 10;\n      ctx.fillStyle = `rgba(255,255,255,0.85)`;\n      ctx.beginPath();\n      ctx.ellipse(cx + 30, cy, 60, 26, 0, 0, Math.PI * 2);\n      ctx.ellipse(cx - 10, cy - 6, 44, 22, 0, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // soft grid lines to suggest circuits\n    ctx.strokeStyle = \"rgba(12,22,45,0.03)\";\n    ctx.lineWidth = 1;\n    for (let x = 0; x < WIDTH; x += 36) {\n      ctx.beginPath();\n      ctx.moveTo(x + (Math.sin(performance.now() / 2000 + x) * 3), 0);\n      ctx.lineTo(x + (Math.cos(performance.now() / 1800 + x) * 3), HEIGHT);\n      ctx.stroke();\n    }\n  }\n\n  function drawCharacters() {\n    // Dr. Volt (battery) left bottom\n    const dvx = 82;\n    const dvy = HEIGHT - 80;\n    drawBattery(dvx, dvy, characters.DrVolt.color, \"Dr. Volt\");\n\n    // Sparky (spark) right bottom\n    drawSpark( WIDTH - 120, HEIGHT - 85, characters.Sparky.color, \"Sparky\");\n\n    // Bulby small mascot near top center\n    drawBulb(WIDTH / 2, 60, characters.Bulby.color, \"Bulby\");\n\n    // subtle ground platform\n    ctx.fillStyle = \"rgba(10,10,10,0.04)\";\n    ctx.fillRect(0, HEIGHT - 40, WIDTH, 40);\n  }\n\n  function drawBattery(x, y, color, label) {\n    ctx.save();\n    ctx.translate(x, y);\n    // body\n    ctx.fillStyle = color;\n    roundRect(ctx, -32, -24, 64, 48, 10);\n    ctx.fill();\n    ctx.strokeStyle = \"#6b4c00\";\n    ctx.lineWidth = 1.5;\n    ctx.stroke();\n    // plus terminal\n    ctx.fillStyle = \"#ffffff\";\n    roundRect(ctx, -12, -34, 24, 8, 3);\n    ctx.fill();\n    // eyes and smile\n    ctx.fillStyle = \"#3a2b1a\";\n    ctx.beginPath();\n    ctx.arc(-10, -6, 3.5, 0, Math.PI * 2);\n    ctx.arc(10, -6, 3.5, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(0, 2, 9, 0, Math.PI);\n    ctx.stroke();\n    // label text\n    ctx.fillStyle = \"#2c2c2c\";\n    ctx.font = \"12px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(label, 0, 30);\n    ctx.restore();\n  }\n\n  function drawSpark(x, y, color, label) {\n    ctx.save();\n    ctx.translate(x, y);\n    // body\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(0, -28);\n    ctx.lineTo(12, -4);\n    ctx.lineTo(28, 0);\n    ctx.lineTo(12, 6);\n    ctx.lineTo(0, 28);\n    ctx.lineTo(-12, 6);\n    ctx.lineTo(-28, 0);\n    ctx.lineTo(-12, -4);\n    ctx.closePath();\n    ctx.fill();\n    // eyes\n    ctx.fillStyle = \"#1d2a2e\";\n    ctx.beginPath();\n    ctx.arc(-8, -2, 3, 0, Math.PI * 2);\n    ctx.arc(8, -2, 3, 0, Math.PI * 2);\n    ctx.fill();\n    // label\n    ctx.fillStyle = \"#1d2a2e\";\n    ctx.font = \"12px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(label, 0, 36);\n    ctx.restore();\n  }\n\n  function drawBulb(x, y, color, label) {\n    ctx.save();\n    ctx.translate(x, y);\n    // glass\n    const gradient = ctx.createRadialGradient(-6, -6, 4, 6, 6, 50);\n    gradient.addColorStop(0, \"#ffffff\");\n    gradient.addColorStop(1, color);\n    ctx.fillStyle = gradient;\n    ctx.beginPath();\n    ctx.ellipse(0, 6, 30, 32, 0, 0, Math.PI * 2);\n    ctx.fill();\n    // base\n    ctx.fillStyle = \"#b3b3b3\";\n    roundRect(ctx, -14, 32, 28, 14, 3);\n    ctx.fill();\n    // filament smile\n    ctx.strokeStyle = \"#6b4c00\";\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(-10, 6);\n    ctx.quadraticCurveTo(0, 18, 10, 6);\n    ctx.stroke();\n    // label\n    ctx.fillStyle = \"#2c2c2c\";\n    ctx.font = \"12px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(label, 0, -28);\n    ctx.restore();\n  }\n\n  function drawDevices() {\n    // draw each bulb device with target and collected electrons\n    devices.forEach((d, idx) => {\n      // bulb body\n      const lit = !d.active;\n      ctx.save();\n      ctx.translate(d.x, d.y);\n      // outer glow when lit\n      if (lit) {\n        const g = ctx.createRadialGradient(0, 6, 4, 0, 6, 60);\n        g.addColorStop(0, \"rgba(255,228,120,0.8)\");\n        g.addColorStop(1, \"rgba(255,228,120,0)\");\n        ctx.fillStyle = g;\n        ctx.beginPath();\n        ctx.ellipse(0, 6, 66, 72, 0, 0, Math.PI * 2);\n        ctx.fill();\n      }\n\n      // glass\n      ctx.fillStyle = lit ? \"#fff1b8\" : \"#fff\";\n      ctx.beginPath();\n      ctx.ellipse(0, 6, 30, 32, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.strokeStyle = \"#d7c2a6\";\n      ctx.lineWidth = 1.5;\n      ctx.stroke();\n      // base\n      ctx.fillStyle = \"#a0a0a0\";\n      roundRect(ctx, -14, 32, 28, 14, 3);\n      ctx.fill();\n\n      // target label and current sum\n      const current = d.collected.reduce((a, b) => a + b.value, 0);\n      ctx.fillStyle = \"#1d2a2e\";\n      ctx.font = \"14px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(`Target: ${d.target}`, 0, -46);\n      ctx.fillText(`${current} / ${d.target}`, 0, 60);\n\n      // show selection highlight\n      if (selectedDeviceIndex === idx) {\n        ctx.strokeStyle = \"rgba(38, 150, 255, 0.9)\";\n        ctx.lineWidth = 3;\n        ctx.beginPath();\n        ctx.ellipse(0, 6, 40, 44, 0, 0, Math.PI * 2);\n        ctx.stroke();\n      }\n\n      // draw wires: connect to battery left bottom\n      ctx.strokeStyle = \"rgba(60,60,60,0.25)\";\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(-300, HEIGHT - 80 - 20); // left towards battery\n      ctx.quadraticCurveTo(d.x - 120, d.y + 60, d.x, d.y + 34);\n      ctx.stroke();\n\n      // draw collected tokens near device\n      const startX = -28;\n      d.collected.forEach((e, i) => {\n        const px = startX + i * 18;\n        const py = 44;\n        ctx.fillStyle = \"#fffaf0\";\n        ctx.beginPath();\n        ctx.arc(px, py, 12, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.fillStyle = \"#2b2b2b\";\n        ctx.font = \"12px sans-serif\";\n        ctx.textAlign = \"center\";\n        ctx.fillText(String(e.value), px, py + 4);\n      });\n\n      ctx.restore();\n    });\n  }\n\n  function drawElectrons() {\n    // update electron positions (bob motion), then draw\n    const now = performance.now();\n    electrons.forEach(e => {\n      if (e.collected) {\n        // when collected, do not draw at original pos; attach anim moves it\n        return;\n      }\n      // bob\n      e.bob += 0.02 + Math.sin(now / 6000 + e.angle) * 0.002;\n      e.x += e.vx;\n      e.y = e.baseY + Math.sin(e.bob) * 8;\n      // wrap edges\n      if (e.x < 30) e.x = 30;\n      if (e.x > WIDTH - 30) e.x = WIDTH - 30;\n      // draw\n      drawElectron(e);\n    });\n  }\n\n  function drawElectron(e) {\n    // glow\n    ctx.save();\n    ctx.globalAlpha = 0.95;\n    const g = ctx.createRadialGradient(e.x, e.y - 4, 2, e.x, e.y, 28);\n    g.addColorStop(0, \"rgba(255,255,200,0.95)\");\n    g.addColorStop(1, \"rgba(255,225,100,0.02)\");\n    ctx.fillStyle = g;\n    ctx.beginPath();\n    ctx.ellipse(e.x, e.y, e.r + 10, e.r + 6, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // core circle\n    ctx.beginPath();\n    ctx.fillStyle = \"#fff8e5\";\n    ctx.arc(e.x, e.y, e.r + 2, 0, Math.PI * 2);\n    ctx.fill();\n    // ring\n    ctx.strokeStyle = \"#f2b800\";\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.arc(e.x, e.y, e.r + 2, 0, Math.PI * 2);\n    ctx.stroke();\n    // number text\n    ctx.fillStyle = \"#2a2a2a\";\n    ctx.font = \"bold 14px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(String(e.value), e.x, e.y + 5);\n    ctx.restore();\n  }\n\n  function drawAnimations() {\n    const now = performance.now();\n    // process attach animations\n    animations = animations.filter(a => {\n      if (a.type === \"attach\") {\n        const t = (now - a.startTime) / a.duration;\n        if (t >= 1) return false;\n        const ease = 1 - Math.pow(1 - t, 3);\n        const x = a.start.x + (a.end.x - a.start.x) * ease;\n        const y = a.start.y + (a.end.y - a.start.y) * ease;\n        // draw a moving electron\n        ctx.save();\n        ctx.globalAlpha = 1;\n        ctx.beginPath();\n        ctx.fillStyle = \"#fffaf0\";\n        ctx.arc(x, y, 10 + (1 - t) * 6, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.fillStyle = \"#2a2a2a\";\n        ctx.font = \"12px sans-serif\";\n        ctx.textAlign = \"center\";\n        ctx.fillText(String(a.electron.value), x, y + 4);\n        ctx.restore();\n        // small wire spark\n        ctx.save();\n        ctx.strokeStyle = `rgba(255,220,120,${1 - t})`;\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.moveTo(a.start.x, a.start.y);\n        ctx.lineTo(x, y);\n        ctx.stroke();\n        ctx.restore();\n        return true;\n      } else if (a.type === \"overload\") {\n        const tt = (now - a.t) / a.life;\n        if (tt > 1) return false;\n        // draw a quick burst\n        ctx.save();\n        const alpha = 1 - tt;\n        for (let i = 0; i < 7; i++) {\n          ctx.strokeStyle = `rgba(255,60,60,${alpha})`;\n          ctx.lineWidth = 1.2;\n          ctx.beginPath();\n          const ang = (i / 7) * Math.PI * 2 + tt * 8;\n          ctx.moveTo(a.x, a.y);\n          ctx.lineTo(a.x + Math.cos(ang) * 18 * (1 - tt), a.y + Math.sin(ang) * 18 * (1 - tt));\n          ctx.stroke();\n        }\n        ctx.restore();\n        return true;\n      } else if (a.type === \"light\") {\n        const life = a.life;\n        const t = (now - a.t) / life;\n        if (t > 1) return false;\n        // expanding glow\n        ctx.save();\n        const rad = 40 + t * 60;\n        const g = ctx.createRadialGradient(a.x, a.y, 10, a.x, a.y, rad);\n        g.addColorStop(0, `rgba(255,236,150,${0.6 - t * 0.5})`);\n        g.addColorStop(1, \"rgba(255,236,150,0)\");\n        ctx.fillStyle = g;\n        ctx.beginPath();\n        ctx.ellipse(a.x, a.y, rad, rad * 1.2, 0, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.restore();\n        return true;\n      }\n      return false;\n    });\n\n    // decorative floating sparks\n    animations.forEach(a => {\n      if (a.type === \"spark\") {\n        a.phase += 0.01;\n        const r = a.r + Math.sin(a.phase * 2) * 1.25;\n        ctx.save();\n        ctx.fillStyle = `rgba(255,255,180,0.6)`;\n        ctx.beginPath();\n        ctx.arc(a.x, a.y + Math.sin(a.phase) * 6, r, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.restore();\n      }\n    });\n\n    // draw collected electrons anchored to devices (static)\n    devices.forEach(d => {\n      d.collected.forEach((e, i) => {\n        // find if an attach anim in progress for this electron; if so skip drawing static small token\n        const inAnim = animations.some(a => a.type === \"attach\" && a.electron === e);\n        if (inAnim) return;\n        // else draw a token near device\n        ctx.save();\n        ctx.translate(d.x, d.y);\n        const px = -28 + i * 18;\n        const py = 44;\n        ctx.beginPath();\n        ctx.fillStyle = \"#fffaf0\";\n        ctx.arc(px, py, 12, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.fillStyle = \"#2d2d2d\";\n        ctx.font = \"12px sans-serif\";\n        ctx.textAlign = \"center\";\n        ctx.fillText(String(e.value), px, py + 4);\n        ctx.restore();\n      });\n    });\n  }\n\n  function drawHUD() {\n    // top bar with score, round, instructions\n    ctx.save();\n    ctx.fillStyle = \"rgba(255,255,255,0.6)\";\n    ctx.fillRect(8, 8, WIDTH - 16, 52);\n    // title and info\n    ctx.fillStyle = \"#15202b\";\n    ctx.font = \"18px sans-serif\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(`Power Planet - Round ${round}`, 20, 30);\n    ctx.font = \"14px sans-serif\";\n    ctx.fillText(`Score: ${score}`, 20, 48);\n\n    // last action message\n    ctx.font = \"13px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillStyle = \"#2c3a47\";\n    ctx.fillText(lastActionMsg, WIDTH / 2, 34);\n\n    // small control hints right\n    ctx.font = \"12px sans-serif\";\n    ctx.textAlign = \"right\";\n    ctx.fillStyle = \"#2d3b44\";\n    ctx.fillText(\"Click a bulb \u2192 Click electrons to add | Keys: \u2190 \u2192 1-9 Backspace M\", WIDTH - 16, 44);\n\n    ctx.restore();\n  }\n\n  function drawAudioIcon() {\n    // top-left small speaker icon inside canvas for toggling audio\n    const x = 22;\n    const y = 34;\n    ctx.save();\n    ctx.beginPath();\n    ctx.fillStyle = audioEnabled ? \"#2d9cdb\" : \"#b0b0b0\";\n    ctx.rect(12, 12, 44, 44);\n    ctx.fillStyle = \"rgba(255,255,255,0.05)\";\n    ctx.fillRect(12, 12, 44, 44);\n    // speaker body\n    ctx.fillStyle = audioEnabled ? \"#2d9cdb\" : \"#a0a0a0\";\n    ctx.beginPath();\n    ctx.moveTo(16, 32);\n    ctx.lineTo(28, 24);\n    ctx.lineTo(28, 40);\n    ctx.closePath();\n    ctx.fill();\n    // sound waves\n    ctx.strokeStyle = audioEnabled ? \"#2d9cdb\" : \"#a0a0a0\";\n    ctx.lineWidth = 2;\n    if (audioEnabled) {\n      ctx.beginPath();\n      ctx.arc(36, 32, 8, -0.6, 0.6);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.arc(36, 32, 12, -0.6, 0.6);\n      ctx.stroke();\n    } else {\n      // X mark when muted\n      ctx.strokeStyle = \"#d9534f\";\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(34, 25);\n      ctx.lineTo(44, 39);\n      ctx.moveTo(44, 25);\n      ctx.lineTo(34, 39);\n      ctx.stroke();\n    }\n\n    // accessible hint text near icon\n    ctx.font = \"10px sans-serif\";\n    ctx.fillStyle = \"#2d3b44\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(\"M to mute\", 12, 58);\n    ctx.restore();\n  }\n\n  // --- Helpers ---\n  function roundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n  }\n\n  // --- Animation Loop ---\n  let lastTime = 0;\n  function loop(t) {\n    if (isPaused) {\n      // draw paused overlay\n      draw();\n      ctx.save();\n      ctx.fillStyle = \"rgba(0,0,0,0.36)\";\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n      ctx.fillStyle = \"#fff\";\n      ctx.font = \"34px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(\"Paused\", WIDTH / 2, HEIGHT / 2);\n      ctx.restore();\n      requestAnimationFrame(loop);\n      return;\n    }\n    draw();\n    lastTime = t;\n    requestAnimationFrame(loop);\n  }\n\n  // --- Pause / Audio toggles ---\n  function togglePause() {\n    isPaused = !isPaused;\n    lastActionMsg = isPaused ? \"Game paused. Press P to resume.\" : \"Game resumed!\";\n    updateInfoBox();\n    playTone({ freq: 320, duration: 0.08, volume: 0.03 });\n  }\n\n  function toggleAudio() {\n    audioEnabled = !audioEnabled;\n    if (audioEnabled) {\n      ensureAudioOnUserGesture();\n      if (audioAvailable) startHum();\n      lastActionMsg = \"Audio on.\";\n      playTone({ freq: 600, duration: 0.08, volume: 0.05, type: \"triangle\" });\n    } else {\n      stopHum();\n      lastActionMsg = \"Audio muted. Press M or click speaker to unmute.\";\n      playErrorSound();\n    }\n    updateInfoBox();\n  }\n\n  // --- Info Box / Accessibility Text ---\n  function updateInfoBox() {\n    // Provide simple textual instructions and current state\n    const dev = devices[selectedDeviceIndex];\n    const devLabel = dev ? `Bulb ${selectedDeviceIndex + 1} target ${dev.target} current ${dev.collected.reduce((a,b)=>a+b.value,0)}` : \"\";\n    infoBox.textContent = `Round ${round} | Score ${score} | ${devLabel} | ${lastActionMsg} Controls: Click a bulb, then click electrons. Keyboard: Left/Right to change bulb, 1-9 to pick, Backspace to undo, M to mute.`;\n  }\n\n  // --- Extra Animations on specific events are added in their functions above ---\n\n  // --- Initialize and start ---\n  resetGameState();\n\n  // Ensure audio is off initially until user interacts\n  if (audioAvailable && audioEnabled) {\n    // do not auto-start hum until user interacts\n    stopHum();\n  }\n\n  // Kick off loop\n  requestAnimationFrame(loop);\n\n  // Announce initial instructions\n  lastActionMsg = \"Welcome to Power Planet! Click a bulb to select it, then click electrons to add numbers to reach the target. Try using keys 1-9 too. Press M to mute.\";\n  updateInfoBox();\n\n  // In case audio context cannot be created, inform user\n  if (!audioAvailable) {\n    lastActionMsg = \"Audio is not available in this browser \u2014 sound will be disabled. Follow on-screen text instructions.\";\n    updateInfoBox();\n  }\n\n  // Expose a small help overlay when pressing H or ?\n  container.addEventListener(\"keydown\", (e) => {\n    if (e.key === \"?\" || e.key === \"h\" || e.key === \"H\") {\n      alert(\"Power Planet Help:\\n- Click a bulb (top) to select it.\\n- Click electrons (floating circles) to add their value to the selected bulb.\\n- Use keys 1-9 to pick electrons by number.\\n- Use \u2190 \u2192 to switch selected bulb. Backspace to undo the last pick for the selected bulb.\\n- M to mute/unmute audio. P to pause.\\n- Reach the target exactly to light each bulb. Enjoy!\");\n    }\n  });\n\n  // Provide error handling for unexpected runtime exceptions inside animation frames\n  window.addEventListener(\"error\", (ev) => {\n    console.error(\"Runtime error in game:\", ev.error || ev.message);\n    lastActionMsg = \"An unexpected error occurred. Please reload the page to try again.\";\n    updateInfoBox();\n    stopHum();\n  });\n})();\n---\n",
  "improve_response_tokens": 24779,
  "formatted_code": true,
  "formatting_response_tokens": 27905,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}