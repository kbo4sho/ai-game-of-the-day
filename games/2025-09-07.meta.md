# Game of the Day - 2025-09-07

## Metadata
- **Generated Date:** 2025-09-07
- **Generated Time:** 2025-09-07T00:28:37.098039
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-07.js
- **File Size:** 25382 bytes
- **Tokens Used:** 9142

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-07.js` - The playable game
- `2025-09-07.meta.json` - Machine-readable metadata
- `2025-09-07.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 18144

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 19475

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
"use strict";

/*
  Machine Math - A calming, wacky math game for ages 7-9.
  Renders into the element with id "game-of-the-day-stage".
  All graphics are drawn on a canvas sized 720x480.
  Sounds are synthesized with the Web Audio API (no external files).
*/

/* =========================
   Setup DOM and Canvas
   ========================= */
const container = document.getElementById('game-of-the-day-stage');
if (!container) {
  throw new Error('Container element #game-of-the-day-stage not found.');
}
container.innerHTML = ''; // Clear any content

// Create canvas
const canvas = document.createElement('canvas');
canvas.width = 720;
canvas.height = 480;
// Accessibility attributes
canvas.setAttribute('role', 'application');
canvas.setAttribute('aria-label', 'Machine Math game. Use left and right arrows to pick a dial, up and down to change numbers, Enter to submit. Press H for hint, R to reset. Press M to toggle sound.');
canvas.tabIndex = 0; // make focusable for keyboard
canvas.style.outline = 'none';
container.appendChild(canvas);

const ctx = canvas.getContext('2d', { alpha: false });

/* =========================
   Constants and Utilities
   ========================= */
const WIDTH = canvas.width;
const HEIGHT = canvas.height;
const CENTER_X = WIDTH / 2;
const CENTER_Y = HEIGHT / 2;

const BG_COLOR = '#f3f6f7';
const MACHINE_COLOR = '#d7eaf0';
const ACCENT = '#7fb3c9';
const HIGHLIGHT = '#ffd27f';
const TEXT_COLOR = '#1f2d3d';
const GEAR_COLOR = '#c3dbe1';
const WACKY_COLOR = '#b083ff';

const NUM_DIALS = 4;
const DIAL_MIN = 0;
const DIAL_MAX = 9;
const TOTAL_LEVELS = 5; // beatable target count

function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

/* =========================
   Audio Setup with Error Handling
   ========================= */

let audioEnabled = true;
let audioUnavailableReason = null;
let audioCtx = null;
let masterGain = null;
let ambientGain = null;
let ambientOsc = null;

function initAudio() {
  if (audioCtx) return;
  try {
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) throw new Error('Web Audio API not supported in this browser.');
    audioCtx = new AC();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.85;
    masterGain.connect(audioCtx.destination);

    // Ambient gentle background: low frequency hum with slow amplitude wobble
    ambientGain = audioCtx.createGain();
    ambientGain.gain.value = 0.06;
    ambientGain.connect(masterGain);

    ambientOsc = audioCtx.createOscillator();
    ambientOsc.type = 'sine';
    ambientOsc.frequency.value = 110; // low hum
    // filter for mellow tone
    const filter = audioCtx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 600;
    ambientOsc.connect(filter);
    filter.connect(ambientGain);

    ambientOsc.start();

    // subtle amplitude modulation using another oscillator
    const lfo = audioCtx.createOscillator();
    const lfoGain = audioCtx.createGain();
    lfo.type = 'sine';
    lfo.frequency.value = 0.07;
    lfoGain.gain.value = 0.03;
    lfo.connect(lfoGain);
    lfoGain.connect(ambientGain.gain);
    lfo.start();

    audioEnabled = true;
  } catch (err) {
    console.warn('Audio initialization failed:', err);
    audioEnabled = false;
    audioUnavailableReason = err.message || String(err);
  }
}

// function to ensure audio context is resumed on user gesture
async function ensureAudioRunning() {
  if (!audioEnabled) return false;
  if (!audioCtx) initAudio();
  if (!audioCtx) return false;
  try {
    if (audioCtx.state === 'suspended') {
      await audioCtx.resume();
    }
    return true;
  } catch (err) {
    console.warn('Audio resume failed:', err);
    audioEnabled = false;
    audioUnavailableReason = err.message || String(err);
    return false;
  }
}

// Play a short tone; returns a promise that resolves when done
function playTone(freq = 440, timeMs = 200, type = 'sine', vol = 0.12) {
  return new Promise((resolve) => {
    if (!audioEnabled || !audioCtx) {
      resolve();
      return;
    }
    try {
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(vol, now + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + (timeMs / 1000));
      osc.connect(gain);
      gain.connect(masterGain);
      osc.start(now);
      osc.stop(now + (timeMs / 1000) + 0.02);
      osc.onended = () => {
        resolve();
      };
    } catch (err) {
      console.warn('playTone error', err);
      resolve();
    }
  });
}

// Play a sequence of tones
async function playSequence(freqs = [440], ms = 150, type = 'sine') {
  for (let i = 0; i < freqs.length; i++) {
    await playTone(freqs[i], ms, type);
    await new Promise(r => setTimeout(r, 60));
  }
}

// Success tune (ascending)
function successTune() {
  if (!audioEnabled) return;
  playSequence([440, 660, 880], 160, 'sine');
}

// Failure tune (descending buzz)
function failureTune() {
  if (!audioEnabled) return;
  playSequence([220, 180, 120], 180, 'square');
}

// Click
function clickBeep() {
  if (!audioEnabled) return;
  playTone(880, 90, 'triangle', 0.08);
}

/* =========================
   Game State and Logic
   ========================= */

const game = {
  level: 1,
  totalLevels: TOTAL_LEVELS,
  dials: new Array(NUM_DIALS).fill(0),
  selectedDial: 0,
  target: 0,
  hintUsed: false,
  moves: 0,
  correctCount: 0,
  running: true,
  machineSpin: 0, // for animation when machine runs
  lastFeedback: null, // 'correct'|'incorrect' for visuals
  feedbackTimer: 0,
  soundOn: true,
};

// Generate a target that is reachable with dials range
function generateTargetForLevel(level) {
  // Increase target complexity with level.
  // Minimum reachable is DIAL_MIN * NUM_DIALS = 0.
  // Max reachable is DIAL_MAX * NUM_DIALS = 36 when DIAL_MAX=9.
  // We'll choose target range expanding with level.
  const min = Math.max(3, Math.floor((level - 1) * 3) + 3);
  const max = Math.min(DIAL_MAX * NUM_DIALS, min + 6 + (level * 2));
  return randInt(min, max);
}

function resetDials() {
  for (let i = 0; i < NUM_DIALS; i++) {
    game.dials[i] = randInt(0, 4); // start with small calming values
  }
  game.selectedDial = 0;
  game.moves = 0;
  game.hintUsed = false;
  game.lastFeedback = null;
}

function startLevel(level = 1) {
  game.level = level;
  game.target = generateTargetForLevel(level);
  resetDials();
  game.running = true;
}

startLevel(1);

/* =========================
   Input Handling (Keyboard and Mouse)
   ========================= */

function handleKey(e) {
  // Allow arrow keys and letters
  const key = e.key;
  if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Enter', ' ', 'Spacebar'].includes(key) || /^[0-9a-zA-Z]$/.test(key)) {
    e.preventDefault();
  }

  if (key === 'ArrowLeft') {
    game.selectedDial = (game.selectedDial - 1 + NUM_DIALS) % NUM_DIALS;
    clickBeep();
  } else if (key === 'ArrowRight') {
    game.selectedDial = (game.selectedDial + 1) % NUM_DIALS;
    clickBeep();
  } else if (key === 'ArrowUp') {
    const before = game.dials[game.selectedDial];
    game.dials[game.selectedDial] = clamp(game.dials[game.selectedDial] + 1, DIAL_MIN, DIAL_MAX);
    if (game.dials[game.selectedDial] !== before) {
      game.moves++;
      clickBeep();
    }
  } else if (key === 'ArrowDown') {
    const before = game.dials[game.selectedDial];
    game.dials[game.selectedDial] = clamp(game.dials[game.selectedDial] - 1, DIAL_MIN, DIAL_MAX);
    if (game.dials[game.selectedDial] !== before) {
      game.moves++;
      clickBeep();
    }
  } else if (key === 'Enter') {
    submitAttempt();
  } else if (key.toLowerCase() === 'h') {
    provideHint();
  } else if (key.toLowerCase() === 'r') {
    // reset current level
    resetDials();
    clickBeep();
  } else if (key.toLowerCase() === 'm') {
    toggleSound();
  } else if (/^[0-9]$/.test(key)) {
    // direct number entry for selected dial
    const num = parseInt(key, 10);
    if (!isNaN(num)) {
      game.dials[game.selectedDial] = clamp(num, DIAL_MIN, DIAL_MAX);
      game.moves++;
      clickBeep();
    }
  }
}

canvas.addEventListener('keydown', (e) => {
  // Ensure audio context starts on first user interaction
  ensureAudioRunning().catch(() => {});
  handleKey(e);
});

canvas.addEventListener('click', (e) => {
  // Click to focus
  canvas.focus();
  // Determine click position for selecting dials or toggling sound
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  // Sound icon top-right bounds
  const soundBox = { x: WIDTH - 54, y: 8, w: 46, h: 46 };
  if (x >= soundBox.x && x <= soundBox.x + soundBox.w && y >= soundBox.y && y <= soundBox.y + soundBox.h) {
    toggleSound();
    return;
  }

  // Check dials region
  const dialsArea = { x: 80, y: 170, w: WIDTH - 160, h: 220 };
  if (x >= dialsArea.x && x <= dialsArea.x + dialsArea.w && y >= dialsArea.y && y <= dialsArea.y + dialsArea.h) {
    // Map x to dial
    const cellW = dialsArea.w / NUM_DIALS;
    let idx = Math.floor((x - dialsArea.x) / cellW);
    idx = clamp(idx, 0, NUM_DIALS - 1);
    if (game.selectedDial === idx) {
      // Clicked selected dial -> increment
      const before = game.dials[idx];
      game.dials[idx] = clamp(game.dials[idx] + 1, DIAL_MIN, DIAL_MAX);
      if (game.dials[idx] !== before) {
        game.moves++;
        clickBeep();
      }
    } else {
      game.selectedDial = idx;
      clickBeep();
    }
  }
});

// Provide hint: minimal helpful guidance
function provideHint() {
  if (game.hintUsed) return;
  game.hintUsed = true;
  // Suggest average per dial and a sample distribution
  const avg = Math.round(game.target / NUM_DIALS);
  // create a suggested array that sums to target
  let suggestion = new Array(NUM_DIALS).fill(avg);
  let sum = suggestion.reduce((a, b) => a + b, 0);
  let i = 0;
  while (sum < game.target) {
    suggestion[i % NUM_DIALS] = clamp(suggestion[i % NUM_DIALS] + 1, DIAL_MIN, DIAL_MAX);
    sum = suggestion.reduce((a, b) => a + b, 0);
    i++;
  }
  while (sum > game.target) {
    suggestion[i % NUM_DIALS] = clamp(suggestion[i % NUM_DIALS] - 1, DIAL_MIN, DIAL_MAX);
    sum = suggestion.reduce((a, b) => a + b, 0);
    i++;
  }
  // Set selected dial to 0 so the player makes changes manually (no auto-fill).
  game.selectedDial = 0;
  // store suggestion for display as visual hint
  game.lastSuggestion = suggestion;
  // play a gentle hint tone
  if (audioEnabled) playSequence([660, 720], 120, 'sine');
}

/* =========================
   Submit and Progression
   ========================= */

function submitAttempt() {
  const sum = game.dials.reduce((a, b) => a + b, 0);
  if (sum === game.target) {
    // correct
    game.correctCount++;
    game.lastFeedback = 'correct';
    game.feedbackTimer = performance.now();
    // animate machine starting
    game.machineSpin = 1.0;
    if (audioEnabled) successTune();
    // move to next level after a short delay
    setTimeout(() => {
      if (game.level < game.totalLevels) {
        startLevel(game.level + 1);
      } else {
        // victory
        game.running = false;
      }
    }, 900);
  } else {
    // incorrect
    game.lastFeedback = 'incorrect';
    game.feedbackTimer = performance.now();
    if (audioEnabled) failureTune();
    // slight jitter or reset one dial softly to encourage change
    // but don't block player's ability to keep trying. No fail state.
  }
}

/* =========================
   Toggle Sound (visual + audio)
   ========================= */

function toggleSound() {
  // If audio not available due to browser, show visual cue only
  if (!audioEnabled && !audioUnavailableReason) {
    // try again
    try {
      initAudio();
      if (audioEnabled) {
        ensureAudioRunning();
      }
    } catch (err) {
      audioUnavailableReason = err.message || String(err);
    }
  }
  if (!audioEnabled && audioUnavailableReason) {
    // can't enable, beep visual feedback
    game.lastFeedback = 'audionot';
    game.feedbackTimer = performance.now();
    return;
  }
  // Toggle master gain
  if (!audioCtx) initAudio();
  if (!audioCtx) {
    audioUnavailableReason = 'Unable to create audio context.';
    game.lastFeedback = 'audionot';
    game.feedbackTimer = performance.now();
    return;
  }

  if (audioCtx.state === 'suspended') {
    ensureAudioRunning();
    game.soundOn = true;
  } else {
    // toggle mute by changing gain
    if (masterGain) {
      if (game.soundOn) {
        try {
          masterGain.gain.setTargetAtTime(0.0001, audioCtx.currentTime, 0.01);
          game.soundOn = false;
        } catch (err) {
          console.warn('Mute failed', err);
        }
      } else {
        try {
          masterGain.gain.setTargetAtTime(0.85, audioCtx.currentTime, 0.01);
          game.soundOn = true;
        } catch (err) {
          console.warn('Unmute failed', err);
        }
      }
    }
  }
  // soft click to indicate change (if possible)
  if (game.soundOn) clickBeep();
}

/* =========================
   Drawing Helpers
   ========================= */

function roundedRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  ctx.fill();
}

// Draw friendly machine body
function drawMachineBody() {
  ctx.fillStyle = MACHINE_COLOR;
  roundedRect(ctx, 60, 120, WIDTH - 120, 260, 18);
  // panels
  ctx.fillStyle = '#eaf3f6';
  for (let i = 0; i < 4; i++) {
    const w = (WIDTH - 160) / 4 - 12;
    const x = 80 + i * ((WIDTH - 160) / 4);
    const y = 170;
    roundedRect(ctx, x, y, w, 160, 12);
  }
}

// Draw top control box with target display
function drawTopPanel() {
  // header
  ctx.fillStyle = ACCENT;
  roundedRect(ctx, 46, 36, WIDTH - 92, 96, 14);
  // machine name
  ctx.fillStyle = TEXT_COLOR;
  ctx.font = '20px system-ui, Arial';
  ctx.textBaseline = 'top';
  ctx.fillText('Machine Math: Fix the Wacky Machine!', 74, 46);
  ctx.font = '14px system-ui, Arial';
  ctx.fillStyle = '#113';
  ctx.fillText(`Level ${game.level} of ${game.totalLevels}`, WIDTH - 170, 46);
  // target display
  ctx.fillStyle = HIGHLIGHT;
  roundedRect(ctx, WIDTH - 200, 66, 120, 44, 8);
  ctx.fillStyle = TEXT_COLOR;
  ctx.font = '20px system-ui, Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(`Target: ${game.target}`, WIDTH - 140, 88);
  ctx.textAlign = 'start';
}

// Draw dials
function drawDials() {
  const areaX = 80;
  const areaY = 170;
  const areaW = WIDTH - 160;
  const areaH = 220;
  const cellW = areaW / NUM_DIALS;
  for (let i = 0; i < NUM_DIALS; i++) {
    const x = areaX + i * cellW + 6;
    const y = areaY + 14;
    const w = cellW - 12;
    const h = 160;
    // panel
    ctx.fillStyle = '#f9ffff';
    roundedRect(ctx, x, y, w, h, 12);

    // dial plate
    const dialCx = x + w / 2;
    const dialCy = y + 56;
    const dialR = 36;
    ctx.beginPath();
    ctx.arc(dialCx, dialCy, dialR + 6, 0, Math.PI * 2);
    ctx.fillStyle = GEAR_COLOR;
    ctx.fill();
    // small highlight ring
    ctx.beginPath();
    ctx.arc(dialCx, dialCy, dialR + 2, 0, Math.PI * 2);
    ctx.strokeStyle = '#e6f2f5';
    ctx.lineWidth = 3;
    ctx.stroke();

    // dial shadow and knob indicator (wacky gear)
    const angle = (game.dials[i] / (DIAL_MAX || 1)) * Math.PI * 2;
    // gear-like teeth drawn as arcs
    for (let t = 0; t < 8; t++) {
      const ta = (t / 8) * Math.PI * 2 + performance.now() / 2000 + (i * 0.4);
      ctx.beginPath();
      ctx.fillStyle = (t % 2 === 0) ? '#d1e6ea' : '#bfe7ef';
      const rx = dialCx + Math.cos(ta) * (dialR + 12);
      const ry = dialCy + Math.sin(ta) * (dialR + 12);
      ctx.ellipse(rx, ry, 8, 6, ta, 0, Math.PI * 2);
      ctx.fill();
    }

    // central knob
    ctx.beginPath();
    ctx.arc(dialCx, dialCy, dialR - 10, 0, Math.PI * 2);
    ctx.fillStyle = WACKY_COLOR;
    ctx.fill();
    ctx.beginPath();
    // show numeric label
    ctx.fillStyle = '#fff';
    ctx.font = '26px system-ui, Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(String(game.dials[i]), dialCx, dialCy);

    // dial selection glow
    if (game.selectedDial === i) {
      ctx.beginPath();
      ctx.arc(dialCx, dialCy, dialR + 12, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(255,210,127,0.7)';
      ctx.lineWidth = 6;
      ctx.stroke();
    }

    // small label below
    ctx.fillStyle = '#1b2b36';
    ctx.font = '14px system-ui, Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`Dial ${i + 1}`, x + w / 2, y + 120);
  }
}

// Draw machine gears and wacky animations
function drawGearsAndFeet() {
  // left gear
  const leftCx = 110;
  const leftCy = 360;
  const rightCx = WIDTH - 110;
  const rightCy = 360;
  const time = performance.now() / 800;
  // left gear rotates based on machineSpin
  const leftSpin = time * (0.8 + game.machineSpin * 3);
  const rightSpin = -time * (0.6 + game.machineSpin * 2);

  function drawGear(cx, cy, radius, teeth, spin, faceColor) {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(spin);
    // teeth
    for (let i = 0; i < teeth; i++) {
      const a = (i / teeth) * Math.PI * 2;
      ctx.beginPath();
      ctx.fillStyle = '#cfe7ea';
      ctx.moveTo(Math.cos(a) * (radius + 6), Math.sin(a) * (radius + 6));
      ctx.arc(Math.cos(a) * (radius + 6), Math.sin(a) * (radius + 6), 8, 0, Math.PI * 2);
      ctx.fill();
    }
    // main circle
    ctx.beginPath();
    ctx.fillStyle = faceColor;
    ctx.arc(0, 0, radius, 0, Math.PI * 2);
    ctx.fill();

    // smiley face
    ctx.fillStyle = '#113';
    ctx.beginPath();
    ctx.arc(-radius * 0.3, -radius * 0.2, radius * 0.12, 0, Math.PI * 2);
    ctx.arc(radius * 0.1, -radius * 0.2, radius * 0.12, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.strokeStyle = '#113';
    ctx.lineWidth = 2;
    ctx.arc(0, radius * 0.05, radius * 0.4, 0.1, Math.PI - 0.1);
    ctx.stroke();

    ctx.restore();
  }

  drawGear(leftCx, leftCy, 28, 10, leftSpin, '#bfe5e9');
  drawGear(rightCx, rightCy, 36, 12, rightSpin, '#aee0e5');
}

// Draw instructions and feedback
function drawTextAndUI() {
  ctx.fillStyle = TEXT_COLOR;
  ctx.font = '14px system-ui, Arial';
  ctx.textAlign = 'left';
  ctx.fillText('Controls: ← → select dial, ↑ ↓ change number, Enter submit, H hint, R reset, M toggle sound', 72, 420);
  ctx.fillText(`Moves: ${game.moves}`, 72, 440);
  ctx.textAlign = 'right';
  ctx.fillText(`Score: ${game.correctCount}`, WIDTH - 72, 440);

  // Feedback visual
  if (game.lastFeedback === 'correct' && performance.now() - game.feedbackTimer < 1500) {
    ctx.fillStyle = 'rgba(127, 211, 121, 0.18)';
    roundedRect(ctx, WIDTH / 2 - 160, 300, 320, 62, 12);
    ctx.fillStyle = '#2e7d32';
    ctx.font = '20px system-ui, Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Nice! Machine fixed!', WIDTH / 2, 335);
  } else if (game.lastFeedback === 'incorrect' && performance.now() - game.feedbackTimer < 1200) {
    ctx.fillStyle = 'rgba(255, 135, 135, 0.14)';
    roundedRect(ctx, WIDTH / 2 - 160, 300, 320, 62, 12);
    ctx.fillStyle = '#b71c1c';
    ctx.font = '18px system-ui, Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Oops! Try adjusting the dials a bit.', WIDTH / 2, 335);
  } else if (game.lastFeedback === 'audionot' && performance.now() - game.feedbackTimer < 1800) {
    ctx.fillStyle = 'rgba(255, 200, 100, 0.12)';
    roundedRect(ctx, WIDTH / 2 - 160, 300, 320, 62, 12);
    ctx.fillStyle = '#6a4f01';
    ctx.font = '16px system-ui, Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Audio unavailable: ' + (audioUnavailableReason || 'blocked'), WIDTH / 2, 335);
  }

  // Draw hint suggestion if used
  if (game.hintUsed && game.lastSuggestion) {
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.font = '13px system-ui, Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Hint suggestion: ' + game.lastSuggestion.join(' + ') + ` = ${game.target}`, WIDTH / 2, 465);
  }
}

// Draw sound icon (top right) with visual cue for audio state
function drawSoundIcon() {
  const x = WIDTH - 54;
  const y = 8;
  // box
  ctx.fillStyle = '#e8f1f3';
  ctx.beginPath();
  roundedRect(ctx, x, y, 46, 46, 8);
  // speaker
  ctx.save();
  ctx.translate(x + 22, y + 24);
  ctx.fillStyle = game.soundOn ? '#314b52' : '#8b8b8b';
  ctx.beginPath();
  ctx.moveTo(-10, -8);
  ctx.lineTo(-2, -8);
  ctx.lineTo(6, -16);
  ctx.lineTo(6, 16);
  ctx.lineTo(-2, 8);
  ctx.lineTo(-10, 8);
  ctx.closePath();
  ctx.fill();
  if (!game.soundOn) {
    ctx.strokeStyle = '#ff6b6b';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(10, -10);
    ctx.lineTo(18, 10);
    ctx.stroke();
  } else if (!audioEnabled && audioUnavailableReason) {
    // show small "x" or warning
    ctx.fillStyle = '#ffb86b';
    ctx.beginPath();
    ctx.arc(14, -12, 6, 0, Math.PI * 2);
    ctx.fill();
  } else {
    // gentle audio waves
    ctx.strokeStyle = 'rgba(49,75,82,0.9)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(6, -2, 8, -0.6, 0.6);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(6, -2, 12, -0.6, 0.6);
    ctx.stroke();
  }
  ctx.restore();
}

/* =========================
   Main Render Loop
   ========================= */

function update(delta) {
  // animate machineSpin towards 0 slowly
  if (game.machineSpin > 0) {
    game.machineSpin = Math.max(0, game.machineSpin - delta * 0.0025);
  }
}

let lastTime = performance.now();

function render() {
  const now = performance.now();
  const delta = now - lastTime;
  lastTime = now;
  update(delta);

  // Clear background
  ctx.fillStyle = BG_COLOR;
  ctx.fillRect(0, 0, WIDTH, HEIGHT);

  // Draw top panel
  drawTopPanel();

  // Machine body and dials
  drawMachineBody();
  drawDials();

  // Gears animation
  drawGearsAndFeet();

  // Controls and feedback text
  drawTextAndUI();

  // Sound icon
  drawSoundIcon();

  // If game complete, overlay victory screen
  if (!game.running) {
    ctx.fillStyle = 'rgba(18,34,40,0.88)';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.font = '34px system-ui, Arial';
    ctx.fillText('All Machines Fixed!', WIDTH / 2, HEIGHT / 2 - 20);
    ctx.font = '18px system-ui, Arial';
    ctx.fillText(`You fixed ${game.correctCount} machines with ${game.moves} moves.`, WIDTH / 2, HEIGHT / 2 + 14);
    ctx.font = '15px system-ui, Arial';
    ctx.fillText('Press R to restart the game.', WIDTH / 2, HEIGHT / 2 + 46);
  }

  requestAnimationFrame(render);
}

requestAnimationFrame(render);

/* =========================
   Accessibility & Focus Hints
   ========================= */

// Provide a visible focus ring when canvas focused
canvas.addEventListener('focus', () => {
  canvas.style.boxShadow = '0 0 0 3px rgba(127,210,255,0.25)';
});
canvas.addEventListener('blur', () => {
  canvas.style.boxShadow = 'none';
});

// Keyboard global: restart when finished
window.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 'r') {
    if (!game.running) {
      // restart game
      game.level = 1;
      game.correctCount = 0;
      startLevel(1);
      game.running = true;
      game.moves = 0;
      game.lastSuggestion = null;
      game.hintUsed = false;
      clickBeep();
    } else {
      // reset current level
      resetDials();
      clickBeep();
    }
  }
});

/* =========================
   Initialize Audio When Allowed
   ========================= */

// Try to initialize audio but handle errors gracefully
try {
  initAudio();
} catch (err) {
  console.warn('Audio init threw', err);
  audioEnabled = false;
  audioUnavailableReason = err.message || String(err);
}

/* =========================
   Expose a tiny help text for screen readers programmatically
   ========================= */
const srHelp = `Welcome to Machine Math. Objective: match the target number by adjusting four dials. 
Use arrow keys: left and right to pick a dial, up and down to change its number. Press Enter to submit. 
Press H for a hint. Press M to toggle sound. Press R to reset or restart.`;
canvas.setAttribute('aria-description', srHelp);

// Ensure canvas has focus initially for keyboard users
setTimeout(() => {
  try {
    canvas.focus();
  } catch (e) {
    // ignore
  }
}, 500);

/* =========================
   Final Safety: Prevent errors from halting game
   ========================= */
window.addEventListener('error', (ev) => {
  console.error('Runtime error in Machine Math:', ev.error || ev.message || ev);
  // show friendly message overlay
  ctx.fillStyle = 'rgba(255,255,255,0.98)';
  ctx.fillRect(0, 0, WIDTH, HEIGHT);
  ctx.fillStyle = '#c33';
  ctx.font = '18px system-ui, Arial';
  ctx.textAlign = 'center';
  ctx.fillText('Oops — something went wrong.', WIDTH / 2, HEIGHT / 2 - 10);
  ctx.fillStyle = '#333';
  ctx.font = '14px system-ui, Arial';
  ctx.fillText('Try reloading the page. If sound is not working, it may be blocked by the browser.', WIDTH / 2, HEIGHT / 2 + 16);
});
---

