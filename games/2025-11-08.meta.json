{
  "generated_date": "2025-11-08",
  "generated_timestamp": "2025-11-08T00:26:22.851045",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 10114,
  "game_filename": "2025-11-08.js",
  "game_size_bytes": 29376,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Drone Math Harvest - Canvas Game\n  // Renders inside element with id \"game-of-the-day-stage\"\n  // Designed for children ages 7-9. Use arrow keys/WASD to fly the drone and collect the correct answer balloon.\n  // Goal: collect 10 correct balloons. Lose: collect 3 wrong balloons. Restart from end screens.\n\n  // -----------------------\n  // Basic setup and safety\n  // -----------------------\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Container element with id \"game-of-the-day-stage\" not found.');\n    return;\n  }\n\n  // Clear container and create canvas\n  container.innerHTML = '';\n  const canvas = document.createElement('canvas');\n  canvas.width = 720;\n  canvas.height = 480;\n  canvas.style.width = '720px';\n  canvas.style.height = '480px';\n  canvas.setAttribute('role', 'img'); // accessibility role\n  canvas.setAttribute('aria-label', 'Drone Math Harvest. Use arrow keys to fly the drone. Collect the balloon with the correct answer. Press number keys 1-4 to choose answers.'); \n  canvas.tabIndex = 0; // allow keyboard focus\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext('2d');\n\n  // Fonts\n  const TITLE_FONT = 'bold 22px Verdana, sans-serif';\n  const UI_FONT = 'bold 20px Verdana, sans-serif';\n  const BODY_FONT = '16px Verdana, sans-serif'; // >=14px\n  const SMALL_FONT = '14px Verdana, sans-serif';\n\n  // UI padding constraints\n  const UI_PADDING = 12; // ensure 10px+ spacing\n\n  // -----------------------\n  // Audio setup with safe handling\n  // -----------------------\n  let audioEnabled = true;\n  let audioContext = null;\n  let masterGain = null;\n  try {\n    const AudioContext = window.AudioContext || window.webkitAudioContext;\n    if (!AudioContext) {\n      audioEnabled = false;\n      console.warn('Web Audio API not supported in this browser.');\n    } else {\n      audioContext = new AudioContext();\n      masterGain = audioContext.createGain();\n      masterGain.gain.value = 0.08; // gentle background volume\n      masterGain.connect(audioContext.destination);\n      // Create a gentle ambient background oscillator (very subtle)\n      const ambient = audioContext.createOscillator();\n      ambient.type = 'sine';\n      ambient.frequency.value = 120; // low frequency\n      const ambientGain = audioContext.createGain();\n      ambientGain.gain.value = 0.002; // very soft\n      ambient.connect(ambientGain);\n      ambientGain.connect(masterGain);\n      ambient.start();\n      // Fade in volume slightly to avoid click\n      masterGain.gain.setValueAtTime(0.0, audioContext.currentTime);\n      masterGain.gain.linearRampToValueAtTime(0.08, audioContext.currentTime + 0.5);\n    }\n  } catch (err) {\n    console.error('AudioContext creation failed:', err);\n    audioEnabled = false;\n  }\n\n  // Helper: play a short tone (frequency in Hz, duration in seconds, type)\n  function playTone({ freq = 440, duration = 0.2, type = 'sine', volume = 0.18 }) {\n    if (!audioEnabled || !audioContext) return;\n    try {\n      const o = audioContext.createOscillator();\n      const g = audioContext.createGain();\n      o.type = type;\n      o.frequency.value = freq;\n      g.gain.value = 0;\n      o.connect(g);\n      g.connect(masterGain);\n      const now = audioContext.currentTime;\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(volume, now + 0.02);\n      o.start(now);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);\n      o.stop(now + duration + 0.02);\n    } catch (err) {\n      console.warn('Error playing tone:', err);\n    }\n  }\n\n  // Correct ascending chime\n  function playCorrectSound() {\n    if (!audioEnabled) return;\n    // play three quick ascending tones\n    playTone({ freq: 440, duration: 0.08, type: 'triangle', volume: 0.14 });\n    setTimeout(() => playTone({ freq: 550, duration: 0.08, type: 'triangle', volume: 0.14 }), 80);\n    setTimeout(() => playTone({ freq: 660, duration: 0.14, type: 'sine', volume: 0.16 }), 160);\n  }\n\n  // Incorrect buzz\n  function playIncorrectSound() {\n    if (!audioEnabled) return;\n    // a short descending buzz\n    playTone({ freq: 220, duration: 0.2, type: 'square', volume: 0.14 });\n    setTimeout(() => playTone({ freq: 180, duration: 0.16, type: 'square', volume: 0.12 }), 60);\n  }\n\n  // Click-ish UI sound\n  function playClick() {\n    if (!audioEnabled) return;\n    playTone({ freq: 880, duration: 0.06, type: 'sine', volume: 0.06 });\n  }\n\n  // -----------------------\n  // Game variables\n  // -----------------------\n  let keys = {};\n  let mouse = { x: 0, y: 0, down: false };\n  let gameState = 'menu'; // 'playing', 'gameover', 'victory', 'menu'\n  let score = 0;\n  let wrong = 0;\n  const MAX_SCORE = 10;\n  const MAX_WRONG = 3;\n  let roundQuestion = null; // {a, b, op, answer}\n  let balloons = []; // array of answer balloon objects\n  let drone = null; // player object\n  let lastSpawnTime = 0;\n  let spawnInterval = 0; // not used maybe\n  let roundStartTime = 0;\n  let showAudioMutedFlash = false;\n  let audioToggleRect = null; // area for audio toggle on canvas\n  let lastFrameTime = performance.now();\n\n  // -----------------------\n  // Utility functions\n  // -----------------------\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  function clamp(v, a, b) {\n    return Math.max(a, Math.min(b, v));\n  }\n\n  // Accessibility: update aria-label with dynamic info\n  function updateAriaLabel() {\n    const label = `Drone Math Harvest. Score ${score}. Wrong ${wrong}. ${gameState === 'playing' ? `Question: ${roundQuestion && roundQuestion.text ? roundQuestion.text : ''}` : gameState}. Use arrow keys to fly the drone or press keys 1 to 4 to choose answers.`;\n    canvas.setAttribute('aria-label', label);\n  }\n\n  // -----------------------\n  // Game objects creation\n  // -----------------------\n  function createQuestion() {\n    // Create a friendly arithmetic question appropriate for ages 7-9\n    // Use addition and subtraction with small numbers\n    const op = Math.random() < 0.6 ? '+' : '-';\n    let a, b;\n    if (op === '+') {\n      a = randInt(1, 12);\n      b = randInt(1, 12);\n    } else {\n      a = randInt(5, 15);\n      b = randInt(1, a - 1);\n    }\n    const answer = op === '+' ? a + b : a - b;\n    const text = `${a} ${op} ${b} = ?`;\n    return { a, b, op, answer, text };\n  }\n\n  function spawnBalloonsForQuestion(q) {\n    balloons = [];\n    const correctIndex = randInt(0, 3);\n    const answers = new Set();\n    answers.add(q.answer);\n    for (let i = 0; i < 4; i++) {\n      let val;\n      if (i === correctIndex) {\n        val = q.answer;\n      } else {\n        // generate plausible wrong answers\n        do {\n          const delta = randInt(-6, 6);\n          val = q.answer + delta;\n        } while (val < 0 || answers.has(val));\n        answers.add(val);\n      }\n\n      // Position balloons in a spread-out layout to avoid overlap with UI\n      const marginX = 80;\n      const marginY = 90;\n      const x = marginX + i * ((canvas.width - marginX * 2) / 4) + randInt(-20, 20);\n      const y = randInt(120, 300) + (i % 2 === 0 ? -20 : 20);\n      const radius = 34;\n      const color = `hsl(${randInt(160, 320)} ${randInt(45, 75)}% ${randInt(50, 70)}%)`;\n      const vy = randInt(-8, 8) / 100 + (i % 2 === 0 ? -0.15 : -0.05);\n      balloons.push({\n        x,\n        y,\n        vy,\n        targetVy: vy,\n        radius,\n        value: val,\n        color,\n        id: i + 1,\n        floatingOffset: Math.random() * Math.PI * 2\n      });\n    }\n  }\n\n  function resetDrone() {\n    drone = {\n      x: canvas.width / 2,\n      y: canvas.height - 80,\n      vx: 0,\n      vy: 0,\n      speed: 2.6,\n      radius: 22,\n      tilt: 0 // for visual tilt\n    };\n  }\n\n  // -----------------------\n  // Start / restart\n  // -----------------------\n  function startGame() {\n    score = 0;\n    wrong = 0;\n    gameState = 'playing';\n    roundQuestion = createQuestion();\n    spawnBalloonsForQuestion(roundQuestion);\n    resetDrone();\n    roundStartTime = performance.now();\n    updateAriaLabel();\n    playClick();\n  }\n\n  function endGame(victory) {\n    gameState = victory ? 'victory' : 'gameover';\n    updateAriaLabel();\n    playClick();\n  }\n\n  // -----------------------\n  // Collisions and answer handling\n  // -----------------------\n  function checkCollisions() {\n    for (let i = 0; i < balloons.length; i++) {\n      const b = balloons[i];\n      // simple circle collision between drone and balloon\n      const dx = b.x - drone.x;\n      const dy = b.y - drone.y;\n      const distSq = dx * dx + dy * dy;\n      const minDist = b.radius + drone.radius;\n      if (distSq <= minDist * minDist) {\n        // collide\n        handleBalloonCollected(b);\n        return;\n      }\n    }\n  }\n\n  function handleBalloonCollected(b) {\n    if (!b) return;\n    const isCorrect = b.value === roundQuestion.answer;\n    // small visual pop and sound\n    if (isCorrect) {\n      score += 1;\n      playCorrectSound();\n    } else {\n      wrong += 1;\n      playIncorrectSound();\n    }\n    // simple balloon pop animation: remove balloon and trigger next question or end\n    balloons = balloons.filter(bb => bb !== b);\n    // after short delay, either spawn next question or end\n    setTimeout(() => {\n      if (score >= MAX_SCORE) {\n        endGame(true);\n        return;\n      }\n      if (wrong >= MAX_WRONG) {\n        endGame(false);\n        return;\n      }\n      roundQuestion = createQuestion();\n      spawnBalloonsForQuestion(roundQuestion);\n      updateAriaLabel();\n    }, 220);\n  }\n\n  // Keyboard selection fallback (1-4)\n  function selectAnswerByIndex(index) {\n    const b = balloons[index];\n    if (b) {\n      handleBalloonCollected(b);\n    }\n  }\n\n  // -----------------------\n  // Input handling\n  // -----------------------\n  canvas.addEventListener('keydown', (e) => {\n    keys[e.key] = true;\n    // Ensure audio context resumes on keyboard interaction for some browsers\n    if (audioContext && audioContext.state === 'suspended') {\n      audioContext.resume().catch(() => {});\n    }\n    // Number keys to select balloon 1-4\n    if (gameState === 'playing') {\n      if (e.key >= '1' && e.key <= '4') {\n        const idx = parseInt(e.key, 10) - 1;\n        selectAnswerByIndex(idx);\n      } else if (e.key === 'Enter') {\n        // attempt center-pick: pick balloon with smallest distance\n        if (balloons.length > 0) {\n          let closest = balloons[0];\n          let bestDist = Infinity;\n          for (const b of balloons) {\n            const d = (b.x - drone.x) ** 2 + (b.y - drone.y) ** 2;\n            if (d < bestDist) {\n              bestDist = d;\n              closest = b;\n            }\n          }\n          handleBalloonCollected(closest);\n        }\n      } else if (e.key === 'm') {\n        toggleAudio();\n      }\n    } else {\n      // End screen: Enter or Space restarts\n      if (e.key === 'Enter' || e.key === ' ') {\n        startGame();\n      }\n    }\n  });\n  canvas.addEventListener('keyup', (e) => {\n    delete keys[e.key];\n  });\n\n  // Mouse\n  canvas.addEventListener('mousemove', (e) => {\n    const r = canvas.getBoundingClientRect();\n    mouse.x = (e.clientX - r.left) * (canvas.width / r.width);\n    mouse.y = (e.clientY - r.top) * (canvas.height / r.height);\n  });\n  canvas.addEventListener('mousedown', (e) => {\n    mouse.down = true;\n    // If clicking audio toggle on top-right\n    if (audioToggleRect && pointInRect(mouse.x, mouse.y, audioToggleRect)) {\n      toggleAudio();\n      return;\n    }\n    // If end screens show, check for restart button click\n    if ((gameState === 'gameover' || gameState === 'victory')) {\n      const btn = getEndScreenButtonRect();\n      if (pointInRect(mouse.x, mouse.y, btn)) {\n        startGame();\n        return;\n      }\n    }\n    // If playing and clicking on a balloon, pick it\n    if (gameState === 'playing') {\n      for (let i = 0; i < balloons.length; i++) {\n        const b = balloons[i];\n        const dx = mouse.x - b.x;\n        const dy = mouse.y - b.y;\n        if (dx * dx + dy * dy <= b.radius * b.radius) {\n          handleBalloonCollected(b);\n          return;\n        }\n      }\n    }\n  });\n  canvas.addEventListener('mouseup', () => { mouse.down = false; });\n\n  // Helper: rectangle tests\n  function pointInRect(px, py, rect) {\n    if (!rect) return false;\n    return px >= rect.x && px <= rect.x + rect.w && py >= rect.y && py <= rect.y + rect.h;\n  }\n\n  // Toggle audio (visual cue)\n  function toggleAudio() {\n    if (!audioContext) {\n      audioEnabled = false;\n      showAudioMutedFlash = true;\n      setTimeout(() => (showAudioMutedFlash = false), 600);\n      return;\n    }\n    if (audioContext.state === 'suspended') {\n      audioContext.resume().then(() => {\n        audioEnabled = true;\n        showAudioMutedFlash = true;\n        setTimeout(() => (showAudioMutedFlash = false), 400);\n      }).catch(() => {\n        audioEnabled = false;\n      });\n    } else {\n      audioContext.suspend().then(() => {\n        audioEnabled = false;\n        showAudioMutedFlash = true;\n        setTimeout(() => (showAudioMutedFlash = false), 400);\n      }).catch(() => {\n        audioEnabled = false;\n      });\n    }\n    playClick();\n  }\n\n  // -----------------------\n  // Drawing helpers\n  // -----------------------\n  function drawRoundedRect(x, y, w, h, r, fillStyle, strokeStyle) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fillStyle) {\n      ctx.fillStyle = fillStyle;\n      ctx.fill();\n    }\n    if (strokeStyle) {\n      ctx.strokeStyle = strokeStyle;\n      ctx.stroke();\n    }\n  }\n\n  // Draw background: calming sky with wacky clouds and simple hills\n  function drawBackground(time) {\n    // gradient sky\n    const g = ctx.createLinearGradient(0, 0, 0, canvas.height);\n    g.addColorStop(0, '#eaf6ff');\n    g.addColorStop(1, '#dfeef6');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // sun: subtle\n    ctx.beginPath();\n    ctx.fillStyle = '#fff8c6';\n    ctx.shadowColor = 'rgba(255, 230, 120, 0.25)';\n    ctx.shadowBlur = 30;\n    ctx.arc(90, 80, 36, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.shadowBlur = 0;\n\n    // rolling hills (wacky shapes)\n    ctx.fillStyle = '#cdeecf';\n    ctx.beginPath();\n    ctx.moveTo(0, 330);\n    ctx.quadraticCurveTo(120, 300, 240, 340);\n    ctx.quadraticCurveTo(360, 380, 480, 340);\n    ctx.quadraticCurveTo(600, 300, 720, 330);\n    ctx.lineTo(720, 480);\n    ctx.lineTo(0, 480);\n    ctx.closePath();\n    ctx.fill();\n\n    // floating clouds (wacky)\n    ctx.fillStyle = '#ffffff';\n    for (let i = 0; i < 5; i++) {\n      const cx = (i * 160 + (time * 0.03 * (i % 2 === 0 ? 1 : -1))) % 840 - 60;\n      const cy = 60 + (i % 2) * 18;\n      drawCloud(cx, cy, 28 + (i % 3) * 8);\n    }\n  }\n\n  function drawCloud(cx, cy, s) {\n    ctx.beginPath();\n    ctx.moveTo(cx - s * 1.2, cy);\n    ctx.arc(cx - s * 0.6, cy - s * 0.2, s * 0.7, Math.PI * 0.5, Math.PI * 1.5);\n    ctx.arc(cx + s * 0.1, cy - s * 0.4, s * 0.9, Math.PI * 1.0, Math.PI * 1.9);\n    ctx.arc(cx + s * 0.9, cy - s * 0.1, s * 0.7, Math.PI * 1.5, Math.PI * 0.5);\n    ctx.closePath();\n    ctx.fill();\n    ctx.strokeStyle = 'rgba(0,0,0,0.02)';\n    ctx.stroke();\n  }\n\n  // Draw drone\n  function drawDrone(dr, time) {\n    const x = dr.x;\n    const y = dr.y;\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(dr.tilt * 0.02);\n    // shadow\n    ctx.beginPath();\n    ctx.fillStyle = 'rgba(0,0,0,0.12)';\n    ctx.ellipse(0, 30, dr.radius * 1.2, dr.radius * 0.5, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // body\n    ctx.beginPath();\n    ctx.fillStyle = '#2a9df4';\n    ctx.strokeStyle = '#083e6d';\n    ctx.lineWidth = 2;\n    ctx.moveTo(-28, -6);\n    ctx.quadraticCurveTo(0, -36, 28, -6); // canopy\n    ctx.quadraticCurveTo(0, 10, -28, -6);\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n\n    // window\n    ctx.beginPath();\n    ctx.fillStyle = '#bde9ff';\n    ctx.ellipse(0, -2, 10, 7, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = 'rgba(0,0,0,0.1)';\n    ctx.stroke();\n\n    // propellers: wacky spinning\n    for (let i = -1; i <= 1; i += 2) {\n      const px = i * 26;\n      const py = -12;\n      ctx.beginPath();\n      ctx.fillStyle = '#f6f6f6';\n      ctx.ellipse(px, py, 12, 6, 0, 0, Math.PI * 2);\n      ctx.fill();\n      // blades\n      ctx.save();\n      ctx.translate(px, py);\n      ctx.rotate((time / 120) * (i === -1 ? 1 : -1));\n      ctx.fillStyle = 'rgba(0,0,0,0.25)';\n      ctx.fillRect(-18, -2, 36, 4);\n      ctx.restore();\n    }\n    ctx.restore();\n  }\n\n  // Draw balloons\n  function drawBalloons(balloonsArr, time) {\n    for (const b of balloonsArr) {\n      // floating movement\n      const floaty = Math.sin((time / 600) + b.floatingOffset) * 4;\n      const bx = b.x;\n      const by = b.y + floaty;\n      // string\n      ctx.beginPath();\n      ctx.strokeStyle = 'rgba(0,0,0,0.08)';\n      ctx.lineWidth = 2;\n      ctx.moveTo(bx, by + b.radius - 2);\n      ctx.quadraticCurveTo(bx + 8, by + b.radius + 18, bx + 4, by + b.radius + 32);\n      ctx.stroke();\n\n      // balloon\n      ctx.beginPath();\n      ctx.fillStyle = b.color;\n      ctx.strokeStyle = 'rgba(0,0,0,0.08)';\n      ctx.lineWidth = 1;\n      ctx.ellipse(bx, by, b.radius, b.radius * 1.14, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n\n      // highlight patch\n      ctx.beginPath();\n      ctx.fillStyle = 'rgba(255,255,255,0.4)';\n      ctx.ellipse(bx - b.radius * 0.25, by - b.radius * 0.3, b.radius * 0.3, b.radius * 0.14, 0, 0, Math.PI * 2);\n      ctx.fill();\n\n      // Number label (body text)\n      ctx.font = 'bold 18px Verdana, sans-serif';\n      ctx.fillStyle = '#083e6d';\n      const text = String(b.value);\n      const metrics = ctx.measureText(text);\n      ctx.fillText(text, bx - metrics.width / 2, by + 6);\n\n      // Small index number for keyboard selection: 1-4\n      ctx.font = SMALL_FONT;\n      ctx.fillStyle = 'rgba(0,0,0,0.4)';\n      const idxText = `(${b.id})`;\n      const idxW = ctx.measureText(idxText).width;\n      ctx.fillText(idxText, bx - idxW / 2, by + b.radius * 1.5 + 8);\n    }\n  }\n\n  // Draw top-left score and top-right lives and audio control\n  function drawUI() {\n    // Score - top-left\n    ctx.font = UI_FONT;\n    ctx.textBaseline = 'top';\n    const scoreText = `Score: ${score}/${MAX_SCORE}`;\n    const scW = ctx.measureText(scoreText).width;\n    const scRect = {\n      x: UI_PADDING,\n      y: UI_PADDING,\n      w: scW + 16,\n      h: 36\n    };\n    drawRoundedRect(scRect.x, scRect.y, scRect.w, scRect.h, 8, 'rgba(255,255,255,0.9)', 'rgba(0,0,0,0.06)');\n    ctx.fillStyle = '#083e6d';\n    ctx.fillText(scoreText, scRect.x + 8, scRect.y + 6);\n\n    // Lives/wrong - top-right\n    ctx.font = UI_FONT;\n    const livesText = `Lives left: ${Math.max(0, MAX_WRONG - wrong)}`;\n    const lvW = ctx.measureText(livesText).width;\n    const lvRect = {\n      x: canvas.width - lvW - UI_PADDING - 16,\n      y: UI_PADDING,\n      w: lvW + 16,\n      h: 36\n    };\n    drawRoundedRect(lvRect.x, lvRect.y, lvRect.w, lvRect.h, 8, 'rgba(255,255,255,0.9)', 'rgba(0,0,0,0.06)');\n    ctx.fillStyle = '#083e6d';\n    ctx.fillText(livesText, lvRect.x + 8, lvRect.y + 6);\n\n    // Audio toggle small icon near lives (left of it)\n    const audSize = 28;\n    const audX = lvRect.x - audSize - 10;\n    const audY = UI_PADDING + (36 - audSize) / 2;\n    audioToggleRect = { x: audX, y: audY, w: audSize, h: audSize };\n    ctx.beginPath();\n    drawRoundedRect(audX, audY, audSize, audSize, 6, audioEnabled ? 'rgba(200,255,200,0.95)' : 'rgba(255,200,200,0.95)', 'rgba(0,0,0,0.06)');\n    ctx.fillStyle = audioEnabled ? '#036a0d' : '#8b0000';\n    ctx.font = 'bold 14px Verdana, sans-serif';\n    const spText = audioEnabled ? '\ud83d\udd0a' : '\ud83d\udd08';\n    const spW = ctx.measureText(spText).width;\n    ctx.fillText(spText, audX + (audSize - spW) / 2, audY + 6);\n\n    // If audio is disabled, show a small visual cue near bottom\n    if (!audioEnabled || showAudioMutedFlash) {\n      ctx.font = SMALL_FONT;\n      ctx.fillStyle = showAudioMutedFlash ? '#ff7700' : '#8b0000';\n      const hint = audioEnabled ? 'Audio on' : 'Audio off (press M)';\n      const w = ctx.measureText(hint).width;\n      const hx = canvas.width - w - UI_PADDING - 6;\n      const hy = UI_PADDING + 36 + 8;\n      drawRoundedRect(hx - 6, hy - 4, w + 12, 26, 6, 'rgba(255,255,255,0.92)', 'rgba(0,0,0,0.06)');\n      ctx.fillText(hint, hx, hy);\n    }\n  }\n\n  // Bottom-center instructions - ensure non-overlap\n  function drawInstructions() {\n    ctx.font = BODY_FONT;\n    ctx.textBaseline = 'top';\n    const lines = [\n      'Fly the friendly drone to the balloon that shows the correct answer.',\n      'Use arrow keys or W/A/S/D to move. Press 1-4 to pick an answer, or click a balloon.',\n      `Goal: collect ${MAX_SCORE} correct balloons. Lose after ${MAX_WRONG} wrong ones.`,\n      'Press M to toggle audio. Press Enter to start / restart.'\n    ];\n    // measure widest\n    let maxW = 0;\n    for (const l of lines) {\n      maxW = Math.max(maxW, ctx.measureText(l).width);\n    }\n    const rectW = maxW + 20;\n    const rectH = lines.length * 22 + 18;\n    const rectX = (canvas.width - rectW) / 2;\n    const rectY = canvas.height - rectH - UI_PADDING;\n    drawRoundedRect(rectX, rectY, rectW, rectH, 10, 'rgba(255,255,255,0.92)', 'rgba(0,0,0,0.06)');\n    ctx.fillStyle = '#083e6d';\n    let y = rectY + 8;\n    for (const l of lines) {\n      ctx.fillText(l, rectX + 10, y);\n      y += 22;\n    }\n  }\n\n  // End screen button rectangle calculation\n  function getEndScreenButtonRect() {\n    const w = 220;\n    const h = 48;\n    return {\n      x: (canvas.width - w) / 2,\n      y: canvas.height - 120,\n      w,\n      h\n    };\n  }\n\n  // Render gameover or victory screen\n  function drawEndScreen() {\n    ctx.font = TITLE_FONT;\n    ctx.textBaseline = 'top';\n    // translucent overlay\n    ctx.fillStyle = 'rgba(10, 20, 30, 0.35)';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // message\n    const title = gameState === 'victory' ? 'Mission Complete!' : 'Game Over';\n    const subtitle = gameState === 'victory'\n      ? `You collected ${score} correct balloons!`\n      : `You made ${wrong} wrong picks. Score: ${score}`;\n\n    // Title box\n    ctx.font = TITLE_FONT;\n    const tW = ctx.measureText(title).width;\n    const titleX = (canvas.width - tW) / 2;\n    const titleY = 120;\n    drawRoundedRect(titleX - 14, titleY - 12, tW + 28, 50, 12, 'rgba(255,255,255,0.95)', 'rgba(0,0,0,0.06)');\n    ctx.fillStyle = '#0d3b5a';\n    ctx.fillText(title, titleX, titleY);\n\n    // Subtitle\n    ctx.font = BODY_FONT;\n    const subW = ctx.measureText(subtitle).width;\n    const subX = (canvas.width - subW) / 2;\n    const subY = titleY + 58;\n    drawRoundedRect(subX - 12, subY - 8, subW + 24, 40, 8, 'rgba(255,255,255,0.95)', 'rgba(0,0,0,0.04)');\n    ctx.fillStyle = '#083e6d';\n    ctx.fillText(subtitle, subX, subY);\n\n    // Restart button\n    const btn = getEndScreenButtonRect();\n    drawRoundedRect(btn.x, btn.y, btn.w, btn.h, 10, 'rgba(255,255,255,0.98)', 'rgba(0,0,0,0.08)');\n    ctx.font = UI_FONT;\n    ctx.fillStyle = '#0266a6';\n    const btText = 'Play Again (Enter)';\n    const btW = ctx.measureText(btText).width;\n    ctx.fillText(btText, btn.x + (btn.w - btW) / 2, btn.y + 10);\n  }\n\n  // Draw current question area - bottom-left area reserved to avoid overlap\n  function drawQuestionPanel() {\n    // place near center-top-ish to avoid overlapping balloons\n    ctx.font = 'bold 20px Verdana, sans-serif';\n    const qText = roundQuestion ? roundQuestion.text : '';\n    const qW = ctx.measureText(qText).width;\n    const boxW = qW + 40;\n    const boxH = 48;\n    const boxX = (canvas.width - boxW) / 2;\n    const boxY = 18 + 36; // under top UI\n    drawRoundedRect(boxX, boxY, boxW, boxH, 10, 'rgba(255,255,255,0.96)', 'rgba(0,0,0,0.04)');\n    ctx.fillStyle = '#083e6d';\n    ctx.fillText(qText, boxX + 20, boxY + 12);\n    // Also show small hint for keyboard numbers\n    ctx.font = SMALL_FONT;\n    const hint = 'Press 1-4 or fly to the correct balloon';\n    const hintW = ctx.measureText(hint).width;\n    ctx.fillStyle = 'rgba(0,0,0,0.45)';\n    ctx.fillText(hint, (canvas.width - hintW) / 2, boxY + boxH + 6);\n  }\n\n  // -----------------------\n  // Game loop and updates\n  // -----------------------\n  function update(dt, t) {\n    if (gameState !== 'playing') return;\n\n    // Control drone\n    const moveLeft = keys.ArrowLeft || keys.a || keys.A;\n    const moveRight = keys.ArrowRight || keys.d || keys.D;\n    const moveUp = keys.ArrowUp || keys.w || keys.W;\n    const moveDown = keys.ArrowDown || keys.s || keys.S;\n\n    const acc = 0.12;\n    if (moveLeft) drone.vx -= acc;\n    if (moveRight) drone.vx += acc;\n    if (moveUp) drone.vy -= acc;\n    if (moveDown) drone.vy += acc;\n\n    // gentle damping\n    drone.vx *= 0.96;\n    drone.vy *= 0.96;\n\n    // apply speed clamp\n    drone.vx = clamp(drone.vx, -drone.speed, drone.speed);\n    drone.vy = clamp(drone.vy, -drone.speed, drone.speed);\n\n    drone.x += drone.vx * dt;\n    drone.y += drone.vy * dt;\n\n    // Keep inside canvas bounds (with padding)\n    drone.x = clamp(drone.x, 30, canvas.width - 30);\n    drone.y = clamp(drone.y, 80, canvas.height - 40);\n\n    // tilt based on vx\n    drone.tilt = drone.vx * 12;\n\n    // Update balloons floating and slight random horizontal drift\n    for (const b of balloons) {\n      b.floatingOffset += dt * 0.001;\n      b.y += b.vy * dt;\n      // small horizontal drift to keep lively\n      b.x += Math.sin((t + b.x) / 4000) * 0.3;\n\n      // gentle bounce if hit bounds\n      if (b.x < 40) b.x = 40;\n      if (b.x > canvas.width - 40) b.x = canvas.width - 40;\n      if (b.y < 90) b.y = 90;\n      if (b.y > canvas.height - 120) b.y = canvas.height - 120;\n    }\n\n    // collision checks\n    checkCollisions();\n  }\n\n  function render(t) {\n    // Clear\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    // draw background\n    drawBackground(t);\n    // draw balloons under drone to create depth\n    drawBalloons(balloons, t);\n    // draw drone on top\n    if (drone) drawDrone(drone, t);\n    // UI\n    drawUI();\n    // question panel\n    if (gameState === 'playing') {\n      drawQuestionPanel();\n    }\n    // instructions bottom\n    drawInstructions();\n    // end screens\n    if (gameState === 'gameover' || gameState === 'victory') {\n      drawEndScreen();\n    }\n  }\n\n  function loop(now) {\n    const dt = Math.min(50, now - lastFrameTime); // ms, capped for stability\n    update(dt / 16.67, now); // normalize roughly to frame scaling\n    render(now);\n    lastFrameTime = now;\n    requestAnimationFrame(loop);\n  }\n\n  // -----------------------\n  // Initialization\n  // -----------------------\n  function init() {\n    // Initial focus\n    canvas.focus();\n\n    // Friendly starting menu\n    gameState = 'menu';\n    score = 0;\n    wrong = 0;\n    roundQuestion = createQuestion();\n    spawnBalloonsForQuestion(roundQuestion);\n    resetDrone();\n\n    // Start the animation loop\n    requestAnimationFrame(loop);\n\n    // Draw a simple initial frame immediately\n    render(performance.now());\n  }\n\n  // Start when user interacts or immediately\n  // Some browsers block AudioContext until user gesture; audio handling attempts to resume on first key or mouse.\n  canvas.addEventListener('click', () => {\n    if (gameState === 'menu') {\n      startGame();\n    }\n  });\n\n  // Show initial menu overlay drawn each frame from gameState === 'menu'\n  function drawMenuOverlay() {\n    // will be drawn inside render when gameState === 'menu'\n    ctx.fillStyle = 'rgba(255,255,255,0.96)';\n    drawRoundedRect(80, 80, canvas.width - 160, canvas.height - 160, 12, 'rgba(255,255,255,0.96)', 'rgba(0,0,0,0.06)');\n    ctx.font = 'bold 28px Verdana, sans-serif';\n    ctx.fillStyle = '#084b6b';\n    const title = 'Drone Math Harvest';\n    const w = ctx.measureText(title).width;\n    ctx.fillText(title, (canvas.width - w) / 2, 120);\n\n    ctx.font = '18px Verdana, sans-serif';\n    ctx.fillStyle = '#083e6d';\n    const lines = [\n      'Help the friendly drone collect the balloon with the correct answer.',\n      'Use arrow keys or W/A/S/D to move. Press 1-4 to choose answers.',\n      `Goal: collect ${MAX_SCORE} correct balloons. Lose after ${MAX_WRONG} wrong picks.`,\n      'Click anywhere or press Enter to start.'\n    ];\n    let y = 180;\n    for (const line of lines) {\n      const lw = ctx.measureText(line).width;\n      ctx.fillText(line, (canvas.width - lw) / 2, y);\n      y += 28;\n    }\n\n    // small playful hint\n    ctx.font = '16px Verdana, sans-serif';\n    const hint = 'Tip: keyboard selection is a helpful accessible option!';\n    const hw = ctx.measureText(hint).width;\n    ctx.fillStyle = 'rgba(0,0,0,0.45)';\n    ctx.fillText(hint, (canvas.width - hw) / 2, y + 16);\n  }\n\n  // We will override render to include menu drawing\n  const originalRender = render;\n  function renderWithMenu(t) {\n    originalRender(t);\n    if (gameState === 'menu') {\n      drawMenuOverlay();\n    }\n  }\n  // Replace render used in loop\n  render = renderWithMenu;\n\n  // Start initialization\n  try {\n    init();\n  } catch (err) {\n    console.error('Game initialization error:', err);\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.font = TITLE_FONT;\n    ctx.fillStyle = '#000';\n    ctx.fillText('An error occurred starting the game.', 20, 40);\n  }\n\n  // Ensure aria label updates periodically\n  setInterval(updateAriaLabel, 1200);\n})();\n---\n",
  "improve_response_tokens": 20836,
  "formatted_code": true,
  "formatting_response_tokens": 22636,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}