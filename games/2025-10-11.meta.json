{
  "generated_date": "2025-10-11",
  "generated_timestamp": "2025-10-11T00:25:44.326886",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9291,
  "game_filename": "2025-10-11.js",
  "game_size_bytes": 27848,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Machine Math Workshop - JavaScript Game\n// Renders inside element with ID \"game-of-the-day-stage\"\n// Canvas 720x480. No external assets. Uses Web Audio API oscillators.\n// Accessible controls: ArrowLeft/ArrowRight to select parts, Enter to place, Backspace to remove last placed,\n// A to toggle audio, R to reset level, Space to pick up / drop with keyboard.\n// Mouse: click to pick/select, drag to place. Speaker icon toggles audio.\n// Includes error handling for AudioContext and resource setup.\n\n// Immediately-invoked function to avoid polluting global scope\n(function () {\n  // Locate container\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Game container #game-of-the-day-stage not found.');\n    return;\n  }\n\n  // Clear container\n  container.innerHTML = '';\n  container.style.position = 'relative';\n  container.style.userSelect = 'none';\n\n  // Create accessible live region for screen readers\n  const liveRegion = document.createElement('div');\n  liveRegion.setAttribute('role', 'status');\n  liveRegion.setAttribute('aria-live', 'polite');\n  liveRegion.style.position = 'absolute';\n  liveRegion.style.left = '-9999px';\n  liveRegion.style.width = '1px';\n  liveRegion.style.height = '1px';\n  liveRegion.style.overflow = 'hidden';\n  container.appendChild(liveRegion);\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.width = WIDTH + 'px';\n  canvas.style.height = HEIGHT + 'px';\n  canvas.setAttribute('tabindex', '0'); // focusable for keyboard\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Handle high DPI displays\n  function resizeForDPR() {\n    const dpr = window.devicePixelRatio || 1;\n    canvas.width = WIDTH * dpr;\n    canvas.height = HEIGHT * dpr;\n    canvas.style.width = WIDTH + 'px';\n    canvas.style.height = HEIGHT + 'px';\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n  }\n  resizeForDPR();\n\n  // Audio setup with error handling\n  let audioEnabled = true;\n  let audioCtx = null;\n  let masterGain = null;\n  let humNode = null;\n  try {\n    const AudioContext = window.AudioContext || window.webkitAudioContext;\n    if (!AudioContext) throw new Error('Web Audio API not supported.');\n    audioCtx = new AudioContext();\n    masterGain = audioCtx.createGain();\n    masterGain.gain.value = 0.12; // gentle overall volume\n    masterGain.connect(audioCtx.destination);\n  } catch (err) {\n    console.warn('Audio disabled:', err.message);\n    audioEnabled = false;\n    audioCtx = null;\n  }\n\n  // Audio helper functions\n  function safeResumeAudio() {\n    if (!audioCtx) return Promise.resolve();\n    if (audioCtx.state === 'suspended') {\n      return audioCtx.resume().catch((e) => {\n        console.warn('Audio resume failed:', e);\n      });\n    }\n    return Promise.resolve();\n  }\n\n  // Play a short tone; returns a Promise resolved when done\n  function playTone(freq, duration = 0.25, type = 'sine', options = {}) {\n    if (!audioEnabled || !audioCtx) return Promise.resolve();\n    const osc = audioCtx.createOscillator();\n    const gain = audioCtx.createGain();\n    const now = audioCtx.currentTime;\n    osc.type = type;\n    osc.frequency.value = freq;\n    gain.gain.value = 0;\n    // gentle attack/decay\n    gain.gain.linearRampToValueAtTime(options.maxGain || 0.12, now + 0.005);\n    gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);\n\n    // optional filter for richer sound\n    if (options.filter) {\n      const filter = audioCtx.createBiquadFilter();\n      filter.type = options.filter.type || 'lowpass';\n      filter.frequency.value = options.filter.freq || 1200;\n      osc.connect(filter);\n      filter.connect(gain);\n    } else {\n      osc.connect(gain);\n    }\n\n    gain.connect(masterGain);\n    osc.start(now);\n    osc.stop(now + duration + 0.02);\n    return new Promise((res) => {\n      setTimeout(res, (duration + 0.02) * 1000);\n    });\n  }\n\n  function playClick() {\n    return playTone(880, 0.06, 'square', { maxGain: 0.08 });\n  }\n  function playWrong() {\n    return playTone(220, 0.5, 'sawtooth', {\n      maxGain: 0.18,\n      filter: { type: 'lowpass', freq: 800 },\n    });\n  }\n  function playSuccess() {\n    // triad of notes\n    return safeResumeAudio().then(() =>\n      Promise.all([\n        playTone(660, 0.18, 'triangle', { maxGain: 0.12 }),\n        new Promise((r) => setTimeout(r, 90)).then(() =>\n          playTone(880, 0.22, 'triangle', { maxGain: 0.12 })\n        ),\n        new Promise((r) => setTimeout(r, 180)).then(() =>\n          playTone(990, 0.28, 'triangle', { maxGain: 0.12 })\n        ),\n      ])\n    );\n  }\n\n  // Gentle background hum with slow wobble\n  function startHum() {\n    if (!audioEnabled || !audioCtx || humNode) return;\n    const osc = audioCtx.createOscillator();\n    const gain = audioCtx.createGain();\n    const lfo = audioCtx.createOscillator();\n    const lfoGain = audioCtx.createGain();\n\n    osc.type = 'sine';\n    osc.frequency.value = 110;\n    gain.gain.value = 0.06;\n    lfo.type = 'sine';\n    lfo.frequency.value = 0.15;\n    lfoGain.gain.value = 8;\n    lfo.connect(lfoGain);\n    lfoGain.connect(osc.frequency);\n\n    osc.connect(gain);\n    gain.connect(masterGain);\n    osc.start();\n    lfo.start();\n    humNode = { osc, gain, lfo, lfoGain };\n  }\n  function stopHum() {\n    if (!humNode) return;\n    try {\n      humNode.osc.stop();\n      humNode.lfo.stop();\n    } catch (e) {\n      // ignore\n    }\n    humNode = null;\n  }\n\n  // Toggle audio with proper resume\n  function toggleAudio() {\n    if (!audioCtx) {\n      audioEnabled = false;\n      return;\n    }\n    if (!audioEnabled) {\n      audioEnabled = true;\n      safeResumeAudio().then(() => {\n        startHum();\n      });\n    } else {\n      audioEnabled = false;\n      stopHum();\n    }\n    announceAudioState();\n  }\n  function announceAudioState() {\n    const msg = audioEnabled ? 'Audio on' : 'Audio off';\n    liveRegion.textContent = msg;\n  }\n\n  // Game variables\n  const LEVEL_COUNT = 5;\n  let currentLevel = 1;\n  let targetNumber = 0;\n  let parts = []; // available parts to drag\n  const placed = []; // placed parts into machine\n  let selectedIndex = -1; // index in parts array of selection (keyboard)\n  let dragging = null; // {part, offsetX, offsetY}\n  let animationTime = 0;\n  let won = false;\n  let showConfetti = 0;\n\n  // Layout constants\n  const MACHINE_X = 420;\n  const MACHINE_Y = 80;\n  const MACHINE_W = 260;\n  const MACHINE_H = 320;\n  const PART_RADIUS = 26;\n  const PART_AREA = { x: 40, y: 80, w: 300, h: 320 };\n\n  // Colors and visual styles\n  const bgColor = '#EAF2F5';\n  const pastel = {\n    machine: '#D6EAF8',\n    highlight: '#7FB3D5',\n    part: '#F7DC6F',\n    partAlt: '#AED6F1',\n    text: '#12333F',\n    gentle: '#D5F5E3',\n  };\n\n  // Utility: random int\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  // Create a beatable level: pick a target and parts which include a subset that sums to target\n  function setupLevel(level) {\n    currentLevel = Math.min(Math.max(1, level), LEVEL_COUNT);\n    won = false;\n    showConfetti = 0;\n    parts = [];\n    placed.length = 0;\n    selectedIndex = -1;\n    dragging = null;\n\n    // Difficulty scales: number of parts and max part value\n    const baseParts = 5 + currentLevel; // 6..10\n    const maxVal = 5 + currentLevel * 3; // e.g., up to 20\n    // choose a target as sum of some randomly chosen parts\n    const subsetCount = Math.min(baseParts, 2 + Math.floor(currentLevel / 1.5)); // 2..?\n    const chosen = [];\n    for (let i = 0; i < subsetCount; i++) {\n      chosen.push(randInt(1, Math.max(2, Math.floor(maxVal / 2))));\n    }\n    targetNumber = chosen.reduce((a, b) => a + b, 0);\n\n    // Create parts array that includes chosen items plus distractors\n    const totalParts = baseParts;\n    const values = chosen.slice();\n\n    while (values.length < totalParts) {\n      // create distractors that do not trivially break solveability\n      let v = randInt(1, maxVal);\n      // Avoid making it trivially equal target alone\n      if (v === targetNumber) v = Math.max(1, v - 1);\n      values.push(v);\n    }\n\n    // Shuffle values\n    for (let i = values.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [values[i], values[j]] = [values[j], values[i]];\n    }\n\n    // Create part objects with positions in the part area\n    const cols = 3;\n    const gapX = PART_AREA.w / cols;\n    const gapY = 60;\n    for (let i = 0; i < values.length; i++) {\n      const col = i % cols;\n      const row = Math.floor(i / cols);\n      const x = PART_AREA.x + 30 + col * gapX + randInt(-10, 10);\n      const y = PART_AREA.y + 40 + row * gapY + randInt(-6, 6);\n      parts.push({\n        id: 'p' + i + '-' + Date.now(),\n        value: values[i],\n        x,\n        y,\n        homeX: x,\n        homeY: y,\n        radius: PART_RADIUS,\n        wobble: Math.random() * Math.PI * 2,\n        color: i % 2 === 0 ? pastel.part : pastel.partAlt,\n      });\n    }\n\n    // Announce level for accessibility\n    liveRegion.textContent = `Level ${currentLevel}. Target ${targetNumber}. Use arrow keys to select a part and press Enter to place it into the machine.`;\n  }\n\n  // Calculate current placed sum\n  function currentSum() {\n    return placed.reduce((s, p) => s + p.value, 0);\n  }\n\n  // Place part into machine (snap into position)\n  function placePart(part) {\n    // Only place if part is not already placed\n    if (parts.indexOf(part) === -1) return;\n    // compute a stacked position inside machine\n    const index = placed.length;\n    const stackX = MACHINE_X + MACHINE_W / 2;\n    const stackY = MACHINE_Y + MACHINE_H - 36 - index * 46;\n    // Remove from parts and push into placed\n    parts = parts.filter((p) => p !== part);\n    part.placedX = stackX + randInt(-6, 6);\n    part.placedY = stackY + randInt(-6, 6);\n    placed.push(part);\n    selectedIndex = Math.min(selectedIndex, parts.length - 1);\n    if (audioEnabled) playClick();\n    liveRegion.textContent = `Placed ${part.value}. Current sum ${currentSum()} of ${targetNumber}.`;\n    checkWinOrOver();\n  }\n\n  // Remove last placed or specified placed item\n  function removeLastPlaced() {\n    if (placed.length === 0) {\n      liveRegion.textContent = 'No parts to remove.';\n      return;\n    }\n    const part = placed.pop();\n    // send back to parts area to home position\n    part.x = part.homeX + randInt(-8, 8);\n    part.y = part.homeY + randInt(-8, 8);\n    parts.push(part);\n    if (audioEnabled) playClick();\n    liveRegion.textContent = `Removed ${part.value}. Current sum ${currentSum()} of ${targetNumber}.`;\n  }\n\n  // Check win or over-sum\n  function checkWinOrOver() {\n    const sum = currentSum();\n    if (sum === targetNumber) {\n      // Win this level\n      won = true;\n      announceWin();\n    } else if (sum > targetNumber) {\n      // Overfilled - play wrong sound\n      if (audioEnabled) playWrong();\n      liveRegion.textContent = `Oh no! The machine is overfilled: ${sum} (target ${targetNumber}). Remove a part.`;\n    } else {\n      // Not yet\n    }\n  }\n\n  async function announceWin() {\n    liveRegion.textContent = `Great! You matched ${targetNumber}. Level ${currentLevel} complete.`;\n    if (audioEnabled) await playSuccess();\n    // celebrate visually\n    showConfetti = 60; // frames\n    // Move to next level after a short delay\n    setTimeout(() => {\n      if (currentLevel < LEVEL_COUNT) {\n        setupLevel(currentLevel + 1);\n        if (audioEnabled) playClick();\n      } else {\n        // final applause\n        liveRegion.textContent = 'You finished all levels! Well done!';\n        if (audioEnabled) playSuccess();\n        // reset to start after a pause\n        setTimeout(() => {\n          setupLevel(1);\n        }, 4000);\n      }\n    }, 1600);\n  }\n\n  // Drawing functions\n  function clear() {\n    ctx.fillStyle = bgColor;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n  }\n\n  // Draw wacky machine with panels, glass, steam\n  function drawMachine(t) {\n    // Machine body\n    ctx.save();\n    ctx.translate(MACHINE_X, MACHINE_Y);\n    // Body\n    roundRect(ctx, 0, 0, MACHINE_W, MACHINE_H, 18, pastel.machine, '#9AC6E1', 2);\n    // Glass window\n    ctx.beginPath();\n    ctx.rect(28, 40, MACHINE_W - 56, MACHINE_H - 120);\n    ctx.fillStyle = 'rgba(255,255,255,0.06)';\n    ctx.fill();\n\n    // Funnel top\n    ctx.beginPath();\n    ctx.moveTo(MACHINE_W / 2 - 36, 12);\n    ctx.lineTo(MACHINE_W / 2 + 36, 12);\n    ctx.lineTo(MACHINE_W - 18, 40);\n    ctx.lineTo(18, 40);\n    ctx.closePath();\n    ctx.fillStyle = '#CFEAF8';\n    ctx.fill();\n\n    // Control panel left\n    roundRect(ctx, 12, MACHINE_H - 72, 80, 56, 10, '#F6E6C3', '#D5A021', 2);\n    // Buttons\n    drawButton(ctx, 26, MACHINE_H - 56, 18, '#FF6B6B');\n    drawButton(ctx, 54, MACHINE_H - 56, 18, '#6BE696');\n\n    // Gauge\n    ctx.beginPath();\n    ctx.arc(MACHINE_W - 56, MACHINE_H - 36, 28, Math.PI, 2 * Math.PI);\n    ctx.fillStyle = '#FFFFFF';\n    ctx.fill();\n    ctx.strokeStyle = '#9BBBD8';\n    ctx.stroke();\n    // Needle showing fullness\n    const sum = currentSum();\n    const pct = Math.min(1, Math.max(0, sum / Math.max(targetNumber, 1)));\n    const angle = Math.PI + pct * Math.PI;\n    ctx.beginPath();\n    ctx.moveTo(MACHINE_W - 56, MACHINE_H - 36);\n    ctx.lineTo(MACHINE_W - 56 + 24 * Math.cos(angle), MACHINE_H - 36 + 24 * Math.sin(angle));\n    ctx.strokeStyle = '#E74C3C';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n\n    // Little piston animation\n    const pistonY = 20 + Math.sin(t * 0.06) * 6;\n    ctx.fillStyle = '#EEDFA8';\n    ctx.fillRect(12, pistonY, MACHINE_W - 24, 8);\n\n    ctx.restore();\n\n    // Machine label\n    ctx.fillStyle = pastel.text;\n    ctx.font = 'bold 18px sans-serif';\n    ctx.fillText('Number Mixer 3000', MACHINE_X + 12, MACHINE_Y - 8);\n  }\n\n  // Helper: rounded rect\n  function roundRect(ctx, x, y, w, h, r, fillStyle, strokeStyle, lineWidth = 1) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fillStyle) {\n      ctx.fillStyle = fillStyle;\n      ctx.fill();\n    }\n    if (strokeStyle) {\n      ctx.strokeStyle = strokeStyle;\n      ctx.lineWidth = lineWidth;\n      ctx.stroke();\n    }\n  }\n\n  // Draw a shiny push button\n  function drawButton(ctx, x, y, r, color) {\n    ctx.beginPath();\n    ctx.arc(x, y, r, 0, Math.PI * 2);\n    ctx.fillStyle = color;\n    ctx.fill();\n    ctx.strokeStyle = 'rgba(0,0,0,0.15)';\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.arc(x - r / 3, y - r / 3, r / 2.2, 0, Math.PI * 2);\n    ctx.fillStyle = 'rgba(255,255,255,0.35)';\n    ctx.fill();\n  }\n\n  // Draw parts (gears/number chips)\n  function drawParts(t) {\n    // Part area background\n    roundRect(ctx, PART_AREA.x - 12, PART_AREA.y - 12, PART_AREA.w + 24, PART_AREA.h + 24, 14, '#F0F7FA');\n    ctx.fillStyle = pastel.text;\n    ctx.font = '14px sans-serif';\n    ctx.fillText('Parts', PART_AREA.x + 8, PART_AREA.y - 2);\n\n    // Draw each part\n    parts.forEach((p, i) => {\n      // wobble\n      p.wobble += 0.02 + i * 0.0005;\n      const wob = Math.sin(p.wobble) * 2;\n      // if dragging, position is dynamic; otherwise ease back to home\n      const dx = p.x - p.homeX;\n      const dy = p.y - p.homeY;\n      // draw gear-like circle\n      drawGear(ctx, p.x, p.y + wob, p.radius, p.color, p.value, i === selectedIndex);\n    });\n\n    // Draw placed parts inside machine\n    placed.forEach((p, i) => {\n      // Slight bounce when recently placed\n      const b = Math.sin(t * 0.12 + i) * 3;\n      drawGear(ctx, p.placedX, p.placedY + b, p.radius, p.color, p.value, false);\n    });\n  }\n\n  // Draw a gear-like circle with value text\n  function drawGear(ctx, x, y, r, color, value, highlight) {\n    ctx.save();\n    ctx.translate(x, y);\n    // Gear teeth\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    const teeth = 8;\n    for (let i = 0; i < teeth; i++) {\n      const angle = (i / teeth) * Math.PI * 2;\n      const tx = Math.cos(angle) * (r + 6);\n      const ty = Math.sin(angle) * (r + 6);\n      ctx.rect(tx - 4, ty - 4, 8, 8);\n    }\n    ctx.fill();\n\n    // Center circle\n    ctx.beginPath();\n    ctx.arc(0, 0, r, 0, Math.PI * 2);\n    ctx.fillStyle = color;\n    ctx.fill();\n    ctx.strokeStyle = '#8A6F3C';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n\n    // value text\n    ctx.fillStyle = '#12333F';\n    ctx.font = 'bold 18px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(String(value), 0, 0);\n\n    if (highlight) {\n      ctx.beginPath();\n      ctx.arc(0, 0, r + 6, 0, Math.PI * 2);\n      ctx.strokeStyle = 'rgba(123,204,196,0.9)';\n      ctx.lineWidth = 3;\n      ctx.stroke();\n    }\n\n    ctx.restore();\n  }\n\n  // Draw HUD: target, sum, instructions, speaker icon\n  function drawHUD() {\n    // Target card\n    ctx.fillStyle = '#FFFFFF';\n    roundRect(ctx, 40, 12, 240, 52, 10, '#FFFFFF', '#C9E1EE', 2);\n\n    ctx.fillStyle = pastel.text;\n    ctx.font = '18px sans-serif';\n    ctx.fillText('Target Number', 60, 32);\n\n    ctx.fillStyle = '#2C3E50';\n    ctx.font = 'bold 32px sans-serif';\n    ctx.fillText(String(targetNumber), 60, 56);\n\n    // Current sum\n    ctx.fillStyle = '#FFFFFF';\n    roundRect(ctx, 320, 12, 220, 52, 10, '#FFFFFF', '#C9E1EE', 2);\n    ctx.fillStyle = pastel.text;\n    ctx.font = '16px sans-serif';\n    ctx.fillText('Current Sum', 336, 30);\n    ctx.font = 'bold 28px sans-serif';\n    ctx.fillStyle = currentSum() === targetNumber ? '#27AE60' : '#2C3E50';\n    ctx.fillText(String(currentSum()), 336, 54);\n\n    // Instructions small\n    ctx.fillStyle = '#12333F';\n    ctx.font = '13px sans-serif';\n    ctx.fillText('Arrow keys: select \u2022 Enter: place \u2022 Backspace: remove \u2022 A: audio \u2022 R: reset', 40, HEIGHT - 18);\n\n    // Speaker icon at top-right\n    const sx = WIDTH - 44;\n    const sy = 16;\n    drawSpeakerIcon(ctx, sx, sy, audioEnabled);\n    // level indicator\n    ctx.fillStyle = '#12333F';\n    ctx.font = '14px sans-serif';\n    ctx.fillText(`Level ${currentLevel}/${LEVEL_COUNT}`, WIDTH - 140, 28);\n  }\n\n  function drawSpeakerIcon(ctx, x, y, on) {\n    ctx.save();\n    ctx.translate(x, y);\n    // box background\n    ctx.beginPath();\n    ctx.rect(-8, -8, 48, 36);\n    ctx.fillStyle = 'rgba(255,255,255,0.06)';\n    ctx.fill();\n    // Speaker\n    ctx.beginPath();\n    ctx.moveTo(0, 6);\n    ctx.lineTo(10, 6);\n    ctx.lineTo(18, 0);\n    ctx.lineTo(18, 24);\n    ctx.lineTo(10, 18);\n    ctx.lineTo(0, 18);\n    ctx.closePath();\n    ctx.fillStyle = '#7FB3D5';\n    ctx.fill();\n    if (!on) {\n      // slash\n      ctx.beginPath();\n      ctx.moveTo(2, 2);\n      ctx.lineTo(28, 26);\n      ctx.strokeStyle = '#E74C3C';\n      ctx.lineWidth = 3;\n      ctx.stroke();\n    } else {\n      // sound waves\n      ctx.beginPath();\n      ctx.arc(24, 10, 6, -0.6, 0.6);\n      ctx.strokeStyle = '#6BE696';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  // Little steam puffs for wacky effect\n  function drawSteam(t) {\n    const steamX = MACHINE_X - 24;\n    for (let i = 0; i < 4; i++) {\n      const s = (t * 0.03 + i * 0.7) % 1;\n      const alpha = 0.12 + Math.sin((s * Math.PI * 2)) * 0.06;\n      ctx.beginPath();\n      ctx.arc(steamX + i * 18, MACHINE_Y + s * MACHINE_H * 0.6, 12 + i * 3, 0, Math.PI * 2);\n      ctx.fillStyle = `rgba(255,255,255,${alpha.toFixed(2)})`;\n      ctx.fill();\n    }\n  }\n\n  // Confetti celebration\n  const confettiPieces = [];\n  function updateConfetti() {\n    if (showConfetti > 0 && confettiPieces.length === 0) {\n      for (let i = 0; i < 40; i++) {\n        confettiPieces.push({\n          x: MACHINE_X + Math.random() * MACHINE_W,\n          y: MACHINE_Y + 10,\n          vx: (Math.random() - 0.5) * 4,\n          vy: Math.random() * 3 - 1,\n          color: `hsl(${Math.random() * 360},70%,60%)`,\n          rot: Math.random() * Math.PI * 2,\n          vr: (Math.random() - 0.5) * 0.3,\n        });\n      }\n    }\n    confettiPieces.forEach((c) => {\n      c.x += c.vx;\n      c.y += c.vy;\n      c.vy += 0.12;\n      c.rot += c.vr;\n    });\n    // decrement showConfetti\n    if (showConfetti > 0) showConfetti--;\n    if (showConfetti === 0) confettiPieces.length = 0;\n  }\n  function drawConfetti() {\n    confettiPieces.forEach((c) => {\n      ctx.save();\n      ctx.translate(c.x, c.y);\n      ctx.rotate(c.rot);\n      ctx.fillStyle = c.color;\n      ctx.fillRect(-4, -6, 8, 12);\n      ctx.restore();\n    });\n  }\n\n  // Event handling: pointer and keyboard\n  let pointerDown = false;\n\n  function canvasToLocal(e) {\n    const rect = canvas.getBoundingClientRect();\n    const x = (e.clientX - rect.left);\n    const y = (e.clientY - rect.top);\n    return { x, y };\n  }\n\n  canvas.addEventListener('pointerdown', (ev) => {\n    pointerDown = true;\n    canvas.setPointerCapture(ev.pointerId);\n    const pt = canvasToLocal(ev);\n    // check speaker icon\n    if (pt.x > WIDTH - 80 && pt.y < 64) {\n      toggleAudio();\n      return;\n    }\n\n    // check selection of a part\n    for (let i = parts.length - 1; i >= 0; i--) {\n      const p = parts[i];\n      if (distance(pt.x, pt.y, p.x, p.y) <= p.radius + 6) {\n        // start dragging\n        dragging = { part: p, offsetX: pt.x - p.x, offsetY: pt.y - p.y };\n        selectedIndex = parts.indexOf(p);\n        if (audioEnabled) safeResumeAudio().then(() => playClick());\n        return;\n      }\n    }\n\n    // click on placed area to remove last\n    if (pt.x > MACHINE_X && pt.x < MACHINE_X + MACHINE_W && pt.y > MACHINE_Y && pt.y < MACHINE_Y + MACHINE_H) {\n      removeLastPlaced();\n      return;\n    }\n  });\n\n  canvas.addEventListener('pointermove', (ev) => {\n    if (!pointerDown || !dragging) return;\n    const pt = canvasToLocal(ev);\n    dragging.part.x = pt.x - dragging.offsetX;\n    dragging.part.y = pt.y - dragging.offsetY;\n  });\n\n  canvas.addEventListener('pointerup', (ev) => {\n    pointerDown = false;\n    canvas.releasePointerCapture && canvas.releasePointerCapture(ev.pointerId);\n    if (!dragging) return;\n    const pt = canvasToLocal(ev);\n    const part = dragging.part;\n    // if dropped inside machine area, place it\n    if (pt.x > MACHINE_X + 12 && pt.x < MACHINE_X + MACHINE_W - 12 && pt.y > MACHINE_Y + 30 && pt.y < MACHINE_Y + MACHINE_H - 20) {\n      placePart(part);\n    } else {\n      // return to home spot\n      part.x = part.homeX + randInt(-6, 6);\n      part.y = part.homeY + randInt(-6, 6);\n      if (audioEnabled) playClick();\n    }\n    dragging = null;\n  });\n\n  // Utility distance\n  function distance(x1, y1, x2, y2) {\n    return Math.hypot(x1 - x2, y1 - y2);\n  }\n\n  // Keyboard controls\n  canvas.addEventListener('keydown', (ev) => {\n    // Ensure audio resume on first user gesture\n    if (audioEnabled && audioCtx && audioCtx.state === 'suspended') safeResumeAudio().then(startHum);\n    if (ev.key === 'ArrowLeft') {\n      ev.preventDefault();\n      if (parts.length > 0) {\n        selectedIndex = (selectedIndex <= 0) ? parts.length - 1 : selectedIndex - 1;\n        liveRegion.textContent = `Selected ${parts[selectedIndex].value}. Press Enter to place.`;\n      }\n    } else if (ev.key === 'ArrowRight') {\n      ev.preventDefault();\n      if (parts.length > 0) {\n        selectedIndex = (selectedIndex >= parts.length - 1) ? 0 : selectedIndex + 1;\n        liveRegion.textContent = `Selected ${parts[selectedIndex].value}. Press Enter to place.`;\n      }\n    } else if (ev.key === 'Enter') {\n      ev.preventDefault();\n      if (selectedIndex >= 0 && parts[selectedIndex]) {\n        placePart(parts[selectedIndex]);\n      } else {\n        liveRegion.textContent = 'No part selected. Use the arrow keys to select a part.';\n      }\n    } else if (ev.key === 'Backspace' || ev.key === 'Delete') {\n      ev.preventDefault();\n      removeLastPlaced();\n    } else if (ev.key.toLowerCase() === 'a') {\n      ev.preventDefault();\n      toggleAudio();\n    } else if (ev.key.toLowerCase() === 'r') {\n      ev.preventDefault();\n      setupLevel(currentLevel);\n      if (audioEnabled) playClick();\n    } else if (ev.key === ' ' /* space */) {\n      ev.preventDefault();\n      // pick up selected part and toggle dragging via keyboard: simulate drop into machine when next press Enter or space?\n      if (selectedIndex >= 0 && parts[selectedIndex]) {\n        // place directly for simplicity\n        placePart(parts[selectedIndex]);\n      } else {\n        liveRegion.textContent = 'Select a part first with arrow keys.';\n      }\n    }\n  });\n\n  // Focus canvas to receive keyboard default\n  canvas.addEventListener('focus', () => {\n    canvas.style.outline = '2px solid rgba(123,204,196,0.6)';\n  });\n  canvas.addEventListener('blur', () => {\n    canvas.style.outline = 'none';\n  });\n\n  // Main animation loop\n  let last = performance.now();\n  function loop(now) {\n    const dt = now - last;\n    last = now;\n    animationTime += dt;\n    update(dt / 1000);\n    render(animationTime * 0.06);\n    requestAnimationFrame(loop);\n  }\n\n  function update(seconds) {\n    // gentle return of parts to home if not dragged\n    parts.forEach((p) => {\n      if (!dragging || dragging.part !== p) {\n        // ease towards home\n        p.x += (p.homeX - p.x) * 0.06;\n        p.y += (p.homeY - p.y) * 0.06;\n      }\n    });\n    updateConfetti();\n  }\n\n  function render(t) {\n    clear();\n    drawSteam(t);\n    drawMachine(t);\n    drawParts(t);\n    drawHudShadow();\n    drawHUD();\n    drawConfetti();\n\n    // Visual \"audio off\" cue\n    if (!audioEnabled) {\n      ctx.fillStyle = 'rgba(231,76,60,0.06)';\n      ctx.fillRect(WIDTH - 88, 6, 84, 40);\n      ctx.fillStyle = '#E74C3C';\n      ctx.font = '12px sans-serif';\n      ctx.fillText('Audio Off', WIDTH - 84, 34);\n    }\n\n    // highlight selected part\n    if (selectedIndex >= 0 && parts[selectedIndex]) {\n      const p = parts[selectedIndex];\n      ctx.beginPath();\n      ctx.arc(p.x, p.y, p.radius + 10, 0, Math.PI * 2);\n      ctx.strokeStyle = 'rgba(123,204,196,0.6)';\n      ctx.lineWidth = 3;\n      ctx.stroke();\n    }\n\n    // overlay instructions when won\n    if (won) {\n      ctx.fillStyle = 'rgba(255,255,255,0.7)';\n      ctx.fillRect(0, HEIGHT / 2 - 40, WIDTH, 80);\n      ctx.fillStyle = '#2C3E50';\n      ctx.font = 'bold 28px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText('Great job! Preparing next level...', WIDTH / 2, HEIGHT / 2 + 8);\n      ctx.textAlign = 'start';\n    }\n  }\n\n  function drawHudShadow() {\n    // subtle shadow to separate UI\n    ctx.fillStyle = 'rgba(0,0,0,0.02)';\n    ctx.fillRect(16, 8, WIDTH - 32, 64);\n  }\n\n  // Initialize\n  setupLevel(1);\n  if (audioEnabled) {\n    // do not auto-start audio until user gesture; but start hum if allowed\n    // We'll start hum only after a user interaction; indicate that in live region\n    liveRegion.textContent = 'Tap or interact to enable audio.';\n    // Add a one-time user gesture listener to start audio if available\n    const onFirstUse = () => {\n      safeResumeAudio().then(() => {\n        if (audioEnabled) startHum();\n      });\n      window.removeEventListener('pointerdown', onFirstUse);\n      window.removeEventListener('keydown', onFirstUse);\n    };\n    window.addEventListener('pointerdown', onFirstUse);\n    window.addEventListener('keydown', onFirstUse);\n  } else {\n    liveRegion.textContent = 'Audio is not available in this browser.';\n  }\n\n  // Start animation\n  requestAnimationFrame(loop);\n\n  // Helper: draw gear created earlier; exported if needed (kept local)\n  // Expose a small public API on container for testing if necessary\n  container._machineMathGame = {\n    reset: () => setupLevel(1),\n    nextLevel: () => setupLevel(currentLevel + 1),\n  };\n\n  // Error handling: basic window.onerror to capture and notify user via live region\n  window.addEventListener('error', (evt) => {\n    liveRegion.textContent = 'An error occurred in the game. Try reloading the page.';\n    console.error('Game error:', evt.error || evt.message);\n  });\n})();\n---\n",
  "improve_response_tokens": 18789,
  "formatted_code": true,
  "formatting_response_tokens": 20216,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}