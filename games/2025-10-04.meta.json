{
  "generated_date": "2025-10-04",
  "generated_timestamp": "2025-10-04T00:24:34.824683",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8970,
  "game_filename": "2025-10-04.js",
  "game_size_bytes": 25858,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Machine Mix-Up - Educational Math Game for Ages 7-9\n// Renders inside element with id 'game-of-the-day-stage'.\n// All visuals drawn on a canvas 720x480. Sounds via Web Audio API oscillators.\n// Keyboard controls, accessible labels, audio error handling, and beatable levels.\n\n// Immediately-invoked function to avoid leaking globals\n(function () {\n  // Find container element\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Game container with id \"game-of-the-day-stage\" not found.');\n    return;\n  }\n\n  // Clear container and create canvas\n  container.innerHTML = '';\n  container.style.position = 'relative';\n  const canvas = document.createElement('canvas');\n  canvas.width = 720;\n  canvas.height = 480;\n  canvas.style.width = '720px';\n  canvas.style.height = '480px';\n  canvas.style.display = 'block';\n  canvas.style.outline = 'none';\n  canvas.setAttribute('role', 'img');\n  canvas.setAttribute('aria-label', 'Machine Mix-Up math game. Use arrow keys to move, space to load a number, Enter to run the machine.');\n  canvas.setAttribute('tabindex', '0'); // focusable for keyboard\n  container.appendChild(canvas);\n\n  // Create hidden accessible instructions for screen readers\n  const srInstructions = document.createElement('div');\n  srInstructions.style.position = 'absolute';\n  srInstructions.style.left = '-10000px';\n  srInstructions.style.top = 'auto';\n  srInstructions.style.width = '1px';\n  srInstructions.style.height = '1px';\n  srInstructions.style.overflow = 'hidden';\n  srInstructions.setAttribute('aria-hidden', 'false');\n  srInstructions.id = 'machine-mixup-instructions';\n  srInstructions.innerText =\n    'Machine Mix-Up. Collect three number tiles from the conveyor by moving the selector with left and right arrows and pressing space to load each into the machine. ' +\n    'Press Enter to run the machine. Try to make the result match the target number. Press Backspace to remove the last loaded tile. Press R to reset, M to toggle sound.';\n  container.appendChild(srInstructions);\n\n  const ctx = canvas.getContext('2d', { alpha: false });\n\n  // Game constants\n  const WIDTH = canvas.width;\n  const HEIGHT = canvas.height;\n  const CONVEYOR_Y = 330;\n  const TILE_WIDTH = 72;\n  const TILE_HEIGHT = 64;\n  const NUM_TILES = 8; // number of tiles on conveyor\n  const SLOTS = 3;\n  const BG_COLORS = ['#EAF6F6', '#F7F3FF']; // calming gradient\n  const MACHINE_COLOR = '#5C9EA3';\n  const ACCENT_COLOR = '#FFB86B';\n  const TEXT_COLOR = '#21333B';\n\n  // Game state\n  let gameState = {\n    tiles: [], // {value, x, y, sx (speed), id}\n    selectorIndex: 0,\n    slots: [null, null, null],\n    currentSlotIndex: 0,\n    target: 0,\n    ops: [], // two ops for machine: ['+', '-', '\u00d7']\n    message: 'Load three tiles then press Enter to run the machine.',\n    level: 1,\n    attempts: 0,\n    solvedLevels: 0,\n    playing: true,\n    audioEnabled: false,\n    soundMuted: false,\n    lastRunResult: null,\n  };\n\n  // Audio setup\n  let audioContext = null;\n  let masterGain = null;\n  let bgOsc = null;\n  let bgGain = null;\n  let bgLFO = null;\n\n  // Helper: Create Audio Context with error handling\n  function createAudioContext() {\n    if (audioContext) return audioContext;\n    try {\n      const AudioCtx = window.AudioContext || window.webkitAudioContext;\n      audioContext = new AudioCtx();\n      masterGain = audioContext.createGain();\n      masterGain.gain.value = 0.0; // start silent until user toggles\n      masterGain.connect(audioContext.destination);\n\n      // Background soothing sound: low triangle with slow LFO to filter frequency\n      bgOsc = audioContext.createOscillator();\n      bgOsc.type = 'sine';\n      bgOsc.frequency.value = 110; // low pitch\n      bgGain = audioContext.createGain();\n      bgGain.gain.value = 0.02; // very gentle\n      bgOsc.connect(bgGain);\n      bgGain.connect(masterGain);\n\n      // LFO to modulate bg frequency slightly\n      try {\n        bgLFO = audioContext.createOscillator();\n        const lfoGain = audioContext.createGain();\n        bgLFO.frequency.value = 0.08; // very slow wobble\n        lfoGain.gain.value = 10;\n        bgLFO.connect(lfoGain);\n        lfoGain.connect(bgOsc.frequency);\n        bgLFO.start();\n      } catch (e) {\n        // Not critical; continue without LFO\n        console.warn('LFO not available:', e);\n      }\n\n      bgOsc.start();\n      gameState.audioEnabled = true;\n      updateAudioVisualCue();\n      return audioContext;\n    } catch (e) {\n      console.warn('AudioContext creation failed or is disallowed by browser:', e);\n      audioContext = null;\n      gameState.audioEnabled = false;\n      return null;\n    }\n  }\n\n  // Toggle sound on/off\n  function setSoundMuted(mute) {\n    gameState.soundMuted = !!mute;\n    if (!audioContext && !mute) {\n      // Try to create audio context on demand\n      createAudioContext();\n    }\n    if (masterGain) {\n      masterGain.gain.value = gameState.soundMuted ? 0.0 : 0.6;\n    }\n    updateAudioVisualCue();\n  }\n\n  // Visual cue: show speaker icon state on canvas via gameState flags\n  function updateAudioVisualCue() {\n    // Nothing to change in DOM; drawing uses gameState.audioEnabled & soundMuted\n  }\n\n  // Utility: play a short sound with oscillator\n  function playTone({ freq = 440, type = 'sine', duration = 0.2, gain = 0.1, attack = 0.005, release = 0.1, filterFreq = null } = {}) {\n    if (!audioContext) {\n      return;\n    }\n    try {\n      const o = audioContext.createOscillator();\n      const g = audioContext.createGain();\n      o.type = type;\n      o.frequency.value = freq;\n\n      if (filterFreq) {\n        const filter = audioContext.createBiquadFilter();\n        filter.type = 'lowpass';\n        filter.frequency.value = filterFreq;\n        o.connect(filter);\n        filter.connect(g);\n      } else {\n        o.connect(g);\n      }\n      g.connect(masterGain);\n      const now = audioContext.currentTime;\n      g.gain.cancelScheduledValues(now);\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.linearRampToValueAtTime(gain, now + attack);\n      g.gain.linearRampToValueAtTime(0.0001, now + duration - release);\n      o.start(now);\n      o.stop(now + duration + 0.02);\n    } catch (e) {\n      console.warn('playTone failed:', e);\n    }\n  }\n\n  // Specialized sounds: correct, incorrect, pick\n  function soundCorrect() {\n    if (gameState.soundMuted) return;\n    // small arp ascending\n    playTone({ freq: 440, type: 'sine', duration: 0.12, gain: 0.12 });\n    setTimeout(() => playTone({ freq: 660, type: 'sine', duration: 0.12, gain: 0.1 }), 120);\n    setTimeout(() => playTone({ freq: 880, type: 'sine', duration: 0.18, gain: 0.08 }), 260);\n  }\n  function soundIncorrect() {\n    if (gameState.soundMuted) return;\n    // low wobble\n    playTone({ freq: 120, type: 'sawtooth', duration: 0.35, gain: 0.14, filterFreq: 600 });\n  }\n  function soundPick() {\n    if (gameState.soundMuted) return;\n    playTone({ freq: 740, type: 'triangle', duration: 0.12, gain: 0.08 });\n  }\n\n  // Game generation: create tiles and target such that level is solvable\n  function generateLevel(level = 1) {\n    // choose three numbers 1..9 biased by level\n    function randInt(a, b) { return Math.floor(Math.random() * (b - a + 1)) + a; }\n    let a, b, c, ops, result;\n    const opsSet = ['+', '-', '\u00d7'];\n    // Try until find a result in 0..99 and not too trivial\n    let attempts = 0;\n    do {\n      a = randInt(1, Math.min(9, 4 + level)); // grow difficulty slightly\n      b = randInt(1, Math.min(9, 4 + level));\n      c = randInt(1, Math.min(9, 4 + level));\n      ops = [opsSet[randInt(0, 2)], opsSet[randInt(0, 2)]];\n      try {\n        // apply operations left-to-right: ((a op b) op c)\n        result = applyOps(a, b, c, ops);\n      } catch (e) {\n        result = NaN;\n      }\n      attempts++;\n      if (attempts > 500) {\n        // fallback simple\n        a = 2; b = 3; c = 4; ops = ['+', '+']; result = 9;\n        break;\n      }\n    } while (!Number.isFinite(result) || result < 0 || result > 99);\n    // Create tiles: include the three numbers plus some random decoys\n    const tiles = [];\n    const values = [a, b, c];\n    // Insert the three values\n    for (let v of values) {\n      tiles.push({ value: v, id: 'core-' + Math.random().toString(36).slice(2) });\n    }\n    // Add decoys until NUM_TILES reached\n    while (tiles.length < NUM_TILES) {\n      tiles.push({ value: randInt(1, 9), id: 'decoy-' + Math.random().toString(36).slice(2) });\n    }\n    // Shuffle tiles\n    for (let i = tiles.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [tiles[i], tiles[j]] = [tiles[j], tiles[i]];\n    }\n    // Assign positions and speeds\n    const startX = 40;\n    const spacing = (WIDTH - 80 - TILE_WIDTH) / Math.max(1, NUM_TILES - 1);\n    tiles.forEach((t, i) => {\n      t.x = startX + i * spacing;\n      t.y = CONVEYOR_Y;\n      t.sx = 0.2 + Math.random() * 0.6;\n    });\n    gameState.tiles = tiles;\n    gameState.selectorIndex = 0;\n    gameState.slots = [null, null, null];\n    gameState.currentSlotIndex = 0;\n    gameState.ops = ops;\n    gameState.target = result;\n    gameState.message = 'Level ' + level + ': Make the machine result equal ' + result + '.';\n    gameState.lastRunResult = null;\n    gameState.attempts = 0;\n  }\n\n  // Apply operations left-to-right\n  function applyOps(a, b, c, ops) {\n    function apply(x, op, y) {\n      if (op === '+') return x + y;\n      if (op === '-') return x - y;\n      if (op === '\u00d7') return x * y;\n      return x + y;\n    }\n    const r1 = apply(a, ops[0], b);\n    const r2 = apply(r1, ops[1], c);\n    return r2;\n  }\n\n  // Place selected tile into next slot\n  function loadSelectedTile() {\n    if (gameState.currentSlotIndex >= SLOTS) {\n      gameState.message = 'All slots are filled. Press Enter to run the machine or Backspace to remove a tile.';\n      return;\n    }\n    const tile = gameState.tiles[gameState.selectorIndex];\n    if (!tile) {\n      gameState.message = 'No tile selected.';\n      return;\n    }\n    // Copy tile into slot\n    gameState.slots[gameState.currentSlotIndex] = { value: tile.value, id: tile.id };\n    gameState.currentSlotIndex++;\n    gameState.message = 'Loaded ' + tile.value + ' into slot ' + gameState.currentSlotIndex + '.';\n    soundPick();\n  }\n\n  // Remove last loaded slot\n  function removeLastSlot() {\n    if (gameState.currentSlotIndex <= 0) {\n      gameState.message = 'No tiles to remove.';\n      return;\n    }\n    gameState.currentSlotIndex--;\n    const removed = gameState.slots[gameState.currentSlotIndex];\n    gameState.slots[gameState.currentSlotIndex] = null;\n    gameState.message = 'Removed ' + (removed ? removed.value : 'tile') + ' from slot ' + (gameState.currentSlotIndex + 1) + '.';\n  }\n\n  // Run machine: compute result from slots and compare to target\n  function runMachine() {\n    if (gameState.slots.some(s => s === null)) {\n      gameState.message = 'Fill all slots first.';\n      soundIncorrect();\n      return;\n    }\n    const vals = gameState.slots.map(s => s.value);\n    const result = applyOps(vals[0], vals[1], vals[2], gameState.ops);\n    gameState.lastRunResult = result;\n    gameState.attempts++;\n    if (result === gameState.target) {\n      // success\n      gameState.message = 'Success! The machine produced ' + result + '. Press R to play next level.';\n      soundCorrect();\n      gameState.solvedLevels++;\n      gameState.playing = false;\n    } else {\n      // incorrect\n      gameState.message = 'Oops! Machine result was ' + result + '. Try again or press R to reset the level.';\n      soundIncorrect();\n      // Allow player to try again; do not clear slots automatically\n    }\n  }\n\n  // Reset current level\n  function resetLevel() {\n    generateLevel(gameState.level);\n    gameState.playing = true;\n  }\n\n  // Advance to next level (beatability)\n  function nextLevel() {\n    gameState.level++;\n    generateLevel(gameState.level);\n    gameState.playing = true;\n  }\n\n  // Keyboard controls handling\n  function handleKeyDown(e) {\n    // Ensure audio can be started on user gesture\n    if (e.key && !gameState.audioEnabled && !gameState.soundMuted) {\n      tryResumeAudio();\n    }\n    switch (e.key) {\n      case 'ArrowLeft':\n        gameState.selectorIndex = (gameState.selectorIndex - 1 + gameState.tiles.length) % gameState.tiles.length;\n        e.preventDefault();\n        break;\n      case 'ArrowRight':\n        gameState.selectorIndex = (gameState.selectorIndex + 1) % gameState.tiles.length;\n        e.preventDefault();\n        break;\n      case ' ':\n        // space to load\n        loadSelectedTile();\n        e.preventDefault();\n        break;\n      case 'Enter':\n        runMachine();\n        e.preventDefault();\n        break;\n      case 'Backspace':\n        removeLastSlot();\n        e.preventDefault();\n        break;\n      case 'r':\n      case 'R':\n        if (!gameState.playing) {\n          // If finished, go to next level\n          nextLevel();\n        } else {\n          resetLevel();\n        }\n        e.preventDefault();\n        break;\n      case 'm':\n      case 'M':\n        setSoundMuted(!gameState.soundMuted);\n        e.preventDefault();\n        break;\n      default:\n        break;\n    }\n  }\n\n  // Mouse controls: clicking canvas focuses and optionally picks tile\n  canvas.addEventListener('click', (ev) => {\n    // Start audio on click if possible\n    tryResumeAudio();\n    const rect = canvas.getBoundingClientRect();\n    const x = ev.clientX - rect.left;\n    const y = ev.clientY - rect.top;\n    // If click on a tile region, move selector there\n    for (let i = 0; i < gameState.tiles.length; i++) {\n      const t = gameState.tiles[i];\n      if (x >= t.x && x <= t.x + TILE_WIDTH && y >= t.y && y <= t.y + TILE_HEIGHT) {\n        gameState.selectorIndex = i;\n        // If click is inside tile, also load it\n        loadSelectedTile();\n        return;\n      }\n    }\n    // If click on \"Run\" area (machine center), run\n    const runBox = { x: 520, y: 160, w: 160, h: 120 };\n    if (x >= runBox.x && x <= runBox.x + runBox.w && y >= runBox.y && y <= runBox.y + runBox.h) {\n      runMachine();\n      return;\n    }\n    // Otherwise focus\n    canvas.focus();\n  });\n\n  // Try to resume/create audio context on user gesture\n  function tryResumeAudio() {\n    if (!audioContext) {\n      createAudioContext();\n    }\n    if (audioContext) {\n      // Some browsers require resume\n      if (typeof audioContext.resume === 'function') {\n        audioContext.resume().then(() => {\n          setSoundMuted(gameState.soundMuted); // apply gain\n        }).catch((e) => {\n          console.warn('AudioContext resume failed:', e);\n        });\n      } else {\n        setSoundMuted(gameState.soundMuted);\n      }\n    }\n  }\n\n  window.addEventListener('keydown', handleKeyDown);\n  canvas.addEventListener('keydown', handleKeyDown);\n\n  // Drawing helpers\n  function drawRoundedRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  // Render loop\n  let lastTime = 0;\n  function render(time) {\n    const dt = (time - lastTime) / 1000 || 0;\n    lastTime = time;\n\n    // Update tile drifting motion\n    for (let i = 0; i < gameState.tiles.length; i++) {\n      const t = gameState.tiles[i];\n      t.x += Math.sin(time / 1000 + i) * 0.2 * dt * 60 * t.sx;\n      // keep tiles within bounds\n      if (t.x < 20) t.x = 20 + (i * 2);\n      if (t.x > WIDTH - TILE_WIDTH - 20) t.x = WIDTH - TILE_WIDTH - 20 - (i * 2);\n    }\n\n    // Clear background with calming gradient\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, BG_COLORS[0]);\n    g.addColorStop(1, BG_COLORS[1]);\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Decorative soft shapes (wacky)\n    drawSoftWackyShapes();\n\n    // Draw machine body\n    drawMachine();\n\n    // Draw conveyor belt and tiles\n    drawConveyor();\n\n    // Draw selector\n    drawSelector();\n\n    // Draw slots\n    drawSlots();\n\n    // Draw target display and ops display\n    drawTargetPanel();\n\n    // Draw instructions and messages\n    drawHUD();\n\n    requestAnimationFrame(render);\n  }\n\n  // Decorative soft shapes to make visuals calming & wacky\n  function drawSoftWackyShapes() {\n    // floating blobs at top-left and top-right\n    ctx.save();\n    ctx.globalAlpha = 0.12;\n    ctx.fillStyle = '#7FB5B3';\n    ctx.beginPath();\n    ctx.ellipse(80, 70, 70, 40, 0.3, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.fillStyle = '#C5E7E6';\n    ctx.beginPath();\n    ctx.ellipse(620, 110, 90, 50, -0.5, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.globalAlpha = 1.0;\n    ctx.restore();\n  }\n\n  function drawMachine() {\n    // Main machine box\n    ctx.save();\n    ctx.fillStyle = MACHINE_COLOR;\n    drawRoundedRect(ctx, 440, 110, 260, 200, 16);\n\n    // Machine \"face\"\n    ctx.fillStyle = '#FFFFFF';\n    ctx.beginPath();\n    ctx.arc(560, 180, 28, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Wacky eye\n    ctx.fillStyle = '#21333B';\n    ctx.beginPath();\n    ctx.arc(560, 180, 8, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Small blinking light as audio visual cue\n    const blinkAlpha = gameState.audioEnabled && !gameState.soundMuted ? 1.0 : 0.2;\n    ctx.fillStyle = `rgba(255, 230, 180, ${blinkAlpha})`;\n    ctx.beginPath();\n    ctx.arc(640, 135, 8, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Flowy pipes to run into machine center\n    ctx.strokeStyle = '#3C6E70';\n    ctx.lineWidth = 8;\n    ctx.beginPath();\n    ctx.moveTo(300, 220);\n    ctx.quadraticCurveTo(380, 140, 520, 180);\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  function drawConveyor() {\n    // Conveyor belt base\n    ctx.save();\n    ctx.fillStyle = '#A3C4C4';\n    drawRoundedRect(ctx, 20, CONVEYOR_Y - 16, WIDTH - 40, TILE_HEIGHT + 32, 12);\n\n    // Treads\n    ctx.fillStyle = '#D6EDEE';\n    for (let i = 20; i < WIDTH - 20; i += 30) {\n      ctx.fillRect(i, CONVEYOR_Y + TILE_HEIGHT + 6, 20, 6);\n    }\n\n    // Draw tiles\n    for (let i = 0; i < gameState.tiles.length; i++) {\n      const t = gameState.tiles[i];\n      drawTile(t.x, t.y, t.value, i === gameState.selectorIndex, t.id);\n    }\n\n    ctx.restore();\n  }\n\n  function drawTile(x, y, value, selected = false, id = '') {\n    // Shadow\n    ctx.save();\n    ctx.fillStyle = 'rgba(0,0,0,0.08)';\n    drawRoundedRect(ctx, x + 6, y + 10, TILE_WIDTH, TILE_HEIGHT, 8);\n\n    // Tile body\n    ctx.fillStyle = '#FFFFFF';\n    drawRoundedRect(ctx, x, y, TILE_WIDTH, TILE_HEIGHT, 10);\n\n    // wacky pattern\n    ctx.fillStyle = '#F1F8F8';\n    ctx.fillRect(x + 6, y + 36, TILE_WIDTH - 12, 6);\n\n    // Number\n    ctx.fillStyle = TEXT_COLOR;\n    ctx.font = 'bold 28px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(String(value), x + TILE_WIDTH / 2, y + TILE_HEIGHT / 2 - 6);\n\n    // id small invisible marker for testing/dev\n    // draw selection\n    if (selected) {\n      ctx.strokeStyle = ACCENT_COLOR;\n      ctx.lineWidth = 4;\n      ctx.strokeRect(x - 2, y - 2, TILE_WIDTH + 4, TILE_HEIGHT + 4);\n    }\n    ctx.restore();\n  }\n\n  function drawSelector() {\n    // small arrow below selected tile\n    const t = gameState.tiles[gameState.selectorIndex];\n    if (!t) return;\n    ctx.save();\n    ctx.fillStyle = ACCENT_COLOR;\n    const sx = t.x + TILE_WIDTH / 2;\n    const sy = t.y + TILE_HEIGHT + 22;\n    ctx.beginPath();\n    ctx.moveTo(sx - 10, sy - 10);\n    ctx.lineTo(sx + 10, sy - 10);\n    ctx.lineTo(sx, sy + 4);\n    ctx.closePath();\n    ctx.fill();\n\n    // Accessibility text near selector (visible)\n    ctx.fillStyle = TEXT_COLOR;\n    ctx.font = '12px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('Selected: ' + t.value, sx, sy + 28);\n    ctx.restore();\n  }\n\n  function drawSlots() {\n    // Draw three input slots feeding into machine pipe\n    ctx.save();\n    const baseX = 260;\n    const baseY = 160;\n    const slotW = 72;\n    const slotH = 52;\n    for (let i = 0; i < SLOTS; i++) {\n      const x = baseX - i * (slotW + 18);\n      const y = baseY;\n      ctx.fillStyle = '#F8FFFF';\n      drawRoundedRect(ctx, x, y, slotW, slotH, 8);\n      ctx.strokeStyle = '#CEEFEF';\n      ctx.stroke();\n\n      // Draw loaded value\n      const s = gameState.slots[i];\n      if (s) {\n        ctx.fillStyle = TEXT_COLOR;\n        ctx.font = 'bold 20px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(String(s.value), x + slotW / 2, y + slotH / 2);\n      } else {\n        ctx.fillStyle = '#9EB7B7';\n        ctx.font = '12px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.fillText('Slot ' + (i + 1), x + slotW / 2, y + slotH / 2);\n      }\n\n      // Visual cue for current slot\n      if (i === gameState.currentSlotIndex) {\n        ctx.strokeStyle = ACCENT_COLOR;\n        ctx.lineWidth = 3;\n        ctx.strokeRect(x - 2, y - 2, slotW + 4, slotH + 4);\n      }\n\n      // Draw little arrow to machine\n      ctx.strokeStyle = '#3C6E70';\n      ctx.lineWidth = 6;\n      ctx.beginPath();\n      ctx.moveTo(x + slotW + 6, y + slotH / 2);\n      ctx.lineTo(420, 200);\n      ctx.stroke();\n\n      // Draw operation icon between slots except last\n      if (i < SLOTS - 1) {\n        const op = gameState.ops[i];\n        ctx.fillStyle = '#FFFBF2';\n        drawRoundedRect(ctx, x - 24, y + slotH + 10, 48, 28, 6);\n        ctx.fillStyle = TEXT_COLOR;\n        ctx.font = 'bold 18px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.fillText(op, x, y + slotH + 24);\n      }\n    }\n    ctx.restore();\n  }\n\n  function drawTargetPanel() {\n    ctx.save();\n    // target display\n    ctx.fillStyle = '#FFFFFF';\n    drawRoundedRect(ctx, 520, 60, 160, 76, 10);\n    ctx.strokeStyle = '#DCEFF0';\n    ctx.stroke();\n\n    ctx.fillStyle = TEXT_COLOR;\n    ctx.font = '20px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('Target Number', 600, 80);\n\n    ctx.fillStyle = ACCENT_COLOR;\n    ctx.font = 'bold 34px sans-serif';\n    ctx.fillText(String(gameState.target), 600, 112);\n\n    // Run button area (visual)\n    ctx.fillStyle = '#EFFFF9';\n    drawRoundedRect(ctx, 520, 160, 160, 120, 10);\n    ctx.fillStyle = '#7EDABF';\n    ctx.font = 'bold 20px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('RUN MACHINE', 600, 210);\n    ctx.fillStyle = TEXT_COLOR;\n    ctx.font = '14px sans-serif';\n    ctx.fillText('Press Enter', 600, 235);\n\n    // Last result display\n    if (gameState.lastRunResult !== null) {\n      ctx.fillStyle = '#FFFFFF';\n      drawRoundedRect(ctx, 520, 290, 160, 60, 8);\n      ctx.fillStyle = TEXT_COLOR;\n      ctx.font = '14px sans-serif';\n      ctx.fillText('Last result: ' + String(gameState.lastRunResult), 600, 320);\n    }\n\n    ctx.restore();\n  }\n\n  function drawHUD() {\n    ctx.save();\n    // Message\n    ctx.fillStyle = '#21333B';\n    ctx.font = '14px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText(gameState.message, 24, 30);\n\n    // Level & attempts\n    ctx.fillStyle = '#21333B';\n    ctx.font = '13px sans-serif';\n    ctx.fillText('Level: ' + gameState.level + '   Attempts: ' + gameState.attempts, 24, 50);\n\n    // Controls reminder\n    ctx.fillStyle = '#21333B';\n    ctx.font = '12px sans-serif';\n    ctx.fillText('\u2190 \u2192 Move   Space Load   Backspace Remove   Enter Run   R Reset/Next   M Toggle sound', 24, HEIGHT - 16);\n\n    // Audio visual indicator (speaker)\n    const speakerX = WIDTH - 42;\n    const speakerY = 26;\n    ctx.fillStyle = '#FFFFFF';\n    ctx.strokeStyle = '#9FBDBD';\n    ctx.lineWidth = 2;\n    drawRoundedRect(ctx, speakerX - 26, speakerY - 18, 52, 36, 8);\n    ctx.fillStyle = gameState.soundMuted ? '#FFADAD' : '#C9FFEE';\n    ctx.beginPath();\n    ctx.moveTo(speakerX - 12, speakerY + 2);\n    ctx.lineTo(speakerX - 12, speakerY - 10);\n    ctx.lineTo(speakerX - 2, speakerY - 4);\n    ctx.lineTo(speakerX + 10, speakerY - 12);\n    ctx.lineTo(speakerX + 10, speakerY + 12);\n    ctx.lineTo(speakerX - 2, speakerY + 4);\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n\n    // Cross out if muted\n    if (gameState.soundMuted) {\n      ctx.strokeStyle = '#C33';\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(speakerX - 20, speakerY - 12);\n      ctx.lineTo(speakerX + 20, speakerY + 12);\n      ctx.stroke();\n    }\n\n    // Friendly machine name\n    ctx.fillStyle = '#21333B';\n    ctx.font = '16px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('Machine Mix-Up', WIDTH / 2, 30);\n\n    ctx.restore();\n  }\n\n  // Initialize\n  function init() {\n    // Safety checks\n    try {\n      canvas.focus();\n    } catch (e) {\n      // ignore\n    }\n    // Default audio muted until user interacts\n    gameState.soundMuted = true;\n    updateAudioVisualCue();\n    generateLevel(gameState.level);\n    requestAnimationFrame(render);\n  }\n\n  // Start\n  init();\n\n  // Expose a small debug API on container for testing (non-intrusive)\n  container.__machineMixup = {\n    reset: resetLevel,\n    next: nextLevel,\n    toggleSound: () => setSoundMuted(!gameState.soundMuted),\n    getState: () => JSON.parse(JSON.stringify(gameState)),\n  };\n\n  // Provide basic accessibility: announce messages via ARIA live region\n  let liveRegion = document.createElement('div');\n  liveRegion.setAttribute('aria-live', 'polite');\n  liveRegion.style.position = 'absolute';\n  liveRegion.style.left = '-10000px';\n  liveRegion.style.top = 'auto';\n  container.appendChild(liveRegion);\n\n  // Update live region when messages change\n  let lastAnnounced = '';\n  setInterval(() => {\n    if (gameState.message && gameState.message !== lastAnnounced) {\n      liveRegion.textContent = gameState.message;\n      lastAnnounced = gameState.message;\n    }\n  }, 300);\n\n  // Graceful cleanup on unload\n  window.addEventListener('beforeunload', () => {\n    try {\n      if (audioContext && typeof audioContext.close === 'function') {\n        audioContext.close();\n      }\n    } catch (e) {\n      // ignore\n    }\n  });\n})();\n---\n",
  "improve_response_tokens": 17800,
  "formatted_code": true,
  "formatting_response_tokens": 19658,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}