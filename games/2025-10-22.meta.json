{
  "generated_date": "2025-10-22",
  "generated_timestamp": "2025-10-22T00:27:53.078981",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9035,
  "game_filename": "2025-10-22.js",
  "game_size_bytes": 26128,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Educational Drone Math Game\n  // Renders inside element with id \"game-of-the-day-stage\"\n  // All drawing done on a canvas sized exactly 720x480\n  // Uses Web Audio API for sounds (with error handling)\n  // Accessible keyboard controls: left/right (arrow or A/D), space to select, 1-4 to choose pad, R to restart, M to mute/unmute\n  // Win: reach targetCorrect (default 10). Lose: mistakes reach maxLives (default 3).\n  // Author: Generated for ages 7-9, focuses on addition/subtraction within 20.\n\n  // --- Configuration ---\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const TARGET_CORRECT = 10;\n  const MAX_LIVES = 3;\n  const PADDING = 12; // minimum padding between UI elements\n\n  // --- Utility functions ---\n  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }\n  function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }\n\n  // --- Setup canvas inside container ---\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Container element #game-of-the-day-stage not found.');\n    return;\n  }\n  container.innerHTML = ''; // clear any content\n  container.style.position = 'relative';\n  container.style.width = WIDTH + 'px';\n  container.style.height = HEIGHT + 'px';\n  container.style.outline = 'none';\n\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute('role', 'img');\n  canvas.setAttribute('aria-label', 'Drone math game. Use arrow keys to move, space to select, 1-4 to choose a pad, R to restart, M to mute.');\n  canvas.tabIndex = 0; // focusable for keyboard\n  canvas.style.display = 'block';\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext('2d');\n\n  // --- Audio setup with error handling ---\n  let audioEnabled = true;\n  let audioCtx = null;\n  let bgGain = null;\n  try {\n    const AudioContext = window.AudioContext || window.webkitAudioContext;\n    if (AudioContext) {\n      audioCtx = new AudioContext();\n      bgGain = audioCtx.createGain();\n      bgGain.gain.value = 0.06; // gentle background volume\n      bgGain.connect(audioCtx.destination);\n\n      // create a gentle background drone using low-frequency oscillator + filter\n      const bgOsc = audioCtx.createOscillator();\n      bgOsc.type = 'sine';\n      bgOsc.frequency.value = 60; // low hum\n      const bgFilter = audioCtx.createBiquadFilter();\n      bgFilter.type = 'lowpass';\n      bgFilter.frequency.value = 400;\n      bgOsc.connect(bgFilter);\n      bgFilter.connect(bgGain);\n      bgOsc.start();\n\n      // subtle movement with periodic LFO\n      const lfo = audioCtx.createOscillator();\n      lfo.frequency.value = 0.12;\n      const lfoGain = audioCtx.createGain();\n      lfoGain.gain.value = 50;\n      lfo.connect(lfoGain);\n      // use WebAudio automation to change filter frequency\n      lfoGain.connect(bgFilter.frequency);\n      lfo.start();\n    } else {\n      audioEnabled = false;\n      console.warn('Web Audio API not supported in this browser.');\n    }\n  } catch (e) {\n    audioEnabled = false;\n    console.warn('Audio context creation failed:', e);\n  }\n\n  function resumeAudioOnGesture() {\n    if (!audioCtx) return;\n    if (audioCtx.state === 'suspended' || audioCtx.state === 'interrupted') {\n      audioCtx.resume().catch((e) => {\n        console.warn('Audio resume failed:', e);\n      });\n    }\n  }\n\n  // Sound effects generator functions\n  function playCorrectSound() {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const o1 = audioCtx.createOscillator();\n      const o2 = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      g.gain.value = 0.001;\n      o1.type = 'sine';\n      o2.type = 'triangle';\n      o1.frequency.setValueAtTime(880, now);\n      o2.frequency.setValueAtTime(660, now);\n      o1.frequency.exponentialRampToValueAtTime(1320, now + 0.25);\n      o2.frequency.exponentialRampToValueAtTime(990, now + 0.25);\n      g.gain.setValueAtTime(0.001, now);\n      g.gain.exponentialRampToValueAtTime(0.25, now + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.8);\n      o1.connect(g);\n      o2.connect(g);\n      g.connect(audioCtx.destination);\n      o1.start(now);\n      o2.start(now);\n      o1.stop(now + 0.9);\n      o2.stop(now + 0.9);\n    } catch (e) {\n      console.warn('Error playing correct sound:', e);\n    }\n  }\n\n  function playIncorrectSound() {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = 'sawtooth';\n      o.frequency.setValueAtTime(220, now);\n      o.frequency.exponentialRampToValueAtTime(90, now + 0.4);\n      g.gain.setValueAtTime(0.001, now);\n      g.gain.exponentialRampToValueAtTime(0.3, now + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.7);\n      o.connect(g);\n      g.connect(audioCtx.destination);\n      o.start(now);\n      o.stop(now + 0.8);\n    } catch (e) {\n      console.warn('Error playing incorrect sound:', e);\n    }\n  }\n\n  // --- Game State ---\n  let score = 0;\n  let lives = MAX_LIVES;\n  let roundActive = true;\n  let currentProblem = null;\n  let choices = [];\n  let drone = {\n    x: WIDTH / 2,\n    y: 120,\n    vx: 0,\n    width: 60,\n    height: 30,\n    descending: false,\n    targetPadIndex: null,\n    descendProgress: 0\n  };\n  let pads = []; // will hold pad objects with x,y,width,height and value\n  let messageTimer = 0;\n  let messageText = '';\n  let paused = false;\n  let gameOverState = null; // null | 'win' | 'loss'\n  let highlightAudio = audioEnabled;\n  let lastAnswerCorrect = null;\n\n  // Prepare pad positions (4 pads across lower third)\n  function layoutPads() {\n    pads = [];\n    const padCount = 4;\n    const padY = HEIGHT - 110;\n    const padW = 120;\n    const padH = 60;\n    const gap = (WIDTH - padCount * padW) / (padCount + 1);\n    for (let i = 0; i < padCount; i++) {\n      const x = gap + i * (padW + gap);\n      pads.push({\n        x,\n        y: padY,\n        w: padW,\n        h: padH,\n        value: 0,\n        idx: i\n      });\n    }\n  }\n\n  layoutPads();\n\n  // --- Problem generation (age 7-9): simple addition or subtraction within 20 ---\n  function generateProblem() {\n    const op = Math.random() < 0.6 ? '+' : '-';\n    let a, b;\n    if (op === '+') {\n      a = randInt(1, 12);\n      b = randInt(1, 10);\n      if (a + b > 20) {\n        a = Math.max(1, 20 - b);\n      }\n    } else {\n      a = randInt(5, 20);\n      b = randInt(1, Math.min(9, a - 1));\n    }\n    const question = `${a} ${op} ${b}`;\n    const answer = op === '+' ? a + b : a - b;\n    currentProblem = { a, b, op, question, answer };\n    // Build choices array (correct + 3 distractors)\n    const set = new Set();\n    set.add(answer);\n    while (set.size < 4) {\n      let delta = randInt(-5, 5);\n      if (delta === 0) delta = randInt(1, 3);\n      let candidate = answer + delta;\n      if (candidate < 0) candidate = Math.abs(candidate) + 1;\n      if (candidate > 30) candidate = 30 - (candidate % 5);\n      set.add(candidate);\n    }\n    choices = shuffle(Array.from(set));\n    // assign to pads\n    for (let i = 0; i < pads.length; i++) {\n      pads[i].value = choices[i];\n    }\n  }\n\n  function shuffle(arr) {\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    return arr;\n  }\n\n  // --- Input Handling ---\n  const keys = {};\n  canvas.addEventListener('keydown', (e) => {\n    keys[e.key.toLowerCase()] = true;\n    // resume audio on first meaningful interaction\n    resumeAudioOnGesture();\n    if (e.key === ' ' || e.key === 'Spacebar') {\n      e.preventDefault();\n    }\n    // handle quick keyboard commands\n    if (e.key.toLowerCase() === 'r') {\n      restartGame();\n    } else if (e.key.toLowerCase() === 'm') {\n      toggleMute();\n    } else if (['1','2','3','4'].includes(e.key)) {\n      // map to pad selection\n      const idx = parseInt(e.key) - 1;\n      attemptSelectPad(idx);\n    }\n  });\n  canvas.addEventListener('keyup', (e) => {\n    keys[e.key.toLowerCase()] = false;\n  });\n\n  // Mouse interactions: clicking a pad selects it; clicking restart while on end screens restarts\n  canvas.addEventListener('click', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    // If game over/win, detect restart button area\n    if (gameOverState) {\n      const btn = getRestartButtonBounds();\n      if (mx >= btn.x && mx <= btn.x + btn.w && my >= btn.y && my <= btn.y + btn.h) {\n        restartGame();\n        return;\n      }\n      return;\n    }\n    // If clicked on a pad:\n    for (let i = 0; i < pads.length; i++) {\n      const p = pads[i];\n      if (mx >= p.x && mx <= p.x + p.w && my >= p.y && my <= p.y + p.h) {\n        attemptSelectPad(i);\n        return;\n      }\n    }\n    // Click toggles audio icon area\n    const audioRect = getAudioIconBounds();\n    if (mx >= audioRect.x && mx <= audioRect.x + audioRect.w && my >= audioRect.y && my <= audioRect.y + audioRect.h) {\n      toggleMute();\n    }\n  });\n\n  function attemptSelectPad(index) {\n    if (gameOverState || !roundActive) return;\n    if (index < 0 || index >= pads.length) return;\n    // start drone descending animation toward pad\n    drone.descending = true;\n    drone.targetPadIndex = index;\n    drone.descendProgress = 0;\n    resumeAudioOnGesture();\n  }\n\n  function getAudioIconBounds() {\n    const w = 36;\n    const h = 28;\n    return { x: WIDTH - w - PADDING, y: PADDING + 30, w, h };\n  }\n\n  function toggleMute() {\n    if (!audioCtx) {\n      audioEnabled = false;\n      highlightAudio = false;\n      return;\n    }\n    if (!audioEnabled) {\n      audioEnabled = true;\n      resumeAudioOnGesture();\n    } else {\n      audioEnabled = false;\n    }\n    highlightAudio = audioEnabled;\n  }\n\n  // --- Game Logic: process selection result when drone reaches pad ---\n  function processSelection(padIndex) {\n    const selectedValue = pads[padIndex].value;\n    const correct = selectedValue === currentProblem.answer;\n    lastAnswerCorrect = correct;\n    if (correct) {\n      score += 1;\n      messageText = 'Nice! Package delivered!';\n      messageTimer = 90;\n      playCorrectSound();\n    } else {\n      lives -= 1;\n      messageText = 'Oops! Wrong building!';\n      messageTimer = 90;\n      playIncorrectSound();\n    }\n    // mini animation feedback\n    roundActive = false;\n    setTimeout(() => {\n      // determine win/loss\n      if (score >= TARGET_CORRECT) {\n        gameOverState = 'win';\n      } else if (lives <= 0) {\n        gameOverState = 'loss';\n      } else {\n        // next round\n        generateProblem();\n        roundActive = true;\n      }\n      // reset drone\n      drone.descending = false;\n      drone.targetPadIndex = null;\n      drone.descendProgress = 0;\n      drone.x = WIDTH / 2;\n      drone.y = 120;\n    }, 700);\n  }\n\n  // --- Restart game ---\n  function restartGame() {\n    score = 0;\n    lives = MAX_LIVES;\n    roundActive = true;\n    gameOverState = null;\n    messageText = '';\n    messageTimer = 0;\n    lastAnswerCorrect = null;\n    generateProblem();\n    drone.x = WIDTH / 2;\n    drone.y = 120;\n    drone.descending = false;\n    drone.targetPadIndex = null;\n    drone.descendProgress = 0;\n    resumeAudioOnGesture();\n  }\n\n  // --- Drawing helpers with layout rules (non-overlapping, measuring) ---\n  function drawBackground() {\n    // calming gradient sky\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, '#e8f7ff');\n    g.addColorStop(1, '#f7fbff');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // whimsical soft clouds and drones background elements (non-interactive)\n    for (let i = 0; i < 7; i++) {\n      const cx = (i * 123) % WIDTH + (i % 3) * 20;\n      const cy = 40 + ((i * 77) % 100);\n      ctx.globalAlpha = 0.3;\n      drawCloud(cx, cy, 36 + (i % 3) * 12, '#ffffff');\n      ctx.globalAlpha = 1;\n    }\n\n    // grass / city silhouette at bottom\n    ctx.fillStyle = '#e6f4ea';\n    ctx.fillRect(0, HEIGHT - 80, WIDTH, 80);\n    // wacky building shapes for landing visual\n    const buildingColors = ['#d7ebff', '#e7ffe6', '#fff6d7'];\n    for (let i = 0; i < 8; i++) {\n      const bw = 60 + (i % 3) * 20;\n      const bh = 40 + (i % 4) * 18;\n      const bx = i * 90 + 10;\n      const by = HEIGHT - 80 - bh;\n      ctx.fillStyle = buildingColors[i % buildingColors.length];\n      roundRect(ctx, bx, by, bw, bh, 6, true, false);\n      ctx.strokeStyle = '#d0d0d0';\n      ctx.strokeRect(bx + 6, by + 6, bw - 12, bh - 12);\n    }\n  }\n\n  function drawCloud(x, y, r, color) {\n    ctx.fillStyle = color;\n    arcFill(x, y, r);\n    arcFill(x + r * 0.8, y - r * 0.2, r * 0.85);\n    arcFill(x - r * 0.8, y - r * 0.2, r * 0.85);\n    ctx.fillRect(x - r, y, r * 2, r * 0.9);\n  }\n\n  function arcFill(x, y, r) {\n    ctx.beginPath();\n    ctx.arc(x, y, r, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  function roundRect(ctx, x, y, w, h, r, fill, stroke) {\n    if (r < 0) r = 0;\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  // --- Draw UI elements with measureText-based backgrounds to avoid overlap ---\n  function drawTopUI() {\n    // Score top-left\n    ctx.font = 'bold 20px sans-serif';\n    const scoreText = `Score: ${score}`;\n    const scoreMetrics = ctx.measureText(scoreText);\n    const scoreW = scoreMetrics.width + 16;\n    const scoreH = 28;\n    const scoreX = PADDING;\n    const scoreY = PADDING;\n    roundRectFillStroke(scoreX, scoreY, scoreW, scoreH, 8, '#ffffffcc', '#a6d1ff');\n\n    ctx.fillStyle = '#154360';\n    ctx.font = 'bold 20px sans-serif';\n    ctx.fillText(scoreText, scoreX + 8, scoreY + 20);\n\n    // Center top: Problem progress\n    ctx.font = 'bold 22px sans-serif';\n    const progressText = `Delivery ${score + 1} of ${TARGET_CORRECT}`;\n    const progMetrics = ctx.measureText(progressText);\n    const progW = progMetrics.width + 20;\n    const progX = (WIDTH - progW) / 2;\n    const progY = PADDING;\n    roundRectFillStroke(progX, progY, progW, scoreH, 8, '#ffffffcc', '#c9f6d3');\n    ctx.fillStyle = '#0b5345';\n    ctx.fillText(progressText, progX + 10, progY + 20);\n\n    // Lives top-right\n    ctx.font = 'bold 20px sans-serif';\n    const livesText = `Mistakes: ${MAX_LIVES - lives}/${MAX_LIVES}`;\n    const livesMetrics = ctx.measureText(livesText);\n    const livesW = livesMetrics.width + 16;\n    const livesX = WIDTH - livesW - PADDING;\n    const livesY = PADDING;\n    roundRectFillStroke(livesX, livesY, livesW, scoreH, 8, '#fff0f0cc', '#ffc9c9');\n    ctx.fillStyle = '#6b0b0b';\n    ctx.fillText(livesText, livesX + 8, livesY + 20);\n\n    // Audio icon below lives\n    const audioRect = getAudioIconBounds();\n    ctx.fillStyle = '#ffffffcc';\n    roundRectFillStroke(audioRect.x - 2, audioRect.y - 2, audioRect.w + 4, audioRect.h + 4, 6, '#ffffffcc', '#cccccc');\n    // draw speaker\n    ctx.fillStyle = highlightAudio ? '#0b6b6b' : '#888';\n    ctx.beginPath();\n    ctx.moveTo(audioRect.x + 6, audioRect.y + 8);\n    ctx.lineTo(audioRect.x + 16, audioRect.y + 8);\n    ctx.lineTo(audioRect.x + 24, audioRect.y + 4);\n    ctx.lineTo(audioRect.x + 24, audioRect.y + audioRect.h - 4);\n    ctx.lineTo(audioRect.x + 16, audioRect.y + audioRect.h - 8);\n    ctx.lineTo(audioRect.x + 6, audioRect.y + audioRect.h - 8);\n    ctx.closePath();\n    ctx.fill();\n    // sound waves or mute cross\n    if (highlightAudio) {\n      ctx.beginPath();\n      ctx.strokeStyle = '#0b6b6b';\n      ctx.lineWidth = 2;\n      ctx.arc(audioRect.x + 26, audioRect.y + audioRect.h / 2 - 2, 8, -0.6, 0.6);\n      ctx.stroke();\n    } else {\n      ctx.strokeStyle = '#aa0000';\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(audioRect.x + 26, audioRect.y + 6);\n      ctx.lineTo(audioRect.x + 34, audioRect.y + audioRect.h - 6);\n      ctx.stroke();\n    }\n  }\n\n  function roundRectFillStroke(x, y, w, h, r, fillColor, strokeColor) {\n    ctx.fillStyle = fillColor;\n    ctx.strokeStyle = strokeColor || '#999';\n    ctx.lineWidth = 1.5;\n    roundRect(ctx, x, y, w, h, r, true, true);\n  }\n\n  // --- Draw drone ---\n  function drawDrone() {\n    const d = drone;\n    // body\n    ctx.save();\n    ctx.translate(d.x, d.y);\n    ctx.fillStyle = '#fff';\n    ctx.strokeStyle = '#5a8190';\n    ctx.lineWidth = 2;\n    roundRect(ctx, -d.width/2, -d.height/2, d.width, d.height, 8, true, true);\n    // windows\n    ctx.fillStyle = '#aee3ff';\n    ctx.fillRect(-d.width/2 + 6, -d.height/2 + 6, d.width - 12, d.height/2 - 2);\n    // propellers (wacky)\n    ctx.fillStyle = '#f9d976';\n    for (let i=0;i<4;i++){\n      const px = (i - 1.5) * (d.width/3);\n      const py = -d.height/2 - 10;\n      ctx.beginPath();\n      ctx.ellipse(px, py, 12, 4, (i%2?0.6:0.2), 0, Math.PI*2);\n      ctx.fill();\n    }\n    ctx.restore();\n    // little package trail\n    if (d.descending) {\n      ctx.fillStyle = lastAnswerCorrect ? '#bfffbf' : '#ffd6d6';\n      ctx.fillRect(d.x - 6, d.y + 20, 12, 14);\n    } else {\n      ctx.fillStyle = '#f0e6c8';\n      ctx.fillRect(d.x - 8, d.y + 20, 16, 10);\n    }\n  }\n\n  // --- Draw pads and their values ---\n  function drawPads() {\n    for (let i = 0; i < pads.length; i++) {\n      const p = pads[i];\n      // highlight if hovered by mouse or targeted by drone\n      // determine if selected\n      const isTarget = drone.targetPadIndex === i && drone.descending;\n      // pad shadow\n      ctx.fillStyle = '#00000010';\n      ctx.fillRect(p.x + 6, p.y + 8, p.w, p.h);\n      // pad body\n      ctx.fillStyle = isTarget ? '#ffe6a6' : '#ffffff';\n      ctx.strokeStyle = '#b3cfe0';\n      ctx.lineWidth = 2;\n      roundRect(ctx, p.x, p.y, p.w, p.h, 12, true, true);\n\n      // pad rooftop drawing\n      ctx.fillStyle = '#e8f7ff';\n      ctx.fillRect(p.x + 10, p.y - 18, p.w - 20, 16);\n      // value text centered\n      ctx.font = 'bold 28px sans-serif';\n      ctx.fillStyle = '#1a3b4d';\n      const text = String(p.value);\n      const metrics = ctx.measureText(text);\n      const tx = p.x + (p.w - metrics.width) / 2;\n      const ty = p.y + p.h / 2 + 10;\n      // background rectangle behind the text for readability\n      const tbw = metrics.width + 12;\n      const tbh = 36;\n      const tbx = tx - 6;\n      const tby = ty - 28;\n      ctx.fillStyle = isTarget ? '#d6ffd6' : '#f9f9f9';\n      roundRectFillStroke(tbx, tby, tbw, tbh, 8, ctx.fillStyle, '#d0d0d0');\n      ctx.fillStyle = '#1a3b4d';\n      ctx.fillText(text, tx, ty);\n      // pad number label (1-4) bottom-left of pad\n      ctx.font = '14px sans-serif';\n      ctx.fillStyle = '#5e5e5e';\n      ctx.fillText(`(${i+1})`, p.x + 8, p.y + p.h - 12);\n    }\n  }\n\n  // --- Instruction area bottom-center ---\n  function drawInstructions() {\n    const lines = [\n      'Controls: \u2190 / \u2192 or A/D to move drone  \u2022  Space to drop  \u2022  1-4 to choose a pad',\n      'Goal: Deliver ' + TARGET_CORRECT + ' packages. 3 wrong deliveries = game over.',\n      'Click a pad or press its number. Press M to mute/unmute audio. Press R to restart.'\n    ];\n    ctx.font = 'bold 16px sans-serif';\n    ctx.fillStyle = '#08303b';\n    // compute text block width (max of lines)\n    let maxW = 0;\n    for (const l of lines) {\n      const m = ctx.measureText(l).width;\n      if (m > maxW) maxW = m;\n    }\n    const boxW = maxW + 20;\n    const boxH = lines.length * 22 + 14;\n    const bx = (WIDTH - boxW) / 2;\n    const by = HEIGHT - boxH - PADDING;\n    roundRectFillStroke(bx, by, boxW, boxH, 8, '#ffffffcc', '#cfe9ff');\n    ctx.fillStyle = '#03313a';\n    for (let i = 0; i < lines.length; i++) {\n      ctx.fillText(lines[i], bx + 10, by + 20 + i * 22);\n    }\n  }\n\n  // --- Message display (short-lived) ---\n  function drawMessage() {\n    if (!messageText || messageTimer <= 0) return;\n    ctx.font = '18px sans-serif';\n    const text = messageText;\n    const metrics = ctx.measureText(text);\n    const w = metrics.width + 24;\n    const h = 36;\n    const x = (WIDTH - w) / 2;\n    const y = 120;\n    roundRectFillStroke(x, y, w, h, 10, lastAnswerCorrect ? '#eaffea' : '#ffecec', '#c3c3c3');\n    ctx.fillStyle = lastAnswerCorrect ? '#0a6b18' : '#a60404';\n    ctx.fillText(text, x + 12, y + 23);\n  }\n\n  // --- End screens ---\n  function getRestartButtonBounds() {\n    const bw = 160;\n    const bh = 44;\n    const bx = (WIDTH - bw) / 2;\n    const by = HEIGHT / 2 + 80;\n    return { x: bx, y: by, w: bw, h: bh };\n  }\n\n  function drawEndScreen() {\n    // dim background\n    ctx.fillStyle = 'rgba(0,0,0,0.35)';\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    ctx.font = 'bold 30px sans-serif';\n    ctx.fillStyle = '#fff';\n    let title = gameOverState === 'win' ? 'Victory!' : 'Game Over';\n    // background box for title\n    const titleMetrics = ctx.measureText(title);\n    const titleW = titleMetrics.width + 40;\n    const titleH = 60;\n    const tx = (WIDTH - titleW) / 2;\n    const ty = HEIGHT / 2 - 80;\n    roundRectFillStroke(tx, ty, titleW, titleH, 12, '#2b7a7a', '#0b3940');\n    ctx.fillStyle = '#fff';\n    ctx.fillText(title, tx + 20, ty + 40);\n\n    // message\n    ctx.font = '18px sans-serif';\n    ctx.fillStyle = '#ffffff';\n    const msg = gameOverState === 'win'\n      ? `Your drone delivered ${score} packages! You're a master pilot.`\n      : `You made ${MAX_LIVES - lives} mistakes. Try again!`;\n    const metrics = ctx.measureText(msg);\n    const mw = metrics.width;\n    ctx.fillText(msg, (WIDTH - mw) / 2, HEIGHT / 2 - 20);\n\n    // restart button\n    const btn = getRestartButtonBounds();\n    roundRectFillStroke(btn.x, btn.y, btn.w, btn.h, 10, '#ffffff', '#377b56');\n    ctx.fillStyle = '#083a2b';\n    ctx.font = 'bold 20px sans-serif';\n    const btnText = 'Restart (R)';\n    const bm = ctx.measureText(btnText).width;\n    ctx.fillText(btnText, btn.x + (btn.w - bm) / 2, btn.y + 28);\n    // also accessibility hint\n    ctx.font = '14px sans-serif';\n    ctx.fillStyle = '#f0f0f0';\n    const hint = 'Press R to restart or click the button';\n    const hm = ctx.measureText(hint).width;\n    ctx.fillText(hint, (WIDTH - hm) / 2, btn.y + btn.h + 26);\n  }\n\n  // --- Game loop and animation ---\n  function update() {\n    if (gameOverState) {\n      // nothing to update when ended except maybe hover or audio toggles\n      return;\n    }\n    // keyboard drone movement when not descending\n    if (!drone.descending) {\n      let move = 0;\n      if (keys['arrowleft'] || keys['a']) move = -1;\n      if (keys['arrowright'] || keys['d']) move = 1;\n      drone.vx = move * 3.2;\n      drone.x += drone.vx;\n      drone.x = clamp(drone.x, 40, WIDTH - 40);\n      // space to drop: attempt to drop on nearest pad\n      if (keys[' '] || keys['spacebar']) {\n        // find nearest pad horizontally\n        let nearest = 0;\n        let minDist = Infinity;\n        for (let i = 0; i < pads.length; i++) {\n          const center = pads[i].x + pads[i].w / 2;\n          const dist = Math.abs(center - drone.x);\n          if (dist < minDist) {\n            minDist = dist;\n            nearest = i;\n          }\n        }\n        attemptSelectPad(nearest);\n        // prevent repeated dropping by clearing space key (simple debounce)\n        keys[' '] = false;\n        keys['spacebar'] = false;\n      }\n    } else {\n      // handle descending animation toward target pad\n      const targetPad = pads[drone.targetPadIndex];\n      if (!targetPad) {\n        drone.descending = false;\n        return;\n      }\n      // move drone horizontally toward pad center\n      const targetX = targetPad.x + targetPad.w / 2;\n      const dx = targetX - drone.x;\n      drone.x += dx * 0.18; // smooth horizontal easing\n      // increase descend progress\n      drone.descendProgress += 0.08;\n      drone.y = 120 + (targetPad.y - 120) * Math.min(1, drone.descendProgress);\n      // when close to pad, trigger landing\n      if (drone.descendProgress >= 0.98 || Math.abs(targetPad.x + targetPad.w/2 - drone.x) < 2) {\n        // land\n        processSelection(drone.targetPadIndex);\n      }\n    }\n\n    if (messageTimer > 0) messageTimer--;\n  }\n\n  function draw() {\n    // clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    drawBackground();\n    drawTopUI();\n    drawPads();\n    drawDrone();\n    drawMessage();\n    drawInstructions();\n    // draw problem box center top area below top UI\n    drawProblemBox();\n    if (gameOverState) drawEndScreen();\n  }\n\n  function drawProblemBox() {\n    if (!currentProblem) return;\n    ctx.font = 'bold 26px sans-serif';\n    const q = 'Solve: ' + currentProblem.question;\n    const metrics = ctx.measureText(q);\n    const boxW = metrics.width + 28;\n    const boxH = 44;\n    const bx = (WIDTH - boxW) / 2;\n    const by = 70;\n    roundRectFillStroke(bx, by, boxW, boxH, 10, '#ffffffee', '#bfe8ff');\n    ctx.fillStyle = '#09414f';\n    ctx.fillText(q, bx + 14, by + 30);\n  }\n\n  // --- Main loop ---\n  generateProblem();\n  let last = performance.now();\n  function loop(ts) {\n    const dt = ts - last;\n    last = ts;\n    update();\n    draw();\n    requestAnimationFrame(loop);\n  }\n  requestAnimationFrame(loop);\n\n  // --- Initial focus and instructions for accessibility ---\n  setTimeout(() => {\n    try {\n      canvas.focus();\n    } catch (e) {\n      // ignore\n    }\n  }, 100);\n\n  // --- Error handling: check audio later, show a small message if audio disabled ---\n  if (!audioEnabled) {\n    // draw small text on canvas after UI is ready\n    setTimeout(() => {\n      ctx.font = '14px sans-serif';\n      const msg = 'Audio unavailable. Press M to toggle (if supported).';\n      const mW = ctx.measureText(msg).width;\n      ctx.fillStyle = '#5a5a5a';\n      ctx.fillText(msg, WIDTH - mW - PADDING, HEIGHT - PADDING - 10);\n    }, 500);\n  }\n\n  // Expose some functions for debugging (optional)\n  window.__droneMathGame = {\n    restart: restartGame,\n    mute: toggleMute\n  };\n\n  // --- Helper: initial draw for any errors in resource load ---\n  try {\n    // ensure fonts exist - not strictly necessary\n  } catch (e) {\n    console.warn('Initialization minor error:', e);\n  }\n\n  // --- End of IIFE ---\n})();\n---\n",
  "improve_response_tokens": 20488,
  "formatted_code": true,
  "formatting_response_tokens": 23547,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}