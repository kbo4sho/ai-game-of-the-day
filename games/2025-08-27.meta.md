# Game of the Day - 2025-08-27

## Metadata
- **Generated Date:** 2025-08-27
- **Generated Time:** 2025-08-27T21:27:28.070547
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-08-27.js
- **File Size:** 34379 bytes
- **Tokens Used:** 10565

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-08-27.js` - The playable game
- `2025-08-27.meta.json` - Machine-readable metadata
- `2025-08-27.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 22144

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 23196

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function() {
  // Machine Match - A calming, wacky, educational math game for ages 7-9
  // Renders inside the element with ID "game-of-the-day-stage"
  // All visuals drawn on a 720x480 canvas. Sounds generated via Web Audio API.
  // Accessible controls: mouse/touch/keyboard. Includes audio toggle and text instructions.

  // ------------------------------
  // Initialization & Setup
  // ------------------------------
  const STAGE_ID = 'game-of-the-day-stage';
  const WIDTH = 720;
  const HEIGHT = 480;
  const SLOT_COUNT = 3; // number of slots to fill each round
  const TOTAL_LEVELS = 5;

  const stage = document.getElementById(STAGE_ID);
  if (!stage) {
    console.error('Game stage element not found:', STAGE_ID);
    return;
  }
  // Clear stage and create canvas
  stage.innerHTML = '';
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.tabIndex = 0; // make focusable for keyboard
  canvas.setAttribute('role', 'application');
  canvas.setAttribute('aria-label', 'Machine Match math game. Use mouse or keyboard to play.');
  stage.appendChild(canvas);

  const ctx = canvas.getContext('2d');
  if (!ctx) {
    console.error('Unable to get 2D context');
    return;
  }

  // Accessibility text fallback: if canvas isn't available, show message
  if (!canvas.getContext) {
    stage.textContent = 'Your browser does not support canvas. Please use a modern browser to play this game.';
    return;
  }

  // ------------------------------
  // Audio setup with error handling
  // ------------------------------
  let audioCtx = null;
  let audioAllowed = false; // toggled by user
  let backgroundGain = null;
  let backgroundOsc = null;

  function safeCreateAudioContext() {
    if (audioCtx) return audioCtx;
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) {
        console.warn('Web Audio API not supported in this browser.');
        return null;
      }
      audioCtx = new AC();
      return audioCtx;
    } catch (e) {
      console.warn('Error creating AudioContext:', e);
      audioCtx = null;
      return null;
    }
  }

  // Called after a user gesture to initialize audio
  function initAudioOnGesture() {
    if (audioAllowed) return;
    const ac = safeCreateAudioContext();
    if (!ac) return;
    try {
      // create a soft ambient hum
      backgroundOsc = ac.createOscillator();
      backgroundGain = ac.createGain();
      backgroundOsc.type = 'sine';
      backgroundOsc.frequency.value = 80; // low rumble
      backgroundGain.gain.value = 0; // start muted until toggled
      backgroundOsc.connect(backgroundGain);
      backgroundGain.connect(ac.destination);
      backgroundOsc.start(0);
      audioAllowed = true;
    } catch (e) {
      console.warn('Error initializing background audio:', e);
      audioAllowed = false;
    }
  }

  // Sound helpers
  function playTone({ frequency = 440, duration = 0.25, type = 'sine', volume = 0.08, attack = 0.01, decay = 0.2 }) {
    const ac = audioCtx;
    if (!ac || !audioAllowed) return;
    try {
      const o = ac.createOscillator();
      const g = ac.createGain();
      const filt = ac.createBiquadFilter();
      o.type = type;
      o.frequency.value = frequency;
      filt.type = 'lowpass';
      filt.frequency.value = Math.max(800, frequency * 2);
      g.gain.value = 0;
      o.connect(filt);
      filt.connect(g);
      g.connect(ac.destination);
      const now = ac.currentTime;
      g.gain.cancelScheduledValues(now);
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(volume, now + attack);
      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);
      o.start(now);
      o.stop(now + duration + 0.05);
    } catch (e) {
      console.warn('Error playing tone:', e);
    }
  }

  function playCorrectTone() {
    playTone({ frequency: 880, duration: 0.35, type: 'triangle', volume: 0.12, attack: 0.01 });
    // small celebratory arpeggio
    setTimeout(() => playTone({ frequency: 1320, duration: 0.18, type: 'sine', volume: 0.09 }), 120);
    setTimeout(() => playTone({ frequency: 1760, duration: 0.14, type: 'sine', volume: 0.08 }), 260);
  }
  function playIncorrectTone() {
    playTone({ frequency: 220, duration: 0.35, type: 'sawtooth', volume: 0.08, attack: 0.01 });
    setTimeout(() => playTone({ frequency: 180, duration: 0.24, type: 'sawtooth', volume: 0.06 }), 120);
  }
  function playClick() {
    playTone({ frequency: 600, duration: 0.08, type: 'square', volume: 0.05, attack: 0.005 });
  }

  // Toggle ambient background on/off (visual cue drawn on canvas)
  let backgroundOn = false;
  function setBackgroundOn(on) {
    const ac = audioCtx;
    backgroundOn = !!on;
    if (!ac || !backgroundGain) return;
    try {
      if (backgroundOn) {
        // fade in very gently
        backgroundGain.gain.cancelScheduledValues(ac.currentTime);
        backgroundGain.gain.setValueAtTime(0, ac.currentTime);
        backgroundGain.gain.linearRampToValueAtTime(0.02, ac.currentTime + 1.2);
      } else {
        backgroundGain.gain.cancelScheduledValues(ac.currentTime);
        backgroundGain.gain.linearRampToValueAtTime(0, ac.currentTime + 0.6);
      }
    } catch (e) {
      console.warn('Error toggling background:', e);
    }
  }

  // ------------------------------
  // Game state & logic
  // ------------------------------
  let level = 1;
  let targetSum = 0;
  let parts = []; // moving parts on conveyor
  let slots = new Array(SLOT_COUNT).fill(null); // placed parts or null
  let conveyorOffset = 0; // animation offset
  let selectedPartIndex = 0; // index of currently highlighted part
  let dragging = null; // {partIndex, offsetX, offsetY} or null
  let animationId = null;
  let message = 'Welcome! Press SPACE or click parts to place them in the machine.';
  let successFlash = 0;
  let attemptsThisLevel = 0;
  let finished = false;

  // Colors (calming palette)
  const palette = {
    bg: '#eaf2f1',
    panel: '#ffffff',
    accent: '#6aa6a7',
    accent2: '#f7b267',
    gear: '#c7e9e6',
    text: '#163b36',
    part: '#f2d8b6',
    wrong: '#ff9b9b',
    slotBg: '#f6f8f8'
  };

  // Utility: random integer
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // Generate parts for level
  function generatePartsForLevel(lv) {
    const count = 6; // number of moving parts visible
    let maxValue = 8 + lv * 2;
    maxValue = Math.min(maxValue, 12);
    const arr = [];
    for (let i = 0; i < count; i++) {
      arr.push({
        value: randInt(1, maxValue),
        wobble: Math.random() * Math.PI * 2,
        id: Math.random().toString(36).slice(2),
      });
    }
    return arr;
  }

  function computeTargetForLevel(lv) {
    // target increases per level and is achievable by combination of SLOT_COUNT numbers from parts pool
    // We'll craft a target between SLOT_COUNT*2 and SLOT_COUNT*10 influenced by level
    const base = SLOT_COUNT * 2 + (lv - 1) * 3;
    return Math.max(base, SLOT_COUNT * 3);
  }

  // Initialize a new level
  function startLevel(lv) {
    level = lv;
    finished = false;
    attemptsThisLevel = 0;
    targetSum = computeTargetForLevel(level);
    parts = generatePartsForLevel(level);
    // Ensure at least one valid combination exists: adjust one part
    // Create combination that sums to target using SLOT_COUNT random parts and set their values accordingly
    const combo = [];
    let remaining = targetSum;
    for (let i = 0; i < SLOT_COUNT; i++) {
      const remainingSlots = SLOT_COUNT - i;
      const maxForSlot = Math.max(1, Math.min(12, Math.floor(remaining / remainingSlots * 1.3)));
      const minForSlot = Math.max(1, Math.floor(remaining / remainingSlots * 0.6));
      const val = i === SLOT_COUNT - 1 ? remaining : randInt(minForSlot, maxForSlot);
      combo.push(val);
      remaining -= val;
    }
    // Place combo values into some parts indices to ensure solvable
    for (let i = 0; i < combo.length; i++) {
      parts[i].value = combo[i];
    }
    // Shuffle parts a bit
    for (let i = parts.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [parts[i], parts[j]] = [parts[j], parts[i]];
    }
    // Reset slots and state
    slots = new Array(SLOT_COUNT).fill(null);
    conveyorOffset = 0;
    selectedPartIndex = 0;
    message = 'Place ' + SLOT_COUNT + ' parts whose numbers add up to ' + targetSum + '. Use mouse or keyboard.';
  }

  // Check whether the placed slots are correct
  function checkSlots() {
    const filled = slots.every(s => s !== null);
    if (!filled) {
      message = `Fill all ${SLOT_COUNT} slots, then press Check (Enter) or it will auto-check.`;
      return false;
    }
    const sum = slots.reduce((acc, s) => acc + s.value, 0);
    attemptsThisLevel++;
    if (sum === targetSum) {
      playCorrectTone();
      successFlash = 40;
      message = 'Nice! The machine hums happily. Press Next to continue.';
      return true;
    } else {
      playIncorrectTone();
      message = `That totals ${sum}. Try again to reach ${targetSum}.`;
      return false;
    }
  }

  // Place a part into the next empty slot (by index)
  function placePartToSlot(partIndex) {
    if (finished) return;
    if (!parts[partIndex]) return;
    const nextSlot = slots.findIndex(s => s === null);
    if (nextSlot === -1) {
      message = 'All slots are full. Press Enter to check or remove a part.';
      playClick();
      return;
    }
    // Move part value into slot and mark part as used
    slots[nextSlot] = { ...parts[partIndex] }; // copy
    parts.splice(partIndex, 1); // remove from conveyor
    // Ensure selectedPartIndex stays in bounds
    if (selectedPartIndex >= parts.length) selectedPartIndex = Math.max(0, parts.length - 1);
    playClick();
    message = 'Placed a part. Press Enter to check or continue placing.';
    // Auto-check if all slots filled
    if (slots.every(s => s !== null)) {
      const ok = checkSlots();
      if (ok) {
        // progress to next or finish after a short delay
        setTimeout(() => {
          if (level >= TOTAL_LEVELS) {
            finished = true;
            message = 'You repaired all machines! You WIN! Press R to play again.';
          } else {
            startLevel(level + 1);
          }
        }, 900);
      } else {
        // allow retry: return parts from slots into conveyor with slight shuffle
        setTimeout(() => {
          // return slot parts to end of parts array (but only if parts array isn't huge)
          const returned = slots.map(s => s && { value: s.value, wobble: Math.random() * Math.PI * 2, id: Math.random().toString(36).slice(2) }).filter(Boolean);
          parts = parts.concat(returned);
          slots = new Array(SLOT_COUNT).fill(null);
        }, 700);
      }
    }
  }

  // Remove a slot (like undo) by index
  function removeSlot(slotIndex) {
    if (slotIndex < 0 || slotIndex >= slots.length || !slots[slotIndex]) {
      message = 'That slot is empty.';
      return;
    }
    // return the part to the end of parts array
    parts.push({ value: slots[slotIndex].value, wobble: Math.random() * Math.PI * 2, id: Math.random().toString(36).slice(2) });
    slots[slotIndex] = null;
    playClick();
    message = 'Removed a part from the machine.';
  }

  // Restart game
  function restartGame() {
    level = 1;
    startLevel(1);
    finished = false;
    playClick();
  }

  // ------------------------------
  // Input handling (mouse, touch, keyboard)
  // ------------------------------
  // Convert client coordinates to canvas coordinates
  function toCanvasCoord(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left) * (canvas.width / rect.width);
    const y = (clientY - rect.top) * (canvas.height / rect.height);
    return { x, y };
  }

  // Hit testing for parts drawn on conveyor
  function hitTestPart(x, y) {
    // parts drawn along a conveyor at y ~ 360 and spaced horizontally
    const conveyorY = 360;
    const spacing = 92;
    const startX = 100;
    for (let i = 0; i < parts.length; i++) {
      const px = startX + i * spacing - conveyorOffset % (spacing * parts.length);
      const py = conveyorY + Math.sin(parts[i].wobble + Date.now() / 800) * 6;
      const dx = x - px;
      const dy = y - py;
      if (Math.sqrt(dx * dx + dy * dy) < 36) {
        return i;
      }
    }
    return -1;
  }

  // Hit testing for slots
  function hitTestSlot(x, y) {
    const slotY = 200;
    const slotWidth = 84;
    const slotSpacing = 112;
    const startX = (WIDTH - ((SLOT_COUNT - 1) * slotSpacing + slotWidth)) / 2;
    for (let i = 0; i < SLOT_COUNT; i++) {
      const sx = startX + i * slotSpacing;
      const sy = slotY;
      if (x >= sx && x <= sx + slotWidth && y >= sy && y <= sy + 68) {
        return i;
      }
    }
    return -1;
  }

  canvas.addEventListener('mousedown', (ev) => {
    canvas.focus();
    initAudioOnGesture(); // ensure audio context created after gesture
    const pos = toCanvasCoord(ev.clientX, ev.clientY);
    const pi = hitTestPart(pos.x, pos.y);
    if (pi >= 0) {
      // start dragging
      const conveyorY = 360;
      const spacing = 92;
      const startX = 100;
      const px = startX + pi * spacing - conveyorOffset % (spacing * parts.length);
      const py = conveyorY + Math.sin(parts[pi].wobble + Date.now() / 800) * 6;
      dragging = {
        partIndex: pi,
        offsetX: pos.x - px,
        offsetY: pos.y - py
      };
      selectedPartIndex = pi;
      playClick();
    } else {
      // check if clicked on audio toggle or next button area or retry area
      handleUIClick(pos.x, pos.y);
    }
  });

  canvas.addEventListener('mousemove', (ev) => {
    if (!dragging) return;
    const pos = toCanvasCoord(ev.clientX, ev.clientY);
    // update dragging visuals by setting a temporary "drag position" on a virtual copy of part
    // We'll store dragPos inside dragging for rendering
    dragging.dragPos = { x: pos.x - dragging.offsetX + 0, y: pos.y - dragging.offsetY + 0 };
  });

  window.addEventListener('mouseup', (ev) => {
    if (!dragging) return;
    const pos = toCanvasCoord(ev.clientX, ev.clientY);
    const slotIndex = hitTestSlot(pos.x, pos.y);
    const originalIndex = dragging.partIndex;
    // Because parts array might have shifted due to clicks, we find target part by ID if possible
    const draggedId = parts[originalIndex] ? parts[originalIndex].id : null;
    const actualIndex = parts.findIndex(p => p.id === draggedId);
    if (slotIndex >= 0 && actualIndex >= 0) {
      // place into slot
      // remove from parts and place into slots
      slots[slotIndex] = { ...parts[actualIndex] };
      parts.splice(actualIndex, 1);
      selectedPartIndex = Math.max(0, Math.min(parts.length - 1, actualIndex));
      playClick();
      message = 'Placed a part into slot ' + (slotIndex + 1) + '.';
      // auto-check if full
      if (slots.every(s => s !== null)) {
        const ok = checkSlots();
        if (ok) {
          setTimeout(() => {
            if (level >= TOTAL_LEVELS) {
              finished = true;
              message = 'You repaired all machines! You WIN! Press R to play again.';
            } else {
              startLevel(level + 1);
            }
          }, 900);
        } else {
          setTimeout(() => {
            const returned = slots.map(s => s && { value: s.value, wobble: Math.random() * Math.PI * 2, id: Math.random().toString(36).slice(2) }).filter(Boolean);
            parts = parts.concat(returned);
            slots = new Array(SLOT_COUNT).fill(null);
          }, 700);
        }
      }
    } else {
      // not dropped on slot: just cancel drag
      message = 'Dropped the part. Click or press SPACE on a part to place it into the next slot.';
    }
    dragging = null;
  });

  // Touch support
  canvas.addEventListener('touchstart', (ev) => {
    ev.preventDefault();
    canvas.focus();
    initAudioOnGesture();
    const touch = ev.changedTouches[0];
    const pos = toCanvasCoord(touch.clientX, touch.clientY);
    const pi = hitTestPart(pos.x, pos.y);
    if (pi >= 0) {
      dragging = {
        partIndex: pi,
        offsetX: 0,
        offsetY: 0
      };
      selectedPartIndex = pi;
      playClick();
    } else {
      handleUIClick(pos.x, pos.y);
    }
  }, { passive: false });

  canvas.addEventListener('touchmove', (ev) => {
    ev.preventDefault();
    if (!dragging) return;
    const touch = ev.changedTouches[0];
    const pos = toCanvasCoord(touch.clientX, touch.clientY);
    dragging.dragPos = { x: pos.x - dragging.offsetX, y: pos.y - dragging.offsetY };
  }, { passive: false });

  canvas.addEventListener('touchend', (ev) => {
    ev.preventDefault();
    if (!dragging) return;
    const touch = ev.changedTouches[0];
    const pos = toCanvasCoord(touch.clientX, touch.clientY);
    const slotIndex = hitTestSlot(pos.x, pos.y);
    const originalIndex = dragging.partIndex;
    const draggedId = parts[originalIndex] ? parts[originalIndex].id : null;
    const actualIndex = parts.findIndex(p => p.id === draggedId);
    if (slotIndex >= 0 && actualIndex >= 0) {
      slots[slotIndex] = { ...parts[actualIndex] };
      parts.splice(actualIndex, 1);
      playClick();
      message = 'Placed a part into slot ' + (slotIndex + 1) + '.';
      if (slots.every(s => s !== null)) {
        const ok = checkSlots();
        if (ok) {
          setTimeout(() => {
            if (level >= TOTAL_LEVELS) {
              finished = true;
              message = 'You repaired all machines! You WIN! Press R to play again.';
            } else {
              startLevel(level + 1);
            }
          }, 900);
        } else {
          setTimeout(() => {
            const returned = slots.map(s => s && { value: s.value, wobble: Math.random() * Math.PI * 2, id: Math.random().toString(36).slice(2) }).filter(Boolean);
            parts = parts.concat(returned);
            slots = new Array(SLOT_COUNT).fill(null);
          }, 700);
        }
      }
    } else {
      message = 'Dropped the part.';
    }
    dragging = null;
  }, { passive: false });

  // Keyboard controls
  canvas.addEventListener('keydown', (ev) => {
    initAudioOnGesture();
    if (ev.key === 'ArrowRight') {
      selectedPartIndex = Math.min(parts.length - 1, selectedPartIndex + 1);
      playClick();
      ev.preventDefault();
    } else if (ev.key === 'ArrowLeft') {
      selectedPartIndex = Math.max(0, selectedPartIndex - 1);
      playClick();
      ev.preventDefault();
    } else if (ev.key === ' ' || ev.key === 'Enter') {
      // Place selected part into next slot, or check if Enter used for checking when all slots filled
      if (ev.key === 'Enter' && slots.every(s => s !== null)) {
        // Check slots
        const ok = checkSlots();
        if (ok) {
          setTimeout(() => {
            if (level >= TOTAL_LEVELS) {
              finished = true;
              message = 'You repaired all machines! You WIN! Press R to play again.';
            } else {
              startLevel(level + 1);
            }
          }, 900);
        } else {
          setTimeout(() => {
            const returned = slots.map(s => s && { value: s.value, wobble: Math.random() * Math.PI * 2, id: Math.random().toString(36).slice(2) }).filter(Boolean);
            parts = parts.concat(returned);
            slots = new Array(SLOT_COUNT).fill(null);
          }, 700);
        }
      } else {
        // place
        if (parts[selectedPartIndex]) {
          placePartToSlot(selectedPartIndex);
        } else {
          message = 'No part selected.';
        }
      }
      ev.preventDefault();
    } else if (ev.key === 'Backspace' || ev.key === 'Delete') {
      // remove last filled slot
      const lastFilled = slots.map((s, i) => s ? i : -1).filter(i => i >= 0).pop();
      if (lastFilled !== undefined && lastFilled >= 0) {
        removeSlot(lastFilled);
      } else {
        message = 'No parts to remove.';
      }
      ev.preventDefault();
    } else if (ev.key.toLowerCase() === 'r') {
      restartGame();
      ev.preventDefault();
    } else if (ev.key.toLowerCase() === 'm') {
      // toggle background
      setBackgroundOn(!backgroundOn);
      playClick();
      ev.preventDefault();
    } else if (ev.key === 'Tab') {
      // cycle selection
      selectedPartIndex = (selectedPartIndex + 1) % Math.max(1, parts.length);
      ev.preventDefault();
    }
  });

  // Clicking UI controls like audio toggle area
  function handleUIClick(x, y) {
    // audio toggle is top-right small box
    const audioBox = { x: WIDTH - 72, y: 12, w: 60, h: 28 };
    if (x >= audioBox.x && x <= audioBox.x + audioBox.w && y >= audioBox.y && y <= audioBox.y + audioBox.h) {
      // Toggle audio: if audio not yet created, create it (user gesture)
      initAudioOnGesture();
      if (!audioCtx) {
        message = 'Audio unavailable in this browser.';
        return;
      }
      // If background oscillator hasn't started or audioAllowed false, set on
      if (!audioAllowed) {
        audioAllowed = true;
      }
      setBackgroundOn(!backgroundOn);
      playClick();
      return;
    }
    // Next/Restart area near bottom right
    const actionBox = { x: WIDTH - 140, y: HEIGHT - 62, w: 120, h: 44 };
    if (x >= actionBox.x && x <= actionBox.x + actionBox.w && y >= actionBox.y && y <= actionBox.y + actionBox.h) {
      if (finished) {
        restartGame();
      } else {
        // If current round is complete (all slots filled and correct) progress; else check
        if (slots.every(s => s !== null) && slots.reduce((a, b) => a + b.value, 0) === targetSum) {
          if (level >= TOTAL_LEVELS) {
            finished = true;
            message = 'You repaired all machines! You WIN! Press R to play again.';
          } else {
            startLevel(level + 1);
          }
        } else {
          const ok = checkSlots();
          if (ok) {
            if (level >= TOTAL_LEVELS) {
              finished = true;
              message = 'You repaired all machines! You WIN! Press R to play again.';
            } else {
              startLevel(level + 1);
            }
          } else {
            // return parts
            setTimeout(() => {
              const returned = slots.map(s => s && { value: s.value, wobble: Math.random() * Math.PI * 2, id: Math.random().toString(36).slice(2) }).filter(Boolean);
              parts = parts.concat(returned);
              slots = new Array(SLOT_COUNT).fill(null);
            }, 700);
          }
        }
      }
      playClick();
      return;
    }
    // If clicked on a slot, remove it
    const slotIndex = hitTestSlot(x, y);
    if (slotIndex >= 0 && slots[slotIndex]) {
      removeSlot(slotIndex);
      return;
    }
  }

  // ------------------------------
  // Rendering functions
  // ------------------------------
  function drawRoundedRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  function drawScene() {
    // background
    ctx.fillStyle = palette.bg;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // top panel with title
    ctx.fillStyle = palette.panel;
    drawRoundedRect(12, 12, WIDTH - 24, 68, 12);
    ctx.fillStyle = palette.text;
    ctx.font = '20px system-ui, Arial';
    ctx.textBaseline = 'middle';
    ctx.fillText('Machine Match • Fix the Wacky Machine', 28, 40);
    ctx.font = '13px system-ui, Arial';
    ctx.fillStyle = '#536b69';
    ctx.fillText('Place parts so their numbers add to the target. Use mouse/touch or keyboard.', 28, 58);

    // audio toggle button (visual cue)
    const audioBox = { x: WIDTH - 72, y: 12, w: 60, h: 28 };
    ctx.fillStyle = audioAllowed ? (backgroundOn ? palette.accent : '#a7d3d2') : '#dfecec';
    drawRoundedRect(audioBox.x, audioBox.y, audioBox.w, audioBox.h, 8);
    ctx.fillStyle = palette.text;
    ctx.font = '12px system-ui, Arial';
    ctx.fillText(backgroundOn ? 'Sound: ON' : 'Sound: Off', audioBox.x + 8, audioBox.y + 17);

    // left panel with whimsical machine illustration
    const panelX = 24;
    const panelY = 96;
    const panelW = WIDTH - 48;
    const panelH = 280;
    ctx.fillStyle = palette.panel;
    drawRoundedRect(panelX, panelY, panelW, panelH, 14);

    // Draw wacky machine elements: big gear, pipes, screen
    drawMachine(panelX + 16, panelY + 20, panelW - 32, panelH - 40);

    // Draw slots (machine input slots) above conveyor
    drawSlots();

    // Draw conveyor with parts
    drawConveyor();

    // Draw UI box bottom-right (Next/Check or Restart)
    drawActionBox();

    // Draw info overlay with target, level, message
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.font = '16px system-ui, Arial';
    ctx.fillStyle = palette.text;
    ctx.fillText('Level ' + level + ' / ' + TOTAL_LEVELS + '   Target: ' + targetSum, 28, HEIGHT - 36);
    ctx.font = '13px system-ui, Arial';
    ctx.fillStyle = '#395b59';
    ctx.fillText(message, 28, HEIGHT - 18);

    // subtle success flash
    if (successFlash > 0) {
      ctx.fillStyle = 'rgba(120,220,180,' + (successFlash / 60) + ')';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      successFlash--;
    }

    // draw keyboard help
    ctx.font = '11px system-ui, Arial';
    ctx.fillStyle = '#567574';
    ctx.fillText('Keys: ← → select part • Space/Enter place • Delete remove • M toggle sound • R restart', WIDTH - 520, HEIGHT - 6);

    // Visual indicator showing whether audio exists (for accessibility)
    ctx.font = '11px system-ui, Arial';
    ctx.fillStyle = '#3c6a65';
    ctx.fillText('Audio: ' + (audioCtx ? 'Available' : 'Unavailable until you click'), WIDTH - 200, 30);
  }

  function drawMachine(x, y, w, h) {
    // panel background inside machine
    ctx.save();
    ctx.translate(x, y);
    // backdrop
    ctx.fillStyle = '#f8fffe';
    drawRoundedRect(0, 0, w, h, 12);

    // big gear (left)
    drawGear(72, 90, 60, 14, palette.gear, '#d0f0ee');

    // small gear (upper right)
    drawGear(w - 96, 60, 30, 8, palette.accent2, '#ffd9b3');

    // silly machine screen (center)
    ctx.fillStyle = '#164a46';
    drawRoundedRect(150, 22, w - 320, 84, 10);
    ctx.fillStyle = '#bfe6e2';
    ctx.font = '20px system-ui, Arial';
    ctx.fillText('Machine Monitor', 170, 46);
    ctx.font = '28px system-ui, Arial';
    ctx.fillStyle = '#08322f';
    ctx.fillText('Target: ' + targetSum, 170, 76);

    // connecting pipes
    ctx.strokeStyle = '#cfe8e4';
    ctx.lineWidth = 12;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(68, 150);
    ctx.lineTo(68, 200);
    ctx.lineTo(220, 200);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(w - 60, 120);
    ctx.quadraticCurveTo(w - 180, 180, w - 220, 230);
    ctx.stroke();

    // friendly face on one gear
    ctx.fillStyle = '#08322f';
    // eyes
    ctx.beginPath();
    ctx.arc(72, 90, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(92, 90, 6, 0, Math.PI * 2);
    ctx.fill();
    // smile
    ctx.beginPath();
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#08322f';
    ctx.arc(82, 100, 10, 0, Math.PI, false);
    ctx.stroke();

    ctx.restore();
  }

  function drawGear(cx, cy, radius, teeth, color, innerColor) {
    ctx.save();
    ctx.translate(cx, cy);
    // gear body
    ctx.fillStyle = color;
    ctx.beginPath();
    for (let i = 0; i < 40; i++) {
      const theta = (i / 40) * Math.PI * 2;
      const r = radius + (i % 4 === 0 ? 8 : 0);
      const x = Math.cos(theta) * r;
      const y = Math.sin(theta) * r;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fill();
    // inner circle
    ctx.fillStyle = innerColor;
    ctx.beginPath();
    ctx.arc(0, 0, radius * 0.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawSlots() {
    const slotY = 200;
    const slotWidth = 84;
    const slotHeight = 68;
    const slotSpacing = 112;
    const startX = (WIDTH - ((SLOT_COUNT - 1) * slotSpacing + slotWidth)) / 2;
    // label
    ctx.font = '14px system-ui, Arial';
    ctx.fillStyle = '#2a5a57';
    ctx.fillText('Machine Input Slots', startX, slotY - 22);

    for (let i = 0; i < SLOT_COUNT; i++) {
      const sx = startX + i * slotSpacing;
      // slot background
      ctx.fillStyle = slots[i] ? palette.accent : palette.slotBg;
      drawRoundedRect(sx, slotY, slotWidth, slotHeight, 10);
      // slot number
      ctx.fillStyle = '#06403d';
      ctx.font = '14px system-ui, Arial';
      ctx.fillText('Slot ' + (i + 1), sx + 10, slotY + 20);
      // display value if present
      if (slots[i]) {
        ctx.fillStyle = '#08322f';
        ctx.font = '28px system-ui, Arial';
        ctx.fillText(slots[i].value, sx + slotWidth / 2 - 8, slotY + slotHeight / 2 + 10);
        // small remove hint
        ctx.font = '11px system-ui, Arial';
        ctx.fillStyle = '#144a47';
        ctx.fillText('Click to remove', sx + 8, slotY + slotHeight - 8);
      } else {
        ctx.font = '12px system-ui, Arial';
        ctx.fillStyle = '#2b6b68';
        ctx.fillText('Empty', sx + 10, slotY + 40);
      }
    }
  }

  function drawConveyor() {
    // conveyor belt
    const convY = 360;
    ctx.fillStyle = '#e6f6f4';
    drawRoundedRect(40, convY - 36, WIDTH - 80, 80, 18);

    // draw a subtle moving texture
    ctx.save();
    ctx.globalAlpha = 0.08;
    ctx.fillStyle = '#9ad4cf';
    for (let i = 0; i < 12; i++) {
      ctx.beginPath();
      ctx.arc(80 + i * 60 + (conveyorOffset / 6) % 60, convY, 24, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();

    // draw parts moving on conveyor
    const spacing = 92;
    const startX = 100;
    for (let i = 0; i < parts.length; i++) {
      const p = parts[i];
      p.wobble += 0.005; // gentle motion
      const px = startX + i * spacing - (conveyorOffset % (spacing * parts.length));
      const py = convY + Math.sin(p.wobble + Date.now() / 800) * 6;
      const isSelected = i === selectedPartIndex;
      // if dragging and this is dragged part, skip drawing here (draw later)
      if (dragging && dragging.partIndex === i) {
        // skip here
        continue;
      }
      drawPart(px, py, p, isSelected);
    }

    // if dragging, draw the dragged part under cursor
    if (dragging && dragging.dragPos) {
      const originalIndex = dragging.partIndex;
      const draggedId = parts[originalIndex] ? parts[originalIndex].id : null;
      const actualIndex = parts.findIndex(p => p.id === draggedId);
      if (actualIndex >= 0) {
        const p = parts[actualIndex];
        drawPart(dragging.dragPos.x, dragging.dragPos.y, p, true, true);
      }
    }

    // subtle label
    ctx.fillStyle = '#2a5a57';
    ctx.font = '13px system-ui, Arial';
    ctx.fillText('Conveyor: Click or drag a part to the machine slots.', 44, convY - 44);
  }

  function drawPart(x, y, part, highlighted = false, translucent = false) {
    ctx.save();
    ctx.translate(x, y);
    // shadow
    ctx.fillStyle = 'rgba(20, 30, 28, 0.08)';
    ctx.beginPath();
    ctx.ellipse(0, 28, 38, 12, 0, 0, Math.PI * 2);
    ctx.fill();

    // body
    ctx.globalAlpha = translucent ? 0.9 : 1.0;
    ctx.fillStyle = palette.part;
    drawRoundedRect(-36, -20, 72, 48, 10);
    // bolts and shapes
    ctx.fillStyle = '#caa86d';
    ctx.beginPath();
    ctx.arc(-18, -6, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(18, -6, 6, 0, Math.PI * 2);
    ctx.fill();
    // number
    ctx.fillStyle = '#08322f';
    ctx.font = highlighted ? '24px system-ui, Arial' : '20px system-ui, Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(part.value, 0, 6);
    // small wobble lines for wacky feeling
    ctx.strokeStyle = 'rgba(4,95,90,0.06)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-30, 12);
    ctx.quadraticCurveTo(0, 22, 30, 12);
    ctx.stroke();
    // selection glow
    if (highlighted) {
      ctx.strokeStyle = palette.accent;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.rect(-38, -22, 76, 52);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawActionBox() {
    const boxW = 120;
    const boxH = 44;
    const boxX = WIDTH - 140;
    const boxY = HEIGHT - 62;
    ctx.fillStyle = palette.accent;
    drawRoundedRect(boxX, boxY, boxW, boxH, 10);
    ctx.fillStyle = '#042d2a';
    ctx.font = '16px system-ui, Arial';
    ctx.fillText(finished ? 'Restart' : 'Check/Next', boxX + 12, boxY + boxH / 2 + 6);
  }

  // ------------------------------
  // Animation loop
  // ------------------------------
  function step() {
    // update conveyor offset
    conveyorOffset += 0.5 + Math.sin(Date.now() / 1200) * 0.3;
    drawScene();
    animationId = requestAnimationFrame(step);
  }

  // ------------------------------
  // Boot sequence
  // ------------------------------
  // Create audio context after a user gesture; but create attempt now too (may be blocked)
  safeCreateAudioContext();

  // Start first level
  startLevel(1);
  // Kick off animation
  step();

  // Start background engine only after user toggles sound or interacts (gesture)
  // We'll show instructions to press M to toggle sound. But also ensure clicking canvas initializes audio.

  // Expose minimal controls for accessibility: focusing canvas and pressing keys works
  // Also, listen for window blur/unload to stop audio
  window.addEventListener('blur', () => {
    // gently stop background when leaving
    if (audioCtx && backgroundGain) {
      try {
        backgroundGain.gain.cancelScheduledValues(audioCtx.currentTime);
        backgroundGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.4);
      } catch (e) {
        // ignore
      }
    }
  });

  window.addEventListener('beforeunload', () => {
    if (audioCtx) {
      try {
        audioCtx.close();
      } catch (e) {}
    }
  });

  // Final note: ensure that if audio context becomes available later we can start background with M or clicking audio toggle
  // That is already handled by initAudioOnGesture() calls in input handlers.

})();
---

