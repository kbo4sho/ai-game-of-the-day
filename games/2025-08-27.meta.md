# Game of the Day - 2025-08-27

## Metadata
- **Generated Date:** 2025-08-27
- **Generated Time:** 2025-08-27T00:27:24.283018
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-27.js
- **File Size:** 27842 bytes
- **Tokens Used:** 9804

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-27.js` - The playable game
- `2025-08-27.meta.json` - Machine-readable metadata
- `2025-08-27.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 20331

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 22815

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function() {
  // Electricity Math Game for ages 7-9
  // Renders into element with id "game-of-the-day-stage"
  // All visuals drawn on a canvas sized 720x480
  // Sounds generated with Web Audio API (oscillators & filters)
  // Accessible: keyboard controls, aria-live text, visual cues, instructions

  // -----------------------
  // Setup DOM and Canvas
  // -----------------------
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Game container element with id "game-of-the-day-stage" not found.');
    return;
  }

  // Clear container and prepare
  container.innerHTML = '';
  container.style.position = 'relative';
  container.setAttribute('role', 'application');
  container.setAttribute('aria-label', 'Electricity math game for children. Use number keys 1-3 to choose answers.');

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = 720;
  canvas.height = 480;
  canvas.style.width = '720px';
  canvas.style.height = '480px';
  canvas.setAttribute('role', 'img');
  canvas.setAttribute('aria-label', 'Interactive canvas showing the electricity game.');
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Hidden live region for screen readers
  const live = document.createElement('div');
  live.setAttribute('aria-live', 'polite');
  live.style.position = 'absolute';
  live.style.left = '-9999px';
  live.style.width = '1px';
  live.style.height = '1px';
  live.style.overflow = 'hidden';
  container.appendChild(live);

  // For instructions visible on canvas but also as text for screen readers
  function announce(text) {
    try {
      live.textContent = text;
    } catch (e) {
      // ignore
    }
  }

  // -----------------------
  // Audio setup & helpers
  // -----------------------
  let audioEnabled = false;
  let audioContext = null;
  let bgGain = null;
  let bgOsc = null;
  let bgRunning = false;

  function tryCreateAudioContext() {
    if (audioContext) return audioContext;
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) throw new Error('Web Audio API not supported');
      audioContext = new AC();
      audioEnabled = true;
    } catch (err) {
      console.warn('Audio context creation failed or not allowed yet:', err);
      audioContext = null;
      audioEnabled = false;
    }
    return audioContext;
  }

  // Create/enable audio on user gesture if it wasn't allowed initially
  function ensureAudioOnUserGesture() {
    if (audioContext) return true;
    try {
      tryCreateAudioContext();
      if (!audioContext) {
        // Try to resume on gesture
        const AC = window.AudioContext || window.webkitAudioContext;
        if (AC) {
          audioContext = new AC();
          audioEnabled = true;
        }
      }
    } catch (e) {
      console.warn('Could not enable audio on gesture:', e);
      audioEnabled = false;
    }
    return audioEnabled;
  }

  // Play a tone with envelope. type: 'sine','square','sawtooth','triangle'
  function playTone(frequency = 440, duration = 0.3, type = 'sine', volume = 0.08) {
    if (!audioContext) return;
    try {
      const now = audioContext.currentTime;
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      osc.type = type;
      osc.frequency.value = frequency;
      gain.gain.value = 0.0001;
      osc.connect(gain);
      // gentle character with a filter
      const filter = audioContext.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = Math.max(600, frequency * 2);
      gain.connect(filter);
      filter.connect(audioContext.destination);

      // Envelope
      gain.gain.cancelScheduledValues(now);
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(volume, now + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);

      osc.start(now);
      osc.stop(now + duration + 0.05);

      // cleanup
      osc.onended = () => {
        try {
          osc.disconnect();
          gain.disconnect();
          filter.disconnect();
        } catch (e) {}
      };
    } catch (e) {
      console.warn('Error playing tone:', e);
    }
  }

  function playCorrectSound() {
    if (!ensureAudioOnUserGesture()) return;
    // small cheerful arpeggio
    playTone(880, 0.12, 'sine', 0.06);
    setTimeout(() => playTone(1100, 0.15, 'triangle', 0.06), 120);
    setTimeout(() => playTone(1320, 0.22, 'sine', 0.06), 260);
  }

  function playIncorrectSound() {
    if (!ensureAudioOnUserGesture()) return;
    // low buzz and quick thud
    playTone(120, 0.25, 'sawtooth', 0.08);
    setTimeout(() => playTone(80, 0.18, 'sine', 0.06), 200);
  }

  function startBackgroundHum() {
    if (!ensureAudioOnUserGesture()) return;
    if (!audioContext || bgRunning) return;
    try {
      bgOsc = audioContext.createOscillator();
      const lfo = audioContext.createOscillator();
      const lfoGain = audioContext.createGain();
      bgGain = audioContext.createGain();

      bgOsc.type = 'sine';
      bgOsc.frequency.value = 80; // low hum
      bgGain.gain.value = 0.02;

      lfo.type = 'sine';
      lfo.frequency.value = 0.12; // gentle wobble
      lfoGain.gain.value = 0.015;

      lfo.connect(lfoGain);
      lfoGain.connect(bgGain.gain);
      bgOsc.connect(bgGain);
      bgGain.connect(audioContext.destination);

      bgOsc.start();
      lfo.start();
      bgRunning = true;
    } catch (e) {
      console.warn('Background hum failed:', e);
      bgRunning = false;
    }
  }

  function stopBackgroundHum() {
    if (!bgRunning || !audioContext) return;
    try {
      if (bgOsc) {
        bgOsc.stop();
        bgOsc.disconnect();
      }
      bgOsc = null;
      bgRunning = false;
    } catch (e) {
      // ignore
    }
  }

  // -----------------------
  // Game Variables & State
  // -----------------------
  const GAME_W = canvas.width;
  const GAME_H = canvas.height;

  let running = true;
  let lastTime = performance.now();

  // Characters
  const characters = {
    drVolt: { x: 120, y: 120 },
    sparky: { x: 600, y: 120 }
  };

  // Game progression
  let score = 0;
  let lives = 3;
  let round = 0;
  let currentQuestion = null;
  let choices = [];
  let chosenIndex = -1;
  let feedbackTimer = 0;
  let feedbackState = null; // 'correct'|'incorrect'|null
  let roundsToLevelUp = 5;
  let difficulty = 1;

  // Animation elements
  const sparks = []; // active spark animations
  const floatingElectrons = []; // ambient floating dots

  // Visual settings for accessibility
  const highContrast = false;

  // Create ambient floating electrons
  for (let i = 0; i < 14; i++) {
    floatingElectrons.push({
      x: Math.random() * GAME_W,
      y: Math.random() * GAME_H,
      r: 3 + Math.random() * 5,
      vx: -0.3 + Math.random() * 0.6,
      vy: -0.2 + Math.random() * 0.4,
      hue: 180 + Math.random() * 80
    });
  }

  // -----------------------
  // Math Question Generator
  // -----------------------
  function newQuestion() {
    round++;
    if ((round - 1) % roundsToLevelUp === 0 && round > 1) {
      difficulty++;
    }
    // Determine problem type: addition or subtraction
    const add = Math.random() < 0.6;
    let a, b, correct;
    if (difficulty === 1) {
      a = Math.floor(Math.random() * 10) + 1; // 1-10
      b = Math.floor(Math.random() * 10) + 1;
    } else if (difficulty === 2) {
      a = Math.floor(Math.random() * 20) + 1; // 1-20
      b = Math.floor(Math.random() * 20) + 1;
    } else {
      a = Math.floor(Math.random() * 40) + 1; // 1-40
      b = Math.floor(Math.random() * 40) + 1;
    }

    if (add) {
      correct = a + b;
      currentQuestion = { left: a, right: b, op: '+', correct };
    } else {
      // ensure non-negative
      if (a < b) [a, b] = [b, a];
      correct = a - b;
      currentQuestion = { left: a, right: b, op: '-', correct };
    }

    // Create 3 choices: one correct, two distractors
    const distractors = new Set();
    while (distractors.size < 2) {
      let delta = Math.floor(Math.random() * Math.max(3, Math.ceil(correct * 0.3 + 1))) + 1;
      if (Math.random() < 0.5) delta = -delta;
      const val = Math.max(0, correct + delta);
      if (val !== correct) distractors.add(val);
    }
    choices = [currentQuestion.correct, ...Array.from(distractors)];
    // Shuffle
    for (let i = choices.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [choices[i], choices[j]] = [choices[j], choices[i]];
    }
    chosenIndex = -1;
    feedbackState = null;
    feedbackTimer = 0;
    announce(`New question: ${currentQuestion.left} ${currentQuestion.op} ${currentQuestion.right}. Choose 1, 2, or 3.`);
  }

  // -----------------------
  // Interaction Handling
  // -----------------------
  function handleChoice(index) {
    if (!currentQuestion) return;
    if (feedbackState) return; // wait until feedback finishes
    chosenIndex = index;
    const value = choices[index];
    if (value === currentQuestion.correct) {
      // correct
      score += 10 * difficulty;
      playCorrectSound();
      feedbackState = 'correct';
      feedbackTimer = 0;
      // create spark animation from battery to bulb
      sparks.push({
        x: 120,
        y: 220,
        tx: 540,
        ty: 220 + index * 90,
        t: 0,
        color: 'gold'
      });
      announce('Correct! The lamp lights up.');
      // small particle burst
      for (let i = 0; i < 6; i++) {
        sparks.push({
          x: 540,
          y: 220 + index * 90,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.8) * 4,
          life: 0.6 + Math.random() * 0.6,
          color: 'rgba(255,220,120,0.9)'
        });
      }
      // prepare next question after a short delay
      setTimeout(() => {
        newQuestion();
      }, 1000);
    } else {
      // incorrect
      lives = Math.max(0, lives - 1);
      playIncorrectSound();
      feedbackState = 'incorrect';
      feedbackTimer = 0;
      announce('Oops, that was not right. Try the next one.');
      // fizzle sparks
      for (let i = 0; i < 5; i++) {
        sparks.push({
          x: 540,
          y: 220 + index * 90,
          vx: (Math.random() - 0.5) * 3,
          vy: (Math.random() - 0.5) * 3,
          life: 0.5 + Math.random() * 0.4,
          color: 'rgba(200,80,80,0.9)'
        });
      }
      // if no lives left, end game
      if (lives <= 0) {
        setTimeout(() => {
          endGame();
        }, 700);
      } else {
        // continue with new question
        setTimeout(() => {
          newQuestion();
        }, 900);
      }
    }
  }

  // Mouse / touch handling
  canvas.addEventListener('click', function(evt) {
    const rect = canvas.getBoundingClientRect();
    const x = (evt.clientX - rect.left) * (canvas.width / rect.width);
    const y = (evt.clientY - rect.top) * (canvas.height / rect.height);
    // If clicked on speaker icon
    if (x >= 650 && x <= 692 && y >= 10 && y <= 52) {
      audioEnabled = !audioEnabled;
      if (audioEnabled) {
        ensureAudioOnUserGesture();
        startBackgroundHum();
        announce('Sound enabled');
      } else {
        stopBackgroundHum();
        announce('Sound muted');
      }
      return;
    }

    // Bulbs area on right side at positions 220 + index * 90
    for (let i = 0; i < 3; i++) {
      const bx = 520;
      const by = 220 + i * 90;
      const br = 40;
      if ((x - bx) * (x - bx) + (y - by) * (y - by) <= br * br) {
        handleChoice(i);
        return;
      }
    }
    // Click on battery area to enable audio if needed
    if (!audioContext) {
      ensureAudioOnUserGesture();
      if (audioEnabled) {
        startBackgroundHum();
      }
    }
  });

  // Keyboard controls
  window.addEventListener('keydown', (e) => {
    if (e.repeat) return;
    // Allow number keys 1,2,3 or keys Q,W,E for left-handed
    if (e.key === '1' || e.key === 'q' || e.key === 'Q') {
      handleChoice(0);
      e.preventDefault();
    } else if (e.key === '2' || e.key === 'w' || e.key === 'W') {
      handleChoice(1);
      e.preventDefault();
    } else if (e.key === '3' || e.key === 'e' || e.key === 'E') {
      handleChoice(2);
      e.preventDefault();
    } else if (e.key === 'm' || e.key === 'M') {
      audioEnabled = !audioEnabled;
      if (audioEnabled) {
        ensureAudioOnUserGesture();
        startBackgroundHum();
        announce('Sound enabled');
      } else {
        stopBackgroundHum();
        announce('Sound muted');
      }
    } else if (e.key === 'Enter') {
      if (!currentQuestion) {
        startGame();
      } else if (!feedbackState) {
        // If no feedback, do nothing
      }
    }
  });

  // -----------------------
  // Drawing Functions
  // -----------------------
  function drawBackground() {
    // soft gradient sky
    const g = ctx.createLinearGradient(0, 0, 0, GAME_H);
    g.addColorStop(0, '#eaf7ff');
    g.addColorStop(1, '#f7fbff');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, GAME_W, GAME_H);

    // wacky hills
    drawWavyHills();
    // floating electrons
    for (const e of floatingElectrons) {
      ctx.beginPath();
      ctx.fillStyle = `hsla(${e.hue},70%,60%,0.18)`;
      ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawWavyHills() {
    // simple wavy shapes for interest
    ctx.save();
    ctx.globalAlpha = 0.7;
    ctx.fillStyle = '#dff6e3';
    ctx.beginPath();
    ctx.moveTo(0, 360);
    ctx.quadraticCurveTo(180, 320, 360, 360);
    ctx.quadraticCurveTo(540, 400, 720, 360);
    ctx.lineTo(720, 480);
    ctx.lineTo(0, 480);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = '#fff7e6';
    ctx.beginPath();
    ctx.moveTo(0, 420);
    ctx.quadraticCurveTo(240, 380, 480, 420);
    ctx.quadraticCurveTo(600, 440, 720, 420);
    ctx.lineTo(720, 480);
    ctx.lineTo(0, 480);
    ctx.closePath();
    ctx.globalAlpha = 0.6;
    ctx.fill();

    ctx.restore();
  }

  function drawCharacters() {
    // Dr. Volt (battery scientist)
    const x = characters.drVolt.x;
    const y = characters.drVolt.y;
    ctx.save();
    ctx.translate(x, y);
    // body (battery)
    ctx.fillStyle = '#ffe680';
    ctx.strokeStyle = '#b38b00';
    ctx.lineWidth = 3;
    roundRect(ctx, -50, -30, 100, 120, 12, true, true);
    // terminals
    ctx.fillStyle = '#ffd27a';
    ctx.fillRect(-14, -36, 28, 8);
    // eyes and smile
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.arc(-18, 10, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(18, 10, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-22, 28);
    ctx.quadraticCurveTo(0, 40, 22, 28);
    ctx.stroke();
    // lab goggles
    ctx.strokeStyle = '#5ec8ff';
    ctx.lineWidth = 3;
    ctx.strokeRect(-34, -4, 68, 18);
    ctx.restore();

    // Sparky (lamp)
    const sx = characters.sparky.x;
    const sy = characters.sparky.y;
    ctx.save();
    ctx.translate(sx, sy);
    // bulb
    ctx.beginPath();
    ctx.fillStyle = '#fff4b8';
    ctx.strokeStyle = '#f6c84a';
    ctx.lineWidth = 3;
    ctx.ellipse(0, 20, 36, 44, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // filament smiley
    ctx.strokeStyle = '#b36b00';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-10, 10);
    ctx.quadraticCurveTo(0, 22, 10, 10);
    ctx.stroke();

    // base
    ctx.fillStyle = '#b7c9d9';
    ctx.fillRect(-20, 60, 40, 18);
    ctx.restore();

    // small labels
    ctx.fillStyle = '#333';
    ctx.font = '14px Arial';
    ctx.fillText('Dr. Volt', 70, 70);
    ctx.fillText('Sparky', 560, 70);
  }

  function drawMachineAndChoices() {
    // left battery
    const bx = 120, by = 220;
    ctx.save();
    // battery box
    roundRect(ctx, bx - 60, by - 30, 120, 60, 8, true, true);
    ctx.fillStyle = '#fff';
    ctx.font = '18px Arial';
    ctx.fillStyle = '#333';
    ctx.fillText('Power Plant', bx - 50, by + 6);
    // little lightning icon
    ctx.fillStyle = '#ffd24d';
    ctx.beginPath();
    ctx.moveTo(bx + 40, by - 18);
    ctx.lineTo(bx + 26, by - 6);
    ctx.lineTo(bx + 34, by - 6);
    ctx.lineTo(bx + 18, by + 12);
    ctx.lineTo(bx + 32, by - 8);
    ctx.lineTo(bx + 24, by - 8);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // three wires to bulbs
    for (let i = 0; i < 3; i++) {
      const y = 220 + i * 90;
      drawCurvyWire(180, 220, 480, y, i);
    }

    // bulbs on right
    for (let i = 0; i < 3; i++) {
      const cx = 540, cy = 220 + i * 90;
      drawBulb(cx, cy, 40, choices[i], i);
    }

    // Show question panel
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    roundRect(ctx, 240, 30, 240, 90, 12, true, true);
    ctx.fillStyle = '#333';
    ctx.font = '22px Arial';
    if (currentQuestion) {
      ctx.fillText(`Q: ${currentQuestion.left} ${currentQuestion.op} ${currentQuestion.right} = ?`, 260, 62);
      ctx.font = '18px Arial';
      ctx.fillText('Pick the right lamp: 1, 2, or 3', 260, 90);
    } else {
      ctx.fillText('Press Enter to start', 270, 62);
      ctx.font = '16px Arial';
      ctx.fillText('Help Dr. Volt light the lamps by solving sums!', 260, 90);
    }
    ctx.restore();
  }

  function drawBulb(x, y, r, label, index) {
    ctx.save();
    // Outer glow if selected or correct/incorrect
    let lit = false;
    if (feedbackState === 'correct' && chosenIndex === index) lit = true;
    // Sphere
    ctx.beginPath();
    ctx.fillStyle = lit ? '#fff9c4' : '#f7f7f9';
    ctx.ellipse(x, y, r, r + 8, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.lineWidth = 3;
    ctx.strokeStyle = lit ? '#f6c84a' : '#d1d7df';
    ctx.stroke();

    // If it's the chosen index during incorrect feedback, show red ring
    if (feedbackState === 'incorrect' && chosenIndex === index) {
      ctx.strokeStyle = 'rgba(220,80,80,0.9)';
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.ellipse(x, y, r + 6, r + 14, 0, 0, Math.PI * 2);
      ctx.stroke();
    }

    // filaments
    ctx.strokeStyle = '#b36b00';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x - 8, y + 4);
    ctx.quadraticCurveTo(x, y - 8, x + 8, y + 4);
    ctx.stroke();

    // base
    ctx.fillStyle = '#b7c9d9';
    ctx.fillRect(x - 22, y + r + 6, 44, 16);

    // label
    ctx.fillStyle = '#222';
    ctx.font = '18px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(String(label), x, y + 4);

    // draw number index (1-3)
    ctx.font = '12px Arial';
    ctx.fillStyle = '#555';
    ctx.fillText(String(index + 1), x + r + 18, y + 4);

    ctx.restore();
  }

  function drawCurvyWire(sx, sy, tx, ty, i) {
    ctx.save();
    ctx.lineWidth = 8;
    const hue = 190 + i * 30;
    ctx.strokeStyle = `hsl(${hue},70%,45%)`;
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    const mx = (sx + tx) / 2 + (i - 1) * 30;
    const my = (sy + ty) / 2 + (i - 1) * 10;
    ctx.quadraticCurveTo(mx, my, tx - 40, ty);
    ctx.stroke();

    // little electrons traveling along wire as animated dots
    const t = (performance.now() / 800 + i * 0.4) % 1;
    const pos = pointOnQuadratic(sx, sy, mx, my, tx - 40, ty, t);
    ctx.beginPath();
    ctx.fillStyle = `hsla(${hue},80%,60%,0.95)`;
    ctx.arc(pos.x, pos.y, 6, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  function drawHUD() {
    // top-left panel for score and lives
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    roundRect(ctx, 10, 10, 200, 64, 10, true, true);
    ctx.fillStyle = '#333';
    ctx.font = '18px Arial';
    ctx.fillText(`Score: ${score}`, 24, 36);
    ctx.fillText(`Lives: ${lives}`, 24, 58);

    // speaker icon top-right (visual cue for audio)
    ctx.fillStyle = audioEnabled ? '#ffd24d' : '#d0d0d0';
    ctx.strokeStyle = '#333';
    roundRect(ctx, 650, 10, 42, 42, 8, true, true);
    ctx.fillStyle = '#333';
    // draw simplified speaker
    ctx.beginPath();
    ctx.moveTo(656, 22);
    ctx.lineTo(668, 22);
    ctx.lineTo(680, 14);
    ctx.lineTo(680, 42);
    ctx.lineTo(668, 34);
    ctx.lineTo(656, 34);
    ctx.closePath();
    ctx.fill();

    if (audioEnabled) {
      ctx.beginPath();
      ctx.strokeStyle = '#ffeb99';
      ctx.lineWidth = 2;
      ctx.arc(690, 30, 8, -0.8, 0.8);
      ctx.stroke();
    } else {
      ctx.beginPath();
      ctx.strokeStyle = '#777';
      ctx.lineWidth = 2;
      ctx.moveTo(682, 22);
      ctx.lineTo(698, 38);
      ctx.stroke();
    }
    ctx.restore();

    // bottom instruction footer
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    roundRect(ctx, 0, GAME_H - 52, GAME_W, 52, 0, true, false);
    ctx.fillStyle = '#333';
    ctx.font = '16px Arial';
    ctx.fillText('Use keys 1-3 or click a lamp. Press M to mute/unmute. Press Enter to start.', 18, GAME_H - 22);
    ctx.restore();
  }

  // Helpers: draw rounded rectangle
  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    if (typeof stroke === 'undefined') stroke = true;
    if (typeof r === 'undefined') r = 5;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // Compute point on quadratic Bezier given t
  function pointOnQuadratic(x0, y0, cx, cy, x1, y1, t) {
    const u = 1 - t;
    const x = u * u * x0 + 2 * u * t * cx + t * t * x1;
    const y = u * u * y0 + 2 * u * t * cy + t * t * y1;
    return { x, y };
  }

  // -----------------------
  // Spark/Particle Animation
  // -----------------------
  function updateSparks(dt) {
    // sparks can be travel sparks or particles with vx vy life
    for (let i = sparks.length - 1; i >= 0; i--) {
      const s = sparks[i];
      if (s.t !== undefined) {
        // travel spark
        s.t += dt * 0.9;
        if (s.t >= 1) {
          sparks.splice(i, 1);
        }
      } else if (s.life !== undefined) {
        s.life -= dt;
        s.x += (s.vx || 0) * 40 * dt;
        s.y += (s.vy || 0) * 40 * dt;
        if (s.life <= 0) sparks.splice(i, 1);
      } else {
        sparks.splice(i, 1);
      }
    }
  }

  function drawSparks() {
    for (const s of sparks) {
      if (s.t !== undefined) {
        const p = {
          x: s.x + (s.tx - s.x) * easeOutExpo(s.t),
          y: s.y + (s.ty - s.y) * easeOutExpo(s.t)
        };
        ctx.beginPath();
        ctx.fillStyle = s.color || 'gold';
        ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
        ctx.fill();
        // trail
        ctx.beginPath();
        ctx.fillStyle = 'rgba(255,255,200,0.3)';
        ctx.arc(p.x - 8, p.y - 2, 4, 0, Math.PI * 2);
        ctx.fill();
      } else if (s.life !== undefined) {
        const alpha = Math.max(0, s.life / 1.2);
        ctx.beginPath();
        ctx.fillStyle = withAlpha(s.color, alpha);
        ctx.arc(s.x, s.y, 5 + (1 - alpha) * 6, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  function withAlpha(color, a) {
    // naive parse for rgba or hex; if rgba return with new alpha; else wrap as rgba( r,g,b,a)
    if (color.startsWith('rgba')) {
      return color.replace(/rgba\(([^,]+),([^,]+),([^,]+),([^)]+)\)/, `rgba($1,$2,$3,${a})`);
    }
    // fallback: return color as is
    return color;
  }

  // -----------------------
  // Game Flow
  // -----------------------
  function startGame() {
    score = 0;
    lives = 3;
    round = 0;
    difficulty = 1;
    sparks.length = 0;
    newQuestion();
    announce('Game started. Solve the questions to light up the lamps!');
  }

  function endGame() {
    currentQuestion = null;
    choices = [];
    feedbackState = null;
    announce(`Game over. Your final score is ${score}. Press Enter to play again.`);
    // show big overlay; let drawing handle it
  }

  // -----------------------
  // Utility easing
  // -----------------------
  function easeOutExpo(t) {
    return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
  }

  // -----------------------
  // Main Loop: update & draw
  // -----------------------
  function update(dt) {
    // ambient electrons drift
    for (const e of floatingElectrons) {
      e.x += e.vx * dt * 40;
      e.y += e.vy * dt * 40;
      if (e.x < -10) e.x = GAME_W + 10;
      if (e.x > GAME_W + 10) e.x = -10;
      if (e.y < 40) e.y = GAME_H - 20;
      if (e.y > GAME_H - 20) e.y = 40;
    }

    // update sparks
    updateSparks(dt);

    // feedback timer
    if (feedbackState) {
      feedbackTimer += dt;
      if (feedbackTimer > 1.2) {
        feedbackState = null;
        feedbackTimer = 0;
      }
    }
  }

  function draw() {
    // clear
    ctx.clearRect(0, 0, GAME_W, GAME_H);
    drawBackground();

    // machine & bulbs
    drawMachineAndChoices();

    // draw sparks
    drawSparks();

    // draw characters & HUD on top
    drawCharacters();
    drawHUD();

    // overlay if no lives
    if (lives <= 0) {
      ctx.save();
      ctx.fillStyle = 'rgba(10,10,20,0.6)';
      ctx.fillRect(0, 0, GAME_W, GAME_H);
      ctx.fillStyle = '#fff';
      ctx.font = '36px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Oh no! The lights went out!', GAME_W / 2, GAME_H / 2 - 20);
      ctx.font = '22px Arial';
      ctx.fillText(`Score: ${score}`, GAME_W / 2, GAME_H / 2 + 14);
      ctx.font = '18px Arial';
      ctx.fillText('Press Enter to try again.', GAME_W / 2, GAME_H / 2 + 54);
      ctx.restore();
    }

    // help text for audio status
    if (!audioContext) {
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      roundRect(ctx, 200, 380, 320, 70, 12, true, true);
      ctx.fillStyle = '#333';
      ctx.font = '16px Arial';
      ctx.fillText('Sound is disabled by the browser. Click or press any key to enable sound.', 210, 412);
      ctx.font = '14px Arial';
      ctx.fillText('You can mute/unmute with M.', 210, 430);
      ctx.restore();
    }
  }

  function loop(now) {
    if (!running) return;
    const dt = Math.min(0.04, (now - lastTime) / 1000);
    lastTime = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // -----------------------
  // Start background and animation
  // -----------------------
  // Some browsers require user interaction to start audio. We attempt to create context,
  // but if it fails we'll enable when user clicks or presses keys.
  tryCreateAudioContext();

  // start background hum if audio allowed
  if (audioContext) {
    audioEnabled = true;
    startBackgroundHum();
  } else {
    audioEnabled = false;
  }

  // Kick off loop
  requestAnimationFrame(loop);

  // Provide initial instruction announce
  announce('Welcome! Press Enter to start the Electricity Math Game. Use keys 1-3 or click lamps to answer.');

  // If Enter pressed while at end of game, restart
  window.addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
      if (lives <= 0 || !currentQuestion) {
        startGame();
      }
    }
  });

  // Expose a small API on the container for testing/debugging (non-essential)
  container._electricGame = {
    start: startGame,
    stop: () => (running = false),
    setAudioEnabled: function(on) {
      audioEnabled = !!on;
      if (audioEnabled) {
        ensureAudioOnUserGesture();
        startBackgroundHum();
      } else {
        stopBackgroundHum();
      }
    }
  };

  // -----------------------
  // Error handling note for audio
  // -----------------------
  // Listen for unhandled audio exceptions to show user-friendly info
  window.addEventListener('unhandledrejection', (ev) => {
    console.warn('Unhandled rejection: ', ev.reason);
  });

  // -----------------------
  // End of game script
  // -----------------------
})();
---

