# Game of the Day - 2025-10-10

## Metadata
- **Generated Date:** 2025-10-10
- **Generated Time:** 2025-10-10T00:26:48.223367
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-10-10.js
- **File Size:** 29965 bytes
- **Tokens Used:** 9547

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-10-10.js` - The playable game
- `2025-10-10.meta.json` - Machine-readable metadata
- `2025-10-10.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 20227

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 21957

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function() {
  // Machine Merge - Math Game for ages 7-9
  // Renders into element with ID "game-of-the-day-stage"
  // Canvas is exactly 720x480
  // No external resources. All graphics via canvas. All sounds via Web Audio API oscillators/filters.
  // Accessible keyboard controls and visual/audio cues.

  // ======== Setup and Utilities ========
  const STAGE_ID = 'game-of-the-day-stage';
  const WIDTH = 720;
  const HEIGHT = 480;

  const container = document.getElementById(STAGE_ID);
  if (!container) {
    throw new Error(`Container element with ID "${STAGE_ID}" not found.`);
  }

  // Clear container and create canvas
  container.innerHTML = '';
  container.style.position = 'relative';
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.width = WIDTH + 'px';
  canvas.style.height = HEIGHT + 'px';
  canvas.tabIndex = 0; // focusable
  canvas.setAttribute('role', 'application');
  canvas.setAttribute('aria-label', 'Machine Merge math game. Use arrow keys to move, space to pick/drop parts, M to toggle audio, Escape to restart.');
  container.appendChild(canvas);

  const ctx = canvas.getContext('2d');

  // Utility random
  const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  // ======== Audio Setup ========
  let audioCtx = null;
  let audioEnabled = true;
  let backgroundGain = null;
  let backgroundOsc = null;
  let audioInitError = false;

  function initAudio() {
    if (audioCtx) return;
    try {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AudioContext();

      // Background hum
      backgroundOsc = audioCtx.createOscillator();
      const bgFilter = audioCtx.createBiquadFilter();
      backgroundGain = audioCtx.createGain();
      bgFilter.type = 'lowpass';
      bgFilter.frequency.value = 800;
      backgroundOsc.type = 'sine';
      backgroundOsc.frequency.value = 110; // low gentle tone
      backgroundGain.gain.value = 0.02; // very gentle
      backgroundOsc.connect(bgFilter);
      bgFilter.connect(backgroundGain);
      backgroundGain.connect(audioCtx.destination);
      backgroundOsc.start();
    } catch (e) {
      console.warn('Audio initialization failed:', e);
      audioInitError = true;
      audioEnabled = false;
      audioCtx = null;
    }
  }

  function resumeAudioOnInteraction() {
    if (!audioCtx) return;
    if (audioCtx.state === 'suspended') {
      audioCtx.resume().catch((e) => {
        console.warn('Audio resume failed:', e);
        audioEnabled = false;
      });
    }
  }

  function setAudioEnabled(enabled) {
    audioEnabled = enabled && !audioInitError;
    if (backgroundGain) backgroundGain.gain.value = audioEnabled ? 0.02 : 0;
  }

  // Short sound effects generated by oscillator
  function playTone({ freq = 440, type = 'sine', duration = 0.15, volume = 0.12, attack = 0.01, decay = 0.08, detune = 0 } = {}) {
    if (!audioEnabled || !audioCtx) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      o.type = type;
      o.frequency.value = freq;
      o.detune.value = detune;
      filter.type = 'lowpass';
      filter.frequency.value = Math.max(600, freq * 2);
      g.gain.value = 0;
      o.connect(filter);
      filter.connect(g);
      g.connect(audioCtx.destination);

      const now = audioCtx.currentTime;
      g.gain.cancelScheduledValues(now);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.linearRampToValueAtTime(volume, now + attack);
      g.gain.exponentialRampToValueAtTime(0.0001, now + duration - decay);

      o.start(now);
      o.stop(now + duration + 0.02);
    } catch (e) {
      console.warn('playTone error', e);
    }
  }

  function playPickSound() {
    playTone({ freq: 880, type: 'triangle', duration: 0.12, volume: 0.08, attack: 0.01, decay: 0.06 });
  }
  function playDropSound() {
    playTone({ freq: 660, type: 'sine', duration: 0.15, volume: 0.10, attack: 0.01, decay: 0.06 });
  }
  function playCorrectSound() {
    // cheerful arpeggio
    playTone({ freq: 880, type: 'sine', duration: 0.14, volume: 0.12 });
    setTimeout(() => playTone({ freq: 1100, type: 'sine', duration: 0.14, volume: 0.12 }), 160);
    setTimeout(() => playTone({ freq: 1320, type: 'sine', duration: 0.18, volume: 0.12 }), 320);
  }
  function playWrongSound() {
    // gentle buzz
    playTone({ freq: 220, type: 'square', duration: 0.22, volume: 0.12 });
    setTimeout(() => playTone({ freq: 170, type: 'square', duration: 0.18, volume: 0.09 }), 120);
  }

  // Initialize audio on first user gesture to satisfy browser policies
  function tryInitAudioOnGesture() {
    initAudio();
  }

  // ======== Game Data & Logic ========
  class Part {
    constructor(x, y, speed, value, belt) {
      this.x = x;
      this.y = y;
      this.speed = speed;
      this.value = value;
      this.radius = 22;
      this.belt = belt; // 0 or 1
      this.id = Math.random().toString(36).substr(2, 9);
      this.picked = false;
    }

    draw(ctx) {
      // draw soft capsule/coggy orb
      ctx.save();
      ctx.translate(this.x, this.y);

      // subtle shadow
      ctx.beginPath();
      ctx.fillStyle = 'rgba(0,0,0,0.08)';
      ctx.arc(6, 12, this.radius + 3, 0, Math.PI * 2);
      ctx.fill();

      // main circle
      const colors = ['#8fd3c7', '#ffd6a5', '#c3b0f8', '#ffb6c1', '#bfe3ff'];
      const base = colors[(this.value + this.belt) % colors.length];
      const grd = ctx.createLinearGradient(-this.radius, -this.radius, this.radius, this.radius);
      grd.addColorStop(0, base);
      grd.addColorStop(1, '#ffffff');

      ctx.beginPath();
      ctx.fillStyle = grd;
      ctx.strokeStyle = '#7d7d7d';
      ctx.lineWidth = 1.5;
      ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // number
      ctx.fillStyle = '#2b2b2b';
      ctx.font = 'bold 18px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(this.value), 0, 0);
      ctx.restore();
    }

    update(dt) {
      if (this.picked) return;
      this.x += this.speed * dt;
      // wrap horizontally
      if (this.speed > 0 && this.x - this.radius > WIDTH + 40) {
        this.x = -40;
      } else if (this.speed < 0 && this.x + this.radius < -40) {
        this.x = WIDTH + 40;
      }
    }
  }

  class Arm {
    constructor() {
      this.x = WIDTH / 2;
      this.y = HEIGHT - 120;
      this.width = 110;
      this.height = 22;
      this.holding = []; // up to 2 parts
      this.cooldown = 0;
    }

    draw(ctx) {
      // arm base
      ctx.save();
      ctx.translate(this.x, this.y);

      // shadow
      ctx.beginPath();
      ctx.fillStyle = 'rgba(0,0,0,0.08)';
      ctx.fillRect(-this.width/2 + 6, 10, this.width, 10);

      // arm beam
      ctx.beginPath();
      ctx.fillStyle = '#dcecf0';
      roundRect(ctx, -this.width/2, -10, this.width, 20, 10);
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#9aaab0';
      ctx.stroke();

      // claw/tray
      ctx.beginPath();
      ctx.fillStyle = '#e8f2ff';
      roundRect(ctx, -44, 12, 88, 28, 8);
      ctx.fill();
      ctx.strokeStyle = '#8aa0b1';
      ctx.stroke();

      // draw held parts in tray positions
      for (let i = 0; i < this.holding.length; i++) {
        const p = this.holding[i];
        ctx.save();
        const offsetX = -22 + i * 44;
        ctx.translate(offsetX, 26);
        // draw small circle with number
        ctx.beginPath();
        ctx.fillStyle = '#fff7';
        ctx.arc(0, 0, 18, 0, Math.PI*2);
        ctx.fill();

        ctx.beginPath();
        ctx.fillStyle = '#2b2b2b';
        ctx.font = 'bold 16px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(String(p.value), 0, 0);
        ctx.restore();
      }

      ctx.restore();
    }
  }

  class Game {
    constructor(ctx) {
      this.ctx = ctx;
      this.lastTime = performance.now();
      this.parts = [];
      this.arm = new Arm();
      this.belts = [
        { y: 140, direction: 1, speedBase: 30 },
        { y: 210, direction: -1, speedBase: 36 }
      ];
      this.level = 1;
      this.maxLevels = 5;
      this.attemptsLeft = 3;
      this.target = 8;
      this.message = 'Welcome! Press Space or Click to pick up parts. Collect two parts that add to the Target.';
      this.messageTimer = 0;
      this.showHelp = true;
      this.running = true;
      this.win = false;
      this.solvedThisLevel = false;
      this.animationRequest = null;
      this.mouse = { x: 0, y: 0, down: false };
      this.keys = {};
      this.audioVisualOn = true; // show speaker icon
      this.initLevel();

      // Input handlers
      this.bindHandlers();
      this.loop = this.loop.bind(this);
      this.animationRequest = requestAnimationFrame(this.loop);
    }

    bindHandlers() {
      // keyboard
      canvas.addEventListener('keydown', (e) => {
        // resume audio on gesture
        tryInitAudioOnGesture();
        resumeAudioOnInteraction();
        if (e.key === 'm' || e.key === 'M') {
          setAudioEnabled(!audioEnabled);
          this.message = audioEnabled ? 'Sound on' : 'Sound off';
          this.messageTimer = 2000;
          e.preventDefault();
          return;
        }
        if (e.key === 'Escape') {
          this.restart();
          e.preventDefault();
          return;
        }
        if (e.key === ' ') {
          // pick/drop
          this.tryPickOrDrop();
          e.preventDefault();
        }
        // movement keys handled on keydown/keyup
        this.keys[e.key] = true;
      });

      canvas.addEventListener('keyup', (e) => {
        this.keys[e.key] = false;
      });

      // mouse
      canvas.addEventListener('mousedown', (e) => {
        tryInitAudioOnGesture();
        resumeAudioOnInteraction();
        const rect = canvas.getBoundingClientRect();
        this.mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
        this.mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
        this.mouse.down = true;
        // clicking left side moves arm there
        this.arm.x = clamp(this.mouse.x, 60, WIDTH - 60);
        this.tryPickOrDrop();
      });

      canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        this.mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
        this.mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
      });

      canvas.addEventListener('mouseup', (e) => {
        this.mouse.down = false;
      });

      // make sure canvas can be focused for keyboard
      canvas.addEventListener('click', () => canvas.focus());
    }

    initLevel() {
      // prepare parts and target so there's always at least one solvable pair
      this.parts = [];
      this.arm.holding = [];
      this.solvedThisLevel = false;
      this.win = false;
      this.attemptsLeft = 3;
      this.message = `Level ${this.level}. Build a pair that adds to the Target.`;
      this.messageTimer = 3000;
      this.showHelp = this.level === 1;

      // choose target depending on level difficulty
      const minTarget = 5 + (this.level - 1) * 1; // grows slightly
      const maxTarget = 10 + (this.level - 1) * 2;
      this.target = randInt(minTarget, maxTarget);

      // create at least 5 moving parts, ensure at least one pair sums to target
      const pairA = randInt(1, this.target - 1);
      const pairB = this.target - pairA;
      const count = 6;
      for (let i = 0; i < count; i++) {
        const beltIndex = i % 2;
        const belt = this.belts[beltIndex];
        const y = belt.y + (beltIndex === 0 ? -6 : -4);
        const direction = belt.direction;
        const speed = (belt.speedBase + randInt(-8, 8)) * direction;
        let value;
        if (i === 0) value = pairA;
        else if (i === 1) value = pairB;
        else value = randInt(1, Math.max(2, this.target - 1));
        const x = randInt(20, WIDTH - 20);
        this.parts.push(new Part(x, y, speed, value, beltIndex));
      }
    }

    tryPickOrDrop() {
      // If holding less than 2, try pick nearest part within reach
      if (this.arm.cooldown > 0) return;
      if (this.arm.holding.length < 2) {
        // find closest part near arm center/tray region
        const trayX = this.arm.x;
        const trayY = this.arm.y + 26;
        let best = null;
        let bestDist = 9999;
        for (const p of this.parts) {
          if (p.picked) continue;
          const dx = p.x - trayX;
          const dy = p.y - trayY;
          const dist = Math.hypot(dx, dy);
          if (dist < 40 && dist < bestDist) {
            best = p;
            bestDist = dist;
          }
        }
        if (best) {
          // pick it
          best.picked = true;
          this.arm.holding.push(best);
          playPickSound();
          this.message = 'Picked a part. Place two parts into the gearbox!';
          this.messageTimer = 2000;
          this.arm.cooldown = 200; // ms
          return;
        }
        // otherwise try picking from belts by reaching down
        for (const p of this.parts) {
          if (p.picked) continue;
          const dx = p.x - this.arm.x;
          const dy = p.y - (this.arm.y - 8);
          const dist = Math.hypot(dx, dy);
          if (dist < 30) {
            p.picked = true;
            this.arm.holding.push(p);
            playPickSound();
            this.message = 'Picked a part!';
            this.messageTimer = 1200;
            this.arm.cooldown = 200;
            return;
          }
        }
      } else {
        // drop into gearbox area if near gearbox
        const gearboxX = WIDTH - 120;
        const gearboxY = HEIGHT / 2;
        const dx = this.arm.x - gearboxX;
        const dy = this.arm.y - gearboxY;
        const dist = Math.hypot(dx, dy);
        if (dist < 120) {
          // drop all held parts into gearbox check
          // The gearbox only accepts 2 parts at a time. If more than 2, drop only first two.
          while (this.arm.holding.length > 2) {
            const extra = this.arm.holding.pop();
            extra.picked = false;
            // re-position extra onto belt
            extra.x = clamp(this.arm.x + randInt(-30, 30), 40, WIDTH - 40);
            playDropSound();
          }

          if (this.arm.holding.length === 2) {
            // compute sum
            const sum = this.arm.holding[0].value + this.arm.holding[1].value;
            if (sum === this.target) {
              // success
              playCorrectSound();
              this.message = `Nice! ${this.arm.holding[0].value} + ${this.arm.holding[1].value} = ${this.target}`;
              this.messageTimer = 3000;
              this.solvedThisLevel = true;
              // remove those parts from the field
              this.parts = this.parts.filter(p => !this.arm.holding.includes(p));
              this.arm.holding = [];
              // progress to next level after a short delay
              setTimeout(() => this.nextLevel(), 1200);
            } else {
              // wrong
              playWrongSound();
              this.attemptsLeft--;
              this.message = `Try again: ${this.arm.holding[0].value} + ${this.arm.holding[1].value} = ${sum}`;
              this.messageTimer = 2500;
              // pop held parts back onto belts near machine
              for (const p of this.arm.holding) {
                p.picked = false;
                p.x = clamp(this.arm.x + randInt(-20, 20), 40, WIDTH - 40);
              }
              this.arm.holding = [];
              this.arm.cooldown = 300;
              if (this.attemptsLeft <= 0) {
                this.message = 'Out of attempts! Restarting level...';
                this.messageTimer = 2200;
                setTimeout(() => this.initLevel(), 1200);
              }
            }
          } else {
            // not enough parts to test
            playDropSound();
            // drop parts back to belts
            for (const p of this.arm.holding) {
              p.picked = false;
              p.x = clamp(this.arm.x + randInt(-20, 20), 40, WIDTH - 40);
            }
            this.arm.holding = [];
            this.message = 'You need two parts to test the gearbox.';
            this.messageTimer = 1500;
          }
          return;
        } else {
          // simply drop the held parts back onto belts where arm is
          for (const p of this.arm.holding) {
            p.picked = false;
            p.x = clamp(this.arm.x + randInt(-20, 20), 40, WIDTH - 40);
          }
          this.arm.holding = [];
          playDropSound();
          this.message = 'Dropped parts back on the belts.';
          this.messageTimer = 1200;
          this.arm.cooldown = 180;
        }
      }
    }

    nextLevel() {
      if (this.level >= this.maxLevels) {
        this.win = true;
        this.message = 'You fixed the Mega Machine! Great work!';
        this.messageTimer = 4000;
        // celebration sounds
        playCorrectSound();
      } else {
        this.level++;
        this.initLevel();
      }
    }

    restart() {
      this.level = 1;
      this.initLevel();
      this.win = false;
      this.message = 'Game restarted. Have fun!';
      this.messageTimer = 2000;
    }

    update(dt) {
      if (!this.running) return;
      // move arm via keyboard
      const moveSpeed = 220; // px/s
      if (this.keys['ArrowLeft'] || this.keys['a'] || this.keys['A']) {
        this.arm.x -= moveSpeed * dt;
      }
      if (this.keys['ArrowRight'] || this.keys['d'] || this.keys['D']) {
        this.arm.x += moveSpeed * dt;
      }
      if (this.keys['ArrowUp'] || this.keys['w'] || this.keys['W']) {
        this.arm.y -= moveSpeed * 0.5 * dt;
      }
      if (this.keys['ArrowDown'] || this.keys['s'] || this.keys['S']) {
        this.arm.y += moveSpeed * 0.5 * dt;
      }
      this.arm.x = clamp(this.arm.x, 60, WIDTH - 60);
      this.arm.y = clamp(this.arm.y, HEIGHT - 200, HEIGHT - 80);

      // quick keyboard pick with Enter
      if (this.keys['Enter']) {
        this.tryPickOrDrop();
        this.keys['Enter'] = false;
      }

      // update parts
      for (const p of this.parts) {
        p.update(dt);
      }

      // move picked parts to follow arm/its tray positions
      for (let i = 0; i < this.arm.holding.length; i++) {
        const p = this.arm.holding[i];
        // target position on tray
        const targetX = this.arm.x + (-22 + i * 44);
        const targetY = this.arm.y + 26;
        p.x += (targetX - p.x) * Math.min(1, dt * 12);
        p.y += (targetY - p.y) * Math.min(1, dt * 12);
      }

      if (this.arm.cooldown > 0) {
        this.arm.cooldown = Math.max(0, this.arm.cooldown - dt * 1000);
      }

      if (this.messageTimer > 0) {
        this.messageTimer -= dt * 1000;
        if (this.messageTimer <= 0) this.message = '';
      }
    }

    drawBackground(ctx) {
      // soft gradient sky
      const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
      g.addColorStop(0, '#f7fbff');
      g.addColorStop(0.5, '#eef9f7');
      g.addColorStop(1, '#f3f7fb');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      // doodle cloud shapes for wacky calm feel
      ctx.save();
      ctx.globalAlpha = 0.7;
      drawCloud(ctx, 80, 60, 60, '#ffffff');
      drawCloud(ctx, 220, 40, 44, '#ffffff');
      drawCloud(ctx, 520, 70, 50, '#ffffff');
      ctx.globalAlpha = 1;
      ctx.restore();

      // big machine frame on right
      ctx.save();
      ctx.translate(WIDTH - 180, HEIGHT / 2 - 20);
      ctx.fillStyle = '#f0f4f8';
      roundRect(ctx, -120, -140, 240, 280, 16);
      ctx.fill();
      ctx.strokeStyle = '#bfcdd7';
      ctx.lineWidth = 2;
      ctx.stroke();
      // porthole
      ctx.beginPath();
      ctx.fillStyle = '#e9fbff';
      ctx.arc(0, -50, 36, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = '#9cc3cf';
      ctx.stroke();

      // target display window
      ctx.beginPath();
      ctx.fillStyle = '#fff7';
      roundRect(ctx, -70, 20, 140, 70, 10);
      ctx.fill();
      ctx.strokeStyle = '#9aaeb7';
      ctx.stroke();

      // little label
      ctx.fillStyle = '#2b2b2b';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Gearbox Target', 0, 16);
      ctx.restore();
    }

    drawConveyorAndParts(ctx) {
      // draw belts
      for (let b = 0; b < this.belts.length; b++) {
        const belt = this.belts[b];
        const y = belt.y;
        // belt backing
        ctx.beginPath();
        ctx.fillStyle = '#eef7f6';
        roundRect(ctx, 20, y - 28, WIDTH - 260, 56, 14);
        ctx.fill();
        // pattern lines to indicate motion
        ctx.save();
        ctx.clip();
        ctx.beginPath();
        ctx.strokeStyle = '#cfe6e3';
        ctx.lineWidth = 3;
        const stripeWidth = 22;
        const offset = ((performance.now() / 30) * belt.direction) % stripeWidth;
        for (let x = -100 + offset; x < WIDTH; x += stripeWidth) {
          ctx.moveTo(x, y - 20);
          ctx.lineTo(x + 14, y + 20);
        }
        ctx.stroke();
        ctx.restore();

        // belt edges screws
        ctx.fillStyle = '#d0d8db';
        for (let s = 24; s < WIDTH - 236; s += 60) {
          ctx.beginPath();
          ctx.arc(s, y - 20, 3, 0, Math.PI*2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(s, y + 20, 3, 0, Math.PI*2);
          ctx.fill();
        }
      }

      // draw parts
      for (const p of this.parts) p.draw(ctx);
    }

    drawMachineDetail(ctx) {
      // gearbox window with target number
      ctx.save();
      const gx = WIDTH - 120;
      const gy = HEIGHT / 2;
      // display target number in window
      ctx.beginPath();
      ctx.fillStyle = '#fff';
      roundRect(ctx, gx - 70, gy + 20, 140, 70, 10);
      ctx.fill();
      ctx.strokeStyle = '#9aaeb7';
      ctx.lineWidth = 2;
      ctx.stroke();

      // target number big
      ctx.fillStyle = '#2b2b2b';
      ctx.font = 'bold 38px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(this.target), gx, gy + 56);

      // gears below
      drawGear(ctx, gx - 40, gy - 30, 22, 8, '#c2e7e1', '#8ab6a9', 0.2);
      drawGear(ctx, gx + 30, gy - 10, 28, 10, '#fde0c2', '#e6b884', -0.12);
      ctx.restore();
    }

    drawArmAndUI(ctx) {
      // draw arm first (so parts overlay nicely)
      this.arm.draw(ctx);

      // HUD: level, attempts, instructions
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.75)';
      roundRect(ctx, 10, 10, 260, 86, 10);
      ctx.fill();
      ctx.strokeStyle = '#d0d6da';
      ctx.stroke();

      ctx.fillStyle = '#2b2b2b';
      ctx.font = 'bold 16px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText(`Level ${this.level}/${this.maxLevels}`, 22, 34);

      ctx.font = '13px sans-serif';
      ctx.fillText(`Attempts: ${this.attemptsLeft}`, 22, 56);
      ctx.fillText('Controls: ← → move  Space/Click pick/drop  M toggle sound', 22, 76);

      // audio icon visual cue
      const iconX = 260;
      const iconY = 32;
      ctx.beginPath();
      ctx.fillStyle = audioEnabled ? '#7fc9a9' : '#ddd';
      roundRect(ctx, iconX, iconY - 12, 34, 24, 6);
      ctx.fill();
      ctx.strokeStyle = '#c3d3d0';
      ctx.stroke();

      ctx.fillStyle = audioEnabled ? '#fff' : '#888';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(audioEnabled ? 'Sound' : 'Muted', iconX + 17, iconY + 1);

      ctx.restore();

      // Message area
      if (this.message) {
        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = '#ffffff';
        roundRect(ctx, WIDTH/2 - 260, HEIGHT - 96, 520, 60, 12);
        ctx.fill();
        ctx.strokeStyle = '#cdd9dc';
        ctx.stroke();

        ctx.fillStyle = '#2b2b2b';
        ctx.font = '15px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(this.message, WIDTH/2, HEIGHT - 60);
        ctx.restore();
      }

      // Accessibility hint
      ctx.save();
      ctx.font = '12px sans-serif';
      ctx.fillStyle = '#6a6a6a';
      ctx.textAlign = 'left';
      ctx.fillText('For screen readers: use keyboard arrows and space to operate the arm. Press M to toggle sound.', 14, HEIGHT - 10);
      ctx.restore();
    }

    drawWinScreen(ctx) {
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      roundRect(ctx, WIDTH/2 - 260, HEIGHT/2 - 120, 520, 240, 18);
      ctx.fill();
      ctx.strokeStyle = '#d7e6e6';
      ctx.stroke();

      ctx.fillStyle = '#2b2b2b';
      ctx.font = 'bold 26px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Mega Machine Fixed!', WIDTH/2, HEIGHT/2 - 20);
      ctx.font = '18px sans-serif';
      ctx.fillText('You solved all levels. Great engineering thinking!', WIDTH/2, HEIGHT/2 + 16);

      ctx.font = '14px sans-serif';
      ctx.fillStyle = '#6a6a6a';
      ctx.fillText('Press Escape to play again.', WIDTH/2, HEIGHT/2 + 56);
      ctx.restore();
    }

    draw(ctx) {
      // clear
      ctx.clearRect(0, 0, WIDTH, HEIGHT);

      this.drawBackground(ctx);
      this.drawConveyorAndParts(ctx);
      this.drawMachineDetail(ctx);
      this.drawArmAndUI(ctx);

      if (this.win) {
        this.drawWinScreen(ctx);
      }

      // draw subtle decorative wacky elements
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = '#ffffff';
      // tiny moving bubbles for calm effect
      const t = performance.now() / 1000;
      for (let i = 0; i < 6; i++) {
        const bx = (i * 110 + ((t * (i + 1) * 5) % 110));
        const by = 40 + (Math.sin(t * (i + 1)) * 10);
        ctx.beginPath();
        ctx.fillStyle = `rgba(255,255,255,${0.6 - i*0.06})`;
        ctx.arc(bx % WIDTH, by, 8 + i % 3, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    loop(now) {
      const dt = Math.min(0.05, (now - this.lastTime) / 1000);
      this.lastTime = now;
      this.update(dt);
      try {
        this.draw(this.ctx);
      } catch (e) {
        console.error('Render error', e);
      }
      this.animationRequest = requestAnimationFrame(this.loop);
    }

    stop() {
      this.running = false;
      if (this.animationRequest) cancelAnimationFrame(this.animationRequest);
    }
  }

  // ======== Drawing Helpers ========
  function roundRect(ctx, x, y, w, h, r) {
    const radius = r || 6;
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.arcTo(x + w, y, x + w, y + h, radius);
    ctx.arcTo(x + w, y + h, x, y + h, radius);
    ctx.arcTo(x, y + h, x, y, radius);
    ctx.arcTo(x, y, x + w, y, radius);
    ctx.closePath();
  }

  function drawCloud(ctx, x, y, size, color = '#fff') {
    ctx.save();
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x, y, size * 0.6, 0, Math.PI * 2);
    ctx.arc(x + size * 0.6, y + 4, size * 0.5, 0, Math.PI * 2);
    ctx.arc(x - size * 0.5, y + 4, size * 0.4, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawGear(ctx, x, y, radius, teeth, colorLight, colorDark, rotation = 0) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rotation);
    // teeth
    for (let i = 0; i < teeth; i++) {
      const ang = (i / teeth) * Math.PI * 2;
      const x1 = Math.cos(ang) * radius;
      const y1 = Math.sin(ang) * radius;
      const x2 = Math.cos(ang) * (radius + 8);
      const y2 = Math.sin(ang) * (radius + 8);
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.lineWidth = 6;
      ctx.strokeStyle = colorDark;
      ctx.stroke();
    }
    // center disc
    ctx.beginPath();
    ctx.fillStyle = colorLight;
    ctx.arc(0, 0, radius - 6, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = colorDark;
    ctx.lineWidth = 2;
    ctx.stroke();

    // hub
    ctx.beginPath();
    ctx.fillStyle = '#ffffff';
    ctx.arc(0, 0, radius / 4, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // ======== Initialization and Error Handling ========
  // Try audio init but allow graceful degrade
  try {
    initAudio();
  } catch (e) {
    console.warn('Audio unavailable:', e);
    audioInitError = true;
    audioEnabled = false;
  }
  setAudioEnabled(audioEnabled);

  // Create and start the game
  const game = new Game(ctx);

  // Accessibility: announce start via canvas aria-label update
  function updateAria() {
    const desc = `Machine Merge. Level ${game.level}. Target ${game.target}. ${game.attemptsLeft} attempts remaining. Use arrows to move the arm, space to pick or drop parts, M to toggle sound.`;
    canvas.setAttribute('aria-label', desc);
  }
  setInterval(updateAria, 1000);

  // Resume audio on first user interaction
  ['click', 'keydown', 'touchstart'].forEach(evt => {
    document.addEventListener(evt, () => {
      tryInitAudioOnGesture();
      resumeAudioOnInteraction();
    }, { once: true });
  });

  // Basic error handling for audio context events
  if (audioCtx) {
    audioCtx.onstatechange = () => {
      if (audioCtx.state === 'suspended') {
        // show visual cue
        game.message = 'Audio suspended; press a key or click to resume audio.';
        game.messageTimer = 3000;
      }
    };
  }

  // Clean up on page unload
  window.addEventListener('beforeunload', () => {
    try {
      if (backgroundOsc) backgroundOsc.disconnect();
      if (backgroundGain) backgroundGain.disconnect();
      if (audioCtx) audioCtx.close();
    } catch (e) {
      // ignore
    }
  });

  // Expose some simple debug hooks (non-invasive)
  window.__MachineMergeGame = {
    restart: () => game.restart(),
    toggleSound: () => setAudioEnabled(!audioEnabled)
  };
})();
---

