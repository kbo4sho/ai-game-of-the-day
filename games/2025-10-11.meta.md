# Game of the Day - 2025-10-11

## Metadata
- **Generated Date:** 2025-10-11
- **Generated Time:** 2025-10-11T00:25:44.326886
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-10-11.js
- **File Size:** 27848 bytes
- **Tokens Used:** 9291

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-10-11.js` - The playable game
- `2025-10-11.meta.json` - Machine-readable metadata
- `2025-10-11.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 18789

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 20216

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Machine Math Workshop - JavaScript Game
// Renders inside element with ID "game-of-the-day-stage"
// Canvas 720x480. No external assets. Uses Web Audio API oscillators.
// Accessible controls: ArrowLeft/ArrowRight to select parts, Enter to place, Backspace to remove last placed,
// A to toggle audio, R to reset level, Space to pick up / drop with keyboard.
// Mouse: click to pick/select, drag to place. Speaker icon toggles audio.
// Includes error handling for AudioContext and resource setup.

// Immediately-invoked function to avoid polluting global scope
(function () {
  // Locate container
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Game container #game-of-the-day-stage not found.');
    return;
  }

  // Clear container
  container.innerHTML = '';
  container.style.position = 'relative';
  container.style.userSelect = 'none';

  // Create accessible live region for screen readers
  const liveRegion = document.createElement('div');
  liveRegion.setAttribute('role', 'status');
  liveRegion.setAttribute('aria-live', 'polite');
  liveRegion.style.position = 'absolute';
  liveRegion.style.left = '-9999px';
  liveRegion.style.width = '1px';
  liveRegion.style.height = '1px';
  liveRegion.style.overflow = 'hidden';
  container.appendChild(liveRegion);

  // Create canvas
  const canvas = document.createElement('canvas');
  const WIDTH = 720;
  const HEIGHT = 480;
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.width = WIDTH + 'px';
  canvas.style.height = HEIGHT + 'px';
  canvas.setAttribute('tabindex', '0'); // focusable for keyboard
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Handle high DPI displays
  function resizeForDPR() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = WIDTH * dpr;
    canvas.height = HEIGHT * dpr;
    canvas.style.width = WIDTH + 'px';
    canvas.style.height = HEIGHT + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  resizeForDPR();

  // Audio setup with error handling
  let audioEnabled = true;
  let audioCtx = null;
  let masterGain = null;
  let humNode = null;
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (!AudioContext) throw new Error('Web Audio API not supported.');
    audioCtx = new AudioContext();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.12; // gentle overall volume
    masterGain.connect(audioCtx.destination);
  } catch (err) {
    console.warn('Audio disabled:', err.message);
    audioEnabled = false;
    audioCtx = null;
  }

  // Audio helper functions
  function safeResumeAudio() {
    if (!audioCtx) return Promise.resolve();
    if (audioCtx.state === 'suspended') {
      return audioCtx.resume().catch((e) => {
        console.warn('Audio resume failed:', e);
      });
    }
    return Promise.resolve();
  }

  // Play a short tone; returns a Promise resolved when done
  function playTone(freq, duration = 0.25, type = 'sine', options = {}) {
    if (!audioEnabled || !audioCtx) return Promise.resolve();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const now = audioCtx.currentTime;
    osc.type = type;
    osc.frequency.value = freq;
    gain.gain.value = 0;
    // gentle attack/decay
    gain.gain.linearRampToValueAtTime(options.maxGain || 0.12, now + 0.005);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);

    // optional filter for richer sound
    if (options.filter) {
      const filter = audioCtx.createBiquadFilter();
      filter.type = options.filter.type || 'lowpass';
      filter.frequency.value = options.filter.freq || 1200;
      osc.connect(filter);
      filter.connect(gain);
    } else {
      osc.connect(gain);
    }

    gain.connect(masterGain);
    osc.start(now);
    osc.stop(now + duration + 0.02);
    return new Promise((res) => {
      setTimeout(res, (duration + 0.02) * 1000);
    });
  }

  function playClick() {
    return playTone(880, 0.06, 'square', { maxGain: 0.08 });
  }
  function playWrong() {
    return playTone(220, 0.5, 'sawtooth', {
      maxGain: 0.18,
      filter: { type: 'lowpass', freq: 800 },
    });
  }
  function playSuccess() {
    // triad of notes
    return safeResumeAudio().then(() =>
      Promise.all([
        playTone(660, 0.18, 'triangle', { maxGain: 0.12 }),
        new Promise((r) => setTimeout(r, 90)).then(() =>
          playTone(880, 0.22, 'triangle', { maxGain: 0.12 })
        ),
        new Promise((r) => setTimeout(r, 180)).then(() =>
          playTone(990, 0.28, 'triangle', { maxGain: 0.12 })
        ),
      ])
    );
  }

  // Gentle background hum with slow wobble
  function startHum() {
    if (!audioEnabled || !audioCtx || humNode) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const lfo = audioCtx.createOscillator();
    const lfoGain = audioCtx.createGain();

    osc.type = 'sine';
    osc.frequency.value = 110;
    gain.gain.value = 0.06;
    lfo.type = 'sine';
    lfo.frequency.value = 0.15;
    lfoGain.gain.value = 8;
    lfo.connect(lfoGain);
    lfoGain.connect(osc.frequency);

    osc.connect(gain);
    gain.connect(masterGain);
    osc.start();
    lfo.start();
    humNode = { osc, gain, lfo, lfoGain };
  }
  function stopHum() {
    if (!humNode) return;
    try {
      humNode.osc.stop();
      humNode.lfo.stop();
    } catch (e) {
      // ignore
    }
    humNode = null;
  }

  // Toggle audio with proper resume
  function toggleAudio() {
    if (!audioCtx) {
      audioEnabled = false;
      return;
    }
    if (!audioEnabled) {
      audioEnabled = true;
      safeResumeAudio().then(() => {
        startHum();
      });
    } else {
      audioEnabled = false;
      stopHum();
    }
    announceAudioState();
  }
  function announceAudioState() {
    const msg = audioEnabled ? 'Audio on' : 'Audio off';
    liveRegion.textContent = msg;
  }

  // Game variables
  const LEVEL_COUNT = 5;
  let currentLevel = 1;
  let targetNumber = 0;
  let parts = []; // available parts to drag
  const placed = []; // placed parts into machine
  let selectedIndex = -1; // index in parts array of selection (keyboard)
  let dragging = null; // {part, offsetX, offsetY}
  let animationTime = 0;
  let won = false;
  let showConfetti = 0;

  // Layout constants
  const MACHINE_X = 420;
  const MACHINE_Y = 80;
  const MACHINE_W = 260;
  const MACHINE_H = 320;
  const PART_RADIUS = 26;
  const PART_AREA = { x: 40, y: 80, w: 300, h: 320 };

  // Colors and visual styles
  const bgColor = '#EAF2F5';
  const pastel = {
    machine: '#D6EAF8',
    highlight: '#7FB3D5',
    part: '#F7DC6F',
    partAlt: '#AED6F1',
    text: '#12333F',
    gentle: '#D5F5E3',
  };

  // Utility: random int
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // Create a beatable level: pick a target and parts which include a subset that sums to target
  function setupLevel(level) {
    currentLevel = Math.min(Math.max(1, level), LEVEL_COUNT);
    won = false;
    showConfetti = 0;
    parts = [];
    placed.length = 0;
    selectedIndex = -1;
    dragging = null;

    // Difficulty scales: number of parts and max part value
    const baseParts = 5 + currentLevel; // 6..10
    const maxVal = 5 + currentLevel * 3; // e.g., up to 20
    // choose a target as sum of some randomly chosen parts
    const subsetCount = Math.min(baseParts, 2 + Math.floor(currentLevel / 1.5)); // 2..?
    const chosen = [];
    for (let i = 0; i < subsetCount; i++) {
      chosen.push(randInt(1, Math.max(2, Math.floor(maxVal / 2))));
    }
    targetNumber = chosen.reduce((a, b) => a + b, 0);

    // Create parts array that includes chosen items plus distractors
    const totalParts = baseParts;
    const values = chosen.slice();

    while (values.length < totalParts) {
      // create distractors that do not trivially break solveability
      let v = randInt(1, maxVal);
      // Avoid making it trivially equal target alone
      if (v === targetNumber) v = Math.max(1, v - 1);
      values.push(v);
    }

    // Shuffle values
    for (let i = values.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [values[i], values[j]] = [values[j], values[i]];
    }

    // Create part objects with positions in the part area
    const cols = 3;
    const gapX = PART_AREA.w / cols;
    const gapY = 60;
    for (let i = 0; i < values.length; i++) {
      const col = i % cols;
      const row = Math.floor(i / cols);
      const x = PART_AREA.x + 30 + col * gapX + randInt(-10, 10);
      const y = PART_AREA.y + 40 + row * gapY + randInt(-6, 6);
      parts.push({
        id: 'p' + i + '-' + Date.now(),
        value: values[i],
        x,
        y,
        homeX: x,
        homeY: y,
        radius: PART_RADIUS,
        wobble: Math.random() * Math.PI * 2,
        color: i % 2 === 0 ? pastel.part : pastel.partAlt,
      });
    }

    // Announce level for accessibility
    liveRegion.textContent = `Level ${currentLevel}. Target ${targetNumber}. Use arrow keys to select a part and press Enter to place it into the machine.`;
  }

  // Calculate current placed sum
  function currentSum() {
    return placed.reduce((s, p) => s + p.value, 0);
  }

  // Place part into machine (snap into position)
  function placePart(part) {
    // Only place if part is not already placed
    if (parts.indexOf(part) === -1) return;
    // compute a stacked position inside machine
    const index = placed.length;
    const stackX = MACHINE_X + MACHINE_W / 2;
    const stackY = MACHINE_Y + MACHINE_H - 36 - index * 46;
    // Remove from parts and push into placed
    parts = parts.filter((p) => p !== part);
    part.placedX = stackX + randInt(-6, 6);
    part.placedY = stackY + randInt(-6, 6);
    placed.push(part);
    selectedIndex = Math.min(selectedIndex, parts.length - 1);
    if (audioEnabled) playClick();
    liveRegion.textContent = `Placed ${part.value}. Current sum ${currentSum()} of ${targetNumber}.`;
    checkWinOrOver();
  }

  // Remove last placed or specified placed item
  function removeLastPlaced() {
    if (placed.length === 0) {
      liveRegion.textContent = 'No parts to remove.';
      return;
    }
    const part = placed.pop();
    // send back to parts area to home position
    part.x = part.homeX + randInt(-8, 8);
    part.y = part.homeY + randInt(-8, 8);
    parts.push(part);
    if (audioEnabled) playClick();
    liveRegion.textContent = `Removed ${part.value}. Current sum ${currentSum()} of ${targetNumber}.`;
  }

  // Check win or over-sum
  function checkWinOrOver() {
    const sum = currentSum();
    if (sum === targetNumber) {
      // Win this level
      won = true;
      announceWin();
    } else if (sum > targetNumber) {
      // Overfilled - play wrong sound
      if (audioEnabled) playWrong();
      liveRegion.textContent = `Oh no! The machine is overfilled: ${sum} (target ${targetNumber}). Remove a part.`;
    } else {
      // Not yet
    }
  }

  async function announceWin() {
    liveRegion.textContent = `Great! You matched ${targetNumber}. Level ${currentLevel} complete.`;
    if (audioEnabled) await playSuccess();
    // celebrate visually
    showConfetti = 60; // frames
    // Move to next level after a short delay
    setTimeout(() => {
      if (currentLevel < LEVEL_COUNT) {
        setupLevel(currentLevel + 1);
        if (audioEnabled) playClick();
      } else {
        // final applause
        liveRegion.textContent = 'You finished all levels! Well done!';
        if (audioEnabled) playSuccess();
        // reset to start after a pause
        setTimeout(() => {
          setupLevel(1);
        }, 4000);
      }
    }, 1600);
  }

  // Drawing functions
  function clear() {
    ctx.fillStyle = bgColor;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
  }

  // Draw wacky machine with panels, glass, steam
  function drawMachine(t) {
    // Machine body
    ctx.save();
    ctx.translate(MACHINE_X, MACHINE_Y);
    // Body
    roundRect(ctx, 0, 0, MACHINE_W, MACHINE_H, 18, pastel.machine, '#9AC6E1', 2);
    // Glass window
    ctx.beginPath();
    ctx.rect(28, 40, MACHINE_W - 56, MACHINE_H - 120);
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fill();

    // Funnel top
    ctx.beginPath();
    ctx.moveTo(MACHINE_W / 2 - 36, 12);
    ctx.lineTo(MACHINE_W / 2 + 36, 12);
    ctx.lineTo(MACHINE_W - 18, 40);
    ctx.lineTo(18, 40);
    ctx.closePath();
    ctx.fillStyle = '#CFEAF8';
    ctx.fill();

    // Control panel left
    roundRect(ctx, 12, MACHINE_H - 72, 80, 56, 10, '#F6E6C3', '#D5A021', 2);
    // Buttons
    drawButton(ctx, 26, MACHINE_H - 56, 18, '#FF6B6B');
    drawButton(ctx, 54, MACHINE_H - 56, 18, '#6BE696');

    // Gauge
    ctx.beginPath();
    ctx.arc(MACHINE_W - 56, MACHINE_H - 36, 28, Math.PI, 2 * Math.PI);
    ctx.fillStyle = '#FFFFFF';
    ctx.fill();
    ctx.strokeStyle = '#9BBBD8';
    ctx.stroke();
    // Needle showing fullness
    const sum = currentSum();
    const pct = Math.min(1, Math.max(0, sum / Math.max(targetNumber, 1)));
    const angle = Math.PI + pct * Math.PI;
    ctx.beginPath();
    ctx.moveTo(MACHINE_W - 56, MACHINE_H - 36);
    ctx.lineTo(MACHINE_W - 56 + 24 * Math.cos(angle), MACHINE_H - 36 + 24 * Math.sin(angle));
    ctx.strokeStyle = '#E74C3C';
    ctx.lineWidth = 3;
    ctx.stroke();

    // Little piston animation
    const pistonY = 20 + Math.sin(t * 0.06) * 6;
    ctx.fillStyle = '#EEDFA8';
    ctx.fillRect(12, pistonY, MACHINE_W - 24, 8);

    ctx.restore();

    // Machine label
    ctx.fillStyle = pastel.text;
    ctx.font = 'bold 18px sans-serif';
    ctx.fillText('Number Mixer 3000', MACHINE_X + 12, MACHINE_Y - 8);
  }

  // Helper: rounded rect
  function roundRect(ctx, x, y, w, h, r, fillStyle, strokeStyle, lineWidth = 1) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fillStyle) {
      ctx.fillStyle = fillStyle;
      ctx.fill();
    }
    if (strokeStyle) {
      ctx.strokeStyle = strokeStyle;
      ctx.lineWidth = lineWidth;
      ctx.stroke();
    }
  }

  // Draw a shiny push button
  function drawButton(ctx, x, y, r, color) {
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.15)';
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(x - r / 3, y - r / 3, r / 2.2, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.fill();
  }

  // Draw parts (gears/number chips)
  function drawParts(t) {
    // Part area background
    roundRect(ctx, PART_AREA.x - 12, PART_AREA.y - 12, PART_AREA.w + 24, PART_AREA.h + 24, 14, '#F0F7FA');
    ctx.fillStyle = pastel.text;
    ctx.font = '14px sans-serif';
    ctx.fillText('Parts', PART_AREA.x + 8, PART_AREA.y - 2);

    // Draw each part
    parts.forEach((p, i) => {
      // wobble
      p.wobble += 0.02 + i * 0.0005;
      const wob = Math.sin(p.wobble) * 2;
      // if dragging, position is dynamic; otherwise ease back to home
      const dx = p.x - p.homeX;
      const dy = p.y - p.homeY;
      // draw gear-like circle
      drawGear(ctx, p.x, p.y + wob, p.radius, p.color, p.value, i === selectedIndex);
    });

    // Draw placed parts inside machine
    placed.forEach((p, i) => {
      // Slight bounce when recently placed
      const b = Math.sin(t * 0.12 + i) * 3;
      drawGear(ctx, p.placedX, p.placedY + b, p.radius, p.color, p.value, false);
    });
  }

  // Draw a gear-like circle with value text
  function drawGear(ctx, x, y, r, color, value, highlight) {
    ctx.save();
    ctx.translate(x, y);
    // Gear teeth
    ctx.fillStyle = color;
    ctx.beginPath();
    const teeth = 8;
    for (let i = 0; i < teeth; i++) {
      const angle = (i / teeth) * Math.PI * 2;
      const tx = Math.cos(angle) * (r + 6);
      const ty = Math.sin(angle) * (r + 6);
      ctx.rect(tx - 4, ty - 4, 8, 8);
    }
    ctx.fill();

    // Center circle
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.strokeStyle = '#8A6F3C';
    ctx.lineWidth = 2;
    ctx.stroke();

    // value text
    ctx.fillStyle = '#12333F';
    ctx.font = 'bold 18px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(String(value), 0, 0);

    if (highlight) {
      ctx.beginPath();
      ctx.arc(0, 0, r + 6, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(123,204,196,0.9)';
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    ctx.restore();
  }

  // Draw HUD: target, sum, instructions, speaker icon
  function drawHUD() {
    // Target card
    ctx.fillStyle = '#FFFFFF';
    roundRect(ctx, 40, 12, 240, 52, 10, '#FFFFFF', '#C9E1EE', 2);

    ctx.fillStyle = pastel.text;
    ctx.font = '18px sans-serif';
    ctx.fillText('Target Number', 60, 32);

    ctx.fillStyle = '#2C3E50';
    ctx.font = 'bold 32px sans-serif';
    ctx.fillText(String(targetNumber), 60, 56);

    // Current sum
    ctx.fillStyle = '#FFFFFF';
    roundRect(ctx, 320, 12, 220, 52, 10, '#FFFFFF', '#C9E1EE', 2);
    ctx.fillStyle = pastel.text;
    ctx.font = '16px sans-serif';
    ctx.fillText('Current Sum', 336, 30);
    ctx.font = 'bold 28px sans-serif';
    ctx.fillStyle = currentSum() === targetNumber ? '#27AE60' : '#2C3E50';
    ctx.fillText(String(currentSum()), 336, 54);

    // Instructions small
    ctx.fillStyle = '#12333F';
    ctx.font = '13px sans-serif';
    ctx.fillText('Arrow keys: select • Enter: place • Backspace: remove • A: audio • R: reset', 40, HEIGHT - 18);

    // Speaker icon at top-right
    const sx = WIDTH - 44;
    const sy = 16;
    drawSpeakerIcon(ctx, sx, sy, audioEnabled);
    // level indicator
    ctx.fillStyle = '#12333F';
    ctx.font = '14px sans-serif';
    ctx.fillText(`Level ${currentLevel}/${LEVEL_COUNT}`, WIDTH - 140, 28);
  }

  function drawSpeakerIcon(ctx, x, y, on) {
    ctx.save();
    ctx.translate(x, y);
    // box background
    ctx.beginPath();
    ctx.rect(-8, -8, 48, 36);
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fill();
    // Speaker
    ctx.beginPath();
    ctx.moveTo(0, 6);
    ctx.lineTo(10, 6);
    ctx.lineTo(18, 0);
    ctx.lineTo(18, 24);
    ctx.lineTo(10, 18);
    ctx.lineTo(0, 18);
    ctx.closePath();
    ctx.fillStyle = '#7FB3D5';
    ctx.fill();
    if (!on) {
      // slash
      ctx.beginPath();
      ctx.moveTo(2, 2);
      ctx.lineTo(28, 26);
      ctx.strokeStyle = '#E74C3C';
      ctx.lineWidth = 3;
      ctx.stroke();
    } else {
      // sound waves
      ctx.beginPath();
      ctx.arc(24, 10, 6, -0.6, 0.6);
      ctx.strokeStyle = '#6BE696';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    ctx.restore();
  }

  // Little steam puffs for wacky effect
  function drawSteam(t) {
    const steamX = MACHINE_X - 24;
    for (let i = 0; i < 4; i++) {
      const s = (t * 0.03 + i * 0.7) % 1;
      const alpha = 0.12 + Math.sin((s * Math.PI * 2)) * 0.06;
      ctx.beginPath();
      ctx.arc(steamX + i * 18, MACHINE_Y + s * MACHINE_H * 0.6, 12 + i * 3, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255,255,255,${alpha.toFixed(2)})`;
      ctx.fill();
    }
  }

  // Confetti celebration
  const confettiPieces = [];
  function updateConfetti() {
    if (showConfetti > 0 && confettiPieces.length === 0) {
      for (let i = 0; i < 40; i++) {
        confettiPieces.push({
          x: MACHINE_X + Math.random() * MACHINE_W,
          y: MACHINE_Y + 10,
          vx: (Math.random() - 0.5) * 4,
          vy: Math.random() * 3 - 1,
          color: `hsl(${Math.random() * 360},70%,60%)`,
          rot: Math.random() * Math.PI * 2,
          vr: (Math.random() - 0.5) * 0.3,
        });
      }
    }
    confettiPieces.forEach((c) => {
      c.x += c.vx;
      c.y += c.vy;
      c.vy += 0.12;
      c.rot += c.vr;
    });
    // decrement showConfetti
    if (showConfetti > 0) showConfetti--;
    if (showConfetti === 0) confettiPieces.length = 0;
  }
  function drawConfetti() {
    confettiPieces.forEach((c) => {
      ctx.save();
      ctx.translate(c.x, c.y);
      ctx.rotate(c.rot);
      ctx.fillStyle = c.color;
      ctx.fillRect(-4, -6, 8, 12);
      ctx.restore();
    });
  }

  // Event handling: pointer and keyboard
  let pointerDown = false;

  function canvasToLocal(e) {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left);
    const y = (e.clientY - rect.top);
    return { x, y };
  }

  canvas.addEventListener('pointerdown', (ev) => {
    pointerDown = true;
    canvas.setPointerCapture(ev.pointerId);
    const pt = canvasToLocal(ev);
    // check speaker icon
    if (pt.x > WIDTH - 80 && pt.y < 64) {
      toggleAudio();
      return;
    }

    // check selection of a part
    for (let i = parts.length - 1; i >= 0; i--) {
      const p = parts[i];
      if (distance(pt.x, pt.y, p.x, p.y) <= p.radius + 6) {
        // start dragging
        dragging = { part: p, offsetX: pt.x - p.x, offsetY: pt.y - p.y };
        selectedIndex = parts.indexOf(p);
        if (audioEnabled) safeResumeAudio().then(() => playClick());
        return;
      }
    }

    // click on placed area to remove last
    if (pt.x > MACHINE_X && pt.x < MACHINE_X + MACHINE_W && pt.y > MACHINE_Y && pt.y < MACHINE_Y + MACHINE_H) {
      removeLastPlaced();
      return;
    }
  });

  canvas.addEventListener('pointermove', (ev) => {
    if (!pointerDown || !dragging) return;
    const pt = canvasToLocal(ev);
    dragging.part.x = pt.x - dragging.offsetX;
    dragging.part.y = pt.y - dragging.offsetY;
  });

  canvas.addEventListener('pointerup', (ev) => {
    pointerDown = false;
    canvas.releasePointerCapture && canvas.releasePointerCapture(ev.pointerId);
    if (!dragging) return;
    const pt = canvasToLocal(ev);
    const part = dragging.part;
    // if dropped inside machine area, place it
    if (pt.x > MACHINE_X + 12 && pt.x < MACHINE_X + MACHINE_W - 12 && pt.y > MACHINE_Y + 30 && pt.y < MACHINE_Y + MACHINE_H - 20) {
      placePart(part);
    } else {
      // return to home spot
      part.x = part.homeX + randInt(-6, 6);
      part.y = part.homeY + randInt(-6, 6);
      if (audioEnabled) playClick();
    }
    dragging = null;
  });

  // Utility distance
  function distance(x1, y1, x2, y2) {
    return Math.hypot(x1 - x2, y1 - y2);
  }

  // Keyboard controls
  canvas.addEventListener('keydown', (ev) => {
    // Ensure audio resume on first user gesture
    if (audioEnabled && audioCtx && audioCtx.state === 'suspended') safeResumeAudio().then(startHum);
    if (ev.key === 'ArrowLeft') {
      ev.preventDefault();
      if (parts.length > 0) {
        selectedIndex = (selectedIndex <= 0) ? parts.length - 1 : selectedIndex - 1;
        liveRegion.textContent = `Selected ${parts[selectedIndex].value}. Press Enter to place.`;
      }
    } else if (ev.key === 'ArrowRight') {
      ev.preventDefault();
      if (parts.length > 0) {
        selectedIndex = (selectedIndex >= parts.length - 1) ? 0 : selectedIndex + 1;
        liveRegion.textContent = `Selected ${parts[selectedIndex].value}. Press Enter to place.`;
      }
    } else if (ev.key === 'Enter') {
      ev.preventDefault();
      if (selectedIndex >= 0 && parts[selectedIndex]) {
        placePart(parts[selectedIndex]);
      } else {
        liveRegion.textContent = 'No part selected. Use the arrow keys to select a part.';
      }
    } else if (ev.key === 'Backspace' || ev.key === 'Delete') {
      ev.preventDefault();
      removeLastPlaced();
    } else if (ev.key.toLowerCase() === 'a') {
      ev.preventDefault();
      toggleAudio();
    } else if (ev.key.toLowerCase() === 'r') {
      ev.preventDefault();
      setupLevel(currentLevel);
      if (audioEnabled) playClick();
    } else if (ev.key === ' ' /* space */) {
      ev.preventDefault();
      // pick up selected part and toggle dragging via keyboard: simulate drop into machine when next press Enter or space?
      if (selectedIndex >= 0 && parts[selectedIndex]) {
        // place directly for simplicity
        placePart(parts[selectedIndex]);
      } else {
        liveRegion.textContent = 'Select a part first with arrow keys.';
      }
    }
  });

  // Focus canvas to receive keyboard default
  canvas.addEventListener('focus', () => {
    canvas.style.outline = '2px solid rgba(123,204,196,0.6)';
  });
  canvas.addEventListener('blur', () => {
    canvas.style.outline = 'none';
  });

  // Main animation loop
  let last = performance.now();
  function loop(now) {
    const dt = now - last;
    last = now;
    animationTime += dt;
    update(dt / 1000);
    render(animationTime * 0.06);
    requestAnimationFrame(loop);
  }

  function update(seconds) {
    // gentle return of parts to home if not dragged
    parts.forEach((p) => {
      if (!dragging || dragging.part !== p) {
        // ease towards home
        p.x += (p.homeX - p.x) * 0.06;
        p.y += (p.homeY - p.y) * 0.06;
      }
    });
    updateConfetti();
  }

  function render(t) {
    clear();
    drawSteam(t);
    drawMachine(t);
    drawParts(t);
    drawHudShadow();
    drawHUD();
    drawConfetti();

    // Visual "audio off" cue
    if (!audioEnabled) {
      ctx.fillStyle = 'rgba(231,76,60,0.06)';
      ctx.fillRect(WIDTH - 88, 6, 84, 40);
      ctx.fillStyle = '#E74C3C';
      ctx.font = '12px sans-serif';
      ctx.fillText('Audio Off', WIDTH - 84, 34);
    }

    // highlight selected part
    if (selectedIndex >= 0 && parts[selectedIndex]) {
      const p = parts[selectedIndex];
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius + 10, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(123,204,196,0.6)';
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    // overlay instructions when won
    if (won) {
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.fillRect(0, HEIGHT / 2 - 40, WIDTH, 80);
      ctx.fillStyle = '#2C3E50';
      ctx.font = 'bold 28px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Great job! Preparing next level...', WIDTH / 2, HEIGHT / 2 + 8);
      ctx.textAlign = 'start';
    }
  }

  function drawHudShadow() {
    // subtle shadow to separate UI
    ctx.fillStyle = 'rgba(0,0,0,0.02)';
    ctx.fillRect(16, 8, WIDTH - 32, 64);
  }

  // Initialize
  setupLevel(1);
  if (audioEnabled) {
    // do not auto-start audio until user gesture; but start hum if allowed
    // We'll start hum only after a user interaction; indicate that in live region
    liveRegion.textContent = 'Tap or interact to enable audio.';
    // Add a one-time user gesture listener to start audio if available
    const onFirstUse = () => {
      safeResumeAudio().then(() => {
        if (audioEnabled) startHum();
      });
      window.removeEventListener('pointerdown', onFirstUse);
      window.removeEventListener('keydown', onFirstUse);
    };
    window.addEventListener('pointerdown', onFirstUse);
    window.addEventListener('keydown', onFirstUse);
  } else {
    liveRegion.textContent = 'Audio is not available in this browser.';
  }

  // Start animation
  requestAnimationFrame(loop);

  // Helper: draw gear created earlier; exported if needed (kept local)
  // Expose a small public API on container for testing if necessary
  container._machineMathGame = {
    reset: () => setupLevel(1),
    nextLevel: () => setupLevel(currentLevel + 1),
  };

  // Error handling: basic window.onerror to capture and notify user via live region
  window.addEventListener('error', (evt) => {
    liveRegion.textContent = 'An error occurred in the game. Try reloading the page.';
    console.error('Game error:', evt.error || evt.message);
  });
})();
---

