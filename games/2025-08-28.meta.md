# Game of the Day - 2025-08-28

## Metadata
- **Generated Date:** 2025-08-28
- **Generated Time:** 2025-08-28T00:26:31.807722
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-08-28.js
- **File Size:** 24062 bytes
- **Tokens Used:** 8813

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: machines

The game must:
• Be fun.
• Be beatable.
• Be engaging, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-08-28.js` - The playable game
- `2025-08-28.meta.json` - Machine-readable metadata
- `2025-08-28.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 19147

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 22868

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function() {
  // Machine Math — Game of the Day
  // Designed for ages 7-9. Rendered entirely inside #game-of-the-day-stage as canvas.
  // All graphics are drawn on canvas. All sounds generated via Web Audio API.
  // Accessible: keyboard controls, aria-label, visible instructions, audio toggle.

  // Utility helpers
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const randInt = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;

  // Find container element
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Game container #game-of-the-day-stage not found.');
    return;
  }
  // Clear container
  container.innerHTML = '';

  // Create canvas and set accessibility attributes
  const canvas = document.createElement('canvas');
  canvas.width = 720;
  canvas.height = 480;
  canvas.style.display = 'block';
  canvas.setAttribute('role', 'application');
  canvas.setAttribute('aria-label', 'Machine Math game. Use arrow keys to change number. Press space or enter to submit. Press M to toggle sound.');
  canvas.tabIndex = 0; // focusable for keyboard
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Game area size requirement: 720 x 480 exactly
  canvas.style.width = '720px';
  canvas.style.height = '480px';

  // Fonts
  const mainFont = 'bold 18px sans-serif';
  const largeFont = 'bold 26px sans-serif';
  const smallFont = '14px sans-serif';

  // Audio setup with robust error handling
  let audioAllowed = true;
  let audioContext = null;
  let bgGain = null;
  let bgOsc = null;
  try {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  } catch (e) {
    console.warn('Web Audio API not available or blocked:', e);
    audioContext = null;
    audioAllowed = false;
  }

  // Function to ensure audio context resumed on user gesture
  async function ensureAudio() {
    if (!audioContext) return false;
    try {
      if (audioContext.state === 'suspended') {
        await audioContext.resume();
      }
      return true;
    } catch (e) {
      console.warn('Unable to resume AudioContext:', e);
      return false;
    }
  }

  // Background hum creation
  function startBackgroundHum() {
    if (!audioContext || !audioAllowed) return;
    try {
      stopBackgroundHum();
      bgOsc = audioContext.createOscillator();
      const lfo = audioContext.createOscillator();
      const lfoGain = audioContext.createGain();
      bgGain = audioContext.createGain();

      bgOsc.type = 'sine';
      bgOsc.frequency.value = 110; // low hum
      bgGain.gain.value = 0.02; // gentle

      lfo.type = 'sine';
      lfo.frequency.value = 0.25; // slow wobble
      lfoGain.gain.value = 8; // vibrato depth in Hz

      lfo.connect(lfoGain);
      lfoGain.connect(bgOsc.frequency);
      bgOsc.connect(bgGain);
      bgGain.connect(audioContext.destination);

      lfo.start();
      bgOsc.start();
    } catch (e) {
      console.warn('Error starting background hum:', e);
    }
  }

  function stopBackgroundHum() {
    try {
      if (bgOsc) {
        bgOsc.stop();
        bgOsc.disconnect();
        bgOsc = null;
      }
      if (bgGain) {
        bgGain.disconnect();
        bgGain = null;
      }
    } catch (e) {
      console.warn('Error stopping background hum:', e);
    }
  }

  // Correct sound: small cheerful chord
  function playCorrect() {
    if (!audioContext || !audioAllowed) return;
    try {
      const now = audioContext.currentTime;
      const freqs = [660, 880, 990]; // simple triad
      const master = audioContext.createGain();
      master.gain.setValueAtTime(0.0001, now);
      master.gain.exponentialRampToValueAtTime(0.18, now + 0.02);
      master.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);

      freqs.forEach((f, i) => {
        const o = audioContext.createOscillator();
        const g = audioContext.createGain();
        o.type = i === 1 ? 'triangle' : 'sine';
        o.frequency.value = f;
        g.gain.setValueAtTime(0.0001, now);
        g.gain.exponentialRampToValueAtTime(0.08, now + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);
        o.connect(g);
        g.connect(master);
        o.start(now);
        o.stop(now + 0.62);
      });
      master.connect(audioContext.destination);
      // disconnect master after done
      setTimeout(() => {
        try { master.disconnect(); } catch(e){}
      }, 700);
    } catch (e) {
      console.warn('Error playing correct sound:', e);
    }
  }

  // Incorrect sound: short buzz
  function playIncorrect() {
    if (!audioContext || !audioAllowed) return;
    try {
      const now = audioContext.currentTime;
      const o = audioContext.createOscillator();
      const g = audioContext.createGain();
      const f = 220;
      o.type = 'square';
      o.frequency.value = f;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.16, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);
      o.connect(g);
      // low-pass filter to soften
      const filt = audioContext.createBiquadFilter();
      filt.type = 'lowpass';
      filt.frequency.value = 900;
      g.connect(filt);
      filt.connect(audioContext.destination);
      o.start(now);
      o.stop(now + 0.6);
      setTimeout(() => {
        try { g.disconnect(); filt.disconnect(); } catch(e){}
      }, 700);
    } catch (e) {
      console.warn('Error playing incorrect sound:', e);
    }
  }

  // Visual and UI elements
  let gameState = {
    round: 0,
    totalRounds: 6,
    score: 0,
    target: 0,
    current: 0,
    needed: 0, // positive => add, negative => remove
    playerChoice: 0,
    message: 'Welcome! Press Space or Enter to start the first round.',
    busy: false, // prevents input during animations
    audioOn: audioAllowed,
    lastFeedback: null, // 'correct' or 'incorrect' for visuals
    lastActionTime: 0
  };

  // Buttons / interactive hit areas
  const ui = {
    plus: { x: 520, y: 360, w: 44, h: 44 },
    minus: { x: 460, y: 360, w: 44, h: 44 },
    submit: { x: 580, y: 360, w: 100, h: 44 },
    next: { x: 580, y: 420, w: 100, h: 36 },
    audioToggle: { x: 680, y: 10, w: 30, h: 30 }
  };

  // Keyboard handling
  const keys = {};

  function initNewRound() {
    gameState.round += 1;
    gameState.busy = false;
    gameState.lastFeedback = null;
    gameState.lastActionTime = Date.now();
    // Generate challenge that practices addition or subtraction
    // For variety: allow both add and remove rounds
    const isAdd = Math.random() > 0.25; // usually add but sometimes remove
    if (isAdd) {
      gameState.target = randInt(6, 15);
      gameState.current = randInt(0, Math.max(0, gameState.target - 1));
    } else {
      // Make a remove round: current > target
      gameState.target = randInt(2, 10);
      gameState.current = randInt(gameState.target + 1, gameState.target + 6);
    }
    gameState.needed = gameState.target - gameState.current;
    // Player choice default: 0 for add, but for remove rounds maybe start at 0 as well
    gameState.playerChoice = Math.abs(gameState.needed) > 0 ? Math.abs(gameState.needed) : 1;
    gameState.message = `Round ${gameState.round} of ${gameState.totalRounds}. Help the machine!`;
  }

  // Start the game
  function startGame() {
    gameState.round = 0;
    gameState.score = 0;
    gameState.message = 'Get ready! Press Space or Enter to begin.';
  }

  startGame();

  // Draw helper: draw a wacky gear
  function drawGear(ctx, cx, cy, radius, teeth = 8, color = '#e2b04a', stroke = '#8b5a12') {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.fillStyle = color;
    ctx.strokeStyle = stroke;
    ctx.lineWidth = 2;
    // Draw gear with simple teeth using arc segments
    ctx.beginPath();
    const inner = radius * 0.65;
    for (let i = 0; i < teeth * 2; i++) {
      const angle = (i / (teeth * 2)) * Math.PI * 2;
      const r = (i % 2 === 0) ? radius : inner;
      const x = Math.cos(angle) * r;
      const y = Math.sin(angle) * r;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // center hole
    ctx.beginPath();
    ctx.fillStyle = '#fff';
    ctx.arc(0, 0, radius * 0.32, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  // Draw the wacky mechanic characters
  function drawCharacters(ctx) {
    // Gizmo (mechanic) left
    ctx.save();
    ctx.translate(60, 120);
    // body
    ctx.fillStyle = '#7fb0de';
    ctx.fillRect(-36, -20, 72, 80);
    // head
    ctx.beginPath();
    ctx.arc(0, -40, 28, 0, Math.PI * 2);
    ctx.fillStyle = '#ffd89b';
    ctx.fill();
    // goggles
    ctx.fillStyle = '#333';
    ctx.fillRect(-20, -44, 16, 12);
    ctx.fillRect(4, -44, 16, 12);
    ctx.fillStyle = '#fff';
    ctx.fillRect(-16, -42, 8, 8);
    ctx.fillRect(8, -42, 8, 8);
    // smile
    ctx.beginPath();
    ctx.strokeStyle = '#b24b4b';
    ctx.lineWidth = 2;
    ctx.arc(0, -34, 10, 0, Math.PI);
    ctx.stroke();
    // hat
    ctx.fillStyle = '#d95a9b';
    ctx.fillRect(-30, -68, 60, 14);
    ctx.restore();

    // Bolt the robot on right
    ctx.save();
    ctx.translate(620, 130);
    // head
    ctx.fillStyle = '#dfe7ea';
    ctx.beginPath();
    ctx.arc(0, -30, 30, 0, Math.PI * 2);
    ctx.fill();
    // one eye
    ctx.fillStyle = '#222';
    ctx.beginPath();
    ctx.arc(-10, -30, 6, 0, Math.PI * 2);
    ctx.fill();
    // smiling speaker
    ctx.fillStyle = '#b6d8c9';
    ctx.fillRect(-22, -6, 44, 56);
    // antenna
    ctx.beginPath();
    ctx.moveTo(0, -58);
    ctx.lineTo(0, -70);
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 3;
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(0, -74, 4, 0, Math.PI * 2);
    ctx.fillStyle = '#ffd166';
    ctx.fill();
    ctx.restore();
  }

  // Draw machine and gears (show current count)
  function drawMachine(ctx, x, y, w, h) {
    // Machine body
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = '#cfe6d6';
    ctx.fillRect(0, 0, w, h);
    // Pipes and cute details
    ctx.fillStyle = '#8fbfbe';
    ctx.fillRect(-20, 10, 20, h - 20);
    ctx.fillRect(w, 10, 24, h - 20);

    // window
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fillRect(18, 18, w - 36, h - 36);
    ctx.strokeStyle = '#9fc8c1';
    ctx.strokeRect(18, 18, w - 36, h - 36);

    // Draw gear slots inside window based on current count
    const cols = 6;
    const rows = 2;
    const slotW = (w - 60) / cols;
    const slotH = (h - 60) / rows;
    let count = gameState.current;
    let idx = 0;
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const cx = 18 + 30 + c * slotW + slotW / 2;
        const cy = 18 + 30 + r * slotH + slotH / 2;
        // Draw slot background
        ctx.beginPath();
        ctx.fillStyle = '#f2f2f2';
        ctx.fillRect(cx - 18, cy - 18, 36, 36);
        ctx.strokeStyle = '#d1d1d1';
        ctx.strokeRect(cx - 18, cy - 18, 36, 36);
        if (idx < gameState.current) {
          // draw small gear
          drawGear(ctx, cx, cy, 14, 8, '#e2b04a', '#8b5a12');
        }
        idx++;
      }
    }
    ctx.restore();

    // Shows numerical current/target
    ctx.save();
    ctx.font = largeFont;
    ctx.fillStyle = '#2b2b2b';
    ctx.fillText(`Machine: ${gameState.current} / ${gameState.target} gears`, x + 12, y + h + 28);
    ctx.restore();
  }

  // Draw UI controls: plus, minus, submit, audio icon, messages
  function drawUI(ctx) {
    // Panel background
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    roundRect(ctx, 420, 300, 280, 150, 12, true, false);
    // Title and instructions
    ctx.font = mainFont;
    ctx.fillStyle = '#2b2b2b';
    ctx.fillText('Gizmo\'s Gear Picker', 440, 330);

    // Operation text depending on add or remove
    const needed = gameState.needed;
    let task = '';
    if (needed > 0) {
      task = `Add ${needed} gears to reach ${gameState.target}.`;
    } else if (needed < 0) {
      task = `Remove ${Math.abs(needed)} gears to reach ${gameState.target}.`;
    } else {
      task = `Machine already has ${gameState.target} gears. Submit 0 to keep it steady.`;
    }
    ctx.font = smallFont;
    ctx.fillText(task, 440, 352);

    // Draw plus button
    drawButton(ctx, ui.minus.x, ui.minus.y, ui.minus.w, ui.minus.h, '-', '#f07b81');
    drawButton(ctx, ui.plus.x, ui.plus.y, ui.plus.w, ui.plus.h, '+', '#88d07a');

    // Player choice display
    ctx.font = largeFont;
    ctx.fillStyle = '#222';
    ctx.fillText(String(gameState.playerChoice), 510, 392);

    // Submit button
    drawButton(ctx, ui.submit.x, ui.submit.y, ui.submit.w, ui.submit.h, 'Insert', '#68a0ff');

    // Next button (appears after feedback)
    if (gameState.lastFeedback) {
      drawButton(ctx, ui.next.x, ui.next.y, ui.next.w, ui.next.h, 'Next', '#ffd166');
    }

    // Audio toggle icon
    drawAudioIcon(ctx, ui.audioToggle.x, ui.audioToggle.y, ui.audioToggle.w, ui.audioToggle.h, gameState.audioOn);

    // Message box
    ctx.font = smallFont;
    ctx.fillStyle = '#111';
    ctx.fillText(gameState.message, 440, 448);
    ctx.restore();
  }

  function drawAudioIcon(ctx, x, y, w, h, on) {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = on ? '#7ef0a6' : '#e0e0e0';
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    // speaker body
    ctx.moveTo(4, 6);
    ctx.lineTo(10, 6);
    ctx.lineTo(16, 2);
    ctx.lineTo(16, 28);
    ctx.lineTo(10, 24);
    ctx.lineTo(4, 24);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    if (on) {
      // draw waves
      ctx.beginPath();
      ctx.strokeStyle = '#086c4c';
      ctx.lineWidth = 2;
      ctx.arc(20, 16, 8, -0.6, 0.6);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(24, 16, 12, -0.6, 0.6);
      ctx.stroke();
    } else {
      ctx.beginPath();
      ctx.moveTo(20, 8);
      ctx.lineTo(28, 24);
      ctx.strokeStyle = '#b84b4b';
      ctx.lineWidth = 3;
      ctx.stroke();
    }
    ctx.restore();
  }

  // Round rect helper
  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  function drawButton(ctx, x, y, w, h, text, color) {
    ctx.save();
    ctx.fillStyle = color;
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    roundRect(ctx, x, y, w, h, 8, true, true);
    ctx.fillStyle = '#111';
    ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, x + w / 2, y + h / 2);
    ctx.restore();
  }

  // Visual feedback overlay for correct/incorrect
  function drawFeedback(ctx) {
    if (!gameState.lastFeedback) return;
    const elapsed = Date.now() - gameState.lastActionTime;
    if (elapsed > 1800) {
      // clear feedback after time
      gameState.lastFeedback = null;
      return;
    }
    ctx.save();
    if (gameState.lastFeedback === 'correct') {
      // green glow
      ctx.fillStyle = `rgba(120,220,140,${0.35 - elapsed / 1800 * 0.35})`;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      // sparkling gears
      for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2 + (elapsed / 900);
        const cx = 360 + Math.cos(angle) * 180;
        const cy = 240 + Math.sin(angle) * 120;
        drawGear(ctx, cx, cy, 8 + (i % 3), 8, '#fff3b0', '#b07a16');
      }
    } else {
      // red tint for incorrect
      ctx.fillStyle = `rgba(220,100,100,${0.28 - elapsed / 1800 * 0.28})`;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      // wobble the machine slightly
      const dx = Math.sin(elapsed / 80) * 8;
      drawWobbleCross(ctx, canvas.width / 2 + dx, canvas.height / 2);
    }
    ctx.restore();
  }

  function drawWobbleCross(ctx, cx, cy) {
    ctx.save();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(cx - 12, cy - 12);
    ctx.lineTo(cx + 12, cy + 12);
    ctx.moveTo(cx + 12, cy - 12);
    ctx.lineTo(cx - 12, cy + 12);
    ctx.stroke();
    ctx.restore();
  }

  // Main draw loop
  function draw() {
    // Clear background with calming gradient
    const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
    g.addColorStop(0, '#f0f7fb');
    g.addColorStop(1, '#e6f0ee');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Decorative floating pipes/gears
    for (let i = 0; i < 6; i++) {
      const x = 120 + i * 90;
      const y = 60 + Math.sin((Date.now() / 800) + i) * 8;
      drawGear(ctx, x, y, 14, 8, '#c7d6f5', '#8b9ad1');
    }

    // Draw characters and machine
    drawCharacters(ctx);
    drawMachine(ctx, 120, 120, 280, 200);

    // UI area
    drawUI(ctx);

    // Feedback overlay if needed
    drawFeedback(ctx);

    // Focus hint
    ctx.save();
    ctx.font = smallFont;
    ctx.fillStyle = '#333';
    ctx.fillText('Keyboard: ↑/→ increase, ↓/← decrease, Enter/Space submit, M toggle sound', 10, 470);
    ctx.restore();

    requestAnimationFrame(draw);
  }

  // Input handling: mouse clicks
  canvas.addEventListener('mousedown', async (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    // Ensure audio resume on first interaction if blocked
    if (audioContext && audioContext.state === 'suspended') {
      await ensureAudio();
    }

    // Audio toggle
    if (hitTest(mx, my, ui.audioToggle)) {
      toggleAudio();
      return;
    }

    // ignore input if busy animating
    if (gameState.busy) return;

    if (hitTest(mx, my, ui.plus)) {
      changePlayerChoice(1);
      return;
    }
    if (hitTest(mx, my, ui.minus)) {
      changePlayerChoice(-1);
      return;
    }
    if (hitTest(mx, my, ui.submit)) {
      submitChoice();
      return;
    }
    if (gameState.lastFeedback && hitTest(mx, my, ui.next)) {
      if (gameState.round >= gameState.totalRounds) {
        // End of game, reset
        gameState.message = `Game complete! Score: ${gameState.score}/${gameState.totalRounds}. Press Space to play again.`;
        gameState.lastFeedback = null;
      } else {
        initNewRound();
      }
      return;
    }

    // Click on machine area to give focus to canvas for keyboard control
    canvas.focus();
  });

  function hitTest(mx, my, rect) {
    return mx >= rect.x && mx <= rect.x + rect.w && my >= rect.y && my <= rect.y + rect.h;
  }

  // Keyboard input handling
  canvas.addEventListener('keydown', async (e) => {
    // resume audio on first user gesture if suspended
    if (audioContext && audioContext.state === 'suspended') {
      await ensureAudio();
    }

    if (gameState.busy) {
      // allow toggling audio even when busy
      if (e.key.toLowerCase() === 'm') {
        toggleAudio();
      }
      return;
    }

    if (e.key === 'ArrowUp' || e.key === 'ArrowRight') {
      changePlayerChoice(1);
      e.preventDefault();
    } else if (e.key === 'ArrowDown' || e.key === 'ArrowLeft') {
      changePlayerChoice(-1);
      e.preventDefault();
    } else if (e.key === 'Enter' || e.key === ' ') {
      submitChoice();
      e.preventDefault();
    } else if (e.key.toLowerCase() === 'm') {
      toggleAudio();
      e.preventDefault();
    } else if (e.key.toLowerCase() === 'n') {
      if (gameState.lastFeedback) {
        if (gameState.round >= gameState.totalRounds) {
          gameState.message = `Game complete! Score: ${gameState.score}/${gameState.totalRounds}. Press Space to play again.`;
          gameState.lastFeedback = null;
        } else {
          initNewRound();
        }
      }
    } else if (e.key.toLowerCase() === 's') {
      // Start game shortcut
      if (gameState.round === 0) {
        initNewRound();
      }
    }
  });

  function changePlayerChoice(delta) {
    gameState.playerChoice = clamp(gameState.playerChoice + delta, 0, 12);
    gameState.message = `You chose ${gameState.playerChoice}. Press Enter or Insert to try it.`;
  }

  // Submission and checking
  function submitChoice() {
    if (gameState.round === 0) {
      // start first round
      initNewRound();
      return;
    }
    if (gameState.busy) return;
    const player = gameState.playerChoice;
    // Determine expected value
    const expected = Math.abs(gameState.needed);
    gameState.busy = true;
    if (player === expected) {
      // Correct — animate adding or removing gears
      gameState.message = 'Nice! Gizmo fixed the machine!';
      gameState.score += 1;
      gameState.lastFeedback = 'correct';
      gameState.lastActionTime = Date.now();
      if (gameState.audioOn) playCorrect();
      // animate changing current to target
      const steps = 12;
      const start = gameState.current;
      const delta = gameState.target - gameState.current;
      let i = 0;
      const anim = setInterval(() => {
        i++;
        gameState.current = Math.round(start + (delta * i) / steps);
        if (i >= steps) {
          clearInterval(anim);
          gameState.current = gameState.target;
          gameState.busy = false;
          // show next button or finish
          if (gameState.round >= gameState.totalRounds) {
            gameState.message = `Great work! Final score ${gameState.score}/${gameState.totalRounds}. Press Space to play again.`;
          } else {
            gameState.message = 'Press Next to continue.';
          }
        }
      }, 60);
    } else {
      // Incorrect
      gameState.message = `Oops. Try again or press Next for another machine.`;
      gameState.lastFeedback = 'incorrect';
      gameState.lastActionTime = Date.now();
      if (gameState.audioOn) playIncorrect();
      // small shake animation to indicate wrong
      const start = gameState.current;
      const t0 = Date.now();
      const dur = 600;
      let animId = setInterval(() => {
        const t = Date.now() - t0;
        if (t > dur) {
          clearInterval(animId);
          gameState.busy = false;
        }
      }, 50);
      // allow attempt again — do not change current
      gameState.busy = false;
    }
  }

  function toggleAudio() {
    gameState.audioOn = !gameState.audioOn;
    if (gameState.audioOn) {
      // Attempt to start audio if possible
      ensureAudio().then((ok) => {
        if (!ok) {
          gameState.audioOn = false;
          gameState.message = 'Audio unavailable in this browser. Muted.';
        } else {
          startBackgroundHum();
          gameState.message = 'Audio enabled.';
        }
      });
    } else {
      stopBackgroundHum();
      gameState.message = 'Audio muted (press M to enable).';
    }
  }

  // Start background hum if audio initially allowed
  if (audioContext && gameState.audioOn) {
    // Some browsers require resume on gesture; we still try
    ensureAudio().then((ok) => {
      if (ok) startBackgroundHum();
      else gameState.audioOn = false;
    });
  }

  // Click handler to support clicking "Enter" semantics when a DOM caret / keyboard focus
  // Also support spacebar to start new round when game awaits
  window.addEventListener('keydown', (e) => {
    // Global: if space pressed and on final screen to restart
    if ((e.code === 'Space' || e.key === ' ') && gameState.round >= gameState.totalRounds && !gameState.lastFeedback) {
      // reset game
      startGame();
      canvas.focus();
    }
  });

  // Provide initial message drawn
  requestAnimationFrame(draw);

  // Safety: in case audio fails later, ensure errors are caught
  window.addEventListener('unhandledrejection', function(evt) {
    console.warn('Unhandled promise rejection in game:', evt.reason);
  });

  // Expose some functions for debugging on canvas dataset (not necessary but safe)
  canvas.dataset.gameVersion = 'machine-math-1.0';

})();
---

