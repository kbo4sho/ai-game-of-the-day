{
  "generated_date": "2025-08-28",
  "generated_timestamp": "2025-08-28T00:26:31.807722",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: machines\n\nThe game must:\n\u2022 Be fun.\n\u2022 Be beatable.\n\u2022 Be engaging, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8813,
  "game_filename": "2025-08-28.js",
  "game_size_bytes": 24062,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function() {\n  // Machine Math \u2014 Game of the Day\n  // Designed for ages 7-9. Rendered entirely inside #game-of-the-day-stage as canvas.\n  // All graphics are drawn on canvas. All sounds generated via Web Audio API.\n  // Accessible: keyboard controls, aria-label, visible instructions, audio toggle.\n\n  // Utility helpers\n  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));\n  const randInt = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;\n\n  // Find container element\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Game container #game-of-the-day-stage not found.');\n    return;\n  }\n  // Clear container\n  container.innerHTML = '';\n\n  // Create canvas and set accessibility attributes\n  const canvas = document.createElement('canvas');\n  canvas.width = 720;\n  canvas.height = 480;\n  canvas.style.display = 'block';\n  canvas.setAttribute('role', 'application');\n  canvas.setAttribute('aria-label', 'Machine Math game. Use arrow keys to change number. Press space or enter to submit. Press M to toggle sound.');\n  canvas.tabIndex = 0; // focusable for keyboard\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Game area size requirement: 720 x 480 exactly\n  canvas.style.width = '720px';\n  canvas.style.height = '480px';\n\n  // Fonts\n  const mainFont = 'bold 18px sans-serif';\n  const largeFont = 'bold 26px sans-serif';\n  const smallFont = '14px sans-serif';\n\n  // Audio setup with robust error handling\n  let audioAllowed = true;\n  let audioContext = null;\n  let bgGain = null;\n  let bgOsc = null;\n  try {\n    audioContext = new (window.AudioContext || window.webkitAudioContext)();\n  } catch (e) {\n    console.warn('Web Audio API not available or blocked:', e);\n    audioContext = null;\n    audioAllowed = false;\n  }\n\n  // Function to ensure audio context resumed on user gesture\n  async function ensureAudio() {\n    if (!audioContext) return false;\n    try {\n      if (audioContext.state === 'suspended') {\n        await audioContext.resume();\n      }\n      return true;\n    } catch (e) {\n      console.warn('Unable to resume AudioContext:', e);\n      return false;\n    }\n  }\n\n  // Background hum creation\n  function startBackgroundHum() {\n    if (!audioContext || !audioAllowed) return;\n    try {\n      stopBackgroundHum();\n      bgOsc = audioContext.createOscillator();\n      const lfo = audioContext.createOscillator();\n      const lfoGain = audioContext.createGain();\n      bgGain = audioContext.createGain();\n\n      bgOsc.type = 'sine';\n      bgOsc.frequency.value = 110; // low hum\n      bgGain.gain.value = 0.02; // gentle\n\n      lfo.type = 'sine';\n      lfo.frequency.value = 0.25; // slow wobble\n      lfoGain.gain.value = 8; // vibrato depth in Hz\n\n      lfo.connect(lfoGain);\n      lfoGain.connect(bgOsc.frequency);\n      bgOsc.connect(bgGain);\n      bgGain.connect(audioContext.destination);\n\n      lfo.start();\n      bgOsc.start();\n    } catch (e) {\n      console.warn('Error starting background hum:', e);\n    }\n  }\n\n  function stopBackgroundHum() {\n    try {\n      if (bgOsc) {\n        bgOsc.stop();\n        bgOsc.disconnect();\n        bgOsc = null;\n      }\n      if (bgGain) {\n        bgGain.disconnect();\n        bgGain = null;\n      }\n    } catch (e) {\n      console.warn('Error stopping background hum:', e);\n    }\n  }\n\n  // Correct sound: small cheerful chord\n  function playCorrect() {\n    if (!audioContext || !audioAllowed) return;\n    try {\n      const now = audioContext.currentTime;\n      const freqs = [660, 880, 990]; // simple triad\n      const master = audioContext.createGain();\n      master.gain.setValueAtTime(0.0001, now);\n      master.gain.exponentialRampToValueAtTime(0.18, now + 0.02);\n      master.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);\n\n      freqs.forEach((f, i) => {\n        const o = audioContext.createOscillator();\n        const g = audioContext.createGain();\n        o.type = i === 1 ? 'triangle' : 'sine';\n        o.frequency.value = f;\n        g.gain.setValueAtTime(0.0001, now);\n        g.gain.exponentialRampToValueAtTime(0.08, now + 0.02);\n        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);\n        o.connect(g);\n        g.connect(master);\n        o.start(now);\n        o.stop(now + 0.62);\n      });\n      master.connect(audioContext.destination);\n      // disconnect master after done\n      setTimeout(() => {\n        try { master.disconnect(); } catch(e){}\n      }, 700);\n    } catch (e) {\n      console.warn('Error playing correct sound:', e);\n    }\n  }\n\n  // Incorrect sound: short buzz\n  function playIncorrect() {\n    if (!audioContext || !audioAllowed) return;\n    try {\n      const now = audioContext.currentTime;\n      const o = audioContext.createOscillator();\n      const g = audioContext.createGain();\n      const f = 220;\n      o.type = 'square';\n      o.frequency.value = f;\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(0.16, now + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);\n      o.connect(g);\n      // low-pass filter to soften\n      const filt = audioContext.createBiquadFilter();\n      filt.type = 'lowpass';\n      filt.frequency.value = 900;\n      g.connect(filt);\n      filt.connect(audioContext.destination);\n      o.start(now);\n      o.stop(now + 0.6);\n      setTimeout(() => {\n        try { g.disconnect(); filt.disconnect(); } catch(e){}\n      }, 700);\n    } catch (e) {\n      console.warn('Error playing incorrect sound:', e);\n    }\n  }\n\n  // Visual and UI elements\n  let gameState = {\n    round: 0,\n    totalRounds: 6,\n    score: 0,\n    target: 0,\n    current: 0,\n    needed: 0, // positive => add, negative => remove\n    playerChoice: 0,\n    message: 'Welcome! Press Space or Enter to start the first round.',\n    busy: false, // prevents input during animations\n    audioOn: audioAllowed,\n    lastFeedback: null, // 'correct' or 'incorrect' for visuals\n    lastActionTime: 0\n  };\n\n  // Buttons / interactive hit areas\n  const ui = {\n    plus: { x: 520, y: 360, w: 44, h: 44 },\n    minus: { x: 460, y: 360, w: 44, h: 44 },\n    submit: { x: 580, y: 360, w: 100, h: 44 },\n    next: { x: 580, y: 420, w: 100, h: 36 },\n    audioToggle: { x: 680, y: 10, w: 30, h: 30 }\n  };\n\n  // Keyboard handling\n  const keys = {};\n\n  function initNewRound() {\n    gameState.round += 1;\n    gameState.busy = false;\n    gameState.lastFeedback = null;\n    gameState.lastActionTime = Date.now();\n    // Generate challenge that practices addition or subtraction\n    // For variety: allow both add and remove rounds\n    const isAdd = Math.random() > 0.25; // usually add but sometimes remove\n    if (isAdd) {\n      gameState.target = randInt(6, 15);\n      gameState.current = randInt(0, Math.max(0, gameState.target - 1));\n    } else {\n      // Make a remove round: current > target\n      gameState.target = randInt(2, 10);\n      gameState.current = randInt(gameState.target + 1, gameState.target + 6);\n    }\n    gameState.needed = gameState.target - gameState.current;\n    // Player choice default: 0 for add, but for remove rounds maybe start at 0 as well\n    gameState.playerChoice = Math.abs(gameState.needed) > 0 ? Math.abs(gameState.needed) : 1;\n    gameState.message = `Round ${gameState.round} of ${gameState.totalRounds}. Help the machine!`;\n  }\n\n  // Start the game\n  function startGame() {\n    gameState.round = 0;\n    gameState.score = 0;\n    gameState.message = 'Get ready! Press Space or Enter to begin.';\n  }\n\n  startGame();\n\n  // Draw helper: draw a wacky gear\n  function drawGear(ctx, cx, cy, radius, teeth = 8, color = '#e2b04a', stroke = '#8b5a12') {\n    ctx.save();\n    ctx.translate(cx, cy);\n    ctx.fillStyle = color;\n    ctx.strokeStyle = stroke;\n    ctx.lineWidth = 2;\n    // Draw gear with simple teeth using arc segments\n    ctx.beginPath();\n    const inner = radius * 0.65;\n    for (let i = 0; i < teeth * 2; i++) {\n      const angle = (i / (teeth * 2)) * Math.PI * 2;\n      const r = (i % 2 === 0) ? radius : inner;\n      const x = Math.cos(angle) * r;\n      const y = Math.sin(angle) * r;\n      if (i === 0) ctx.moveTo(x, y);\n      else ctx.lineTo(x, y);\n    }\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n\n    // center hole\n    ctx.beginPath();\n    ctx.fillStyle = '#fff';\n    ctx.arc(0, 0, radius * 0.32, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  // Draw the wacky mechanic characters\n  function drawCharacters(ctx) {\n    // Gizmo (mechanic) left\n    ctx.save();\n    ctx.translate(60, 120);\n    // body\n    ctx.fillStyle = '#7fb0de';\n    ctx.fillRect(-36, -20, 72, 80);\n    // head\n    ctx.beginPath();\n    ctx.arc(0, -40, 28, 0, Math.PI * 2);\n    ctx.fillStyle = '#ffd89b';\n    ctx.fill();\n    // goggles\n    ctx.fillStyle = '#333';\n    ctx.fillRect(-20, -44, 16, 12);\n    ctx.fillRect(4, -44, 16, 12);\n    ctx.fillStyle = '#fff';\n    ctx.fillRect(-16, -42, 8, 8);\n    ctx.fillRect(8, -42, 8, 8);\n    // smile\n    ctx.beginPath();\n    ctx.strokeStyle = '#b24b4b';\n    ctx.lineWidth = 2;\n    ctx.arc(0, -34, 10, 0, Math.PI);\n    ctx.stroke();\n    // hat\n    ctx.fillStyle = '#d95a9b';\n    ctx.fillRect(-30, -68, 60, 14);\n    ctx.restore();\n\n    // Bolt the robot on right\n    ctx.save();\n    ctx.translate(620, 130);\n    // head\n    ctx.fillStyle = '#dfe7ea';\n    ctx.beginPath();\n    ctx.arc(0, -30, 30, 0, Math.PI * 2);\n    ctx.fill();\n    // one eye\n    ctx.fillStyle = '#222';\n    ctx.beginPath();\n    ctx.arc(-10, -30, 6, 0, Math.PI * 2);\n    ctx.fill();\n    // smiling speaker\n    ctx.fillStyle = '#b6d8c9';\n    ctx.fillRect(-22, -6, 44, 56);\n    // antenna\n    ctx.beginPath();\n    ctx.moveTo(0, -58);\n    ctx.lineTo(0, -70);\n    ctx.strokeStyle = '#333';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.arc(0, -74, 4, 0, Math.PI * 2);\n    ctx.fillStyle = '#ffd166';\n    ctx.fill();\n    ctx.restore();\n  }\n\n  // Draw machine and gears (show current count)\n  function drawMachine(ctx, x, y, w, h) {\n    // Machine body\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.fillStyle = '#cfe6d6';\n    ctx.fillRect(0, 0, w, h);\n    // Pipes and cute details\n    ctx.fillStyle = '#8fbfbe';\n    ctx.fillRect(-20, 10, 20, h - 20);\n    ctx.fillRect(w, 10, 24, h - 20);\n\n    // window\n    ctx.beginPath();\n    ctx.fillStyle = 'rgba(255,255,255,0.3)';\n    ctx.fillRect(18, 18, w - 36, h - 36);\n    ctx.strokeStyle = '#9fc8c1';\n    ctx.strokeRect(18, 18, w - 36, h - 36);\n\n    // Draw gear slots inside window based on current count\n    const cols = 6;\n    const rows = 2;\n    const slotW = (w - 60) / cols;\n    const slotH = (h - 60) / rows;\n    let count = gameState.current;\n    let idx = 0;\n    for (let r = 0; r < rows; r++) {\n      for (let c = 0; c < cols; c++) {\n        const cx = 18 + 30 + c * slotW + slotW / 2;\n        const cy = 18 + 30 + r * slotH + slotH / 2;\n        // Draw slot background\n        ctx.beginPath();\n        ctx.fillStyle = '#f2f2f2';\n        ctx.fillRect(cx - 18, cy - 18, 36, 36);\n        ctx.strokeStyle = '#d1d1d1';\n        ctx.strokeRect(cx - 18, cy - 18, 36, 36);\n        if (idx < gameState.current) {\n          // draw small gear\n          drawGear(ctx, cx, cy, 14, 8, '#e2b04a', '#8b5a12');\n        }\n        idx++;\n      }\n    }\n    ctx.restore();\n\n    // Shows numerical current/target\n    ctx.save();\n    ctx.font = largeFont;\n    ctx.fillStyle = '#2b2b2b';\n    ctx.fillText(`Machine: ${gameState.current} / ${gameState.target} gears`, x + 12, y + h + 28);\n    ctx.restore();\n  }\n\n  // Draw UI controls: plus, minus, submit, audio icon, messages\n  function drawUI(ctx) {\n    // Panel background\n    ctx.save();\n    ctx.fillStyle = 'rgba(255,255,255,0.6)';\n    roundRect(ctx, 420, 300, 280, 150, 12, true, false);\n    // Title and instructions\n    ctx.font = mainFont;\n    ctx.fillStyle = '#2b2b2b';\n    ctx.fillText('Gizmo\\'s Gear Picker', 440, 330);\n\n    // Operation text depending on add or remove\n    const needed = gameState.needed;\n    let task = '';\n    if (needed > 0) {\n      task = `Add ${needed} gears to reach ${gameState.target}.`;\n    } else if (needed < 0) {\n      task = `Remove ${Math.abs(needed)} gears to reach ${gameState.target}.`;\n    } else {\n      task = `Machine already has ${gameState.target} gears. Submit 0 to keep it steady.`;\n    }\n    ctx.font = smallFont;\n    ctx.fillText(task, 440, 352);\n\n    // Draw plus button\n    drawButton(ctx, ui.minus.x, ui.minus.y, ui.minus.w, ui.minus.h, '-', '#f07b81');\n    drawButton(ctx, ui.plus.x, ui.plus.y, ui.plus.w, ui.plus.h, '+', '#88d07a');\n\n    // Player choice display\n    ctx.font = largeFont;\n    ctx.fillStyle = '#222';\n    ctx.fillText(String(gameState.playerChoice), 510, 392);\n\n    // Submit button\n    drawButton(ctx, ui.submit.x, ui.submit.y, ui.submit.w, ui.submit.h, 'Insert', '#68a0ff');\n\n    // Next button (appears after feedback)\n    if (gameState.lastFeedback) {\n      drawButton(ctx, ui.next.x, ui.next.y, ui.next.w, ui.next.h, 'Next', '#ffd166');\n    }\n\n    // Audio toggle icon\n    drawAudioIcon(ctx, ui.audioToggle.x, ui.audioToggle.y, ui.audioToggle.w, ui.audioToggle.h, gameState.audioOn);\n\n    // Message box\n    ctx.font = smallFont;\n    ctx.fillStyle = '#111';\n    ctx.fillText(gameState.message, 440, 448);\n    ctx.restore();\n  }\n\n  function drawAudioIcon(ctx, x, y, w, h, on) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.fillStyle = on ? '#7ef0a6' : '#e0e0e0';\n    ctx.strokeStyle = '#333';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    // speaker body\n    ctx.moveTo(4, 6);\n    ctx.lineTo(10, 6);\n    ctx.lineTo(16, 2);\n    ctx.lineTo(16, 28);\n    ctx.lineTo(10, 24);\n    ctx.lineTo(4, 24);\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n    if (on) {\n      // draw waves\n      ctx.beginPath();\n      ctx.strokeStyle = '#086c4c';\n      ctx.lineWidth = 2;\n      ctx.arc(20, 16, 8, -0.6, 0.6);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.arc(24, 16, 12, -0.6, 0.6);\n      ctx.stroke();\n    } else {\n      ctx.beginPath();\n      ctx.moveTo(20, 8);\n      ctx.lineTo(28, 24);\n      ctx.strokeStyle = '#b84b4b';\n      ctx.lineWidth = 3;\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  // Round rect helper\n  function roundRect(ctx, x, y, w, h, r, fill, stroke) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  function drawButton(ctx, x, y, w, h, text, color) {\n    ctx.save();\n    ctx.fillStyle = color;\n    ctx.strokeStyle = '#333';\n    ctx.lineWidth = 2;\n    roundRect(ctx, x, y, w, h, 8, true, true);\n    ctx.fillStyle = '#111';\n    ctx.font = 'bold 16px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(text, x + w / 2, y + h / 2);\n    ctx.restore();\n  }\n\n  // Visual feedback overlay for correct/incorrect\n  function drawFeedback(ctx) {\n    if (!gameState.lastFeedback) return;\n    const elapsed = Date.now() - gameState.lastActionTime;\n    if (elapsed > 1800) {\n      // clear feedback after time\n      gameState.lastFeedback = null;\n      return;\n    }\n    ctx.save();\n    if (gameState.lastFeedback === 'correct') {\n      // green glow\n      ctx.fillStyle = `rgba(120,220,140,${0.35 - elapsed / 1800 * 0.35})`;\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n      // sparkling gears\n      for (let i = 0; i < 12; i++) {\n        const angle = (i / 12) * Math.PI * 2 + (elapsed / 900);\n        const cx = 360 + Math.cos(angle) * 180;\n        const cy = 240 + Math.sin(angle) * 120;\n        drawGear(ctx, cx, cy, 8 + (i % 3), 8, '#fff3b0', '#b07a16');\n      }\n    } else {\n      // red tint for incorrect\n      ctx.fillStyle = `rgba(220,100,100,${0.28 - elapsed / 1800 * 0.28})`;\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n      // wobble the machine slightly\n      const dx = Math.sin(elapsed / 80) * 8;\n      drawWobbleCross(ctx, canvas.width / 2 + dx, canvas.height / 2);\n    }\n    ctx.restore();\n  }\n\n  function drawWobbleCross(ctx, cx, cy) {\n    ctx.save();\n    ctx.strokeStyle = '#fff';\n    ctx.lineWidth = 6;\n    ctx.beginPath();\n    ctx.moveTo(cx - 12, cy - 12);\n    ctx.lineTo(cx + 12, cy + 12);\n    ctx.moveTo(cx + 12, cy - 12);\n    ctx.lineTo(cx - 12, cy + 12);\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  // Main draw loop\n  function draw() {\n    // Clear background with calming gradient\n    const g = ctx.createLinearGradient(0, 0, 0, canvas.height);\n    g.addColorStop(0, '#f0f7fb');\n    g.addColorStop(1, '#e6f0ee');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // Decorative floating pipes/gears\n    for (let i = 0; i < 6; i++) {\n      const x = 120 + i * 90;\n      const y = 60 + Math.sin((Date.now() / 800) + i) * 8;\n      drawGear(ctx, x, y, 14, 8, '#c7d6f5', '#8b9ad1');\n    }\n\n    // Draw characters and machine\n    drawCharacters(ctx);\n    drawMachine(ctx, 120, 120, 280, 200);\n\n    // UI area\n    drawUI(ctx);\n\n    // Feedback overlay if needed\n    drawFeedback(ctx);\n\n    // Focus hint\n    ctx.save();\n    ctx.font = smallFont;\n    ctx.fillStyle = '#333';\n    ctx.fillText('Keyboard: \u2191/\u2192 increase, \u2193/\u2190 decrease, Enter/Space submit, M toggle sound', 10, 470);\n    ctx.restore();\n\n    requestAnimationFrame(draw);\n  }\n\n  // Input handling: mouse clicks\n  canvas.addEventListener('mousedown', async (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n\n    // Ensure audio resume on first interaction if blocked\n    if (audioContext && audioContext.state === 'suspended') {\n      await ensureAudio();\n    }\n\n    // Audio toggle\n    if (hitTest(mx, my, ui.audioToggle)) {\n      toggleAudio();\n      return;\n    }\n\n    // ignore input if busy animating\n    if (gameState.busy) return;\n\n    if (hitTest(mx, my, ui.plus)) {\n      changePlayerChoice(1);\n      return;\n    }\n    if (hitTest(mx, my, ui.minus)) {\n      changePlayerChoice(-1);\n      return;\n    }\n    if (hitTest(mx, my, ui.submit)) {\n      submitChoice();\n      return;\n    }\n    if (gameState.lastFeedback && hitTest(mx, my, ui.next)) {\n      if (gameState.round >= gameState.totalRounds) {\n        // End of game, reset\n        gameState.message = `Game complete! Score: ${gameState.score}/${gameState.totalRounds}. Press Space to play again.`;\n        gameState.lastFeedback = null;\n      } else {\n        initNewRound();\n      }\n      return;\n    }\n\n    // Click on machine area to give focus to canvas for keyboard control\n    canvas.focus();\n  });\n\n  function hitTest(mx, my, rect) {\n    return mx >= rect.x && mx <= rect.x + rect.w && my >= rect.y && my <= rect.y + rect.h;\n  }\n\n  // Keyboard input handling\n  canvas.addEventListener('keydown', async (e) => {\n    // resume audio on first user gesture if suspended\n    if (audioContext && audioContext.state === 'suspended') {\n      await ensureAudio();\n    }\n\n    if (gameState.busy) {\n      // allow toggling audio even when busy\n      if (e.key.toLowerCase() === 'm') {\n        toggleAudio();\n      }\n      return;\n    }\n\n    if (e.key === 'ArrowUp' || e.key === 'ArrowRight') {\n      changePlayerChoice(1);\n      e.preventDefault();\n    } else if (e.key === 'ArrowDown' || e.key === 'ArrowLeft') {\n      changePlayerChoice(-1);\n      e.preventDefault();\n    } else if (e.key === 'Enter' || e.key === ' ') {\n      submitChoice();\n      e.preventDefault();\n    } else if (e.key.toLowerCase() === 'm') {\n      toggleAudio();\n      e.preventDefault();\n    } else if (e.key.toLowerCase() === 'n') {\n      if (gameState.lastFeedback) {\n        if (gameState.round >= gameState.totalRounds) {\n          gameState.message = `Game complete! Score: ${gameState.score}/${gameState.totalRounds}. Press Space to play again.`;\n          gameState.lastFeedback = null;\n        } else {\n          initNewRound();\n        }\n      }\n    } else if (e.key.toLowerCase() === 's') {\n      // Start game shortcut\n      if (gameState.round === 0) {\n        initNewRound();\n      }\n    }\n  });\n\n  function changePlayerChoice(delta) {\n    gameState.playerChoice = clamp(gameState.playerChoice + delta, 0, 12);\n    gameState.message = `You chose ${gameState.playerChoice}. Press Enter or Insert to try it.`;\n  }\n\n  // Submission and checking\n  function submitChoice() {\n    if (gameState.round === 0) {\n      // start first round\n      initNewRound();\n      return;\n    }\n    if (gameState.busy) return;\n    const player = gameState.playerChoice;\n    // Determine expected value\n    const expected = Math.abs(gameState.needed);\n    gameState.busy = true;\n    if (player === expected) {\n      // Correct \u2014 animate adding or removing gears\n      gameState.message = 'Nice! Gizmo fixed the machine!';\n      gameState.score += 1;\n      gameState.lastFeedback = 'correct';\n      gameState.lastActionTime = Date.now();\n      if (gameState.audioOn) playCorrect();\n      // animate changing current to target\n      const steps = 12;\n      const start = gameState.current;\n      const delta = gameState.target - gameState.current;\n      let i = 0;\n      const anim = setInterval(() => {\n        i++;\n        gameState.current = Math.round(start + (delta * i) / steps);\n        if (i >= steps) {\n          clearInterval(anim);\n          gameState.current = gameState.target;\n          gameState.busy = false;\n          // show next button or finish\n          if (gameState.round >= gameState.totalRounds) {\n            gameState.message = `Great work! Final score ${gameState.score}/${gameState.totalRounds}. Press Space to play again.`;\n          } else {\n            gameState.message = 'Press Next to continue.';\n          }\n        }\n      }, 60);\n    } else {\n      // Incorrect\n      gameState.message = `Oops. Try again or press Next for another machine.`;\n      gameState.lastFeedback = 'incorrect';\n      gameState.lastActionTime = Date.now();\n      if (gameState.audioOn) playIncorrect();\n      // small shake animation to indicate wrong\n      const start = gameState.current;\n      const t0 = Date.now();\n      const dur = 600;\n      let animId = setInterval(() => {\n        const t = Date.now() - t0;\n        if (t > dur) {\n          clearInterval(animId);\n          gameState.busy = false;\n        }\n      }, 50);\n      // allow attempt again \u2014 do not change current\n      gameState.busy = false;\n    }\n  }\n\n  function toggleAudio() {\n    gameState.audioOn = !gameState.audioOn;\n    if (gameState.audioOn) {\n      // Attempt to start audio if possible\n      ensureAudio().then((ok) => {\n        if (!ok) {\n          gameState.audioOn = false;\n          gameState.message = 'Audio unavailable in this browser. Muted.';\n        } else {\n          startBackgroundHum();\n          gameState.message = 'Audio enabled.';\n        }\n      });\n    } else {\n      stopBackgroundHum();\n      gameState.message = 'Audio muted (press M to enable).';\n    }\n  }\n\n  // Start background hum if audio initially allowed\n  if (audioContext && gameState.audioOn) {\n    // Some browsers require resume on gesture; we still try\n    ensureAudio().then((ok) => {\n      if (ok) startBackgroundHum();\n      else gameState.audioOn = false;\n    });\n  }\n\n  // Click handler to support clicking \"Enter\" semantics when a DOM caret / keyboard focus\n  // Also support spacebar to start new round when game awaits\n  window.addEventListener('keydown', (e) => {\n    // Global: if space pressed and on final screen to restart\n    if ((e.code === 'Space' || e.key === ' ') && gameState.round >= gameState.totalRounds && !gameState.lastFeedback) {\n      // reset game\n      startGame();\n      canvas.focus();\n    }\n  });\n\n  // Provide initial message drawn\n  requestAnimationFrame(draw);\n\n  // Safety: in case audio fails later, ensure errors are caught\n  window.addEventListener('unhandledrejection', function(evt) {\n    console.warn('Unhandled promise rejection in game:', evt.reason);\n  });\n\n  // Expose some functions for debugging on canvas dataset (not necessary but safe)\n  canvas.dataset.gameVersion = 'machine-math-1.0';\n\n})();\n---\n",
  "improve_response_tokens": 19147,
  "formatted_code": true,
  "formatting_response_tokens": 22868,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}