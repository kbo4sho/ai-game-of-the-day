{
  "generated_date": "2025-08-22",
  "generated_timestamp": "2025-08-22T00:26:35.253268",
  "model": "gpt-5-mini",
  "theme": "electricity",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8956,
  "game_filename": "2025-08-22.js",
  "game_size_bytes": 26207,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Power-Up Circuit: A math game for ages 7-9 (addition practice) themed around electricity.\n  // The entire game renders inside the element with ID \"game-of-the-day-stage\".\n  // All graphics drawn to a 720x480 canvas. Sounds are generated with Web Audio API oscillators/filters.\n  // Controls: Arrow keys or WASD to move Sparkie. Space toggles audio. Enter restarts after finish.\n  // Accessibility: A hidden ARIA live region provides text updates. Keyboard controls supported.\n  // Author: educational game designer AI.\n\n  // -----------------------\n  // Configuration & Setup\n  // -----------------------\n  const STAGE_ID = \"game-of-the-day-stage\";\n  const WIDTH = 720;\n  const HEIGHT = 480;\n\n  // Ensure container exists\n  const container = document.getElementById(STAGE_ID);\n  if (!container) {\n    console.error(`Game container with ID \"${STAGE_ID}\" not found.`);\n    return;\n  }\n\n  // Clear container and create canvas\n  container.innerHTML = \"\";\n  container.style.position = \"relative\";\n  container.style.width = WIDTH + \"px\";\n  container.style.height = HEIGHT + \"px\";\n  container.style.userSelect = \"none\";\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute(\"role\", \"application\");\n  canvas.setAttribute(\"aria-label\", \"Power-Up Circuit math game. Use arrow keys or WASD to move Sparkie and collect numbered energy bits to match lamp targets.\");\n  canvas.style.display = \"block\";\n  container.appendChild(canvas);\n\n  // Hidden ARIA live region for screen readers\n  const sr = document.createElement(\"div\");\n  sr.setAttribute(\"aria-live\", \"polite\");\n  sr.style.position = \"absolute\";\n  sr.style.left = \"-9999px\";\n  sr.style.width = \"1px\";\n  sr.style.height = \"1px\";\n  sr.style.overflow = \"hidden\";\n  sr.id = \"game-of-the-day-status\";\n  container.appendChild(sr);\n\n  const ctx = canvas.getContext(\"2d\", { alpha: false });\n\n  // -----------------------\n  // Audio Initialization\n  // -----------------------\n  let audioCtx = null;\n  let audioEnabled = true; // ability to play\n  let bgOsc = null;\n  let bgGain = null;\n\n  function initAudio() {\n    try {\n      const AC = window.AudioContext || window.webkitAudioContext;\n      if (!AC) {\n        throw new Error(\"Web Audio API not supported\");\n      }\n      audioCtx = new AC();\n      // Create gentle background hum\n      bgOsc = audioCtx.createOscillator();\n      bgOsc.type = \"sine\";\n      bgOsc.frequency.value = 110; // low hum\n      const lfo = audioCtx.createOscillator();\n      lfo.type = \"sine\";\n      lfo.frequency.value = 0.25; // slow wobble\n      const lfoGain = audioCtx.createGain();\n      lfoGain.gain.value = 6; // frequency modulation depth\n      lfo.connect(lfoGain);\n      lfoGain.connect(bgOsc.frequency);\n      bgGain = audioCtx.createGain();\n      bgGain.gain.value = 0.03; // quiet background\n      bgOsc.connect(bgGain);\n      bgGain.connect(audioCtx.destination);\n      bgOsc.start();\n      lfo.start();\n      // start but keep low; can toggle via toggleAudio\n      audioEnabled = true;\n    } catch (err) {\n      console.warn(\"Audio initialization failed:\", err);\n      audioCtx = null;\n      audioEnabled = false;\n    }\n  }\n\n  // Play a short blip when picking up energy\n  function playPickup() {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = \"triangle\";\n      o.frequency.value = 660;\n      g.gain.value = 0.0001;\n      o.connect(g);\n      g.connect(audioCtx.destination);\n      const now = audioCtx.currentTime;\n      g.gain.cancelScheduledValues(now);\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(0.08, now + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.28);\n      o.start(now);\n      o.stop(now + 0.3);\n    } catch (err) {\n      console.warn(\"playPickup error\", err);\n    }\n  }\n\n  // Play positive chime for correct sum\n  function playSuccess() {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      // Create two oscillators for pleasant harmony\n      const o1 = audioCtx.createOscillator();\n      const o2 = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o1.type = \"sine\";\n      o2.type = \"sine\";\n      o1.frequency.value = 660;\n      o2.frequency.value = 880;\n      o1.connect(g);\n      o2.connect(g);\n      g.connect(audioCtx.destination);\n      const now = audioCtx.currentTime;\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(0.12, now + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);\n      o1.start(now);\n      o2.start(now);\n      o1.stop(now + 0.6);\n      o2.stop(now + 0.6);\n    } catch (err) {\n      console.warn(\"playSuccess error\", err);\n    }\n  }\n\n  // Play error buzz\n  function playError() {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const f = audioCtx.createBiquadFilter();\n      const g = audioCtx.createGain();\n      o.type = \"square\";\n      o.frequency.value = 220;\n      f.type = \"lowpass\";\n      f.frequency.value = 800;\n      o.connect(f);\n      f.connect(g);\n      g.connect(audioCtx.destination);\n      const now = audioCtx.currentTime;\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(0.1, now + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);\n      o.start(now);\n      o.stop(now + 0.35);\n    } catch (err) {\n      console.warn(\"playError error\", err);\n    }\n  }\n\n  function setBackgroundVolume(vol) {\n    if (!bgGain) return;\n    try {\n      bgGain.gain.setValueAtTime(vol, audioCtx.currentTime);\n    } catch (err) {\n      console.warn(\"setBackgroundVolume error\", err);\n    }\n  }\n\n  function toggleAudio() {\n    if (!audioCtx) {\n      // try to initialize if not yet available\n      initAudio();\n      if (!audioCtx) {\n        audioEnabled = false;\n        announce(\"Audio not available on this device\");\n        return;\n      }\n    }\n    if (audioCtx.state === \"suspended\") {\n      audioCtx.resume().catch((e) => console.warn(e));\n    }\n    audioEnabled = !audioEnabled;\n    setBackgroundVolume(audioEnabled ? 0.03 : 0.0);\n    announce(audioEnabled ? \"Audio turned on\" : \"Audio turned off\");\n  }\n\n  // -----------------------\n  // Game Objects & State\n  // -----------------------\n  const keys = {};\n  const pointer = { x: 0, y: 0, down: false };\n\n  // Sparkie (player)\n  const player = {\n    x: WIDTH / 2,\n    y: HEIGHT - 80,\n    r: 18,\n    color1: \"#FFD66B\",\n    color2: \"#FFAA00\",\n    vx: 0,\n    vy: 0,\n    speed: 160, // pixels per second\n  };\n\n  // Lamps (targets) - drawn as wacky lightbulbs with required target sum\n  const lampCount = 3;\n  let lamps = [];\n\n  // Energy bits (collectible number pellets)\n  let pellets = [];\n\n  // Level and game flow\n  let level = 1;\n  let score = 0;\n  let lives = 3;\n  let gameState = \"start\"; // start, playing, levelComplete, gameOver\n  let lastTime = null;\n\n  // Timers\n  let spawnTimer = 0;\n  const spawnInterval = 1.0; // spawn pellet every second-ish\n\n  // Accessibility announcer\n  function announce(message) {\n    try {\n      sr.textContent = message;\n    } catch (err) {\n      console.warn(\"announce error\", err);\n    }\n  }\n\n  // -----------------------\n  // Utility Functions\n  // -----------------------\n  function rand(min, max) {\n    return Math.random() * (max - min) + min;\n  }\n\n  function randint(min, max) {\n    return Math.floor(rand(min, max + 1));\n  }\n\n  // Create lamps based on level: targets increase slightly\n  function resetLampsForLevel(lv) {\n    lamps = [];\n    const padding = 40;\n    const spacing = (WIDTH - padding * 2) / (lampCount - 1);\n    for (let i = 0; i < lampCount; i++) {\n      const targetBase = 6 + lv * 2; // base grows with level\n      const target = randint(targetBase, targetBase + 6);\n      lamps.push({\n        x: padding + spacing * i,\n        y: 90,\n        r: 44,\n        target: target,\n        sum: 0,\n        lit: false,\n        wobble: Math.random() * Math.PI * 2,\n      });\n    }\n  }\n\n  // Reset pellets for start of level\n  function resetPellets() {\n    pellets = [];\n    // Prepopulate some pellets\n    for (let i = 0; i < 6; i++) spawnPellet();\n  }\n\n  // Spawn pellet with a number that makes sense for current lamps: values 1..9\n  function spawnPellet() {\n    // Avoid too many pellets\n    if (pellets.length > 14) return;\n    const n = randint(1, Math.min(9, 2 + level * 3));\n    const p = {\n      x: rand(40, WIDTH - 40),\n      y: rand(160, HEIGHT - 120),\n      r: 14,\n      value: n,\n      vx: rand(-20, 20),\n      vy: rand(-10, 10),\n      wobble: Math.random() * Math.PI * 2,\n    };\n    pellets.push(p);\n  }\n\n  // Initialize level\n  function startLevel(lv) {\n    level = lv;\n    resetLampsForLevel(level);\n    resetPellets();\n    spawnTimer = 0;\n    gameState = \"playing\";\n    announce(`Level ${level}. Help Sparkie light up ${lampCount} lamps by collecting numbers that add to each lamp's target.`);\n  }\n\n  function restartGame() {\n    level = 1;\n    score = 0;\n    lives = 3;\n    player.x = WIDTH / 2;\n    player.y = HEIGHT - 80;\n    startLevel(level);\n  }\n\n  // -----------------------\n  // Collision Helpers\n  // -----------------------\n  function circleCollision(a, b) {\n    const dx = a.x - b.x;\n    const dy = a.y - b.y;\n    const r = a.r + b.r;\n    return dx * dx + dy * dy <= r * r;\n  }\n\n  // -----------------------\n  // Input Handling\n  // -----------------------\n  window.addEventListener(\"keydown\", (e) => {\n    keys[e.key] = true;\n    if (e.key === \" \" || e.code === \"Space\") {\n      e.preventDefault();\n    }\n    // Start audio on first key press if available but suspended\n    if (audioCtx && audioCtx.state === \"suspended\") {\n      audioCtx.resume().catch((err) => console.warn(\"audio resume failed\", err));\n    }\n    // Space toggles audio\n    if (e.key === \" \") {\n      toggleAudio();\n    }\n    // Enter to start or restart\n    if (e.key === \"Enter\") {\n      if (gameState === \"start\" || gameState === \"levelComplete\" || gameState === \"gameOver\") {\n        restartGame();\n      }\n    }\n  });\n  window.addEventListener(\"keyup\", (e) => {\n    keys[e.key] = false;\n  });\n\n  // Mouse for pointer and click-to-toggle\n  canvas.addEventListener(\"mousemove\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    pointer.x = (e.clientX - rect.left) * (canvas.width / rect.width);\n    pointer.y = (e.clientY - rect.top) * (canvas.height / rect.height);\n  });\n  canvas.addEventListener(\n    \"mousedown\",\n    (e) => {\n      pointer.down = true;\n      // Clicking speaker area toggles audio\n      const sx = WIDTH - 52;\n      const sy = 12;\n      if (pointer.x >= sx && pointer.x <= sx + 40 && pointer.y >= sy && pointer.y <= sy + 40) {\n        toggleAudio();\n      }\n      // Clicking on start or restart areas\n      if (gameState === \"start\" || gameState === \"levelComplete\" || gameState === \"gameOver\") {\n        // Entire canvas click considered as start\n        restartGame();\n      }\n    },\n    false\n  );\n  canvas.addEventListener(\"mouseup\", () => {\n    pointer.down = false;\n  });\n\n  // Touch support\n  canvas.addEventListener(\n    \"touchstart\",\n    (e) => {\n      const rect = canvas.getBoundingClientRect();\n      const t = e.touches[0];\n      pointer.x = (t.clientX - rect.left) * (canvas.width / rect.width);\n      pointer.y = (t.clientY - rect.top) * (canvas.height / rect.height);\n      pointer.down = true;\n      e.preventDefault();\n      if (audioCtx && audioCtx.state === \"suspended\") {\n        audioCtx.resume().catch((err) => console.warn(\"audio resume failed\", err));\n      }\n    },\n    { passive: false }\n  );\n  canvas.addEventListener(\n    \"touchmove\",\n    (e) => {\n      const rect = canvas.getBoundingClientRect();\n      const t = e.touches[0];\n      pointer.x = (t.clientX - rect.left) * (canvas.width / rect.width);\n      pointer.y = (t.clientY - rect.top) * (canvas.height / rect.height);\n      e.preventDefault();\n    },\n    { passive: false }\n  );\n  canvas.addEventListener(\n    \"touchend\",\n    (e) => {\n      pointer.down = false;\n      e.preventDefault();\n    },\n    { passive: false }\n  );\n\n  // -----------------------\n  // Drawing Helpers\n  // -----------------------\n  function drawRoundedRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function drawBackground() {\n    // Soft gradient sky\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, \"#eaf6ff\");\n    g.addColorStop(1, \"#f5fbff\");\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Floating capacitors and whimsical wires\n    for (let i = 0; i < 7; i++) {\n      const sx = ((i * 137) % WIDTH) + (Math.sin(performance.now() / 2000 + i) + 1) * 8;\n      ctx.save();\n      ctx.globalAlpha = 0.15;\n      ctx.fillStyle = \"#bfe9ff\";\n      ctx.beginPath();\n      ctx.ellipse(sx, 40 + (i % 3) * 20, 60 - (i % 4) * 6, 12, Math.PI / 8, 0, 2 * Math.PI);\n      ctx.fill();\n      ctx.restore();\n    }\n\n    // Ground strip\n    ctx.fillStyle = \"#e8f7ee\";\n    ctx.fillRect(0, HEIGHT - 100, WIDTH, 100);\n\n    // Wacky power pole on left\n    ctx.save();\n    ctx.translate(48, HEIGHT - 120);\n    ctx.fillStyle = \"#6b4a2a\";\n    drawRoundedRect(ctx, -12, -40, 24, 120, 6);\n    ctx.fillStyle = \"#ffeed2\";\n    ctx.beginPath();\n    ctx.arc(0, -24, 28, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = \"#ffecb3\";\n    ctx.fillRect(-18, -14, 36, 18);\n    ctx.restore();\n  }\n\n  function drawLamp(l) {\n    ctx.save();\n    ctx.translate(l.x, l.y);\n    // Wobble\n    l.wobble += 0.02;\n    const wob = Math.sin(l.wobble) * 4;\n    // Lamp glass\n    const grad = ctx.createRadialGradient(-12, -10, 8, 0, 0, 60);\n    grad.addColorStop(0, l.lit ? \"#fff7b0\" : \"#ffffff\");\n    grad.addColorStop(1, l.lit ? \"#fff67a\" : \"#dceeff\");\n    ctx.fillStyle = grad;\n    ctx.beginPath();\n    ctx.ellipse(wob, 0, l.r, l.r * 1.15, 0, 0, Math.PI * 2);\n    ctx.fill();\n    // Filament and base\n    ctx.fillStyle = l.lit ? \"#ffb703\" : \"#7b7b7b\";\n    ctx.fillRect(-18, 30, 36, 14);\n    // Tiny circuit bolts\n    ctx.strokeStyle = \"#ffea85\";\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(-10, 4);\n    ctx.lineTo(-2, 10);\n    ctx.lineTo(-6, 10);\n    ctx.lineTo(2, 18);\n    ctx.stroke();\n    // Display text: target and current sum\n    ctx.fillStyle = \"#333\";\n    ctx.font = \"600 16px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(`Target: ${l.target}`, 0, -l.r - 12);\n    ctx.fillStyle = l.lit ? \"#006400\" : \"#1a3d6a\";\n    ctx.font = \"700 20px serif\";\n    ctx.fillText(`${l.sum}`, 0, 6);\n    ctx.restore();\n  }\n\n  function drawPellet(p) {\n    ctx.save();\n    ctx.translate(p.x, p.y);\n    p.wobble += 0.08;\n    const shift = Math.sin(p.wobble) * 3;\n    // Outer ring\n    ctx.beginPath();\n    ctx.fillStyle = \"#fff\";\n    ctx.arc(0 + shift, 0, p.r + 3, 0, Math.PI * 2);\n    ctx.fill();\n    // Inner gradient\n    const grad = ctx.createLinearGradient(-p.r, -p.r, p.r, p.r);\n    grad.addColorStop(0, \"#ffdede\");\n    grad.addColorStop(1, \"#ff8c8c\");\n    ctx.fillStyle = grad;\n    ctx.beginPath();\n    ctx.arc(0 + shift, 0, p.r, 0, Math.PI * 2);\n    ctx.fill();\n    // Number\n    ctx.fillStyle = \"#3a0b0b\";\n    ctx.font = \"700 14px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(p.value.toString(), shift, 0);\n    ctx.restore();\n  }\n\n  function drawPlayer(pl) {\n    ctx.save();\n    ctx.translate(pl.x, pl.y);\n    // glow and trail\n    const glow = ctx.createRadialGradient(0, 0, 4, 0, 0, 36);\n    glow.addColorStop(0, \"#fff7d6\");\n    glow.addColorStop(1, \"rgba(255,170,0,0)\");\n    ctx.fillStyle = glow;\n    ctx.beginPath();\n    ctx.arc(0, 0, 36, 0, Math.PI * 2);\n    ctx.fill();\n\n    // spark body\n    ctx.beginPath();\n    ctx.fillStyle = pl.color1;\n    ctx.arc(0, 0, pl.r, 0, Math.PI * 2);\n    ctx.fill();\n\n    // eyes\n    ctx.fillStyle = \"#222\";\n    ctx.beginPath();\n    ctx.ellipse(-6, -4, 4, 5, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.ellipse(6, -3, 4, 5, 0, 0, Math.PI * 2);\n    ctx.fill();\n    // smile\n    ctx.strokeStyle = \"#6b3b00\";\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.arc(0, 4, 8, 0.1 * Math.PI, 0.9 * Math.PI);\n    ctx.stroke();\n\n    // little electric tail\n    ctx.strokeStyle = \"#ffd66b\";\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.moveTo(-pl.r - 2, 2);\n    ctx.lineTo(-pl.r - 12, 6);\n    ctx.lineTo(-pl.r - 6, 12);\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  function drawHUD() {\n    // Top bar\n    ctx.save();\n    ctx.fillStyle = \"rgba(10,10,10,0.04)\";\n    ctx.fillRect(0, 0, WIDTH, 54);\n    ctx.fillStyle = \"#123\";\n    ctx.font = \"700 18px sans-serif\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(`Score: ${score}`, 12, 26);\n    ctx.fillText(`Level: ${level}`, 160, 26);\n    ctx.fillText(`Lives: ${lives}`, 260, 26);\n    // Audio icon\n    const sx = WIDTH - 52;\n    const sy = 12;\n    ctx.fillStyle = audioEnabled ? \"#ffd66b\" : \"#cfcfcf\";\n    ctx.fillRect(sx, sy, 40, 36);\n    ctx.fillStyle = \"#3a3a3a\";\n    ctx.font = \"600 12px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(audioEnabled ? \"SOUND ON\" : \"SOUND OFF\", sx + 20, sy + 22);\n    ctx.restore();\n  }\n\n  // Instruction overlay on start screen\n  function drawStartScreen() {\n    ctx.save();\n    ctx.fillStyle = \"rgba(10,20,40,0.6)\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.fillStyle = \"#fff\";\n    ctx.textAlign = \"center\";\n    ctx.font = \"800 28px sans-serif\";\n    ctx.fillText(\"Power-Up Circuit\", WIDTH / 2, 120);\n    ctx.font = \"600 18px sans-serif\";\n    ctx.fillText(\"Help Sparkie light the lamps by collecting energy bits (numbers).\", WIDTH / 2, 160);\n    ctx.fillText(\"Use arrow keys or WASD to move. Space toggles audio. Click or press Enter to start.\", WIDTH / 2, 190);\n    ctx.fillStyle = \"#ffd66b\";\n    ctx.beginPath();\n    ctx.ellipse(WIDTH / 2, 300, 70, 70, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = \"#222\";\n    ctx.font = \"700 22px sans-serif\";\n    ctx.fillText(\"Click to Start\", WIDTH / 2, 308);\n    ctx.restore();\n  }\n\n  function drawLevelComplete() {\n    ctx.save();\n    ctx.fillStyle = \"rgba(0,0,0,0.45)\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.fillStyle = \"#fff\";\n    ctx.textAlign = \"center\";\n    ctx.font = \"800 28px sans-serif\";\n    ctx.fillText(\"All lamps powered!\", WIDTH / 2, 160);\n    ctx.font = \"700 20px sans-serif\";\n    ctx.fillText(`Level ${level} complete. Score: ${score}`, WIDTH / 2, 200);\n    ctx.font = \"600 16px sans-serif\";\n    ctx.fillText(\"Click or press Enter to continue to the next challenge.\", WIDTH / 2, 260);\n    ctx.restore();\n  }\n\n  function drawGameOver() {\n    ctx.save();\n    ctx.fillStyle = \"rgba(0,0,0,0.55)\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.fillStyle = \"#fff\";\n    ctx.textAlign = \"center\";\n    ctx.font = \"800 30px sans-serif\";\n    ctx.fillText(\"Oh no! Power outage!\", WIDTH / 2, 160);\n    ctx.font = \"700 22px sans-serif\";\n    ctx.fillText(`Final Score: ${score}`, WIDTH / 2, 210);\n    ctx.font = \"600 16px sans-serif\";\n    ctx.fillText(\"Click or press Enter to try again and power up the town!\", WIDTH / 2, 260);\n    ctx.restore();\n  }\n\n  // -----------------------\n  // Gameplay Logic\n  // -----------------------\n  function update(dt) {\n    if (gameState !== \"playing\") return;\n\n    // Player movement via keyboard\n    let vx = 0,\n      vy = 0;\n    if (keys[\"ArrowLeft\"] || keys[\"a\"] || keys[\"A\"]) vx -= 1;\n    if (keys[\"ArrowRight\"] || keys[\"d\"] || keys[\"D\"]) vx += 1;\n    if (keys[\"ArrowUp\"] || keys[\"w\"] || keys[\"W\"]) vy -= 1;\n    if (keys[\"ArrowDown\"] || keys[\"s\"] || keys[\"S\"]) vy += 1;\n    const len = Math.hypot(vx, vy);\n    if (len > 0) {\n      vx = (vx / len) * player.speed;\n      vy = (vy / len) * player.speed;\n    }\n    // Pointer control (mouse) nudges player\n    if (pointer.down) {\n      // Move player toward pointer slowly for touch control\n      const dx = pointer.x - player.x;\n      const dy = pointer.y - player.y;\n      vx += dx * 1.4;\n      vy += dy * 1.4;\n    }\n    player.x += vx * dt;\n    player.y += vy * dt;\n    // Boundaries\n    player.x = Math.max(22, Math.min(WIDTH - 22, player.x));\n    player.y = Math.max(120, Math.min(HEIGHT - 24, player.y));\n\n    // Pellets move slightly\n    for (const p of pellets) {\n      // gentle drift\n      p.x += p.vx * dt;\n      p.y += p.vy * dt;\n      // keep inside\n      if (p.x < 24 || p.x > WIDTH - 24) p.vx *= -1;\n      if (p.y < 140 || p.y > HEIGHT - 40) p.vy *= -1;\n      // slight damping\n      p.vx *= 0.995;\n      p.vy *= 0.995;\n    }\n\n    // Spawn new pellets occasionally\n    spawnTimer += dt;\n    if (spawnTimer >= spawnInterval) {\n      spawnTimer = 0;\n      if (Math.random() < 0.85) spawnPellet();\n    }\n\n    // Collision with pellets\n    for (let i = pellets.length - 1; i >= 0; i--) {\n      const p = pellets[i];\n      if (circleCollision(player, { x: p.x, y: p.y, r: p.r })) {\n        // Collect pellet\n        playPickup();\n        // Which lamp to assign to? We'll assign to the nearest unlit lamp.\n        const unlit = lamps.filter((l) => !l.lit);\n        if (unlit.length === 0) {\n          // Nothing to assign to, small score\n          score += p.value;\n          announce(`Collected ${p.value} energy. No lamps need energy right now.`);\n        } else {\n          // find nearest unlit lamp\n          let nearest = unlit[0];\n          let best = Infinity;\n          for (const l of unlit) {\n            const d = (l.x - player.x) ** 2 + (l.y - player.y) ** 2;\n            if (d < best) {\n              best = d;\n              nearest = l;\n            }\n          }\n          nearest.sum += p.value;\n          // Announce\n          announce(`Delivered ${p.value} energy to a lamp. Lamp at ${nearest.x} now has ${nearest.sum}.`);\n          // Check success or overload\n          if (nearest.sum === nearest.target) {\n            nearest.lit = true;\n            score += nearest.target * 2;\n            playSuccess();\n            announce(`Bingo! Lamp reached target ${nearest.target} and lit up!`);\n          } else if (nearest.sum > nearest.target) {\n            // Overload\n            playError();\n            lives -= 1;\n            // visual penalty: reduce sum partially\n            nearest.sum = Math.max(0, Math.floor(nearest.sum / 2));\n            announce(`Oops! Lamp overloaded. Lives left: ${lives}. The lamp's energy decreased to ${nearest.sum}.`);\n            if (lives <= 0) {\n              gameState = \"gameOver\";\n              announce(\"Game over. Try again to help Sparkie power the town.\");\n            }\n          } else {\n            // partial success\n            // small score for contributing\n            score += p.value;\n          }\n        }\n        pellets.splice(i, 1);\n      }\n    }\n\n    // Check if all lamps are lit\n    if (lamps.every((l) => l.lit)) {\n      gameState = \"levelComplete\";\n      level += 1;\n      // Award bonus\n      score += 50;\n      playSuccess();\n      announce(`Level complete! You powered all lamps. Score ${score}. Click or press Enter to continue.`);\n    }\n  }\n\n  // -----------------------\n  // Main Loop\n  // -----------------------\n  function loop(ts) {\n    if (!lastTime) lastTime = ts;\n    const dt = Math.min(0.05, (ts - lastTime) / 1000);\n    lastTime = ts;\n\n    // Clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // Update based on state\n    if (gameState === \"start\") {\n      // Gentle animated background\n      drawBackground();\n      drawPlayer(player);\n      drawHUD();\n      drawStartScreen();\n    } else if (gameState === \"playing\") {\n      update(dt);\n      drawBackground();\n      // Draw lamps\n      for (const l of lamps) drawLamp(l);\n      // Draw pellets\n      for (const p of pellets) drawPellet(p);\n      // Draw player\n      drawPlayer(player);\n      drawHUD();\n      // Little instruction hint\n      ctx.fillStyle = \"rgba(0,0,0,0.06)\";\n      ctx.fillRect(8, HEIGHT - 84, WIDTH - 16, 72);\n      ctx.fillStyle = \"#123\";\n      ctx.font = \"600 14px sans-serif\";\n      ctx.textAlign = \"left\";\n      ctx.fillText(\"Collect numbers and deliver them to lamps to match their target sums. Avoid overloads.\", 14, HEIGHT - 54);\n    } else if (gameState === \"levelComplete\") {\n      drawBackground();\n      for (const l of lamps) drawLamp(l);\n      for (const p of pellets) drawPellet(p);\n      drawPlayer(player);\n      drawHUD();\n      drawLevelComplete();\n    } else if (gameState === \"gameOver\") {\n      drawBackground();\n      for (const l of lamps) drawLamp(l);\n      drawHUD();\n      drawGameOver();\n    }\n\n    // Draw small audio indicator (visual cue for audio state)\n    ctx.save();\n    ctx.globalAlpha = 0.9;\n    ctx.fillStyle = audioEnabled ? \"#d9f7a6\" : \"#f0d6d6\";\n    const sx = WIDTH - 76;\n    const sy = 8;\n    drawRoundedRect(ctx, sx, sy, 62, 36, 6);\n    ctx.fillStyle = \"#222\";\n    ctx.font = \"600 12px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(audioEnabled ? \"Audio: On\" : \"Audio: Off\", sx + 31, sy + 22);\n    ctx.restore();\n\n    requestAnimationFrame(loop);\n  }\n\n  // -----------------------\n  // Initialization\n  // -----------------------\n  function init() {\n    // Try initializing audio but handle errors gracefully\n    try {\n      initAudio();\n      if (!audioCtx) {\n        announce(\"Audio is not available. You can still play the game with visual feedback.\");\n      } else {\n        // ensure background volume based on audioEnabled\n        setBackgroundVolume(audioEnabled ? 0.03 : 0.0);\n      }\n    } catch (err) {\n      console.warn(\"Audio init error\", err);\n    }\n\n    // set initial positions for lamps and pellets\n    resetLampsForLevel(1);\n    resetPellets();\n\n    // show start screen\n    gameState = \"start\";\n    announce(\"Welcome to Power-Up Circuit! Press Enter or click to start. Use arrow keys or WASD to move Sparkie and collect numbers for lamps.\");\n\n    // Kick off loop\n    requestAnimationFrame(loop);\n  }\n\n  // Start\n  init();\n\n  // Expose some debug functions on the canvas element for testing in dev console\n  canvas.gameDebug = {\n    restart: restartGame,\n    toggleAudio: toggleAudio,\n    getState: () => ({ level, score, lives, gameState, lamps, pellets }),\n  };\n})();\n---\n",
  "improve_response_tokens": 18287,
  "formatted_code": true,
  "formatting_response_tokens": 19947,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}