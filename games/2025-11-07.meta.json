{
  "generated_date": "2025-11-07",
  "generated_timestamp": "2025-11-07T00:29:08.415820",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 10001,
  "game_filename": "2025-11-07.js",
  "game_size_bytes": 28476,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Drone Math Game for ages 7-9\n  // Renders entirely into the element with id \"game-of-the-day-stage\".\n  // Requirements: canvas 720x480, WebAudio API sounds, accessible keyboard controls,\n  // clear win/loss conditions, non-overlapping UI using ctx.measureText(), etc.\n\n  // Basic config\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const GOAL = 10; // number of correct answers needed to win\n  const MAX_WRONG = 3; // lives\n\n  // Find container and create canvas\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Container element #game-of-the-day-stage not found.');\n    return;\n  }\n  container.innerHTML = ''; // clear\n  container.style.position = 'relative';\n\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute('role', 'application');\n  canvas.setAttribute('aria-label', 'Drone Math Game canvas');\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext('2d', { alpha: false });\n\n  // Fonts and spacing\n  const PADDING = 12;\n  const UI_FONT = '16px sans-serif';\n  const IMPORTANT_FONT = '22px sans-serif';\n  const TITLE_FONT = '28px sans-serif';\n\n  // Audio\n  let audioCtx = null;\n  let audioAvailable = true;\n  let bgGain = null;\n  let bgOsc = null;\n  let bgLFO = null;\n  let audioInitialized = false;\n  let muted = false;\n\n  function initAudio() {\n    // Initialize Web Audio API with error handling.\n    if (audioInitialized) return;\n    audioInitialized = true;\n    try {\n      const AudioContext = window.AudioContext || window.webkitAudioContext;\n      audioCtx = new AudioContext();\n      // Create background hum with low volume\n      bgGain = audioCtx.createGain();\n      bgGain.gain.value = 0.02; // gentle\n      bgGain.connect(audioCtx.destination);\n\n      bgOsc = audioCtx.createOscillator();\n      bgOsc.type = 'sine';\n      bgOsc.frequency.value = 80; // base hum\n      // Slight vibrato via LFO\n      bgLFO = audioCtx.createOscillator();\n      const lfoGain = audioCtx.createGain();\n      lfoGain.gain.value = 6;\n      bgLFO.frequency.value = 0.15; // slow\n      bgLFO.connect(lfoGain);\n      lfoGain.connect(bgOsc.frequency);\n\n      bgOsc.connect(bgGain);\n\n      // Start oscillators only when user interacts (to satisfy browser autoplay policies)\n    } catch (e) {\n      console.warn('Audio not available:', e);\n      audioAvailable = false;\n      audioCtx = null;\n    }\n  }\n\n  function resumeAudioIfNeeded() {\n    if (!audioAvailable || !audioCtx) return;\n    if (audioCtx.state === 'suspended') {\n      audioCtx.resume().catch((e) => {\n        console.warn('Could not resume audio context:', e);\n      });\n    }\n  }\n\n  function startBackground() {\n    if (!audioAvailable || !audioCtx || !bgOsc) return;\n    try {\n      if (bgOsc.start) {\n        // start only if not already started. Creating new oscillator each start could be needed,\n        // but we created them once and haven't started yet.\n      }\n      // If oscillators were already started earlier, don't start again.\n      try {\n        bgOsc.start();\n        bgLFO.start();\n      } catch (e) {\n        // already started - that's okay\n      }\n      bgGain.gain.value = muted ? 0 : 0.02;\n    } catch (e) {\n      console.warn('Error starting background audio:', e);\n    }\n  }\n\n  function stopBackground() {\n    if (!audioAvailable || !audioCtx || !bgGain) return;\n    bgGain.gain.value = 0;\n  }\n\n  function playTone(freq, duration = 0.25, type = 'sine', volume = 0.12) {\n    if (!audioAvailable || !audioCtx) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = type;\n      o.frequency.value = freq;\n      g.gain.value = 0;\n      o.connect(g);\n      g.connect(audioCtx.destination);\n      const now = audioCtx.currentTime;\n      g.gain.cancelScheduledValues(now);\n      g.gain.setValueAtTime(0, now);\n      g.gain.linearRampToValueAtTime(volume, now + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);\n      o.start(now);\n      o.stop(now + duration + 0.05);\n    } catch (e) {\n      console.warn('Error playing tone:', e);\n    }\n  }\n\n  function playCorrectSound() {\n    if (!audioAvailable || !audioCtx) return;\n    try {\n      // pleasant arpeggio\n      const now = audioCtx.currentTime;\n      const freqs = [660, 880, 990];\n      freqs.forEach((f, i) => {\n        const o = audioCtx.createOscillator();\n        o.type = 'triangle';\n        o.frequency.value = f;\n        const g = audioCtx.createGain();\n        g.gain.value = 0;\n        o.connect(g);\n        g.connect(audioCtx.destination);\n        const start = now + i * 0.06;\n        g.gain.setValueAtTime(0.0001, start);\n        g.gain.linearRampToValueAtTime(0.11, start + 0.02);\n        g.gain.exponentialRampToValueAtTime(0.0001, start + 0.26);\n        o.start(start);\n        o.stop(start + 0.3);\n      });\n    } catch (e) {\n      console.warn('Error playing correct sound:', e);\n    }\n  }\n\n  function playWrongSound() {\n    if (!audioAvailable || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const o = audioCtx.createOscillator();\n      o.type = 'sawtooth';\n      o.frequency.setValueAtTime(220, now);\n      const g = audioCtx.createGain();\n      o.connect(g);\n      g.connect(audioCtx.destination);\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.linearRampToValueAtTime(0.18, now + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);\n      o.frequency.linearRampToValueAtTime(120, now + 0.4);\n      o.start(now);\n      o.stop(now + 0.45);\n    } catch (e) {\n      console.warn('Error playing wrong sound:', e);\n    }\n  }\n\n  // Game state\n  let state = {\n    mode: 'start', // 'start' | 'playing' | 'victory' | 'gameover'\n    correct: 0,\n    wrong: 0,\n    question: null,\n    choices: [],\n    selectedIndex: 0,\n    // Drone visual progress (0..GOAL)\n    progress: 0,\n    lastActionTime: 0,\n  };\n\n  // Answer boxes rectangles for hit testing\n  let answerBoxes = [];\n\n  // Utility to generate question appropriate for ages 7-9\n  function generateQuestion() {\n    // choose operation weighted: addition/subtraction common, multiplication sometimes\n    const ops = ['+', '+', '+', '-', '-', '\u00d7'];\n    const op = ops[Math.floor(Math.random() * ops.length)];\n    let a, b, answer;\n    if (op === '+') {\n      a = Math.floor(Math.random() * 20) + 1; // 1-20\n      b = Math.floor(Math.random() * 20) + 1;\n      answer = a + b;\n    } else if (op === '-') {\n      a = Math.floor(Math.random() * 20) + 1;\n      b = Math.floor(Math.random() * a) + 0; // ensure non-negative result\n      answer = a - b;\n    } else {\n      // multiplication small\n      a = Math.floor(Math.random() * 6) + 1; // 1-6\n      b = Math.floor(Math.random() * 6) + 1;\n      answer = a * b;\n    }\n    const qText = `${a} ${op} ${b} = ?`;\n    // create 3 choices\n    const choices = new Set();\n    choices.add(answer);\n    while (choices.size < 3) {\n      // plausible distractor: answer +/- small value\n      const delta = Math.floor(Math.random() * 5) + 1;\n      const sign = Math.random() < 0.5 ? -1 : 1;\n      const choiceValue = Math.max(0, answer + sign * delta);\n      choices.add(choiceValue);\n    }\n    const choicesArr = Array.from(choices);\n    // shuffle\n    for (let i = choicesArr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [choicesArr[i], choicesArr[j]] = [choicesArr[j], choicesArr[i]];\n    }\n    return {\n      text: qText,\n      answer,\n      choices: choicesArr,\n    };\n  }\n\n  function startNewQuestion() {\n    const q = generateQuestion();\n    state.question = q.text;\n    state.choices = q.choices;\n    state.correctAnswer = q.answer;\n    state.selectedIndex = 0;\n    state.lastActionTime = Date.now();\n    computeAnswerBoxes(); // places boxes based on choices\n  }\n\n  // Layout helpers using ctx.measureText\n  function drawTextWithBackground(text, x, y, font, textColor = '#051', bgColor = 'rgba(255,255,255,0.8)', padding = 10, align = 'left') {\n    ctx.font = font;\n    const metrics = ctx.measureText(text);\n    const textWidth = Math.ceil(metrics.width);\n    const textHeight = Math.ceil(parseInt(font, 10)); // approximate\n    let bx = x;\n    if (align === 'center') {\n      bx = x - textWidth / 2 - padding;\n    } else if (align === 'right') {\n      bx = x - textWidth - padding * 2;\n    }\n    const by = y;\n    ctx.fillStyle = bgColor;\n    ctx.fillRect(bx, by, textWidth + padding * 2, textHeight + padding);\n    ctx.fillStyle = textColor;\n    ctx.textBaseline = 'top';\n    if (align === 'center') {\n      ctx.textAlign = 'center';\n      ctx.fillText(text, x, y + padding / 2);\n    } else if (align === 'right') {\n      ctx.textAlign = 'right';\n      ctx.fillText(text, bx + textWidth + padding, y + padding / 2);\n    } else {\n      ctx.textAlign = 'left';\n      ctx.fillText(text, bx + padding, y + padding / 2);\n    }\n    return { bx, by, bw: textWidth + padding * 2, bh: textHeight + padding };\n  }\n\n  // Compute answer box positions ensuring non-overlap and using measureText\n  function computeAnswerBoxes() {\n    // We'll place three boxes centered horizontally in the lower-middle area\n    ctx.font = IMPORTANT_FONT;\n    const textWidths = state.choices.map((c) => Math.ceil(ctx.measureText(String(c)).width));\n    const boxHe = Math.max(40, parseInt(IMPORTANT_FONT, 10) + 14);\n    const spacingMin = 12; // minimum spacing between boxes\n    // Total width\n    const totalTextWidth = textWidths.reduce((a, b) => a + b, 0);\n    const totalBoxPadding = (textWidths.length) * 24; // left+right padding ~24 each\n    let totalWidth = totalTextWidth + totalBoxPadding + (state.choices.length - 1) * spacingMin;\n    const maxAreaWidth = WIDTH - 240; // leave room for drone on right\n    if (totalWidth > maxAreaWidth) {\n      // If too wide, reduce padding and spacing\n      const extra = totalWidth - maxAreaWidth;\n      // reduce spacing proportionally\n      totalWidth = maxAreaWidth;\n    }\n    const startX = Math.round((WIDTH - totalWidth) / 2);\n    const y = Math.round(HEIGHT * 0.45);\n    answerBoxes = [];\n    let x = startX;\n    for (let i = 0; i < state.choices.length; i++) {\n      const tw = textWidths[i];\n      const boxW = tw + 24;\n      answerBoxes.push({\n        x,\n        y,\n        w: boxW,\n        h: boxHe,\n        text: String(state.choices[i]),\n        index: i,\n      });\n      x += boxW + spacingMin;\n    }\n  }\n\n  // Hit test for clicks\n  function hitTestAnswer(mx, my) {\n    for (const box of answerBoxes) {\n      if (mx >= box.x && mx <= box.x + box.w && my >= box.y && my <= box.y + box.h) {\n        return box.index;\n      }\n    }\n    return -1;\n  }\n\n  // Input handlers\n  canvas.addEventListener('click', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    resumeAudioIfNeeded();\n    initAudio();\n    if (!audioInitialized) initAudio();\n    if (!audioAvailable && !audioInitialized) {\n      // Audio unavailable - continue anyway\n    } else {\n      startBackground();\n    }\n\n    if (state.mode === 'start') {\n      // Start the game\n      startGame();\n      return;\n    } else if (state.mode === 'playing') {\n      const hit = hitTestAnswer(mx, my);\n      if (hit >= 0) {\n        state.selectedIndex = hit;\n        submitAnswer();\n        return;\n      }\n    } else if (state.mode === 'victory' || state.mode === 'gameover') {\n      // Check if clicked restart button area\n      if (isInsideRestart(mx, my)) {\n        restartGame();\n      } else {\n        // clicking anywhere also restarts for convenience\n        restartGame();\n      }\n    }\n    // Handle clicking audio icon\n    if (isInsideAudioToggle(mx, my)) {\n      toggleMute();\n    }\n  });\n\n  function isInsideRestart(mx, my) {\n    // We'll draw restart button at bottom center; check approximate area\n    const bw = 160;\n    const bh = 46;\n    const bx = (WIDTH - bw) / 2;\n    const by = HEIGHT - bh - 20;\n    return mx >= bx && mx <= bx + bw && my >= by && my <= by + bh;\n  }\n\n  function isInsideAudioToggle(mx, my) {\n    // small rectangle top-left offset\n    const bx = 10;\n    const by = HEIGHT - 44;\n    const bw = 110;\n    const bh = 34;\n    return mx >= bx && mx <= bx + bw && my >= by && my <= by + bh;\n  }\n\n  window.addEventListener('keydown', (e) => {\n    const key = e.key;\n    if (key === 'm' || key === 'M') {\n      toggleMute();\n    } else if ((key === 'r' || key === 'R')) {\n      if (state.mode === 'victory' || state.mode === 'gameover') {\n        restartGame();\n      } else if (state.mode === 'start') {\n        startGame();\n      } else {\n        restartGame();\n      }\n    } else if ((key === ' ' || key === 'Spacebar') && state.mode === 'start') {\n      startGame();\n      e.preventDefault();\n    } else if (state.mode === 'playing') {\n      // number keys 1-3 to pick choices\n      if (key >= '1' && key <= '3') {\n        const idx = parseInt(key, 10) - 1;\n        if (idx < state.choices.length) {\n          state.selectedIndex = idx;\n          submitAnswer();\n        }\n      } else if (key === 'ArrowLeft') {\n        state.selectedIndex = (state.selectedIndex - 1 + state.choices.length) % state.choices.length;\n      } else if (key === 'ArrowRight') {\n        state.selectedIndex = (state.selectedIndex + 1) % state.choices.length;\n      } else if (key === 'Enter') {\n        submitAnswer();\n      }\n    }\n    resumeAudioIfNeeded();\n    initAudio();\n    startBackground();\n  });\n\n  function toggleMute() {\n    muted = !muted;\n    if (bgGain) bgGain.gain.value = muted ? 0 : 0.02;\n  }\n\n  // Game flow\n  function startGame() {\n    state.mode = 'playing';\n    state.correct = 0;\n    state.wrong = 0;\n    state.progress = 0;\n    startNewQuestion();\n    resumeAudioIfNeeded();\n    initAudio();\n    startBackground();\n    lastTick = performance.now();\n  }\n\n  function restartGame() {\n    state.mode = 'start';\n    state.correct = 0;\n    state.wrong = 0;\n    state.progress = 0;\n    state.question = null;\n    state.choices = [];\n    state.selectedIndex = 0;\n    answerBoxes = [];\n    stopBackground();\n  }\n\n  function submitAnswer() {\n    if (state.mode !== 'playing') return;\n    const chosen = state.choices[state.selectedIndex];\n    const isCorrect = Number(chosen) === Number(state.correctAnswer);\n    if (isCorrect) {\n      // correct\n      state.correct++;\n      state.progress = Math.min(GOAL, state.progress + 1);\n      playCorrectSound();\n      // small boost animation/time\n      if (state.correct >= GOAL) {\n        // victory\n        state.mode = 'victory';\n        stopBackground();\n        setTimeout(() => {\n          // leave as is\n        }, 300);\n        return;\n      }\n      // next question after brief delay\n      setTimeout(startNewQuestion, 400);\n    } else {\n      state.wrong++;\n      playWrongSound();\n      // vibrate drone or show wobble\n      if (state.wrong >= MAX_WRONG) {\n        state.mode = 'gameover';\n        stopBackground();\n        return;\n      } else {\n        // new question after a small delay\n        setTimeout(startNewQuestion, 450);\n      }\n    }\n  }\n\n  // Drawing utilities\n  function drawBackground() {\n    // calming gradient with wacky elements (floating clouds)\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, '#dff3ff');\n    g.addColorStop(1, '#ffffff');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Draw softly wavy lines (wind)\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = 'rgba(120,180,220,0.12)';\n    for (let i = 0; i < 5; i++) {\n      ctx.beginPath();\n      const y = 40 + i * 70;\n      ctx.moveTo(0, y);\n      for (let x = 0; x <= WIDTH; x += 20) {\n        const yy = y + Math.sin((x + performance.now() / 60) / 40 + i) * 8;\n        ctx.lineTo(x, yy);\n      }\n      ctx.stroke();\n    }\n    // soft clouds: made with arcs\n    ctx.fillStyle = 'rgba(255,255,255,0.9)';\n    const t = performance.now() / 1000;\n    const cloudCenters = [\n      { x: 120 + Math.sin(t / 4) * 16, y: 60 },\n      { x: 320 + Math.cos(t / 5) * 12, y: 80 },\n      { x: 520 + Math.sin(t / 6) * 10, y: 50 },\n    ];\n    for (const c of cloudCenters) {\n      ctx.beginPath();\n      ctx.arc(c.x, c.y, 24, 0, Math.PI * 2);\n      ctx.arc(c.x + 28, c.y + 4, 30, 0, Math.PI * 2);\n      ctx.arc(c.x + 56, c.y, 22, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n\n  function drawTopUI() {\n    // Score top-left\n    ctx.font = UI_FONT;\n    ctx.textBaseline = 'top';\n    ctx.fillStyle = '#053';\n    const scoreText = `Correct: ${state.correct}/${GOAL}`;\n    const sBox = drawTextWithBackground(scoreText, PADDING, PADDING, UI_FONT, '#053', 'rgba(255,255,255,0.9)', PADDING, 'left');\n\n    // Lives top-right with hearts\n    const livesText = `Lives: ${Math.max(0, MAX_WRONG - state.wrong)}`;\n    const metrics = ctx.measureText(livesText);\n    ctx.font = UI_FONT;\n    const textWidth = Math.ceil(metrics.width);\n    const bx = WIDTH - textWidth - PADDING * 3;\n    const by = PADDING;\n    ctx.fillStyle = 'rgba(255,255,255,0.9)';\n    ctx.fillRect(bx, by, textWidth + PADDING * 2, parseInt(UI_FONT, 10) + PADDING);\n    ctx.fillStyle = '#550';\n    ctx.textAlign = 'left';\n    ctx.fillText(livesText, bx + PADDING, by + PADDING / 2);\n\n    // Audio status bottom-left-ish (accessible)\n    ctx.font = '14px sans-serif';\n    const audioText = audioAvailable ? (muted ? 'Audio: Off (M)' : 'Audio: On (M)') : 'Audio: Unavailable';\n    const ax = PADDING;\n    const ay = HEIGHT - 44;\n    const audMetrics = ctx.measureText(audioText);\n    const aw = Math.ceil(audMetrics.width) + PADDING * 2;\n    const ah = 34;\n    ctx.fillStyle = 'rgba(255,255,255,0.9)';\n    ctx.fillRect(ax, ay, aw, ah);\n    ctx.fillStyle = '#333';\n    ctx.fillText(audioText, ax + PADDING, ay + 10);\n\n    // Instructions bottom-center (non-overlapping)\n    ctx.font = '18px sans-serif';\n    const inst = state.mode === 'start' ? 'Press Space or Click to Start. Use 1-3, arrows or click answers.' : 'Use 1-3 or click. Enter to submit. Press M to toggle audio.';\n    const centerX = WIDTH / 2;\n    // measure\n    const instWidth = Math.ceil(ctx.measureText(inst).width);\n    const ix = centerX - instWidth / 2 - PADDING;\n    const iy = HEIGHT - 44;\n    ctx.fillStyle = 'rgba(255,255,255,0.95)';\n    ctx.fillRect(ix, iy, instWidth + PADDING * 2, 34);\n    ctx.fillStyle = '#014';\n    ctx.textAlign = 'center';\n    ctx.fillText(inst, centerX, iy + 8);\n  }\n\n  function drawQuestionArea() {\n    // centered near top middle-left (leave room for drone)\n    ctx.font = TITLE_FONT;\n    ctx.textBaseline = 'top';\n    ctx.fillStyle = '#053';\n    const question = state.question || 'Get ready!';\n    const x = WIDTH / 2 - 120;\n    const y = 80;\n    // use measureText to compute rect\n    ctx.font = TITLE_FONT;\n    const metrics = ctx.measureText(question);\n    const w = Math.ceil(metrics.width);\n    const h = parseInt(TITLE_FONT, 10) + 8;\n    ctx.fillStyle = 'rgba(255,255,255,0.95)';\n    ctx.fillRect(x - PADDING, y - PADDING, w + PADDING * 2 + 20, h + PADDING);\n    ctx.fillStyle = '#024';\n    ctx.textAlign = 'left';\n    ctx.fillText(question, x + 8, y);\n  }\n\n  function drawChoices() {\n    // draw boxes from answerBoxes\n    ctx.font = IMPORTANT_FONT;\n    for (const box of answerBoxes) {\n      // background\n      const isSelected = state.selectedIndex === box.index && state.mode === 'playing';\n      ctx.fillStyle = isSelected ? 'rgba(245,235,200,0.95)' : 'rgba(255,255,255,0.95)';\n      ctx.fillRect(box.x, box.y, box.w, box.h);\n      // border\n      ctx.strokeStyle = isSelected ? '#f7a' : '#cce';\n      ctx.lineWidth = isSelected ? 3 : 2;\n      ctx.strokeRect(box.x + 0.5, box.y + 0.5, box.w - 1, box.h - 1);\n      // text\n      ctx.fillStyle = '#023';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(box.text, box.x + box.w / 2, box.y + box.h / 2);\n      // small label number\n      ctx.font = '12px sans-serif';\n      ctx.fillStyle = '#666';\n      ctx.textAlign = 'left';\n      ctx.fillText(String(box.index + 1), box.x + 6, box.y + 6);\n      ctx.font = IMPORTANT_FONT;\n    }\n  }\n\n  // Drone drawing\n  function drawDrone() {\n    // Position drone on right side. Vertical bobbing based on time and progress.\n    const baseX = WIDTH - 160;\n    const baseY = HEIGHT / 2 + (GOAL - state.progress) * 6 - 20; // progress causes ascent\n    const t = performance.now() / 500;\n    const bob = Math.sin(t) * 6;\n    const x = baseX;\n    const y = baseY + bob;\n    // Body\n    ctx.save();\n    ctx.translate(x, y);\n    // shadow\n    ctx.fillStyle = 'rgba(0,0,0,0.08)';\n    ctx.beginPath();\n    ctx.ellipse(18, 54, 46, 12, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = '#fffbcc';\n    ctx.strokeStyle = '#333';\n    // main body\n    ctx.fillStyle = '#eaf7ff';\n    ctx.strokeStyle = '#0b3';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.ellipse(0, 0, 48, 26, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n    // cockpit\n    ctx.fillStyle = '#d0f0ff';\n    ctx.beginPath();\n    ctx.ellipse(8, -4, 18, 12, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n\n    // weird wacky smile\n    ctx.strokeStyle = '#0a4';\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.arc(8, 2, 8, 0.2, Math.PI - 0.2);\n    ctx.stroke();\n\n    // rotor arms and rotors\n    const rotorOffsets = [\n      { rx: -38, ry: -18 },\n      { rx: 38, ry: -18 },\n      { rx: -38, ry: 18 },\n      { rx: 38, ry: 18 },\n    ];\n    const rotAngle = performance.now() / 120;\n    rotorOffsets.forEach((o, i) => {\n      // arm\n      ctx.strokeStyle = 'rgba(10,60,80,0.6)';\n      ctx.lineWidth = 4;\n      ctx.beginPath();\n      ctx.moveTo(o.rx / 2, o.ry / 2);\n      ctx.lineTo(o.rx, o.ry);\n      ctx.stroke();\n      // rotor hub\n      ctx.fillStyle = '#f5f5f0';\n      ctx.beginPath();\n      ctx.arc(o.rx, o.ry, 8, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n      // blades - wacky: 3 blades rotating\n      ctx.save();\n      ctx.translate(o.rx, o.ry);\n      ctx.rotate(rotAngle + i);\n      ctx.fillStyle = 'rgba(120,160,180,0.85)';\n      for (let b = 0; b < 3; b++) {\n        ctx.beginPath();\n        ctx.ellipse(0, 14, 3.5, 14, b * (Math.PI * 2 / 3), 0, Math.PI * 2);\n        ctx.fill();\n      }\n      ctx.restore();\n    });\n\n    ctx.restore();\n\n    // Altitude meter (progress)\n    const meterX = WIDTH - 80;\n    const meterY = 40;\n    const meterW = 24;\n    const meterH = 240;\n    ctx.fillStyle = 'rgba(255,255,255,0.95)';\n    ctx.fillRect(meterX - 12, meterY - 8, meterW + 24, meterH + 16);\n    ctx.strokeStyle = '#cce';\n    ctx.strokeRect(meterX - 12 + 0.5, meterY - 8 + 0.5, meterW + 24 - 1, meterH + 16 - 1);\n    // meter bar background\n    ctx.fillStyle = '#eef6ff';\n    ctx.fillRect(meterX, meterY, meterW, meterH);\n    // filled portion\n    const filledH = Math.round((state.progress / GOAL) * meterH);\n    ctx.fillStyle = '#7fd3a6';\n    ctx.fillRect(meterX, meterY + (meterH - filledH), meterW, filledH);\n    ctx.strokeStyle = '#2b8';\n    ctx.strokeRect(meterX, meterY, meterW, meterH);\n    // small labels\n    ctx.fillStyle = '#224';\n    ctx.font = '12px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('Altitude', meterX + meterW / 2, meterY - 20);\n    ctx.fillText(`${state.progress}/${GOAL}`, meterX + meterW / 2, meterY + meterH + 6);\n  }\n\n  function drawStarsCollected() {\n    // Draw collected little stars near top-right below score\n    const sx = WIDTH - 180;\n    const sy = 18 + 40;\n    for (let i = 0; i < GOAL; i++) {\n      const cx = sx + (i % 5) * 18;\n      const cy = sy + Math.floor(i / 5) * 18;\n      drawStar(cx, cy, 6, i < state.progress ? '#ffd24d' : '#f0f0f0', i < state.progress ? '#e68400' : '#ccc');\n    }\n  }\n\n  function drawStar(cx, cy, r, fill, stroke) {\n    ctx.save();\n    ctx.beginPath();\n    for (let i = 0; i < 5; i++) {\n      const a = (Math.PI * 2 * i) / 5 - Math.PI / 2;\n      const sx = cx + Math.cos(a) * r;\n      const sy = cy + Math.sin(a) * r;\n      ctx.lineTo(sx, sy);\n      const a2 = a + Math.PI / 5;\n      ctx.lineTo(cx + Math.cos(a2) * (r / 2), cy + Math.sin(a2) * (r / 2));\n    }\n    ctx.closePath();\n    ctx.fillStyle = fill;\n    ctx.fill();\n    ctx.strokeStyle = stroke;\n    ctx.lineWidth = 1;\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  // Victory and Game Over screens\n  function drawEndScreen() {\n    ctx.fillStyle = 'rgba(0,0,0,0.25)';\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    ctx.textAlign = 'center';\n    ctx.fillStyle = '#fff';\n    ctx.font = '40px sans-serif';\n    const title = state.mode === 'victory' ? 'Mission Accomplished!' : 'Game Over';\n    const subtitle = state.mode === 'victory' ? 'The drone is airborne! Great job!' : `You had ${state.wrong} wrong answers. Try again!`;\n    // compute text widths and draw background box using measureText\n    ctx.font = TITLE_FONT;\n    const titleW = Math.ceil(ctx.measureText(title).width);\n    const boxW = Math.max(420, titleW + 60);\n    const bx = (WIDTH - boxW) / 2;\n    const by = HEIGHT / 2 - 110;\n    ctx.fillStyle = 'rgba(255,255,255,0.96)';\n    ctx.fillRect(bx, by, boxW, 220);\n    ctx.fillStyle = '#063';\n    ctx.font = TITLE_FONT;\n    ctx.fillText(title, WIDTH / 2, by + 22);\n    ctx.font = IMPORTANT_FONT;\n    ctx.fillStyle = '#024';\n    ctx.fillText(subtitle, WIDTH / 2, by + 72);\n\n    // restart button\n    const bw = 160;\n    const bh = 46;\n    const rx = (WIDTH - bw) / 2;\n    const ry = by + 130;\n    ctx.fillStyle = '#e6f8ff';\n    ctx.fillRect(rx, ry, bw, bh);\n    ctx.strokeStyle = '#7cc';\n    ctx.strokeRect(rx + 0.5, ry + 0.5, bw - 1, bh - 1);\n    ctx.fillStyle = '#045';\n    ctx.font = '18px sans-serif';\n    ctx.fillText('Restart (R)', WIDTH / 2, ry + 12);\n\n    // small hint for accessibility\n    ctx.font = '14px sans-serif';\n    ctx.fillStyle = '#113';\n    ctx.fillText('Press R or click Restart to play again.', WIDTH / 2, ry + 40);\n  }\n\n  // Main draw loop\n  let lastTick = performance.now();\n  function frame() {\n    // update\n    const now = performance.now();\n    const dt = (now - lastTick) / 1000;\n    lastTick = now;\n\n    // clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    drawBackground();\n    drawTopUI();\n    drawQuestionArea();\n\n    if (state.mode === 'start') {\n      // big start card in center\n      ctx.font = '26px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillStyle = '#023';\n      const title = 'Drone Math \u2014 Power the Drone!';\n      const subtitle = 'Answer 10 questions correctly to lift off. 3 wrong answers and the mission fails.';\n      // measure and background\n      const w1 = Math.ceil(ctx.measureText(title).width);\n      ctx.font = '16px sans-serif';\n      const w2 = Math.ceil(ctx.measureText(subtitle).width);\n      const boxW = Math.max(w1, w2) + 40;\n      const bx = (WIDTH - boxW) / 2;\n      const by = HEIGHT / 2 - 70;\n      ctx.fillStyle = 'rgba(255,255,255,0.95)';\n      ctx.fillRect(bx, by, boxW, 140);\n      ctx.fillStyle = '#024';\n      ctx.font = '26px sans-serif';\n      ctx.fillText(title, WIDTH / 2, by + 10);\n      ctx.font = '16px sans-serif';\n      ctx.fillText(subtitle, WIDTH / 2, by + 52);\n      ctx.fillStyle = '#046';\n      ctx.font = '18px sans-serif';\n      ctx.fillText('Press Space or Click to Start. Use 1-3 or click answers.', WIDTH / 2, by + 92);\n\n      // tiny robot/drone doodle\n      ctx.save();\n      ctx.translate(WIDTH / 2 + 180, HEIGHT / 2 - 40);\n      ctx.fillStyle = '#fff2cc';\n      ctx.beginPath();\n      ctx.ellipse(0, 0, 30, 16, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.strokeStyle = '#c89';\n      ctx.stroke();\n      ctx.restore();\n    } else if (state.mode === 'playing') {\n      drawChoices();\n      drawDrone();\n      drawStarsCollected();\n    } else if (state.mode === 'victory' || state.mode === 'gameover') {\n      drawDrone();\n      drawStarsCollected();\n      drawEndScreen();\n    }\n\n    // accessibility focus highlight for selected answer (if playing)\n    if (state.mode === 'playing' && answerBoxes[state.selectedIndex]) {\n      const b = answerBoxes[state.selectedIndex];\n      ctx.save();\n      ctx.strokeStyle = '#ff8';\n      ctx.lineWidth = 3;\n      ctx.setLineDash([6, 6]);\n      ctx.strokeRect(b.x - 4, b.y - 4, b.w + 8, b.h + 8);\n      ctx.restore();\n    }\n\n    // next frame\n    requestAnimationFrame(frame);\n  }\n\n  // initial setup\n  initAudio();\n  restartGame();\n  // compute initial text layout to ensure no overlaps\n  ctx.font = UI_FONT;\n  computeAnswerBoxes();\n\n  // Start render loop\n  requestAnimationFrame(frame);\n\n  // Expose some debug functions to console (optional)\n  window.__droneMathGame = {\n    restart: restartGame,\n    start: startGame,\n    state,\n  };\n})();\n---\n",
  "improve_response_tokens": 21155,
  "formatted_code": true,
  "formatting_response_tokens": 23805,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}