# Game of the Day - 2025-09-02

## Metadata
- **Generated Date:** 2025-09-02
- **Generated Time:** 2025-09-02T00:26:51.854883
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-02.js
- **File Size:** 26055 bytes
- **Tokens Used:** 9442

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-02.js` - The playable game
- `2025-09-02.meta.json` - Machine-readable metadata
- `2025-09-02.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 19683

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 20585

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(() => {
  // Machine Math — a calming, wacky math game for ages 7–9.
  // Renders inside element with ID "game-of-the-day-stage".
  // All visuals drawn on canvas. Sounds generated with Web Audio API.
  // Written with modern JS practices, clear structure, and error handling.

  // Config
  const WIDTH = 720;
  const HEIGHT = 480;
  const STAGE_ID = "game-of-the-day-stage";
  const MAX_LEVEL = 6;
  const LIVES = 3;

  // Grab stage element
  const stage = document.getElementById(STAGE_ID);
  if (!stage) {
    console.error(`Missing container element with id "${STAGE_ID}"`);
    return;
  }
  // Clear stage
  stage.innerHTML = "";

  // Create a visually hidden live region for screen readers (text alternatives)
  const liveRegion = document.createElement("div");
  liveRegion.setAttribute("role", "status");
  liveRegion.setAttribute("aria-live", "polite");
  liveRegion.style.position = "absolute";
  liveRegion.style.left = "-9999px";
  liveRegion.style.width = "1px";
  liveRegion.style.height = "1px";
  stage.appendChild(liveRegion);

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.tabIndex = 0; // allow keyboard focus
  canvas.style.outline = "none";
  canvas.style.display = "block";
  canvas.setAttribute("aria-label", "Machine Math. Use arrow keys to pick parts and Enter to feed the machine.");
  stage.appendChild(canvas);
  const ctx = canvas.getContext("2d");

  // Accessibility: focus canvas so keyboard events work
  canvas.focus();

  // Audio setup
  let audioCtx = null;
  let masterGain = null;
  let bgGainNode = null;
  let isAudioAllowed = false;
  let audioEnabled = true; // user can toggle
  // Visual cue for audio: small icon drawn on canvas, and live updates.

  // Try to create AudioContext with error handling
  function createAudioContext() {
    if (audioCtx) return audioCtx;
    try {
      // Some browsers require user gesture to start audio. Create but suspended.
      const AC = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AC();
      masterGain = audioCtx.createGain();
      masterGain.connect(audioCtx.destination);
      masterGain.gain.value = 0.95;
      // background gentle hum
      bgGainNode = audioCtx.createGain();
      bgGainNode.gain.value = 0.02; // gentle
      bgGainNode.connect(masterGain);
    } catch (e) {
      audioCtx = null;
      console.warn("Web Audio not available:", e);
      liveAnnounce("Audio is not available in this browser.");
    }
    return audioCtx;
  }

  // Call to ensure audio allowed (on user gesture)
  async function tryResumeAudio() {
    try {
      createAudioContext();
      if (audioCtx && audioCtx.state === "suspended") {
        await audioCtx.resume();
      }
      isAudioAllowed = true;
      liveAnnounce("Audio enabled.");
      startBackgroundHum();
    } catch (e) {
      console.warn("Audio resume failed", e);
      liveAnnounce("Unable to enable audio.");
    }
  }

  // Sound generators
  function playClick() {
    if (!audioCtx || !audioEnabled) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "sine";
      o.frequency.value = 880;
      g.gain.value = 0.0001;
      o.connect(g);
      g.connect(masterGain);
      const now = audioCtx.currentTime;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.02, now + 0.02);
      o.start(now);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.16);
      o.stop(now + 0.18);
    } catch (e) {
      console.warn("playClick error", e);
    }
  }

  function playWrong() {
    if (!audioCtx || !audioEnabled) return;
    try {
      const o = audioCtx.createOscillator();
      const f = audioCtx.createBiquadFilter();
      const g = audioCtx.createGain();
      o.type = "sawtooth";
      o.frequency.value = 200;
      f.type = "lowpass";
      f.frequency.value = 1200;
      o.connect(f);
      f.connect(g);
      g.connect(masterGain);
      const now = audioCtx.currentTime;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.08, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);
      o.start(now);
      o.stop(now + 0.62);
    } catch (e) {
      console.warn("playWrong error", e);
    }
  }

  function playSuccess() {
    if (!audioCtx || !audioEnabled) return;
    try {
      const now = audioCtx.currentTime;
      // Play a short major chord using three oscillators
      const freqs = [660, 830, 990]; // harmonically pleasing
      const gains = freqs.map(() => audioCtx.createGain());
      const oscs = freqs.map((f, i) => {
        const o = audioCtx.createOscillator();
        o.type = i === 1 ? "triangle" : "sine";
        o.frequency.value = f;
        o.connect(gains[i]);
        gains[i].connect(masterGain);
        gains[i].gain.setValueAtTime(0.0001, now);
        gains[i].gain.exponentialRampToValueAtTime(0.04, now + 0.02);
        gains[i].gain.exponentialRampToValueAtTime(0.0001, now + 0.7);
        o.start(now);
        o.stop(now + 0.72);
        return o;
      });
    } catch (e) {
      console.warn("playSuccess error", e);
    }
  }

  function startBackgroundHum() {
    if (!audioCtx || !audioEnabled) return;
    try {
      // A subtle drifting oscillator for calming machine hum
      const o = audioCtx.createOscillator();
      const lfo = audioCtx.createOscillator();
      const lfoGain = audioCtx.createGain();
      const g = bgGainNode || audioCtx.createGain();
      if (!bgGainNode) {
        bgGainNode = g;
        bgGainNode.connect(masterGain);
      }
      o.type = "sine";
      o.frequency.value = 90;
      lfo.type = "sine";
      lfo.frequency.value = 0.08;
      lfoGain.gain.value = 10;
      lfo.connect(lfoGain);
      lfoGain.connect(o.frequency);
      o.connect(g);
      g.gain.value = 0.02;
      try {
        o.start();
        lfo.start();
      } catch (e) {
        // ignore already started
      }
      // keep references so the oscillator doesn't get GC'd
      bgHumOsc = { o, lfo, g };
    } catch (e) {
      console.warn("startBackgroundHum error", e);
    }
  }
  let bgHumOsc = null;

  function stopBackgroundHum() {
    try {
      if (bgHumOsc) {
        // No built-in stop for lfo later? We can disconnect instead.
        bgHumOsc.o.disconnect();
        bgHumOsc.lfo.disconnect();
        bgHumOsc.g.disconnect();
        bgHumOsc = null;
      }
    } catch (e) {
      console.warn("stopBackgroundHum error", e);
    }
  }

  // Utility: announce to screen reader
  function liveAnnounce(text) {
    liveRegion.innerText = text;
  }

  // Game state
  const state = {
    level: 1,
    lives: LIVES,
    target: 10,
    currentSum: 0,
    parts: [], // array of {value, id, x, y, picked}
    selectorIndex: 0,
    animParticles: [],
    gameOver: false,
    levelComplete: false,
    paused: false,
    ticks: 0,
    audioOn: true,
  };

  // Create parts such that there is at least one exact combination
  function generateLevel(level) {
    state.currentSum = 0;
    state.level = level;
    state.lives = state.lives; // unchanged
    state.gameOver = false;
    state.levelComplete = false;
    state.ticks = 0;
    // Target increases with level
    const base = 5 + level * 2; // 7,9,11...
    const target = base + Math.floor(Math.random() * 6); // up to +5
    state.target = Math.max(5, Math.min(20, target));
    // Create a solvable combination: pick 2-3 numbers that sum to target
    const comboLen = Math.random() < 0.5 ? 2 : 3;
    const combo = [];
    let rem = state.target;
    for (let i = comboLen - 1; i >= 0; i--) {
      const maxVal = Math.max(1, rem - i); // ensure at least 1 per remaining
      const val = Math.floor(Math.random() * Math.min(6 + level, maxVal)) + 1;
      combo.push(val);
      rem -= val;
    }
    // If leftover, add to first
    if (rem > 0) combo[0] += rem;

    // Build parts: include combo numbers and distractors
    const parts = [];
    let idCounter = 0;
    // Add combo parts
    for (const v of combo) {
      parts.push({ value: v, id: idCounter++, picked: false });
    }
    // Add distractors (to total 5)
    while (parts.length < 5) {
      const v = Math.floor(Math.random() * (6 + level)) + 1;
      // avoid making another trivial duplicate that makes many solutions; allow duplicates sometimes
      parts.push({ value: v, id: idCounter++, picked: false });
    }
    // Shuffle parts
    for (let i = parts.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [parts[i], parts[j]] = [parts[j], parts[i]];
    }
    // Assign positions for conveyor and floating animation properties
    const startY = HEIGHT - 120;
    const spacing = 120;
    const startX = WIDTH / 2 - (parts.length - 1) * spacing / 2;
    parts.forEach((p, i) => {
      p.x = startX + i * spacing;
      p.y = startY + Math.sin(i) * 6;
      p.offset = 0;
      p.faceOffset = Math.random() * Math.PI * 2;
    });

    state.parts = parts;
    state.selectorIndex = 0;
    liveAnnounce(`Level ${state.level}. Target ${state.target}. You have ${state.lives} lives.`);
  }

  // Draw utilities (calming pastel palette)
  const palette = {
    sky: "#EAF6FF",
    machine: "#9AD3DE",
    accent: "#FFB6C1",
    metal: "#C6C8CA",
    bolt: "#FFD27F",
    text: "#1B2430",
    cloud: "#FFFFFF",
    shadow: "rgba(27,36,48,0.12)",
  };

  function drawRoundedRect(x, y, w, h, r, fillStyle, strokeStyle) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fillStyle) {
      ctx.fillStyle = fillStyle;
      ctx.fill();
    }
    if (strokeStyle) {
      ctx.strokeStyle = strokeStyle;
      ctx.stroke();
    }
  }

  // Draw machine, conveyor, parts, selector, UI
  function render() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    // Background sky
    ctx.fillStyle = palette.sky;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Soft hills
    ctx.fillStyle = "#DFF3E8";
    ctx.beginPath();
    ctx.ellipse(140, 420, 180, 70, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(540, 440, 200, 90, 0, 0, Math.PI * 2);
    ctx.fill();

    // Clouds (wacky)
    drawCloud(120, 80, 100, 50, 0.9);
    drawCloud(480, 60, 140, 60, 0.8);
    drawCloud(320, 120, 120, 50, 0.85);

    // Machine body
    drawMachine();

    // Conveyor belt
    drawConveyor();

    // Parts on conveyor
    for (let i = 0; i < state.parts.length; i++) {
      drawPart(state.parts[i], i === state.selectorIndex);
    }

    // Machine display with target and current sum
    drawDisplay();

    // Lives and level
    drawHUD();

    // Visual audio icon
    drawAudioIcon(650, 16);

    // Tooltip / instructions small
    ctx.fillStyle = palette.text;
    ctx.font = "14px Arial";
    ctx.fillText("Controls: ← → to move • Enter / Space to feed • 1-5 to pick • M to mute • R to restart", 14, HEIGHT - 12);

    // Particle animations
    renderParticles();

    // If paused overlay
    if (state.paused) {
      ctx.fillStyle = "rgba(20,20,30,0.5)";
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = "#FFF";
      ctx.font = "28px Arial";
      ctx.fillText("Paused", WIDTH / 2 - 40, HEIGHT / 2 - 10);
    }

    // If level complete overlay
    if (state.levelComplete) {
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      drawRoundedRect(WIDTH / 2 - 180, HEIGHT / 2 - 90, 360, 180, 14, "rgba(255,255,255,0.98)", palette.shadow);
      ctx.fillStyle = "#223";
      ctx.font = "24px Arial";
      ctx.fillText(`Level ${state.level} Complete!`, WIDTH / 2 - 120, HEIGHT / 2 - 20);
      ctx.font = "18px Arial";
      ctx.fillText("Press Enter to continue", WIDTH / 2 - 110, HEIGHT / 2 + 20);
    }

    if (state.gameOver) {
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = "#FFF";
      ctx.font = "28px Arial";
      ctx.fillText("Game Over", WIDTH / 2 - 80, HEIGHT / 2 - 20);
      ctx.font = "18px Arial";
      ctx.fillText("Press R to try again.", WIDTH / 2 - 90, HEIGHT / 2 + 20);
    }
  }

  function drawCloud(x, y, w, h, alpha) {
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = palette.cloud;
    ctx.beginPath();
    ctx.ellipse(x, y, w * 0.5, h * 0.5, 0, 0, Math.PI * 2);
    ctx.ellipse(x + w * 0.3, y - 10, w * 0.3, h * 0.35, 0, 0, Math.PI * 2);
    ctx.ellipse(x - w * 0.35, y - 8, w * 0.28, h * 0.32, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawMachine() {
    // Body
    drawRoundedRect(120, 80, 480, 220, 18, palette.machine, palette.shadow);
    // Front panel
    drawRoundedRect(160, 140, 400, 120, 12, palette.metal, null);
    // Gears (wacky)
    drawGear(200, 190, 36, 8, "#E6A6FF", 0.03 * state.ticks);
    drawGear(330, 170, 50, 10, "#BFD8FF", -0.02 * state.ticks);
    drawGear(470, 200, 28, 6, "#FFD7A6", 0.05 * state.ticks);
    // Pipe and nozzle
    ctx.fillStyle = "#9BB3A9";
    ctx.fillRect(520, 170, 90, 18);
    ctx.beginPath();
    ctx.moveTo(610, 170);
    ctx.lineTo(640, 150);
    ctx.lineTo(640, 188);
    ctx.closePath();
    ctx.fill();
    // Steam puffs near top-right
    for (let i = 0; i < 3; i++) {
      const a = Math.sin((state.ticks / 60) + i) * 6;
      ctx.globalAlpha = 0.45;
      ctx.fillStyle = "#FFF";
      ctx.beginPath();
      ctx.ellipse(540 + i * 18, 90 - (state.ticks % 40) * 0.5 - a, 18, 10, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  function drawGear(cx, cy, r, teeth, color, rotation) {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(rotation || 0);
    ctx.fillStyle = color;
    ctx.beginPath();
    for (let i = 0; i < teeth * 2; i++) {
      const angle = (i / (teeth * 2)) * Math.PI * 2;
      const rad = i % 2 === 0 ? r : r * 0.74;
      ctx.lineTo(Math.cos(angle) * rad, Math.sin(angle) * rad);
    }
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "rgba(255,255,255,0.2)";
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.4, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawConveyor() {
    // Belt
    const beltY = HEIGHT - 140;
    ctx.fillStyle = "#6C6F70"; // dark belt
    drawRoundedRect(40, beltY - 24, WIDTH - 80, 48, 12, "#6C6F70");
    // Little teeth pattern
    ctx.fillStyle = "#4B4D4E";
    for (let i = 0; i < 16; i++) {
      ctx.fillRect(60 + i * 40, beltY - 10, 18, 20);
    }
    // Machine receiving tray
    drawRoundedRect(560, beltY - 64, 120, 64, 10, "#DDEBF2");
  }

  function drawPart(part, isSelected) {
    // Floating wobble
    part.offset += 0.03;
    const bob = Math.sin(part.offset + part.faceOffset) * 6;
    const x = part.x;
    const y = part.y + bob;
    // Shadow
    ctx.fillStyle = "rgba(0,0,0,0.08)";
    ctx.beginPath();
    ctx.ellipse(x, y + 36, 36, 12, 0, 0, Math.PI * 2);
    ctx.fill();
    // Body
    drawRoundedRect(x - 36, y - 28, 72, 56, 12, palette.bolt);
    // Funny face: eyes and mouth
    ctx.fillStyle = "#3b3b3b";
    ctx.beginPath();
    ctx.arc(x - 12, y - 6, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x + 12, y - 6, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "#3b3b3b";
    ctx.beginPath();
    ctx.moveTo(x - 8, y + 6);
    ctx.quadraticCurveTo(x, y + 12, x + 8, y + 6);
    ctx.stroke();
    // Value text
    ctx.fillStyle = palette.text;
    ctx.font = "20px Arial";
    ctx.fillText(String(part.value), x - 6, y + 6);
    // selection ring
    if (isSelected && !part.picked) {
      ctx.strokeStyle = "#3B82F6";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(x, y, 48, 0, Math.PI * 2);
      ctx.stroke();
      ctx.lineWidth = 1;
    }

    // If picked, animate toward machine
    if (part.picked) {
      // Particle puff
      createParticles(x, y, 6, palette.accent);
    }
  }

  // Simple particle system for visual feedback
  function createParticles(x, y, n, color) {
    for (let i = 0; i < n; i++) {
      state.animParticles.push({
        x,
        y,
        vx: (Math.random() - 0.5) * 2,
        vy: -Math.random() * 2 - 0.5,
        life: 40 + Math.random() * 20,
        color,
      });
    }
  }
  function renderParticles() {
    for (let i = state.animParticles.length - 1; i >= 0; i--) {
      const p = state.animParticles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.06;
      p.life--;
      if (p.life <= 0) {
        state.animParticles.splice(i, 1);
        continue;
      }
      ctx.globalAlpha = Math.max(0, p.life / 80);
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  function drawDisplay() {
    // Screen on machine
    const sx = 210;
    const sy = 110;
    const sw = 300;
    const sh = 80;
    drawRoundedRect(sx, sy, sw, sh, 8, "#071A2B");
    // Target and sum
    ctx.fillStyle = "#A6F0C3";
    ctx.font = "26px Arial";
    ctx.fillText("TARGET:", sx + 18, sy + 30);
    ctx.fillStyle = "#FFF";
    ctx.font = "bold 34px Arial";
    ctx.fillText(String(state.target), sx + 150, sy + 30);
    ctx.fillStyle = "#FFD9A6";
    ctx.font = "22px Arial";
    ctx.fillText("SUM:", sx + 18, sy + 64);
    ctx.fillStyle = "#FFF";
    ctx.font = "24px Arial";
    ctx.fillText(String(state.currentSum), sx + 150, sy + 64);

    // Visual meter showing progress
    const meterX = sx + sw + 10;
    const meterY = sy + 12;
    const meterW = 32;
    const meterH = sh - 24;
    ctx.fillStyle = "#2B8F74";
    ctx.fillRect(meterX, meterY + (meterH * (1 - Math.min(1, state.currentSum / state.target))), meterW, meterH * Math.min(1, state.currentSum / state.target));
    ctx.strokeStyle = "#FFF3";
    ctx.strokeRect(meterX, meterY, meterW, meterH);
  }

  function drawHUD() {
    // Lives hearts
    const heartX = 18;
    const heartY = 18;
    for (let i = 0; i < LIVES; i++) {
      drawHeart(heartX + i * 28, heartY, i < state.lives ? "#FF6B6B" : "#F0CFCF");
    }
    // Level
    ctx.fillStyle = palette.text;
    ctx.font = "18px Arial";
    ctx.fillText(`Level ${state.level} / ${MAX_LEVEL}`, 110, 32);
  }

  function drawHeart(x, y, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x, y + 4);
    ctx.bezierCurveTo(x, y - 6, x + 18, y - 6, x + 18, y + 4);
    ctx.bezierCurveTo(x + 18, y + 22, x + 9, y + 28, x, y + 36);
    ctx.bezierCurveTo(x - 9, y + 28, x - 18, y + 22, x - 18, y + 4);
    ctx.bezierCurveTo(x - 18, y - 6, x - 9, y - 6, x, y + 4);
    ctx.fill();
  }

  function drawAudioIcon(x, y) {
    ctx.save();
    ctx.translate(x, y);
    // Speaker
    ctx.fillStyle = audioEnabled ? "#333" : "#AAA";
    ctx.beginPath();
    ctx.moveTo(0, 8);
    ctx.lineTo(0, -8);
    ctx.lineTo(10, -8);
    ctx.lineTo(18, -16);
    ctx.lineTo(18, 16);
    ctx.lineTo(10, 8);
    ctx.closePath();
    ctx.fill();
    // Bars (visual cue)
    if (audioEnabled) {
      const barCount = 3;
      for (let i = 0; i < barCount; i++) {
        const h = 6 + Math.abs(Math.sin((state.ticks / 40) + i)) * 12;
        ctx.fillRect(22 + i * 8, -h / 2, 6, h);
      }
    } else {
      // muted X
      ctx.strokeStyle = "#FAFAFA";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(22, -14);
      ctx.lineTo(38, 4);
      ctx.moveTo(22, 4);
      ctx.lineTo(38, -14);
      ctx.stroke();
      ctx.lineWidth = 1;
    }
    ctx.restore();
  }

  // Input handling
  function onKeyDown(e) {
    // ensure audio can start on first user gesture
    tryResumeAudio();
    if (state.gameOver) {
      if (e.key === "r" || e.key === "R") {
        restartGame();
      }
      return;
    }
    if (state.levelComplete) {
      if (e.key === "Enter" || e.key === " ") {
        nextLevel();
      }
      return;
    }
    if (e.key === "m" || e.key === "M") {
      toggleAudio();
      return;
    }
    if (e.key === "p" || e.key === "P") {
      state.paused = !state.paused;
      liveAnnounce(state.paused ? "Game paused" : "Game resumed");
      return;
    }
    if (state.paused) return;

    if (e.key === "ArrowLeft") {
      state.selectorIndex = Math.max(0, state.selectorIndex - 1);
      playClick();
    } else if (e.key === "ArrowRight") {
      state.selectorIndex = Math.min(state.parts.length - 1, state.selectorIndex + 1);
      playClick();
    } else if (e.key === "Enter" || e.key === " ") {
      pickPart(state.selectorIndex);
    } else if (/^[1-5]$/.test(e.key)) {
      const idx = parseInt(e.key, 10) - 1;
      if (idx >= 0 && idx < state.parts.length) {
        state.selectorIndex = idx;
        pickPart(idx);
      }
    } else if (e.key === "r" || e.key === "R") {
      restartGame();
    }
  }

  // Mouse click handling for picking parts and audio icon
  function onMouseDown(e) {
    tryResumeAudio();
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    // Check audio icon area
    if (mx >= 650 && my <= 40) {
      toggleAudio();
      return;
    }
    // If clicking on part area, pick nearest part
    let nearestIdx = -1;
    let nearestDist = 1e9;
    for (let i = 0; i < state.parts.length; i++) {
      const p = state.parts[i];
      const dx = mx - p.x;
      const dy = my - p.y;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d < nearestDist && d < 60) {
        nearestDist = d;
        nearestIdx = i;
      }
    }
    if (nearestIdx >= 0) {
      state.selectorIndex = nearestIdx;
      pickPart(nearestIdx);
    }
  }

  function toggleAudio() {
    audioEnabled = !audioEnabled;
    if (audioEnabled) {
      liveAnnounce("Audio on. Press M to mute.");
      startBackgroundHum();
      tryResumeAudio();
    } else {
      liveAnnounce("Audio muted. Press M to unmute.");
      stopBackgroundHum();
    }
  }

  // Picking a part: add value to sum, animate and check results
  function pickPart(index) {
    if (state.paused || state.levelComplete || state.gameOver) return;
    const part = state.parts[index];
    if (!part || part.picked) {
      // nothing happens
      playWrong();
      return;
    }
    // Mark picked
    part.picked = true;
    playClick();

    // Animate movement toward machine (we will update currentSum immediately and animate particles)
    state.currentSum += part.value;
    createParticles(part.x, part.y - 10, 8, palette.accent);

    // Check for match or over
    if (state.currentSum === state.target) {
      // Level success
      playSuccess();
      state.levelComplete = true;
      liveAnnounce(`Great! You matched the target ${state.target}. Press Enter to continue.`);
      // small celebratory particles
      createParticles(WIDTH / 2, HEIGHT / 2 - 40, 30, "#A6F0C3");
    } else if (state.currentSum > state.target) {
      // Wrong, reduce a life and reset currentSum to 0 and un-pick some parts
      playWrong();
      state.lives--;
      liveAnnounce(`Too much! You exceeded ${state.target}. Lives left: ${state.lives}.`);
      // Create big puff
      createParticles(WIDTH / 2, HEIGHT / 2, 40, "#FFB6C1");
      if (state.lives <= 0) {
        state.gameOver = true;
        liveAnnounce("Game over. Press R to try again.");
      } else {
        // Reset: unpick all parts and currentSum back to 0
        setTimeout(() => {
          state.parts.forEach((p) => (p.picked = false));
          state.currentSum = 0;
        }, 700);
      }
    } else {
      // Still below target — continue
      liveAnnounce(`Added ${part.value}. Current sum ${state.currentSum}.`);
    }
  }

  function nextLevel() {
    if (state.level >= MAX_LEVEL) {
      liveAnnounce("You finished all levels! Well done!");
      // Victory screen: reset or let user restart
      state.gameOver = true;
      return;
    }
    state.level++;
    if (state.level > MAX_LEVEL) state.level = MAX_LEVEL;
    // Keep lives (but not exceed)
    generateLevel(state.level);
  }

  function restartGame() {
    state.level = 1;
    state.lives = LIVES;
    state.gameOver = false;
    state.levelComplete = false;
    state.currentSum = 0;
    generateLevel(1);
  }

  // Animation loop
  function tick() {
    state.ticks++;
    // Small automatic conveyor motion: shift x slightly as if moving
    for (let i = 0; i < state.parts.length; i++) {
      const p = state.parts[i];
      p.x += Math.sin((state.ticks + i * 10) / 40) * 0.2;
    }
    render();
    requestAnimationFrame(tick);
  }

  // Initialize interactions
  canvas.addEventListener("keydown", onKeyDown);
  window.addEventListener("keydown", (e) => {
    // let canvas handle keys when focused; also global for convenience
    if (document.activeElement !== canvas) {
      // resume audio on any first keypress
      tryResumeAudio();
    }
    onKeyDown(e);
  });
  canvas.addEventListener("mousedown", (e) => onMouseDown(e));
  canvas.addEventListener("touchstart", (e) => {
    tryResumeAudio();
    const touch = e.touches[0];
    if (touch) {
      // synthesize mouse down
      onMouseDown({ clientX: touch.clientX, clientY: touch.clientY });
    }
    e.preventDefault();
  }, { passive: false });

  // Initialize game and audio handling
  generateLevel(1);
  // Ensure audio tries to start on user gesture (click or keydown)
  canvas.addEventListener("pointerdown", tryResumeAudio, { once: true });
  window.addEventListener("keydown", tryResumeAudio, { once: true });

  // Start background hum only if audio allowed after user gesture
  // We'll attempt to create audio context immediately but will remain suspended until gesture.
  createAudioContext();

  // Provide initial live instruction
  liveAnnounce("Welcome to Machine Math. Use arrow keys to select parts and Enter to feed the machine. Press M to mute. Click or press any key to enable sound.");

  // Start main loop
  tick();

  // Expose for debugging (non-intrusive)
  window.__machineMathState = state;
})();
---

