{
  "generated_date": "2025-09-14",
  "generated_timestamp": "2025-09-14T00:28:08.715401",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9253,
  "game_filename": "2025-09-14.js",
  "game_size_bytes": 25894,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Educational Math Game: Machine Mash\n  // Renders a 720x480 canvas into #game-of-the-day-stage\n  // Uses Web Audio API (oscillators) for sounds, full keyboard accessibility,\n  // and canvas-only visuals. Designed for kids ages 7-9.\n\n  // Ensure the target container exists\n  const container = document.getElementById(\"game-of-the-day-stage\");\n  if (!container) {\n    console.error(\"Game container '#game-of-the-day-stage' not found.\");\n    return;\n  }\n\n  // Clear container and create canvas\n  container.innerHTML = \"\";\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 720;\n  canvas.height = 480;\n  canvas.style.width = \"720px\";\n  canvas.style.height = \"480px\";\n  canvas.setAttribute(\"role\", \"img\");\n  canvas.setAttribute(\n    \"aria-label\",\n    \"Machine Mash math game. Use left and right arrows or keys 1,2,3 to pick a machine. Press Space to catch a number. Press A to toggle audio.\"\n  );\n  canvas.tabIndex = 0; // focusable for keyboard\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    console.error(\"Canvas context not available.\");\n    return;\n  }\n\n  // Game area constants\n  const W = 720;\n  const H = 480;\n\n  // Audio setup\n  let audioEnabled = true;\n  let audioAllowedByUser = false;\n  let AudioCtx = window.AudioContext || window.webkitAudioContext || null;\n  let audioCtx = null;\n  let masterGain = null;\n  let bgOsc = null;\n  let bgFilter = null;\n\n  function initAudioOnUserGesture() {\n    if (!AudioCtx) {\n      audioEnabled = false;\n      return;\n    }\n    if (audioCtx) return;\n    try {\n      audioCtx = new AudioCtx();\n      masterGain = audioCtx.createGain();\n      masterGain.gain.value = 0.12; // overall volume\n      masterGain.connect(audioCtx.destination);\n\n      // Gentle background hum: low oscillator + filter\n      bgOsc = audioCtx.createOscillator();\n      bgOsc.type = \"sine\";\n      bgOsc.frequency.value = 110; // low hum\n      bgFilter = audioCtx.createBiquadFilter();\n      bgFilter.type = \"lowpass\";\n      bgFilter.frequency.value = 700;\n      const bgGain = audioCtx.createGain();\n      bgGain.gain.value = 0.06;\n      bgOsc.connect(bgFilter);\n      bgFilter.connect(bgGain);\n      bgGain.connect(masterGain);\n      bgOsc.start(0);\n      audioAllowedByUser = true;\n    } catch (e) {\n      console.warn(\"AudioContext failed to initialize:\", e);\n      audioEnabled = false;\n      audioCtx = null;\n    }\n  }\n\n  function toggleAudio() {\n    if (!AudioCtx) {\n      audioEnabled = false;\n      return;\n    }\n    if (!audioCtx) {\n      initAudioOnUserGesture();\n      return;\n    }\n    if (audioCtx.state === \"suspended\") {\n      audioCtx.resume().catch((e) => {\n        console.warn(\"AudioContext resume failed:\", e);\n        audioEnabled = false;\n      });\n    }\n    audioEnabled = !audioEnabled;\n    if (masterGain) {\n      masterGain.gain.value = audioEnabled ? 0.12 : 0.0;\n    }\n  }\n\n  function safeCreateOscillator() {\n    if (!audioCtx) return null;\n    try {\n      const osc = audioCtx.createOscillator();\n      return osc;\n    } catch (e) {\n      console.warn(\"Oscillator creation failed:\", e);\n      return null;\n    }\n  }\n\n  function playClickTone() {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const o = safeCreateOscillator();\n      const g = audioCtx.createGain();\n      if (!o) return;\n      o.type = \"triangle\";\n      o.frequency.value = 880;\n      g.gain.value = 0.001;\n      o.connect(g);\n      g.connect(masterGain);\n      g.gain.setValueAtTime(0.001, now);\n      g.gain.linearRampToValueAtTime(0.08, now + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.001, now + 0.18);\n      o.start(now);\n      o.stop(now + 0.2);\n    } catch (e) {\n      console.warn(\"playClickTone error:\", e);\n    }\n  }\n\n  function playCorrectSequence() {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      const notes = [880, 990, 1176]; // triad ascending\n      let t = audioCtx.currentTime;\n      notes.forEach((f, i) => {\n        const o = safeCreateOscillator();\n        if (!o) return;\n        const g = audioCtx.createGain();\n        o.type = i === notes.length - 1 ? \"sine\" : \"triangle\";\n        o.frequency.value = f;\n        o.connect(g);\n        g.connect(masterGain);\n        g.gain.setValueAtTime(0.0001, t);\n        g.gain.exponentialRampToValueAtTime(0.08, t + 0.02);\n        g.gain.exponentialRampToValueAtTime(0.0001, t + 0.12);\n        o.start(t);\n        o.stop(t + 0.12);\n        t += 0.08;\n      });\n    } catch (e) {\n      console.warn(\"playCorrectSequence error:\", e);\n    }\n  }\n\n  function playWrongBuzz() {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      const o = safeCreateOscillator();\n      if (!o) return;\n      const g = audioCtx.createGain();\n      const f = audioCtx.createBiquadFilter();\n      f.type = \"lowpass\";\n      f.frequency.value = 1200;\n      o.type = \"sawtooth\";\n      o.frequency.value = 220;\n      o.connect(f);\n      f.connect(g);\n      g.connect(masterGain);\n      const now = audioCtx.currentTime;\n      g.gain.setValueAtTime(0.001, now);\n      g.gain.linearRampToValueAtTime(0.09, now + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.001, now + 0.35);\n      o.start(now);\n      o.stop(now + 0.35);\n    } catch (e) {\n      console.warn(\"playWrongBuzz error:\", e);\n    }\n  }\n\n  // Game state\n  let lastTime = performance.now();\n  let spawnTimer = 0;\n  let spawnInterval = 1400; // ms between numbers\n  let balls = [];\n  let selectorIndex = 1; // between 0 and 2 (three machines)\n  let catching = false;\n  let catchCooldown = 0;\n  let level = 0;\n  let paused = false;\n  let showHints = true;\n  let speakerVisible = true;\n\n  const levels = [\n    // Each level: machines ops, target, goal correctness, allowed misses\n    {\n      label: \"Starter Sparks\",\n      machines: [\n        { op: (n) => n + 1, label: \"+1\", color: \"#FFD166\" },\n        { op: (n) => n + 2, label: \"+2\", color: \"#06D6A0\" },\n        { op: (n) => n + 3, label: \"+3\", color: \"#4CC9F0\" },\n      ],\n      target: 7,\n      goal: 4,\n      allowedMisses: 5,\n      spawnInterval: 1500,\n    },\n    {\n      label: \"Gear Shift\",\n      machines: [\n        { op: (n) => n - 1, label: \"-1\", color: \"#FF6B6B\" },\n        { op: (n) => n + 2, label: \"+2\", color: \"#FFD166\" },\n        { op: (n) => n * 2, label: \"\u00d72\", color: \"#06D6A0\" },\n      ],\n      target: 8,\n      goal: 5,\n      allowedMisses: 5,\n      spawnInterval: 1300,\n    },\n    {\n      label: \"Turbo Mix\",\n      machines: [\n        { op: (n) => Math.max(1, n - 2), label: \"-2\", color: \"#FFB4A2\" },\n        { op: (n) => n * 2, label: \"\u00d72\", color: \"#CBF3F0\" },\n        { op: (n) => n + 4, label: \"+4\", color: \"#90BE6D\" },\n      ],\n      target: 10,\n      goal: 6,\n      allowedMisses: 6,\n      spawnInterval: 1200,\n    },\n  ];\n\n  // Score and counters\n  let correctCount = 0;\n  let missedCount = 0;\n  let totalCaught = 0;\n\n  // Conveyor / machine layout\n  const beltY = 160;\n  const chuteY = 220;\n  const machineY = 260;\n  const machinesX = [120, 360, 600];\n  const machineWidth = 160;\n  const machineHeight = 140;\n\n  // For friendly visual animations\n  let wiggle = 0;\n\n  // Utility functions\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  function resetLevel(lvlIndex = 0) {\n    level = Math.max(0, Math.min(lvlIndex, levels.length - 1));\n    balls = [];\n    selectorIndex = 1;\n    catching = false;\n    catchCooldown = 0;\n    correctCount = 0;\n    missedCount = 0;\n    totalCaught = 0;\n    spawnTimer = 0;\n    spawnInterval = levels[level].spawnInterval || 1400;\n    paused = false;\n  }\n\n  resetLevel(0);\n\n  // Ball object: moves along belt from left to right then drops into chute\n  function spawnBall() {\n    // spawn at left outside area\n    const value = randInt(1, 9);\n    const b = {\n      x: -30,\n      y: beltY,\n      vx: 60 + Math.random() * 40, // pixels per second\n      value: value,\n      state: \"rolling\", // rolling -> dropping -> processed or fallen\n      targetMachine: null,\n      dropY: beltY,\n      caught: false,\n      processed: false,\n      id: Math.random().toString(36).substr(2, 9),\n    };\n    balls.push(b);\n  }\n\n  // Process a ball into a machine index\n  function processBall(ball, machineIndex) {\n    const machine = levels[level].machines[machineIndex];\n    let result;\n    try {\n      result = machine.op(ball.value);\n    } catch (e) {\n      console.warn(\"Machine operation failed:\", e);\n      result = NaN;\n    }\n    totalCaught++;\n    ball.processed = true;\n    // Check correctness against target\n    const target = levels[level].target;\n    if (result === target) {\n      correctCount++;\n      playCorrectSequence();\n      flashFeedback(\"correct\", machinesX[machineIndex], machineY);\n    } else {\n      missedCount++;\n      playWrongBuzz();\n      flashFeedback(\"wrong\", machinesX[machineIndex], machineY);\n    }\n    // After processing, animate ball to little result bubble then remove\n    setTimeout(() => {\n      // safe removal later by marking processed\n    }, 400);\n  }\n\n  // Visual feedback bubbles\n  let feedbacks = [];\n  function flashFeedback(kind, x, y) {\n    feedbacks.push({\n      kind,\n      x,\n      y,\n      t: 0,\n    });\n  }\n\n  // Input handling\n  const keyState = {};\n  function onKeyDown(e) {\n    // ensure audio init on first gesture\n    initAudioOnUserGesture();\n\n    if (e.key === \"ArrowLeft\") {\n      keyState.left = true;\n      e.preventDefault();\n    } else if (e.key === \"ArrowRight\") {\n      keyState.right = true;\n      e.preventDefault();\n    } else if (e.key === \" \") {\n      keyState.space = true;\n      e.preventDefault();\n    } else if (e.key === \"1\") {\n      selectorIndex = 0;\n      playClickTone();\n    } else if (e.key === \"2\") {\n      selectorIndex = 1;\n      playClickTone();\n    } else if (e.key === \"3\") {\n      selectorIndex = 2;\n      playClickTone();\n    } else if (e.key.toLowerCase() === \"a\") {\n      toggleAudio();\n      playClickTone();\n    } else if (e.key.toLowerCase() === \"h\") {\n      showHints = !showHints;\n    } else if (e.key.toLowerCase() === \"p\") {\n      paused = !paused;\n    } else if (e.key === \"Enter\" && (correctCount >= levels[level].goal || missedCount >= levels[level].allowedMisses)) {\n      // Advance or restart\n      if (correctCount >= levels[level].goal) {\n        resetLevel(Math.min(level + 1, levels.length - 1));\n      } else {\n        resetLevel(level);\n      }\n    }\n  }\n\n  function onKeyUp(e) {\n    if (e.key === \"ArrowLeft\") {\n      keyState.left = false;\n    } else if (e.key === \"ArrowRight\") {\n      keyState.right = false;\n    } else if (e.key === \" \") {\n      keyState.space = false;\n    }\n  }\n\n  // Mouse support for selecting machines & toggling audio\n  function onMouseDown(e) {\n    initAudioOnUserGesture();\n    const rect = canvas.getBoundingClientRect();\n    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);\n    const my = (e.clientY - rect.top) * (canvas.height / rect.height);\n    // Check if clicked on machines\n    for (let i = 0; i < machinesX.length; i++) {\n      const mx0 = machinesX[i] - machineWidth / 2;\n      const mx1 = machinesX[i] + machineWidth / 2;\n      const my0 = machineY;\n      const my1 = machineY + machineHeight;\n      if (mx >= mx0 && mx <= mx1 && my >= my0 && my <= my1) {\n        selectorIndex = i;\n        playClickTone();\n        return;\n      }\n    }\n    // Check speaker icon area top-right\n    if (mx > W - 58 && mx < W - 20 && my > 12 && my < 44) {\n      toggleAudio();\n      playClickTone();\n    }\n  }\n\n  // Catch logic: player presses space to attempt to catch a ball that is dropping at the moment\n  function tryCatch() {\n    if (catchCooldown > 0) return;\n    catchCooldown = 180; // ms cooldown\n    playClickTone();\n    // Find a ball that is dropping into the selected machine region OR is just at the drop point\n    for (let b of balls) {\n      if (b.state === \"dropping\" && b.targetMachine === selectorIndex && !b.caught && !b.processed) {\n        b.caught = true;\n        b.state = \"caught\";\n        processBall(b, selectorIndex);\n        return;\n      }\n    }\n    // If nothing caught, small penalty\n    missedCount++;\n    playWrongBuzz();\n  }\n\n  // Focus management for accessibility\n  canvas.addEventListener(\"focus\", () => {\n    // show focus outline by drawing; nothing else needed\n  });\n\n  // Register events\n  window.addEventListener(\"keydown\", onKeyDown);\n  window.addEventListener(\"keyup\", onKeyUp);\n  canvas.addEventListener(\"mousedown\", onMouseDown);\n  // For mobile/touch: convert taps to clicks\n  canvas.addEventListener(\"touchstart\", function (e) {\n    e.preventDefault();\n    const touch = e.touches[0];\n    onMouseDown({ clientX: touch.clientX, clientY: touch.clientY });\n  }, { passive: false });\n\n  // Main update and draw loop\n  function update(dt) {\n    if (paused) return;\n\n    wiggle += dt * 0.002;\n\n    // Spawn logic\n    spawnTimer += dt;\n    spawnInterval = levels[level].spawnInterval || spawnInterval;\n    if (spawnTimer > spawnInterval) {\n      spawnTimer = spawnTimer % spawnInterval;\n      spawnBall();\n    }\n\n    // Update balls\n    for (let b of balls) {\n      if (b.state === \"rolling\") {\n        b.x += (b.vx * dt) / 1000;\n        // If approaching machine chute horizontally, start dropping\n        for (let i = 0; i < machinesX.length; i++) {\n          const mx = machinesX[i];\n          if (b.x > mx - 22 && b.x < mx + 22) {\n            b.state = \"dropping\";\n            b.targetMachine = i;\n            b.dropY = b.y;\n            break;\n          }\n        }\n        if (b.x > W + 30) {\n          // missed entirely (fell off conveyor)\n          b.state = \"gone\";\n          missedCount++;\n        }\n      } else if (b.state === \"dropping\") {\n        // vertical drop with easing\n        b.y += (dt / 1000) * 160;\n        if (b.y >= chuteY + 28) {\n          // ball reached the machine entrance\n          // If not caught, it falls into bin (processed by machine but player didn't catch)\n          if (!b.caught && !b.processed) {\n            // automatic processing as a miss (player didn't catch)\n            b.processed = true;\n            missedCount++;\n            playWrongBuzz();\n            flashFeedback(\"wrong\", machinesX[b.targetMachine], machineY);\n          }\n          b.state = \"landed\";\n        }\n      } else if (b.state === \"caught\" || b.state === \"landed\" || b.state === \"processed\") {\n        // gently float away before removal\n        b.y += (dt / 1000) * 20;\n      }\n    }\n\n    // Cull old balls\n    balls = balls.filter((b) => !(b.x > W + 200 || b.y > H + 200 || b.state === \"gone\" || (b.processed && b.y > H + 80)));\n\n    // Handle catching input\n    if (keyState.space) {\n      tryCatch();\n      // make a small delay so key holding doesn't spam\n      keyState.space = false;\n    }\n\n    // keyboard left/right control selector\n    if (keyState.left) {\n      selectorIndex = Math.max(0, selectorIndex - 1);\n      keyState.left = false;\n    } else if (keyState.right) {\n      selectorIndex = Math.min(2, selectorIndex + 1);\n      keyState.right = false;\n    }\n\n    // cooldown timer\n    catchCooldown = Math.max(0, catchCooldown - dt);\n\n    // Update feedback animations\n    for (let f of feedbacks) {\n      f.t += dt;\n    }\n    feedbacks = feedbacks.filter((f) => f.t < 900);\n  }\n\n  function drawRoundedRect(c, x, y, w, h, r) {\n    c.beginPath();\n    c.moveTo(x + r, y);\n    c.arcTo(x + w, y, x + w, y + h, r);\n    c.arcTo(x + w, y + h, x, y + h, r);\n    c.arcTo(x, y + h, x, y, r);\n    c.arcTo(x, y, x + w, y, r);\n    c.closePath();\n  }\n\n  function draw() {\n    // background soft gradient\n    const g = ctx.createLinearGradient(0, 0, 0, H);\n    g.addColorStop(0, \"#f7fbff\");\n    g.addColorStop(1, \"#eaf6ff\");\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, W, H);\n\n    // gentle wacky mechanical background shapes (gears as circles, purely drawn)\n    for (let i = 0; i < 8; i++) {\n      const gx = (i / 7) * W;\n      const gy = 40 + (i % 2) * 40;\n      const radius = 18 + (i % 3) * 4;\n      ctx.save();\n      ctx.globalAlpha = 0.06;\n      ctx.translate(gx + (Math.sin(wiggle + i) * 6), gy + (Math.cos(wiggle + i) * 6));\n      // draw simple gear-ish ring\n      ctx.beginPath();\n      for (let j = 0; j < 10; j++) {\n        const a = (j / 10) * Math.PI * 2;\n        const r = radius + (j % 2 === 0 ? 6 : -2);\n        const x = Math.cos(a) * r;\n        const y = Math.sin(a) * r;\n        if (j === 0) ctx.moveTo(x, y);\n        else ctx.lineTo(x, y);\n      }\n      ctx.closePath();\n      ctx.fillStyle = \"#44566f\";\n      ctx.fill();\n      ctx.restore();\n    }\n\n    // Header: Level name and target\n    ctx.fillStyle = \"#393E46\";\n    ctx.font = \"700 20px 'Segoe UI', Roboto, Arial\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(\"Level: \" + levels[level].label, 12, 28);\n\n    // Target display\n    ctx.textAlign = \"center\";\n    ctx.font = \"800 34px 'Segoe UI', Roboto, Arial\";\n    ctx.fillStyle = \"#222831\";\n    ctx.fillText(\"Target: \" + levels[level].target, W / 2, 44);\n\n    // Speaker icon and audio status (top-right)\n    ctx.save();\n    ctx.translate(W - 60, 12);\n    // Box\n    ctx.fillStyle = audioEnabled ? \"#07c160\" : \"#d9534f\";\n    drawRoundedRect(ctx, 0, 0, 44, 32, 6);\n    ctx.fill();\n    ctx.fillStyle = \"#fff\";\n    ctx.font = \"600 14px 'Segoe UI'\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(audioEnabled ? \"Audio ON\" : \"Audio OFF\", 22, 20);\n    ctx.restore();\n\n    // Conveyor belt drawing\n    ctx.fillStyle = \"#c4d7eb\";\n    drawRoundedRect(ctx, 20, beltY - 20, W - 40, 60, 12);\n    ctx.fill();\n\n    // Decorative belt lines\n    ctx.strokeStyle = \"rgba(0,0,0,0.06)\";\n    ctx.lineWidth = 2;\n    for (let i = 0; i < 10; i++) {\n      ctx.beginPath();\n      ctx.moveTo(24 + i * 72 + (wiggle * 2) % 72, beltY + 10);\n      ctx.lineTo(24 + i * 72 + (wiggle * 2) % 72, beltY + 30);\n      ctx.stroke();\n    }\n\n    // Draw machines\n    for (let i = 0; i < machinesX.length; i++) {\n      const mx = machinesX[i];\n      // base body\n      ctx.save();\n      ctx.translate(mx, machineY);\n      const m = levels[level].machines[i];\n      // body\n      ctx.fillStyle = m.color;\n      drawRoundedRect(ctx, -machineWidth / 2, 0, machineWidth, machineHeight, 18);\n      ctx.fill();\n      // face / window\n      ctx.fillStyle = \"rgba(255,255,255,0.85)\";\n      drawRoundedRect(ctx, -machineWidth / 2 + 14, 12, machineWidth - 28, 64, 10);\n      ctx.fill();\n      // operation label\n      ctx.fillStyle = \"#222\";\n      ctx.font = \"700 20px 'Segoe UI'\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(m.label, 0, 42);\n      // chutes\n      ctx.fillStyle = \"#2b2d42\";\n      drawRoundedRect(ctx, -36, 78, 72, 28, 8);\n      ctx.fill();\n      // little lever\n      ctx.fillStyle = \"#2f4858\";\n      ctx.fillRect(-12, 106, 24, 8);\n      // machine legs\n      ctx.fillStyle = \"#2f4858\";\n      ctx.fillRect(-machineWidth / 2 + 16, machineHeight - 16, 28, 12);\n      ctx.fillRect(machineWidth / 2 - 44, machineHeight - 16, 28, 12);\n      // highlight selected machine\n      if (selectorIndex === i) {\n        ctx.strokeStyle = \"#ffda79\";\n        ctx.lineWidth = 4;\n        drawRoundedRect(ctx, -machineWidth / 2 + 6, 6, machineWidth - 12, machineHeight - 12, 18);\n        ctx.stroke();\n      }\n      // show goal check progress on machine\n      ctx.restore();\n    }\n\n    // Draw selector pointer above machines\n    const sx = machinesX[selectorIndex];\n    ctx.beginPath();\n    ctx.moveTo(sx, beltY - 44);\n    ctx.lineTo(sx - 14, beltY - 20);\n    ctx.lineTo(sx + 14, beltY - 20);\n    ctx.closePath();\n    ctx.fillStyle = \"#ff7f50\";\n    ctx.fill();\n    // pointer label\n    ctx.fillStyle = \"#fff\";\n    ctx.font = \"700 12px 'Segoe UI'\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"YOU\", sx, beltY - 26);\n\n    // Draw balls\n    for (let b of balls) {\n      ctx.save();\n      ctx.translate(b.x, b.y);\n      // shadow\n      ctx.beginPath();\n      ctx.ellipse(0, 18, 20, 8, 0, 0, Math.PI * 2);\n      ctx.fillStyle = \"rgba(0,0,0,0.08)\";\n      ctx.fill();\n      // body\n      ctx.beginPath();\n      ctx.arc(0, 0, 18, 0, Math.PI * 2);\n      ctx.fillStyle = \"#fff\";\n      ctx.fill();\n      ctx.lineWidth = 2;\n      ctx.strokeStyle = \"#b8c6d8\";\n      ctx.stroke();\n      // number text\n      ctx.fillStyle = \"#223\";\n      ctx.font = \"700 16px 'Segoe UI'\";\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillText(b.value.toString(), 0, 0);\n      ctx.restore();\n    }\n\n    // Draw floating small counters and UI\n    ctx.fillStyle = \"#222\";\n    ctx.font = \"700 18px 'Segoe UI'\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(\"Correct: \" + correctCount + \" / \" + levels[level].goal, 12, H - 56);\n    ctx.fillText(\"Misses: \" + missedCount + \" / \" + levels[level].allowedMisses, 12, H - 28);\n\n    // Draw friendly hints area\n    if (showHints) {\n      ctx.save();\n      ctx.globalAlpha = 0.9;\n      ctx.fillStyle = \"#ffffff\";\n      drawRoundedRect(ctx, W - 260, H - 110, 248, 98, 10);\n      ctx.fill();\n      ctx.fillStyle = \"#222\";\n      ctx.font = \"600 12px 'Segoe UI'\";\n      ctx.textAlign = \"left\";\n      ctx.fillText(\"How to play:\", W - 246, H - 88);\n      ctx.font = \"500 12px 'Segoe UI'\";\n      ctx.fillText(\"1) Use \u2190 \u2192 or keys 1/2/3 to pick a machine\", W - 246, H - 68);\n      ctx.fillText(\"2) Press Space when a number drops into the machine\", W - 246, H - 52);\n      ctx.fillText(\"3) Aim to get numbers that make the target\", W - 246, H - 36);\n      ctx.fillText(\"A: Toggle audio  \u2022  P: Pause  \u2022  H: Toggle hints\", W - 246, H - 18);\n      ctx.restore();\n    } else {\n      ctx.save();\n      ctx.fillStyle = \"rgba(255,255,255,0.5)\";\n      drawRoundedRect(ctx, W - 180, H - 76, 160, 56, 8);\n      ctx.fill();\n      ctx.fillStyle = \"#111\";\n      ctx.font = \"500 12px 'Segoe UI'\";\n      ctx.fillText(\"Press H for help\", W - 100, H - 40);\n      ctx.restore();\n    }\n\n    // Draw feedback animations\n    for (let f of feedbacks) {\n      const p = f.t / 900;\n      ctx.globalAlpha = 1 - p;\n      if (f.kind === \"correct\") {\n        ctx.fillStyle = \"#07c160\";\n        ctx.beginPath();\n        ctx.arc(f.x, f.y - p * 40, 22 * (1 - p * 0.6), 0, Math.PI * 2);\n        ctx.fill();\n        ctx.fillStyle = \"#fff\";\n        ctx.font = \"700 16px 'Segoe UI'\";\n        ctx.textAlign = \"center\";\n        ctx.fillText(\"+1\", f.x, f.y - p * 40 + 4);\n      } else {\n        ctx.fillStyle = \"#ff6b6b\";\n        ctx.beginPath();\n        ctx.arc(f.x, f.y - p * 40, 22 * (1 - p * 0.6), 0, Math.PI * 2);\n        ctx.fill();\n        ctx.fillStyle = \"#fff\";\n        ctx.font = \"700 16px 'Segoe UI'\";\n        ctx.textAlign = \"center\";\n        ctx.fillText(\"-1\", f.x, f.y - p * 40 + 4);\n      }\n      ctx.globalAlpha = 1;\n    }\n\n    // Draw end-level panel if won or lost\n    if (correctCount >= levels[level].goal || missedCount >= levels[level].allowedMisses) {\n      ctx.save();\n      ctx.fillStyle = \"rgba(10,10,20,0.6)\";\n      ctx.fillRect(0, 0, W, H);\n      ctx.fillStyle = \"#fff\";\n      ctx.textAlign = \"center\";\n      ctx.font = \"800 36px 'Segoe UI'\";\n      if (correctCount >= levels[level].goal) {\n        ctx.fillText(\"Level Complete!\", W / 2, H / 2 - 12);\n        ctx.font = \"600 20px 'Segoe UI'\";\n        ctx.fillText(\"Press Enter to go to the next level\", W / 2, H / 2 + 24);\n      } else {\n        ctx.fillText(\"Out of Chances\", W / 2, H / 2 - 12);\n        ctx.font = \"600 20px 'Segoe UI'\";\n        ctx.fillText(\"Press Enter to try again\", W / 2, H / 2 + 24);\n      }\n      ctx.restore();\n    }\n\n    // Footer: accessibility instruction\n    ctx.fillStyle = \"#2b2d42\";\n    ctx.font = \"500 12px 'Segoe UI'\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(\"Controls: \u2190 \u2192 or 1/2/3 to select, Space to catch, A audio, H help\", 12, H - 8);\n  }\n\n  // Game loop\n  function loop(now) {\n    const dt = now - lastTime;\n    lastTime = now;\n    update(dt);\n    draw();\n    requestAnimationFrame(loop);\n  }\n  requestAnimationFrame(loop);\n\n  // Periodic cleanup on unload\n  window.addEventListener(\"beforeunload\", () => {\n    try {\n      if (bgOsc) bgOsc.stop();\n      if (audioCtx && typeof audioCtx.close === \"function\") audioCtx.close();\n    } catch (e) {\n      // ignore\n    }\n  });\n\n  // Provide an initial friendly prompt and try to create AudioContext on first click anywhere\n  const startPrompt = {\n    shown: false,\n  };\n\n  // Draw a subtle overlay for first interaction\n  function drawStartOverlay() {\n    ctx.save();\n    ctx.fillStyle = \"rgba(255,255,255,0.86)\";\n    drawRoundedRect(ctx, W / 2 - 200, H / 2 - 84, 400, 168, 14);\n    ctx.fill();\n    ctx.fillStyle = \"#223\";\n    ctx.font = \"700 20px 'Segoe UI'\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"Welcome to Machine Mash!\", W / 2, H / 2 - 36);\n    ctx.font = \"500 14px 'Segoe UI'\";\n    ctx.fillText(\"Move machines with \u2190 \u2192, press Space to catch a number.\", W / 2, H / 2 - 8);\n    ctx.fillText(\"Press A to toggle audio. Click or press any key to begin.\", W / 2, H / 2 + 16);\n    ctx.restore();\n  }\n\n  // On first user interaction, init audio if possible and remove overlay\n  function firstUserGesture() {\n    if (!startPrompt.shown) {\n      startPrompt.shown = true;\n      initAudioOnUserGesture();\n    }\n  }\n\n  // Hook first gestures\n  function onFirstGestureEvent() {\n    firstUserGesture();\n    canvas.removeEventListener(\"click\", onFirstGestureEvent);\n    window.removeEventListener(\"keydown\", onFirstGestureEvent);\n  }\n  canvas.addEventListener(\"click\", onFirstGestureEvent);\n  window.addEventListener(\"keydown\", onFirstGestureEvent);\n\n  // Keep drawing overlay until touched\n  (function overlayLoop() {\n    if (!startPrompt.shown) {\n      draw();\n      drawStartOverlay();\n      requestAnimationFrame(overlayLoop);\n    }\n  })();\n\n  // Expose restart function on the element for testing or manual control (accessible)\n  container.restartGame = function () {\n    resetLevel(0);\n  };\n\n  // Error handling examples: warn when audio cannot be used\n  if (!AudioCtx) {\n    console.warn(\"Web Audio API not supported in this browser. Sounds disabled.\");\n    audioEnabled = false;\n  }\n})();\n---\n",
  "improve_response_tokens": 20095,
  "formatted_code": true,
  "formatting_response_tokens": 22935,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}