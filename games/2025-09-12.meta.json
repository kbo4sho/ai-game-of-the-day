{
  "generated_date": "2025-09-12",
  "generated_timestamp": "2025-09-12T00:26:25.458185",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 11377,
  "game_filename": "2025-09-12.js",
  "game_size_bytes": 35831,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Machine Math: Canvas game for ages 7-9\n  // Renders inside element with ID 'game-of-the-day-stage'\n  // All graphics drawn on canvas. Sounds produced with Web Audio API oscillators.\n  // Accessible: keyboard controls, ARIA live text, instructions on canvas, visual audio indicator.\n  // Author: AI educational game designer\n\n  // CONFIG\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const STAGE_ID = \"game-of-the-day-stage\";\n  const MAX_LEVEL = 5;\n  const INITIAL_LIVES = 3;\n\n  // UTILITIES\n  function clamp(v, a, b) {\n    return Math.max(a, Math.min(b, v));\n  }\n\n  function randInt(a, b) {\n    return Math.floor(Math.random() * (b - a + 1)) + a;\n  }\n\n  function choose(arr) {\n    return arr[Math.floor(Math.random() * arr.length)];\n  }\n\n  // Ensure stage exists\n  const stage = document.getElementById(STAGE_ID);\n  if (!stage) {\n    console.error(\"Game mount element not found: #\" + STAGE_ID);\n    return;\n  }\n\n  // Clear stage\n  stage.innerHTML = \"\";\n  stage.style.position = \"relative\";\n\n  // Create ARIA live region (for screen readers)\n  const ariaStatus = document.createElement(\"div\");\n  ariaStatus.setAttribute(\"role\", \"status\");\n  ariaStatus.setAttribute(\"aria-live\", \"polite\");\n  ariaStatus.style.position = \"absolute\";\n  ariaStatus.style.left = \"-9999px\";\n  ariaStatus.style.width = \"1px\";\n  ariaStatus.style.height = \"1px\";\n  ariaStatus.style.overflow = \"hidden\";\n  stage.appendChild(ariaStatus);\n\n  // Create canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute(\"tabindex\", \"0\"); // focusable\n  canvas.style.outline = \"none\";\n  stage.appendChild(canvas);\n\n  const ctx = canvas.getContext(\"2d\");\n\n  // Setup audio manager\n  class AudioManager {\n    constructor() {\n      this.enabled = false;\n      this.ctx = null;\n      this.gain = null;\n      this.bgOsc = null;\n      this.muted = false;\n      this.available = false;\n      this.init();\n    }\n\n    async init() {\n      try {\n        const AudioCtx = window.AudioContext || window.webkitAudioContext;\n        if (!AudioCtx) throw new Error(\"Web Audio API not supported\");\n        this.ctx = new AudioCtx();\n        // create master gain\n        this.gain = this.ctx.createGain();\n        this.gain.gain.value = 0.12; // gentle\n        this.gain.connect(this.ctx.destination);\n        // create gentle background hum\n        this.bgOsc = this.ctx.createOscillator();\n        this.bgOsc.type = \"sine\";\n        this.bgOsc.frequency.value = 110; // low hum\n        // create subtle filter for warmth\n        const filter = this.ctx.createBiquadFilter();\n        filter.type = \"lowpass\";\n        filter.frequency.value = 800;\n        this.bgOsc.connect(filter);\n        filter.connect(this.gain);\n        this.bgOsc.start();\n        this.available = true;\n        this.enabled = true;\n      } catch (e) {\n        console.warn(\"Audio initialization failed:\", e);\n        this.available = false;\n        this.enabled = false;\n      }\n    }\n\n    async resumeIfNeeded() {\n      if (!this.ctx) return;\n      try {\n        if (this.ctx.state === \"suspended\") {\n          await this.ctx.resume();\n        }\n      } catch (e) {\n        console.warn(\"Audio resume failed:\", e);\n      }\n    }\n\n    setMuted(m) {\n      this.muted = !!m;\n      if (this.gain) {\n        this.gain.gain.value = this.muted ? 0 : 0.12;\n      }\n    }\n\n    // correct chime: rising triad\n    playCorrect() {\n      if (!this.available || this.muted) return;\n      try {\n        const now = this.ctx.currentTime;\n        const notes = [440, 550, 660];\n        notes.forEach((freq, i) => {\n          const o = this.ctx.createOscillator();\n          const g = this.ctx.createGain();\n          o.type = \"sine\";\n          o.frequency.value = freq;\n          g.gain.value = 0;\n          o.connect(g);\n          g.connect(this.gain);\n          g.gain.cancelScheduledValues(now);\n          g.gain.setValueAtTime(0, now);\n          g.gain.linearRampToValueAtTime(0.12, now + 0.02);\n          g.gain.linearRampToValueAtTime(0.0001, now + 0.22 + i * 0.05);\n          o.start(now + i * 0.05);\n          o.stop(now + 0.25 + i * 0.05);\n        });\n      } catch (e) {\n        console.warn(\"playCorrect error:\", e);\n      }\n    }\n\n    // incorrect buzzer\n    playIncorrect() {\n      if (!this.available || this.muted) return;\n      try {\n        const now = this.ctx.currentTime;\n        const o = this.ctx.createOscillator();\n        const g = this.ctx.createGain();\n        const filter = this.ctx.createBiquadFilter();\n        o.type = \"square\";\n        o.frequency.value = 220;\n        filter.type = \"lowpass\";\n        filter.frequency.value = 800;\n        g.gain.value = 0.0001;\n        o.connect(filter);\n        filter.connect(g);\n        g.connect(this.gain);\n        g.gain.setValueAtTime(0.0001, now);\n        g.gain.linearRampToValueAtTime(0.16, now + 0.02);\n        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.32);\n        o.start(now);\n        o.stop(now + 0.34);\n      } catch (e) {\n        console.warn(\"playIncorrect error:\", e);\n      }\n    }\n\n    // single click sound\n    playClick() {\n      if (!this.available || this.muted) return;\n      try {\n        const now = this.ctx.currentTime;\n        const o = this.ctx.createOscillator();\n        const g = this.ctx.createGain();\n        o.type = \"triangle\";\n        o.frequency.value = 660;\n        g.gain.value = 0.0001;\n        o.connect(g);\n        g.connect(this.gain);\n        g.gain.setValueAtTime(0.0001, now);\n        g.gain.linearRampToValueAtTime(0.08, now + 0.01);\n        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);\n        o.start(now);\n        o.stop(now + 0.14);\n      } catch (e) {\n        console.warn(\"playClick error:\", e);\n      }\n    }\n\n    dispose() {\n      try {\n        if (this.bgOsc) {\n          this.bgOsc.stop();\n        }\n        if (this.ctx && this.ctx.close) {\n          this.ctx.close();\n        }\n      } catch (e) {\n        // ignore\n      }\n    }\n  }\n\n  const audio = new AudioManager();\n\n  // GAME STATE\n  let game = {\n    level: 1,\n    lives: INITIAL_LIVES,\n    score: 0,\n    target: 0,\n    slots: 2,\n    cogValues: [],\n    selectedCogIndex: null,\n    placed: [], // values or null per slot\n    draggingIndex: null,\n    statusMessage: \"Welcome! Click or press Enter to begin.\",\n    hintUsed: false,\n    levelComplete: false,\n    finished: false,\n    audioEnabled: audio.available,\n  };\n\n  // Accessibility helper\n  function announce(msg) {\n    try {\n      ariaStatus.textContent = msg;\n    } catch (e) {\n      // ignore\n    }\n  }\n\n  // Generate solvable puzzle for a level\n  function generateLevel(level) {\n    const slots = clamp(2 + Math.floor((level - 1) / 2), 2, 3); // level 1-2:2, 3-4:3 maybe\n    // Set target range based on level\n    const minTarget = 5 + (level - 1) * 2;\n    const maxTarget = 12 + (level - 1) * 4;\n    // We'll choose a combination of 'slots' numbers to form target\n    const chosen = [];\n    for (let i = 0; i < slots; i++) {\n      // pick components to create interesting combos\n      chosen.push(randInt(1, Math.max(8, Math.floor(maxTarget / (slots + 1)))));\n    }\n    // Adjust to make target reachable\n    let target = chosen.reduce((a, b) => a + b, 0);\n    // Randomly nudge target into the desired range by adding another term if needed\n    if (target < minTarget) {\n      target += randInt(minTarget - target, Math.max(1, minTarget - target + 3));\n    }\n    if (target > maxTarget) {\n      // reduce some elements\n      while (target > maxTarget && chosen.length && Math.random() < 0.8) {\n        const i = randInt(0, chosen.length - 1);\n        const reduce = randInt(1, Math.floor(chosen[i] / 2) + 1);\n        chosen[i] = Math.max(1, chosen[i] - reduce);\n        target = chosen.reduce((a, b) => a + b, 0);\n      }\n      // if still big, set target to something smaller by trimming last\n      if (target > maxTarget) {\n        target = Math.min(maxTarget, Math.max(minTarget, target));\n      }\n    }\n    // Now create distractor cogs and final cog list\n    const totalCogs = 6;\n    const cogs = [];\n    // Place the chosen numbers among the cogs\n    const chosenCopy = chosen.slice();\n    while (chosenCopy.length < Math.min(totalCogs, chosen.length + 2)) {\n      // sometimes add an extra useful cog\n      chosenCopy.push(randInt(1, 9));\n    }\n    // Fill with left over distractors\n    while (cogs.length < totalCogs) {\n      if (chosenCopy.length > 0) {\n        cogs.push(chosenCopy.pop());\n      } else {\n        // produce distractor number but avoid exactly making new valid combos accidentally\n        cogs.push(randInt(1, Math.max(10, Math.floor(maxTarget / 2))));\n      }\n    }\n    // Shuffle\n    for (let i = cogs.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [cogs[i], cogs[j]] = [cogs[j], cogs[i]];\n    }\n    // Ensure solvable: check if there's a combination of 'slots' from cogs that sum to target\n    function existsCombination(nums, k, targetSum) {\n      function helper(i, k, sum) {\n        if (k === 0) return sum === targetSum;\n        if (i >= nums.length) return false;\n        // choose\n        if (helper(i + 1, k - 1, sum + nums[i])) return true;\n        // skip\n        return helper(i + 1, k, sum);\n      }\n      return helper(0, k, 0);\n    }\n    // If not solvable, forcibly build a solvable set by ensuring chosen slots included\n    if (!existsCombination(cogs, slots, target)) {\n      // replace first 'slots' elements with chosen numbers that sum to target\n      const forced = [];\n      // Try to find integer partition of target into 'slots' parts using numbers between 1-12\n      if (slots === 2) {\n        const a = randInt(1, target - 1);\n        forced.push(a, target - a);\n      } else {\n        // 3 slots\n        const a = randInt(1, Math.max(1, Math.floor(target / 3)));\n        const b = randInt(1, Math.max(1, Math.floor((target - a) / 2)));\n        const c = target - a - b;\n        forced.push(a, b, c);\n      }\n      // Place forced into cogs\n      for (let i = 0; i < forced.length && i < cogs.length; i++) {\n        cogs[i] = Math.max(1, forced[i]);\n      }\n    }\n\n    return {\n      target: target,\n      slots: slots,\n      cogs: cogs,\n    };\n  }\n\n  // Initialize or reset level\n  function startLevel(lvl) {\n    const data = generateLevel(lvl);\n    game.level = lvl;\n    game.target = data.target;\n    game.slots = data.slots;\n    game.cogValues = data.cogs;\n    game.selectedCogIndex = null;\n    game.placed = new Array(game.slots).fill(null);\n    game.draggingIndex = null;\n    game.statusMessage = `Level ${lvl}: Make ${game.target} by placing ${game.slots} cog${game.slots > 1 ? \"s\" : \"\"}.`;\n    game.hintUsed = false;\n    game.levelComplete = false;\n    game.finished = false;\n    announce(game.statusMessage);\n  }\n\n  // Draw functions\n  function draw() {\n    // Clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // Background - calming wavy gradient\n    const grad = ctx.createLinearGradient(0, 0, WIDTH, HEIGHT);\n    grad.addColorStop(0, \"#E8F5F9\");\n    grad.addColorStop(1, \"#FFF7EC\");\n    ctx.fillStyle = grad;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Draw subtle mechanical pattern: floating gears (simple spirals)\n    drawFloatingGears();\n\n    // Panel for machine\n    drawMachinePanel();\n\n    // Draw cogs area\n    drawCogsArea();\n\n    // Draw HUD: level, lives, score, audio indicator\n    drawHUD();\n\n    // Draw instructions and status at bottom\n    drawFooter();\n  }\n\n  function drawFloatingGears() {\n    // Small decorative gears moving slowly\n    ctx.save();\n    const time = Date.now() / 1500;\n    for (let i = 0; i < 6; i++) {\n      const x = (i + 1) * 100;\n      const y = 60 + Math.sin(time + i) * 10;\n      drawGear(x, y, 18 + (i % 3) * 4, (time + i) * 0.8, \"#DDEFF3\", \"#C9E6F2\", 0.4);\n    }\n    ctx.restore();\n  }\n\n  function drawGear(x, y, radius, rotation, fillStyle, strokeStyle, alpha = 1) {\n    ctx.save();\n    ctx.globalAlpha = alpha;\n    ctx.translate(x, y);\n    ctx.rotate(rotation);\n    ctx.fillStyle = fillStyle;\n    ctx.strokeStyle = strokeStyle;\n    ctx.lineWidth = 1.3;\n    // gear teeth\n    const teeth = 8;\n    for (let i = 0; i < teeth; i++) {\n      const angle = (i / teeth) * Math.PI * 2;\n      const x1 = Math.cos(angle) * radius;\n      const y1 = Math.sin(angle) * radius;\n      const x2 = Math.cos(angle) * (radius + 6);\n      const y2 = Math.sin(angle) * (radius + 6);\n      ctx.beginPath();\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x2, y2);\n      ctx.stroke();\n    }\n    // center circle\n    ctx.beginPath();\n    ctx.arc(0, 0, radius - 4, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  function drawMachinePanel() {\n    // Machine centered left of center\n    const panelX = 120;\n    const panelY = 120;\n    const panelW = 420;\n    const panelH = 220;\n    // Outer machine body\n    roundRect(ctx, panelX, panelY, panelW, panelH, 18, \"#F8F2E6\");\n    ctx.strokeStyle = \"#C7A47A\";\n    ctx.lineWidth = 2;\n    ctx.stroke();\n\n    // Wacky machine face - friendly\n    // Eyes\n    ctx.fillStyle = \"#FFFFFF\";\n    ctx.beginPath();\n    ctx.ellipse(panelX + 100, panelY + 60, 22, 14, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.ellipse(panelX + 180, panelY + 60, 22, 14, 0, 0, Math.PI * 2);\n    ctx.fill();\n    // Pupils\n    ctx.fillStyle = \"#333\";\n    ctx.beginPath();\n    ctx.arc(panelX + 100, panelY + 62, 6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(panelX + 180, panelY + 62, 6, 0, Math.PI * 2);\n    ctx.fill();\n    // Smiling mouth\n    ctx.strokeStyle = \"#8B5E3C\";\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.arc(panelX + 140, panelY + 110, 36, 0.15 * Math.PI, 0.85 * Math.PI);\n    ctx.stroke();\n\n    // Target display (like screen)\n    ctx.fillStyle = \"#213547\";\n    ctx.fillRect(panelX + 250, panelY + 24, 120, 52);\n    ctx.fillStyle = \"#BEE7FF\";\n    ctx.font = \"bold 28px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(\"Target\", panelX + 310, panelY + 40);\n    ctx.font = \"bold 44px sans-serif\";\n    ctx.fillText(game.target.toString(), panelX + 310, panelY + 68);\n\n    // Slots area (where player places cogs)\n    const slotStartX = panelX + 50;\n    const slotY = panelY + 150;\n    const slotGap = 90;\n    for (let i = 0; i < game.slots; i++) {\n      const sx = slotStartX + i * slotGap;\n      // slot background\n      ctx.beginPath();\n      ctx.fillStyle = \"#F0F7FA\";\n      roundRect(ctx, sx - 28, slotY - 28, 56, 56, 12);\n      ctx.fill();\n      ctx.strokeStyle = \"#B3D6E6\";\n      ctx.lineWidth = 2;\n      ctx.stroke();\n      // If placed, draw cog value inside\n      const v = game.placed[i];\n      if (v !== null && v !== undefined) {\n        drawBigCog(sx, slotY, 22, \"#FFE9D4\", \"#FFC78B\");\n        ctx.fillStyle = \"#6A3C12\";\n        ctx.font = \"bold 20px sans-serif\";\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillText(v.toString(), sx, slotY + 2);\n      } else {\n        // empty slot icon\n        ctx.fillStyle = \"#DDEFF3\";\n        ctx.beginPath();\n        ctx.arc(sx, slotY, 10, 0, Math.PI * 2);\n        ctx.fill();\n      }\n      // highlight if selected and slot empty\n      if (game.selectedCogIndex !== null && game.draggingIndex === null) {\n        // nothing\n      }\n    }\n\n    // Machine lever / button\n    const buttonX = panelX + 340;\n    const buttonY = panelY + 150;\n    ctx.fillStyle = \"#FFCF6B\";\n    roundRect(ctx, buttonX - 28, buttonY - 18, 56, 36, 8);\n    ctx.fill();\n    ctx.strokeStyle = \"#C9952E\";\n    ctx.stroke();\n    ctx.fillStyle = \"#3B2B1C\";\n    ctx.font = \"bold 16px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(\"CHECK\", buttonX, buttonY);\n\n    // visual cue for audio enabled\n    ctx.fillStyle = game.audioEnabled ? \"#A6E3A1\" : \"#E7A6A6\";\n    ctx.beginPath();\n    ctx.arc(panelX + panelW - 20, panelY + 12, 10, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = \"#2D2D2D\";\n    ctx.font = \"10px sans-serif\";\n    ctx.textAlign = \"right\";\n    ctx.fillText(game.audioEnabled ? \"Audio On\" : \"Audio Off\", panelX + panelW - 28, panelY + 10);\n  }\n\n  function drawBigCog(x, y, radius, fillStyle, strokeStyle) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate((Date.now() / 2000) % (Math.PI * 2));\n    ctx.fillStyle = fillStyle;\n    ctx.strokeStyle = strokeStyle;\n    ctx.lineWidth = 2;\n    const teeth = 10;\n    for (let i = 0; i < teeth; i++) {\n      const angle = (i / teeth) * Math.PI * 2;\n      const x1 = Math.cos(angle) * radius;\n      const y1 = Math.sin(angle) * radius;\n      const x2 = Math.cos(angle) * (radius + 6);\n      const y2 = Math.sin(angle) * (radius + 6);\n      ctx.beginPath();\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x2, y2);\n      ctx.stroke();\n    }\n    ctx.beginPath();\n    ctx.arc(0, 0, radius - 6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  function drawCogsArea() {\n    const areaX = 40;\n    const areaY = 320;\n    const areaW = WIDTH - 80;\n    const areaH = 130;\n    // background\n    ctx.fillStyle = \"#F4FCFF\";\n    roundRect(ctx, areaX, areaY, areaW, areaH, 12);\n    ctx.fillStyle = \"#ECF8FF\";\n    ctx.strokeStyle = \"#CFEAF6\";\n    ctx.lineWidth = 2;\n    ctx.stroke();\n\n    // title\n    ctx.fillStyle = \"#2B4A5A\";\n    ctx.font = \"18px sans-serif\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(\"Cogs (Pick and place onto the machine):\", areaX + 12, areaY + 24);\n\n    // Draw cog tokens\n    const startX = areaX + 40;\n    const startY = areaY + 68;\n    const gap = 100;\n    for (let i = 0; i < game.cogValues.length; i++) {\n      const x = startX + i * gap;\n      const y = startY;\n      const v = game.cogValues[i];\n      const isSelected = game.selectedCogIndex === i || game.draggingIndex === i;\n      // If cog already used (placed into slot), draw it faded or hidden\n      if (isCogUsed(i)) {\n        // draw faded small indicator where used originally\n        ctx.globalAlpha = 0.15;\n      } else {\n        ctx.globalAlpha = 1;\n      }\n      // highlight border if selected\n      drawCogToken(x, y, 32, v, isSelected);\n      ctx.globalAlpha = 1;\n      // draw keyboard hint (index)\n      ctx.fillStyle = \"#2D2D2D\";\n      ctx.font = \"12px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.fillText((i + 1).toString(), x + 28, y - 10);\n    }\n\n    // Accessibility text: keyboard guide\n    ctx.fillStyle = \"#2B4A5A\";\n    ctx.font = \"12px sans-serif\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(\"Keyboard: \u2190/\u2192 move, Enter pick/place, H hint, R reset, S toggle sound\", areaX + 12, areaY + areaH - 10);\n  }\n\n  function drawCogToken(x, y, radius, value, selected) {\n    // outer body\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.shadowColor = \"rgba(0,0,0,0.08)\";\n    ctx.shadowBlur = 6;\n    ctx.fillStyle = selected ? \"#FFEDD7\" : \"#FFF8F3\";\n    ctx.beginPath();\n    ctx.arc(0, 0, radius, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = selected ? \"#F3B47F\" : \"#E2C2A4\";\n    ctx.lineWidth = selected ? 3 : 2;\n    ctx.stroke();\n    // little gear teeth\n    ctx.rotate((Date.now() / 1000 + x) % 10);\n    for (let t = 0; t < 8; t++) {\n      const a = (t / 8) * Math.PI * 2;\n      const x1 = Math.cos(a) * radius;\n      const y1 = Math.sin(a) * radius;\n      const x2 = Math.cos(a) * (radius + 5);\n      const y2 = Math.sin(a) * (radius + 5);\n      ctx.beginPath();\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x2, y2);\n      ctx.strokeStyle = \"#ECD0B2\";\n      ctx.lineWidth = 1;\n      ctx.stroke();\n    }\n    // number\n    ctx.fillStyle = \"#5A3B1C\";\n    ctx.font = \"bold 20px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(value.toString(), 0, 0);\n    ctx.restore();\n  }\n\n  function drawHUD() {\n    // Top right info\n    ctx.fillStyle = \"#2B4A5A\";\n    ctx.font = \"14px sans-serif\";\n    ctx.textAlign = \"right\";\n    ctx.fillText(`Level: ${game.level} / ${MAX_LEVEL}`, WIDTH - 14, 22);\n    ctx.fillText(`Lives: ${game.lives}`, WIDTH - 14, 42);\n    ctx.fillText(`Score: ${game.score}`, WIDTH - 14, 62);\n\n    // Visual life hearts\n    const heartX = WIDTH - 140;\n    for (let i = 0; i < game.lives; i++) {\n      drawHeart(heartX + i * 18, 46, 8, \"#FF6B6B\");\n    }\n  }\n\n  function drawHeart(x, y, size, color) {\n    ctx.save();\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(x, y);\n    ctx.bezierCurveTo(x, y - size / 2, x - size, y - size / 2, x - size, y + size / 4);\n    ctx.bezierCurveTo(x - size, y + size, x, y + size * 1.5, x, y + size * 2);\n    ctx.bezierCurveTo(x, y + size * 1.5, x + size, y + size, x + size, y + size / 4);\n    ctx.bezierCurveTo(x + size, y - size / 2, x, y - size / 2, x, y);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function drawFooter() {\n    ctx.fillStyle = \"#2B4A5A\";\n    ctx.font = \"bold 16px sans-serif\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(game.statusMessage, 16, HEIGHT - 10);\n  }\n\n  // Utility: rounded rectangle\n  function roundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.lineTo(x + w - r, y);\n    ctx.quadraticCurveTo(x + w, y, x + w, y + r);\n    ctx.lineTo(x + w, y + h - r);\n    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);\n    ctx.lineTo(x + r, y + h);\n    ctx.quadraticCurveTo(x, y + h, x, y + h - r);\n    ctx.lineTo(x, y + r);\n    ctx.quadraticCurveTo(x, y, x + r, y);\n    ctx.closePath();\n  }\n\n  // Game logic helpers\n  function isCogUsed(index) {\n    // A cog is used if its value exists in placed as that particular reference; but there can be duplicates\n    // We'll mark used by tracking placedIndices mapping to original index when placing\n    return (game._placedIndices && game._placedIndices.includes(index));\n  }\n\n  // The placedIndices array stores which cog indices are in slots\n  // We'll maintain game._placedIndices in tandem with game.placed\n  function placeCogToSlot(cogIndex, slotIndex) {\n    if (cogIndex === null || slotIndex === null) return false;\n    if (isCogUsed(cogIndex)) return false;\n    if (game.placed[slotIndex] !== null) return false;\n    game.placed[slotIndex] = game.cogValues[cogIndex];\n    game._placedIndices = game._placedIndices || [];\n    game._placedIndices[slotIndex] = cogIndex;\n    audio.playClick();\n    announce(`Placed cog ${cogIndex + 1} with value ${game.cogValues[cogIndex]} into slot ${slotIndex + 1}`);\n    return true;\n  }\n\n  function removeCogFromSlot(slotIndex) {\n    if (slotIndex == null) return false;\n    if (game.placed[slotIndex] === null) return false;\n    // free index\n    if (game._placedIndices) {\n      const idx = game._placedIndices[slotIndex];\n      game._placedIndices[slotIndex] = null;\n    }\n    game.placed[slotIndex] = null;\n    audio.playClick();\n    announce(`Removed from slot ${slotIndex + 1}`);\n    return true;\n  }\n\n  function checkSolution() {\n    // If any slot empty, notify\n    for (let i = 0; i < game.slots; i++) {\n      if (game.placed[i] === null) {\n        game.statusMessage = \"Place all cogs before checking.\";\n        announce(game.statusMessage);\n        audio.playIncorrect();\n        return false;\n      }\n    }\n    const sum = game.placed.reduce((a, b) => a + b, 0);\n    if (sum === game.target) {\n      audio.playCorrect();\n      game.statusMessage = `Nice! Level ${game.level} complete.`;\n      game.score += 10 + (game.hintUsed ? 0 : 5);\n      game.levelComplete = true;\n      announce(game.statusMessage);\n      // advance after short delay\n      setTimeout(() => {\n        if (game.level >= MAX_LEVEL) {\n          game.finished = true;\n          game.statusMessage = \"You fixed all the machines! Great job!\";\n          announce(game.statusMessage);\n        } else {\n          startLevel(game.level + 1);\n        }\n        draw();\n      }, 900);\n      return true;\n    } else {\n      audio.playIncorrect();\n      game.lives -= 1;\n      if (game.lives <= 0) {\n        // reset progress to level 1\n        game.statusMessage = \"Oh no! The machine stopped. Restarting level.\";\n        announce(game.statusMessage);\n        setTimeout(() => {\n          game.lives = INITIAL_LIVES;\n          startLevel(1);\n          draw();\n        }, 1200);\n      } else {\n        game.statusMessage = `Not quite. The machine output ${sum}. Try again!`;\n        // allow player to change placements - maybe clear placed slots or allow swap\n        // we'll clear placed slots for simplicity\n        game.placed = new Array(game.slots).fill(null);\n        game._placedIndices = new Array(game.slots).fill(null);\n        announce(game.statusMessage + ` Lives left: ${game.lives}`);\n      }\n      draw();\n      return false;\n    }\n  }\n\n  function giveHint() {\n    // find a valid combination and reveal one slot\n    game.hintUsed = true;\n    const nums = game.cogValues.slice();\n    // Try all combinations\n    let found = null;\n    function helper(start, k, sum, chosenIndices) {\n      if (k === 0) {\n        if (sum === game.target) {\n          found = chosenIndices.slice();\n          return true;\n        }\n        return false;\n      }\n      for (let i = start; i <= nums.length - k; i++) {\n        if (helper(i + 1, k - 1, sum + nums[i], chosenIndices.concat(i))) return true;\n      }\n      return false;\n    }\n    helper(0, game.slots, 0, []);\n    if (found && found.length > 0) {\n      // place the first value into first empty slot\n      let slotToFill = null;\n      for (let s = 0; s < game.slots; s++) {\n        if (game.placed[s] === null) {\n          slotToFill = s;\n          break;\n        }\n      }\n      if (slotToFill === null) slotToFill = 0;\n      placeCogToSlot(found[0], slotToFill);\n      game.statusMessage = \"Hint: one cog placed to help you get started.\";\n      announce(game.statusMessage);\n    } else {\n      game.statusMessage = \"Hmm, I couldn't find a hint. Try a different choice!\";\n      announce(game.statusMessage);\n    }\n  }\n\n  // Input handling\n  // Map keyboard to selection and actions\n  let focusedCog = 0; // for keyboard navigation among cogs\n\n  function handleKey(e) {\n    if (game.finished) {\n      if (e.key === \"r\" || e.key === \"R\") {\n        startLevel(1);\n      }\n      return;\n    }\n    if (e.key === \"ArrowRight\") {\n      focusedCog = (focusedCog + 1) % game.cogValues.length;\n      game.selectedCogIndex = focusedCog;\n      audio.playClick();\n      announce(`Selected cog ${focusedCog + 1} value ${game.cogValues[focusedCog]}`);\n      draw();\n      e.preventDefault();\n    } else if (e.key === \"ArrowLeft\") {\n      focusedCog = (focusedCog - 1 + game.cogValues.length) % game.cogValues.length;\n      game.selectedCogIndex = focusedCog;\n      audio.playClick();\n      announce(`Selected cog ${focusedCog + 1} value ${game.cogValues[focusedCog]}`);\n      draw();\n      e.preventDefault();\n    } else if (e.key === \"Enter\") {\n      // pick or place depending on selection\n      if (game.selectedCogIndex !== null) {\n        // try to place to first empty slot\n        let placed = false;\n        for (let s = 0; s < game.slots; s++) {\n          if (game.placed[s] === null) {\n            placed = placeCogToSlot(game.selectedCogIndex, s);\n            break;\n          }\n        }\n        if (!placed) {\n          // maybe remove last placed\n          // allow removing from slot using keyboard: ENTER on selected cog removes it from slot if used\n          const usedPos = (game._placedIndices || []).indexOf(game.selectedCogIndex);\n          if (usedPos >= 0) {\n            removeCogFromSlot(usedPos);\n          } else {\n            game.statusMessage = \"That cog is already used or no empty slot.\";\n            announce(game.statusMessage);\n            audio.playIncorrect();\n          }\n        }\n        draw();\n      } else {\n        // no cog selected -> nothing\n        game.statusMessage = \"Select a cog first with Left/Right.\";\n        announce(game.statusMessage);\n        audio.playIncorrect();\n      }\n      e.preventDefault();\n    } else if (e.key === \"h\" || e.key === \"H\") {\n      giveHint();\n      draw();\n      e.preventDefault();\n    } else if (e.key === \"r\" || e.key === \"R\") {\n      startLevel(game.level);\n      draw();\n      audio.playClick();\n      announce(\"Level reset.\");\n      e.preventDefault();\n    } else if (e.key === \"s\" || e.key === \"S\") {\n      // toggle audio\n      game.audioEnabled = !game.audioEnabled;\n      audio.setMuted(!game.audioEnabled);\n      announce(game.audioEnabled ? \"Audio enabled\" : \"Audio disabled\");\n      draw();\n      e.preventDefault();\n    } else if (e.key === \" \") {\n      // space attempts check\n      checkSolution();\n      draw();\n      e.preventDefault();\n    } else if (e.key === \"Tab\") {\n      // move selection cycle\n      focusedCog = (focusedCog + 1) % game.cogValues.length;\n      game.selectedCogIndex = focusedCog;\n      draw();\n      e.preventDefault();\n    }\n  }\n\n  // Mouse events: pick cog, drag to slot, click check button\n  let mouse = {\n    down: false,\n    x: 0,\n    y: 0,\n  };\n\n  function getCogIndexAt(x, y) {\n    const areaX = 40;\n    const areaY = 320;\n    const startX = areaX + 40;\n    const startY = areaY + 68;\n    const gap = 100;\n    for (let i = 0; i < game.cogValues.length; i++) {\n      const cx = startX + i * gap;\n      const cy = startY;\n      const dx = x - cx;\n      const dy = y - cy;\n      if (dx * dx + dy * dy <= 32 * 32) return i;\n    }\n    return null;\n  }\n\n  function getSlotAt(x, y) {\n    const panelX = 120;\n    const panelY = 120;\n    const slotStartX = panelX + 50;\n    const slotY = panelY + 150;\n    const slotGap = 90;\n    for (let i = 0; i < game.slots; i++) {\n      const sx = slotStartX + i * slotGap;\n      const sy = slotY;\n      const dx = x - sx;\n      const dy = y - sy;\n      if (dx * dx + dy * dy <= 40 * 40) return i;\n    }\n    return null;\n  }\n\n  function getCheckButtonAt(x, y) {\n    const panelX = 120;\n    const panelY = 120;\n    const buttonX = panelX + 340;\n    const buttonY = panelY + 150;\n    if (Math.abs(x - buttonX) <= 40 && Math.abs(y - buttonY) <= 24) return true;\n    return false;\n  }\n\n  canvas.addEventListener(\"mousedown\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    mouse.down = true;\n    mouse.x = x;\n    mouse.y = y;\n    // resume audio if suspended\n    audio.resumeIfNeeded();\n\n    const cogIdx = getCogIndexAt(x, y);\n    if (cogIdx !== null) {\n      // if cog is used, remove it instead\n      if (isCogUsed(cogIdx)) {\n        // find slot\n        const slot = (game._placedIndices || []).indexOf(cogIdx);\n        if (slot >= 0) {\n          removeCogFromSlot(slot);\n        }\n      } else {\n        game.selectedCogIndex = cogIdx;\n        game.draggingIndex = cogIdx;\n        focusedCog = cogIdx;\n        audio.playClick();\n        announce(`Picked up cog ${cogIdx + 1}, value ${game.cogValues[cogIdx]}`);\n      }\n      draw();\n      return;\n    }\n    // click machine check button?\n    if (getCheckButtonAt(x, y)) {\n      checkSolution();\n      draw();\n      return;\n    }\n    // click on slot to remove if present\n    const slotIdx = getSlotAt(x, y);\n    if (slotIdx !== null) {\n      if (game.placed[slotIdx] !== null) {\n        removeCogFromSlot(slotIdx);\n        draw();\n      } else {\n        // if selected cog exists, place into this slot\n        if (game.selectedCogIndex !== null && !isCogUsed(game.selectedCogIndex)) {\n          placeCogToSlot(game.selectedCogIndex, slotIdx);\n          draw();\n        }\n      }\n      return;\n    }\n  });\n\n  canvas.addEventListener(\"mousemove\", (e) => {\n    if (!mouse.down) return;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    mouse.x = x;\n    mouse.y = y;\n    // visual dragging handled in drawing: store draggingIndex\n    draw();\n  });\n\n  canvas.addEventListener(\"mouseup\", (e) => {\n    mouse.down = false;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    // If dragging a cog, attempt to drop to a slot\n    if (game.draggingIndex !== null) {\n      const slotIdx = getSlotAt(x, y);\n      if (slotIdx !== null) {\n        // attempt to place\n        const success = placeCogToSlot(game.draggingIndex, slotIdx);\n        if (!success) {\n          game.statusMessage = \"Can't place there.\";\n          announce(game.statusMessage);\n        }\n      } else {\n        // dropped elsewhere, remain selected but not placed\n        game.statusMessage = \"Cog returned to its place.\";\n        announce(game.statusMessage);\n      }\n      game.draggingIndex = null;\n      draw();\n    }\n  });\n\n  // Click/tap to focus for keyboard controls\n  canvas.addEventListener(\"click\", (e) => {\n    canvas.focus();\n    // resume audio on user gesture\n    audio.resumeIfNeeded();\n  });\n\n  // Touch support: map to mouse events\n  canvas.addEventListener(\"touchstart\", (e) => {\n    e.preventDefault();\n    const touch = e.touches[0];\n    const rect = canvas.getBoundingClientRect();\n    const x = touch.clientX - rect.left;\n    const y = touch.clientY - rect.top;\n    mouse.down = true;\n    mouse.x = x;\n    mouse.y = y;\n    const cogIdx = getCogIndexAt(x, y);\n    if (cogIdx !== null) {\n      if (isCogUsed(cogIdx)) {\n        const slot = (game._placedIndices || []).indexOf(cogIdx);\n        if (slot >= 0) removeCogFromSlot(slot);\n      } else {\n        game.selectedCogIndex = cogIdx;\n        game.draggingIndex = cogIdx;\n        focusedCog = cogIdx;\n      }\n      draw();\n      return;\n    }\n    if (getCheckButtonAt(x, y)) {\n      checkSolution();\n      draw();\n      return;\n    }\n  });\n\n  canvas.addEventListener(\"touchmove\", (e) => {\n    e.preventDefault();\n    if (!mouse.down) return;\n    const touch = e.touches[0];\n    const rect = canvas.getBoundingClientRect();\n    mouse.x = touch.clientX - rect.left;\n    mouse.y = touch.clientY - rect.top;\n    draw();\n  });\n\n  canvas.addEventListener(\"touchend\", (e) => {\n    e.preventDefault();\n    mouse.down = false;\n    if (game.draggingIndex !== null) {\n      // drop at last location\n      const x = mouse.x, y = mouse.y;\n      const slotIdx = getSlotAt(x, y);\n      if (slotIdx !== null) {\n        placeCogToSlot(game.draggingIndex, slotIdx);\n      }\n      game.draggingIndex = null;\n      draw();\n    }\n  });\n\n  window.addEventListener(\"keydown\", handleKey);\n\n  // Main render loop for animations\n  function frame() {\n    // draw dynamic dragging preview\n    // We'll draw the base scene then overlay dragged cog if any\n    drawBaseSceneWithDrag();\n    requestAnimationFrame(frame);\n  }\n\n  function drawBaseSceneWithDrag() {\n    // draw everything\n    draw();\n    // overlay dragging cog\n    if (game.draggingIndex !== null && mouse.x !== undefined) {\n      const i = game.draggingIndex;\n      // draw semi-transparent cog following cursor\n      ctx.save();\n      ctx.globalAlpha = 0.95;\n      drawCogToken(mouse.x, mouse.y, 32, game.cogValues[i], true);\n      ctx.restore();\n    }\n  }\n\n  // Start the game\n  function initGame() {\n    startLevel(1);\n    draw();\n    announce(\"Game ready. Use mouse or keyboard to play. Press S to toggle sound.\");\n    // Kick off render loop\n    requestAnimationFrame(frame);\n  }\n\n  // Initialize audio state from manager readiness after small delay (allow init)\n  setTimeout(() => {\n    if (!audio.available) {\n      game.audioEnabled = false;\n      game.statusMessage = \"Audio is not available in this browser or was blocked. Use S to toggle sound.\";\n      announce(game.statusMessage);\n      draw();\n    } else {\n      game.audioEnabled = true;\n      audio.setMuted(!game.audioEnabled);\n      announce(\"Audio is ready. Click canvas to enable sound if needed.\");\n    }\n  }, 300);\n\n  // Accessibility: click-to-enable audio button displayed graphically inside canvas, but we also provide keyboard S toggle.\n\n  // Error handling for page unloading: dispose audio\n  window.addEventListener(\"beforeunload\", () => {\n    try {\n      audio.dispose();\n    } catch (e) {}\n  });\n\n  // Kick off\n  initGame();\n})();\n---\n",
  "improve_response_tokens": 24759,
  "formatted_code": true,
  "formatting_response_tokens": 26071,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}