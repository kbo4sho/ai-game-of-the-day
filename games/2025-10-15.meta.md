# Game of the Day - 2025-10-15

## Metadata
- **Generated Date:** 2025-10-15
- **Generated Time:** 2025-10-15T01:57:45.147429
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-10-15.js
- **File Size:** 23811 bytes
- **Tokens Used:** 8027

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-10-15.js` - The playable game
- `2025-10-15.meta.json` - Machine-readable metadata
- `2025-10-15.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 18092

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 20974

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Drone Math Catcher - Canvas Game
  // Ages 7-9. Theme: Drones. Collect the correct numbered packages to answer math questions.
  // Goal: Collect 10 correct packages. Lose when 3 wrong choices are made.
  // All visuals via canvas. All sounds via Web Audio API oscillators/filters.
  // Written for readability and accessibility.

  // Ensure host container
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Container element with id "game-of-the-day-stage" not found.');
    return;
  }

  // Create canvas
  const WIDTH = 720;
  const HEIGHT = 480;
  container.innerHTML = ''; // clear existing content
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.display = 'block';
  canvas.setAttribute('role', 'application');
  canvas.setAttribute('aria-label', 'Drone Math Catcher. Use left and right arrows to move. Press R to restart.');
  canvas.tabIndex = 0; // make focusable for keyboard
  container.appendChild(canvas);

  const ctx = canvas.getContext('2d');

  // UI layout constants and padding
  const PADDING = 10;
  const TOP_UI_Y = PADDING;
  const SCORE_X = PADDING;
  const LIVES_X = WIDTH - PADDING;
  const INSTRUCTIONS_Y = HEIGHT - 70; // bottom area for instructions
  const MIN_BODY_FONT = 14;
  const BIG_FONT = 24;

  // Game parameters
  const TARGET_SCORE = 10;
  const MAX_LIVES = 3;
  const PACKAGE_SPEED_MIN = 0.4;
  const PACKAGE_SPEED_MAX = 1.2;
  const DRONE_SPEED = 4;
  const PACKAGE_RADIUS = 28;
  const DRONE_WIDTH = 80;
  const DRONE_HEIGHT = 32;

  // State
  let score = 0;
  let lives = MAX_LIVES;
  let level = 1;
  let gameState = 'running'; // running, won, lost, paused
  let packages = [];
  let currentProblem = null;
  let keys = {};
  let animationFrameId = null;
  let lastTime = performance.now();

  // Accessibility messages
  function updateAriaMessage(msg) {
    canvas.setAttribute('aria-label', msg);
  }

  // Audio setup with error handling
  let audioCtx = null;
  let audioAllowed = true;
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AudioContext();
  } catch (e) {
    console.warn('Web Audio API not available or blocked:', e);
    audioAllowed = false;
    audioCtx = null;
  }

  // Resume audio on user gesture if suspended
  function tryResumeAudio() {
    if (!audioCtx) return;
    if (audioCtx.state === 'suspended') {
      audioCtx.resume().catch((e) => {
        console.warn('AudioContext resume failed:', e);
      });
    }
  }

  // Sound helpers (use oscillators; handle audio errors)
  function playSuccessSound() {
    if (!audioAllowed || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'sine';
      o.frequency.setValueAtTime(880, now);
      o.frequency.exponentialRampToValueAtTime(1320, now + 0.12);
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(0.08, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);
      o.connect(g);
      g.connect(audioCtx.destination);
      o.start(now);
      o.stop(now + 0.3);
    } catch (e) {
      console.warn('Error playing success sound', e);
    }
  }

  function playFailSound() {
    if (!audioAllowed || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const f = audioCtx.createBiquadFilter();
      o.type = 'square';
      o.frequency.setValueAtTime(200, now);
      o.frequency.exponentialRampToValueAtTime(80, now + 0.15);
      f.type = 'lowpass';
      f.frequency.setValueAtTime(1200, now);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.08, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.3);
      o.connect(f);
      f.connect(g);
      g.connect(audioCtx.destination);
      o.start(now);
      o.stop(now + 0.35);
    } catch (e) {
      console.warn('Error playing fail sound', e);
    }
  }

  // Background gentle hum: persistent oscillator low volume
  let hum = null;
  function startBackgroundHum() {
    if (!audioAllowed || !audioCtx) return;
    try {
      if (hum) return;
      hum = {};
      hum.osc = audioCtx.createOscillator();
      hum.gain = audioCtx.createGain();
      hum.filter = audioCtx.createBiquadFilter();
      hum.osc.type = 'sine';
      hum.osc.frequency.setValueAtTime(120, audioCtx.currentTime);
      hum.filter.type = 'lowpass';
      hum.filter.frequency.setValueAtTime(600, audioCtx.currentTime);
      hum.gain.gain.setValueAtTime(0.01, audioCtx.currentTime);
      hum.osc.connect(hum.filter);
      hum.filter.connect(hum.gain);
      hum.gain.connect(audioCtx.destination);
      hum.osc.start();
    } catch (e) {
      console.warn('Could not start background hum', e);
      hum = null;
    }
  }

  function stopBackgroundHum() {
    if (!hum) return;
    try {
      hum.osc.stop();
      hum.osc.disconnect();
      hum.filter.disconnect();
      hum.gain.disconnect();
    } catch (e) {
      // no-op
    }
    hum = null;
  }

  // Game objects
  const drone = {
    x: WIDTH / 2,
    y: HEIGHT - 80,
    vx: 0,
    width: DRONE_WIDTH,
    height: DRONE_HEIGHT,
    color: '#6AB8FF',
    draw: function (ctx) {
      // draw drone body
      ctx.save();
      ctx.fillStyle = this.color;
      ctx.strokeStyle = '#23395B';
      ctx.lineWidth = 2;
      // body
      ctx.beginPath();
      ctx.ellipse(this.x, this.y, this.width / 2, this.height / 2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      // propellers (wacky)
      ctx.fillStyle = '#DDEEFF';
      const pr = 10;
      ctx.beginPath();
      ctx.arc(this.x - this.width / 2 + 12, this.y - this.height / 2 - 6, pr, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(this.x + this.width / 2 - 12, this.y - this.height / 2 - 6, pr, 0, Math.PI * 2);
      ctx.fill();
      // legs
      ctx.strokeStyle = '#23395B';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(this.x - 22, this.y + 14);
      ctx.lineTo(this.x - 22, this.y + 24);
      ctx.moveTo(this.x + 22, this.y + 14);
      ctx.lineTo(this.x + 22, this.y + 24);
      ctx.stroke();
      ctx.restore();
      // hitbox guide for accessibility (thin outline)
      ctx.save();
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.lineWidth = 1;
      ctx.strokeRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
      ctx.restore();
    },
    update: function () {
      // Horizontal movement constrained to canvas
      if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
        this.vx = -DRONE_SPEED;
      } else if (keys['ArrowRight'] || keys['d'] || keys['D']) {
        this.vx = DRONE_SPEED;
      } else {
        this.vx = 0;
      }
      this.x += this.vx;
      if (this.x < this.width / 2) this.x = this.width / 2;
      if (this.x > WIDTH - this.width / 2) this.x = WIDTH - this.width / 2;
    },
  };

  class PackageItem {
    constructor(x, y, value, speed, color) {
      this.x = x;
      this.y = y;
      this.value = value;
      this.speed = speed;
      this.color = color;
      this.radius = PACKAGE_RADIUS;
      this.collected = false;
    }

    update(dt) {
      this.y += this.speed * dt;
      // bounce horizontally slightly for wacky motion (sinus)
      this.x += Math.sin(this.y / 40) * 0.2;
    }

    draw(ctx) {
      ctx.save();
      // package body
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fill();
      // stripe
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fillRect(this.x - this.radius * 0.7, this.y - 6, this.radius * 1.4, 12);
      // number
      ctx.fillStyle = '#102A43';
      ctx.font = 'bold 20px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(this.value), this.x, this.y);
      // small shadow
      ctx.globalAlpha = 0.12;
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.ellipse(this.x + 6, this.y + this.radius + 6, this.radius * 0.7, 8, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    isOffscreen() {
      return this.y - this.radius > HEIGHT;
    }

    collidesWithDrone(drone) {
      const dx = this.x - drone.x;
      const dy = this.y - drone.y;
      // rough collision circle vs rect: check if circle center inside extended rect region
      const closestX = Math.max(drone.x - drone.width / 2, Math.min(this.x, drone.x + drone.width / 2));
      const closestY = Math.max(drone.y - drone.height / 2, Math.min(this.y, drone.y + drone.height / 2));
      const distX = this.x - closestX;
      const distY = this.y - closestY;
      return distX * distX + distY * distY < this.radius * this.radius;
    }
  }

  // Utility: draw text with background box using measureText
  function drawTextBox(ctx, text, x, y, options = {}) {
    const font = options.font || `${MIN_BODY_FONT}px sans-serif`;
    const padding = options.padding || 8;
    const align = options.align || 'left';
    const baseline = options.baseline || 'top';
    ctx.save();
    ctx.font = font;
    ctx.textAlign = align;
    ctx.textBaseline = baseline;
    // support multiline by splitting lines
    const lines = text.split('\n');
    // measure widest line
    let maxWidth = 0;
    for (const line of lines) {
      const m = ctx.measureText(line).width;
      if (m > maxWidth) maxWidth = m;
    }
    // determine box top-left
    let boxX = x;
    if (align === 'center') boxX = x - maxWidth / 2 - padding;
    else if (align === 'right') boxX = x - maxWidth - padding * 2;
    let boxY = y;
    if (baseline === 'middle') boxY = y - (lines.length * parseInt(font, 10)) / 2 - padding;
    else if (baseline === 'bottom') boxY = y - lines.length * parseInt(font, 10) - padding * 2;
    // draw background
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    const boxW = maxWidth + padding * 2;
    const lineHeight = parseInt(font, 10) + 6;
    const boxH = lines.length * lineHeight + padding * 2 - 6;
    ctx.fillRect(boxX, boxY, boxW, boxH);
    // border
    ctx.strokeStyle = 'rgba(0,0,0,0.12)';
    ctx.lineWidth = 1;
    ctx.strokeRect(boxX, boxY, boxW, boxH);
    // draw lines
    ctx.fillStyle = '#102A43';
    ctx.textAlign = align;
    ctx.textBaseline = 'top';
    let textX = x;
    if (align === 'center') textX = x;
    else if (align === 'left') textX = boxX + padding;
    else if (align === 'right') textX = boxX + boxW - padding;
    let textY = boxY + padding;
    for (const line of lines) {
      ctx.fillText(line, textX, textY);
      textY += lineHeight;
    }
    ctx.restore();
    // return box bounds for interaction if needed
    return { x: boxX, y: boxY, w: boxW, h: boxH };
  }

  // Generate math problems (age-appropriate)
  function generateProblem() {
    const type = Math.random() < 0.6 ? 'add' : 'sub';
    let a, b, answer;
    if (type === 'add') {
      a = Math.floor(Math.random() * 10) + 1; // 1-10
      b = Math.floor(Math.random() * Math.min(10, 11 - a)) + 1; // keep sums <= 20
      answer = a + b;
    } else {
      a = Math.floor(Math.random() * 12) + 2; // 2-13
      b = Math.floor(Math.random() * (a - 1)) + 1; // 1 to a-1 so result positive
      answer = a - b;
    }
    const text = type === 'add' ? `${a} + ${b}` : `${a} - ${b}`;
    return { text, answer, a, b, type };
  }

  // Spawn packages for a problem: one correct and two distractors
  function spawnPackagesForProblem(problem) {
    packages = [];
    const correctValue = problem.answer;
    // choose two distractors (avoid duplicates and negative)
    const distractors = new Set();
    while (distractors.size < 2) {
      let delta = Math.floor(Math.random() * 5) - 2; // -2..2
      if (delta === 0) delta = 3; // avoid zero
      const val = correctValue + delta;
      if (val < 0 || val === correctValue) continue;
      distractors.add(val);
    }
    const values = [correctValue, ...Array.from(distractors)];
    // shuffle
    for (let i = values.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [values[i], values[j]] = [values[j], values[i]];
    }
    // place packages near top with varied x positions
    const xPositions = [WIDTH * 0.25, WIDTH * 0.5, WIDTH * 0.75];
    for (let i = 0; i < values.length; i++) {
      const x = xPositions[i] + (Math.random() * 40 - 20);
      const y = -20 - Math.random() * 80;
      const speed = PACKAGE_SPEED_MIN + Math.random() * (PACKAGE_SPEED_MAX - PACKAGE_SPEED_MIN) + level * 0.06;
      const color = ['#FFD166', '#06D6A0', '#FF6B6B'][i % 3];
      packages.push(new PackageItem(x, y, values[i], speed, color));
    }
  }

  // Initialize a new round
  function newRound() {
    currentProblem = generateProblem();
    spawnPackagesForProblem(currentProblem);
    updateAriaMessage(`New problem: ${currentProblem.text}. Move the drone to catch the correct package.`);
  }

  // Restart game
  function restartGame() {
    score = 0;
    lives = MAX_LIVES;
    level = 1;
    gameState = 'running';
    drone.x = WIDTH / 2;
    packages = [];
    newRound();
    tryResumeAudio();
    startBackgroundHum();
  }

  // Handle collection result
  function handleCollection(pkg) {
    if (!pkg) return;
    if (pkg.value === currentProblem.answer) {
      score += 1;
      playSuccessSound();
      updateAriaMessage(`Correct! You collected ${pkg.value}. Score ${score} of ${TARGET_SCORE}.`);
      if (score >= TARGET_SCORE) {
        gameState = 'won';
        stopBackgroundHum();
      } else {
        level = 1 + Math.floor(score / 3);
        newRound();
      }
    } else {
      lives -= 1;
      playFailSound();
      updateAriaMessage(`Oops! ${pkg.value} was wrong. Lives left ${lives}.`);
      if (lives <= 0) {
        gameState = 'lost';
        stopBackgroundHum();
      } else {
        // respawn same problem so player can try again
        spawnPackagesForProblem(currentProblem);
      }
    }
  }

  // Input handling
  window.addEventListener('keydown', (e) => {
    keys[e.key] = true;
    if (e.key === 'r' || e.key === 'R') {
      // restart on R
      restartGame();
    }
    // pause toggling with P
    if (e.key === 'p' || e.key === 'P') {
      gameState = gameState === 'running' ? 'paused' : 'running';
      if (gameState === 'running') {
        tryResumeAudio();
        startBackgroundHum();
      } else {
        stopBackgroundHum();
      }
    }
    // allow audio resume with AnyKey
    tryResumeAudio();
  });

  window.addEventListener('keyup', (e) => {
    keys[e.key] = false;
  });

  // Mouse click for restart button or focusing canvas
  canvas.addEventListener('click', (e) => {
    canvas.focus();
    tryResumeAudio();
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    if (gameState === 'won' || gameState === 'lost') {
      // check restart button bounds
      const btnW = 220;
      const btnH = 50;
      const btnX = WIDTH / 2 - btnW / 2;
      const btnY = HEIGHT / 2 + 40;
      if (mx >= btnX && mx <= btnX + btnW && my >= btnY && my <= btnY + btnH) {
        restartGame();
      }
    }
  });

  // Main update loop
  function update(dt) {
    if (gameState !== 'running') return;
    drone.update();
    // dt in ms, convert to factor
    const factor = dt * 0.06; // tuned factor
    for (let i = packages.length - 1; i >= 0; i--) {
      const pkg = packages[i];
      pkg.update(factor);
      if (pkg.collidesWithDrone(drone)) {
        // handle collection
        const collected = pkg;
        packages.splice(i, 1);
        handleCollection(collected);
      } else if (pkg.isOffscreen()) {
        // if a correct package goes offscreen, respawn packages (player missed)
        if (pkg.value === currentProblem.answer) {
          // miss = lose a life
          lives -= 1;
          playFailSound();
          updateAriaMessage(`You missed the correct package. Lives left ${lives}.`);
          if (lives <= 0) {
            gameState = 'lost';
            stopBackgroundHum();
            return;
          }
          // respawn same problem
          spawnPackagesForProblem(currentProblem);
          return;
        } else {
          // remove distractor offscreen
          packages.splice(i, 1);
          // If all packages gone unexpectedly, spawn new set
          if (packages.length === 0) {
            spawnPackagesForProblem(currentProblem);
          }
        }
      }
    }
  }

  // Drawing loop
  function draw() {
    // Clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Background: calming gradient with wacky cloud-ish shapes
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#E6F7FF');
    g.addColorStop(1, '#F6FBFF');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Draw some wacky floating shapes (simple clouds/drones)
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = '#FAFFFD';
    for (let i = 0; i < 4; i++) {
      const cx = 80 + i * 170;
      const cy = 50 + Math.sin((Date.now() / 1000) + i) * 6;
      ctx.beginPath();
      ctx.ellipse(cx, cy, 54, 20, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(cx + 24, cy - 6, 30, 12, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(cx - 28, cy - 4, 26, 10, 0, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();

    // Top UI: Score on left
    const scoreText = `Score: ${score}/${TARGET_SCORE}`;
    ctx.font = `bold ${BIG_FONT}px sans-serif`;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    const scoreBox = drawTextBox(ctx, scoreText, SCORE_X + 2, TOP_UI_Y + 2, {
      font: `bold ${BIG_FONT}px sans-serif`,
      padding: 8,
      align: 'left',
      baseline: 'top',
    });

    // Lives on right
    const livesText = `Lives: ${lives}`;
    ctx.font = `bold ${BIG_FONT}px sans-serif`;
    ctx.textAlign = 'right';
    ctx.textBaseline = 'top';
    // measure and draw right-aligned box using helper by giving x as right edge
    const livesBox = drawTextBox(ctx, livesText, LIVES_X - 2, TOP_UI_Y + 2, {
      font: `bold ${BIG_FONT}px sans-serif`,
      padding: 8,
      align: 'right',
      baseline: 'top',
    });

    // Problem text centered top
    const problemText = currentProblem ? `Solve: ${currentProblem.text}` : 'Loading...';
    ctx.font = `bold 20px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    drawTextBox(ctx, problemText, WIDTH / 2, TOP_UI_Y + 2, {
      font: `bold 20px sans-serif`,
      padding: 8,
      align: 'center',
      baseline: 'top',
    });

    // Draw drone (player)
    drone.draw(ctx);

    // Draw packages
    for (const pkg of packages) {
      pkg.draw(ctx);
    }

    // Instructions at bottom center (ensure not overlapping)
    const instructions = 'Use ← → or A D to move the drone. Catch the correct number.\nPress R to restart, P to pause.';
    ctx.font = `${MIN_BODY_FONT}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    drawTextBox(ctx, instructions, WIDTH / 2, INSTRUCTIONS_Y, {
      font: `${MIN_BODY_FONT}px sans-serif`,
      padding: 10,
      align: 'center',
      baseline: 'top',
    });

    // Audio visual cue (small icon top-left of instructions)
    ctx.save();
    const audioLabel = audioAllowed && audioCtx ? 'Audio: On (press any key to enable)' : 'Audio: Off';
    ctx.font = `14px sans-serif`;
    ctx.textBaseline = 'top';
    ctx.textAlign = 'left';
    const audioBox = drawTextBox(ctx, audioLabel, PADDING, INSTRUCTIONS_Y - 50, {
      font: `14px sans-serif`,
      padding: 6,
      align: 'left',
      baseline: 'top',
    });
    ctx.restore();

    // If paused overlay
    if (gameState === 'paused') {
      ctx.save();
      ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.font = 'bold 36px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      drawTextBox(ctx, 'Paused', WIDTH / 2, HEIGHT / 2 - 40, {
        font: 'bold 36px sans-serif',
        padding: 12,
        align: 'center',
        baseline: 'middle',
      });
      ctx.restore();
    }

    // End screens
    if (gameState === 'won') {
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.fillRect(60, 80, WIDTH - 120, HEIGHT - 160);
      ctx.strokeStyle = '#1B4965';
      ctx.lineWidth = 3;
      ctx.strokeRect(60, 80, WIDTH - 120, HEIGHT - 160);
      ctx.font = 'bold 32px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      drawTextBox(ctx, `Victory!\nYou helped the drone collect ${TARGET_SCORE} correct packages!`, WIDTH / 2, HEIGHT / 2 - 40, {
        font: 'bold 28px sans-serif',
        padding: 12,
        align: 'center',
        baseline: 'middle',
      });
      // Restart button
      const btnW = 220;
      const btnH = 50;
      const btnX = WIDTH / 2 - btnW / 2;
      const btnY = HEIGHT / 2 + 40;
      ctx.fillStyle = '#06D6A0';
      ctx.fillRect(btnX, btnY, btnW, btnH);
      ctx.strokeStyle = '#054A3C';
      ctx.strokeRect(btnX, btnY, btnW, btnH);
      ctx.font = 'bold 20px sans-serif';
      ctx.fillStyle = '#053A2B';
      ctx.fillText('Play Again (Click R)', WIDTH / 2, btnY + btnH / 2);
      ctx.restore();
    } else if (gameState === 'lost') {
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.fillRect(60, 80, WIDTH - 120, HEIGHT - 160);
      ctx.strokeStyle = '#6B0F1A';
      ctx.lineWidth = 3;
      ctx.strokeRect(60, 80, WIDTH - 120, HEIGHT - 160);
      drawTextBox(ctx, `Game Over\nYou ran out of lives. Score: ${score}`, WIDTH / 2, HEIGHT / 2 - 30, {
        font: 'bold 26px sans-serif',
        padding: 12,
        align: 'center',
        baseline: 'middle',
      });
      const btnW = 220;
      const btnH = 50;
      const btnX = WIDTH / 2 - btnW / 2;
      const btnY = HEIGHT / 2 + 60;
      ctx.fillStyle = '#FF6B6B';
      ctx.fillRect(btnX, btnY, btnW, btnH);
      ctx.strokeStyle = '#5B1010';
      ctx.strokeRect(btnX, btnY, btnW, btnH);
      ctx.font = 'bold 20px sans-serif';
      ctx.fillStyle = '#381313';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('Try Again (Click R)', WIDTH / 2, btnY + btnH / 2);
      ctx.restore();
    }
  }

  function gameLoop(ts) {
    const dt = ts - lastTime;
    lastTime = ts;
    update(dt);
    draw();
    animationFrameId = requestAnimationFrame(gameLoop);
  }

  // Start game
  function start() {
    tryResumeAudio();
    startBackgroundHum();
    restartGame();
    lastTime = performance.now();
    if (animationFrameId) cancelAnimationFrame(animationFrameId);
    animationFrameId = requestAnimationFrame(gameLoop);
  }

  // Graceful cleanup on page unload
  window.addEventListener('blur', () => {
    // pause when tab loses focus to save CPU and audio
    if (gameState === 'running') {
      gameState = 'paused';
      stopBackgroundHum();
    }
  });

  window.addEventListener('focus', () => {
    // resume automatically only if not ended
    if (gameState === 'paused') {
      gameState = 'running';
      tryResumeAudio();
      startBackgroundHum();
    }
  });

  // Provide some initial instruction in console and aria
  console.log('Drone Math Catcher loaded. Focus the canvas and use arrow keys to play. Press R to restart.');
  updateAriaMessage('Drone Math Catcher loaded. Press arrow keys to move. Press R to restart.');

  // Kick off
  start();
})();
---

