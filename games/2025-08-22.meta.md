# Game of the Day - 2025-08-22

## Metadata
- **Generated Date:** 2025-08-22
- **Generated Time:** 2025-08-22T00:26:35.253268
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-22.js
- **File Size:** 26207 bytes
- **Tokens Used:** 8956

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-22.js` - The playable game
- `2025-08-22.meta.json` - Machine-readable metadata
- `2025-08-22.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 18287

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 19947

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Power-Up Circuit: A math game for ages 7-9 (addition practice) themed around electricity.
  // The entire game renders inside the element with ID "game-of-the-day-stage".
  // All graphics drawn to a 720x480 canvas. Sounds are generated with Web Audio API oscillators/filters.
  // Controls: Arrow keys or WASD to move Sparkie. Space toggles audio. Enter restarts after finish.
  // Accessibility: A hidden ARIA live region provides text updates. Keyboard controls supported.
  // Author: educational game designer AI.

  // -----------------------
  // Configuration & Setup
  // -----------------------
  const STAGE_ID = "game-of-the-day-stage";
  const WIDTH = 720;
  const HEIGHT = 480;

  // Ensure container exists
  const container = document.getElementById(STAGE_ID);
  if (!container) {
    console.error(`Game container with ID "${STAGE_ID}" not found.`);
    return;
  }

  // Clear container and create canvas
  container.innerHTML = "";
  container.style.position = "relative";
  container.style.width = WIDTH + "px";
  container.style.height = HEIGHT + "px";
  container.style.userSelect = "none";

  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute("role", "application");
  canvas.setAttribute("aria-label", "Power-Up Circuit math game. Use arrow keys or WASD to move Sparkie and collect numbered energy bits to match lamp targets.");
  canvas.style.display = "block";
  container.appendChild(canvas);

  // Hidden ARIA live region for screen readers
  const sr = document.createElement("div");
  sr.setAttribute("aria-live", "polite");
  sr.style.position = "absolute";
  sr.style.left = "-9999px";
  sr.style.width = "1px";
  sr.style.height = "1px";
  sr.style.overflow = "hidden";
  sr.id = "game-of-the-day-status";
  container.appendChild(sr);

  const ctx = canvas.getContext("2d", { alpha: false });

  // -----------------------
  // Audio Initialization
  // -----------------------
  let audioCtx = null;
  let audioEnabled = true; // ability to play
  let bgOsc = null;
  let bgGain = null;

  function initAudio() {
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) {
        throw new Error("Web Audio API not supported");
      }
      audioCtx = new AC();
      // Create gentle background hum
      bgOsc = audioCtx.createOscillator();
      bgOsc.type = "sine";
      bgOsc.frequency.value = 110; // low hum
      const lfo = audioCtx.createOscillator();
      lfo.type = "sine";
      lfo.frequency.value = 0.25; // slow wobble
      const lfoGain = audioCtx.createGain();
      lfoGain.gain.value = 6; // frequency modulation depth
      lfo.connect(lfoGain);
      lfoGain.connect(bgOsc.frequency);
      bgGain = audioCtx.createGain();
      bgGain.gain.value = 0.03; // quiet background
      bgOsc.connect(bgGain);
      bgGain.connect(audioCtx.destination);
      bgOsc.start();
      lfo.start();
      // start but keep low; can toggle via toggleAudio
      audioEnabled = true;
    } catch (err) {
      console.warn("Audio initialization failed:", err);
      audioCtx = null;
      audioEnabled = false;
    }
  }

  // Play a short blip when picking up energy
  function playPickup() {
    if (!audioEnabled || !audioCtx) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "triangle";
      o.frequency.value = 660;
      g.gain.value = 0.0001;
      o.connect(g);
      g.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      g.gain.cancelScheduledValues(now);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.08, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.28);
      o.start(now);
      o.stop(now + 0.3);
    } catch (err) {
      console.warn("playPickup error", err);
    }
  }

  // Play positive chime for correct sum
  function playSuccess() {
    if (!audioEnabled || !audioCtx) return;
    try {
      // Create two oscillators for pleasant harmony
      const o1 = audioCtx.createOscillator();
      const o2 = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o1.type = "sine";
      o2.type = "sine";
      o1.frequency.value = 660;
      o2.frequency.value = 880;
      o1.connect(g);
      o2.connect(g);
      g.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.12, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);
      o1.start(now);
      o2.start(now);
      o1.stop(now + 0.6);
      o2.stop(now + 0.6);
    } catch (err) {
      console.warn("playSuccess error", err);
    }
  }

  // Play error buzz
  function playError() {
    if (!audioEnabled || !audioCtx) return;
    try {
      const o = audioCtx.createOscillator();
      const f = audioCtx.createBiquadFilter();
      const g = audioCtx.createGain();
      o.type = "square";
      o.frequency.value = 220;
      f.type = "lowpass";
      f.frequency.value = 800;
      o.connect(f);
      f.connect(g);
      g.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.1, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);
      o.start(now);
      o.stop(now + 0.35);
    } catch (err) {
      console.warn("playError error", err);
    }
  }

  function setBackgroundVolume(vol) {
    if (!bgGain) return;
    try {
      bgGain.gain.setValueAtTime(vol, audioCtx.currentTime);
    } catch (err) {
      console.warn("setBackgroundVolume error", err);
    }
  }

  function toggleAudio() {
    if (!audioCtx) {
      // try to initialize if not yet available
      initAudio();
      if (!audioCtx) {
        audioEnabled = false;
        announce("Audio not available on this device");
        return;
      }
    }
    if (audioCtx.state === "suspended") {
      audioCtx.resume().catch((e) => console.warn(e));
    }
    audioEnabled = !audioEnabled;
    setBackgroundVolume(audioEnabled ? 0.03 : 0.0);
    announce(audioEnabled ? "Audio turned on" : "Audio turned off");
  }

  // -----------------------
  // Game Objects & State
  // -----------------------
  const keys = {};
  const pointer = { x: 0, y: 0, down: false };

  // Sparkie (player)
  const player = {
    x: WIDTH / 2,
    y: HEIGHT - 80,
    r: 18,
    color1: "#FFD66B",
    color2: "#FFAA00",
    vx: 0,
    vy: 0,
    speed: 160, // pixels per second
  };

  // Lamps (targets) - drawn as wacky lightbulbs with required target sum
  const lampCount = 3;
  let lamps = [];

  // Energy bits (collectible number pellets)
  let pellets = [];

  // Level and game flow
  let level = 1;
  let score = 0;
  let lives = 3;
  let gameState = "start"; // start, playing, levelComplete, gameOver
  let lastTime = null;

  // Timers
  let spawnTimer = 0;
  const spawnInterval = 1.0; // spawn pellet every second-ish

  // Accessibility announcer
  function announce(message) {
    try {
      sr.textContent = message;
    } catch (err) {
      console.warn("announce error", err);
    }
  }

  // -----------------------
  // Utility Functions
  // -----------------------
  function rand(min, max) {
    return Math.random() * (max - min) + min;
  }

  function randint(min, max) {
    return Math.floor(rand(min, max + 1));
  }

  // Create lamps based on level: targets increase slightly
  function resetLampsForLevel(lv) {
    lamps = [];
    const padding = 40;
    const spacing = (WIDTH - padding * 2) / (lampCount - 1);
    for (let i = 0; i < lampCount; i++) {
      const targetBase = 6 + lv * 2; // base grows with level
      const target = randint(targetBase, targetBase + 6);
      lamps.push({
        x: padding + spacing * i,
        y: 90,
        r: 44,
        target: target,
        sum: 0,
        lit: false,
        wobble: Math.random() * Math.PI * 2,
      });
    }
  }

  // Reset pellets for start of level
  function resetPellets() {
    pellets = [];
    // Prepopulate some pellets
    for (let i = 0; i < 6; i++) spawnPellet();
  }

  // Spawn pellet with a number that makes sense for current lamps: values 1..9
  function spawnPellet() {
    // Avoid too many pellets
    if (pellets.length > 14) return;
    const n = randint(1, Math.min(9, 2 + level * 3));
    const p = {
      x: rand(40, WIDTH - 40),
      y: rand(160, HEIGHT - 120),
      r: 14,
      value: n,
      vx: rand(-20, 20),
      vy: rand(-10, 10),
      wobble: Math.random() * Math.PI * 2,
    };
    pellets.push(p);
  }

  // Initialize level
  function startLevel(lv) {
    level = lv;
    resetLampsForLevel(level);
    resetPellets();
    spawnTimer = 0;
    gameState = "playing";
    announce(`Level ${level}. Help Sparkie light up ${lampCount} lamps by collecting numbers that add to each lamp's target.`);
  }

  function restartGame() {
    level = 1;
    score = 0;
    lives = 3;
    player.x = WIDTH / 2;
    player.y = HEIGHT - 80;
    startLevel(level);
  }

  // -----------------------
  // Collision Helpers
  // -----------------------
  function circleCollision(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    const r = a.r + b.r;
    return dx * dx + dy * dy <= r * r;
  }

  // -----------------------
  // Input Handling
  // -----------------------
  window.addEventListener("keydown", (e) => {
    keys[e.key] = true;
    if (e.key === " " || e.code === "Space") {
      e.preventDefault();
    }
    // Start audio on first key press if available but suspended
    if (audioCtx && audioCtx.state === "suspended") {
      audioCtx.resume().catch((err) => console.warn("audio resume failed", err));
    }
    // Space toggles audio
    if (e.key === " ") {
      toggleAudio();
    }
    // Enter to start or restart
    if (e.key === "Enter") {
      if (gameState === "start" || gameState === "levelComplete" || gameState === "gameOver") {
        restartGame();
      }
    }
  });
  window.addEventListener("keyup", (e) => {
    keys[e.key] = false;
  });

  // Mouse for pointer and click-to-toggle
  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    pointer.x = (e.clientX - rect.left) * (canvas.width / rect.width);
    pointer.y = (e.clientY - rect.top) * (canvas.height / rect.height);
  });
  canvas.addEventListener(
    "mousedown",
    (e) => {
      pointer.down = true;
      // Clicking speaker area toggles audio
      const sx = WIDTH - 52;
      const sy = 12;
      if (pointer.x >= sx && pointer.x <= sx + 40 && pointer.y >= sy && pointer.y <= sy + 40) {
        toggleAudio();
      }
      // Clicking on start or restart areas
      if (gameState === "start" || gameState === "levelComplete" || gameState === "gameOver") {
        // Entire canvas click considered as start
        restartGame();
      }
    },
    false
  );
  canvas.addEventListener("mouseup", () => {
    pointer.down = false;
  });

  // Touch support
  canvas.addEventListener(
    "touchstart",
    (e) => {
      const rect = canvas.getBoundingClientRect();
      const t = e.touches[0];
      pointer.x = (t.clientX - rect.left) * (canvas.width / rect.width);
      pointer.y = (t.clientY - rect.top) * (canvas.height / rect.height);
      pointer.down = true;
      e.preventDefault();
      if (audioCtx && audioCtx.state === "suspended") {
        audioCtx.resume().catch((err) => console.warn("audio resume failed", err));
      }
    },
    { passive: false }
  );
  canvas.addEventListener(
    "touchmove",
    (e) => {
      const rect = canvas.getBoundingClientRect();
      const t = e.touches[0];
      pointer.x = (t.clientX - rect.left) * (canvas.width / rect.width);
      pointer.y = (t.clientY - rect.top) * (canvas.height / rect.height);
      e.preventDefault();
    },
    { passive: false }
  );
  canvas.addEventListener(
    "touchend",
    (e) => {
      pointer.down = false;
      e.preventDefault();
    },
    { passive: false }
  );

  // -----------------------
  // Drawing Helpers
  // -----------------------
  function drawRoundedRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  function drawBackground() {
    // Soft gradient sky
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, "#eaf6ff");
    g.addColorStop(1, "#f5fbff");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Floating capacitors and whimsical wires
    for (let i = 0; i < 7; i++) {
      const sx = ((i * 137) % WIDTH) + (Math.sin(performance.now() / 2000 + i) + 1) * 8;
      ctx.save();
      ctx.globalAlpha = 0.15;
      ctx.fillStyle = "#bfe9ff";
      ctx.beginPath();
      ctx.ellipse(sx, 40 + (i % 3) * 20, 60 - (i % 4) * 6, 12, Math.PI / 8, 0, 2 * Math.PI);
      ctx.fill();
      ctx.restore();
    }

    // Ground strip
    ctx.fillStyle = "#e8f7ee";
    ctx.fillRect(0, HEIGHT - 100, WIDTH, 100);

    // Wacky power pole on left
    ctx.save();
    ctx.translate(48, HEIGHT - 120);
    ctx.fillStyle = "#6b4a2a";
    drawRoundedRect(ctx, -12, -40, 24, 120, 6);
    ctx.fillStyle = "#ffeed2";
    ctx.beginPath();
    ctx.arc(0, -24, 28, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#ffecb3";
    ctx.fillRect(-18, -14, 36, 18);
    ctx.restore();
  }

  function drawLamp(l) {
    ctx.save();
    ctx.translate(l.x, l.y);
    // Wobble
    l.wobble += 0.02;
    const wob = Math.sin(l.wobble) * 4;
    // Lamp glass
    const grad = ctx.createRadialGradient(-12, -10, 8, 0, 0, 60);
    grad.addColorStop(0, l.lit ? "#fff7b0" : "#ffffff");
    grad.addColorStop(1, l.lit ? "#fff67a" : "#dceeff");
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.ellipse(wob, 0, l.r, l.r * 1.15, 0, 0, Math.PI * 2);
    ctx.fill();
    // Filament and base
    ctx.fillStyle = l.lit ? "#ffb703" : "#7b7b7b";
    ctx.fillRect(-18, 30, 36, 14);
    // Tiny circuit bolts
    ctx.strokeStyle = "#ffea85";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-10, 4);
    ctx.lineTo(-2, 10);
    ctx.lineTo(-6, 10);
    ctx.lineTo(2, 18);
    ctx.stroke();
    // Display text: target and current sum
    ctx.fillStyle = "#333";
    ctx.font = "600 16px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(`Target: ${l.target}`, 0, -l.r - 12);
    ctx.fillStyle = l.lit ? "#006400" : "#1a3d6a";
    ctx.font = "700 20px serif";
    ctx.fillText(`${l.sum}`, 0, 6);
    ctx.restore();
  }

  function drawPellet(p) {
    ctx.save();
    ctx.translate(p.x, p.y);
    p.wobble += 0.08;
    const shift = Math.sin(p.wobble) * 3;
    // Outer ring
    ctx.beginPath();
    ctx.fillStyle = "#fff";
    ctx.arc(0 + shift, 0, p.r + 3, 0, Math.PI * 2);
    ctx.fill();
    // Inner gradient
    const grad = ctx.createLinearGradient(-p.r, -p.r, p.r, p.r);
    grad.addColorStop(0, "#ffdede");
    grad.addColorStop(1, "#ff8c8c");
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(0 + shift, 0, p.r, 0, Math.PI * 2);
    ctx.fill();
    // Number
    ctx.fillStyle = "#3a0b0b";
    ctx.font = "700 14px sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(p.value.toString(), shift, 0);
    ctx.restore();
  }

  function drawPlayer(pl) {
    ctx.save();
    ctx.translate(pl.x, pl.y);
    // glow and trail
    const glow = ctx.createRadialGradient(0, 0, 4, 0, 0, 36);
    glow.addColorStop(0, "#fff7d6");
    glow.addColorStop(1, "rgba(255,170,0,0)");
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(0, 0, 36, 0, Math.PI * 2);
    ctx.fill();

    // spark body
    ctx.beginPath();
    ctx.fillStyle = pl.color1;
    ctx.arc(0, 0, pl.r, 0, Math.PI * 2);
    ctx.fill();

    // eyes
    ctx.fillStyle = "#222";
    ctx.beginPath();
    ctx.ellipse(-6, -4, 4, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(6, -3, 4, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    // smile
    ctx.strokeStyle = "#6b3b00";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 4, 8, 0.1 * Math.PI, 0.9 * Math.PI);
    ctx.stroke();

    // little electric tail
    ctx.strokeStyle = "#ffd66b";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-pl.r - 2, 2);
    ctx.lineTo(-pl.r - 12, 6);
    ctx.lineTo(-pl.r - 6, 12);
    ctx.stroke();
    ctx.restore();
  }

  function drawHUD() {
    // Top bar
    ctx.save();
    ctx.fillStyle = "rgba(10,10,10,0.04)";
    ctx.fillRect(0, 0, WIDTH, 54);
    ctx.fillStyle = "#123";
    ctx.font = "700 18px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText(`Score: ${score}`, 12, 26);
    ctx.fillText(`Level: ${level}`, 160, 26);
    ctx.fillText(`Lives: ${lives}`, 260, 26);
    // Audio icon
    const sx = WIDTH - 52;
    const sy = 12;
    ctx.fillStyle = audioEnabled ? "#ffd66b" : "#cfcfcf";
    ctx.fillRect(sx, sy, 40, 36);
    ctx.fillStyle = "#3a3a3a";
    ctx.font = "600 12px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(audioEnabled ? "SOUND ON" : "SOUND OFF", sx + 20, sy + 22);
    ctx.restore();
  }

  // Instruction overlay on start screen
  function drawStartScreen() {
    ctx.save();
    ctx.fillStyle = "rgba(10,20,40,0.6)";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";
    ctx.font = "800 28px sans-serif";
    ctx.fillText("Power-Up Circuit", WIDTH / 2, 120);
    ctx.font = "600 18px sans-serif";
    ctx.fillText("Help Sparkie light the lamps by collecting energy bits (numbers).", WIDTH / 2, 160);
    ctx.fillText("Use arrow keys or WASD to move. Space toggles audio. Click or press Enter to start.", WIDTH / 2, 190);
    ctx.fillStyle = "#ffd66b";
    ctx.beginPath();
    ctx.ellipse(WIDTH / 2, 300, 70, 70, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#222";
    ctx.font = "700 22px sans-serif";
    ctx.fillText("Click to Start", WIDTH / 2, 308);
    ctx.restore();
  }

  function drawLevelComplete() {
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.45)";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";
    ctx.font = "800 28px sans-serif";
    ctx.fillText("All lamps powered!", WIDTH / 2, 160);
    ctx.font = "700 20px sans-serif";
    ctx.fillText(`Level ${level} complete. Score: ${score}`, WIDTH / 2, 200);
    ctx.font = "600 16px sans-serif";
    ctx.fillText("Click or press Enter to continue to the next challenge.", WIDTH / 2, 260);
    ctx.restore();
  }

  function drawGameOver() {
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";
    ctx.font = "800 30px sans-serif";
    ctx.fillText("Oh no! Power outage!", WIDTH / 2, 160);
    ctx.font = "700 22px sans-serif";
    ctx.fillText(`Final Score: ${score}`, WIDTH / 2, 210);
    ctx.font = "600 16px sans-serif";
    ctx.fillText("Click or press Enter to try again and power up the town!", WIDTH / 2, 260);
    ctx.restore();
  }

  // -----------------------
  // Gameplay Logic
  // -----------------------
  function update(dt) {
    if (gameState !== "playing") return;

    // Player movement via keyboard
    let vx = 0,
      vy = 0;
    if (keys["ArrowLeft"] || keys["a"] || keys["A"]) vx -= 1;
    if (keys["ArrowRight"] || keys["d"] || keys["D"]) vx += 1;
    if (keys["ArrowUp"] || keys["w"] || keys["W"]) vy -= 1;
    if (keys["ArrowDown"] || keys["s"] || keys["S"]) vy += 1;
    const len = Math.hypot(vx, vy);
    if (len > 0) {
      vx = (vx / len) * player.speed;
      vy = (vy / len) * player.speed;
    }
    // Pointer control (mouse) nudges player
    if (pointer.down) {
      // Move player toward pointer slowly for touch control
      const dx = pointer.x - player.x;
      const dy = pointer.y - player.y;
      vx += dx * 1.4;
      vy += dy * 1.4;
    }
    player.x += vx * dt;
    player.y += vy * dt;
    // Boundaries
    player.x = Math.max(22, Math.min(WIDTH - 22, player.x));
    player.y = Math.max(120, Math.min(HEIGHT - 24, player.y));

    // Pellets move slightly
    for (const p of pellets) {
      // gentle drift
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      // keep inside
      if (p.x < 24 || p.x > WIDTH - 24) p.vx *= -1;
      if (p.y < 140 || p.y > HEIGHT - 40) p.vy *= -1;
      // slight damping
      p.vx *= 0.995;
      p.vy *= 0.995;
    }

    // Spawn new pellets occasionally
    spawnTimer += dt;
    if (spawnTimer >= spawnInterval) {
      spawnTimer = 0;
      if (Math.random() < 0.85) spawnPellet();
    }

    // Collision with pellets
    for (let i = pellets.length - 1; i >= 0; i--) {
      const p = pellets[i];
      if (circleCollision(player, { x: p.x, y: p.y, r: p.r })) {
        // Collect pellet
        playPickup();
        // Which lamp to assign to? We'll assign to the nearest unlit lamp.
        const unlit = lamps.filter((l) => !l.lit);
        if (unlit.length === 0) {
          // Nothing to assign to, small score
          score += p.value;
          announce(`Collected ${p.value} energy. No lamps need energy right now.`);
        } else {
          // find nearest unlit lamp
          let nearest = unlit[0];
          let best = Infinity;
          for (const l of unlit) {
            const d = (l.x - player.x) ** 2 + (l.y - player.y) ** 2;
            if (d < best) {
              best = d;
              nearest = l;
            }
          }
          nearest.sum += p.value;
          // Announce
          announce(`Delivered ${p.value} energy to a lamp. Lamp at ${nearest.x} now has ${nearest.sum}.`);
          // Check success or overload
          if (nearest.sum === nearest.target) {
            nearest.lit = true;
            score += nearest.target * 2;
            playSuccess();
            announce(`Bingo! Lamp reached target ${nearest.target} and lit up!`);
          } else if (nearest.sum > nearest.target) {
            // Overload
            playError();
            lives -= 1;
            // visual penalty: reduce sum partially
            nearest.sum = Math.max(0, Math.floor(nearest.sum / 2));
            announce(`Oops! Lamp overloaded. Lives left: ${lives}. The lamp's energy decreased to ${nearest.sum}.`);
            if (lives <= 0) {
              gameState = "gameOver";
              announce("Game over. Try again to help Sparkie power the town.");
            }
          } else {
            // partial success
            // small score for contributing
            score += p.value;
          }
        }
        pellets.splice(i, 1);
      }
    }

    // Check if all lamps are lit
    if (lamps.every((l) => l.lit)) {
      gameState = "levelComplete";
      level += 1;
      // Award bonus
      score += 50;
      playSuccess();
      announce(`Level complete! You powered all lamps. Score ${score}. Click or press Enter to continue.`);
    }
  }

  // -----------------------
  // Main Loop
  // -----------------------
  function loop(ts) {
    if (!lastTime) lastTime = ts;
    const dt = Math.min(0.05, (ts - lastTime) / 1000);
    lastTime = ts;

    // Clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Update based on state
    if (gameState === "start") {
      // Gentle animated background
      drawBackground();
      drawPlayer(player);
      drawHUD();
      drawStartScreen();
    } else if (gameState === "playing") {
      update(dt);
      drawBackground();
      // Draw lamps
      for (const l of lamps) drawLamp(l);
      // Draw pellets
      for (const p of pellets) drawPellet(p);
      // Draw player
      drawPlayer(player);
      drawHUD();
      // Little instruction hint
      ctx.fillStyle = "rgba(0,0,0,0.06)";
      ctx.fillRect(8, HEIGHT - 84, WIDTH - 16, 72);
      ctx.fillStyle = "#123";
      ctx.font = "600 14px sans-serif";
      ctx.textAlign = "left";
      ctx.fillText("Collect numbers and deliver them to lamps to match their target sums. Avoid overloads.", 14, HEIGHT - 54);
    } else if (gameState === "levelComplete") {
      drawBackground();
      for (const l of lamps) drawLamp(l);
      for (const p of pellets) drawPellet(p);
      drawPlayer(player);
      drawHUD();
      drawLevelComplete();
    } else if (gameState === "gameOver") {
      drawBackground();
      for (const l of lamps) drawLamp(l);
      drawHUD();
      drawGameOver();
    }

    // Draw small audio indicator (visual cue for audio state)
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = audioEnabled ? "#d9f7a6" : "#f0d6d6";
    const sx = WIDTH - 76;
    const sy = 8;
    drawRoundedRect(ctx, sx, sy, 62, 36, 6);
    ctx.fillStyle = "#222";
    ctx.font = "600 12px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(audioEnabled ? "Audio: On" : "Audio: Off", sx + 31, sy + 22);
    ctx.restore();

    requestAnimationFrame(loop);
  }

  // -----------------------
  // Initialization
  // -----------------------
  function init() {
    // Try initializing audio but handle errors gracefully
    try {
      initAudio();
      if (!audioCtx) {
        announce("Audio is not available. You can still play the game with visual feedback.");
      } else {
        // ensure background volume based on audioEnabled
        setBackgroundVolume(audioEnabled ? 0.03 : 0.0);
      }
    } catch (err) {
      console.warn("Audio init error", err);
    }

    // set initial positions for lamps and pellets
    resetLampsForLevel(1);
    resetPellets();

    // show start screen
    gameState = "start";
    announce("Welcome to Power-Up Circuit! Press Enter or click to start. Use arrow keys or WASD to move Sparkie and collect numbers for lamps.");

    // Kick off loop
    requestAnimationFrame(loop);
  }

  // Start
  init();

  // Expose some debug functions on the canvas element for testing in dev console
  canvas.gameDebug = {
    restart: restartGame,
    toggleAudio: toggleAudio,
    getState: () => ({ level, score, lives, gameState, lamps, pellets }),
  };
})();
---

