# Game of the Day - 2025-09-19

## Metadata
- **Generated Date:** 2025-09-19
- **Generated Time:** 2025-09-19T00:26:00.046004
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-19.js
- **File Size:** 23327 bytes
- **Tokens Used:** 7655

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-19.js` - The playable game
- `2025-09-19.meta.json` - Machine-readable metadata
- `2025-09-19.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 16309

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 17624

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Machine Math: A calming, wacky educational game for ages 7-9
// Renders inside element with id "game-of-the-day-stage"
// Uses Canvas and Web Audio API only. No external resources.
// Accessible keyboard controls and visual/audio feedback included.

// Immediately invoked to avoid polluting global scope
(function () {
  // Find the stage element and create canvas
  const stage = document.getElementById('game-of-the-day-stage');
  if (!stage) {
    console.error('Game stage element with id "game-of-the-day-stage" not found.');
    return;
  }
  // Clear stage and create canvas
  stage.innerHTML = '';
  const canvas = document.createElement('canvas');
  canvas.width = 720;
  canvas.height = 480;
  canvas.style.width = '720px';
  canvas.style.height = '480px';
  canvas.setAttribute('tabindex', '0'); // make focusable for keyboard controls
  canvas.setAttribute('role', 'img');
  canvas.setAttribute('aria-label', 'Machine Math game. Use mouse or keys 1-5 to select gears, Enter to submit, Space to toggle audio.');
  stage.appendChild(canvas);

  const ctx = canvas.getContext('2d');

  // Utility: clamp
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  // Audio setup with error handling
  let audioSupported = true;
  let audioEnabled = false; // user must enable audio (gesture) for most browsers
  let audioContext = null;
  let masterGain = null;
  let bgGain = null;
  let bgOsc = null;
  try {
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if (!AudioCtx) {
      audioSupported = false;
      console.warn('Web Audio API not supported in this browser.');
    } else {
      audioContext = new AudioCtx();
      masterGain = audioContext.createGain();
      masterGain.gain.value = 0.9;
      masterGain.connect(audioContext.destination);

      // gentle background hum (starts silent until enabled)
      bgGain = audioContext.createGain();
      bgGain.gain.value = 0.0;
      bgOsc = audioContext.createOscillator();
      bgOsc.type = 'sine';
      bgOsc.frequency.value = 110; // low calming hum
      const bgFilter = audioContext.createBiquadFilter();
      bgFilter.type = 'lowpass';
      bgFilter.frequency.value = 400;
      bgOsc.connect(bgFilter);
      bgFilter.connect(bgGain);
      bgGain.connect(masterGain);
      try {
        bgOsc.start();
      } catch (e) {
        // some browsers require start later; handle gracefully
        setTimeout(() => {
          try { bgOsc.start(); } catch (e2) {}
        }, 100);
      }
    }
  } catch (err) {
    audioSupported = false;
    console.error('Error creating AudioContext:', err);
  }

  function enableAudioOnGesture() {
    if (!audioSupported || audioEnabled) return;
    // resume context on user gesture
    if (audioContext && audioContext.state === 'suspended') {
      audioContext.resume().then(() => {
        audioEnabled = true;
        if (bgGain) bgGain.gain.linearRampToValueAtTime(0.06, audioContext.currentTime + 0.5);
        draw(); // update visuals
      }).catch((e) => {
        console.warn('AudioContext resume failed:', e);
      });
    } else {
      audioEnabled = true;
      if (bgGain) bgGain.gain.value = 0.06;
    }
  }

  // Sound generators with safety checks
  function playTone(freq, duration = 0.4, type = 'sine', volume = 0.12) {
    if (!audioSupported || !audioContext || !audioEnabled) return;
    try {
      const t0 = audioContext.currentTime;
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      gain.gain.value = volume;
      const filter = audioContext.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = Math.max(300, freq * 2);
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);
      osc.start(t0);
      gain.gain.setValueAtTime(volume, t0);
      gain.gain.exponentialRampToValueAtTime(0.0001, t0 + duration);
      osc.stop(t0 + duration + 0.02);
    } catch (e) {
      console.warn('playTone error:', e);
    }
  }

  function playChime() {
    // pleasant chord
    if (!audioSupported || !audioContext || !audioEnabled) return;
    try {
      const base = 440;
      playTone(base, 0.25, 'sine', 0.09);
      setTimeout(() => playTone(base * 1.5, 0.35, 'sine', 0.08), 50);
      setTimeout(() => playTone(base * 2, 0.4, 'triangle', 0.06), 110);
    } catch (e) {
      console.warn('playChime error:', e);
    }
  }

  function playBuzz() {
    if (!audioSupported || !audioContext || !audioEnabled) return;
    try {
      const t0 = audioContext.currentTime;
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      osc.type = 'square';
      osc.frequency.value = 120;
      gain.gain.value = 0.16;
      const filter = audioContext.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 800;
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);
      osc.start(t0);
      gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.25);
      osc.stop(t0 + 0.26);
    } catch (e) {
      console.warn('playBuzz error:', e);
    }
  }

  // Game state and logic
  const game = {
    round: 1,
    maxRounds: 6,
    target: 0,
    availableGears: [], // {value, x, y, radius, id}
    selected: [], // ids
    solvedCount: 0,
    level: 1,
    message: '',
    messageTimer: 0,
    soundOn: audioSupported && audioEnabled,
    running: true, // allow input
  };

  // Generate solvable gear set: guarantee at least one combination equals target
  function generateRound(roundNum) {
    game.selected = [];
    game.message = '';
    game.messageTimer = 0;
    const difficulty = clamp(roundNum, 1, 6);
    // target between 5 and 15 increasing with difficulty
    const minTarget = 5 + Math.floor((difficulty - 1) * 1.5);
    const maxTarget = 10 + difficulty * 1;
    const target = Math.floor(Math.random() * (maxTarget - minTarget + 1)) + minTarget;

    // Pick a base solution of 2 or 3 numbers
    const numPieces = Math.random() < 0.6 ? 2 : 3;
    const pieces = [];
    let remaining = target;
    for (let i = 0; i < numPieces - 1; i++) {
      // pick random 1..(remaining - (numPieces - i - 1))
      const maxPick = Math.max(1, remaining - (numPieces - i - 1));
      const pick = Math.floor(Math.random() * Math.min(9, maxPick)) + 1;
      pieces.push(pick);
      remaining -= pick;
    }
    pieces.push(remaining); // last piece

    // Now create extra filler gears so total count is 5
    const totalGears = 5;
    const gears = pieces.slice();
    while (gears.length < totalGears) {
      // make a filler not accidentally solve the target alone
      let val;
      do {
        val = Math.floor(Math.random() * 9) + 1;
      } while (gears.includes(val) && Math.random() > 0.6);
      gears.push(val);
    }
    // shuffle gears
    for (let i = gears.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [gears[i], gears[j]] = [gears[j], gears[i]];
    }
    // place gears visually
    const gearObjs = [];
    const startX = 120;
    const startY = 250;
    const spacing = 110;
    for (let i = 0; i < gears.length; i++) {
      const gx = startX + i * spacing;
      const gy = startY + ((i % 2) * 14 - 7); // slight wobble
      gearObjs.push({
        value: gears[i],
        x: gx,
        y: gy,
        radius: 36,
        id: 'g' + Date.now() + '_' + i,
      });
    }

    game.target = target;
    game.availableGears = gearObjs;
    game.level = difficulty;
  }

  // Start first round
  generateRound(game.round);

  // Helper: sum of selected
  function currentSum() {
    return game.selected.reduce((s, id) => {
      const g = game.availableGears.find(gg => gg.id === id);
      return s + (g ? g.value : 0);
    }, 0);
  }

  // Attempt submission
  function submitSelection() {
    if (!game.running) return;
    const sum = currentSum();
    if (sum === game.target) {
      game.solvedCount++;
      game.message = 'Nice! Machine hums happily!';
      game.messageTimer = Date.now();
      playChime();
      // Visual: animate little confetti wacky bits
      // Prepare next round or win
      if (game.round >= game.maxRounds) {
        game.running = false;
        setTimeout(() => showVictory(), 800);
      } else {
        // advance round after short delay
        setTimeout(() => {
          game.round++;
          generateRound(game.round);
        }, 900);
      }
    } else {
      game.message = 'Not right yet! Check the sum.';
      game.messageTimer = Date.now();
      playBuzz();
      // Negative feedback: keep playing
    }
  }

  function showVictory() {
    game.message = 'You fixed all the machines! You win!';
    game.messageTimer = Date.now();
    playChime();
  }

  // UI interactions
  function toggleGearSelection(id) {
    if (!game.running) return;
    const idx = game.selected.indexOf(id);
    if (idx >= 0) {
      game.selected.splice(idx, 1);
    } else {
      // limit selection to 3 pieces to keep simple
      if (game.selected.length >= 3) {
        game.message = 'Too many gears! Try fewer pieces.';
        game.messageTimer = Date.now();
        playBuzz();
        return;
      } else {
        game.selected.push(id);
      }
    }
    // small click sound
    playTone(660, 0.08, 'square', 0.04);
  }

  // Reset / New game
  function resetGame() {
    game.round = 1;
    game.solvedCount = 0;
    game.running = true;
    generateRound(game.round);
  }

  // Mouse handling
  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    const my = (e.clientY - rect.top) * (canvas.height / rect.height);

    // Check for: start/resume audio button (top-right), speaker icon
    if (mx > 640 && mx < 716 && my > 12 && my < 48) {
      // toggle audio
      if (!audioSupported) {
        game.message = 'Audio not supported in your browser.';
        game.messageTimer = Date.now();
      } else {
        if (!audioEnabled) {
          enableAudioOnGesture();
          game.message = 'Audio enabled.';
          game.messageTimer = Date.now();
          game.soundOn = true;
        } else {
          // toggle mute
          game.soundOn = !game.soundOn;
          if (masterGain) masterGain.gain.value = game.soundOn ? 0.9 : 0.0;
          game.message = game.soundOn ? 'Sound on' : 'Sound off';
          game.messageTimer = Date.now();
        }
      }
      return;
    }

    // Check for submit button area
    if (mx > 540 && mx < 700 && my > 360 && my < 440) {
      submitSelection();
      return;
    }

    // Restart button on victory area
    if (!game.running && mx > 300 && mx < 420 && my > 300 && my < 340) {
      resetGame();
      playTone(520, 0.12, 'sine', 0.08);
      return;
    }

    // Check gears
    for (let g of game.availableGears) {
      const dx = mx - g.x;
      const dy = my - g.y;
      if (dx * dx + dy * dy <= g.radius * g.radius) {
        toggleGearSelection(g.id);
        return;
      }
    }
  });

  // Keyboard controls
  canvas.addEventListener('keydown', (e) => {
    // Allow space to enable/resume audio
    if (e.code === 'Space') {
      e.preventDefault();
      if (!audioSupported) {
        game.message = 'Audio not supported.';
        game.messageTimer = Date.now();
      } else {
        if (!audioEnabled) {
          enableAudioOnGesture();
          game.message = 'Audio enabled.';
          game.messageTimer = Date.now();
          game.soundOn = true;
        } else {
          game.soundOn = !game.soundOn;
          if (masterGain) masterGain.gain.value = game.soundOn ? 0.9 : 0.0;
          game.message = game.soundOn ? 'Sound on' : 'Sound off';
          game.messageTimer = Date.now();
        }
      }
      return;
    }

    // Numbers 1-5 select corresponding gears
    if (/Digit[1-5]/.test(e.code) || /Numpad[1-5]/.test(e.code)) {
      e.preventDefault();
      const num = parseInt(e.key, 10);
      if (!isNaN(num) && game.availableGears[num - 1]) {
        toggleGearSelection(game.availableGears[num - 1].id);
      }
      return;
    }
    // Enter to submit
    if (e.code === 'Enter') {
      e.preventDefault();
      submitSelection();
      return;
    }
    // R to restart
    if (e.code === 'KeyR') {
      e.preventDefault();
      resetGame();
    }
  });

  // Pointer move: for hover effects
  let pointer = { x: -1, y: -1, over: null };
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    pointer.x = (e.clientX - rect.left) * (canvas.width / rect.width);
    pointer.y = (e.clientY - rect.top) * (canvas.height / rect.height);
    pointer.over = null;
    for (let i = 0; i < game.availableGears.length; i++) {
      const g = game.availableGears[i];
      const dx = pointer.x - g.x;
      const dy = pointer.y - g.y;
      if (dx * dx + dy * dy <= g.radius * g.radius) {
        pointer.over = i;
        break;
      }
    }
  });
  canvas.addEventListener('mouseleave', () => {
    pointer.x = -1; pointer.y = -1; pointer.over = null;
  });

  // Drawing helpers
  function drawRoundedRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  function drawGear(x, y, radius, teeth, angle, fillColor, strokeColor) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    // draw base circle
    ctx.beginPath();
    ctx.fillStyle = fillColor;
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 3;
    ctx.arc(0, 0, radius * 0.6, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // teeth
    for (let i = 0; i < teeth; i++) {
      const a = (i / teeth) * Math.PI * 2;
      const x1 = Math.cos(a) * radius * 0.7;
      const y1 = Math.sin(a) * radius * 0.7;
      const x2 = Math.cos(a) * radius;
      const y2 = Math.sin(a) * radius;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.lineWidth = 6;
      ctx.strokeStyle = strokeColor;
      ctx.stroke();
    }

    // center bolt
    ctx.beginPath();
    ctx.fillStyle = '#222';
    ctx.arc(0, 0, radius * 0.18, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  // Draw full scene
  function draw() {
    // background
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // calming gradient sky
    const grad = ctx.createLinearGradient(0, 0, 0, 480);
    grad.addColorStop(0, '#f7fbff');
    grad.addColorStop(1, '#eaf6f9');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 720, 480);

    // wavy ground
    ctx.beginPath();
    ctx.moveTo(0, 360);
    for (let x = 0; x <= 720; x += 10) {
      ctx.lineTo(x, 360 + Math.sin(x * 0.02) * 10 + 4 * Math.sin(Date.now() * 0.002 + x * 0.01));
    }
    ctx.lineTo(720, 480);
    ctx.lineTo(0, 480);
    ctx.closePath();
    ctx.fillStyle = '#dbeef2';
    ctx.fill();

    // Title
    ctx.fillStyle = '#103b48';
    ctx.font = '22px Comic Sans MS, Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Machine Math — Fix the Wacky Machines!', 18, 34);

    // Speaker / audio toggle icon (top-right)
    ctx.save();
    ctx.beginPath();
    ctx.fillStyle = audioSupported ? (audioEnabled && game.soundOn ? '#1a8f6b' : '#f0a500') : '#c0c0c0';
    ctx.strokeStyle = '#0b2b32';
    ctx.lineWidth = 2;
    ctx.roundRect = function (x, y, w, h, r) {
      this.moveTo(x + r, y);
      this.arcTo(x + w, y, x + w, y + h, r);
      this.arcTo(x + w, y + h, x, y + h, r);
      this.arcTo(x, y + h, x, y, r);
      this.arcTo(x, y, x + w, y, r);
    };
    ctx.beginPath();
    ctx.roundRect(640, 12, 74, 36, 8);
    ctx.fill();
    ctx.stroke();

    // speaker symbol
    ctx.fillStyle = '#052425';
    ctx.beginPath();
    ctx.moveTo(654, 30);
    ctx.lineTo(666, 22);
    ctx.lineTo(666, 38);
    ctx.closePath();
    ctx.fill();

    // sound waves
    ctx.beginPath();
    ctx.strokeStyle = '#052425';
    ctx.lineWidth = 2;
    if (audioSupported && audioEnabled && game.soundOn) {
      ctx.arc(676, 30, 8, -0.6, 0.6);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(686, 30, 12, -0.6, 0.6);
      ctx.stroke();
    } else {
      // muted cross
      ctx.moveTo(669, 20);
      ctx.lineTo(703, 40);
      ctx.moveTo(703, 20);
      ctx.lineTo(669, 40);
      ctx.stroke();
    }
    ctx.restore();

    // Draw machine body: a whimsical robot
    ctx.save();
    ctx.translate(120, 120);
    // body shadow
    ctx.fillStyle = 'rgba(0,0,0,0.06)';
    ctx.fillRect(-30, 60, 420, 160);
    // body
    ctx.beginPath();
    ctx.fillStyle = '#f7dfc6';
    ctx.strokeStyle = '#b5824d';
    ctx.lineWidth = 4;
    ctx.roundRect = function (x, y, w, h, r) {
      this.moveTo(x + r, y);
      this.arcTo(x + w, y, x + w, y + h, r);
      this.arcTo(x + w, y + h, x, y + h, r);
      this.arcTo(x, y + h, x, y, r);
      this.arcTo(x, y, x + w, y, r);
    };
    ctx.beginPath();
    ctx.roundRect(0, 0, 360, 200, 24);
    ctx.fill();
    ctx.stroke();

    // control screen
    ctx.fillStyle = '#e9f9ff';
    ctx.fillRect(20, 20, 250, 110);
    ctx.strokeStyle = '#89b4c1';
    ctx.strokeRect(20, 20, 250, 110);

    // cute dial
    ctx.beginPath();
    ctx.fillStyle = '#ffd3a3';
    ctx.arc(310, 60, 38, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    ctx.restore();

    // Display target number in machine screen
    ctx.fillStyle = '#02323a';
    ctx.font = '46px Comic Sans MS, Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Target: ' + game.target, 220, 90);

    // little instruction text
    ctx.fillStyle = '#05444f';
    ctx.font = '14px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Choose up to 3 gears so their numbers add to the target.', 18, 70);
    ctx.fillText('Click a gear or press keys 1-5 to pick. Press Enter to submit.', 18, 88);
    ctx.fillText('Rounds: ' + game.round + ' / ' + game.maxRounds + '   Solved: ' + game.solvedCount, 18, 106);

    // Draw gears (available)
    for (let i = 0; i < game.availableGears.length; i++) {
      const g = game.availableGears[i];
      // wobble gently to look wacky
      const wobble = Math.sin(Date.now() * 0.002 + i) * 0.08;
      const selected = game.selected.indexOf(g.id) >= 0;
      const hover = pointer.over === i;
      const baseColor = selected ? '#ffd27f' : '#fff';
      const strokeColor = selected ? '#c86e00' : '#4b6b72';
      // gear body
      drawGear(g.x, g.y - (selected ? 6 : 0), g.radius + (hover ? 4 : 0), 12 + (i % 3), wobble, baseColor, strokeColor);

      // number
      ctx.fillStyle = '#052425';
      ctx.font = selected ? 'bold 22px Arial' : 'bold 20px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(g.value, g.x, g.y + 6 - (selected ? 6 : 0));

      // label index (1-5)
      ctx.fillStyle = '#064851';
      ctx.font = '12px Arial';
      ctx.fillText((i + 1).toString(), g.x + g.radius - 10, g.y + g.radius - 6);
    }

    // Draw conveyor belt under gears
    ctx.fillStyle = '#d1e9ed';
    ctx.fillRect(40, 302, 640, 36);
    ctx.strokeStyle = '#b0cfd3';
    ctx.strokeRect(40, 302, 640, 36);

    // Submit button area drawn as big "Run Machine"
    ctx.save();
    ctx.beginPath();
    ctx.fillStyle = '#7fd3c6';
    ctx.strokeStyle = '#2b6e63';
    ctx.lineWidth = 3;
    drawRoundedRect(540, 360, 160, 80, 14);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = '#033c36';
    ctx.font = '22px Comic Sans MS, Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Run Machine', 620, 402);
    ctx.font = '14px Arial';
    ctx.fillText('Enter or Click', 620, 426);
    ctx.restore();

    // current sum display
    ctx.fillStyle = '#043b3f';
    ctx.font = '18px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Current Sum: ' + currentSum(), 18, 160);

    // visual meter: progress toward target
    const sum = currentSum();
    const ratio = clamp(sum / Math.max(1, game.target), 0, 1);
    ctx.fillStyle = '#d0f0e2';
    ctx.fillRect(18, 172, 300, 18);
    ctx.fillStyle = '#24a77a';
    ctx.fillRect(18, 172, 300 * ratio, 18);
    ctx.strokeStyle = '#0b2b28';
    ctx.strokeRect(18, 172, 300, 18);

    // message box
    if (game.message && Date.now() - game.messageTimer < 4000) {
      ctx.fillStyle = 'rgba(255,255,255,0.88)';
      ctx.strokeStyle = '#7aa8ad';
      ctx.lineWidth = 2;
      drawRoundedRect(360, 20, 340, 72, 12);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = '#063b3d';
      ctx.font = '16px Arial';
      ctx.textAlign = 'left';
      ctx.fillText(game.message, 376, 50);
    }

    // audio state hint
    ctx.fillStyle = '#05444f';
    ctx.font = '12px Arial';
    ctx.textAlign = 'left';
    if (!audioSupported) {
      ctx.fillText('Audio: not supported', 380, 130);
    } else {
      ctx.fillText('Audio: ' + (audioEnabled ? (game.soundOn ? 'on' : 'muted') : 'off (press Space or click speaker)'), 380, 130);
    }

    // If game finished, show celebration panel
    if (!game.running) {
      ctx.fillStyle = 'rgba(3,50,54,0.85)';
      ctx.fillRect(120, 220, 480, 170);
      ctx.fillStyle = '#fff';
      ctx.font = '28px Comic Sans MS, Arial';
      ctx.textAlign = 'center';
      ctx.fillText('All Machines Fixed!', 360, 270);
      ctx.font = '18px Arial';
      ctx.fillText('You helped the machines hum happily. Great job!', 360, 300);
      // restart button
      ctx.fillStyle = '#ffd27f';
      drawRoundedRect(300, 300, 120, 40, 10);
      ctx.fillStyle = '#052425';
      ctx.font = '16px Arial';
      ctx.fillText('Play Again', 360, 328);
    }

    // Accessibility text overlay for screen readers (update aria)
    canvas.setAttribute('aria-label', `Machine Math. Round ${game.round} of ${game.maxRounds}. Target ${game.target}. Current sum ${sum}. Use keys 1 to ${game.availableGears.length} to pick gear, Enter to run machine. Audio ${audioSupported ? (audioEnabled ? (game.soundOn ? 'on' : 'muted') : 'off') : 'not supported'}.`);

    // request next frame
    requestAnimationFrame(draw);
  }

  // Kick off animation
  draw();

  // Small visual indicator if audio context errors occurred
  if (!audioSupported) {
    game.message = 'Your browser does not support Web Audio. Sound disabled.';
    game.messageTimer = Date.now();
  } else {
    // If audio context exists but is suspended, instruct to press space
    if (audioContext && audioContext.state === 'suspended') {
      game.message = 'Press Space or click the speaker to enable sound.';
      game.messageTimer = Date.now();
    } else {
      // Audio may be running; set audioEnabled true by default in some browsers
      audioEnabled = audioContext ? audioContext.state === 'running' : false;
      game.soundOn = audioEnabled;
      if (audioEnabled && masterGain) masterGain.gain.value = 0.9;
    }
  }

  // Ensure canvas gets focus for keyboard controls
  setTimeout(() => {
    try { canvas.focus(); } catch (e) {}
  }, 200);

  // Provide a small tutorial modal on first load (drawn inside canvas as message)
  game.message = 'Welcome! Use keys 1-5 or click gears, press Enter to run. Fix all machines!';
  game.messageTimer = Date.now();
})();
---

