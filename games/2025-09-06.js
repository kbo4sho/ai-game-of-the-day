(function () {
  // Machine Math — Canvas Game for ages 7-9
  // Renders inside #game-of-the-day-stage, canvas size 720x480
  // Uses Web Audio API for sounds (created with oscillators and noise)
  // Enhanced visuals and audio (canvas + WebAudio only)
  // Author: Generated by assistant (improvements to visuals & audio)

  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const STAGE_ID = "game-of-the-day-stage";

  // Game parameters (unchanged)
  const TOTAL_LEVELS = 6;
  const GEAR_MIN = 1;
  const GEAR_MAX = 9;
  const MAX_GEARS = 6;
  const PLAYER_SPEED = 4;
  const PICK_RANGE = 40;

  // Colors and style (calming, slightly playful palette)
  const COLORS = {
    backgroundTop: "#EAF6F2",
    backgroundBottom: "#F8FFF9",
    panel: "#FFFFFF",
    machine: "#E5F3F0",
    accent: "#5FB3A8",
    accent2: "#F29494",
    text: "#20373A",
    gearFill: "#FFFFFF",
    gearStroke: "#B7DDD6",
    robotBody: "#FFDFA7",
    highlight: "#DFF7F1",
    wrong: "#F9D3D3",
    success: "#DFF3E7",
    shadow: "rgba(20,20,20,0.08)",
    silhouette: "rgba(95,179,168,0.06)",
  };

  // Utility: clamp
  function clamp(v, a, b) {
    return Math.max(a, Math.min(b, v));
  }

  // Get stage element
  const stage = document.getElementById(STAGE_ID);
  if (!stage) {
    console.error("Stage element with id '" + STAGE_ID + "' not found.");
    return;
  }

  // Clear stage and create canvas and accessibility region
  stage.innerHTML = "";
  stage.style.position = "relative";
  stage.style.width = WIDTH + "px";
  stage.style.height = HEIGHT + "px";

  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.display = "block";
  canvas.style.outline = "none";
  canvas.setAttribute("role", "application");
  canvas.setAttribute(
    "aria-label",
    "Machine Math game area. Use left and right arrows to move. Press space to pick up a gear. Press N for next level or R to restart."
  );
  canvas.tabIndex = 0; // make focusable for keyboard controls
  stage.appendChild(canvas);

  // Create a small visible audio control and an aria-live status region (for screen readers)
  const audioControl = document.createElement("button");
  audioControl.textContent = "Enable sound";
  audioControl.style.position = "absolute";
  audioControl.style.right = "8px";
  audioControl.style.top = "8px";
  audioControl.style.padding = "6px 10px";
  audioControl.style.borderRadius = "6px";
  audioControl.style.border = "none";
  audioControl.style.background = COLORS.accent;
  audioControl.style.color = COLORS.text;
  audioControl.style.fontWeight = "600";
  audioControl.style.cursor = "pointer";
  audioControl.title = "Click to allow sound (some browsers require a gesture)";
  stage.appendChild(audioControl);

  const statusRegion = document.createElement("div");
  statusRegion.setAttribute("aria-live", "polite"); // screen readers
  statusRegion.style.position = "absolute";
  statusRegion.style.left = "-9999px";
  statusRegion.style.width = "1px";
  statusRegion.style.height = "1px";
  statusRegion.style.overflow = "hidden";
  stage.appendChild(statusRegion);

  // Canvas context
  const ctx = canvas.getContext("2d");

  // Audio setup (improved)
  let audioContext = null;
  let masterGain = null;
  let backgroundNodes = []; // to hold oscillators/filters for background
  let audioAllowed = false;
  let audioInitialized = false;

  // Particle system for subtle visual feedback
  const particles = [];
  function emitParticles(x, y, color, count = 10, spread = 40) {
    for (let i = 0; i < count; i++) {
      particles.push({
        x: x + (Math.random() - 0.5) * spread,
        y: y + (Math.random() - 0.5) * spread * 0.6,
        vx: (Math.random() - 0.5) * 2.2,
        vy: -Math.random() * 2 - 0.5,
        life: 60 + Math.random() * 40,
        maxLife: 60 + Math.random() * 40,
        size: 2 + Math.random() * 2.5,
        color,
        spin: (Math.random() - 0.5) * 0.2,
      });
    }
  }

  // Improved audio initialization with robust error handling
  function initAudio() {
    if (audioInitialized) return;
    audioInitialized = true;
    try {
      const AudioCtor = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtor) {
        throw new Error("Web Audio API is not supported in this browser");
      }
      audioContext = new AudioCtor();
      masterGain = audioContext.createGain();
      masterGain.gain.value = 0.12; // gentle overall volume
      masterGain.connect(audioContext.destination);
      // Prepare a small noise buffer for clicks
      // (will be created lazily on first use)
    } catch (e) {
      audioContext = null;
      masterGain = null;
      console.warn("Audio not initialized:", e);
      statusRegion.textContent = "Audio not available.";
    }
  }

  // Create background ambience nodes (two oscillators + filter + gentle LFO)
  function startBackground() {
    if (!audioContext || !audioAllowed) return;
    // avoid creating duplicates
    if (backgroundNodes.length) return;
    try {
      const now = audioContext.currentTime;

      // low warm pad
      const oscA = audioContext.createOscillator();
      oscA.type = "sine";
      oscA.frequency.value = 65; // deep hum

      const oscAGain = audioContext.createGain();
      oscAGain.gain.value = 0.02;

      // higher gentle bell-ish
      const oscB = audioContext.createOscillator();
      oscB.type = "triangle";
      oscB.frequency.value = 220;

      const oscBGain = audioContext.createGain();
      oscBGain.gain.value = 0.01;

      // filter for character
      const lp = audioContext.createBiquadFilter();
      lp.type = "lowpass";
      lp.frequency.value = 900;

      // gentle tremolo LFO
      const lfo = audioContext.createOscillator();
      lfo.type = "sine";
      lfo.frequency.value = 0.15;
      const lfoGain = audioContext.createGain();
      lfoGain.gain.value = 0.01;

      // connect
      oscA.connect(lp);
      oscB.connect(lp);
      lp.connect(oscAGain);
      lp.connect(oscBGain);
      oscAGain.connect(masterGain);
      oscBGain.connect(masterGain);
      lfo.connect(lfoGain);
      lfoGain.connect(oscAGain.gain);
      lfoGain.connect(oscBGain.gain);

      // start
      try {
        oscA.start();
        oscB.start();
        lfo.start();
      } catch (e) {
        // some browsers can throw if already started; ignore
      }

      backgroundNodes.push({ osc: oscA });
      backgroundNodes.push({ osc: oscB });
      backgroundNodes.push({ lfo: lfo });
      // store filter/gains for smooth stop
      backgroundNodes.push({ lp, oscAGain, oscBGain });
    } catch (e) {
      console.warn("Failed to start background audio:", e);
    }
  }

  // Stop background with gentle fade
  function stopBackground() {
    if (!audioContext || !backgroundNodes.length) return;
    try {
      // fade master gain down
      const now = audioContext.currentTime;
      masterGain.gain.cancelScheduledValues(now);
      masterGain.gain.setValueAtTime(masterGain.gain.value, now);
      masterGain.gain.linearRampToValueAtTime(0.0001, now + 0.6);
      // stop individual oscillators after fade
      backgroundNodes.forEach((n) => {
        try {
          if (n.osc) n.osc.stop(now + 0.65);
          if (n.lfo) n.lfo.stop(now + 0.65);
        } catch (e) {
          // ignore
        }
      });
    } catch (e) {
      console.warn("Error stopping background:", e);
    } finally {
      backgroundNodes.length = 0;
      // restore master gain for future
      setTimeout(() => {
        try {
          if (masterGain) masterGain.gain.value = 0.12;
        } catch (e) {}
      }, 800);
    }
  }

  // Utility to create a short noise buffer for clicks
  let noiseBuffer = null;
  function ensureNoiseBuffer() {
    if (!audioContext) return null;
    if (noiseBuffer) return noiseBuffer;
    try {
      const sampleRate = audioContext.sampleRate;
      const buffer = audioContext.createBuffer(1, sampleRate * 1.0, sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < data.length; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (sampleRate * 0.2)); // decaying noise
      }
      noiseBuffer = buffer;
      return noiseBuffer;
    } catch (e) {
      console.warn("Noise buffer creation failed:", e);
      return null;
    }
  }

  // Play a pleasant mechanical chime for success (layered bell)
  function playSuccess(x = null, y = null) {
    if (!audioContext || !audioAllowed) return;
    try {
      const now = audioContext.currentTime;
      const freqs = [660, 880, 990];
      freqs.forEach((f, i) => {
        try {
          const o = audioContext.createOscillator();
          o.type = "sine";
          o.frequency.value = f;
          const g = audioContext.createGain();
          g.gain.value = 0.0001;
          // bright filter
          const hp = audioContext.createBiquadFilter();
          hp.type = "highpass";
          hp.frequency.value = 300;
          o.connect(hp);
          hp.connect(g);
          g.connect(masterGain);
          g.gain.setValueAtTime(0.0001, now + i * 0.08);
          g.gain.exponentialRampToValueAtTime(0.12, now + i * 0.08 + 0.03);
          g.gain.exponentialRampToValueAtTime(0.0001, now + i * 0.08 + 0.8);
          o.start(now + i * 0.08);
          o.stop(now + i * 0.08 + 1.0);
        } catch (e) {
          console.warn("Success tone creation error", e);
        }
      });
      // small sparkling noise
      const nb = ensureNoiseBuffer();
      if (nb) {
        const s = audioContext.createBufferSource();
        s.buffer = nb;
        const sg = audioContext.createGain();
        sg.gain.value = 0.08;
        s.connect(sg);
        sg.connect(masterGain);
        s.start(now);
        s.stop(now + 0.25);
      }
      // visual particles
      if (typeof x === "number" && typeof y === "number") {
        emitParticles(x, y - 10, COLORS.success, 28, 50);
      } else {
        emitParticles(WIDTH / 2, HEIGHT / 2 - 10, COLORS.success, 28, 60);
      }
    } catch (e) {
      console.warn("playSuccess error:", e);
    }
  }

  // Play a gentle pick sound (short metallic click + small particle)
  function playPick(x = null, y = null) {
    if (!audioContext || !audioAllowed) return;
    try {
      const now = audioContext.currentTime;
      // short metallic click using two oscillators detuned
      const o1 = audioContext.createOscillator();
      o1.type = "square";
      o1.frequency.value = 1200;
      const o2 = audioContext.createOscillator();
      o2.type = "sine";
      o2.frequency.value = 950;
      const g = audioContext.createGain();
      g.gain.value = 0.0001;

      // tiny bandpass for metallic character
      const bp = audioContext.createBiquadFilter();
      bp.type = "bandpass";
      bp.frequency.value = 1000;
      bp.Q.value = 5;

      o1.connect(bp);
      o2.connect(bp);
      bp.connect(g);
      g.connect(masterGain);

      g.gain.setValueAtTime(0.0001, now);
      g.gain.linearRampToValueAtTime(0.12, now + 0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.16);

      try {
        o1.start(now);
        o2.start(now);
        o1.stop(now + 0.18);
        o2.stop(now + 0.18);
      } catch (e) {
        // ignore start errors
      }

      // tiny click of noise layered
      const nb = ensureNoiseBuffer();
      if (nb) {
        const s = audioContext.createBufferSource();
        s.buffer = nb;
        const sg = audioContext.createGain();
        sg.gain.value = 0.06;
        const hf = audioContext.createBiquadFilter();
        hf.type = "highpass";
        hf.frequency.value = 1200;
        s.connect(hf);
        hf.connect(sg);
        sg.connect(masterGain);
        s.start(now);
        s.stop(now + 0.12);
      }

      // visual particles near pick position
      if (typeof x === "number" && typeof y === "number") {
        emitParticles(x, y - 8, COLORS.highlight, 10, 28);
      } else {
        emitParticles(WIDTH / 2, HEIGHT / 2, COLORS.highlight, 10, 28);
      }
    } catch (e) {
      console.warn("playPick error", e);
    }
  }

  // Play incorrect buzz (soft and short)
  function playIncorrect(x = null, y = null) {
    if (!audioContext || !audioAllowed) return;
    try {
      const now = audioContext.currentTime;
      const o = audioContext.createOscillator();
      o.type = "triangle";
      o.frequency.value = 260;
      const g = audioContext.createGain();
      g.gain.value = 0.0001;
      o.connect(g);
      g.connect(masterGain);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.linearRampToValueAtTime(0.09, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.22);
      try {
        o.start(now);
        o.frequency.exponentialRampToValueAtTime(140, now + 0.22);
        o.stop(now + 0.26);
      } catch (e) {}
      // faint red particle puff
      if (typeof x === "number" && typeof y === "number") {
        emitParticles(x, y - 6, COLORS.wrong, 12, 36);
      } else {
        emitParticles(player.x, player.y - 10, COLORS.wrong, 12, 36);
      }
    } catch (e) {
      console.warn("playIncorrect error", e);
    }
  }

  // Controls audio enable button
  audioControl.addEventListener("click", function () {
    initAudio();
    if (!audioContext) {
      audioControl.textContent = "Audio unavailable";
      audioControl.disabled = true;
      statusRegion.textContent = "Audio is not available in this browser.";
      return;
    }
    // resume audio context if suspended (some browsers require user gesture)
    audioContext
      .resume()
      .then(() => {
        audioAllowed = true;
        startBackground();
        audioControl.textContent = "Sound on";
        audioControl.style.background = COLORS.accent2;
        statusRegion.textContent = "Audio enabled.";
      })
      .catch((e) => {
        audioAllowed = false;
        audioControl.textContent = "Enable sound";
        statusRegion.textContent = "Audio failed to start.";
        console.warn("Audio resume failed:", e);
      });
  });

  // Game state (unchanged mechanics)
  let level = 1;
  let target = 0;
  let gears = [];
  let player = {
    x: WIDTH / 2,
    y: HEIGHT - 110,
    radius: 22,
    carrying: [],
    blinkTimer: 0,
  };
  let keys = {};
  let message = "";
  let messageTimer = 0;
  let levelComplete = false;
  let gameComplete = false;
  let moves = 0;

  // Accessibility announcement
  function announce(text) {
    statusRegion.textContent = text;
  }

  // Utility: random int inclusive
  function randInt(a, b) {
    return Math.floor(Math.random() * (b - a + 1)) + a;
  }

  // Generate a solvable set of gears that can sum to target (unchanged)
  function generateLevel(lv) {
    const gearCount = Math.min(MAX_GEARS, Math.max(3, 2 + lv));
    const baseMax = GEAR_MAX + Math.min(5, lv);
    target = randInt(5 + lv, 8 + baseMax);
    gears = [];
    // Guarantee solvability
    const partsCount = randInt(2, Math.min(3, gearCount));
    let remaining = target;
    let solutionParts = [];
    for (let i = 0; i < partsCount - 1; i++) {
      const maxPart = Math.min(GEAR_MAX, remaining - (partsCount - i - 1) * GEAR_MIN);
      const minPart = Math.max(GEAR_MIN, remaining - (partsCount - i - 1) * GEAR_MAX);
      const part = randInt(minPart, maxPart);
      solutionParts.push(part);
      remaining -= part;
    }
    solutionParts.push(remaining);

    for (let v of solutionParts) {
      gears.push({
        x: randInt(80, WIDTH - 80),
        y: randInt(150, HEIGHT - 220),
        val: v,
        taken: false,
        id: cryptoRandomId(),
        rot: Math.random() * Math.PI * 2,
        rotSpeed: (Math.random() - 0.5) * 0.03,
      });
    }

    while (gears.length < gearCount) {
      const v = randInt(GEAR_MIN, Math.max(GEAR_MAX, Math.floor(target / 2) + 2));
      gears.push({
        x: randInt(80, WIDTH - 80),
        y: randInt(150, HEIGHT - 220),
        val: v,
        taken: false,
        id: cryptoRandomId(),
        rot: Math.random() * Math.PI * 2,
        rotSpeed: (Math.random() - 0.5) * 0.03,
      });
    }

    // Slightly nudge positions to avoid overlap
    for (let i = 0; i < gears.length; i++) {
      for (let j = i + 1; j < gears.length; j++) {
        const a = gears[i],
          b = gears[j];
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        if (dist < 60) {
          b.x += (dx / dist) * 40 + randInt(-12, 12);
          b.y += (dy / dist) * 40 + randInt(-12, 12);
        }
      }
    }

    player.x = WIDTH / 2;
    player.carrying = [];
    levelComplete = false;
    gameComplete = false;
    moves = 0;
    announce(
      `Level ${level}. Fix the machine by collecting gears that add to ${target}. Use left and right arrows, press space to pick up a gear.`
    );
  }

  // Generate a short random id
  function cryptoRandomId() {
    try {
      return Math.random().toString(36).slice(2, 9);
    } catch (e) {
      return Date.now().toString(36);
    }
  }

  // Input handling (unchanged)
  window.addEventListener("keydown", function (e) {
    if (e.repeat) return;
    keys[e.key] = true;
    if (e.key === " " || e.key === "Spacebar") {
      e.preventDefault();
      attemptPick();
    } else if (e.key === "Enter") {
      attemptPick();
    } else if (e.key === "r" || e.key === "R") {
      resetGame();
    } else if (e.key === "n" || e.key === "N") {
      nextLevel();
    }
  });

  window.addEventListener("keyup", function (e) {
    delete keys[e.key];
  });

  // Mouse click to pick (unchanged behavior)
  canvas.addEventListener("click", function (ev) {
    const rect = canvas.getBoundingClientRect();
    const mx = ev.clientX - rect.left;
    const my = ev.clientY - rect.top;
    let clicked = false;
    for (let g of gears) {
      if (!g.taken) {
        const d = Math.hypot(g.x - mx, g.y - my);
        if (d < 40) {
          player.x = clamp(g.x + randInt(-10, 10), 40, WIDTH - 40);
          attemptPick();
          clicked = true;
          break;
        }
      }
    }
    if (!clicked) {
      // do nothing
    }
  });

  // Attempt to pick up gears when near (unchanged game logic)
  function attemptPick() {
    if (levelComplete || gameComplete) return;
    let nearest = null;
    let nearestDist = Infinity;
    for (let g of gears) {
      if (g.taken) continue;
      const d = Math.hypot(g.x - player.x, g.y - player.y);
      if (d < nearestDist) {
        nearestDist = d;
        nearest = g;
      }
    }
    if (nearest && nearestDist <= PICK_RANGE) {
      nearest.taken = true;
      player.carrying.push(nearest);
      moves++;
      // play pick with location for nice feedback
      playPick(nearest.x, nearest.y);
      announce(`Picked gear ${nearest.val}. Current sum is ${currentSum()}.`);
      const sum = currentSum();
      if (sum === target) {
        onLevelSuccess();
      } else if (sum > target) {
        message = "Too many! Try again (press R to reset).";
        messageTimer = 240;
        playIncorrect(nearest.x, nearest.y);
        announce("Too many. Press R to try again.");
      } else {
        message = "Nice! You're not there yet.";
        messageTimer = 80;
      }
    } else {
      message = "No gear nearby. Move closer to pick a gear.";
      messageTimer = 80;
      // provide audio cue at player location
      playIncorrect(player.x, player.y);
      announce("No gear nearby.");
    }
  }

  function currentSum() {
    return player.carrying.reduce((s, g) => s + g.val, 0);
  }

  function onLevelSuccess() {
    levelComplete = true;
    // use playSuccess with center of machine for visual effect
    playSuccess(WIDTH / 2, HEIGHT / 2 - 30);
    message = "Machine fixed! Nice work.";
    messageTimer = 240;
    announce(`Level ${level} complete! You fixed the machine.`);
    if (level >= TOTAL_LEVELS) {
      gameComplete = true;
      announce("Congratulations! You repaired all the machines. Press R to play again.");
    }
  }

  function nextLevel() {
    if (levelComplete && level < TOTAL_LEVELS) {
      level++;
      generateLevel(level);
    } else if (!levelComplete) {
      message = "Finish the current level before moving on.";
      messageTimer = 120;
      announce("Finish the current level first.");
    } else if (gameComplete) {
      level = 1;
      generateLevel(level);
    }
  }

  function resetGame() {
    for (let g of gears) {
      g.taken = false;
    }
    player.carrying = [];
    message = "Level reset. Try a new combination!";
    messageTimer = 120;
    announce("Level reset.");
  }

  // Drawing helpers (enhanced visuals)
  function drawRoundedRect(ctx, x, y, w, h, r, fillStyle, strokeStyle) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fillStyle) {
      ctx.fillStyle = fillStyle;
      ctx.fill();
    }
    if (strokeStyle) {
      ctx.strokeStyle = strokeStyle;
      ctx.stroke();
    }
  }

  function drawGear(ctx, x, y, radius, teeth, colorFill, colorStroke, rotation = 0) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rotation);
    // gear body with soft bevel
    const inner = radius * 0.68;
    const toothWidth = (Math.PI * 2) / (teeth * 2);
    ctx.beginPath();
    for (let i = 0; i < teeth * 2; i++) {
      const angle = i * toothWidth;
      const r = i % 2 === 0 ? radius : inner;
      const px = Math.cos(angle) * r;
      const py = Math.sin(angle) * r;
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.closePath();
    // radial gradient for a subtle 3D feel
    const grd = ctx.createRadialGradient(-radius * 0.2, -radius * 0.35, radius * 0.1, 0, 0, radius);
    grd.addColorStop(0, shadeColor(colorFill, -6));
    grd.addColorStop(0.5, colorFill);
    grd.addColorStop(1, shadeColor(colorFill, 8));
    ctx.fillStyle = grd;
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = colorStroke;
    ctx.stroke();

    // center hole with soft highlight
    ctx.beginPath();
    ctx.arc(0, 0, radius * 0.34, 0, Math.PI * 2);
    ctx.fillStyle = "#F6FAF9";
    ctx.fill();
    ctx.stroke();

    // light shine
    ctx.beginPath();
    ctx.ellipse(-radius * 0.25, -radius * 0.3, radius * 0.18, radius * 0.08, 0, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(255,255,255,0.35)";
    ctx.fill();

    ctx.restore();
  }

  // Slightly nicer robot drawing with subtle bounce and blinking
  function drawRobot(ctx, x, y, carrying) {
    ctx.save();
    const bob = Math.sin(Date.now() / 500 + x) * 2;
    ctx.translate(x, y + bob);
    // shadow
    ctx.beginPath();
    ctx.ellipse(0, 36, 26, 8, 0, 0, Math.PI * 2);
    ctx.fillStyle = COLORS.shadow;
    ctx.fill();

    // body with gradient
    ctx.save();
    ctx.translate(0, -6);
    drawRoundedRect(ctx, -28, -34, 56, 56, 10, null, null);
    const bodyGrd = ctx.createLinearGradient(-28, -34, 28, 22);
    bodyGrd.addColorStop(0, "#FFF5E6");
    bodyGrd.addColorStop(1, COLORS.robotBody);
    drawRoundedRect(ctx, -28, -34, 56, 56, 10, bodyGrd, "#C79B5E");

    // head
    drawRoundedRect(ctx, -20, -64, 40, 30, 6, "#FFF8EC", "#C79B5E");
    // eyes (blink logic)
    player.blinkTimer--;
    if (player.blinkTimer <= 0) {
      if (Math.random() < 0.06) player.blinkTimer = 8; // blink for 8 frames
      else player.blinkTimer = 60 + Math.floor(Math.random() * 120);
    }
    const eyeOpen = player.blinkTimer > 6;
    ctx.fillStyle = COLORS.text;
    if (eyeOpen) {
      ctx.beginPath();
      ctx.arc(-6, -52, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(6, -52, 4, 0, Math.PI * 2);
      ctx.fill();
    } else {
      ctx.strokeStyle = COLORS.text;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-10, -52);
      ctx.lineTo(-2, -52);
      ctx.moveTo(2, -52);
      ctx.lineTo(10, -52);
      ctx.stroke();
    }

    // mouth smile
    ctx.strokeStyle = COLORS.text;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(0, -44, 7, 0, Math.PI, false);
    ctx.stroke();

    // arm holding gears (stacked)
    const startX = 22;
    let sy = -6;
    for (let i = 0; i < carrying.length; i++) {
      const g = carrying[i];
      drawGear(
        ctx,
        startX + (i % 2) * 10 - i * 0.5,
        sy - i * 6,
        10,
        8,
        COLORS.gearFill,
        COLORS.gearStroke,
        (i * 0.35 + Date.now() / 800) % (Math.PI * 2)
      );
      ctx.fillStyle = COLORS.text;
      ctx.font = "10px monospace";
      ctx.textAlign = "center";
      ctx.fillText(g.val, startX + (i % 2) * 10 - i * 0.5, sy - i * 6 + 4);
    }

    ctx.restore();
    ctx.restore();
  }

  // Utility: shade color (lighten/darken) for simple gradients
  function shadeColor(hex, percent) {
    // hex like #RRGGBB
    try {
      const h = hex.replace("#", "");
      const num = parseInt(h, 16);
      let r = (num >> 16) + percent;
      let g = ((num >> 8) & 0x00ff) + percent;
      let b = (num & 0x0000ff) + percent;
      r = Math.max(0, Math.min(255, r));
      g = Math.max(0, Math.min(255, g));
      b = Math.max(0, Math.min(255, b));
      return "#" + (r << 16 | g << 8 | b).toString(16).padStart(6, "0");
    } catch (e) {
      return hex;
    }
  }

  // Small animated background silhouettes to add depth
  const silhouettes = [];
  for (let i = 0; i < 6; i++) {
    silhouettes.push({
      x: Math.random() * WIDTH,
      y: 80 + Math.random() * 120,
      s: 40 + Math.random() * 80,
      rot: Math.random() * Math.PI * 2,
      speed: (Math.random() - 0.5) * 0.0008,
    });
  }

  // Main draw loop (with particles and improved visuals)
  let lastTime = 0;
  function loop(ts) {
    const dt = (ts - lastTime) || 16;
    lastTime = ts;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  function update(dt) {
    // Movement
    if (keys["ArrowLeft"]) {
      player.x -= PLAYER_SPEED;
    }
    if (keys["ArrowRight"]) {
      player.x += PLAYER_SPEED;
    }
    player.x = clamp(player.x, 40, WIDTH - 40);

    // update gear rotations
    const now = Date.now();
    for (let g of gears) {
      g.rot += g.rotSpeed * (dt / 16);
    }

    // update silhouettes drift
    for (let s of silhouettes) {
      s.rot += s.speed * dt;
      s.x += Math.sin(now / 10000 + s.rot) * 0.02 * dt;
      if (s.x < -100) s.x = WIDTH + 100;
      if (s.x > WIDTH + 100) s.x = -100;
    }

    // update particles
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.06; // gravity
      p.vx *= 0.99;
      p.vy *= 0.99;
      p.life--;
      p.size *= 0.995;
      if (p.life <= 0 || p.size < 0.2) {
        particles.splice(i, 1);
      }
    }

    // handle message timer
    if (messageTimer > 0) {
      messageTimer--;
      if (messageTimer === 0) {
        message = "";
      }
    }
  }

  function draw() {
    // clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // background gradient
    const bg = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    bg.addColorStop(0, COLORS.backgroundTop);
    bg.addColorStop(1, COLORS.backgroundBottom);
    ctx.fillStyle = bg;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // faint gear silhouettes
    for (let i = 0; i < silhouettes.length; i++) {
      const s = silhouettes[i];
      ctx.save();
      ctx.globalAlpha = 0.18;
      ctx.translate(s.x, s.y);
      ctx.rotate(Math.sin(Date.now() * s.speed * 0.5 + i) * 0.2 + s.rot);
      drawGear(
        ctx,
        0,
        0,
        s.s * 0.7,
        Math.floor(8 + (s.s % 5)),
        COLORS.silhouette,
        COLORS.silhouette,
        s.rot * 0.2
      );
      ctx.restore();
    }

    // top panel
    drawRoundedRect(ctx, 12, 12, WIDTH - 24, 96, 12, COLORS.panel, "rgba(0,0,0,0.04)");
    ctx.fillStyle = COLORS.text;
    ctx.font = "20px Inter, sans-serif";
    ctx.textAlign = "left";
    ctx.fillText(`Machine Math — Level ${level} of ${TOTAL_LEVELS}`, 28, 40);
    ctx.font = "13px Inter, sans-serif";
    ctx.fillStyle = "#2F5552";
    ctx.fillText(`Fix the machine by collecting gears that add to:`, 28, 62);
    ctx.font = "30px monospace";
    ctx.fillStyle = COLORS.accent2;
    ctx.fillText(`${target}`, 320, 74);

    ctx.font = "12px Inter, sans-serif";
    ctx.fillStyle = "#4F6B6A";
    ctx.fillText("Use ← → keys to move. Press Space or Enter to pick up a gear when you're close.", 28, 88);

    // machine area
    drawRoundedRect(ctx, 36, 120, WIDTH - 72, HEIGHT - 170, 14, COLORS.machine, "rgba(0,0,0,0.04)");

    // conveyor belt animated stripes
    const beltX = 36,
      beltY = HEIGHT - 160,
      beltW = WIDTH - 72,
      beltH = 24;
    ctx.fillStyle = "#EAF9F6";
    ctx.fillRect(beltX, beltY, beltW, beltH);
    ctx.save();
    ctx.beginPath();
    ctx.rect(beltX, beltY, beltW, beltH);
    ctx.clip();
    const stripeW = 28;
    const offset = (Date.now() / 10) % stripeW;
    for (let sx = -stripeW + offset; sx < beltW + stripeW; sx += stripeW) {
      ctx.fillStyle = "rgba(95,179,168,0.06)";
      ctx.fillRect(beltX + sx, beltY, stripeW * 0.6, beltH);
    }
    ctx.restore();

    // decorative piping
    ctx.strokeStyle = "#CDEDE8";
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(60, 160);
    ctx.bezierCurveTo(120, 130, 240, 200, 380, 160);
    ctx.bezierCurveTo(500, 120, 620, 200, 660, 160);
    ctx.stroke();

    // Draw gears with animation and shadows
    for (let g of gears) {
      ctx.save();
      const bob = Math.sin((g.x + g.y + Date.now() / 200) / 150) * 5;
      const x = g.x;
      const y = g.y + bob;
      const dist = Math.hypot(player.x - x, player.y - y);
      const near = dist < PICK_RANGE;
      // shadow
      ctx.beginPath();
      ctx.ellipse(x + 6, y + 16, 20, 6, 0, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(20,20,20,0.05)";
      ctx.fill();
      ctx.globalAlpha = g.taken ? 0.25 : 1;
      drawGear(ctx, x, y, 28, 12, COLORS.gearFill, near ? COLORS.accent : COLORS.gearStroke, g.rot);
      ctx.fillStyle = COLORS.text;
      ctx.font = "20px monospace";
      ctx.textAlign = "center";
      ctx.fillText(g.val, x, y + 6);
      // subtle glow when near
      if (near && !g.taken) {
        ctx.beginPath();
        ctx.arc(x, y, 36, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(95,179,168,0.06)";
        ctx.fill();
      }
      ctx.restore();
    }

    // Draw robot (player)
    drawRobot(ctx, player.x, player.y, player.carrying);

    // current sum and moves
    ctx.font = "15px Inter, sans-serif";
    ctx.fillStyle = COLORS.text;
    ctx.textAlign = "left";
    ctx.fillText(`Current sum: ${currentSum()}`, 48, HEIGHT - 28);
    ctx.textAlign = "right";
    ctx.fillText(`Moves: ${moves}`, WIDTH - 48, HEIGHT - 28);

    // message box
    if (message) {
      const boxW = WIDTH - 160;
      const boxX = (WIDTH - boxW) / 2;
      const boxY = HEIGHT - 110;
      drawRoundedRect(
        ctx,
        boxX,
        boxY,
        boxW,
        40,
        8,
        message.includes("Too") ? COLORS.wrong : COLORS.success,
        "#B7D9D0"
      );
      ctx.fillStyle = COLORS.text;
      ctx.font = "16px Inter, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(message, boxX + boxW / 2, boxY + 26);
    }

    // audio status indicator drawn on canvas
    ctx.save();
    ctx.textAlign = "right";
    ctx.font = "12px Inter, sans-serif";
    if (audioAllowed) {
      ctx.fillStyle = COLORS.accent2;
      ctx.fillText("Audio: ON", WIDTH - 20, 30);
      // small animated waveform
      ctx.strokeStyle = COLORS.accent2;
      ctx.lineWidth = 2;
      ctx.beginPath();
      const cx = WIDTH - 80;
      const cy = 24;
      ctx.moveTo(cx, cy);
      ctx.quadraticCurveTo(cx + 6, cy - 6, cx + 12, cy);
      ctx.quadraticCurveTo(cx + 18, cy + 6, cx + 24, cy);
      ctx.stroke();
    } else {
      ctx.fillStyle = "#A7BFB9";
      ctx.fillText("Audio: OFF", WIDTH - 20, 30);
      ctx.strokeStyle = "#A7BFB9";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(WIDTH - 80, 24);
      ctx.lineTo(WIDTH - 56, 24);
      ctx.stroke();
    }
    ctx.restore();

    // particles rendering
    for (let p of particles) {
      ctx.save();
      ctx.globalAlpha = Math.max(0, p.life / p.maxLife);
      ctx.fillStyle = p.color || "#FFF";
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // overlays for completion
    if (levelComplete) {
      ctx.save();
      ctx.globalAlpha = 0.96;
      drawRoundedRect(ctx, WIDTH / 2 - 180, HEIGHT / 2 - 70, 360, 140, 12, "#FFFFFF", "#D8EFE7");
      ctx.fillStyle = COLORS.text;
      ctx.font = "22px Inter, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(level >= TOTAL_LEVELS ? "Well done!" : "Machine repaired!", WIDTH / 2, HEIGHT / 2 - 18);
      ctx.font = "16px Inter, sans-serif";
      ctx.fillStyle = "#4F6B6A";
      ctx.fillText(
        level >= TOTAL_LEVELS ? "You fixed all the machines." : "Press N to move to the next machine.",
        WIDTH / 2,
        HEIGHT / 2 + 12
      );
      ctx.restore();
    }

    if (gameComplete) {
      ctx.save();
      ctx.globalAlpha = 0.98;
      drawRoundedRect(ctx, WIDTH / 2 - 200, HEIGHT / 2 - 80, 400, 160, 16, "#FDFDFB", "#CFF1E0");
      ctx.fillStyle = COLORS.text;
      ctx.font = "24px Inter, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("All Machines Fixed!", WIDTH / 2, HEIGHT / 2 - 10);
      ctx.font = "16px Inter, sans-serif";
      ctx.fillStyle = "#4F6B6A";
      ctx.fillText("Great job! Press R to play again.", WIDTH / 2, HEIGHT / 2 + 20);
      ctx.restore();
    }

    // help caption
    ctx.font = "11px Inter, sans-serif";
    ctx.fillStyle = "#6D8B88";
    ctx.textAlign = "left";
    ctx.fillText("Keyboard: ← → to move • Space/Enter to pick • R reset • N next", 40, HEIGHT - 8);
  }

  // Initialize first level
  generateLevel(level);
  initAudio();

  // Start loop
  requestAnimationFrame(loop);

  // Expose some helpful console functions (optional)
  window.machineMathGame = {
    nextLevel: function () {
      nextLevel();
    },
    resetLevel: function () {
      resetGame();
    },
    enableAudio: function () {
      audioControl.click();
    },
    getState: function () {
      return {
        level,
        target,
        sum: currentSum(),
        moves,
        audioAllowed,
      };
    },
  };

  // Safety: if audio not enabled within a while, show hint
  setTimeout(() => {
    if (!audioAllowed && audioContext) {
      statusRegion.textContent = "Tip: Click 'Enable sound' to hear friendly game sounds.";
    }
  }, 4000);

  // Error handling for canvas context lost
  canvas.addEventListener("webglcontextlost", function (e) {
    e.preventDefault();
    alert("Canvas context lost — please reload the page.");
  });

  // Focus canvas to allow keyboard immediately (best effort)
  try {
    canvas.focus();
  } catch (e) {
    // ignore
  }
})();