{
  "generated_date": "2025-09-15",
  "generated_timestamp": "2025-09-15T00:29:06.635003",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 10767,
  "game_filename": "2025-09-15.js",
  "game_size_bytes": 32078,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Machine Math Workshop - JavaScript game\n// Renders inside element with id \"game-of-the-day-stage\"\n// Canvas size: 720 x 480\n// Uses Web Audio API (oscillators) for sounds\n// Accessible: keyboard, screen-reader live region, visual audio cue\n// No external assets. All drawing with canvas API.\n\n// Immediately invoked function to avoid global leakage\n(function () {\n  // Constants\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const STAGE_ID = \"game-of-the-day-stage\";\n  const MAX_LEVELS = 6;\n  const GEAR_COUNT = 7; // gears shown per level\n  const FONT = \"16px system-ui, -apple-system, 'Segoe UI', Roboto\";\n  const LARGE_FONT = \"20px system-ui, -apple-system, 'Segoe UI', Roboto\";\n\n  // Stage and DOM setup\n  const stageElem = document.getElementById(STAGE_ID);\n  if (!stageElem) {\n    console.error(`Element with id \"${STAGE_ID}\" not found. Game cannot start.`);\n    return;\n  }\n\n  // Create a live region for screen reader feedback and instructions\n  const liveRegion = document.createElement(\"div\");\n  liveRegion.setAttribute(\"aria-live\", \"polite\");\n  liveRegion.setAttribute(\"aria-atomic\", \"true\");\n  liveRegion.style.position = \"absolute\";\n  liveRegion.style.left = \"-9999px\";\n  liveRegion.style.width = \"1px\";\n  liveRegion.style.height = \"1px\";\n  liveRegion.style.overflow = \"hidden\";\n  stageElem.appendChild(liveRegion);\n\n  // Create canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.width = WIDTH + \"px\";\n  canvas.style.height = HEIGHT + \"px\";\n  canvas.setAttribute(\"role\", \"application\");\n  canvas.setAttribute(\"aria-label\", \"Machine Math Workshop. Use arrow keys to pick gears and press Enter to add them to the machine. Press P to process.\");\n  canvas.tabIndex = 0; // focusable for keyboard\n  stageElem.appendChild(canvas);\n\n  const ctx = canvas.getContext(\"2d\", { alpha: false });\n\n  // Scale for crisp text on high DPI\n  function setPixelRatio() {\n    const dpr = window.devicePixelRatio || 1;\n    canvas.width = WIDTH * dpr;\n    canvas.height = HEIGHT * dpr;\n    canvas.style.width = WIDTH + \"px\";\n    canvas.style.height = HEIGHT + \"px\";\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n  }\n  setPixelRatio();\n  window.addEventListener(\"resize\", setPixelRatio);\n\n  // Audio setup\n  let audioCtx = null;\n  let masterGain = null;\n  let bgGain = null;\n  let bgOsc = null;\n  let audioEnabled = true;\n  let audioInitError = null;\n\n  function initAudio(onUserGesture = false) {\n    if (audioCtx) return;\n    try {\n      const AudioContext = window.AudioContext || window.webkitAudioContext;\n      audioCtx = new AudioContext();\n      masterGain = audioCtx.createGain();\n      masterGain.gain.value = 0.9;\n      masterGain.connect(audioCtx.destination);\n\n      // Background hum\n      bgOsc = audioCtx.createOscillator();\n      bgOsc.type = \"sine\";\n      bgOsc.frequency.value = 120; // gentle base\n      const bgFilter = audioCtx.createBiquadFilter();\n      bgFilter.type = \"lowpass\";\n      bgFilter.frequency.value = 600;\n      bgGain = audioCtx.createGain();\n      bgGain.gain.value = 0.02; // subtle\n      bgOsc.connect(bgFilter);\n      bgFilter.connect(bgGain);\n      bgGain.connect(masterGain);\n      bgOsc.start();\n\n      // Smoothly ramp down if audio should be muted\n      if (!audioEnabled) {\n        masterGain.gain.value = 0;\n      }\n\n      // Announce readiness\n      updateLiveRegion(\"Audio initialized.\");\n    } catch (e) {\n      audioInitError = e;\n      console.error(\"Audio initialization error:\", e);\n      updateLiveRegion(\"Audio unavailable in this browser.\");\n      audioEnabled = false;\n    }\n  }\n\n  // Play a short tone (for clicks)\n  function playTone(freq = 440, duration = 0.12, type = \"sine\", volume = 0.12) {\n    if (audioInitError || !audioEnabled) return;\n    try {\n      if (!audioCtx) initAudio();\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = type;\n      o.frequency.value = freq;\n      g.gain.value = volume;\n      o.connect(g);\n      g.connect(masterGain);\n      const t = audioCtx.currentTime;\n      g.gain.setValueAtTime(volume, t);\n      g.gain.exponentialRampToValueAtTime(0.0001, t + duration);\n      o.start(t);\n      o.stop(t + duration + 0.02);\n    } catch (e) {\n      console.error(\"playTone error:\", e);\n    }\n  }\n\n  // Positive chime sequence\n  function playPositive() {\n    if (audioInitError || !audioEnabled) return;\n    try {\n      if (!audioCtx) initAudio();\n      const now = audioCtx.currentTime;\n      const freqs = [660, 880, 990];\n      freqs.forEach((f, i) => {\n        const o = audioCtx.createOscillator();\n        const g = audioCtx.createGain();\n        o.type = \"sine\";\n        o.frequency.value = f;\n        g.gain.value = 0.0001;\n        o.connect(g);\n        g.connect(masterGain);\n        const start = now + i * 0.09;\n        g.gain.setValueAtTime(0.0001, start);\n        g.gain.linearRampToValueAtTime(0.12, start + 0.01);\n        g.gain.exponentialRampToValueAtTime(0.0001, start + 0.28);\n        o.start(start);\n        o.stop(start + 0.32);\n      });\n      updateLiveRegion(\"Correct! Target reached.\");\n    } catch (e) {\n      console.error(\"playPositive error:\", e);\n    }\n  }\n\n  // Negative thud\n  function playNegative() {\n    if (audioInitError || !audioEnabled) return;\n    try {\n      if (!audioCtx) initAudio();\n      const o1 = audioCtx.createOscillator();\n      const o2 = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      const fNoise = audioCtx.createBiquadFilter();\n      o1.type = \"sawtooth\";\n      o1.frequency.value = 120;\n      o2.type = \"sine\";\n      o2.frequency.value = 80;\n      g.gain.value = 0.0001;\n      const t = audioCtx.currentTime;\n      o1.connect(g);\n      o2.connect(g);\n      g.connect(masterGain);\n      g.gain.setValueAtTime(0.0001, t);\n      g.gain.linearRampToValueAtTime(0.18, t + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.25);\n      o1.start(t);\n      o2.start(t);\n      o1.stop(t + 0.3);\n      o2.stop(t + 0.3);\n      updateLiveRegion(\"That went over the target. Try again.\");\n    } catch (e) {\n      console.error(\"playNegative error:\", e);\n    }\n  }\n\n  // Gentle click\n  function playClick() {\n    playTone(880, 0.06, \"square\", 0.06);\n  }\n\n  // Toggle audio on/off\n  function toggleAudio() {\n    audioEnabled = !audioEnabled;\n    if (!audioCtx) {\n      // require gesture to create audio; will initialize on next user gesture\n      if (audioEnabled) {\n        updateLiveRegion(\"Audio enabled. Tap to start sounds.\");\n      } else {\n        updateLiveRegion(\"Audio disabled.\");\n      }\n    } else {\n      try {\n        if (audioEnabled) {\n          masterGain.gain.setTargetAtTime(0.9, audioCtx.currentTime, 0.05);\n          bgGain.gain.setTargetAtTime(0.02, audioCtx.currentTime, 0.05);\n          updateLiveRegion(\"Audio on.\");\n        } else {\n          masterGain.gain.setTargetAtTime(0.0001, audioCtx.currentTime, 0.05);\n          updateLiveRegion(\"Audio off.\");\n        }\n      } catch (e) {\n        console.error(\"toggleAudio error:\", e);\n      }\n    }\n  }\n\n  // Game state\n  let levels = [];\n  let currentLevelIndex = 0;\n  let gears = []; // gear objects for current level\n  let selectedIDs = []; // ids of gears currently placed in machine slot\n  let takenIDs = new Set(); // gears that have been moved into slot\n  let processing = false;\n  let focusIndex = 0; // keyboard focus for gear selection or control\n  let attempts = 0;\n  let showHint = false;\n  let animationTime = 0;\n\n  // Layout locations\n  const conveyorY = HEIGHT - 110;\n  const conveyorLeft = 24;\n  const conveyorRight = WIDTH - 240;\n  const machineX = WIDTH - 200;\n  const machineY = 60;\n\n  // Create levels algorithmically to ensure solvable puzzle\n  function generateLevels(num) {\n    const arr = [];\n    for (let i = 0; i < num; i++) {\n      // difficulty increases: target grows\n      const difficulty = 1 + i;\n      const targetMin = 6 + difficulty * 3;\n      const targetMax = 12 + difficulty * 4;\n      const target = randInt(targetMin, targetMax);\n      // create a subset that sums to target\n      // We'll pick k numbers that sum to target, where each is 1..9\n      let subset = [];\n      let remaining = target;\n      let k = randInt(2, Math.min(5, Math.max(2, Math.floor(target / 2))));\n      // Fill subset with random numbers but ensure total equals target\n      for (let s = 0; s < k - 1; s++) {\n        const maxVal = Math.min(9, remaining - (k - s - 1) * 1);\n        const val = randInt(1, Math.max(1, maxVal));\n        subset.push(val);\n        remaining -= val;\n      }\n      subset.push(Math.max(1, remaining));\n      // If any >9, break into pieces\n      let fixed = [];\n      subset.forEach((v) => {\n        if (v <= 9) fixed.push(v);\n        else {\n          let r = v;\n          while (r > 9) {\n            fixed.push(9);\n            r -= 9;\n          }\n          if (r > 0) fixed.push(r);\n        }\n      });\n      // create gears including subset and distractors\n      const gearVals = fixed.slice();\n      while (gearVals.length < GEAR_COUNT - 1) {\n        gearVals.push(randInt(1, 9));\n      }\n      // Shuffle and ensure at least one solution: the fixed subset is within the set\n      // Add an extra random gear for challenge\n      gearVals.push(randInt(1, 9));\n      shuffleArray(gearVals);\n      arr.push({ target: target, gearValues: gearVals });\n    }\n    return arr;\n  }\n\n  // Utility helpers\n  function randInt(a, b) {\n    return Math.floor(Math.random() * (b - a + 1)) + a;\n  }\n  function shuffleArray(a) {\n    for (let i = a.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [a[i], a[j]] = [a[j], a[i]];\n    }\n  }\n\n  // Initialize first levels\n  levels = generateLevels(MAX_LEVELS);\n\n  // Create gear objects for a level\n  function setupLevel(index) {\n    gears = [];\n    selectedIDs = [];\n    takenIDs = new Set();\n    attempts = 0;\n    processing = false;\n    focusIndex = 0;\n    showHint = false;\n    const data = levels[index];\n    const values = data.gearValues.slice();\n    // Place gears evenly on conveyor\n    const spacing = (conveyorRight - conveyorLeft) / (values.length);\n    for (let i = 0; i < values.length; i++) {\n      const x = conveyorLeft + spacing * i + spacing / 2;\n      const y = conveyorY + randInt(-6, 6);\n      const id = `L${index}G${i}`;\n      gears.push({\n        id,\n        value: values[i],\n        x,\n        y,\n        radius: 30 + (i % 2 ? 2 : 0),\n        angle: 0,\n        wobble: Math.random() * Math.PI * 2,\n        taken: false,\n        visible: true,\n      });\n    }\n    // Announce level\n    updateLiveRegion(\n      `Level ${index + 1}. Build total ${data.target} using the gears below. Use arrow keys to pick and Enter to move a gear to the machine.`\n    );\n  }\n\n  // Start first level\n  setupLevel(currentLevelIndex);\n\n  // Drawing helpers\n  function clearCanvas() {\n    // calming gradient background\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, \"#eaf6ff\");\n    g.addColorStop(1, \"#f7fbf5\");\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n  }\n\n  function drawTitle() {\n    ctx.save();\n    ctx.font = \"bold 24px system-ui, -apple-system, 'Segoe UI', Roboto\";\n    ctx.fillStyle = \"#244\";\n    ctx.fillText(\"Machine Math Workshop\", 20, 34);\n    ctx.restore();\n  }\n\n  function drawInstructions() {\n    ctx.save();\n    ctx.font = FONT;\n    ctx.fillStyle = \"#233\";\n    ctx.globalAlpha = 0.9;\n    const instructions = [\n      \"Pick gears and put them into the machine so their sum equals the target number.\",\n      \"Keyboard: Left/Right to move, Enter/Space to pick/unpick, P to process, R to reset, S to toggle sound.\",\n      \"Click a gear to pick it, click a gear in the slot to return it.\",\n    ];\n    for (let i = 0; i < instructions.length; i++) {\n      ctx.fillText(instructions[i], 20, 62 + i * 18);\n    }\n    ctx.restore();\n  }\n\n  function drawMachineOutline() {\n    // Machine body\n    ctx.save();\n    ctx.fillStyle = \"#dde8f0\";\n    ctx.fillRect(machineX, machineY, 180, 320);\n    // Screen\n    ctx.fillStyle = \"#122\";\n    ctx.fillRect(machineX + 16, machineY + 18, 148, 58);\n    // Display window border\n    ctx.strokeStyle = \"#9ad\";\n    ctx.lineWidth = 2;\n    ctx.strokeRect(machineX + 16, machineY + 18, 148, 58);\n    // Slots area\n    ctx.fillStyle = \"#cfe3e8\";\n    ctx.fillRect(machineX + 16, machineY + 92, 148, 150);\n    ctx.strokeStyle = \"#b4cbd3\";\n    ctx.strokeRect(machineX + 16, machineY + 92, 148, 150);\n    // Base\n    ctx.fillStyle = \"#d4dbe2\";\n    ctx.fillRect(machineX + 16, machineY + 256, 148, 24);\n    ctx.restore();\n  }\n\n  function drawMachineDisplay(target, currentSum, processingAnim) {\n    // Dark screen\n    ctx.save();\n    ctx.font = \"bold 22px system-ui, -apple-system, 'Segoe UI', Roboto\";\n    // screen background\n    const sx = machineX + 16;\n    const sy = machineY + 18;\n    const sw = 148;\n    const sh = 58;\n    // glow effect if processing\n    if (processingAnim) {\n      const g = ctx.createLinearGradient(sx, sy, sx + sw, sy + sh);\n      g.addColorStop(0, \"#dfffdc\");\n      g.addColorStop(1, \"#bde6ff\");\n      ctx.fillStyle = g;\n    } else {\n      ctx.fillStyle = \"#0c2a2d\";\n    }\n    ctx.fillRect(sx, sy, sw, sh);\n    // text\n    ctx.fillStyle = processingAnim ? \"#135\" : \"#8fe3ff\";\n    ctx.fillText(`Target: ${target}`, sx + 10, sy + 30);\n    ctx.font = \"bold 20px system-ui, -apple-system, 'Segoe UI', Roboto\";\n    ctx.fillText(`Sum: ${currentSum}`, sx + 10, sy + 52);\n    ctx.restore();\n  }\n\n  function drawGears() {\n    gears.forEach((g, i) => {\n      if (!g.visible) return;\n      // subtle rotation\n      g.angle += 0.004 + (i % 3) * 0.001;\n      drawGear(g.x, g.y, g.radius, g.value, g.angle, g.taken, i === focusIndex && !g.taken);\n    });\n    // conveyor\n    ctx.save();\n    ctx.fillStyle = \"#e6f1f4\";\n    ctx.fillRect(conveyorLeft - 10, conveyorY - 12, conveyorRight - conveyorLeft + 20, 70);\n    ctx.strokeStyle = \"#bcd\";\n    ctx.strokeRect(conveyorLeft - 10, conveyorY - 12, conveyorRight - conveyorLeft + 20, 70);\n    ctx.restore();\n  }\n\n  function drawGear(x, y, r, label, angle = 0, taken = false, focused = false) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(angle);\n    // shadow\n    ctx.fillStyle = \"rgba(20,20,24,0.06)\";\n    ctx.beginPath();\n    ctx.ellipse(6, 6, r + 6, r + 2, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // gear teeth\n    const teeth = 10;\n    for (let t = 0; t < teeth; t++) {\n      const theta = (t / teeth) * Math.PI * 2;\n      const tx = Math.cos(theta) * (r + 6);\n      const ty = Math.sin(theta) * (r + 6);\n      ctx.fillStyle = \"#cbe\";\n      ctx.fillRect(tx - 4, ty - 3, 8, 6);\n    }\n\n    // body\n    ctx.beginPath();\n    ctx.arc(0, 0, r, 0, Math.PI * 2);\n    ctx.fillStyle = taken ? \"#f0efd6\" : \"#fff9f0\";\n    ctx.fill();\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = focused ? \"#2a6d8c\" : \"#d0cbc0\";\n    ctx.stroke();\n\n    // inner circle\n    ctx.beginPath();\n    ctx.arc(0, 0, r * 0.6, 0, Math.PI * 2);\n    ctx.fillStyle = taken ? \"#e7f2ff\" : \"#f3f8ff\";\n    ctx.fill();\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = \"#b7cbd4\";\n    ctx.stroke();\n\n    // number\n    ctx.fillStyle = \"#153\";\n    ctx.font = \"bold 18px system-ui, -apple-system, 'Segoe UI', Roboto\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(String(label), 0, 0);\n\n    // focus ring\n    if (focused) {\n      ctx.lineWidth = 3;\n      ctx.strokeStyle = \"#ffda6b\";\n      ctx.beginPath();\n      ctx.arc(0, 0, r + 8, 0, Math.PI * 2);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  function drawSlotGears() {\n    // Display selected gears in machine slot area\n    const sx = machineX + 28;\n    const sy = machineY + 106;\n    const slotW = 124;\n    const slotH = 132;\n    const slotPadding = 12;\n    const slotCols = 3;\n    const slotRows = Math.ceil(selectedIDs.length / slotCols);\n    const cellW = (slotW - slotPadding * 2) / slotCols;\n    const cellH = 44;\n    for (let i = 0; i < selectedIDs.length; i++) {\n      const id = selectedIDs[i];\n      const gear = gears.find((g) => g.id === id);\n      if (!gear) continue;\n      const col = i % slotCols;\n      const row = Math.floor(i / slotCols);\n      const gx = sx + slotPadding + col * cellW + cellW / 2;\n      const gy = sy + slotPadding + row * (cellH + 6) + cellH / 2;\n      drawGear(gx, gy, 20, gear.value, gear.angle + 0.2 * Math.sin(animationTime / 180 + i), true, false);\n    }\n  }\n\n  function drawControls() {\n    // Buttons: PROCESS, RESET, SOUND\n    ctx.save();\n    ctx.font = \"bold 16px system-ui, -apple-system, 'Segoe UI', Roboto\";\n\n    // Process button\n    const bx = machineX + 36;\n    const by = machineY + 284;\n    ctx.fillStyle = \"#8ad2d8\";\n    ctx.fillRect(bx, by, 110, 28);\n    ctx.strokeStyle = \"#6bb0b6\";\n    ctx.strokeRect(bx, by, 110, 28);\n    ctx.fillStyle = \"#052\";\n    ctx.fillText(\"PROCESS (P)\", bx + 6, by + 19);\n\n    // Reset\n    const rx = machineX + 36;\n    const ry = machineY + 320;\n    ctx.fillStyle = \"#ffe5d9\";\n    ctx.fillRect(rx, ry, 110, 26);\n    ctx.strokeStyle = \"#f8c0ae\";\n    ctx.strokeRect(rx, ry, 110, 26);\n    ctx.fillStyle = \"#5a2313\";\n    ctx.fillText(\"RESET (R)\", rx + 6, ry + 18);\n\n    // Sound indicator\n    const sxIcon = machineX + 36;\n    const syIcon = machineY + 354;\n    ctx.fillStyle = audioEnabled ? \"#d2ffd8\" : \"#ffdede\";\n    ctx.fillRect(sxIcon, syIcon, 110, 26);\n    ctx.strokeStyle = audioEnabled ? \"#9fd89e\" : \"#f1a3a3\";\n    ctx.strokeRect(sxIcon, syIcon, 110, 26);\n    ctx.fillStyle = audioEnabled ? \"#063\" : \"#630\";\n    ctx.fillText((audioEnabled ? \"SOUND ON (S)\" : \"SOUND OFF (S)\"), sxIcon + 6, syIcon + 18);\n\n    // Small visual audio pulse\n    if (audioEnabled && audioCtx) {\n      ctx.fillStyle = \"rgba(30,120,140,0.12)\";\n      ctx.beginPath();\n      const px = sxIcon + 92;\n      const py = syIcon + 13;\n      const pulse = 4 + 2 * Math.sin(animationTime / 90);\n      ctx.arc(px, py, pulse + 6, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.fillStyle = \"#0b5\";\n      ctx.beginPath();\n      ctx.arc(px, py, pulse, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    ctx.restore();\n  }\n\n  function drawLevelIndicator() {\n    ctx.save();\n    ctx.font = \"16px system-ui, -apple-system, 'Segoe UI', Roboto\";\n    ctx.fillStyle = \"#234\";\n    ctx.fillText(`Level ${currentLevelIndex + 1} of ${MAX_LEVELS}`, WIDTH - 180, 34);\n    ctx.restore();\n  }\n\n  function drawHint() {\n    if (!showHint) return;\n    const data = levels[currentLevelIndex];\n    const hintText = `Hint: Try using these numbers: ${getHintSubset(data).join(\", \")}`;\n    ctx.save();\n    ctx.font = \"14px system-ui, -apple-system, 'Segoe UI', Roboto\";\n    ctx.fillStyle = \"rgba(10,10,10,0.7)\";\n    ctx.fillRect(20, HEIGHT - 44, 540, 34);\n    ctx.fillStyle = \"#fff\";\n    ctx.fillText(hintText, 28, HEIGHT - 22);\n    ctx.restore();\n  }\n\n  // Compute current sum of selected gears\n  function currentSum() {\n    return selectedIDs.reduce((s, id) => {\n      const g = gears.find((gr) => gr.id === id);\n      return s + (g ? g.value : 0);\n    }, 0);\n  }\n\n  // Get hint subset (a useful subset that sums to target)\n  function getHintSubset(levelData) {\n    // We'll attempt to find small subset of gear values that sum to target using subset-sum DP\n    const arr = levelData.gearValues;\n    const target = levelData.target;\n    const n = arr.length;\n    // dp[i][s] = index of last element used or -1\n    const dp = Array.from({ length: target + 1 }, () => -1);\n    dp[0] = -2; // base\n    const parent = Array(target + 1).fill(-1);\n    for (let i = 0; i < n; i++) {\n      const v = arr[i];\n      for (let s = target; s >= v; s--) {\n        if (dp[s - v] !== -1 && dp[s] === -1) {\n          dp[s] = i;\n          parent[s] = s - v;\n        }\n      }\n    }\n    if (dp[target] === -1) {\n      return [Math.min(...arr)]; // fallback\n    }\n    // reconstruct subset\n    let s = target;\n    const chosen = [];\n    while (s > 0 && dp[s] !== -1) {\n      chosen.push(arr[dp[s]]);\n      s = parent[s];\n    }\n    return chosen;\n  }\n\n  // Drawing main frame\n  function render() {\n    animationTime++;\n    clearCanvas();\n    drawTitle();\n    drawInstructions();\n    drawMachineOutline();\n    const data = levels[currentLevelIndex];\n    drawMachineDisplay(data.target, currentSum(), processing);\n    drawGears();\n    drawSlotGears();\n    drawControls();\n    drawLevelIndicator();\n    drawHint();\n\n    // small footer\n    ctx.save();\n    ctx.font = \"12px system-ui, -apple-system, 'Segoe UI', Roboto\";\n    ctx.fillStyle = \"#234\";\n    ctx.fillText(\"Tip: You can remove a gear from the slot by clicking it.\", 20, HEIGHT - 8);\n    ctx.restore();\n\n    requestAnimationFrame(render);\n  }\n  requestAnimationFrame(render);\n\n  // Interaction handlers\n  function pickGearById(id) {\n    const gear = gears.find((g) => g.id === id);\n    if (!gear || gear.taken) return;\n    playClick();\n    gear.taken = true;\n    takenIDs.add(id);\n    selectedIDs.push(id);\n    updateLiveRegion(`Picked gear ${gear.value} and placed in machine.`);\n  }\n\n  function unpickGearById(id) {\n    const idx = selectedIDs.indexOf(id);\n    if (idx === -1) return;\n    const gear = gears.find((g) => g.id === id);\n    selectedIDs.splice(idx, 1);\n    if (gear) gear.taken = false;\n    takenIDs.delete(id);\n    playClick();\n    updateLiveRegion(`Returned gear ${gear.value} to the conveyor.`);\n  }\n\n  // Click position to id mapping\n  function gearAtPos(px, py) {\n    for (let i = gears.length - 1; i >= 0; i--) {\n      const g = gears[i];\n      if (!g.visible) continue;\n      const dx = px - g.x;\n      const dy = py - g.y;\n      if (dx * dx + dy * dy <= (g.radius + 6) * (g.radius + 6)) return g.id;\n    }\n    // check slot area for selected gears\n    const sx = machineX + 28;\n    const sy = machineY + 106;\n    const slotW = 124;\n    const slotPadding = 12;\n    const slotCols = 3;\n    for (let i = 0; i < selectedIDs.length; i++) {\n      const id = selectedIDs[i];\n      const gear = gears.find((g) => g.id === id);\n      const col = i % slotCols;\n      const row = Math.floor(i / slotCols);\n      const gx = sx + slotPadding + col * ((slotW - slotPadding * 2) / slotCols) + (slotW - slotPadding * 2) / (slotCols * 2);\n      const gy = sy + slotPadding + row * (44 + 6) + 22;\n      const dx = px - gx;\n      const dy = py - gy;\n      if (dx * dx + dy * dy <= 20 * 20) return id; // return slot gear id\n    }\n    // buttons\n    const bx = machineX + 36;\n    const by = machineY + 284;\n    if (px >= bx && px <= bx + 110 && py >= by && py <= by + 28) return \"BTN_PROCESS\";\n    const rx = machineX + 36;\n    const ry = machineY + 320;\n    if (px >= rx && px <= rx + 110 && py >= ry && py <= ry + 26) return \"BTN_RESET\";\n    const sxIcon = machineX + 36;\n    const syIcon = machineY + 354;\n    if (px >= sxIcon && px <= sxIcon + 110 && py >= syIcon && py <= syIcon + 26) return \"BTN_SOUND\";\n    return null;\n  }\n\n  canvas.addEventListener(\"mousedown\", (ev) => {\n    // initialize audio on first user gesture (some browsers require)\n    if (!audioCtx && audioEnabled) {\n      try {\n        initAudio(true);\n        if (audioCtx && audioCtx.state === \"suspended\") {\n          audioCtx.resume().catch((e) => console.warn(\"Audio resume failed\", e));\n        }\n      } catch (e) {\n        console.warn(\"Audio init on mousedown failed\", e);\n      }\n    }\n\n    const rect = canvas.getBoundingClientRect();\n    const px = ev.clientX - rect.left;\n    const py = ev.clientY - rect.top;\n    const hit = gearAtPos(px, py);\n    if (!hit) {\n      return;\n    }\n    if (hit === \"BTN_PROCESS\") {\n      processMachine();\n      return;\n    }\n    if (hit === \"BTN_RESET\") {\n      resetLevel();\n      return;\n    }\n    if (hit === \"BTN_SOUND\") {\n      toggleAudio();\n      return;\n    }\n    // If clicked a selected slot gear, return it\n    if (selectedIDs.includes(hit)) {\n      unpickGearById(hit);\n      return;\n    }\n    // pick gear if on conveyor\n    pickGearById(hit);\n  });\n\n  // Keyboard controls\n  canvas.addEventListener(\"keydown\", (ev) => {\n    // initialize audio on first gesture\n    if (!audioCtx && audioEnabled) {\n      try {\n        initAudio(true);\n        if (audioCtx && audioCtx.state === \"suspended\") {\n          audioCtx.resume().catch((e) => console.warn(\"Audio resume failed\", e));\n        }\n      } catch (e) {\n        console.warn(\"Audio init on keydown failed\", e);\n      }\n    }\n\n    const code = ev.key;\n    if (code === \"ArrowRight\") {\n      // move focus to next visible gear\n      let i = focusIndex;\n      for (let c = 0; c < gears.length; c++) {\n        i = (i + 1) % gears.length;\n        if (!gears[i].taken) {\n          focusIndex = i;\n          break;\n        }\n      }\n      ev.preventDefault();\n      playTone(660, 0.05, \"sine\", 0.04);\n    } else if (code === \"ArrowLeft\") {\n      let i = focusIndex;\n      for (let c = 0; c < gears.length; c++) {\n        i = (i - 1 + gears.length) % gears.length;\n        if (!gears[i].taken) {\n          focusIndex = i;\n          break;\n        }\n      }\n      ev.preventDefault();\n      playTone(550, 0.05, \"sine\", 0.04);\n    } else if (code === \" \" || code === \"Enter\") {\n      // pick/unpick focused gear\n      const g = gears[focusIndex];\n      if (g) {\n        if (selectedIDs.includes(g.id)) {\n          unpickGearById(g.id);\n        } else {\n          pickGearById(g.id);\n        }\n      }\n      ev.preventDefault();\n    } else if (code.toLowerCase() === \"p\") {\n      processMachine();\n      ev.preventDefault();\n    } else if (code.toLowerCase() === \"r\") {\n      resetLevel();\n      ev.preventDefault();\n    } else if (code.toLowerCase() === \"s\") {\n      toggleAudio();\n      ev.preventDefault();\n    } else if (code.toLowerCase() === \"h\") {\n      showHint = !showHint;\n      updateLiveRegion(showHint ? \"Hint shown.\" : \"Hint hidden.\");\n      ev.preventDefault();\n    }\n  });\n\n  function processMachine() {\n    if (processing) return;\n    attempts++;\n    const sum = currentSum();\n    const target = levels[currentLevelIndex].target;\n    processing = true;\n    playTone(420, 0.06, \"sine\", 0.06);\n    updateLiveRegion(`Processing... Current sum is ${sum}.`);\n    // animate a short delay\n    setTimeout(() => {\n      if (sum === target) {\n        // success\n        playPositive();\n        processing = false;\n        // clear selected gears visually and proceed to next level after animation\n        animateSuccess(() => {\n          currentLevelIndex++;\n          if (currentLevelIndex >= MAX_LEVELS) {\n            announceVictory();\n          } else {\n            setupLevel(currentLevelIndex);\n            playTone(720, 0.12, \"sine\", 0.08);\n          }\n        });\n      } else if (sum > target) {\n        // incorrect (over)\n        playNegative();\n        processing = false;\n        updateLiveRegion(\"Sum is over the target. Try removing a gear.\");\n      } else {\n        // sum < target: encourage more picks\n        playTone(520, 0.08, \"triangle\", 0.06);\n        processing = false;\n        updateLiveRegion(\"Not enough yet. Pick more gears.\");\n      }\n    }, 700);\n  }\n\n  function animateSuccess(callback) {\n    // Simple animation: spin selected gears out and show confetti\n    const confetti = [];\n    for (let i = 0; i < 18; i++) {\n      confetti.push({\n        x: machineX + 50 + Math.random() * 80,\n        y: machineY + 80 + Math.random() * 80,\n        vx: (Math.random() - 0.5) * 6,\n        vy: -Math.random() * 6 - 2,\n        color: [\"#ff7b7b\", \"#ffd47b\", \"#7be28a\", \"#7bd9ff\"][i % 4],\n        size: 4 + Math.random() * 6,\n      });\n    }\n    let t = 0;\n    const steps = 60;\n    const anim = () => {\n      t++;\n      // draw confetti over canvas\n      ctx.save();\n      confetti.forEach((c) => {\n        c.x += c.vx;\n        c.y += c.vy;\n        c.vy += 0.18;\n        ctx.fillStyle = c.color;\n        ctx.fillRect(c.x, c.y, c.size, c.size);\n      });\n      ctx.restore();\n      if (t < steps) {\n        requestAnimationFrame(anim);\n      } else {\n        // clear selection\n        selectedIDs.forEach((id) => {\n          const gear = gears.find((g) => g.id === id);\n          if (gear) gear.visible = false;\n        });\n        selectedIDs = [];\n        updateLiveRegion(\"Great job! Moving to the next level.\");\n        callback();\n      }\n    };\n    anim();\n  }\n\n  function resetLevel() {\n    // return all selected gears\n    selectedIDs.forEach((id) => {\n      const g = gears.find((gg) => gg.id === id);\n      if (g) g.taken = false;\n      takenIDs.delete(id);\n    });\n    selectedIDs = [];\n    attempts = 0;\n    playClick();\n    updateLiveRegion(\"Level has been reset.\");\n  }\n\n  function announceVictory() {\n    updateLiveRegion(\"Congratulations! You completed all levels. You win!\");\n    playPositive();\n    // Show big confetti in canvas\n    const confetti = [];\n    for (let i = 0; i < 120; i++) {\n      confetti.push({\n        x: Math.random() * WIDTH,\n        y: -Math.random() * 200,\n        vx: (Math.random() - 0.5) * 4,\n        vy: Math.random() * 4 + 1,\n        color: [\"#ff7b7b\", \"#ffd47b\", \"#7be28a\", \"#7bd9ff\", \"#d9b3ff\"][i % 5],\n        size: 6 + Math.random() * 8,\n        rot: Math.random() * Math.PI,\n      });\n    }\n    let t = 0;\n    const anim = () => {\n      t++;\n      clearCanvas();\n      drawTitle();\n      ctx.save();\n      ctx.font = \"28px system-ui, -apple-system, 'Segoe UI', Roboto\";\n      ctx.fillStyle = \"#163\";\n      ctx.fillText(\"You Fixed the Machine! You Win!\", 100, 220);\n      ctx.restore();\n      confetti.forEach((c) => {\n        c.x += c.vx;\n        c.y += c.vy;\n        c.vy += 0.06;\n        ctx.save();\n        ctx.fillStyle = c.color;\n        ctx.translate(c.x, c.y);\n        ctx.rotate(c.rot);\n        ctx.fillRect(-c.size / 2, -c.size / 2, c.size, c.size);\n        ctx.restore();\n      });\n      if (t < 160) {\n        requestAnimationFrame(anim);\n      } else {\n        // final state: allow restart\n        const restartMsg = document.createElement(\"div\");\n        restartMsg.style.position = \"absolute\";\n        restartMsg.style.left = \"20px\";\n        restartMsg.style.top = \"420px\";\n        restartMsg.style.background = \"rgba(255,255,255,0.9)\";\n        restartMsg.style.padding = \"8px 12px\";\n        restartMsg.style.borderRadius = \"8px\";\n        restartMsg.style.boxShadow = \"0 2px 6px rgba(0,0,0,0.12)\";\n        restartMsg.innerText = \"Press R to play again.\";\n        stageElem.appendChild(restartMsg);\n        // reset to first level for replay after user hits R\n      }\n    };\n    anim();\n  }\n\n  // Update live region for screen readers\n  let lastLive = \"\";\n  function updateLiveRegion(msg) {\n    lastLive = msg;\n    liveRegion.textContent = msg;\n  }\n\n  // Utility: in case of audio resume errors\n  function safeResumeAudio() {\n    if (audioCtx) {\n      audioCtx.resume().catch((e) => {\n        console.warn(\"Audio resume failed:\", e);\n      });\n    }\n  }\n\n  // On first focus by keyboard, announce\n  canvas.addEventListener(\"focus\", () => {\n    updateLiveRegion(\"Game focused. Use the keyboard or click to interact.\");\n  });\n\n  // Provide error handling for audio creation on user gesture (some browsers require)\n  document.addEventListener(\"click\", function onFirstClick() {\n    if (!audioCtx && audioEnabled) {\n      try {\n        initAudio(true);\n        if (audioCtx && audioCtx.state === \"suspended\") {\n          audioCtx.resume().catch((e) => console.warn(\"Audio resume failed\", e));\n        }\n      } catch (e) {\n        console.warn(\"Error initializing audio on click:\", e);\n      }\n    }\n    document.removeEventListener(\"click\", onFirstClick);\n  });\n\n  // Utility: regenerate all levels when pressing R after victory\n  document.addEventListener(\"keydown\", (ev) => {\n    if (ev.key.toLowerCase() === \"r\") {\n      // Restart if all levels done or always restart current level\n      if (currentLevelIndex >= MAX_LEVELS - 1) {\n        // restart whole game\n        levels = generateLevels(MAX_LEVELS);\n        currentLevelIndex = 0;\n        setupLevel(currentLevelIndex);\n        updateLiveRegion(\"Game restarted. New levels are ready.\");\n      }\n    }\n  });\n\n  // Expose a minimal console command safe for debugging (not necessary)\n  window._machineMath = {\n    reset: () => {\n      currentLevelIndex = 0;\n      levels = generateLevels(MAX_LEVELS);\n      setupLevel(0);\n    },\n  };\n})();\n---\n",
  "improve_response_tokens": 21881,
  "formatted_code": true,
  "formatting_response_tokens": 23076,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}