{
  "generated_date": "2025-11-17",
  "generated_timestamp": "2025-11-17T00:29:47.049853",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9860,
  "game_filename": "2025-11-17.js",
  "game_size_bytes": 27874,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Drone Math Quest\n  // Rendered entirely inside the element with ID \"game-of-the-day-stage\"\n  // Canvas size: 720x480\n  // Controls: ArrowLeft/ArrowRight to move drone, 1-4 to choose answer, Enter/Space to select, R to restart, M to toggle audio\n  // Goal: 10 correct answers to win. 3 wrong answers -> Game Over.\n\n  // Strict mode\n  'use strict';\n\n  // Configuration\n  const CANVAS_WIDTH = 720;\n  const CANVAS_HEIGHT = 480;\n  const GOAL_SCORE = 10;\n  const MAX_WRONG = 3;\n  const DRONE_SPEED = 6;\n  const OPTION_COUNT = 4;\n  const PADDING = 12; // UI padding at least 10px required\n\n  // Get stage container\n  const stage = document.getElementById('game-of-the-day-stage');\n  if (!stage) {\n    console.error('Missing container element with id \"game-of-the-day-stage\". Game cannot start.');\n    return;\n  }\n\n  // Set ARIA label for text alternatives and keyboard instructions\n  stage.setAttribute(\n    'aria-label',\n    'Drone Math Quest. Use left and right arrow keys to move the drone. Press number keys 1 to 4 to choose an answer or click the answer boxes. Press M to toggle audio, R to restart.'\n  );\n  stage.tabIndex = 0; // make focusable\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = CANVAS_WIDTH;\n  canvas.height = CANVAS_HEIGHT;\n  canvas.style.width = CANVAS_WIDTH + 'px';\n  canvas.style.height = CANVAS_HEIGHT + 'px';\n  canvas.setAttribute('role', 'application');\n  canvas.setAttribute('aria-label', 'Drone Math Quest game canvas');\n  stage.innerHTML = ''; // clear content\n  stage.appendChild(canvas);\n\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    console.error('2D context not supported.');\n    return;\n  }\n\n  // Setup audio\n  let audioCtx = null;\n  let masterGain = null;\n  let backgroundOsc = null;\n  let audioAvailable = true;\n  try {\n    const AudioCtx = window.AudioContext || window.webkitAudioContext;\n    if (!AudioCtx) throw new Error('Web Audio API not supported in this browser.');\n    audioCtx = new AudioCtx();\n    masterGain = audioCtx.createGain();\n    masterGain.gain.value = 0.06; // gentle background volume\n    masterGain.connect(audioCtx.destination);\n\n    // Background gentle hum (low-frequency oscillator with slight modulation)\n    backgroundOsc = audioCtx.createOscillator();\n    backgroundOsc.type = 'sine';\n    backgroundOsc.frequency.value = 60; // low rumble\n    const bgGain = audioCtx.createGain();\n    bgGain.gain.value = 0.2;\n    backgroundOsc.connect(bgGain);\n    bgGain.connect(masterGain);\n    backgroundOsc.start();\n\n    // A slow LFO to modulate background gain for gentle variation\n    const lfo = audioCtx.createOscillator();\n    lfo.type = 'sine';\n    lfo.frequency.value = 0.12;\n    const lfoGain = audioCtx.createGain();\n    lfoGain.gain.value = 0.12;\n    lfo.connect(lfoGain);\n    lfoGain.connect(bgGain.gain);\n    lfo.start();\n  } catch (err) {\n    console.warn('Audio disabled:', err);\n    audioAvailable = false;\n  }\n\n  let soundOn = audioAvailable;\n\n  // Utility: play a quick beep sequence for correct answer\n  function playCorrectSound() {\n    if (!audioAvailable || !soundOn) return;\n    try {\n      const t0 = audioCtx.currentTime;\n      const freqs = [880, 1047, 1319]; // A5, C6, E6\n      freqs.forEach((f, i) => {\n        const o = audioCtx.createOscillator();\n        o.type = 'triangle';\n        o.frequency.value = f;\n        const g = audioCtx.createGain();\n        g.gain.value = 0;\n        o.connect(g);\n        g.connect(masterGain);\n        o.start(t0 + i * 0.09);\n        g.gain.setValueAtTime(0.0001, t0 + i * 0.09);\n        g.gain.exponentialRampToValueAtTime(0.3, t0 + i * 0.09 + 0.01);\n        g.gain.exponentialRampToValueAtTime(0.0001, t0 + i * 0.09 + 0.28);\n        o.stop(t0 + i * 0.09 + 0.3);\n      });\n    } catch (e) {\n      console.warn('Error playing correct sound', e);\n    }\n  }\n\n  // Utility: play a low buzz for incorrect answer\n  function playIncorrectSound() {\n    if (!audioAvailable || !soundOn) return;\n    try {\n      const t0 = audioCtx.currentTime;\n      const o = audioCtx.createOscillator();\n      o.type = 'sawtooth';\n      o.frequency.value = 180;\n      const g = audioCtx.createGain();\n      g.gain.value = 0.0001;\n      o.connect(g);\n      g.connect(masterGain);\n      o.start(t0);\n      g.gain.exponentialRampToValueAtTime(0.3, t0 + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.4);\n      o.frequency.setValueAtTime(180, t0);\n      o.frequency.exponentialRampToValueAtTime(80, t0 + 0.4);\n      o.stop(t0 + 0.45);\n    } catch (e) {\n      console.warn('Error playing incorrect sound', e);\n    }\n  }\n\n  // Game state\n  let drone = {\n    x: CANVAS_WIDTH / 2,\n    y: 140,\n    width: 120,\n    height: 50,\n    vx: 0\n  };\n\n  let score = 0;\n  let wrong = 0;\n  let currentQuestion = null;\n  let options = []; // {x,y,w,h,value,isCorrect}\n  let gameState = 'playing'; // playing, won, lost\n  let keysDown = {};\n  let lastInputTime = 0;\n  let cloudOffset = 0;\n\n  // For responsive text layout, fonts\n  const fonts = {\n    title: '28px sans-serif',\n    important: '20px sans-serif',\n    body: '16px sans-serif',\n    small: '14px sans-serif'\n  };\n\n  // Generate a new math question for foundational math (ages 7-9): addition/subtraction, simple multiplication or missing addend\n  function generateQuestion() {\n    const types = ['add', 'sub', 'missing'];\n    const type = types[Math.floor(Math.random() * types.length)];\n    if (type === 'add') {\n      const a = randInt(2, 12);\n      const b = randInt(2, 12);\n      const correct = a + b;\n      return {\n        text: `${a} + ${b} = ?`,\n        correct\n      };\n    } else if (type === 'sub') {\n      const a = randInt(5, 15);\n      const b = randInt(1, a - 1);\n      const correct = a - b;\n      return {\n        text: `${a} - ${b} = ?`,\n        correct\n      };\n    } else {\n      // missing addend, e.g., ? + 7 = 12\n      const b = randInt(2, 10);\n      const correct = randInt(2, 12);\n      const a = correct - b;\n      // Ensure positive\n      if (a < 0) return generateQuestion();\n      return {\n        text: `? + ${b} = ${correct}`,\n        correct: a\n      };\n    }\n  }\n\n  // Utility random\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  // Create options array with shuffled incorrect answers\n  function createOptions(correct) {\n    const set = new Set([correct]);\n    while (set.size < OPTION_COUNT) {\n      let delta = randInt(1, 6);\n      let candidate = Math.random() < 0.5 ? correct + delta : correct - delta;\n      if (candidate < 0) candidate = correct + delta + 2;\n      set.add(candidate);\n    }\n    const arr = Array.from(set);\n    // shuffle\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    return arr.map((v, idx) => ({ value: v, index: idx }));\n  }\n\n  // Place option rectangles in the canvas below drone\n  function layoutOptions(optionValues) {\n    options = [];\n    const margin = 30;\n    const areaWidth = CANVAS_WIDTH - margin * 2;\n    const gap = 18;\n    const boxW = (areaWidth - gap * (OPTION_COUNT - 1)) / OPTION_COUNT;\n    const boxH = 68;\n    const startX = margin;\n    const y = 260;\n    optionValues.forEach((opt, i) => {\n      const x = startX + i * (boxW + gap);\n      options.push({\n        x,\n        y,\n        w: boxW,\n        h: boxH,\n        value: opt.value,\n        isCorrect: opt.value === currentQuestion.correct,\n        index: i\n      });\n    });\n  }\n\n  // Initialize first question\n  function newQuestion() {\n    currentQuestion = generateQuestion();\n    const optVals = createOptions(currentQuestion.correct);\n    layoutOptions(optVals);\n  }\n\n  // Initialize game\n  function resetGame() {\n    score = 0;\n    wrong = 0;\n    drone.x = CANVAS_WIDTH / 2;\n    drone.vx = 0;\n    gameState = 'playing';\n    newQuestion();\n    lastInputTime = performance.now();\n  }\n\n  // Hit test for option click\n  function hitOption(x, y) {\n    for (const opt of options) {\n      if (x >= opt.x && x <= opt.x + opt.w && y >= opt.y && y <= opt.y + opt.h) {\n        return opt;\n      }\n    }\n    return null;\n  }\n\n  // Hit test for restart button in end screens (we will position it center)\n  function hitRestart(x, y) {\n    const btn = getRestartButtonRect();\n    return x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h;\n  }\n\n  function getRestartButtonRect() {\n    const w = 220;\n    const h = 52;\n    return {\n      x: CANVAS_WIDTH / 2 - w / 2,\n      y: CANVAS_HEIGHT / 2 + 60,\n      w,\n      h\n    };\n  }\n\n  // Player selects an option\n  function selectOption(opt) {\n    if (gameState !== 'playing') return;\n    if (!opt) return;\n    if (opt.isCorrect) {\n      score += 1;\n      playCorrectSound();\n      // small celebratory animation: bump drone upward briefly (handled in draw)\n      drone.y = 120; // temporarily raise\n      setTimeout(() => (drone.y = 140), 220);\n      if (score >= GOAL_SCORE) {\n        gameState = 'won';\n        // stop background hum gentle fade\n        if (audioAvailable && backgroundOsc) {\n          try {\n            masterGain.gain.exponentialRampToValueAtTime(0.02, audioCtx.currentTime + 0.9);\n          } catch (e) {}\n        }\n      } else {\n        newQuestion();\n      }\n    } else {\n      wrong += 1;\n      playIncorrectSound();\n      // visual cue: shake drone\n      const origX = drone.x;\n      let shakeTimes = 6;\n      const shakeInterval = setInterval(() => {\n        drone.x = origX + (Math.random() - 0.5) * 18;\n        shakeTimes--;\n        if (shakeTimes <= 0) {\n          clearInterval(shakeInterval);\n          drone.x = origX;\n        }\n      }, 50);\n      if (wrong >= MAX_WRONG) {\n        gameState = 'lost';\n      } else {\n        // keep same question, but regenerate options to keep it dynamic\n        const optVals = createOptions(currentQuestion.correct);\n        layoutOptions(optVals);\n      }\n    }\n  }\n\n  // Keyboard handlers\n  function keyDownHandler(e) {\n    lastInputTime = performance.now();\n    if (e.key === 'ArrowLeft') {\n      keysDown.ArrowLeft = true;\n      e.preventDefault();\n    } else if (e.key === 'ArrowRight') {\n      keysDown.ArrowRight = true;\n      e.preventDefault();\n    } else if (['1', '2', '3', '4'].includes(e.key)) {\n      // pick option\n      const idx = parseInt(e.key, 10) - 1;\n      if (options[idx]) {\n        selectOption(options[idx]);\n      }\n    } else if (e.key === 'Enter' || e.key === ' ') {\n      // attempt to pick the option under the drone horizontally\n      // find closest option to drone center\n      const centerX = drone.x;\n      let best = null;\n      let bestDist = Infinity;\n      for (const opt of options) {\n        const optCenter = opt.x + opt.w / 2;\n        const d = Math.abs(optCenter - centerX);\n        if (d < bestDist) {\n          bestDist = d;\n          best = opt;\n        }\n      }\n      if (best) selectOption(best);\n      e.preventDefault();\n    } else if (e.key.toLowerCase() === 'r') {\n      resetGame();\n    } else if (e.key.toLowerCase() === 'm') {\n      // Toggle audio\n      soundOn = !soundOn;\n      if (!soundOn) {\n        // reduce master gain\n        if (masterGain) masterGain.gain.setValueAtTime(0.0001, audioCtx ? audioCtx.currentTime : 0);\n      } else {\n        if (masterGain) masterGain.gain.setValueAtTime(0.06, audioCtx ? audioCtx.currentTime : 0);\n      }\n    }\n  }\n\n  function keyUpHandler(e) {\n    if (e.key === 'ArrowLeft') {\n      keysDown.ArrowLeft = false;\n      e.preventDefault();\n    } else if (e.key === 'ArrowRight') {\n      keysDown.ArrowRight = false;\n      e.preventDefault();\n    }\n  }\n\n  // Mouse / Pointer handlers\n  function pointerDownHandler(e) {\n    canvas.focus();\n    const rect = canvas.getBoundingClientRect();\n    const x = (e.clientX || e.touches && e.touches[0].clientX) - rect.left;\n    const y = (e.clientY || e.touches && e.touches[0].clientY) - rect.top;\n    if (gameState === 'playing') {\n      const hit = hitOption(x, y);\n      if (hit) {\n        selectOption(hit);\n        return;\n      }\n    } else {\n      if (hitRestart(x, y)) {\n        resetGame();\n        return;\n      }\n    }\n    // toggle audio icon if clicked top-right audio icon area\n    const audioIconRect = getAudioIconRect();\n    if (x >= audioIconRect.x && x <= audioIconRect.x + audioIconRect.w && y >= audioIconRect.y && y <= audioIconRect.y + audioIconRect.h) {\n      soundOn = !soundOn;\n      if (!soundOn) {\n        if (masterGain) masterGain.gain.setValueAtTime(0.0001, audioCtx ? audioCtx.currentTime : 0);\n      } else {\n        if (masterGain) masterGain.gain.setValueAtTime(0.06, audioCtx ? audioCtx.currentTime : 0);\n      }\n    }\n  }\n\n  // Setup event listeners\n  window.addEventListener('keydown', keyDownHandler);\n  window.addEventListener('keyup', keyUpHandler);\n  canvas.addEventListener('pointerdown', pointerDownHandler);\n\n  // Returns rectangle for audio icon placement (top-right)\n  function getAudioIconRect() {\n    const w = 40;\n    const h = 30;\n    return {\n      x: CANVAS_WIDTH - w - PADDING,\n      y: PADDING + 6,\n      w,\n      h\n    };\n  }\n\n  // Draw background calming and wacky: soft gradient + animated clouds and floating shapes\n  function drawBackground(dt) {\n    // Sky gradient\n    const g = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);\n    g.addColorStop(0, '#dff3ff');\n    g.addColorStop(1, '#ffffff');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n    // Gentle rolling hills\n    ctx.fillStyle = '#e6f7e8';\n    ctx.beginPath();\n    ctx.moveTo(0, CANVAS_HEIGHT);\n    ctx.quadraticCurveTo(180, 380 + Math.sin(performance.now() / 2000) * 6, 360, CANVAS_HEIGHT - 60);\n    ctx.quadraticCurveTo(520, 360 + Math.cos(performance.now() / 1800) * 8, CANVAS_WIDTH, CANVAS_HEIGHT - 30);\n    ctx.lineTo(CANVAS_WIDTH, CANVAS_HEIGHT);\n    ctx.closePath();\n    ctx.fill();\n\n    // Animated clouds (wacky rounded blobs)\n    cloudOffset += dt * 0.02;\n    for (let i = 0; i < 5; i++) {\n      const cx = ((i * 230) + cloudOffset * (i + 1) * 20) % (CANVAS_WIDTH + 200) - 100;\n      const cy = 40 + (i % 2) * 24;\n      drawCloud(cx, cy, 60 + (i % 3) * 12, 30 + (i % 2) * 8, `rgba(255,255,255,${0.9 - i * 0.12})`);\n    }\n\n    // Floating playful shapes\n    for (let i = 0; i < 6; i++) {\n      const x = ((i * 150) + cloudOffset * 12) % CANVAS_WIDTH;\n      const y = 340 + Math.sin((performance.now() / 800) + i) * 9;\n      ctx.fillStyle = `rgba(255, 205, ${150 + i * 8}, 0.12)`;\n      ctx.beginPath();\n      ctx.ellipse(x + 20, y, 40, 12 + (i % 3) * 3, Math.sin(i) * 0.6, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n\n  function drawCloud(cx, cy, rx, ry, color) {\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);\n    ctx.ellipse(cx - rx * 0.6, cy + 6, rx * 0.7, ry * 0.8, 0, 0, Math.PI * 2);\n    ctx.ellipse(cx + rx * 0.6, cy + 6, rx * 0.7, ry * 0.8, 0, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  // Draw drone (wacky, friendly)\n  function drawDrone() {\n    const x = drone.x;\n    const y = drone.y;\n    const w = drone.width;\n    const h = drone.height;\n\n    // shadow\n    ctx.fillStyle = 'rgba(0,0,0,0.08)';\n    ctx.beginPath();\n    ctx.ellipse(x, y + h + 16, w * 0.6, 10, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // body\n    ctx.fillStyle = '#a3d3ff';\n    roundRect(ctx, x - w / 2, y - h / 2, w, h, 12);\n    ctx.fill();\n\n    // cockpit\n    ctx.fillStyle = '#2b7bbf';\n    ctx.beginPath();\n    ctx.ellipse(x + 10, y - 6, w * 0.24, h * 0.48, -0.2, 0, Math.PI * 2);\n    ctx.fill();\n\n    // smiley face\n    ctx.fillStyle = '#ffffff';\n    ctx.beginPath();\n    ctx.arc(x + 20, y - 6, 6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = '#2b7bbf';\n    ctx.fillRect(x - 6, y + 2, 22, 4);\n\n    // rotors (wacky propellers)\n    for (let i = -1; i <= 1; i += 2) {\n      const rx = x + i * (w / 2 - 6);\n      const ry = y - h / 2 - 8;\n      ctx.fillStyle = '#ffe7c7';\n      roundRect(ctx, rx - 8, ry - 6, 16, 12, 6);\n      // blades\n      ctx.save();\n      ctx.translate(rx, ry);\n      ctx.rotate((performance.now() / 1000) * (i * 6));\n      ctx.fillStyle = 'rgba(40,40,50,0.7)';\n      ctx.fillRect(-36, -3, 72, 6);\n      ctx.restore();\n    }\n\n    // small antenna\n    ctx.fillStyle = '#2b7bbf';\n    ctx.fillRect(x + w / 2 - 26, y - h / 2 - 2, 4, 18);\n    ctx.fillStyle = '#ff6b6b';\n    ctx.beginPath();\n    ctx.arc(x + w / 2 - 24, y - h / 2 - 6, 5, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  // Draw options (packages)\n  function drawOptions() {\n    for (let i = 0; i < options.length; i++) {\n      const opt = options[i];\n      // package body\n      ctx.fillStyle = '#fff9e6';\n      roundRect(ctx, opt.x, opt.y, opt.w, opt.h, 10);\n      ctx.fill();\n      // box stripes\n      ctx.strokeStyle = '#ffd58a';\n      ctx.lineWidth = 2;\n      ctx.strokeRect(opt.x + 6, opt.y + 6, opt.w - 12, opt.h - 12);\n      // label\n      ctx.font = fonts.important;\n      ctx.fillStyle = '#333';\n      const text = (i + 1) + '. ' + opt.value;\n      const textMetrics = ctx.measureText(text);\n      // ensure text fits; if not reduce font\n      let f = fonts.important;\n      if (textMetrics.width > opt.w - 20) {\n        f = '16px sans-serif';\n      }\n      ctx.font = f;\n      const tw = ctx.measureText(text).width;\n      const tx = opt.x + opt.w / 2 - tw / 2;\n      const ty = opt.y + opt.h / 2 + 6;\n      // background rectangle behind text for readability\n      const textPad = 6;\n      const bgW = tw + textPad * 2;\n      const bgH = 26;\n      ctx.fillStyle = 'rgba(255,255,255,0.8)';\n      roundRect(ctx, tx - textPad, ty - 18, bgW, bgH, 6);\n      ctx.fill();\n      ctx.fillStyle = '#333';\n      ctx.fillText(text, tx, ty);\n    }\n  }\n\n  // Draw UI: score top-left, lives top-right, instructions bottom-center, audio icon\n  function drawUI() {\n    // Score top-left\n    ctx.font = fonts.important;\n    const scoreText = `Stars: ${score}/${GOAL_SCORE}`;\n    const scoreMetrics = ctx.measureText(scoreText);\n    const scorePadding = PADDING;\n    const scoreBoxW = scoreMetrics.width + scorePadding * 2;\n    const scoreBoxH = 36;\n    const scoreX = PADDING;\n    const scoreY = PADDING;\n    ctx.fillStyle = 'rgba(255,255,255,0.8)';\n    roundRect(ctx, scoreX, scoreY, scoreBoxW, scoreBoxH, 8);\n    ctx.fill();\n    ctx.fillStyle = '#003b5c';\n    ctx.fillText(scoreText, scoreX + scorePadding, scoreY + 24);\n\n    // Lives top-right\n    ctx.font = fonts.important;\n    const livesText = `Strikes: ${wrong}/${MAX_WRONG}`;\n    const livesMetrics = ctx.measureText(livesText);\n    const livesW = livesMetrics.width + scorePadding * 2;\n    const livesH = 36;\n    const livesX = CANVAS_WIDTH - livesW - PADDING - 46; // leave space for audio icon\n    const livesY = PADDING;\n    ctx.fillStyle = 'rgba(255,255,255,0.8)';\n    roundRect(ctx, livesX, livesY, livesW, livesH, 8);\n    ctx.fill();\n    ctx.fillStyle = '#8b0000';\n    ctx.fillText(livesText, livesX + scorePadding, livesY + 24);\n\n    // Audio icon top-right area\n    const audioRect = getAudioIconRect();\n    ctx.fillStyle = 'rgba(255,255,255,0.8)';\n    roundRect(ctx, audioRect.x, audioRect.y, audioRect.w, audioRect.h, 6);\n    ctx.fill();\n    // Draw speaker icon\n    ctx.strokeStyle = '#333';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(audioRect.x + 8, audioRect.y + audioRect.h / 2 - 6);\n    ctx.lineTo(audioRect.x + 18, audioRect.y + audioRect.h / 2 - 10);\n    ctx.lineTo(audioRect.x + 18, audioRect.y + audioRect.h / 2 + 10);\n    ctx.lineTo(audioRect.x + 8, audioRect.y + audioRect.h / 2 + 6);\n    ctx.closePath();\n    ctx.fillStyle = '#333';\n    ctx.fill();\n    // waves or cross\n    if (soundOn && audioAvailable) {\n      ctx.strokeStyle = '#2b7bbf';\n      ctx.beginPath();\n      ctx.arc(audioRect.x + 24, audioRect.y + audioRect.h / 2 - 2, 10, -Math.PI / 6, Math.PI / 6);\n      ctx.stroke();\n    } else {\n      // draw a small muted cross\n      ctx.strokeStyle = '#a0a0a0';\n      ctx.beginPath();\n      ctx.moveTo(audioRect.x + 22, audioRect.y + 8);\n      ctx.lineTo(audioRect.x + 36, audioRect.y + 22);\n      ctx.moveTo(audioRect.x + 36, audioRect.y + 8);\n      ctx.lineTo(audioRect.x + 22, audioRect.y + 22);\n      ctx.stroke();\n    }\n\n    // Bottom-center instructions\n    ctx.font = fonts.body;\n    const lines = [\n      'Move the drone with \u2190 \u2192 keys.',\n      'Choose the correct package (1\u20134 keys or click).',\n      'Collect 10 stars to win. 3 wrong = game over.',\n      'Press M to toggle audio. Press R to restart.'\n    ];\n    // compute widest line\n    let widest = 0;\n    ctx.font = fonts.body;\n    lines.forEach((l) => {\n      const w = ctx.measureText(l).width;\n      if (w > widest) widest = w;\n    });\n    const boxW = widest + PADDING * 2;\n    const boxH = lines.length * 20 + PADDING * 2;\n    const bx = CANVAS_WIDTH / 2 - boxW / 2;\n    const by = CANVAS_HEIGHT - boxH - PADDING;\n    ctx.fillStyle = 'rgba(255,255,255,0.85)';\n    roundRect(ctx, bx, by, boxW, boxH, 8);\n    ctx.fill();\n    ctx.fillStyle = '#073642';\n    ctx.font = fonts.body;\n    for (let i = 0; i < lines.length; i++) {\n      ctx.fillText(lines[i], bx + PADDING, by + PADDING + (i + 1) * 18 - 4);\n    }\n  }\n\n  // Draw question panel centered above options\n  function drawQuestionPanel() {\n    ctx.font = '22px sans-serif';\n    const qText = currentQuestion ? currentQuestion.text : '';\n    const metrics = ctx.measureText(qText);\n    const boxW = metrics.width + PADDING * 2;\n    const boxH = 44;\n    const bx = CANVAS_WIDTH / 2 - boxW / 2;\n    const by = 200 - boxH / 2;\n    ctx.fillStyle = 'rgba(255,255,255,0.9)';\n    roundRect(ctx, bx, by, boxW, boxH, 10);\n    ctx.fill();\n    ctx.fillStyle = '#0a3b5a';\n    ctx.fillText(qText, bx + PADDING, by + 28);\n  }\n\n  // Draw end screens\n  function drawEndScreen() {\n    // semi-transparent overlay\n    ctx.fillStyle = 'rgba(10,10,20,0.48)';\n    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n    ctx.textAlign = 'center';\n    if (gameState === 'won') {\n      ctx.font = '34px sans-serif';\n      const title = 'Victory! Drone Fleet Celebrates!';\n      const tm = ctx.measureText(title);\n      // background\n      const boxW = Math.min(CANVAS_WIDTH - 80, tm.width + 40);\n      const boxH = 140;\n      const bx = CANVAS_WIDTH / 2 - boxW / 2;\n      const by = CANVAS_HEIGHT / 2 - boxH / 2;\n      ctx.fillStyle = 'rgba(255,255,255,0.95)';\n      roundRect(ctx, bx, by, boxW, boxH, 12);\n      ctx.fill();\n      ctx.fillStyle = '#034f84';\n      ctx.fillText(title, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 8);\n      ctx.font = '18px sans-serif';\n      ctx.fillStyle = '#2b7bbf';\n      ctx.fillText(`You collected ${score} stars! Great job!`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 22);\n    } else if (gameState === 'lost') {\n      ctx.font = '34px sans-serif';\n      const title = 'Game Over \u2014 Oops!';\n      const tm = ctx.measureText(title);\n      const boxW = Math.min(CANVAS_WIDTH - 80, tm.width + 40);\n      const boxH = 140;\n      const bx = CANVAS_WIDTH / 2 - boxW / 2;\n      const by = CANVAS_HEIGHT / 2 - boxH / 2;\n      ctx.fillStyle = 'rgba(255,255,255,0.95)';\n      roundRect(ctx, bx, by, boxW, boxH, 12);\n      ctx.fill();\n      ctx.fillStyle = '#8b0000';\n      ctx.fillText(title, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 8);\n      ctx.font = '18px sans-serif';\n      ctx.fillStyle = '#6a3b3b';\n      ctx.fillText(`You had ${wrong} strikes. Try again!`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 22);\n    }\n    // Restart button\n    const btn = getRestartButtonRect();\n    ctx.fillStyle = '#ffd58a';\n    roundRect(ctx, btn.x, btn.y, btn.w, btn.h, 10);\n    ctx.fill();\n    ctx.fillStyle = '#333';\n    ctx.font = '20px sans-serif';\n    ctx.fillText('Restart Game (R)', btn.x + btn.w / 2, btn.y + btn.h / 2 + 7);\n    ctx.textAlign = 'start';\n  }\n\n  // Utility: draw rounded rectangle\n  function roundRect(ctx, x, y, w, h, r) {\n    const radius = Math.min(r, Math.min(w / 2, h / 2));\n    ctx.beginPath();\n    ctx.moveTo(x + radius, y);\n    ctx.arcTo(x + w, y, x + w, y + h, radius);\n    ctx.arcTo(x + w, y + h, x, y + h, radius);\n    ctx.arcTo(x, y + h, x, y, radius);\n    ctx.arcTo(x, y, x + w, y, radius);\n    ctx.closePath();\n  }\n\n  // Main loop\n  let lastTime = performance.now();\n  function loop(now) {\n    const dt = now - lastTime;\n    lastTime = now;\n\n    // Update\n    update(dt);\n\n    // Clear canvas\n    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n    // Draw\n    drawBackground(dt);\n    drawOptions();\n    drawDrone();\n    drawQuestionPanel();\n    drawUI();\n\n    // Draw helpful aiming line from drone to nearest option\n    ctx.strokeStyle = 'rgba(0,90,120,0.08)';\n    ctx.lineWidth = 2;\n    const centerX = drone.x;\n    let nearest = null;\n    let nd = Infinity;\n    for (const opt of options) {\n      const cx = opt.x + opt.w / 2;\n      const d = Math.abs(cx - centerX);\n      if (d < nd) {\n        nd = d;\n        nearest = opt;\n      }\n    }\n    if (nearest) {\n      ctx.beginPath();\n      ctx.moveTo(centerX, drone.y + drone.height / 2);\n      ctx.lineTo(nearest.x + nearest.w / 2, nearest.y);\n      ctx.stroke();\n      // highlight nearest option background for focus\n      ctx.strokeStyle = 'rgba(43,123,191,0.12)';\n      ctx.lineWidth = 6;\n      ctx.strokeRect(nearest.x + 4, nearest.y + 4, nearest.w - 8, nearest.h - 8);\n    }\n\n    // Draw end screen overlay if ended\n    if (gameState === 'won' || gameState === 'lost') {\n      drawEndScreen();\n    }\n\n    requestAnimationFrame(loop);\n  }\n\n  function update(dt) {\n    if (gameState !== 'playing') return;\n\n    // Move drone based on keys\n    if (keysDown.ArrowLeft) {\n      drone.vx = -DRONE_SPEED;\n    } else if (keysDown.ArrowRight) {\n      drone.vx = DRONE_SPEED;\n    } else {\n      drone.vx = 0;\n    }\n    drone.x += drone.vx;\n\n    // Boundaries\n    const halfW = drone.width / 2;\n    if (drone.x < halfW + 8) drone.x = halfW + 8;\n    if (drone.x > CANVAS_WIDTH - halfW - 8) drone.x = CANVAS_WIDTH - halfW - 8;\n\n    // gentle bobbing for drone's y when idle\n    const bob = Math.sin(performance.now() / 420) * 2;\n    if (drone.y !== 140) {\n      // if temporarily raised by correct, do not override immediately\n    } else {\n      drone.y = 140 + bob;\n    }\n  }\n\n  // Initialize fonts and measurement (ensure minimum font sizes)\n  function initFonts() {\n    ctx.font = fonts.title;\n    ctx.textBaseline = 'top';\n  }\n\n  // Start game logic\n  initFonts();\n  resetGame();\n  requestAnimationFrame(loop);\n\n  // Ensure canvas text rendering spacing minimum 10px is respected in draw functions:\n  // - We used PADDING = 12 for boxes and ensured UI placement leaves space.\n\n  // Expose a small debug console on the stage element in case of audio error\n  if (!audioAvailable) {\n    const warnText = document.createElement('div');\n    warnText.innerText = 'Audio not available';\n    warnText.style.position = 'absolute';\n    warnText.style.left = '8px';\n    warnText.style.top = '8px';\n    warnText.style.background = 'rgba(255,255,255,0.6)';\n    warnText.style.padding = '4px 8px';\n    warnText.style.borderRadius = '6px';\n    warnText.style.fontSize = '12px';\n    stage.appendChild(warnText);\n  }\n\n  // Error handling examples for audio on resume attempts\n  stage.addEventListener('click', () => {\n    if (!audioAvailable) return;\n    // Try to resume audio context if suspended (some browsers require user gesture)\n    if (audioCtx && audioCtx.state === 'suspended') {\n      audioCtx.resume().catch((e) => {\n        console.warn('AudioContext resume failed:', e);\n      });\n    }\n  });\n\n  // Accessibility: keyboard focus and instructions drawn on canvas; also ensure canvas focus\n  canvas.addEventListener('focus', () => {\n    // nothing else needed; instructions are shown visually\n  });\n\n  // Prevent accidental selection\n  canvas.addEventListener('mousedown', (e) => e.preventDefault());\n\n  // Clean up on unload\n  window.addEventListener('unload', () => {\n    try {\n      if (backgroundOsc) backgroundOsc.stop();\n      if (audioCtx && typeof audioCtx.close === 'function') audioCtx.close();\n    } catch (e) {}\n  });\n})();\n---\n",
  "improve_response_tokens": 19388,
  "formatted_code": true,
  "formatting_response_tokens": 20830,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}