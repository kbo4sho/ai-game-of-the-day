# Game of the Day - 2025-09-25

## Metadata
- **Generated Date:** 2025-09-25
- **Generated Time:** 2025-09-25T00:26:32.402579
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-25.js
- **File Size:** 27486 bytes
- **Tokens Used:** 9250

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-25.js` - The playable game
- `2025-09-25.meta.json` - Machine-readable metadata
- `2025-09-25.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 19016

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 20955

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function() {
  // Machine Math — Canvas Game for Ages 7-9
  // Renders inside element with id "game-of-the-day-stage"
  // All visuals drawn with canvas. Sounds made with Web Audio API oscillators.
  // Keyboard: ← → move, Space pick/drop, Enter submit, M mute, R reset level
  // Accessible live text updates added for screen readers.

  // Constants
  const WIDTH = 720;
  const HEIGHT = 480;
  const STAGE_ID = "game-of-the-day-stage";
  const MAX_LEVEL = 6;
  const NUM_BUBBLES = 5;
  const SLOT_COUNT = 3;

  // Colors and styling
  const COLORS = {
    bg: "#f2f7fb",
    machine: "#D6EAF8",
    accent: "#8EC5FF",
    gear: "#B2D3E8",
    text: "#21495A",
    bubble: "#F7D6A5",
    bubbleText: "#3E3E3E",
    robot: "#C6EBC5",
    slotEmpty: "#EDEDED",
    slotFilled: "#F8E1E7",
    good: "#4BB543",
    bad: "#E04E4E",
    speakerOn: "#21495A",
    speakerOff: "#A0A0A0"
  };

  // Helper utilities
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function clamp(v, a, b) {
    return Math.max(a, Math.min(b, v));
  }

  function safeAudioContext() {
    try {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) return null;
      return new Ctx();
    } catch (e) {
      return null;
    }
  }

  // Get stage element
  const stage = document.getElementById(STAGE_ID);
  if (!stage) {
    console.error("Game stage element not found:", STAGE_ID);
    return;
  }

  // Create an offscreen live region for screen readers inside the stage element
  const liveRegion = document.createElement("div");
  liveRegion.setAttribute("aria-live", "polite");
  liveRegion.setAttribute("role", "status");
  // Visually hide but keep accessible
  liveRegion.style.position = "absolute";
  liveRegion.style.left = "-9999px";
  liveRegion.style.top = "auto";
  stage.appendChild(liveRegion);

  // Create canvas exactly 720x480
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute("role", "img");
  canvas.setAttribute("aria-label", "Machine Math game. Move robot with left and right arrow keys, pick up numbers with space, submit with Enter. Press M to mute sound.");
  stage.appendChild(canvas);
  const ctx = canvas.getContext("2d");

  // Game state
  let state = {
    level: 1,
    target: 0,
    bubbles: [], // {x,y,val,visible}
    slots: new Array(SLOT_COUNT).fill(null), // each holds a number or null
    robot: { x: WIDTH / 2, y: HEIGHT - 70, speed: 6, holding: null },
    score: 0,
    message: "Welcome! Press Space to pick up a number.",
    messageTimer: 0,
    audioEnabled: false,
    audioAvailable: true,
    muted: false,
    bgHum: null, // background oscillator
    soundContext: null,
    awaitingUserGesture: true,
    levelSolved: false
  };

  // Audio utilities and sounds
  function initAudio() {
    if (state.soundContext) return;
    try {
      const ctxAudio = safeAudioContext();
      if (!ctxAudio) {
        state.audioAvailable = false;
        console.warn("Web Audio API not available.");
        liveAnnounce("Audio is not available in your browser.");
        return;
      }
      state.soundContext = ctxAudio;
      // Create a gentle background hum (low volume)
      try {
        const humOsc = ctxAudio.createOscillator();
        humOsc.type = "sine";
        humOsc.frequency.value = 60; // low hum
        const humGain = ctxAudio.createGain();
        humGain.gain.value = 0.0025; // very gentle background
        humOsc.connect(humGain).connect(ctxAudio.destination);
        humOsc.start();
        state.bgHum = { osc: humOsc, gain: humGain };
        state.audioAvailable = true;
      } catch (err) {
        console.warn("Background hum error:", err);
      }
    } catch (err) {
      state.audioAvailable = false;
      console.warn("Failed to initialize audio:", err);
      liveAnnounce("Audio initialization failed.");
    }
  }

  function resumeAudioOnUserGesture() {
    if (!state.soundContext) return;
    const ctx = state.soundContext;
    if (ctx.state === "suspended") {
      ctx.resume().then(() => {
        state.awaitingUserGesture = false;
        state.audioEnabled = !state.muted;
      }).catch(err => {
        console.warn("Audio resume failed:", err);
      });
    }
  }

  function stopAllSounds() {
    if (!state.soundContext) return;
    try {
      if (state.bgHum && state.bgHum.osc) {
        try { state.bgHum.osc.stop(); } catch (e) {}
        state.bgHum.osc.disconnect();
        state.bgHum.gain.disconnect();
      }
    } catch (e) {
      console.warn("Error stopping sounds:", e);
    }
    state.bgHum = null;
    // Close context if possible
    if (state.soundContext.close) {
      state.soundContext.close().catch(() => {});
    }
    state.soundContext = null;
  }

  function playToneSequence(tones = [], options = {}) {
    if (!state.audioAvailable || state.muted) return;
    if (!state.soundContext) return;
    try {
      const ctx = state.soundContext;
      const now = ctx.currentTime;
      const masterGain = ctx.createGain();
      masterGain.gain.value = options.volume ?? 0.08;
      masterGain.connect(ctx.destination);
      let t = now;
      tones.forEach((tone, i) => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = tone.type || "sine";
        osc.frequency.value = tone.freq;
        gain.gain.setValueAtTime(0.0001, t);
        gain.gain.exponentialRampToValueAtTime(1, t + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.001, t + (tone.dur ?? 0.15));
        osc.connect(gain).connect(masterGain);
        osc.start(t);
        osc.stop(t + (tone.dur ?? 0.15) + 0.02);
        t += (tone.dur ?? 0.15) + (tone.pause ?? 0.02);
      });
      // cleanup after longest tone
      setTimeout(() => {
        try { masterGain.disconnect(); } catch (e) {}
      }, 1000);
    } catch (err) {
      console.warn("playToneSequence error:", err);
    }
  }

  function playCorrect() {
    // pleasant ascending arpeggio
    playToneSequence([
      { freq: 440, dur: 0.12, type: "sine" },
      { freq: 550, dur: 0.12, type: "sine" },
      { freq: 660, dur: 0.16, type: "sine" }
    ], { volume: 0.06 });
  }

  function playIncorrect() {
    // low buzz
    playToneSequence([
      { freq: 120, dur: 0.25, type: "sawtooth" }
    ], { volume: 0.12 });
  }

  function playPick() {
    playToneSequence([{ freq: 660, dur: 0.08 }], { volume: 0.04 });
  }

  function playDrop() {
    playToneSequence([{ freq: 330, dur: 0.08 }], { volume: 0.04 });
  }

  // Accessibility live announcements
  function liveAnnounce(text) {
    if (!liveRegion) return;
    liveRegion.textContent = "";
    // Short timeout to ensure SR reads new text
    setTimeout(() => liveRegion.textContent = text, 50);
  }

  // Level generation ensuring solvability
  function generateLevel(level) {
    // Construct a set of numbers with a guaranteed solution
    const bubbles = [];
    const subsetSize = Math.min(1 + (level % 3), SLOT_COUNT); // 1 to 3
    const baseNumbers = [];
    for (let i = 0; i < subsetSize; i++) {
      baseNumbers.push(randInt(1 + level, 4 + level + 4)); // slightly increasing
    }
    const target = baseNumbers.reduce((a, b) => a + b, 0);

    // Fill additional numbers
    while (baseNumbers.length < NUM_BUBBLES) {
      // Avoid creating duplicates of the exact target parts too often
      const candidate = randInt(1, Math.max(6, 6 + level));
      baseNumbers.push(candidate);
    }

    // Shuffle and position them
    for (let i = 0; i < NUM_BUBBLES; i++) {
      const val = baseNumbers[i];
      const x = 120 + (i % 3) * 90 + randInt(-6, 6);
      const y = 110 + Math.floor(i / 3) * 80 + randInt(-6, 6);
      bubbles.push({ x, y, val, visible: true, id: i });
    }

    return { target, bubbles };
  }

  // Initialize or reset the level
  function startLevel(levelNumber) {
    const lvl = clamp(levelNumber, 1, MAX_LEVEL);
    state.level = lvl;
    state.slots = new Array(SLOT_COUNT).fill(null);
    state.robot.holding = null;
    state.levelSolved = false;
    const lvlData = generateLevel(lvl);
    state.target = lvlData.target;
    state.bubbles = lvlData.bubbles;
    state.message = `Level ${lvl} — Make the machine equal ${state.target}.`;
    state.messageTimer = 300; // frames
    liveAnnounce(`Level ${lvl}. Target number ${state.target}. Use arrows to move robot and space to pick up numbers.`);
  }

  // Check if subset of slots sums to target
  function checkSolution() {
    const sum = state.slots.reduce((acc, s) => acc + (s === null ? 0 : s), 0);
    if (sum === state.target) {
      // Win
      state.score += 10 * state.level;
      state.levelSolved = true;
      state.message = "Correct! Machine is happy.";
      state.messageTimer = 240;
      playCorrect();
      liveAnnounce(`Correct! You solved level ${state.level}.`);
      // Proceed to next level after short delay
      setTimeout(() => {
        if (state.level < MAX_LEVEL) {
          startLevel(state.level + 1);
        } else {
          state.message = "You finished all levels! Great job!";
          liveAnnounce("Congratulations! You finished all levels!");
        }
      }, 1500);
    } else {
      // Incorrect
      state.message = `Not quite. Current sum ${sum}, target ${state.target}. Try again.`;
      state.messageTimer = 240;
      playIncorrect();
      liveAnnounce(`Try again. Current sum ${sum}, target ${state.target}.`);
      // Reset slots and return numbers back
      state.slots.forEach((s, idx) => {
        if (s !== null) {
          // find a hidden spot to put it back
          const bubble = state.bubbles.find(b => b.val === s && !b.visible);
          if (bubble) {
            bubble.visible = true;
          } else {
            // create a new bubble to avoid loss
            state.bubbles.push({ x: 120 + (idx * 60) % 240, y: 240, val: s, visible: true, id: Date.now() + idx });
          }
        }
      });
      state.slots = new Array(SLOT_COUNT).fill(null);
      state.robot.holding = null;
    }
  }

  // Robot picks up the nearest visible bubble within range
  function robotPickOrDrop() {
    const r = state.robot;
    if (r.holding === null) {
      // Try pick a bubble near robot
      let nearest = null;
      let nearestDist = 9999;
      for (const b of state.bubbles) {
        if (!b.visible) continue;
        const dx = b.x - r.x;
        const dy = b.y - r.y;
        const d = Math.hypot(dx, dy);
        if (d < nearestDist && d < 60) {
          nearestDist = d;
          nearest = b;
        }
      }
      if (nearest) {
        r.holding = { val: nearest.val, id: nearest.id };
        nearest.visible = false;
        state.message = `Picked up ${r.holding.val}.`;
        state.messageTimer = 140;
        playPick();
        liveAnnounce(`Picked up ${r.holding.val}.`);
      } else {
        state.message = "No number close enough to pick. Move closer.";
        state.messageTimer = 120;
      }
    } else {
      // Try drop into an empty slot if robot is near machine
      const machineX = WIDTH - 220;
      const machineY = HEIGHT / 2;
      const dx = r.x - machineX;
      const dy = r.y - machineY;
      const d = Math.hypot(dx, dy);
      if (d < 120) {
        // find empty slot
        let placed = false;
        for (let i = 0; i < SLOT_COUNT; i++) {
          if (state.slots[i] === null) {
            state.slots[i] = r.holding.val;
            r.holding = null;
            state.message = "Dropped into machine.";
            state.messageTimer = 120;
            playDrop();
            liveAnnounce("Dropped number into machine.");
            placed = true;
            break;
          }
        }
        if (!placed) {
          state.message = "All machine slots are full. Press Enter to check or remove a number.";
          state.messageTimer = 160;
        }
      } else {
        // drop back to nearest bubble area (failsafe)
        const droppedBack = { x: r.x + randInt(-20, 20), y: r.y + randInt(-20, 20), val: r.holding.val, visible: true, id: Date.now() };
        state.bubbles.push(droppedBack);
        r.holding = null;
        playDrop();
        state.message = "Dropped the number back.";
        state.messageTimer = 120;
      }
    }
  }

  // Remove a filled slot (player can move robot near machine and press Space to pick a number out)
  function robotPickupFromSlot() {
    const r = state.robot;
    const machineX = WIDTH - 220;
    const machineY = HEIGHT / 2;
    const dx = r.x - machineX;
    const dy = r.y - machineY;
    const d = Math.hypot(dx, dy);
    if (d < 120 && r.holding === null) {
      // pick from last non-empty slot
      for (let i = SLOT_COUNT - 1; i >= 0; i--) {
        if (state.slots[i] !== null) {
          r.holding = { val: state.slots[i], fromSlot: i };
          state.slots[i] = null;
          playPick();
          state.message = `Picked up ${r.holding.val} from slot ${i + 1}.`;
          state.messageTimer = 140;
          liveAnnounce(`Picked up ${r.holding.val} from slot ${i + 1}.`);
          return true;
        }
      }
      state.message = "No numbers in machine to pick up.";
      state.messageTimer = 120;
      return false;
    }
    return false;
  }

  // Keyboard and mouse controls
  const keys = {};
  window.addEventListener("keydown", (e) => {
    if (e.key === "ArrowLeft" || e.key === "ArrowRight" || e.key === " " || e.key === "Enter" || e.key === "m" || e.key === "M" || e.key === "r" || e.key === "R") {
      e.preventDefault();
    }
    keys[e.key] = true;

    // initialize audio on first user gesture
    if (state.awaitingUserGesture) {
      initAudio();
      resumeAudioOnUserGesture();
      state.awaitingUserGesture = false;
    }

    // Shortcuts
    if (e.key === "m" || e.key === "M") {
      state.muted = !state.muted;
      if (state.muted) {
        liveAnnounce("Audio muted.");
      } else {
        liveAnnounce("Audio unmuted.");
      }
    }
    if (e.key === "r" || e.key === "R") {
      startLevel(state.level);
      liveAnnounce(`Level ${state.level} restarted.`);
    }
  });

  window.addEventListener("keyup", (e) => {
    keys[e.key] = false;
  });

  // Allow clicking/tapping to pick/drop
  canvas.addEventListener("click", (ev) => {
    // initialize audio on user gesture
    if (state.awaitingUserGesture) {
      initAudio();
      resumeAudioOnUserGesture();
      state.awaitingUserGesture = false;
      liveAnnounce("Audio enabled.");
    }
    const rect = canvas.getBoundingClientRect();
    const cx = ev.clientX - rect.left;
    const cy = ev.clientY - rect.top;
    // If clicked near speaker icon toggle mute
    if (cx < 46 && cy < 46) {
      state.muted = !state.muted;
      liveAnnounce(state.muted ? "Audio muted." : "Audio unmuted.");
      return;
    }
    // If near robot, pick/drop
    const r = state.robot;
    const dx = cx - r.x;
    const dy = cy - r.y;
    if (Math.hypot(dx, dy) < 80) {
      // if near machine area and holding something then drop, else pick
      if (state.robot.holding !== null) {
        robotPickOrDrop();
      } else {
        // try pick from slot first if clicking near machine
        const machineX = WIDTH - 220;
        const machineY = HEIGHT / 2;
        const d2 = Math.hypot(cx - machineX, cy - machineY);
        if (d2 < 120) {
          robotPickupFromSlot();
        } else {
          robotPickOrDrop();
        }
      }
      return;
    }
    // Else click nearest bubble to pick directly
    let picked = false;
    for (const b of state.bubbles) {
      if (b.visible) {
        const dbx = cx - b.x;
        const dby = cy - b.y;
        if (Math.hypot(dbx, dby) < 28) {
          // move robot near to that bubble and pick
          state.robot.x = clamp(b.x, 40, WIDTH - 40);
          state.robot.y = clamp(b.y + 40, HEIGHT - 120, HEIGHT - 40);
          if (!state.robot.holding) {
            state.robot.holding = { val: b.val, id: b.id };
            b.visible = false;
            state.message = `Picked up ${b.val}.`;
            state.messageTimer = 120;
            playPick();
            liveAnnounce(`Picked up ${b.val}.`);
          }
          picked = true;
          break;
        }
      }
    }
    if (!picked) {
      // if clicked on machine area, try to pick from slot
      const machineX = WIDTH - 220;
      const machineY = HEIGHT / 2;
      if (Math.hypot(cx - machineX, cy - machineY) < 140) {
        robotPickupFromSlot();
      }
    }
  });

  // Main update loop
  function update() {
    // Movement
    if (keys["ArrowLeft"]) {
      state.robot.x -= state.robot.speed;
      if (state.robot.x < 40) state.robot.x = 40;
    }
    if (keys["ArrowRight"]) {
      state.robot.x += state.robot.speed;
      if (state.robot.x > WIDTH - 40) state.robot.x = WIDTH - 40;
    }

    // Pick/drop with space
    if (keys[" "]) {
      if (!state._spaceHeld) {
        // single action on press
        // if near machine and holding nothing, pick from slot
        const machineX = WIDTH - 220;
        const machineY = HEIGHT / 2;
        const d = Math.hypot(state.robot.x - machineX, state.robot.y - machineY);
        if (d < 120 && state.robot.holding === null) {
          robotPickupFromSlot();
        } else {
          robotPickOrDrop();
        }
        state._spaceHeld = true;
      }
    } else {
      state._spaceHeld = false;
    }

    // Submit with Enter
    if (keys["Enter"]) {
      if (!state._enterHeld) {
        checkSolution();
        state._enterHeld = true;
      }
    } else {
      state._enterHeld = false;
    }

    // Update bubble floatiness
    for (const b of state.bubbles) {
      if (!b.visible) continue;
      // small up/down drifting
      b.y += Math.sin((Date.now() + b.id * 47) / 500) * 0.2;
      b.x += Math.cos((Date.now() + b.id * 31) / 700) * 0.08;
    }

    // message timer decay
    if (state.messageTimer > 0) {
      state.messageTimer--;
      if (state.messageTimer === 0) {
        state.message = "";
      }
    }
  }

  // Drawing functions
  function drawBackground() {
    // sky background
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // faint diagonal stripes for a calming pattern
    ctx.save();
    ctx.globalAlpha = 0.08;
    ctx.fillStyle = COLORS.accent;
    for (let i = -HEIGHT; i < WIDTH; i += 40) {
      ctx.beginPath();
      ctx.moveTo(i, 0);
      ctx.lineTo(i + 20, 0);
      ctx.lineTo(i + HEIGHT + 20, HEIGHT);
      ctx.lineTo(i + HEIGHT, HEIGHT);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();

    // Ground platform
    ctx.fillStyle = "#e9f4f8";
    ctx.fillRect(0, HEIGHT - 80, WIDTH, 80);

    // Wacky pipes on left
    ctx.save();
    ctx.translate(40, 40);
    for (let i = 0; i < 3; i++) {
      ctx.fillStyle = i % 2 === 0 ? COLORS.gear : COLORS.machine;
      ctx.fillRect(i * 40, 60 + i * 14, 100, 18);
      ctx.beginPath();
      ctx.arc(i * 40 + 8, 60 + i * 14 + 9, 12, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();

    // Large soothing gear shapes
    drawGear(180, 70, 40, 8, COLORS.gear, 0.08);
    drawGear(260, 50, 28, 6, COLORS.gear, -0.05);
    drawGear(110, 130, 22, 6, COLORS.gear, 0.06);
  }

  function drawGear(cx, cy, radius, teeth, color, rotateOffset) {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate((Date.now() / 500) * rotateOffset);
    ctx.fillStyle = color;
    for (let i = 0; i < teeth; i++) {
      ctx.beginPath();
      const a1 = (i / teeth) * Math.PI * 2;
      const a2 = a1 + (Math.PI * 2 / teeth) * 0.6;
      ctx.moveTo(Math.cos(a1) * radius, Math.sin(a1) * radius);
      ctx.lineTo(Math.cos(a1) * (radius + 8), Math.sin(a1) * (radius + 8));
      ctx.lineTo(Math.cos(a2) * radius, Math.sin(a2) * radius);
      ctx.closePath();
      ctx.fill();
    }
    ctx.beginPath();
    ctx.fillStyle = "#fff";
    ctx.arc(0, 0, radius - 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawBubbles() {
    for (const b of state.bubbles) {
      if (!b.visible) continue;
      ctx.save();
      ctx.beginPath();
      ctx.fillStyle = COLORS.bubble;
      ctx.strokeStyle = "#d1bfa9";
      ctx.lineWidth = 2;
      ctx.arc(b.x, b.y, 28, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // subtle highlight
      ctx.beginPath();
      ctx.fillStyle = "rgba(255,255,255,0.6)";
      ctx.ellipse(b.x - 10, b.y - 12, 10, 6, -0.5, 0, Math.PI * 2);
      ctx.fill();

      // number
      ctx.fillStyle = COLORS.bubbleText;
      ctx.font = "bold 18px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(b.val), b.x, b.y);
      ctx.restore();
    }
  }

  function drawMachine() {
    const mx = WIDTH - 320;
    const my = HEIGHT / 2 - 40;
    // Machine body
    ctx.save();
    ctx.fillStyle = COLORS.machine;
    roundRect(ctx, mx, my, 300, 260, 18, true, false);
    // control panel
    ctx.fillStyle = "#cfeaf6";
    roundRect(ctx, mx + 20, my + 18, 260, 60, 10, true, false);

    // display target
    ctx.fillStyle = COLORS.accent;
    roundRect(ctx, mx + 40, my + 28, 200, 36, 8, true, false);
    ctx.fillStyle = COLORS.text;
    ctx.font = "bold 22px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("TARGET: " + state.target, mx + 140, my + 52);

    // draw slots
    const slotStartX = mx + 42;
    const slotY = my + 110;
    for (let i = 0; i < SLOT_COUNT; i++) {
      const sx = slotStartX + i * 90;
      ctx.fillStyle = state.slots[i] === null ? COLORS.slotEmpty : COLORS.slotFilled;
      roundRect(ctx, sx, slotY, 70, 70, 10, true, true);
      if (state.slots[i] !== null) {
        // fill number inside
        ctx.fillStyle = COLORS.bubbleText;
        ctx.font = "bold 26px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(String(state.slots[i]), sx + 35, slotY + 35);
      } else {
        // draw small indicator
        ctx.fillStyle = "#c6d3db";
        ctx.font = "12px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("slot " + (i + 1), sx + 35, slotY + 60);
      }
    }

    // Machine smiley (if solved)
    ctx.fillStyle = state.levelSolved ? COLORS.good : "#7fb2c9";
    ctx.beginPath();
    ctx.ellipse(mx + 180, my + 200, 36, 24, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#fff";
    ctx.font = "12px sans-serif";
    ctx.fillText(state.levelSolved ? "Machine happy" : "Machine", mx + 180, my + 200);
    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  function drawRobot() {
    const r = state.robot;
    ctx.save();
    ctx.translate(r.x, r.y);

    // shadow
    ctx.beginPath();
    ctx.fillStyle = "rgba(30,30,30,0.08)";
    ctx.ellipse(0, 46, 46, 14, 0, 0, Math.PI * 2);
    ctx.fill();

    // body
    ctx.fillStyle = COLORS.robot;
    roundRect(ctx, -28, -28, 56, 56, 8, true, true);
    // head
    ctx.fillStyle = "#fff";
    roundRect(ctx, -20, -50, 40, 30, 6, true, true);
    // eye
    ctx.fillStyle = "#21495A";
    ctx.beginPath();
    ctx.arc(0, -35, 5, 0, Math.PI * 2);
    ctx.fill();

    // arms
    ctx.strokeStyle = "#bde5c9";
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.moveTo(-20, -10);
    ctx.lineTo(-42, 8);
    ctx.moveTo(20, -10);
    ctx.lineTo(48, 20);
    ctx.stroke();

    // wheel
    ctx.fillStyle = "#cbdfe1";
    ctx.beginPath();
    ctx.arc(0, 38, 22, 0, Math.PI * 2);
    ctx.fill();

    // holding number bubble (if any)
    if (r.holding) {
      ctx.save();
      ctx.translate(36, -8);
      ctx.beginPath();
      ctx.fillStyle = COLORS.bubble;
      ctx.arc(0, 0, 20, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = COLORS.bubbleText;
      ctx.font = "bold 16px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(r.holding.val), 0, 0);
      ctx.restore();
    }

    ctx.restore();
  }

  function drawHUD() {
    // Top-left speaker icon
    ctx.save();
    ctx.translate(12, 12);
    ctx.beginPath();
    ctx.fillStyle = state.muted ? COLORS.speakerOff : COLORS.speakerOn;
    ctx.fillRect(0, 10, 8, 12);
    ctx.beginPath();
    ctx.moveTo(10, 10);
    ctx.lineTo(20, 6);
    ctx.lineTo(20, 26);
    ctx.lineTo(10, 22);
    ctx.closePath();
    ctx.fill();

    if (!state.muted) {
      ctx.beginPath();
      ctx.strokeStyle = COLORS.speakerOn;
      ctx.lineWidth = 2;
      ctx.arc(26, 16, 8, -0.9, 0.9);
      ctx.stroke();
    } else {
      // cross
      ctx.strokeStyle = COLORS.speakerOff;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(6, 6);
      ctx.lineTo(34, 26);
      ctx.moveTo(34, 6);
      ctx.lineTo(6, 26);
      ctx.stroke();
    }
    ctx.restore();

    // Level and score
    ctx.fillStyle = COLORS.text;
    ctx.font = "16px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText(`Level ${state.level}`, 12, 60);
    ctx.fillText(`Score ${state.score}`, 12, 82);

    // Instructions
    ctx.font = "12px sans-serif";
    ctx.fillStyle = "#29586a";
    ctx.fillText("← → to move  •  Space to pick/drop  •  Enter to check  •  M to mute  •  R restart", 120, 28);

    // Message box
    if (state.message) {
      ctx.save();
      ctx.globalAlpha = 0.95;
      roundRect(ctx, WIDTH / 2 - 200, 18, 400, 36, 8, true, false);
      ctx.fillStyle = COLORS.text;
      ctx.font = "14px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(state.message, WIDTH / 2, 42);
      ctx.restore();
    }
  }

  function draw() {
    // Clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    // Draw everything
    drawBackground();
    drawBubbles();
    drawMachine();
    drawRobot();
    drawHUD();
  }

  // Main loop
  function loop() {
    try {
      update();
      draw();
      requestAnimationFrame(loop);
    } catch (err) {
      console.error("Game loop error:", err);
    }
  }

  // Initial start
  startLevel(1);
  initAudio(); // attempt silent init; will be resumed on gesture
  loop();

  // Expose a safe reset method on the canvas element for debug or accessibility
  canvas.resetGame = function() {
    stopAllSounds();
    state = {
      level: 1,
      target: 0,
      bubbles: [],
      slots: new Array(SLOT_COUNT).fill(null),
      robot: { x: WIDTH / 2, y: HEIGHT - 70, speed: 6, holding: null },
      score: 0,
      message: "Resetting game.",
      messageTimer: 120,
      audioEnabled: false,
      audioAvailable: true,
      muted: false,
      bgHum: null,
      soundContext: null,
      awaitingUserGesture: true,
      levelSolved: false
    };
    startLevel(1);
    initAudio();
  };

  // Provide error handling for audio context creation attempts after user gesture
  window.addEventListener("click", () => {
    if (!state.soundContext && !state.audioAvailable) {
      try {
        initAudio();
        resumeAudioOnUserGesture();
      } catch (err) {
        console.warn("Audio gesture init error:", err);
      }
    }
  });

  // Graceful unload: stop audio
  window.addEventListener("beforeunload", () => {
    try {
      stopAllSounds();
    } catch (e) {}
  });

})();
---

