{
  "generated_date": "2025-11-06",
  "generated_timestamp": "2025-11-06T00:27:41.911949",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8084,
  "game_filename": "2025-11-06.js",
  "game_size_bytes": 22733,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Educational Drone Math Game\n  // Renders into the existing element with id \"game-of-the-day-stage\"\n  // Canvas dimensions: 720 x 480\n  // Goal: Answer 10 questions correctly to win\n  // Lose: 3 wrong answers -> game over\n  // Accessibility: keyboard controls, ARIA status updates, visual audio indicator, error handling\n\n  // --------------------------\n  // Configuration and State\n  // --------------------------\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const PADDING = 10;\n  const TARGET_CORRECT = 10;\n  const MAX_WRONG = 3;\n  const FONT_BODY = '16px \"Segoe UI\", Roboto, Arial, sans-serif';\n  const FONT_LARGE = '22px \"Segoe UI\", Roboto, Arial, sans-serif';\n  const FONT_BIG = '28px \"Segoe UI\", Roboto, Arial, sans-serif';\n\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Missing container element with id \"game-of-the-day-stage\". Game cannot start.');\n    return;\n  }\n\n  // Clear container and create canvas\n  container.innerHTML = '';\n  container.setAttribute('role', 'application');\n  container.setAttribute('aria-label', 'Drone math game. Use number keys 1-3 or click answers. Press M to toggle sound. Press R to restart.');\n  container.style.outline = 'none';\n\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute('role', 'img');\n  canvas.setAttribute('aria-label', 'Math game canvas showing drone and interactive math questions.');\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Offscreen live region for screen readers\n  const liveRegion = document.createElement('div');\n  liveRegion.setAttribute('aria-live', 'polite');\n  liveRegion.style.position = 'absolute';\n  liveRegion.style.left = '-9999px';\n  container.appendChild(liveRegion);\n\n  // --------------------------\n  // Audio Setup using Web Audio API\n  // --------------------------\n  let audioCtx = null;\n  let masterGain = null;\n  let ambientNode = null;\n  let soundEnabled = true;\n  let audioAvailable = true;\n\n  function initAudioContext() {\n    try {\n      const AudioContext = window.AudioContext || window.webkitAudioContext;\n      if (!AudioContext) {\n        audioAvailable = false;\n        console.warn('Web Audio API not supported in this browser.');\n        return;\n      }\n      audioCtx = new AudioContext();\n      masterGain = audioCtx.createGain();\n      masterGain.gain.value = 0.6;\n      masterGain.connect(audioCtx.destination);\n      // gentle ambient oscillator\n      ambientNode = audioCtx.createOscillator();\n      const ambientGain = audioCtx.createGain();\n      ambientNode.type = 'sine';\n      ambientNode.frequency.value = 220;\n      ambientGain.gain.value = 0.02;\n      ambientNode.connect(ambientGain);\n      ambientGain.connect(masterGain);\n      ambientNode.start();\n    } catch (e) {\n      audioAvailable = false;\n      console.error('Error initializing AudioContext:', e);\n    }\n  }\n\n  function resumeAudioIfNeeded() {\n    if (!audioAvailable || !audioCtx) return;\n    if (audioCtx.state === 'suspended') {\n      audioCtx.resume().catch((e) => {\n        console.warn('AudioContext resume failed:', e);\n      });\n    }\n  }\n\n  function playTone({ frequency = 440, duration = 0.2, type = 'sine', gain = 0.1, detune = 0 }) {\n    if (!audioAvailable || !audioCtx || !soundEnabled) return;\n    try {\n      const now = audioCtx.currentTime;\n      const osc = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      osc.type = type;\n      osc.frequency.value = frequency;\n      osc.detune.value = detune;\n      g.gain.setValueAtTime(gain, now);\n      g.gain.exponentialRampToValueAtTime(0.001, now + duration);\n      osc.connect(g);\n      g.connect(masterGain);\n      osc.start(now);\n      osc.stop(now + duration + 0.05);\n    } catch (e) {\n      console.warn('playTone error:', e);\n    }\n  }\n\n  function playCorrectSound() {\n    // cheerful arpeggio-ish\n    playTone({ frequency: 880, duration: 0.08, type: 'square', gain: 0.06 });\n    setTimeout(() => playTone({ frequency: 660, duration: 0.12, type: 'sine', gain: 0.05 }), 80);\n    pulseAudioVisual();\n  }\n\n  function playWrongSound() {\n    // low buzz\n    playTone({ frequency: 180, duration: 0.25, type: 'sawtooth', gain: 0.1 });\n    pulseAudioVisual(true);\n  }\n\n  // --------------------------\n  // Game Variables\n  // --------------------------\n  let question = null;\n  let answers = [];\n  let correctIndex = 0;\n  let score = 0;\n  let wrong = 0;\n  let elapsed = 0;\n  let lastTime = 0;\n  let propellerAngle = 0;\n  let running = true;\n  let showVictory = false;\n  let showGameOver = false;\n  let shaking = 0;\n  let audioPulse = 0; // visual pulse for audio feedback\n  let autoplayHintTimer = 0;\n\n  // Answer button layout\n  const answerButtons = [\n    { x: 110, y: 320, w: 160, h: 70 },\n    { x: 280, y: 320, w: 160, h: 70 },\n    { x: 450, y: 320, w: 160, h: 70 },\n  ];\n\n  // Initialize audio context (may require user gesture to resume)\n  initAudioContext();\n\n  // --------------------------\n  // Utilities: Math Questions for age 7-9\n  // --------------------------\n  function randomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  function generateQuestion() {\n    // Mix addition, subtraction, simple multiplication, and number bonds\n    const types = ['add', 'sub', 'mul', 'bond'];\n    const type = types[randomInt(0, types.length - 1)];\n\n    let q = '';\n    let correct = 0;\n\n    if (type === 'add') {\n      const a = randomInt(3, 18);\n      const b = randomInt(1, 12);\n      correct = a + b;\n      q = `${a} + ${b} = ?`;\n    } else if (type === 'sub') {\n      let a = randomInt(7, 20);\n      let b = randomInt(1, 6);\n      if (b > a) [a, b] = [b, a];\n      correct = a - b;\n      q = `${a} \u2212 ${b} = ?`;\n    } else if (type === 'mul') {\n      const a = randomInt(2, 6);\n      const b = randomInt(2, 6);\n      correct = a * b;\n      q = `${a} \u00d7 ${b} = ?`;\n    } else {\n      // number bond to 10 or 20\n      const total = Math.random() < 0.6 ? 10 : 20;\n      const a = randomInt(1, Math.min(8, total - 1));\n      correct = total - a;\n      q = `${a} + ? = ${total}`;\n    }\n\n    // Generate plausible wrong answers\n    const wrongs = new Set();\n    while (wrongs.size < 6) {\n      const delta = randomInt(-4, 5);\n      const candidate = correct + delta;\n      if (candidate >= 0 && candidate !== correct) wrongs.add(candidate);\n    }\n    const wrongArray = Array.from(wrongs);\n    const choices = [];\n    // ensure three choices with correct one randomly placed\n    correctIndex = randomInt(0, 2);\n    for (let i = 0; i < 3; i++) {\n      if (i === correctIndex) choices.push(correct);\n      else choices.push(wrongArray.pop());\n    }\n\n    return { q, choices, correctIndex, correct };\n  }\n\n  function nextQuestion() {\n    const qobj = generateQuestion();\n    question = qobj.q;\n    answers = qobj.choices;\n    correctIndex = qobj.correctIndex;\n    // brief hint animation\n    autoplayHintTimer = 0.6;\n  }\n\n  // --------------------------\n  // Drawing Helpers\n  // --------------------------\n  function clear() {\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n  }\n\n  function drawRoundedRect(x, y, w, h, r, fillStyle, strokeStyle) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fillStyle) {\n      ctx.fillStyle = fillStyle;\n      ctx.fill();\n    }\n    if (strokeStyle) {\n      ctx.strokeStyle = strokeStyle;\n      ctx.stroke();\n    }\n  }\n\n  function drawTopUI() {\n    // Score top-left\n    ctx.font = FONT_LARGE;\n    ctx.textBaseline = 'top';\n    const scoreText = `Score: ${score}/${TARGET_CORRECT}`;\n    const scoreWidth = ctx.measureText(scoreText).width;\n    const scorePadding = 8;\n    const scoreBgW = scoreWidth + scorePadding * 2;\n    const scoreBgH = 34;\n    const scoreX = PADDING;\n    const scoreY = PADDING;\n\n    ctx.fillStyle = 'rgba(255,255,255,0.85)';\n    drawRoundedRect(scoreX, scoreY, scoreBgW, scoreBgH, 8, 'rgba(255,255,255,0.9)', '#333');\n    ctx.fillStyle = '#0a3156';\n    ctx.fillText(scoreText, scoreX + scorePadding, scoreY + 6);\n\n    // Lives top-right\n    const livesText = `Lives: ${Math.max(0, MAX_WRONG - wrong)}`;\n    const livesWidth = ctx.measureText(livesText).width;\n    const livesBgW = livesWidth + scorePadding * 2;\n    const livesBgH = 34;\n    const livesX = WIDTH - PADDING - livesBgW;\n    const livesY = PADDING;\n\n    drawRoundedRect(livesX, livesY, livesBgW, livesBgH, 8, 'rgba(255,255,255,0.9)', '#333');\n    ctx.fillStyle = '#8b0000';\n    ctx.fillText(livesText, livesX + scorePadding, livesY + 6);\n\n    // Audio indicator just right of lives (visual cue)\n    const audioX = livesX - 42;\n    const audioY = PADDING + 4;\n    ctx.fillStyle = '#fff';\n    drawRoundedRect(audioX - 6, audioY - 4, 40, 26, 6, 'rgba(255,255,255,0.9)', '#333');\n    ctx.fillStyle = soundEnabled ? '#157F0A' : '#888';\n    // speaker icon\n    ctx.beginPath();\n    ctx.moveTo(audioX, audioY + 6);\n    ctx.lineTo(audioX + 8, audioY + 6);\n    ctx.lineTo(audioX + 16, audioY + 2);\n    ctx.lineTo(audioX + 16, audioY + 22);\n    ctx.lineTo(audioX + 8, audioY + 18);\n    ctx.lineTo(audioX, audioY + 18);\n    ctx.closePath();\n    ctx.fill();\n    // sound waves\n    ctx.strokeStyle = soundEnabled ? '#157F0A' : '#888';\n    ctx.lineWidth = 2;\n    if (soundEnabled) {\n      ctx.beginPath();\n      ctx.arc(audioX + 22, audioY + 11, 6 + Math.sin(audioPulse * Math.PI) * 2,  -0.6, 0.6);\n      ctx.stroke();\n    } else {\n      ctx.beginPath();\n      ctx.moveTo(audioX + 20, audioY + 5);\n      ctx.lineTo(audioX + 30, audioY + 19);\n      ctx.stroke();\n    }\n  }\n\n  function drawBackground() {\n    // calming sky gradient\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, '#E8F7FF');\n    g.addColorStop(1, '#F3FBFF');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // floating wacky clouds\n    drawCloud(80, 80, 60, 14, '#ffffff', '#dfefff');\n    drawCloud(550, 60, 70, 18, '#fff8ff', '#e9f0ff');\n    drawCloud(420, 140, 48, 12, '#fff', '#eef7ff');\n\n    // gentle horizon line\n    ctx.fillStyle = '#dff3ff';\n    ctx.fillRect(0, HEIGHT - 80, WIDTH, 80);\n  }\n\n  function drawCloud(cx, cy, size, puff, color, shade) {\n    ctx.fillStyle = shade || '#e8f6ff';\n    ctx.beginPath();\n    for (let i = 0; i < 8; i++) {\n      const angle = (i / 8) * Math.PI * 2;\n      const rx = cx + Math.cos(angle) * (size * 0.6) * Math.random();\n      const ry = cy + Math.sin(angle) * (size * 0.35) * Math.random();\n      ctx.moveTo(rx, ry);\n      ctx.arc(rx, ry, size * 0.2 + Math.random() * (puff * 0.25), 0, Math.PI * 2);\n    }\n    ctx.fill();\n    ctx.fillStyle = color || '#fff';\n    ctx.globalAlpha = 0.8;\n    ctx.beginPath();\n    ctx.ellipse(cx - size * 0.08, cy, size * 0.9, size * 0.45, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.globalAlpha = 1;\n  }\n\n  function drawDrone(x, y) {\n    // main body\n    ctx.save();\n    ctx.translate(x, y);\n    if (shaking > 0) {\n      ctx.translate(Math.sin(shaking * 30) * 6, Math.cos(shaking * 50) * 3);\n    }\n    ctx.fillStyle = '#FFD27F';\n    drawRoundedRect(-60, -28, 120, 56, 16, '#FFD27F', '#3b2f1f');\n    // window\n    ctx.fillStyle = '#90E0FF';\n    ctx.beginPath();\n    ctx.ellipse(0, -6, 32, 20, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = '#065a7c';\n    ctx.stroke();\n\n    // rotor arms and propellers (wacky)\n    ctx.fillStyle = '#BFCFFF';\n    for (let i = -1; i <= 1; i += 2) {\n      ctx.save();\n      ctx.translate(i * 60, -22);\n      ctx.rotate(propellerAngle * i);\n      ctx.fillStyle = '#cde6ff';\n      ctx.fillRect(-4, -26, 8, 52);\n      // blades\n      ctx.fillStyle = '#ffffff';\n      ctx.beginPath();\n      ctx.ellipse(0, -36, 30, 6, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.beginPath();\n      ctx.ellipse(0, 36, 30, 6, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n    }\n\n    // friendly face\n    ctx.fillStyle = '#3b2f1f';\n    ctx.beginPath();\n    ctx.arc(-12, 0, 3, 0, Math.PI * 2);\n    ctx.arc(12, 0, 3, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(0, 10, 10, 0, Math.PI, false);\n    ctx.strokeStyle = '#3b2f1f';\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  function drawQuestionArea() {\n    // Question text centered top of the play area\n    ctx.font = FONT_BIG;\n    ctx.textBaseline = 'top';\n    ctx.fillStyle = '#073B4C';\n    const qText = `Question: ${question}`;\n    const qWidth = ctx.measureText(qText).width;\n    const bgW = qWidth + 24;\n    const bgH = 44;\n    const qX = (WIDTH - bgW) / 2;\n    const qY = 90;\n    drawRoundedRect(qX, qY, bgW, bgH, 10, 'rgba(255,255,255,0.95)', '#1a4b61');\n    ctx.fillStyle = '#052F3A';\n    ctx.fillText(qText, qX + 12, qY + 8);\n  }\n\n  function drawAnswerButtons() {\n    ctx.font = FONT_BODY;\n    ctx.textBaseline = 'middle';\n    answers.forEach((ans, i) => {\n      const b = answerButtons[i];\n      const isHover = false; // we'll handle hover via click events; no pointer hover tracking needed\n      const isCorrectPotential = autoplayHintTimer > 0 && i === correctIndex;\n      const bg = isCorrectPotential ? 'linear' : null;\n      // choose colors\n      const base = '#fff';\n      const stroke = '#243b4a';\n      const fillStyle = isCorrectPotential ? '#e8fff0' : '#ffffff';\n      drawRoundedRect(b.x, b.y, b.w, b.h, 12, fillStyle, stroke);\n      // draw number label\n      ctx.fillStyle = '#0a3b5a';\n      const numText = `${i + 1}.`;\n      ctx.fillText(numText, b.x + 14, b.y + b.h / 2);\n      // draw answer value\n      const valText = String(ans);\n      const valWidth = ctx.measureText(valText).width;\n      // ensure no overlap between number and value\n      ctx.fillStyle = '#0a2a40';\n      ctx.fillText(valText, b.x + b.w / 2 - valWidth / 2 + 12, b.y + b.h / 2);\n    });\n  }\n\n  function drawProgressStars() {\n    // show small stars for each correct point collected at top center below UI\n    const startX = WIDTH / 2 - (TARGET_CORRECT * 14) / 2;\n    const y = 52;\n    for (let i = 0; i < TARGET_CORRECT; i++) {\n      const x = startX + i * 14;\n      ctx.beginPath();\n      // star using simple path\n      const outerR = 6;\n      const innerR = 2.8;\n      for (let p = 0; p < 5; p++) {\n        const a1 = (p * 2 * Math.PI) / 5 - Math.PI / 2;\n        const a2 = a1 + Math.PI / 5;\n        const x1 = x + Math.cos(a1) * outerR;\n        const y1 = y + Math.sin(a1) * outerR;\n        const x2 = x + Math.cos(a2) * innerR;\n        const y2 = y + Math.sin(a2) * innerR;\n        if (p === 0) ctx.moveTo(x1, y1);\n        else ctx.lineTo(x1, y1);\n        ctx.lineTo(x2, y2);\n      }\n      ctx.closePath();\n      ctx.fillStyle = i < score ? '#FFD700' : 'rgba(200,200,200,0.4)';\n      ctx.fill();\n      ctx.strokeStyle = '#8b6b00';\n      ctx.stroke();\n    }\n  }\n\n  function drawBottomInstructions() {\n    ctx.font = FONT_BODY;\n    ctx.textBaseline = 'top';\n    const lines = [\n      'Controls: Click an answer or press 1, 2, 3. Press M to toggle sound. Press R to restart.',\n      'Goal: Answer 10 questions correctly. Too many wrong answers (3) and the drone returns home (game over).',\n    ];\n    // combine into multi-line block and ensure padding and background\n    const maxWidth = Math.max(...lines.map((l) => ctx.measureText(l).width));\n    const bgW = maxWidth + 20;\n    const x = (WIDTH - bgW) / 2;\n    const y = HEIGHT - 70;\n    drawRoundedRect(x, y, bgW, 60, 8, 'rgba(255,255,255,0.9)', '#2e4a59');\n    ctx.fillStyle = '#052F3A';\n    lines.forEach((line, idx) => {\n      ctx.fillText(line, x + 10, y + 6 + idx * 22);\n    });\n  }\n\n  function drawVictoryScreen() {\n    ctx.fillStyle = 'rgba(10, 40, 30, 0.85)';\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.font = FONT_BIG;\n    ctx.fillStyle = '#fff';\n    const txt = 'Victory! The drone delivered all the packages!';\n    const w = ctx.measureText(txt).width;\n    ctx.fillText(txt, WIDTH / 2 - w / 2, HEIGHT / 2 - 50);\n    ctx.font = FONT_LARGE;\n    const sub = `You answered ${score} correctly. Press R to play again.`;\n    const sw = ctx.measureText(sub).width;\n    ctx.fillText(sub, WIDTH / 2 - sw / 2, HEIGHT / 2);\n  }\n\n  function drawGameOverScreen() {\n    ctx.fillStyle = 'rgba(50, 10, 10, 0.9)';\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.font = FONT_BIG;\n    ctx.fillStyle = '#fff';\n    const txt = 'Game Over \u2014 the drone had to return home!';\n    const w = ctx.measureText(txt).width;\n    ctx.fillText(txt, WIDTH / 2 - w / 2, HEIGHT / 2 - 50);\n    ctx.font = FONT_LARGE;\n    const sub = `Correct answers: ${score}. Press R to try again.`;\n    const sw = ctx.measureText(sub).width;\n    ctx.fillText(sub, WIDTH / 2 - sw / 2, HEIGHT / 2);\n  }\n\n  // --------------------------\n  // Game Logic\n  // --------------------------\n  function answerSelected(index) {\n    if (!running) return;\n    // handle audio resume on first interaction\n    resumeAudioIfNeeded();\n    if (index === correctIndex) {\n      score++;\n      liveAnnounce(`Correct! Score ${score}`);\n      playCorrectSound();\n      // small positive animation\n      audioPulse = 1;\n      // Next question or victory check\n      if (score >= TARGET_CORRECT) {\n        showVictory = true;\n        running = false;\n        liveAnnounce('Victory! You completed the game.');\n        return;\n      } else {\n        nextQuestion();\n      }\n    } else {\n      wrong++;\n      liveAnnounce(`Oops. Wrong answer. ${Math.max(0, MAX_WRONG - wrong)} lives left.`);\n      playWrongSound();\n      shaking = 0.6; // start shake animation\n      if (wrong >= MAX_WRONG) {\n        showGameOver = true;\n        running = false;\n        liveAnnounce('Game over. The drone returned home.');\n        return;\n      }\n    }\n  }\n\n  function liveAnnounce(text) {\n    // Update live region for screen readers\n    liveRegion.textContent = text;\n  }\n\n  // --------------------------\n  // Input Handling\n  // --------------------------\n  canvas.addEventListener('click', (ev) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = ev.clientX - rect.left;\n    const my = ev.clientY - rect.top;\n\n    // toggle sound if click near audio icon area top-right\n    const livesText = `Lives: ${Math.max(0, MAX_WRONG - wrong)}`;\n    ctx.font = FONT_LARGE;\n    const livesWidth = ctx.measureText(livesText).width;\n    const livesBgW = livesWidth + 8 * 2;\n    const livesX = WIDTH - PADDING - livesBgW;\n    const audioX = livesX - 42;\n    const audioRect = { x: audioX - 6, y: PADDING, w: 40, h: 26 };\n\n    if (mx >= audioRect.x && mx <= audioRect.x + audioRect.w && my >= audioRect.y && my <= audioRect.y + audioRect.h) {\n      toggleSound();\n      return;\n    }\n\n    // check answer button clicks\n    for (let i = 0; i < answerButtons.length; i++) {\n      const b = answerButtons[i];\n      if (mx >= b.x && mx <= b.x + b.w && my >= b.y && my <= b.y + b.h) {\n        answerSelected(i);\n        return;\n      }\n    }\n\n    // restart if on end screens and clicking center\n    if (!running) {\n      // central button area\n      answerSelected(-1);\n    }\n  });\n\n  function toggleSound() {\n    soundEnabled = !soundEnabled;\n    liveAnnounce(soundEnabled ? 'Sound on' : 'Sound off');\n    if (audioAvailable && audioCtx) {\n      // reduce master gain if toggled off\n      if (masterGain) masterGain.gain.value = soundEnabled ? 0.6 : 0.0;\n    }\n  }\n\n  window.addEventListener('keydown', (ev) => {\n    // handle numeric keypresses 1-3\n    if (ev.key >= '1' && ev.key <= '3') {\n      const idx = parseInt(ev.key, 10) - 1;\n      answerSelected(idx);\n      resumeAudioIfNeeded();\n      ev.preventDefault();\n    } else if (ev.key.toLowerCase() === 'm') {\n      toggleSound();\n    } else if (ev.key.toLowerCase() === 'r') {\n      restartGame();\n    }\n  });\n\n  // --------------------------\n  // Restart and Initialization\n  // --------------------------\n  function restartGame() {\n    score = 0;\n    wrong = 0;\n    elapsed = 0;\n    lastTime = performance.now();\n    propellerAngle = 0;\n    running = true;\n    showVictory = false;\n    showGameOver = false;\n    shaking = 0;\n    audioPulse = 0;\n    nextQuestion();\n    liveAnnounce('Game restarted. Answer the question. Good luck!');\n    // ensure audio context can be resumed by user gesture\n    resumeAudioIfNeeded();\n  }\n\n  // --------------------------\n  // Animation Loop\n  // --------------------------\n  function update(dt) {\n    elapsed += dt;\n    propellerAngle += dt * 6; // rotation speed\n    if (shaking > 0) {\n      shaking -= dt;\n      if (shaking < 0) shaking = 0;\n    }\n    if (audioPulse > 0) {\n      audioPulse -= dt * 1.2;\n      if (audioPulse < 0) audioPulse = 0;\n    }\n    if (autoplayHintTimer > 0) {\n      autoplayHintTimer -= dt;\n    }\n  }\n\n  function render() {\n    clear();\n    drawBackground();\n    drawTopUI();\n    drawProgressStars();\n    drawQuestionArea();\n    drawAnswerButtons();\n    drawBottomInstructions();\n    // draw drone in center-left\n    const droneX = 180 + Math.sin(elapsed) * 6;\n    const droneY = 200 + Math.cos(elapsed * 0.6) * 6;\n    drawDrone(droneX, droneY);\n\n    // small floating packages / stars near right to show wacky elements\n    for (let i = 0; i < 4; i++) {\n      const sx = 520 + i * 36;\n      const sy = 150 + Math.sin(elapsed + i) * 8;\n      ctx.fillStyle = '#FFDFBA';\n      ctx.fillRect(sx, sy, 22, 18);\n      ctx.strokeStyle = '#7b4a23';\n      ctx.strokeRect(sx, sy, 22, 18);\n      ctx.fillStyle = '#7b4a23';\n      ctx.fillText('+', sx + 8, sy + 2);\n    }\n\n    if (showVictory) {\n      drawVictoryScreen();\n    } else if (showGameOver) {\n      drawGameOverScreen();\n    }\n\n    // visual audio pulse overlay\n    if (audioPulse > 0 && soundEnabled) {\n      ctx.fillStyle = `rgba(21,127,10,${0.12 * audioPulse})`;\n      ctx.beginPath();\n      ctx.arc(60, 60, 50 + audioPulse * 18, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n\n  function loop(now) {\n    if (!lastTime) lastTime = now;\n    const dt = Math.min(0.05, (now - lastTime) / 1000);\n    lastTime = now;\n    if (running) update(dt);\n    render();\n    requestAnimationFrame(loop);\n  }\n\n  // --------------------------\n  // Start Game\n  // --------------------------\n  // Use try/catch for safety\n  try {\n    nextQuestion();\n    lastTime = performance.now();\n    requestAnimationFrame(loop);\n  } catch (e) {\n    console.error('Error starting game loop:', e);\n    ctx.fillStyle = '#fff';\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.fillStyle = '#000';\n    ctx.font = FONT_LARGE;\n    const msg = 'An error occurred starting the game. Please reload the page.';\n    ctx.fillText(msg, 20, 20);\n  }\n\n  // Expose a few functions for debugging in console (non-essential)\n  window._droneMathGame = {\n    restart: restartGame,\n    toggleSound,\n    getState: () => ({ score, wrong, running, showVictory, showGameOver }),\n  };\n})();\n---\n",
  "improve_response_tokens": 18534,
  "formatted_code": true,
  "formatting_response_tokens": 21530,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}