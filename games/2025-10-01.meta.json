{
  "generated_date": "2025-10-01",
  "generated_timestamp": "2025-10-01T00:30:53.017365",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 11419,
  "game_filename": "2025-10-01.js",
  "game_size_bytes": 33928,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Educational Math Game: \"Wacky Machine Mixer\"\n// Renders into element with id \"game-of-the-day-stage\"\n// All graphics drawn on canvas, sounds via Web Audio API oscillators\n// Accessible: keyboard controls, ARIA status updates, visual audio indicator\n(function () {\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const MAX_LEVELS = 8; // beatable\n  const STAGE_ID = \"game-of-the-day-stage\";\n\n  // Utility helpers\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  function clamp(v, a, b) {\n    return Math.max(a, Math.min(b, v));\n  }\n\n  // Find container\n  const container = document.getElementById(STAGE_ID);\n  if (!container) {\n    console.error(\"Game container not found: #\" + STAGE_ID);\n    return;\n  }\n  container.innerHTML = \"\"; // clear\n  container.style.position = \"relative\";\n  container.setAttribute(\"role\", \"application\");\n  container.setAttribute(\"aria-label\", \"Wacky Machine Math Game\");\n\n  // Create offscreen live region for accessibility messages\n  const liveRegion = document.createElement(\"div\");\n  liveRegion.setAttribute(\"aria-live\", \"polite\");\n  liveRegion.style.position = \"absolute\";\n  liveRegion.style.left = \"-9999px\";\n  liveRegion.style.width = \"1px\";\n  liveRegion.style.height = \"1px\";\n  container.appendChild(liveRegion);\n\n  // Create canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute(\"tabindex\", \"0\"); // to capture keyboard\n  canvas.style.outline = \"none\";\n  container.appendChild(canvas);\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    console.error(\"Canvas 2D not supported.\");\n    liveRegion.textContent = \"Your browser does not support the game canvas.\";\n    return;\n  }\n\n  // Audio setup with error handling\n  let audioAvailable = true;\n  let audioCtx = null;\n  let masterGain = null;\n  let bgGain = null;\n  let bgOsc = null;\n  let bgLFO = null;\n  try {\n    const AudioContext = window.AudioContext || window.webkitAudioContext;\n    audioCtx = new AudioContext();\n    masterGain = audioCtx.createGain();\n    masterGain.gain.value = 0.9;\n    masterGain.connect(audioCtx.destination);\n    // Background gentle pad\n    bgGain = audioCtx.createGain();\n    bgGain.gain.value = 0.02; // very gentle\n    bgGain.connect(masterGain);\n    bgOsc = audioCtx.createOscillator();\n    bgOsc.type = \"sine\";\n    bgOsc.frequency.value = 120; // low tone\n    // LFO to modulate filter\n    bgLFO = audioCtx.createOscillator();\n    bgLFO.frequency.value = 0.08; // slow\n    const lfoGain = audioCtx.createGain();\n    lfoGain.gain.value = 200;\n    // filter\n    const bgFilter = audioCtx.createBiquadFilter();\n    bgFilter.type = \"lowpass\";\n    bgFilter.frequency.value = 300;\n    bgOsc.connect(bgFilter);\n    bgFilter.connect(bgGain);\n    bgLFO.connect(lfoGain);\n    lfoGain.connect(bgFilter.frequency);\n    bgOsc.start();\n    bgLFO.start();\n    // Initially suspend until user interacts\n    if (audioCtx.state === \"suspended\") {\n      audioAvailable = true; // still available but suspended\n    }\n  } catch (e) {\n    console.warn(\"Audio context not created:\", e);\n    audioAvailable = false;\n    audioCtx = null;\n    masterGain = null;\n  }\n\n  // Simple sound primitives\n  function ensureAudioRunning() {\n    if (!audioCtx) return Promise.resolve(false);\n    if (audioCtx.state === \"suspended\") {\n      return audioCtx.resume().then(() => true).catch(() => false);\n    }\n    return Promise.resolve(true);\n  }\n\n  function playBeep(time = 0, duration = 0.18, freq = 880, type = \"sine\", volume = 0.08) {\n    if (!audioCtx) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = type;\n      o.frequency.value = freq;\n      g.gain.value = volume;\n      o.connect(g);\n      g.connect(masterGain);\n      const now = audioCtx.currentTime;\n      o.start(now + time);\n      g.gain.setValueAtTime(volume, now + time);\n      g.gain.exponentialRampToValueAtTime(0.001, now + time + duration);\n      o.stop(now + time + duration + 0.02);\n    } catch (e) {\n      console.warn(\"playBeep failed:\", e);\n    }\n  }\n\n  function playCorrectTune() {\n    ensureAudioRunning().then((ok) => {\n      if (!ok) return;\n      // simple arpeggio\n      playBeep(0, 0.16, 880, \"sine\", 0.06);\n      playBeep(0.12, 0.18, 1046.5, \"sine\", 0.06);\n      playBeep(0.26, 0.24, 1318.5, \"sine\", 0.07);\n    });\n  }\n\n  function playWrongThud() {\n    ensureAudioRunning().then((ok) => {\n      if (!ok) return;\n      try {\n        const now = audioCtx.currentTime;\n        const o = audioCtx.createOscillator();\n        const f = audioCtx.createBiquadFilter();\n        const g = audioCtx.createGain();\n        o.type = \"square\";\n        o.frequency.value = 120;\n        f.type = \"lowpass\";\n        f.frequency.value = 200;\n        g.gain.value = 0.08;\n        o.connect(f);\n        f.connect(g);\n        g.connect(masterGain);\n        o.start(now);\n        g.gain.setValueAtTime(0.08, now);\n        g.gain.exponentialRampToValueAtTime(0.001, now + 0.35);\n        o.stop(now + 0.36);\n      } catch (e) {\n        console.warn(\"playWrongThud failed:\", e);\n      }\n    });\n  }\n\n  function playClick() {\n    ensureAudioRunning().then((ok) => {\n      if (!ok) return;\n      playBeep(0, 0.06, 1200, \"square\", 0.03);\n    });\n  }\n\n  // Game state\n  let level = 1;\n  let score = 0;\n  let tokens = []; // token objects\n  let selectedIds = new Set();\n  let target = 0;\n  let attemptsLeft = 3;\n  let rotatingCogAngle = 0;\n  let tick = 0;\n  let showAudioOn = true;\n\n  // Visual theme colors\n  const palette = {\n    bg: \"#f0f7fb\",\n    machine: \"#cfe7f3\",\n    accent: \"#8ab6c6\",\n    tokenFill: [\"#ffd6a5\", \"#c8f7d8\", \"#d0c7ff\", \"#fff2a6\", \"#f8c6d8\"],\n    text: \"#153243\",\n    wrong: \"#ff8a8a\",\n    right: \"#7ee787\",\n    subtle: \"#b7dbe6\",\n  };\n\n  // Accessibility: update live region\n  function aria(msg) {\n    liveRegion.textContent = msg;\n  }\n\n  // Generate tokens that guarantee a solvable subset for the target\n  function generateLevel(lv) {\n    // target grows with level\n    const minTarget = 5 + Math.floor((lv - 1) * 1.5);\n    const maxTarget = 9 + lv * 2;\n    target = randInt(minTarget, maxTarget);\n    // choose number of tokens 3..6\n    const n = clamp(4 + Math.floor(lv / 3), 3, 6);\n    // create one guaranteed solution: pick k numbers between 1 and 9 whose sum = target, with k 2..3\n    let solution = null;\n    for (let attempts = 0; attempts < 200 && !solution; attempts++) {\n      const k = randInt(2, Math.min(3, Math.max(2, Math.floor(target / 3))));\n      // generate k numbers sum to target but each 1..9\n      // simple approach: pick k-1 random then last = target - sum\n      const parts = [];\n      let sum = 0;\n      for (let i = 0; i < k - 1; i++) {\n        const rem = target - sum - (k - i - 1) * 1;\n        const maxVal = Math.min(9, rem - (k - i - 2) * 1);\n        const val = Math.max(1, randInt(1, Math.max(1, maxVal)));\n        parts.push(val);\n        sum += val;\n      }\n      const last = target - sum;\n      if (last >= 1 && last <= 9) {\n        parts.push(last);\n        // ensure parts not too many large duplicates (not necessary)\n        solution = parts;\n      }\n    }\n    if (!solution) {\n      // fallback: target as one token if <=9\n      if (target <= 9) solution = [target];\n      else solution = [Math.min(9, target - 1), Math.max(1, target - Math.min(9, target - 1))];\n    }\n    // Fill remaining tokens\n    tokens = [];\n    const usedColors = palette.tokenFill;\n    let idx = 0;\n    // Place solution tokens in random positions among tokens\n    const positions = [];\n    const margin = 40;\n    const startX = 120;\n    const gap = (WIDTH - 2 * startX) / (n - 1);\n    for (let i = 0; i < n; i++) {\n      positions.push({ x: startX + gap * i, y: HEIGHT - 110 });\n    }\n    shuffleArray(positions);\n    // add solution numbers first\n    for (let v of solution) {\n      const pos = positions.pop();\n      tokens.push(makeToken(v, pos.x, pos.y, usedColors[idx % usedColors.length]));\n      idx++;\n    }\n    // fill with distractors\n    while (tokens.length < n) {\n      // create random value 1..9 but avoid accidental trivial extra solutions that sum to target when combined with others maybe allow\n      const v = randInt(1, 9);\n      const pos = positions.pop();\n      tokens.push(makeToken(v, pos.x, pos.y, usedColors[idx % usedColors.length]));\n      idx++;\n    }\n    shuffleArray(tokens); // random order\n    // reset selection etc.\n    selectedIds = new Set();\n    attemptsLeft = 3;\n    aria(`Level ${level}. Target ${target}. Choose tokens that add up to ${target}.`);\n  }\n\n  function makeToken(value, x, y, color) {\n    return {\n      id: Math.random().toString(36).slice(2, 9),\n      value,\n      x,\n      y,\n      r: 28,\n      color,\n      used: false,\n      wobble: Math.random() * Math.PI * 2,\n    };\n  }\n\n  function shuffleArray(a) {\n    for (let i = a.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [a[i], a[j]] = [a[j], a[i]];\n    }\n  }\n\n  // Interaction state\n  let drag = null;\n  let pointerDown = false;\n  let keyboardIndex = 0;\n\n  // Input handlers\n  canvas.addEventListener(\"mousedown\", (e) => {\n    const pos = getMouse(e);\n    pointerDown = true;\n    const t = findTokenAt(pos.x, pos.y);\n    if (t) {\n      drag = { token: t, offsetX: pos.x - t.x, offsetY: pos.y - t.y };\n      playClick();\n      keyboardIndex = tokens.findIndex((tk) => tk.id === t.id);\n      canvas.focus();\n    } else {\n      // check submit or clear or toggle audio\n      const btn = hitButtonAt(pos.x, pos.y);\n      if (btn === \"submit\") handleSubmit();\n      if (btn === \"clear\") handleClear();\n      if (btn === \"audio\") toggleAudio();\n    }\n  });\n\n  canvas.addEventListener(\"mousemove\", (e) => {\n    if (!drag) return;\n    const pos = getMouse(e);\n    drag.token.x = pos.x - drag.offsetX;\n    drag.token.y = pos.y - drag.offsetY;\n  });\n\n  canvas.addEventListener(\"mouseup\", (e) => {\n    pointerDown = false;\n    if (drag) {\n      // dropping near machine bowl (center) toggles selection\n      const bowl = { x: WIDTH / 2 + 140, y: HEIGHT / 2 + 20, r: 90 };\n      const t = drag.token;\n      const dist = Math.hypot(t.x - bowl.x, t.y - bowl.y);\n      if (dist < bowl.r + 20) {\n        toggleTokenSelection(t.id);\n      } else {\n        // snap back to base row\n        snapTokenBack(t);\n      }\n    }\n    drag = null;\n  });\n\n  // Touch support\n  canvas.addEventListener(\"touchstart\", (e) => {\n    e.preventDefault();\n    const t0 = e.changedTouches[0];\n    const rect = canvas.getBoundingClientRect();\n    const pos = { x: t0.clientX - rect.left, y: t0.clientY - rect.top };\n    pointerDown = true;\n    const tkn = findTokenAt(pos.x, pos.y);\n    if (tkn) {\n      drag = { token: tkn, offsetX: pos.x - tkn.x, offsetY: pos.y - tkn.y };\n      playClick();\n      keyboardIndex = tokens.findIndex((tk) => tk.id === tkn.id);\n      canvas.focus();\n    } else {\n      const btn = hitButtonAt(pos.x, pos.y);\n      if (btn === \"submit\") handleSubmit();\n      if (btn === \"clear\") handleClear();\n      if (btn === \"audio\") toggleAudio();\n    }\n  });\n\n  canvas.addEventListener(\"touchmove\", (e) => {\n    e.preventDefault();\n    if (!drag) return;\n    const t0 = e.changedTouches[0];\n    const rect = canvas.getBoundingClientRect();\n    const pos = { x: t0.clientX - rect.left, y: t0.clientY - rect.top };\n    drag.token.x = pos.x - drag.offsetX;\n    drag.token.y = pos.y - drag.offsetY;\n  });\n\n  canvas.addEventListener(\"touchend\", (e) => {\n    e.preventDefault();\n    pointerDown = false;\n    if (!drag) return;\n    const bowl = { x: WIDTH / 2 + 140, y: HEIGHT / 2 + 20, r: 90 };\n    const t = drag.token;\n    const dist = Math.hypot(t.x - bowl.x, t.y - bowl.y);\n    if (dist < bowl.r + 20) {\n      toggleTokenSelection(t.id);\n    } else {\n      snapTokenBack(t);\n    }\n    drag = null;\n  });\n\n  function getMouse(e) {\n    const rect = canvas.getBoundingClientRect();\n    return { x: e.clientX - rect.left, y: e.clientY - rect.top };\n  }\n\n  function findTokenAt(x, y) {\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const t = tokens[i];\n      const d = Math.hypot(x - t.x, y - t.y);\n      if (d <= t.r + 6) return t;\n    }\n    return null;\n  }\n\n  function snapTokenBack(t) {\n    // return to original anchored row positions (distribute)\n    const basePositions = computeTokenBasePositions(tokens.length);\n    const index = tokens.findIndex((tk) => tk.id === t.id);\n    const pos = basePositions[index];\n    animateMove(t, pos.x, pos.y, 280);\n  }\n\n  function computeTokenBasePositions(n) {\n    const startX = 120;\n    const gap = (WIDTH - 2 * startX) / (Math.max(1, n - 1));\n    const arr = [];\n    for (let i = 0; i < n; i++) {\n      arr.push({ x: startX + gap * i, y: HEIGHT - 110 });\n    }\n    return arr;\n  }\n\n  // Selection logic\n  function toggleTokenSelection(id) {\n    const t = tokens.find((tk) => tk.id === id);\n    if (!t) return;\n    if (selectedIds.has(id)) {\n      selectedIds.delete(id);\n      // visually push back\n      snapTokenBack(t);\n      playClick();\n      aria(`Removed ${t.value} from machine. Current sum ${currentSelectionSum()}.`);\n      return;\n    }\n    // select only up to 4 tokens to avoid complexity\n    if (selectedIds.size >= 4) {\n      aria(\"You can use up to 4 tokens. Remove one before adding.\");\n      playWrongThud();\n      return;\n    }\n    selectedIds.add(id);\n    // animate token to bowl area\n    const bowlCenter = { x: WIDTH / 2 + 140, y: HEIGHT / 2 + 20 };\n    const offset = { x: randInt(-40, 40), y: randInt(-20, 20) };\n    animateMove(t, bowlCenter.x + offset.x, bowlCenter.y + offset.y, 380);\n    playClick();\n    aria(`Added ${t.value}. Current sum ${currentSelectionSum()}.`);\n  }\n\n  function animateMove(obj, tx, ty, duration = 300) {\n    const start = { x: obj.x, y: obj.y, t: performance.now() };\n    const end = { x: tx, y: ty };\n    function step(now) {\n      const p = Math.min(1, (now - start.t) / duration);\n      const ease = p < 0.5 ? 2 * p * p : -1 + (4 - 2 * p) * p;\n      obj.x = start.x + (end.x - start.x) * ease;\n      obj.y = start.y + (end.y - start.y) * ease;\n      if (p < 1) requestAnimationFrame(step);\n    }\n    requestAnimationFrame(step);\n  }\n\n  function currentSelectionSum() {\n    let s = 0;\n    for (let id of selectedIds) {\n      const t = tokens.find((tk) => tk.id === id);\n      if (t) s += t.value;\n    }\n    return s;\n  }\n\n  function handleSubmit() {\n    const s = currentSelectionSum();\n    if (s === 0) {\n      aria(\"No tokens selected. Choose tokens to make the target total.\");\n      playWrongThud();\n      return;\n    }\n    if (s === target) {\n      // correct\n      score += 10 + attemptsLeft * 2;\n      playCorrectTune();\n      aria(`Correct! You made ${target}. Level ${level} completed.`);\n      // mark tokens as used and move to success animation\n      for (let id of selectedIds) {\n        const t = tokens.find((tk) => tk.id === id);\n        if (t) t.used = true;\n      }\n      selectedIds.clear();\n      setTimeout(() => {\n        level++;\n        if (level > MAX_LEVELS) {\n          // win game\n          showWin();\n        } else {\n          generateLevel(level);\n        }\n      }, 900);\n    } else {\n      attemptsLeft--;\n      playWrongThud();\n      aria(`Not quite. Your sum is ${s}. Attempts left: ${attemptsLeft}.`);\n      if (attemptsLeft <= 0) {\n        // reveal correct hint and advance\n        revealHint();\n        setTimeout(() => {\n          level++;\n          if (level > MAX_LEVELS) showWin();\n          else generateLevel(level);\n        }, 1200);\n      }\n    }\n  }\n\n  function revealHint() {\n    // find any subset that makes target and highlight\n    const vals = tokens.map((t) => t.value);\n    const idxs = subsetSumIndices(vals, target);\n    if (idxs) {\n      for (let i of idxs) {\n        selectedIds.add(tokens[i].id);\n      }\n      // animate bowl acceptance\n      playCorrectTune();\n      aria(\"Here's a helpful hint: some tokens are highlighted.\");\n    } else {\n      aria(\"No hint found; moving to next round.\");\n    }\n  }\n\n  // subset sum solver returning indices\n  function subsetSumIndices(arr, target) {\n    const n = arr.length;\n    // try all subsets up to size 4\n    for (let size = 1; size <= Math.min(4, n); size++) {\n      const comb = [];\n      if (search(0, 0)) {\n        return comb;\n      }\n      function search(i, sum) {\n        if (sum === target && comb.length === size) return true;\n        if (sum > target) return false;\n        if (i >= n) return false;\n        // choose\n        comb.push(i);\n        if (search(i + 1, sum + arr[i])) return true;\n        comb.pop();\n        // skip\n        return search(i + 1, sum);\n      }\n    }\n    // try any subset\n    const best = [];\n    function dfs(i, sum) {\n      if (sum === target) return [];\n      if (i >= n) return null;\n      // choose\n      const withChoose = dfs(i + 1, sum + arr[i]);\n      if (withChoose !== null) {\n        return [i].concat(withChoose);\n      }\n      return dfs(i + 1, sum);\n    }\n    return dfs(0, 0);\n  }\n\n  function handleClear() {\n    selectedIds.clear();\n    // snap back all tokens that are not used\n    tokens.forEach((t, i) => {\n      if (!t.used) {\n        const pos = computeTokenBasePositions(tokens.length)[i];\n        animateMove(t, pos.x, pos.y, 300);\n      }\n    });\n    aria(\"Selection cleared.\");\n    playClick();\n  }\n\n  function toggleAudio() {\n    showAudioOn = !showAudioOn;\n    if (audioCtx && showAudioOn) {\n      ensureAudioRunning();\n      bgGain.gain.value = 0.02;\n    } else if (audioCtx) {\n      bgGain.gain.value = 0;\n    }\n    aria(showAudioOn ? \"Audio enabled.\" : \"Audio muted.\");\n  }\n\n  function hitButtonAt(x, y) {\n    // Submit button rectangle\n    const submit = { x: WIDTH - 140, y: HEIGHT - 120, w: 110, h: 44 };\n    const clear = { x: WIDTH - 280, y: HEIGHT - 120, w: 110, h: 44 };\n    const audioBtn = { x: WIDTH - 70, y: 20, r: 18 };\n    if (x >= submit.x && x <= submit.x + submit.w && y >= submit.y && y <= submit.y + submit.h) return \"submit\";\n    if (x >= clear.x && x <= clear.x + clear.w && y >= clear.y && y <= clear.y + clear.h) return \"clear\";\n    if (Math.hypot(x - audioBtn.x, y - audioBtn.y) <= audioBtn.r) return \"audio\";\n    return null;\n  }\n\n  // Keyboard controls\n  canvas.addEventListener(\"keydown\", (e) => {\n    // Ensure audio starts on first key\n    if (audioAvailable && audioCtx && audioCtx.state === \"suspended\") {\n      ensureAudioRunning();\n    }\n    if ([\"ArrowLeft\", \"ArrowRight\", \"ArrowUp\", \"ArrowDown\"].includes(e.key)) {\n      e.preventDefault();\n    }\n    switch (e.key) {\n      case \"ArrowLeft\":\n        keyboardIndex = (keyboardIndex - 1 + tokens.length) % tokens.length;\n        playClick();\n        aria(`Selected token ${tokens[keyboardIndex].value}. Press Enter to toggle it.`);\n        break;\n      case \"ArrowRight\":\n        keyboardIndex = (keyboardIndex + 1) % tokens.length;\n        playClick();\n        aria(`Selected token ${tokens[keyboardIndex].value}. Press Enter to toggle it.`);\n        break;\n      case \"Enter\":\n      case \" \":\n        // toggle selected token\n        if (tokens[keyboardIndex]) {\n          toggleTokenSelection(tokens[keyboardIndex].id);\n        }\n        break;\n      case \"Backspace\":\n      case \"Delete\":\n        handleClear();\n        break;\n      case \"s\":\n      case \"S\":\n        handleSubmit();\n        break;\n      case \"a\":\n      case \"A\":\n        toggleAudio();\n        break;\n    }\n  });\n\n  // Draw helpers\n  function drawRoundedRect(x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  // Main render loop\n  function render() {\n    tick++;\n    rotatingCogAngle += 0.008 * (1 + level * 0.05);\n    // background\n    ctx.fillStyle = palette.bg;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // soft gradient sky panel\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, \"#eef7fb\");\n    g.addColorStop(1, \"#f6fbff\");\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Soft ground\n    ctx.fillStyle = \"#eaf7f5\";\n    ctx.fillRect(0, HEIGHT - 110, WIDTH, 110);\n\n    // Wacky machine body\n    ctx.save();\n    ctx.translate(WIDTH / 2 - 40, HEIGHT / 2 - 20);\n    ctx.fillStyle = palette.machine;\n    drawRoundedRect(-180, -120, 420, 240, 24); // main body\n    ctx.fillStyle = palette.subtle;\n    // machine screen\n    ctx.fillRect(40, -90, 160, 60);\n    ctx.fillStyle = palette.accent;\n    ctx.fillRect(48, -82, 144, 44);\n    ctx.restore();\n\n    // Screen text\n    ctx.fillStyle = palette.text;\n    ctx.font = \"22px sans-serif\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(\"Wacky Machine Mixer\", 18, 36);\n\n    // Draw rotating cog (left)\n    drawCog(88, 120, 48, rotatingCogAngle, \"#d6e9f0\", \"#7fb6c7\");\n    // Draw small cog right\n    drawCog(WIDTH - 140, 120, 30, -rotatingCogAngle * 1.4, \"#f0e1f9\", \"#b69ff0\");\n\n    // Draw gauge showing target\n    drawGauge(WIDTH / 2 + 160, HEIGHT / 2 - 40, target);\n\n    // Draw bowl where tokens go\n    drawBowl(WIDTH / 2 + 140, HEIGHT / 2 + 20, 90);\n\n    // Draw tokens\n    for (let i = 0; i < tokens.length; i++) {\n      const t = tokens[i];\n      // gently bobbing\n      t.wobble += 0.02;\n      if (!selectedIds.has(t.id) && !t.used && (!drag || drag.token.id !== t.id)) {\n        // drift toward base position\n        const base = computeTokenBasePositions(tokens.length)[i];\n        t.x += (base.x - t.x) * 0.08;\n        t.y += (base.y - t.y) * 0.08;\n      }\n      drawToken(t, i === keyboardIndex);\n    }\n\n    // Draw submit and clear buttons\n    drawButtons();\n\n    // Draw HUD: level, score, attempts\n    ctx.fillStyle = palette.text;\n    ctx.font = \"16px sans-serif\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(`Level ${level} / ${MAX_LEVELS}`, 18, HEIGHT - 78);\n    ctx.fillText(`Score ${score}`, 18, HEIGHT - 54);\n    ctx.fillText(`Attempts left: ${attemptsLeft}`, 18, HEIGHT - 30);\n\n    // Draw audio icon + visualizer\n    drawAudioIcon(WIDTH - 70, 20, showAudioOn);\n\n    // Draw subtle wacky animated pipes\n    drawPipes();\n\n    requestAnimationFrame(render);\n  }\n\n  function drawPipes() {\n    ctx.save();\n    ctx.globalAlpha = 0.6;\n    ctx.strokeStyle = \"#cbeaf0\";\n    ctx.lineWidth = 6;\n    ctx.beginPath();\n    ctx.moveTo(20, 80);\n    ctx.bezierCurveTo(120, 20, 240, 40, WIDTH / 2 - 120, HEIGHT / 2 - 40);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.moveTo(WIDTH - 20, 80);\n    ctx.bezierCurveTo(WIDTH - 160, 20, WIDTH - 280, 80, WIDTH / 2 + 80, HEIGHT / 2 - 40);\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  function drawAudioIcon(x, y, on) {\n    // circle speaker with pulse\n    ctx.save();\n    ctx.beginPath();\n    ctx.arc(x, y, 18, 0, Math.PI * 2);\n    ctx.fillStyle = on ? \"#e9fff8\" : \"#f5f5f5\";\n    ctx.fill();\n    ctx.strokeStyle = \"#cde7e3\";\n    ctx.stroke();\n    // speaker shape\n    ctx.fillStyle = on ? \"#1a6b5a\" : \"#6c6c6c\";\n    ctx.beginPath();\n    ctx.moveTo(x - 6, y - 6);\n    ctx.lineTo(x - 2, y - 6);\n    ctx.lineTo(x + 2, y - 10);\n    ctx.lineTo(x + 2, y + 10);\n    ctx.lineTo(x - 2, y + 6);\n    ctx.lineTo(x - 6, y + 6);\n    ctx.closePath();\n    ctx.fill();\n    // waves if on, animate\n    if (on) {\n      const waveCount = 2;\n      for (let i = 1; i <= waveCount; i++) {\n        ctx.beginPath();\n        ctx.strokeStyle = `rgba(26,107,90,${0.18 - i * 0.06})`;\n        ctx.lineWidth = 2;\n        ctx.arc(x + 4, y, 6 + (tick * 0.8 + i * 8) % 12, -0.6, 0.6);\n        ctx.stroke();\n      }\n    }\n    ctx.restore();\n  }\n\n  function drawButtons() {\n    // clear\n    const clear = { x: WIDTH - 280, y: HEIGHT - 120, w: 110, h: 44 };\n    ctx.fillStyle = \"#fff\";\n    ctx.strokeStyle = \"#cfe7f3\";\n    ctx.lineWidth = 2;\n    drawRoundedRect(clear.x, clear.y, clear.w, clear.h, 8);\n    ctx.fillStyle = palette.text;\n    ctx.font = \"16px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"Clear\", clear.x + clear.w / 2, clear.y + clear.h / 2 + 6);\n\n    // submit\n    const submit = { x: WIDTH - 140, y: HEIGHT - 120, w: 110, h: 44 };\n    ctx.fillStyle = \"#aee7d6\";\n    ctx.strokeStyle = \"#89cdb3\";\n    drawRoundedRect(submit.x, submit.y, submit.w, submit.h, 10);\n    ctx.fillStyle = palette.text;\n    ctx.fillText(\"Submit\", submit.x + submit.w / 2, submit.y + submit.h / 2 + 6);\n  }\n\n  function drawBowl(cx, cy, r) {\n    ctx.save();\n    ctx.translate(cx, cy);\n    // shadow\n    ctx.beginPath();\n    ctx.ellipse(0, r - 12, r * 1.1, 16, 0, 0, Math.PI * 2);\n    ctx.fillStyle = \"rgba(40,60,60,0.06)\";\n    ctx.fill();\n    // bowl\n    ctx.beginPath();\n    ctx.moveTo(-r, -20);\n    ctx.quadraticCurveTo(0, -r - 10, r, -20);\n    ctx.lineTo(r, 40);\n    ctx.quadraticCurveTo(0, r, -r, 40);\n    ctx.closePath();\n    ctx.fillStyle = \"#f3fbff\";\n    ctx.fill();\n    ctx.strokeStyle = \"#cfe7f3\";\n    ctx.stroke();\n    // digital display showing current sum\n    ctx.fillStyle = \"#e7f7ff\";\n    ctx.fillRect(-54, -12, 108, 28);\n    ctx.strokeStyle = \"#bfe6f0\";\n    ctx.strokeRect(-54, -12, 108, 28);\n    ctx.fillStyle = palette.text;\n    ctx.font = \"18px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(`${currentSelectionSum()} / ${target}`, 0, 8);\n    ctx.restore();\n  }\n\n  function drawGauge(x, y, value) {\n    ctx.save();\n    ctx.translate(x, y);\n    // circular gauge\n    ctx.beginPath();\n    ctx.arc(0, 0, 64, Math.PI * 0.8, Math.PI * 2.2);\n    ctx.strokeStyle = \"#ddeffd\";\n    ctx.lineWidth = 18;\n    ctx.stroke();\n    // needle\n    const fraction = clamp(value / 30, 0, 1); // scale\n    const angle = Math.PI * 0.8 + (Math.PI * 1.4) * fraction;\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(Math.cos(angle) * 56, Math.sin(angle) * 56);\n    ctx.strokeStyle = \"#15707a\";\n    ctx.lineWidth = 3;\n    ctx.stroke();\n    // center dot\n    ctx.beginPath();\n    ctx.arc(0, 0, 6, 0, Math.PI * 2);\n    ctx.fillStyle = \"#15707a\";\n    ctx.fill();\n    // label\n    ctx.fillStyle = palette.text;\n    ctx.font = \"18px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"Target\", 0, -84);\n    ctx.font = \"24px sans-serif\";\n    ctx.fillText(value, 0, -56);\n    ctx.restore();\n  }\n\n  function drawToken(t, highlighted = false) {\n    ctx.save();\n    // shadow\n    ctx.beginPath();\n    ctx.ellipse(t.x + 6, t.y + 8, t.r * 0.9, t.r * 0.5, 0, 0, Math.PI * 2);\n    ctx.fillStyle = \"rgba(40,60,60,0.08)\";\n    ctx.fill();\n\n    // token body\n    ctx.beginPath();\n    ctx.arc(t.x, t.y, t.r, 0, Math.PI * 2);\n    ctx.fillStyle = t.color;\n    ctx.fill();\n    ctx.strokeStyle = highlighted ? \"#3b6f6b\" : \"#c7dfe6\";\n    ctx.lineWidth = highlighted ? 4 : 2;\n    ctx.stroke();\n\n    // little face to be wacky\n    ctx.fillStyle = \"#ffffffcc\";\n    ctx.beginPath();\n    ctx.arc(t.x - 8, t.y - 4, 6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(t.x + 6, t.y - 4, 6, 0, Math.PI * 2);\n    ctx.fill();\n    // pupils\n    ctx.fillStyle = \"#333\";\n    ctx.beginPath();\n    ctx.arc(t.x - 7, t.y - 3, 2, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(t.x + 5, t.y - 3, 2, 0, Math.PI * 2);\n    ctx.fill();\n\n    // value text\n    ctx.fillStyle = palette.text;\n    ctx.font = \"bold 18px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(t.value, t.x, t.y + 6);\n\n    // used overlay\n    if (t.used) {\n      ctx.fillStyle = \"rgba(255,255,255,0.7)\";\n      ctx.beginPath();\n      ctx.arc(t.x, t.y, t.r - 6, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.fillStyle = palette.text;\n      ctx.font = \"14px sans-serif\";\n      ctx.fillText(\"\u2713\", t.x, t.y + 5);\n    }\n\n    // selection glow\n    if (selectedIds.has(t.id)) {\n      ctx.beginPath();\n      ctx.arc(t.x, t.y, t.r + 8, 0, Math.PI * 2);\n      ctx.strokeStyle = palette.right;\n      ctx.lineWidth = 6;\n      ctx.stroke();\n    }\n\n    ctx.restore();\n  }\n\n  function drawCog(cx, cy, radius, angle, fill, stroke) {\n    ctx.save();\n    ctx.translate(cx, cy);\n    ctx.rotate(angle);\n    const teeth = 10;\n    ctx.beginPath();\n    for (let i = 0; i < teeth; i++) {\n      const a = (i / teeth) * Math.PI * 2;\n      const r1 = radius;\n      const r2 = radius * 1.28;\n      const x1 = Math.cos(a) * r1;\n      const y1 = Math.sin(a) * r1;\n      const x2 = Math.cos(a + Math.PI / teeth) * r2;\n      const y2 = Math.sin(a + Math.PI / teeth) * r2;\n      if (i === 0) ctx.moveTo(x1, y1);\n      ctx.lineTo(x2, y2);\n    }\n    ctx.closePath();\n    ctx.fillStyle = fill;\n    ctx.fill();\n    ctx.strokeStyle = stroke;\n    ctx.lineWidth = 3;\n    ctx.stroke();\n    // center\n    ctx.beginPath();\n    ctx.arc(0, 0, radius * 0.6, 0, Math.PI * 2);\n    ctx.fillStyle = \"#f8fbff\";\n    ctx.fill();\n    ctx.strokeStyle = \"#c9eaf1\";\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  // Win state drawing and handling\n  let winning = false;\n  function showWin() {\n    winning = true;\n    aria(`Fantastic! You finished all ${MAX_LEVELS} levels with a score of ${score}.`);\n    // celebration sounds\n    if (audioCtx) {\n      playBeep(0, 0.18, 880, \"sine\", 0.06);\n      playBeep(0.12, 0.18, 1100, \"sine\", 0.06);\n      playBeep(0.24, 0.26, 1318, \"sine\", 0.06);\n    }\n    // show animated fireworks for a few seconds then reset to intro\n    let t0 = performance.now();\n    let done = false;\n    function celebrate(now) {\n      // clear area\n      ctx.fillStyle = palette.bg;\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n      ctx.fillStyle = \"#f0fbff\";\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n      // big message\n      ctx.fillStyle = palette.text;\n      ctx.font = \"40px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(\"BRAVO! Machine Master!\", WIDTH / 2, HEIGHT / 2 - 20);\n      ctx.font = \"20px sans-serif\";\n      ctx.fillText(`Score: ${score}`, WIDTH / 2, HEIGHT / 2 + 14);\n      // simple fireworks\n      const elapsed = now - t0;\n      for (let i = 0; i < 8; i++) {\n        const phase = (elapsed / 1000) * (0.5 + i * 0.07);\n        const cx = WIDTH / 2 + Math.cos(phase + i) * 160;\n        const cy = HEIGHT / 2 + Math.sin(phase * 1.3 + i * 0.4) * 80;\n        drawSpark(cx, cy, (i * 37) % 360, (elapsed / 100) % 360, i + 5);\n      }\n      if (elapsed > 4200) {\n        done = true;\n      }\n      if (!done) requestAnimationFrame(celebrate);\n      else {\n        // reset game\n        level = 1;\n        score = 0;\n        winning = false;\n        generateLevel(level);\n      }\n    }\n    requestAnimationFrame(celebrate);\n  }\n\n  function drawSpark(cx, cy, hue, phase, spikes) {\n    ctx.save();\n    ctx.translate(cx, cy);\n    for (let j = 0; j < spikes; j++) {\n      ctx.beginPath();\n      const a = (j / spikes) * Math.PI * 2;\n      const r1 = 2 + (Math.sin((tick * 0.1) + j) + 1) * 10;\n      const r2 = 2 + (Math.cos((tick * 0.12) + j) + 1) * 12;\n      ctx.moveTo(Math.cos(a) * r1, Math.sin(a) * r1);\n      ctx.lineTo(Math.cos(a + 0.02) * r2, Math.sin(a + 0.02) * r2);\n      ctx.strokeStyle = `hsla(${(hue + j * 30) % 360},70%,60%,0.95)`;\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  // Start screen\n  function showIntro() {\n    ctx.fillStyle = palette.bg;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.fillStyle = palette.text;\n    ctx.font = \"28px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"Wacky Machine Mixer\", WIDTH / 2, 120);\n    ctx.font = \"18px sans-serif\";\n    ctx.fillText(\"Make the machine happy by choosing tokens that add up to the target number!\", WIDTH / 2, 160);\n    ctx.fillText(\"Use the mouse or keyboard (arrow keys to select, Enter to pick, S to submit).\", WIDTH / 2, 190);\n    ctx.fillText(\"You can use up to 4 tokens. Press A to toggle audio. Beat all levels to win!\", WIDTH / 2, 220);\n\n    // small start button drawn on canvas\n    ctx.fillStyle = \"#aee7d6\";\n    drawRoundedRect(WIDTH / 2 - 80, 260, 160, 52, 10);\n    ctx.fillStyle = palette.text;\n    ctx.font = \"20px sans-serif\";\n    ctx.fillText(\"Start Game\", WIDTH / 2, 292);\n\n    // keyboard instructions block left\n    ctx.fillStyle = \"#fff\";\n    drawRoundedRect(32, 320, 240, 120, 12);\n    ctx.fillStyle = palette.text;\n    ctx.font = \"14px sans-serif\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(\"Keyboard\", 48, 344);\n    ctx.fillText(\"\u2190 \u2192 : Select tokens\", 48, 364);\n    ctx.fillText(\"Enter or Space: Toggle token\", 48, 384);\n    ctx.fillText(\"S: Submit   Delete: Clear\", 48, 404);\n\n    // clickable start\n    canvas.addEventListener(\"click\", startClickHandler);\n    canvas.addEventListener(\"touchend\", startClickHandler);\n    aria(\"Welcome! Press Start to play. Use keyboard or mouse to interact.\");\n  }\n\n  function startClickHandler(e) {\n    let pos;\n    if (e.changedTouches) {\n      const t0 = e.changedTouches[0];\n      const rect = canvas.getBoundingClientRect();\n      pos = { x: t0.clientX - rect.left, y: t0.clientY - rect.top };\n    } else {\n      pos = getMouse(e);\n    }\n    if (pos.x >= WIDTH / 2 - 80 && pos.x <= WIDTH / 2 + 80 && pos.y >= 260 && pos.y <= 312) {\n      canvas.removeEventListener(\"click\", startClickHandler);\n      canvas.removeEventListener(\"touchend\", startClickHandler);\n      // ensure audio will start on next gesture\n      if (audioCtx && audioCtx.state === \"suspended\") {\n        ensureAudioRunning();\n      }\n      generateLevel(level);\n      requestAnimationFrame(render);\n    }\n  }\n\n  // Error and fallback messages for audio\n  if (!audioAvailable) {\n    aria(\"Audio is not available in this browser. The game will play without sound.\");\n    showAudioOn = false;\n  } else {\n    // ensure audio starts on first canvas focus/click\n    const resumeOnInteract = () => {\n      if (audioCtx && audioCtx.state === \"suspended\") {\n        audioCtx.resume().catch(() => {});\n      }\n      canvas.removeEventListener(\"pointerdown\", resumeOnInteract);\n      canvas.removeEventListener(\"keydown\", resumeOnInteract);\n    };\n    canvas.addEventListener(\"pointerdown\", resumeOnInteract);\n    canvas.addEventListener(\"keydown\", resumeOnInteract);\n  }\n\n  // Initialize to intro\n  showIntro();\n\n  // Helper: subsetSumIndices requires careful but this simple approach above is ok.\n\n  // END of IIFE\n})();\n---\n",
  "improve_response_tokens": 23549,
  "formatted_code": true,
  "formatting_response_tokens": 25468,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}