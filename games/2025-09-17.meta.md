# Game of the Day - 2025-09-17

## Metadata
- **Generated Date:** 2025-09-17
- **Generated Time:** 2025-09-17T00:27:08.927586
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-17.js
- **File Size:** 30254 bytes
- **Tokens Used:** 10072

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-17.js` - The playable game
- `2025-09-17.meta.json` - Machine-readable metadata
- `2025-09-17.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 19502

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 20033

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Machines Math Game
  // Designed for children ages 7-9. Rendered inside element with ID "game-of-the-day-stage".
  // All visuals are drawn on a canvas. Sounds are generated with Web Audio API oscillators/filters.
  // Accessible via keyboard and mouse. Clean, commented code.

  // --- Setup container and canvas ---
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Game container with ID "game-of-the-day-stage" not found.');
    return;
  }
  // Clear container
  container.innerHTML = '';
  container.style.position = 'relative';
  container.style.width = '720px';
  container.style.height = '480px';
  container.setAttribute('role', 'application');
  container.setAttribute('aria-label', 'Machines Math Game. Press Enter to begin.');

  const canvas = document.createElement('canvas');
  canvas.width = 720;
  canvas.height = 480;
  canvas.setAttribute('aria-hidden', 'false');
  canvas.style.display = 'block';
  canvas.style.outline = 'none';
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Accessible text area and controls (live region)
  const liveRegion = document.createElement('div');
  liveRegion.setAttribute('aria-live', 'polite');
  liveRegion.style.position = 'absolute';
  liveRegion.style.left = '0';
  liveRegion.style.top = '0';
  liveRegion.style.width = '1px';
  liveRegion.style.height = '1px';
  liveRegion.style.overflow = 'hidden';
  liveRegion.style.clip = 'rect(1px, 1px, 1px, 1px)';
  container.appendChild(liveRegion);

  // On-screen instructions area so players can read controls
  const instructionsBox = document.createElement('div');
  instructionsBox.style.position = 'absolute';
  instructionsBox.style.left = '8px';
  instructionsBox.style.top = '8px';
  instructionsBox.style.padding = '6px 8px';
  instructionsBox.style.background = 'rgba(255,255,255,0.85)';
  instructionsBox.style.borderRadius = '8px';
  instructionsBox.style.fontFamily = 'sans-serif';
  instructionsBox.style.fontSize = '12px';
  instructionsBox.style.color = '#222';
  instructionsBox.style.maxWidth = '340px';
  instructionsBox.innerHTML =
    '<strong>Machines Math</strong><br>Use ← → or A/D to move. Press Space or Enter to pick a tile. Click tiles to pick. Press M to mute/unmute audio. Press Enter to start.';
  container.appendChild(instructionsBox);

  // Audio state and Web Audio API setup
  let audioEnabled = true;
  let audioContext = null;
  let masterGain = null;
  let backgroundOsc = null;
  let backgroundLFO = null;
  let audioAvailable = false;

  function initAudio() {
    try {
      // Some browsers require user gesture to resume; handle gracefully
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtx) {
        throw new Error('Web Audio API not supported.');
      }
      audioContext = new AudioCtx();
      masterGain = audioContext.createGain();
      masterGain.gain.value = 0.12; // default low volume
      masterGain.connect(audioContext.destination);

      // Background gentle hum
      backgroundOsc = audioContext.createOscillator();
      backgroundOsc.type = 'sine';
      backgroundOsc.frequency.value = 110; // low hum
      const bgFilter = audioContext.createBiquadFilter();
      bgFilter.type = 'lowpass';
      bgFilter.frequency.value = 500;
      backgroundOsc.connect(bgFilter);

      backgroundLFO = audioContext.createOscillator();
      backgroundLFO.type = 'sine';
      backgroundLFO.frequency.value = 0.08;
      const lfoGain = audioContext.createGain();
      lfoGain.gain.value = 10;

      backgroundLFO.connect(lfoGain);
      lfoGain.connect(bgFilter.frequency);

      bgFilter.connect(masterGain);

      backgroundOsc.start();
      backgroundLFO.start();

      audioAvailable = true;
      audioEnabled = true;
    } catch (e) {
      console.warn('Audio initialization failed:', e);
      audioAvailable = false;
      audioEnabled = false;
    }
  }

  function tryResumeAudio() {
    if (!audioContext) return;
    if (typeof audioContext.resume === 'function') {
      audioContext.resume().catch((e) => {
        console.warn('Audio resume failed:', e);
      });
    }
  }

  // Utility to play a short tone/pulse
  function playTone({ freq = 440, type = 'sine', duration = 0.2, volume = 0.18, attack = 0.01, release = 0.05 }) {
    if (!audioAvailable || !audioEnabled) return;
    try {
      const now = audioContext.currentTime;
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      const filter = audioContext.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = Math.max(800, freq * 2);

      osc.type = type;
      osc.frequency.setValueAtTime(freq, now);
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.linearRampToValueAtTime(volume, now + attack);
      gain.gain.linearRampToValueAtTime(0.0001, now + duration - release);

      osc.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);

      osc.start(now);
      osc.stop(now + duration + 0.05);
    } catch (e) {
      console.warn('playTone error', e);
    }
  }

  function playSuccess() {
    // Harmonious burst
    playTone({ freq: 660, type: 'sine', duration: 0.18, volume: 0.16 });
    setTimeout(() => playTone({ freq: 880, type: 'triangle', duration: 0.14, volume: 0.12 }), 70);
    setTimeout(() => playTone({ freq: 1100, type: 'sine', duration: 0.12, volume: 0.08 }), 150);
    announce('Correct! Machine powered up.');
  }

  function playFail() {
    // Gentle buzzer in lower octave
    playTone({ freq: 180, type: 'square', duration: 0.28, volume: 0.14 });
    setTimeout(() => playTone({ freq: 120, type: 'square', duration: 0.15, volume: 0.10 }), 80);
    announce('Not quite. Try again.');
  }

  function announce(text) {
    liveRegion.textContent = text;
  }

  // Start audio on user gesture to satisfy browsers
  function ensureAudioOnUserGesture() {
    function userGesture() {
      tryResumeAudio();
      window.removeEventListener('keydown', userGesture);
      window.removeEventListener('pointerdown', userGesture);
    }
    window.addEventListener('keydown', userGesture);
    window.addEventListener('pointerdown', userGesture);
  }

  // Initialize audio but allow for browsers blocking until gesture
  initAudio();
  ensureAudioOnUserGesture();

  // --- Game state ---
  const GAME_WIDTH = 720;
  const GAME_HEIGHT = 480;

  let running = true;
  let lastTime = 0;
  let frame = 0;

  const levels = [
    { target: 8, tiles: 4, maxNum: 9 }, // easy
    { target: 12, tiles: 4, maxNum: 12 },
    { target: 15, tiles: 5, maxNum: 15 },
    { target: 18, tiles: 5, maxNum: 20 },
    { target: 21, tiles: 6, maxNum: 20 }
  ];
  let currentLevelIndex = -1;
  let tiles = []; // {value, x, y, w, h, picked}
  let selectorIndex = 0;
  let picks = []; // indices of picked tiles for current attempt
  let attempts = 0;
  let maxAttemptsBeforeHint = 2;
  let showOverlay = true;
  let gameMessage = 'Press Enter to Start!';
  let victory = false;
  let audioMutedVisual = false;

  // Floating gears for background animation
  const floatingGears = [];
  for (let i = 0; i < 8; i++) {
    floatingGears.push({
      x: Math.random() * GAME_WIDTH,
      y: Math.random() * GAME_HEIGHT,
      r: 12 + Math.random() * 28,
      speed: 0.1 + Math.random() * 0.35,
      angle: Math.random() * Math.PI * 2,
      color: `hsla(${120 + Math.random() * 80}, 60%, ${60 - Math.random() * 10}%, 0.15)`
    });
  }

  // --- Helper functions for level generation ---
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function generateLevel(index) {
    const def = levels[index];
    const count = def.tiles;
    const maxNum = def.maxNum;
    const target = def.target;
    const optionCount = count;

    // Ensure there exists at least one solution of two numbers adding to target
    // We'll construct options guaranteeing at least one correct pair.
    const options = [];
    // choose one correct pair (a,b)
    let a = randInt(1, Math.min(maxNum, target - 1));
    let b = target - a;
    if (b < 1) {
      a = 1;
      b = target - a;
    }
    options.push(a, b);

    // fill the rest with distractors (random numbers)
    while (options.length < optionCount) {
      let n = randInt(1, maxNum);
      // avoid duplicates too many times
      if (options.includes(n) && Math.random() > 0.5) continue;
      // avoid accidentally creating an extra correct pair too often
      // but it's ok if multiple solutions exist
      options.push(n);
    }

    // Shuffle options
    for (let i = options.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [options[i], options[j]] = [options[j], options[i]];
    }

    // Place tiles along a conveyor belt area
    tiles = [];
    const beltLeft = 60;
    const beltRight = GAME_WIDTH - 60;
    const beltTop = 320;
    const availableWidth = beltRight - beltLeft;
    const tileWidth = Math.min(110, Math.floor(availableWidth / optionCount) - 10);
    for (let i = 0; i < options.length; i++) {
      const w = tileWidth;
      const h = 60;
      const spacing = (availableWidth - optionCount * w) / (optionCount - 1 || 1);
      const x = beltLeft + i * (w + spacing);
      const y = beltTop + 20 + (Math.sin(i * 0.8) * 4);
      tiles.push({
        value: options[i],
        x,
        y,
        w,
        h,
        picked: false,
        hover: false
      });
    }
    selectorIndex = 0;
    picks = [];
    attempts = 0;
    victory = false;
    gameMessage = `Make ${target} by selecting two tiles that add to it.`;
    announce(gameMessage);
    return { target };
  }

  let currentLevel = null;

  function startNextLevel() {
    currentLevelIndex++;
    if (currentLevelIndex >= levels.length) {
      // Victory!
      victory = true;
      showOverlay = true;
      gameMessage = 'You fixed all the machines! Great job!';
      announce(gameMessage);
      return;
    }
    currentLevel = generateLevel(currentLevelIndex);
    showOverlay = false;
  }

  // --- Drawing functions ---
  function drawBackground(delta) {
    // Soft gradient
    const g = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
    g.addColorStop(0, '#EAF8FF');
    g.addColorStop(1, '#F7FFF7');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    // Floating gears (wacky shapes)
    floatingGears.forEach((gear, i) => {
      gear.y -= gear.speed * delta * 0.06;
      gear.angle += 0.003 * (i % 3 === 0 ? 1 : -1) * delta * 0.02;
      if (gear.y + gear.r < -20) {
        gear.y = GAME_HEIGHT + 40;
        gear.x = Math.random() * GAME_WIDTH;
      }
      ctx.save();
      ctx.translate(gear.x, gear.y);
      ctx.rotate(gear.angle);
      ctx.fillStyle = gear.color;
      drawGear(0, 0, gear.r, 8, 0.45);
      ctx.restore();
    });

    // Light piston motion shapes as subtle stripes
    ctx.save();
    ctx.globalAlpha = 0.06;
    ctx.fillStyle = '#000';
    for (let i = -1; i < GAME_WIDTH / 60 + 2; i++) {
      ctx.beginPath();
      ctx.ellipse(40 + i * 60 - (frame % 200) / 8, GAME_HEIGHT - 40, 60, 16, 0, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawGear(cx, cy, r, teeth = 8, innerRatio = 0.5) {
    // Draw a gear shape
    const outer = r;
    const inner = r * innerRatio;
    ctx.beginPath();
    for (let i = 0; i < teeth; i++) {
      const a = (i / teeth) * Math.PI * 2;
      const a2 = ((i + 0.5) / teeth) * Math.PI * 2;
      const ax = Math.cos(a) * outer;
      const ay = Math.sin(a) * outer;
      ctx.lineTo(ax, ay);
      const bx = Math.cos(a2) * inner;
      const by = Math.sin(a2) * inner;
      ctx.lineTo(bx, by);
    }
    ctx.closePath();
    ctx.fill();
    // center hole
    ctx.fillStyle = '#FFF';
    ctx.beginPath();
    ctx.arc(0, 0, inner * 0.45, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawMachineArea() {
    // Central machine with two slots
    const mx = GAME_WIDTH / 2;
    const my = 160;
    const mw = 420;
    const mh = 180;

    // Machine body
    ctx.save();
    // Body shadow
    ctx.fillStyle = '#000';
    ctx.globalAlpha = 0.06;
    ctx.fillRect(mx - mw / 2 + 10, my - mh / 2 + 10, mw, mh);
    ctx.globalAlpha = 1;
    // Body
    const grad = ctx.createLinearGradient(mx - mw / 2, my - mh / 2, mx + mw / 2, my + mh / 2);
    grad.addColorStop(0, '#FFFBEE');
    grad.addColorStop(1, '#E8F7FF');
    roundRect(ctx, mx - mw / 2, my - mh / 2, mw, mh, 18, true, false);
    ctx.fillStyle = grad;
    ctx.globalAlpha = 1;
    ctx.fill();

    // Pipes and dials
    ctx.fillStyle = '#D5EAF1';
    roundRect(ctx, mx - mw / 2 + 12, my - mh / 2 + 12, mw - 24, mh - 24, 12, true, false);
    // Slots for numbers
    const slotW = 110;
    const slotH = 60;
    const leftSlotX = mx - 80 - slotW / 2;
    const rightSlotX = mx + 80 - slotW / 2;
    const slotY = my - slotH / 2;
    // left slot
    ctx.fillStyle = '#FFF';
    roundRect(ctx, leftSlotX, slotY, slotW, slotH, 10, true, false);
    ctx.fillStyle = '#BFDDE9';
    ctx.fillRect(leftSlotX, slotY + slotH - 10, slotW, 8);
    // right slot
    ctx.fillStyle = '#FFF';
    roundRect(ctx, rightSlotX, slotY, slotW, slotH, 10, true, false);
    ctx.fillStyle = '#BFDDE9';
    ctx.fillRect(rightSlotX, slotY + slotH - 10, slotW, 8);

    // Target display
    ctx.fillStyle = '#111';
    ctx.font = '700 26px "Segoe UI", Roboto, Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`Target: ${currentLevel ? currentLevel.target : '-'}`, mx, my - mh / 2 + 36);

    // Fill the picks visually
    ctx.fillStyle = '#222';
    ctx.font = '700 34px "Segoe UI", Roboto, Arial';
    if (picks.length > 0) {
      const val = tiles[picks[0]] ? tiles[picks[0]].value : '';
      ctx.fillText(val, leftSlotX + slotW / 2, slotY + slotH / 2 + 11);
    } else {
      ctx.fillStyle = '#888';
      ctx.font = '600 18px "Segoe UI", Roboto, Arial';
      ctx.fillText('Add first tile', leftSlotX + slotW / 2, slotY + slotH / 2 + 8);
    }
    if (picks.length > 1) {
      ctx.fillStyle = '#222';
      ctx.font = '700 34px "Segoe UI", Roboto, Arial';
      const val = tiles[picks[1]] ? tiles[picks[1]].value : '';
      ctx.fillText(val, rightSlotX + slotW / 2, slotY + slotH / 2 + 11);
    } else {
      ctx.fillStyle = '#888';
      ctx.font = '600 18px "Segoe UI", Roboto, Arial';
      ctx.fillText('Add second tile', rightSlotX + slotW / 2, slotY + slotH / 2 + 8);
    }

    // Power meter
    const meterX = mx + mw / 2 - 46;
    const meterY = my - mh / 2 + 12;
    const meterH = 100;
    ctx.fillStyle = '#EEE';
    roundRect(ctx, meterX, meterY, 28, meterH, 6, true, false);
    // compute current power if picks 2
    let powerRatio = 0;
    if (picks.length === 2) {
      const sum = tiles[picks[0]].value + tiles[picks[1]].value;
      powerRatio = Math.max(0, Math.min(1, sum / (currentLevel.target * 1.2)));
    } else {
      powerRatio = 0.1;
    }
    const filledH = meterH * powerRatio;
    ctx.fillStyle = '#9EE493';
    roundRect(ctx, meterX + 2, meterY + meterH - filledH + 2, 24, filledH - 4, 6, true, false);

    // Labels for machine
    ctx.fillStyle = '#2B3A42';
    ctx.font = '600 14px "Segoe UI", Roboto, Arial';
    ctx.fillText('Power', meterX + 14, meterY + meterH + 16);

    ctx.restore();
  }

  function drawTiles() {
    // Conveyor belt
    const beltX = 40;
    const beltY = 340;
    const beltW = GAME_WIDTH - 80;
    const beltH = 92;

    ctx.save();
    ctx.fillStyle = '#DDEFF3';
    roundRect(ctx, beltX, beltY, beltW, beltH, 12, true, false);

    // moving stripes
    ctx.globalAlpha = 0.08;
    ctx.fillStyle = '#000';
    for (let i = 0; i < 6; i++) {
      ctx.fillRect(beltX + ((frame * 0.7 + i * 80) % beltW), beltY + 12, 40, beltH - 24);
    }
    ctx.globalAlpha = 1;

    // Draw each tile
    tiles.forEach((tile, i) => {
      const x = tile.x;
      const y = tile.y;
      const w = tile.w;
      const h = tile.h;
      // detect selector
      const isSelected = selectorIndex === i;
      // tile body
      ctx.save();
      // shadow
      ctx.fillStyle = 'rgba(0,0,0,0.08)';
      roundRect(ctx, x + 4, y + 8, w, h, 10, true, false);
      // main
      const base = `hsl(${190 + (i * 40) % 120}, 70%, ${55 - (i % 3) * 6}%)`;
      ctx.fillStyle = tile.picked ? '#EAEEF2' : base;
      roundRect(ctx, x, y, w, h, 10, true, false);

      // if hovered or selected highlight
      if (isSelected || tile.hover) {
        ctx.lineWidth = 3;
        ctx.strokeStyle = 'rgba(255,215,120,0.95)';
        roundedRectStroke(ctx, x - 2, y - 2, w + 4, h + 4, 12);
      } else {
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgba(0,0,0,0.06)';
        roundedRectStroke(ctx, x, y, w, h, 10);
      }

      // tile number
      ctx.fillStyle = tile.picked ? '#888' : '#143';
      ctx.font = tile.picked ? '600 22px "Segoe UI", Roboto' : '700 28px "Segoe UI", Roboto';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(tile.value, x + w / 2, y + h / 2);

      // little machine icon on tile
      ctx.fillStyle = 'rgba(255,255,255,0.35)';
      ctx.beginPath();
      ctx.arc(x + 20, y + 18, 10 + Math.sin((frame + i * 40) * 0.06) * 2, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    });

    ctx.restore();
  }

  function drawSelector() {
    // Draw a wrench pointing at selected tile
    const tile = tiles[selectorIndex];
    if (!tile) return;
    const x = tile.x + tile.w / 2;
    const y = tile.y - 24;
    ctx.save();
    // Shaft
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 6;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(x - 40, y + 20 + Math.sin(frame * 0.05) * 1.5);
    ctx.lineTo(x, y);
    ctx.stroke();

    // Wrench head
    ctx.fillStyle = '#465861';
    ctx.beginPath();
    ctx.arc(x, y, 14, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#FFF';
    ctx.font = '700 12px "Segoe UI", Roboto';
    ctx.textAlign = 'center';
    ctx.fillText('Grab', x, y + 4);

    // Focus ring on tile (for keyboard)
    ctx.strokeStyle = 'rgba(64, 160, 255, 0.9)';
    ctx.lineWidth = 3;
    roundedRectStroke(ctx, tile.x - 4, tile.y - 4, tile.w + 8, tile.h + 8, 12);

    ctx.restore();
  }

  function drawHUD() {
    // top right small controls: level, attempts, audio icon
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    roundRect(ctx, GAME_WIDTH - 200, 12, 188, 44, 10, true, false);
    ctx.fillStyle = '#344';
    ctx.font = '600 14px "Segoe UI", Roboto';
    ctx.textAlign = 'left';
    ctx.fillText(`Level ${Math.min(currentLevelIndex + 1, levels.length)}/${levels.length}`, GAME_WIDTH - 188, 30);

    ctx.font = '600 14px "Segoe UI", Roboto';
    ctx.fillStyle = '#666';
    ctx.textAlign = 'right';
    ctx.fillText(`Attempts: ${attempts}`, GAME_WIDTH - 18, 30);

    // Audio icon
    ctx.fillStyle = audioEnabled ? '#4CAF50' : '#D9534F';
    ctx.beginPath();
    ctx.roundRect = ctx.roundRect || function (x, y, w, h, r) {
      // polyfill if not present
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
    };
    // draw a simple speaker box
    const sx = GAME_WIDTH - 58;
    const sy = 18;
    ctx.fillRect(sx, sy, 14, 12);
    ctx.beginPath();
    ctx.moveTo(sx + 14, sy);
    ctx.lineTo(sx + 22, sy + 6);
    ctx.lineTo(sx + 14, sy + 12);
    ctx.closePath();
    ctx.fill();

    if (!audioEnabled) {
      // draw a line across
      ctx.strokeStyle = '#FFF';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(sx - 4, sy + 2);
      ctx.lineTo(sx + 30, sy + 14);
      ctx.stroke();
    }

    ctx.restore();

    // bottom left message
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    roundRect(ctx, 12, GAME_HEIGHT - 64, 360, 52, 10, true, false);
    ctx.fillStyle = '#234';
    ctx.font = '600 14px "Segoe UI", Roboto';
    ctx.textAlign = 'left';
    ctx.fillText(gameMessage, 22, GAME_HEIGHT - 36);
    ctx.restore();
  }

  function drawOverlay() {
    if (!showOverlay) return;
    ctx.save();
    // dim background
    ctx.fillStyle = 'rgba(12,22,28,0.55)';
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    // centered box
    ctx.fillStyle = '#FFF';
    roundRect(ctx, GAME_WIDTH / 2 - 260, GAME_HEIGHT / 2 - 80, 520, 160, 14, true, false);
    ctx.fillStyle = '#314658';
    ctx.font = '700 20px "Segoe UI", Roboto';
    ctx.textAlign = 'center';
    ctx.fillText(victory ? 'Machine Master!' : 'Machines Math', GAME_WIDTH / 2, GAME_HEIGHT / 2 - 36);
    ctx.font = '600 16px "Segoe UI", Roboto';
    ctx.fillStyle = '#2B3A42';
    ctx.fillText(gameMessage, GAME_WIDTH / 2, GAME_HEIGHT / 2 - 2);
    ctx.font = '600 14px "Segoe UI", Roboto';
    ctx.fillStyle = '#436';
    ctx.fillText('Controls: ← → / A D to move, Space or Enter to pick, Click to pick tiles, M to mute', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 28);

    // big start/continue button visual
    ctx.fillStyle = '#6DD3B4';
    roundRect(ctx, GAME_WIDTH / 2 - 80, GAME_HEIGHT / 2 + 40, 160, 36, 8, true, false);
    ctx.fillStyle = '#053';
    ctx.font = '700 16px "Segoe UI", Roboto';
    ctx.fillText(victory ? 'Play Again' : 'Start', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 66);

    ctx.restore();
  }

  // Utility drawing helpers
  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  function roundedRectStroke(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.stroke();
  }

  // --- Game logic interactions ---
  function pickTile(index) {
    if (!tiles[index] || tiles[index].picked) {
      return;
    }
    // pick the tile
    tiles[index].picked = true;
    picks.push(index);
    playTone({ freq: 420 + tiles[index].value * 6, type: 'sine', duration: 0.12, volume: 0.12 });
    announce(`Picked ${tiles[index].value}`);

    if (picks.length === 2) {
      attempts++;
      const val1 = tiles[picks[0]].value;
      const val2 = tiles[picks[1]].value;
      const sum = val1 + val2;
      if (sum === currentLevel.target) {
        // correct
        playSuccess();
        // animate power up (simple)
        setTimeout(() => {
          // prepare next level
          if (currentLevelIndex + 1 >= levels.length) {
            victory = true;
            showOverlay = true;
            gameMessage = 'You fixed all the machines! Great job!';
            announce(gameMessage);
          } else {
            gameMessage = 'Great! Machine repaired. Next machine incoming...';
            announce(gameMessage);
            setTimeout(() => {
              startNextLevel();
            }, 900);
          }
        }, 200);
      } else {
        // incorrect
        playFail();
        // visual shake and unpick after short delay
        gameMessage = `Oops! ${val1} + ${val2} = ${sum}. Try again.`;
        announce(gameMessage);
        setTimeout(() => {
          // put tiles back
          picks.forEach((pi) => {
            if (tiles[pi]) tiles[pi].picked = false;
          });
          picks = [];
          // hint if many attempts
          if (attempts >= maxAttemptsBeforeHint) {
            const hint = findHint(currentLevel.target, tiles.map((t) => t.value));
            if (hint) {
              gameMessage = `Hint: Try ${hint[0]} and ${hint[1]}.`;
              announce(gameMessage);
            } else {
              gameMessage = 'No matching pair among the tiles. Try different combination.';
              announce(gameMessage);
            }
          }
        }, 700);
      }
    }
  }

  function findHint(target, values) {
    for (let i = 0; i < values.length; i++) {
      for (let j = i + 1; j < values.length; j++) {
        if (values[i] + values[j] === target) return [values[i], values[j]];
      }
    }
    return null;
  }

  // Reset game
  function resetGame() {
    currentLevelIndex = -1;
    victory = false;
    startNextLevel();
  }

  // --- Input handling (keyboard & mouse) ---
  window.addEventListener('keydown', (e) => {
    if (!running) return;
    const key = e.key;
    if (showOverlay) {
      if (key === 'Enter' || key === ' ') {
        // start or continue
        e.preventDefault();
        if (victory) {
          // restart
          resetGame();
        } else {
          startNextLevel();
        }
        tryResumeAudio();
        return;
      }
    }

    if (key === 'ArrowLeft' || key === 'a' || key === 'A') {
      selectorIndex = Math.max(0, selectorIndex - 1);
      announce(`Selected tile ${selectorIndex + 1}`);
    } else if (key === 'ArrowRight' || key === 'd' || key === 'D') {
      selectorIndex = Math.min(tiles.length - 1, selectorIndex + 1);
      announce(`Selected tile ${selectorIndex + 1}`);
    } else if (key === ' ' || key === 'Enter') {
      // pick current
      e.preventDefault();
      pickTile(selectorIndex);
    } else if (/^[1-9]$/.test(key)) {
      // quick pick by number key (1..9) maps to tile indices
      const idx = parseInt(key, 10) - 1;
      if (tiles[idx]) {
        selectorIndex = idx;
        pickTile(idx);
      }
    } else if (key === 'm' || key === 'M') {
      audioEnabled = !audioEnabled;
      announce(audioEnabled ? 'Audio on' : 'Audio muted');
    } else if (key === 'Escape') {
      // Show overlay/instructions
      showOverlay = true;
      gameMessage = 'Paused. Press Enter to continue.';
      announce(gameMessage);
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    tiles.forEach((t, i) => {
      const over = mx >= t.x && mx <= t.x + t.w && my >= t.y && my <= t.y + t.h;
      t.hover = over;
      if (over) {
        selectorIndex = i;
      }
    });
  });

  canvas.addEventListener('mouseleave', (e) => {
    tiles.forEach((t) => (t.hover = false));
  });

  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    if (showOverlay) {
      // If click inside start button area
      const bx = GAME_WIDTH / 2 - 80;
      const by = GAME_HEIGHT / 2 + 40;
      const bw = 160;
      const bh = 36;
      if (mx >= bx && mx <= bx + bw && my >= by && my <= by + bh) {
        if (victory) resetGame();
        else startNextLevel();
        tryResumeAudio();
      }
      return;
    }
    // Click tiles
    for (let i = 0; i < tiles.length; i++) {
      const t = tiles[i];
      if (mx >= t.x && mx <= t.x + t.w && my >= t.y && my <= t.y + t.h) {
        selectorIndex = i;
        pickTile(i);
        break;
      }
    }
    // Click audio icon region
    const sx = GAME_WIDTH - 58;
    const sy = 18;
    if (mx >= sx - 6 && mx <= sx + 36 && my >= sy - 6 && my <= sy + 20) {
      audioEnabled = !audioEnabled;
      announce(audioEnabled ? 'Audio on' : 'Audio muted');
    }
  });

  // Touch support taps -> click logic
  canvas.addEventListener('touchstart', (e) => {
    if (e.touches.length > 0) {
      const t = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const mx = t.clientX - rect.left;
      const my = t.clientY - rect.top;
      // emulate click
      canvas.dispatchEvent(new MouseEvent('click', { clientX: t.clientX, clientY: t.clientY }));
    }
    e.preventDefault();
  }, { passive: false });

  // --- Main loop ---
  function update(dt) {
    // gear animations updated in drawBackground via frame/time
  }

  function render(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const dt = timestamp - lastTime;
    lastTime = timestamp;
    frame++;

    try {
      // draw scene
      drawBackground(dt);
      if (!currentLevel) {
        // show a simple central machine placeholder
        ctx.save();
        ctx.fillStyle = '#FDFDFD';
        roundRect(ctx, GAME_WIDTH / 2 - 220, 80, 440, 220, 16, true, false);
        ctx.fillStyle = '#2C3B46';
        ctx.font = '700 26px "Segoe UI", Roboto';
        ctx.textAlign = 'center';
        ctx.fillText('Welcome to the Machine Lab', GAME_WIDTH / 2, 140);
        ctx.font = '600 16px "Segoe UI", Roboto';
        ctx.fillStyle = '#456';
        ctx.fillText('Solve puzzles to power the machines. Press Enter to begin.', GAME_WIDTH / 2, 180);
        ctx.restore();
      } else {
        drawMachineArea();
        drawTiles();
        drawSelector();
      }
      drawHUD();
      drawOverlay();
    } catch (e) {
      // drawing error handling
      console.error('Render error', e);
      ctx.save();
      ctx.fillStyle = '#FBE9E7';
      ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
      ctx.fillStyle = '#C62828';
      ctx.font = '700 16px "Segoe UI", Roboto';
      ctx.fillText('Rendering error. Please reload the page.', 20, 60);
      ctx.restore();
      running = false;
    }

    if (running) requestAnimationFrame(render);
  }

  // Start initial overlay
  showOverlay = true;
  gameMessage = 'Press Enter to Start!';

  // Begin loop
  requestAnimationFrame(render);

  // Accessibility: focus canvas for keyboard interaction
  canvas.tabIndex = 0;
  canvas.style.cursor = 'pointer';
  canvas.addEventListener('focus', () => {
    announce('Canvas focused. Use arrow keys to play.');
  });

  // Focus on container so keys work immediately
  setTimeout(() => {
    try {
      canvas.focus();
    } catch (e) {}
  }, 500);

  // Safe defaults
  resetGame();

  // Expose some controls for testing (non-global)
  // Error handling summary visible in console if audio not available
  if (!audioAvailable) {
    announce('Audio unavailable. Game will play without sound.');
  }

  // End of IIFE
})();
---

