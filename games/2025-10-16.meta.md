# Game of the Day - 2025-10-16

## Metadata
- **Generated Date:** 2025-10-16
- **Generated Time:** 2025-10-16T00:28:42.438329
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-10-16.js
- **File Size:** 25596 bytes
- **Tokens Used:** 9078

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-10-16.js` - The playable game
- `2025-10-16.meta.json` - Machine-readable metadata
- `2025-10-16.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 19536

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 22287

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Drone Math Adventure
  // Designed for children ages 7-9. Renders inside element with ID "game-of-the-day-stage".
  // All visuals are canvas-drawn. Sounds using Web Audio API oscillators/filters.
  // Goal: Answer 10 questions correctly. 3 wrong answers = Game Over.
  // Controls: Mouse or number keys 1-4 to pick answers. M to toggle audio. R to restart.

  // Retrieve container
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Container element with ID "game-of-the-day-stage" not found.');
    return;
  }

  // Clear container and create canvas
  container.innerHTML = '';
  const canvas = document.createElement('canvas');
  canvas.width = 720;
  canvas.height = 480;
  canvas.setAttribute('role', 'img');
  canvas.setAttribute(
    'aria-label',
    'Drone Math Adventure. Answer math questions by clicking or pressing keys 1 to 4. Press M to toggle audio. Press R to restart.'
  );
  canvas.style.display = 'block';
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d', { alpha: false });

  // Layout constants and reserved zones to prevent overlap
  const WIDTH = 720;
  const HEIGHT = 480;
  const PADDING = 12; // min 10px padding
  const TOP_UI_HEIGHT = 56;
  const BOTTOM_UI_HEIGHT = 96;
  const GAME_AREA = {
    x: 0,
    y: TOP_UI_HEIGHT,
    w: WIDTH,
    h: HEIGHT - TOP_UI_HEIGHT - BOTTOM_UI_HEIGHT,
  };

  // Fonts
  const FONT_BODY = '16px sans-serif';
  const FONT_IMPORTANT = '22px sans-serif';
  const FONT_TITLE = '28px sans-serif';

  // Game parameters
  const TARGET_CORRECT = 10;
  const MAX_WRONG = 3;

  // State
  let correctCount = 0;
  let wrongCount = 0;
  let currentQuestion = null;
  let choices = []; // [{text, x,y,r}]
  let gameState = 'start'; // 'start', 'playing', 'victory', 'gameover'
  let focusedChoiceIndex = 0;
  let lastAnswerResult = null; // 'correct' | 'wrong' | null
  let shakeTime = 0;
  let droneX = WIDTH / 2;
  let droneY = TOP_UI_HEIGHT + GAME_AREA.h - 60;
  let droneTargetX = droneX;
  let droneTargetY = droneY;
  let bgHumOn = true;
  let lastTick = performance.now();

  // Audio setup with error handling
  let audioCtx = null;
  let bgGain = null;
  let bgOsc = null;

  function createAudioContextSafe() {
    try {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) return null;
      const ac = new Ctx();
      // Initialize background hum
      const gain = ac.createGain();
      gain.gain.value = 0.03; // gentle
      gain.connect(ac.destination);
      const osc = ac.createOscillator();
      osc.type = 'sine';
      osc.frequency.value = 110;
      const filter = ac.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 300;
      osc.connect(filter);
      filter.connect(gain);
      osc.start();
      audioCtx = ac;
      bgGain = gain;
      bgOsc = osc;
      return ac;
    } catch (e) {
      console.warn('AudioContext creation failed:', e);
      return null;
    }
  }

  audioCtx = createAudioContextSafe();
  if (!audioCtx) {
    bgHumOn = false;
  }

  // Sound effects via oscillators + envelope
  function playTone({ frequency = 440, duration = 0.2, type = 'sine', volume = 0.08, detune = 0 } = {}) {
    if (!audioCtx || !bgGain) return;
    try {
      const ac = audioCtx;
      const now = ac.currentTime;
      const osc = ac.createOscillator();
      const gain = ac.createGain();
      const filter = ac.createBiquadFilter();
      osc.type = type;
      osc.frequency.value = frequency;
      osc.detune.value = detune;
      filter.type = 'lowpass';
      filter.frequency.value = Math.max(300, frequency * 2);
      gain.gain.value = 0;
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(ac.destination);
      osc.start(now);
      // Envelope
      gain.gain.cancelScheduledValues(now);
      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime(volume, now + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
      osc.stop(now + duration + 0.02);
    } catch (e) {
      console.warn('Audio playTone error:', e);
    }
  }

  function playCorrectSound() {
    if (!audioCtx || !bgGain) return;
    // joyful ascending chime
    playTone({ frequency: 660, duration: 0.08, type: 'sine', volume: 0.06 });
    setTimeout(() => playTone({ frequency: 880, duration: 0.12, type: 'sine', volume: 0.05 }), 90);
    setTimeout(() => playTone({ frequency: 1100, duration: 0.16, type: 'triangle', volume: 0.04 }), 210);
  }

  function playWrongSound() {
    if (!audioCtx || !bgGain) return;
    // low buzz
    playTone({ frequency: 200, duration: 0.18, type: 'sawtooth', volume: 0.08 });
    setTimeout(() => playTone({ frequency: 140, duration: 0.12, type: 'sawtooth', volume: 0.06 }), 120);
  }

  function toggleBackgroundHum(on) {
    if (!audioCtx || !bgGain) return;
    try {
      bgGain.gain.setTargetAtTime(on ? 0.03 : 0, audioCtx.currentTime, 0.05);
      bgHumOn = on;
    } catch (e) {
      console.warn('toggleBackgroundHum error:', e);
    }
  }

  // Math question generator - simple addition/subtraction up to 20
  function generateQuestion() {
    const a = Math.floor(Math.random() * 11); // 0..10
    const b = Math.floor(Math.random() * 11); // 0..10
    const add = Math.random() < 0.6; // more addition
    const op = add ? '+' : '-';
    let questionText = `${a} ${op} ${b}`;
    let answer = add ? a + b : a - b;
    // ensure non-negative answer for this age
    if (answer < 0) {
      // flip to addition
      questionText = `${a + b} - ${a}`;
      answer = b;
    }
    // generate 3 distractors within small range, ensure unique
    const distractors = new Set();
    while (distractors.size < 3) {
      let delta = Math.floor(Math.random() * 7) - 3; // -3..3
      if (delta === 0) delta = 4; // avoid correct
      let cand = answer + delta;
      if (cand < 0) cand = Math.abs(cand) + 1;
      distractors.add(cand);
    }
    const options = [answer, ...Array.from(distractors)];
    // shuffle
    for (let i = options.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [options[i], options[j]] = [options[j], options[i]];
    }
    currentQuestion = { text: questionText, answer };
    choices = []; // place four circular choice buttons inside GAME_AREA, non-overlapping
    const positions = [];
    const cols = 2;
    const rows = 2;
    const marginX = 40;
    const marginY = 20;
    const cellW = (GAME_AREA.w - marginX * 2) / cols;
    const cellH = (GAME_AREA.h - marginY * 2) / rows;
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const cx = marginX + c * cellW + cellW / 2;
        const cy = GAME_AREA.y + marginY + r * cellH + cellH / 2;
        positions.push({ x: cx, y: cy });
      }
    }
    // small shuffle of positions to produce wackiness
    for (let i = positions.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [positions[i], positions[j]] = [positions[j], positions[i]];
    }
    const baseR = Math.min(cellW, cellH) / 3.2;
    for (let i = 0; i < options.length; i++) {
      const pos = positions[i];
      const jitterX = (Math.random() - 0.5) * 30;
      const jitterY = (Math.random() - 0.5) * 20;
      choices.push({
        text: String(options[i]),
        value: options[i],
        x: pos.x + jitterX,
        y: pos.y + jitterY,
        r: baseR + (Math.random() * 6 - 3),
      });
    }
    focusedChoiceIndex = 0;
  }

  // UI helpers
  function drawRoundedRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  function drawTopUI() {
    // Score top-left
    ctx.font = FONT_BODY;
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#000';
    const scoreText = `Stars: ${correctCount}/${TARGET_CORRECT}`;
    const scoreMetrics = ctx.measureText(scoreText);
    const scoreW = scoreMetrics.width + PADDING * 2;
    const scoreH = 34;
    const scoreX = PADDING;
    const scoreY = PADDING;
    // background
    ctx.fillStyle = '#d0f0ff';
    drawRoundedRect(scoreX, scoreY, scoreW, scoreH, 8);
    // text
    ctx.fillStyle = '#00334d';
    ctx.font = FONT_IMPORTANT;
    ctx.fillText(scoreText, scoreX + PADDING, scoreY + scoreH / 2);

    // Lives top-right
    const livesText = `Lives: ${Math.max(MAX_WRONG - wrongCount, 0)}`;
    ctx.font = FONT_IMPORTANT;
    const livesMetrics = ctx.measureText(livesText);
    const livesW = livesMetrics.width + PADDING * 2;
    const livesH = 34;
    const livesX = WIDTH - livesW - PADDING;
    const livesY = PADDING;
    ctx.fillStyle = '#ffe0e0';
    drawRoundedRect(livesX, livesY, livesW, livesH, 8);
    ctx.fillStyle = '#660000';
    ctx.fillText(livesText, livesX + PADDING, livesY + livesH / 2);

    // Audio indicator next to lives
    const audioText = bgHumOn ? 'Audio: On (M)' : 'Audio: Off (M)';
    ctx.font = FONT_BODY;
    const audioMetrics = ctx.measureText(audioText);
    const audioW = audioMetrics.width + PADDING * 2;
    const audioH = 26;
    const audioX = livesX - audioW - PADDING;
    const audioY = PADDING + (livesH - audioH) / 2;
    ctx.fillStyle = bgHumOn ? '#e8ffd8' : '#f0f0f0';
    drawRoundedRect(audioX, audioY, audioW, audioH, 6);
    ctx.fillStyle = bgHumOn ? '#225500' : '#333';
    ctx.fillText(audioText, audioX + PADDING, audioY + audioH / 2);
  }

  function drawBottomUI() {
    // Instructions centered bottom
    const instructions = [
      'Control: Click a cloud or press keys 1-4 to answer.',
      'Goal: Collect 10 stars by answering correctly. 3 wrong answers and the drones must rest (game over).',
      'Press R to restart at any time.',
    ];
    ctx.font = FONT_BODY;
    ctx.textBaseline = 'top';
    const combined = instructions.join('   ');
    // We'll draw a rounded background box centered
    const padding = 12;
    // Measure widest text line
    let maxWidth = 0;
    instructions.forEach((line) => {
      const m = ctx.measureText(line).width;
      if (m > maxWidth) maxWidth = m;
    });
    const boxW = Math.min(WIDTH - PADDING * 4, maxWidth + padding * 2);
    const boxH = instructions.length * 20 + padding * 2;
    const boxX = (WIDTH - boxW) / 2;
    const boxY = HEIGHT - BOTTOM_UI_HEIGHT + (BOTTOM_UI_HEIGHT - boxH) / 2;
    ctx.fillStyle = '#fff9da';
    drawRoundedRect(boxX, boxY, boxW, boxH, 10);
    ctx.fillStyle = '#333';
    ctx.font = FONT_BODY;
    for (let i = 0; i < instructions.length; i++) {
      const line = instructions[i];
      ctx.fillText(line, boxX + padding, boxY + padding + i * 20);
    }
  }

  // Drawing the drone
  function drawDrone(x, y, wobble = 0) {
    // Drone body
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(Math.sin(wobble) * 0.05);
    // body
    ctx.fillStyle = '#e6f7ff';
    drawRoundedRect(-40, -16, 80, 32, 12);
    ctx.fillStyle = '#336b87';
    ctx.fillText('DR', -14, -3); // fun marking
    // rotors: four circles with little arms
    const rotorOffsets = [
      { dx: -42, dy: -28 },
      { dx: 42, dy: -28 },
      { dx: -42, dy: 28 },
      { dx: 42, dy: 28 },
    ];
    for (let i = 0; i < rotorOffsets.length; i++) {
      const ro = rotorOffsets[i];
      ctx.beginPath();
      ctx.fillStyle = '#f7f7f7';
      ctx.strokeStyle = '#aaa';
      ctx.lineWidth = 2;
      // arm
      ctx.moveTo(ro.dx, ro.dy);
      ctx.lineTo(ro.dx + (ro.dx < 0 ? -12 : 12), ro.dy + (i < 2 ? -8 : 8));
      ctx.stroke();
      // rotor circle
      ctx.beginPath();
      ctx.ellipse(ro.dx + (ro.dx < 0 ? -20 : 20), ro.dy + (i < 2 ? -12 : 12), 14, 8, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      // rotor blade as rotated arc
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      ctx.lineWidth = 3;
      ctx.moveTo(ro.dx + (ro.dx < 0 ? -34 : 34), ro.dy + (i < 2 ? -12 : 12));
      ctx.lineTo(ro.dx + (ro.dx < 0 ? -6 : 6), ro.dy + (i < 2 ? -12 : 12));
      ctx.stroke();
    }
    ctx.restore();
  }

  // Draw answer clouds (wacky)
  function drawChoice(choice, index) {
    // Circle with a cloud-like border using multiple arcs
    const { x, y, r, text } = choice;
    ctx.save();
    // cloud body
    ctx.beginPath();
    ctx.fillStyle = '#fff';
    ctx.strokeStyle = '#8fbfe6';
    ctx.lineWidth = 3;
    // multi-arc cloud
    ctx.arc(x - r * 0.6, y, r * 0.55, Math.PI * 0.5, Math.PI * 1.5);
    ctx.arc(x - r * 0.15, y - r * 0.5, r * 0.7, Math.PI * 1.0, Math.PI * 1.9);
    ctx.arc(x + r * 0.4, y - r * 0.4, r * 0.6, Math.PI * 1.2, Math.PI * 2.0);
    ctx.arc(x + r * 0.85, y, r * 0.45, Math.PI * 1.5, Math.PI * 0.5);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Number text inside
    ctx.fillStyle = '#004466';
    ctx.font = FONT_IMPORTANT;
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'center';
    // compute width and ensure it fits, adjust font size if needed
    let fontSize = 22;
    ctx.font = `${fontSize}px sans-serif`;
    let tw = ctx.measureText(text).width;
    while (tw > r * 1.4 && fontSize > 14) {
      fontSize -= 1;
      ctx.font = `${fontSize}px sans-serif`;
      tw = ctx.measureText(text).width;
    }
    ctx.fillText(text, x, y);

    // index label small
    ctx.fillStyle = '#666';
    ctx.font = FONT_BODY;
    ctx.textAlign = 'left';
    ctx.fillText(`${index + 1}`, x - r - 6, y - r - 6);

    // focus highlight if keyboard focused
    if (focusedChoiceIndex === index && gameState === 'playing') {
      ctx.strokeStyle = '#ff9800';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.ellipse(x, y, r + 8, r + 6, 0, 0, Math.PI * 2);
      ctx.stroke();
    }

    ctx.restore();
  }

  // Handle answer attempt
  function handleAnswerChoice(index) {
    if (gameState !== 'playing') return;
    const choice = choices[index];
    if (!choice) return;
    if (choice.value === currentQuestion.answer) {
      correctCount++;
      lastAnswerResult = 'correct';
      playCorrectSound();
      // animate drone to chosen cloud
      droneTargetX = choice.x;
      droneTargetY = choice.y - 40;
      // small celebration indicator
      shakeTime = 16;
    } else {
      wrongCount++;
      lastAnswerResult = 'wrong';
      playWrongSound();
      // shake
      shakeTime = 22;
      // nudge drone away
      droneTargetX = WIDTH / 2 + (Math.random() - 0.5) * 80;
      droneTargetY = TOP_UI_HEIGHT + GAME_AREA.h - 60;
    }
    // check end conditions
    if (correctCount >= TARGET_CORRECT) {
      gameState = 'victory';
      // celebratory sound
      setTimeout(() => {
        playTone({ frequency: 880, duration: 0.12, type: 'sine', volume: 0.07 });
        playTone({ frequency: 1320, duration: 0.18, type: 'triangle', volume: 0.05 });
      }, 100);
    } else if (wrongCount >= MAX_WRONG) {
      gameState = 'gameover';
    } else {
      // prepare next question after a short delay
      setTimeout(() => {
        generateQuestion();
        lastAnswerResult = null;
      }, 700);
    }
  }

  // Input handling
  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    const my = (e.clientY - rect.top) * (canvas.height / rect.height);
    if (gameState === 'start') {
      // Start the game when clicking anywhere on canvas
      startGame();
      return;
    }
    if (gameState === 'victory' || gameState === 'gameover') {
      // Restart if clicked
      const restartClicked = true; // simple: any click restarts
      if (restartClicked) startGame();
      return;
    }
    // Check choices clicked
    for (let i = 0; i < choices.length; i++) {
      const c = choices[i];
      const dx = mx - c.x;
      const dy = my - c.y;
      if (Math.sqrt(dx * dx + dy * dy) <= c.r + 8) {
        handleAnswerChoice(i);
        return;
      }
    }
  });

  window.addEventListener('keydown', (e) => {
    if (e.key === 'M' || e.key === 'm') {
      // toggle audio
      if (!audioCtx) {
        // try to create on demand
        audioCtx = createAudioContextSafe();
        if (!audioCtx) {
          bgHumOn = false;
          return;
        } else {
          toggleBackgroundHum(true);
        }
      } else {
        toggleBackgroundHum(!bgHumOn);
      }
    } else if (e.key === 'R' || e.key === 'r') {
      startGame();
    } else if (gameState === 'start') {
      if (e.key === 'Enter' || e.key === ' ') startGame();
    } else if (gameState === 'victory' || gameState === 'gameover') {
      if (e.key === 'Enter' || e.key === ' ' || e.key === 'r' || e.key === 'R') startGame();
    } else if (gameState === 'playing') {
      // number keys 1-4
      if (/^[1-4]$/.test(e.key)) {
        const idx = Number(e.key) - 1;
        focusedChoiceIndex = idx;
        handleAnswerChoice(idx);
      } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
        focusedChoiceIndex = (focusedChoiceIndex + 1) % choices.length;
      } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
        focusedChoiceIndex = (focusedChoiceIndex - 1 + choices.length) % choices.length;
      } else if (e.key === 'Enter' || e.key === ' ') {
        handleAnswerChoice(focusedChoiceIndex);
      }
    }
  });

  // Game flow
  function startGame() {
    correctCount = 0;
    wrongCount = 0;
    focusedChoiceIndex = 0;
    lastAnswerResult = null;
    shakeTime = 0;
    droneX = WIDTH / 2;
    droneY = TOP_UI_HEIGHT + GAME_AREA.h - 60;
    droneTargetX = droneX;
    droneTargetY = droneY;
    gameState = 'playing';
    generateQuestion();
    // ensure audio context resumed on user gesture
    if (audioCtx && audioCtx.state === 'suspended') {
      audioCtx.resume().catch((e) => {
        console.warn('Audio resume failed:', e);
      });
    }
    toggleBackgroundHum(bgHumOn);
  }

  // Draw start screen
  function drawStartScreen() {
    ctx.fillStyle = '#eaf6ff';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    // Title
    ctx.fillStyle = '#00334d';
    ctx.font = FONT_TITLE;
    ctx.textBaseline = 'top';
    const title = 'Drone Math Adventure';
    const tw = ctx.measureText(title).width;
    ctx.fillStyle = '#00334d';
    // background rectangle for title
    const boxW = tw + PADDING * 2;
    const boxH = 48;
    const boxX = (WIDTH - boxW) / 2;
    const boxY = PADDING * 2;
    ctx.fillStyle = '#dff7ff';
    drawRoundedRect(boxX, boxY, boxW, boxH, 8);
    ctx.fillStyle = '#00334d';
    ctx.font = FONT_TITLE;
    ctx.fillText(title, boxX + PADDING, boxY + 8);

    // Fun drone drawing
    drawDrone(WIDTH / 2, HEIGHT / 2 - 20, performance.now() / 200);

    // Instructions
    ctx.font = FONT_IMPORTANT;
    ctx.fillStyle = '#223';
    const instr = 'Click to launch! Answer 10 questions correctly. 3 mistakes and the game ends.';
    const metrics = ctx.measureText(instr);
    const instrW = Math.min(metrics.width, WIDTH - PADDING * 4);
    const instrX = (WIDTH - instrW) / 2;
    const instrY = HEIGHT - 140;
    ctx.fillStyle = '#fff7d9';
    drawRoundedRect(instrX - 12, instrY - 8, instrW + 24, 56, 10);
    ctx.fillStyle = '#333';
    ctx.font = FONT_BODY;
    wrapText(instr, instrX, instrY, WIDTH - PADDING * 4, 18);
    // small hint
    ctx.font = FONT_BODY;
    ctx.fillStyle = '#555';
    ctx.fillText('Controls: Click clouds or press keys 1-4. M toggles audio.', instrX, instrY + 44);
  }

  function drawVictoryScreen() {
    ctx.fillStyle = '#fffbe6';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    ctx.fillStyle = '#225500';
    ctx.font = FONT_TITLE;
    ctx.fillText('You did it! Drone Champion!', PADDING * 2, PADDING * 2);
    // show confetti-like bursts
    for (let i = 0; i < 30; i++) {
      ctx.fillStyle = `hsl(${(i * 37) % 360}, 70%, 60%)`;
      const x = (i * 53) % WIDTH + Math.sin((i + performance.now() / 200) / 4) * 12;
      const y = HEIGHT / 2 + Math.cos((i + performance.now() / 300) / 3) * 40 - Math.abs(Math.sin(performance.now() / 600 + i)) * 40;
      ctx.beginPath();
      ctx.arc(x, y, 6 + (i % 3), 0, Math.PI * 2);
      ctx.fill();
    }
    // Summary box centered
    ctx.fillStyle = '#e6fff0';
    const stext = `Stars collected: ${correctCount}/${TARGET_CORRECT}`;
    ctx.font = FONT_IMPORTANT;
    const sm = ctx.measureText(stext);
    const bw = sm.width + PADDING * 2;
    const bh = 44;
    const bx = (WIDTH - bw) / 2;
    const by = HEIGHT / 2 - 20;
    drawRoundedRect(bx, by, bw, bh, 10);
    ctx.fillStyle = '#073b2f';
    ctx.fillText(stext, bx + PADDING, by + bh / 2);

    ctx.font = FONT_BODY;
    ctx.fillStyle = '#333';
    const hint = 'Press R or click to play again.';
    ctx.fillText(hint, bx, by + bh + 18);
  }

  function drawGameOverScreen() {
    ctx.fillStyle = '#fff0f0';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    ctx.fillStyle = '#660000';
    ctx.font = FONT_TITLE;
    ctx.fillText('Game Over - Drones need rest', PADDING * 2, PADDING * 2);

    // Sad drone
    drawDrone(WIDTH / 2, HEIGHT / 2 - 10, performance.now() / 500);

    ctx.fillStyle = '#fff';
    ctx.font = FONT_IMPORTANT;
    const stext = `Stars collected: ${correctCount}/${TARGET_CORRECT}`;
    const sm = ctx.measureText(stext);
    const bw = sm.width + PADDING * 2;
    const bh = 44;
    const bx = (WIDTH - bw) / 2;
    const by = HEIGHT / 2 + 60;
    ctx.fillStyle = '#ffecec';
    drawRoundedRect(bx, by, bw, bh, 10);
    ctx.fillStyle = '#660000';
    ctx.fillText(stext, bx + PADDING, by + bh / 2);

    ctx.font = FONT_BODY;
    ctx.fillStyle = '#333';
    const hint = 'Press R to try again.';
    ctx.fillText(hint, bx, by + bh + 18);
  }

  // Utility to wrap text within width (canvas)
  function wrapText(text, x, y, maxWidth, lineHeight) {
    const words = text.split(' ');
    let line = '';
    ctx.font = FONT_BODY;
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + ' ';
      const metrics = ctx.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        ctx.fillText(line, x, y);
        line = words[n] + ' ';
        y += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line, x, y);
  }

  // Main draw loop
  function draw() {
    // clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    // background calming sky with subtle gradient
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#e8f8ff');
    g.addColorStop(1, '#f7fcff');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Top and bottom UI always present (even on start/victory/gameover) but adjusted
    drawTopUI();
    drawBottomUI();

    if (gameState === 'start') {
      drawStartScreen();
      return;
    }
    if (gameState === 'victory') {
      drawVictoryScreen();
      return;
    }
    if (gameState === 'gameover') {
      drawGameOverScreen();
      return;
    }

    // playing state
    // Draw the current question in the upper part of game area
    ctx.font = FONT_IMPORTANT;
    ctx.fillStyle = '#053b4a';
    ctx.textBaseline = 'top';
    const qText = currentQuestion ? `Solve: ${currentQuestion.text}` : 'Preparing...';
    const qMetrics = ctx.measureText(qText);
    const qW = qMetrics.width + PADDING * 2;
    const qH = 40;
    const qX = (WIDTH - qW) / 2;
    const qY = PADDING + TOP_UI_HEIGHT - 40;
    ctx.fillStyle = '#fff8e6';
    drawRoundedRect(qX, qY, qW, qH, 10);
    ctx.fillStyle = '#003a4d';
    ctx.fillText(qText, qX + PADDING, qY + 10);

    // Draw choices
    for (let i = 0; i < choices.length; i++) {
      drawChoice(choices[i], i);
    }

    // Draw drone
    // apply simple smoothing towards target
    droneX += (droneTargetX - droneX) * 0.08;
    droneY += (droneTargetY - droneY) * 0.08;
    // add wobble when correct/wrong
    const wobble = Math.sin(performance.now() / 200) * 0.6;
    drawDrone(droneX + (Math.random() - 0.5) * (shakeTime > 0 ? 8 : 0), droneY + (Math.random() - 0.5) * (shakeTime > 0 ? 6 : 0), wobble);

    // show last answer feedback near drone
    if (lastAnswerResult === 'correct') {
      ctx.fillStyle = '#e8ffea';
      const t = '+1 star!';
      ctx.font = FONT_BODY;
      ctx.fillText(t, droneX - 20, droneY - 70);
    } else if (lastAnswerResult === 'wrong') {
      ctx.fillStyle = '#fff0f0';
      const t = 'Oops!';
      ctx.font = FONT_BODY;
      ctx.fillText(t, droneX - 10, droneY - 70);
    }

    // Draw little trajectory line from drone to target
    ctx.strokeStyle = '#b3e6ff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(WIDTH / 2, TOP_UI_HEIGHT + GAME_AREA.h);
    ctx.quadraticCurveTo((WIDTH / 2 + droneX) / 2, droneY - 80, droneX, droneY);
    ctx.stroke();

    // reserved bottom area will show instructions and prevents overlap

    // Decrement shake time
    if (shakeTime > 0) shakeTime--;

    // Accessibility: focus highlight note
    ctx.font = FONT_BODY;
    ctx.fillStyle = '#444';
    ctx.fillText('Focus with arrows, select with Enter, or press 1-4.', PADDING, HEIGHT - BOTTOM_UI_HEIGHT + 8);
  }

  // Game loop
  function loop(ts) {
    const dt = ts - lastTick;
    lastTick = ts;
    draw();
    requestAnimationFrame(loop);
  }

  // Start rendering
  requestAnimationFrame(loop);

  // Start page initially
  gameState = 'start';
  draw();

  // Expose minimal debug in window for testing (non-intrusive)
  window.__droneMathGame = {
    startGame,
    getState: () => ({ gameState, correctCount, wrongCount }),
  };
})();
---

