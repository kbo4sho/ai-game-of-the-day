# Game of the Day - 2025-10-07

## Metadata
- **Generated Date:** 2025-10-07
- **Generated Time:** 2025-10-07T00:27:22.439352
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-10-07.js
- **File Size:** 30776 bytes
- **Tokens Used:** 10456

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-10-07.js` - The playable game
- `2025-10-07.meta.json` - Machine-readable metadata
- `2025-10-07.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 20041

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 21268

### Final Functionality Score After Improvement
- **Score:** 7/8 (87.5%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- ⚠️  No game state management found

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function() {
  // Robo-Assembly: a calming, wacky math game for ages 7-9
  // Renders into the element with id "game-of-the-day-stage"
  // Uses Canvas for graphics and Web Audio API for sounds.
  // Accessible: keyboard controls, textual status for screen readers.

  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const TARGET_MACHINES = 5; // number of machines to assemble to win
  const PART_COUNT = 9; // number of parts visible on the belt at once
  const BELT_Y = 300;
  const BELT_HEIGHT = 110;
  const PART_SPEED = 0.5; // base speed in px per frame - will be multiplied by dt
  const PALETTE = {
    bg: '#e8f0ef',
    belt: '#d0e1dc',
    beltShadow: '#b8c9c4',
    gear: '#9fb6c3',
    partFill: ['#F9C784', '#C7E7B9', '#C8E6F5', '#F6D1E1', '#E7D3FF', '#FFE5B4'],
    text: '#13323e',
    selector: '#ff6b6b'
  };

  // Grab parent element
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Game container with id "game-of-the-day-stage" not found.');
    return;
  }
  // Clear container children and set styles
  container.innerHTML = '';
  container.style.position = 'relative';
  container.style.width = `${WIDTH}px`;
  container.style.height = `${HEIGHT}px`;
  container.style.maxWidth = `${WIDTH}px`;
  container.style.maxHeight = `${HEIGHT}px`;
  container.style.userSelect = 'none';
  container.style.fontFamily = 'sans-serif';

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.width = `${WIDTH}px`;
  canvas.style.height = `${HEIGHT}px`;
  canvas.style.display = 'block';
  canvas.setAttribute('role', 'img');
  canvas.setAttribute('aria-label', 'Robo assembly machine math game');
  canvas.tabIndex = 0; // focusable for keyboard events
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Create hidden live region for screen readers
  const statusRegion = document.createElement('div');
  statusRegion.setAttribute('role', 'status');
  statusRegion.setAttribute('aria-live', 'polite');
  statusRegion.style.position = 'absolute';
  statusRegion.style.left = '-9999px';
  statusRegion.style.top = 'auto';
  statusRegion.style.width = '1px';
  statusRegion.style.height = '1px';
  statusRegion.style.overflow = 'hidden';
  container.appendChild(statusRegion);

  // Utility functions
  function clamp(n, a, b) {
    return Math.max(a, Math.min(b, n));
  }
  function randInt(a, b) {
    return Math.floor(Math.random() * (b - a + 1)) + a;
  }
  function pick(array) {
    return array[Math.floor(Math.random() * array.length)];
  }

  // Audio Manager
  class AudioManager {
    constructor() {
      this.ctx = null;
      this.ambientGain = null;
      this.ambientOsc = null;
      this.ambientOn = false;
      this.enabled = false;
      this.muted = false;
    }

    async initFromUserGesture() {
      if (this.enabled) return true;
      try {
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        if (!AudioCtx) throw new Error('Web Audio API not supported.');
        this.ctx = new AudioCtx();
        // create master gain -> destination with gentle ramp
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.9;
        this.masterGain.connect(this.ctx.destination);

        // smooth resume in case of suspended context that needs user gesture
        if (this.ctx.state === 'suspended') {
          await this.ctx.resume();
        }

        this.enabled = true;
        this.startAmbient();
        return true;
      } catch (err) {
        console.warn('Audio initialization failed:', err);
        this.enabled = false;
        this.ctx = null;
        return false;
      }
    }

    toggleMute() {
      this.muted = !this.muted;
      if (this.masterGain) {
        this.masterGain.gain.setValueAtTime(this.muted ? 0 : 0.9, this.ctx.currentTime);
      }
    }

    startAmbient() {
      if (!this.enabled || this.ambientOn) return;
      try {
        const ctx = this.ctx;
        const g = ctx.createGain();
        g.gain.value = 0.06; // subtle
        g.connect(this.masterGain);

        // create a slowly detuned pair to make gentle pad
        const osc1 = ctx.createOscillator();
        osc1.type = 'sine';
        osc1.frequency.value = 110;
        const osc2 = ctx.createOscillator();
        osc2.type = 'triangle';
        osc2.frequency.value = 138.5;

        // subtle amplitude modulation
        const lfo = ctx.createOscillator();
        lfo.type = 'sine';
        lfo.frequency.value = 0.05; // very slow
        const lfoGain = ctx.createGain();
        lfoGain.gain.value = 0.03;

        lfo.connect(lfoGain);
        lfoGain.connect(g.gain);

        osc1.connect(g);
        osc2.connect(g);

        osc1.start();
        osc2.start();
        lfo.start();

        this.ambientOsc = [osc1, osc2, lfo];
        this.ambientGain = g;
        this.ambientOn = true;
      } catch (err) {
        console.warn('Ambient sound failed to start:', err);
      }
    }

    stopAmbient() {
      if (!this.enabled || !this.ambientOn) return;
      try {
        this.ambientOsc.forEach(o => {
          try { o.stop(); } catch (e) {}
          try { o.disconnect(); } catch (e) {}
        });
        try { this.ambientGain.disconnect(); } catch (e) {}
      } catch (err) {
        console.warn('Failed to stop ambient:', err);
      } finally {
        this.ambientOn = false;
        this.ambientOsc = null;
        this.ambientGain = null;
      }
    }

    playClick() {
      if (!this.enabled || !this.ctx) return;
      try {
        const ctx = this.ctx;
        const o = ctx.createOscillator();
        o.type = 'square';
        o.frequency.value = 880;
        const g = ctx.createGain();
        g.gain.value = 0;
        o.connect(g);
        g.connect(this.masterGain);
        const now = ctx.currentTime;
        g.gain.cancelScheduledValues(now);
        g.gain.setValueAtTime(0, now);
        g.gain.linearRampToValueAtTime(0.06, now + 0.01);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
        o.start(now);
        o.stop(now + 0.25);
      } catch (err) {
        console.warn('playClick failed', err);
      }
    }

    playCorrect() {
      if (!this.enabled || !this.ctx) return;
      try {
        const ctx = this.ctx;
        const o = ctx.createOscillator();
        o.type = 'sine';
        o.frequency.setValueAtTime(660, ctx.currentTime);
        const o2 = ctx.createOscillator();
        o2.type = 'sine';
        o2.frequency.setValueAtTime(880, ctx.currentTime);
        const g = ctx.createGain();
        g.gain.value = 0;
        const filter = ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 1200;
        o.connect(filter);
        o2.connect(filter);
        filter.connect(g);
        g.connect(this.masterGain);
        const now = ctx.currentTime;
        g.gain.setValueAtTime(0.0001, now);
        g.gain.exponentialRampToValueAtTime(0.15, now + 0.03);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.7);
        o.start(now);
        o2.start(now);
        o.stop(now + 0.8);
        o2.stop(now + 0.8);
      } catch (err) {
        console.warn('playCorrect failed', err);
      }
    }

    playWrong() {
      if (!this.enabled || !this.ctx) return;
      try {
        const ctx = this.ctx;
        const o = ctx.createOscillator();
        o.type = 'sawtooth';
        o.frequency.value = 220;
        const g = ctx.createGain();
        g.gain.value = 0;
        const now = ctx.currentTime;
        o.connect(g);
        g.connect(this.masterGain);
        g.gain.setValueAtTime(0.0001, now);
        g.gain.exponentialRampToValueAtTime(0.12, now + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);
        o.start(now);
        o.stop(now + 0.45);
      } catch (err) {
        console.warn('playWrong failed', err);
      }
    }

    showUnavailable() {
      // Called when audio cannot be created; no-op except for logging
      console.warn('Audio is unavailable.');
    }
  }

  const audio = new AudioManager();

  // Game objects
  class Part {
    constructor(id, x, y, number, shapeIdx = 0, color = null) {
      this.id = id;
      this.x = x;
      this.y = y;
      this.number = number;
      this.shapeIdx = shapeIdx;
      this.color = color || pick(PALETTE.partFill);
      this.radius = 28;
      this.selected = false;
      this.hover = false;
    }

    draw(ctx, angle = 0) {
      // Draw a wacky machine part shape
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(angle);
      // outline blob
      ctx.beginPath();
      const r = this.radius;
      ctx.fillStyle = this.selected ? '#fff1b6' : this.color;
      ctx.strokeStyle = this.selected ? '#ff9b9b' : '#9aa9a6';
      ctx.lineWidth = this.selected ? 4 : 2;
      // Use a rounded rect with funny knobs
      ctx.moveTo(-r, -r * 0.6);
      ctx.quadraticCurveTo(-r * 1.4, 0, -r, r * 0.6);
      ctx.quadraticCurveTo(-r * 0.6, r * 1.4, 0, r);
      ctx.quadraticCurveTo(r * 0.6, r * 1.4, r, r * 0.6);
      ctx.quadraticCurveTo(r * 1.4, 0, r, -r * 0.6);
      ctx.quadraticCurveTo(r * 0.6, -r * 1.2, 0, -r * 1.05);
      ctx.quadraticCurveTo(-r * 0.6, -r * 1.2, -r, -r * 0.6);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // little bolts
      for (let i = -1; i <= 1; i++) {
        ctx.beginPath();
        ctx.fillStyle = 'rgba(0,0,0,0.08)';
        ctx.arc(i * r * 0.6, -r * 0.2, 3, 0, Math.PI * 2);
        ctx.fill();
      }

      // number
      ctx.fillStyle = PALETTE.text;
      ctx.font = 'bold 18px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(this.number), 0, 0);

      // hover glow
      if (this.hover) {
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255,255,255,0.6)';
        ctx.lineWidth = 2;
        ctx.arc(0, 0, r + 6, 0, Math.PI * 2);
        ctx.stroke();
      }

      ctx.restore();
    }

    contains(px, py) {
      const dx = px - this.x;
      const dy = py - this.y;
      return Math.sqrt(dx * dx + dy * dy) <= this.radius + 6;
    }
  }

  class Game {
    constructor() {
      this.parts = [];
      this.lastPartId = 0;
      this.running = true;
      this.assembled = 0;
      this.machineIndex = 0;
      this.target = 0;
      this.requiredParts = []; // numbers that compose target
      this.currentSum = 0;
      this.selectedIds = new Set();
      this.time = 0;
      this.lastTime = performance.now();
      this.speed = PART_SPEED;
      this.selectorIndex = 0; // for keyboard navigation
      this.hoverPart = null;
      this.message = '';
      this.messageTimer = 0;
      this.won = false;
      this.showInstructions = true;
      this.speakerAnimating = 0;
      this.init();
    }

    init() {
      // generate an initial conveyor layout
      this.parts = [];
      this.lastPartId = 0;
      this.assembled = 0;
      this.machineIndex = 0;
      this.won = false;
      this.selectedIds.clear();
      this.selectorIndex = 0;
      this.createNextMachine();
      for (let i = 0; i < PART_COUNT; i++) {
        this.spawnPart(WIDTH + i * 80 + randInt(0, 80));
      }
      this.updateStatus(`Welcome! Target: ${this.target}. Use arrow keys and Enter to pick parts.`);
    }

    updateStatus(text) {
      statusRegion.textContent = text;
    }

    createNextMachine() {
      // create a target by choosing 2 or 3 numbers between 1 and 12 (age-appropriate)
      this.machineIndex++;
      const count = clamp(2 + Math.floor(this.machineIndex / 3), 2, 4); // slowly increase components
      const nums = [];
      let sum = 0;
      for (let i = 0; i < count; i++) {
        const n = randInt(1, Math.min(12, 6 + this.machineIndex)); // numbers slightly larger with level
        nums.push(n);
        sum += n;
      }
      // sometimes create simpler target if too large for young players
      if (sum > 20) {
        while (sum > 20) {
          const idx = randInt(0, nums.length - 1);
          nums[idx] = Math.max(1, nums[idx] - 1);
          sum = nums.reduce((a, b) => a + b, 0);
        }
      }
      this.requiredParts = nums.slice();
      this.target = nums.reduce((a, b) => a + b, 0);
      this.currentSum = 0;
      this.selectedIds.clear();
      // ensure required parts are on the belt soon: spawn them in next few positions
      this.spawnRequiredPartsOnBelt(nums);
      this.updateStatus(`Assemble machine ${this.machineIndex}. Target power: ${this.target}.`);
    }

    spawnRequiredPartsOnBelt(nums) {
      // place required numbers at various future x positions so player can catch them
      const baseX = WIDTH + 60;
      const spacing = 110;
      for (let i = 0; i < nums.length; i++) {
        const x = baseX + i * spacing + randInt(-10, 10);
        const y = BELT_Y + BELT_HEIGHT / 2 + randInt(-15, 15);
        const p = new Part(++this.lastPartId, x, y, nums[i]);
        p.color = pick(PALETTE.partFill);
        this.parts.push(p);
      }
    }

    spawnPart(x) {
      const y = BELT_Y + BELT_HEIGHT / 2 + randInt(-18, 18);
      const number = randInt(1, 12);
      const p = new Part(++this.lastPartId, x, y, number);
      this.parts.push(p);
    }

    handlePick(part) {
      if (this.won) return;
      if (!part) return;
      // toggle selection
      if (this.selectedIds.has(part.id)) {
        this.selectedIds.delete(part.id);
        part.selected = false;
        this.recalcSum();
        audio.playClick();
        this.updateStatus(`Removed ${part.number}. Current sum ${this.currentSum} / ${this.target}.`);
        return;
      }

      // select
      this.selectedIds.add(part.id);
      part.selected = true;
      this.recalcSum();
      audio.playClick();
      if (this.currentSum === this.target) {
        // success
        audio.playCorrect();
        this.assembled++;
        this.message = 'Machine assembled! Great job!';
        this.messageTimer = 1500;
        this.updateStatus(`Correct! Machine assembled. ${this.assembled} / ${TARGET_MACHINES}`);
        // clear selected parts (they get consumed)
        this.parts = this.parts.filter(p => !this.selectedIds.has(p.id));
        this.selectedIds.clear();
        this.currentSum = 0;
        // step to next machine or win
        if (this.assembled >= TARGET_MACHINES) {
          this.win();
          return;
        }
        // create next machine
        setTimeout(() => {
          this.createNextMachine();
        }, 900);
      } else if (this.currentSum > this.target) {
        // wrong
        audio.playWrong();
        this.message = 'Oh no — too much power! Try again.';
        this.messageTimer = 1500;
        this.updateStatus(`Too much. Current sum ${this.currentSum}. Resetting selections.`);
        // deselect all
        this.parts.forEach(p => (p.selected = false));
        this.selectedIds.clear();
        this.currentSum = 0;
      } else {
        this.updateStatus(`Selected ${part.number}. Current sum ${this.currentSum} / ${this.target}.`);
      }
    }

    recalcSum() {
      let sum = 0;
      for (const id of this.selectedIds) {
        const p = this.parts.find(x => x.id === id);
        if (p) sum += p.number;
      }
      this.currentSum = sum;
    }

    win() {
      this.won = true;
      this.message = 'You assembled all machines! You win!';
      this.messageTimer = 4000;
      audio.playCorrect();
      this.updateStatus('Victory! You assembled all machines. Press R to play again.');
    }

    restart() {
      this.init();
      this.message = '';
      this.messageTimer = 0;
      this.won = false;
    }

    update(dt) {
      // move parts
      for (const p of this.parts) {
        p.x -= this.speed * dt;
      }
      // remove parts that have moved far left
      this.parts = this.parts.filter(p => p.x > -80);

      // spawn new parts if needed
      while (this.parts.length < PART_COUNT) {
        const lastX = this.parts.length ? Math.max(...this.parts.map(p => p.x)) : WIDTH;
        this.spawnPart(lastX + randInt(80, 140));
      }

      // update selector index to clamp
      if (this.selectorIndex >= this.parts.length) this.selectorIndex = Math.max(0, this.parts.length - 1);

      // manage message timer
      if (this.messageTimer > 0) {
        this.messageTimer -= dt;
        if (this.messageTimer <= 0) this.message = '';
      }
    }

    draw() {
      // background
      ctx.fillStyle = PALETTE.bg;
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      // soft patterned top
      for (let i = -20; i < WIDTH; i += 80) {
        ctx.fillStyle = 'rgba(255,255,255,0.06)';
        ctx.beginPath();
        ctx.ellipse(i + 40, 60, 60, 20, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      // factory gears (calming, slow rotation)
      this.drawGears();

      // conveyer belt
      this.drawBelt();

      // parts (floating)
      const angleBase = (performance.now() % 6000) / 6000 * Math.PI * 2;
      for (let i = 0; i < this.parts.length; i++) {
        const p = this.parts[i];
        const a = angleBase * (0.2 + (p.id % 5) * 0.05);
        p.draw(ctx, a);
      }

      // selector (robotic claw) - highlight selected index or hovered
      this.drawSelector();

      // HUD: target, assembled count, instructions toggle, speaker icon
      this.drawHUD();

      // message
      if (this.message) {
        ctx.save();
        ctx.fillStyle = 'rgba(20,20,30,0.9)';
        ctx.fillRect(80, 40, 560, 36);
        ctx.fillStyle = '#fff';
        ctx.font = '18px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.message, WIDTH / 2, 58);
        ctx.restore();
      }

      // if won show celebration
      if (this.won) {
        this.drawCelebration();
      }

      // instructions overlay (toggle)
      if (this.showInstructions) {
        this.drawInstructions();
      }
    }

    drawGears() {
      // three calm gears with subtle motion
      const now = performance.now() / 1000;
      const gearPositions = [{x: 120, y: 110, r: 40, s: 0.02}, {x: 220, y: 150, r: 28, s: -0.03}, {x: 80, y: 180, r: 22, s: 0.015}];
      for (const g of gearPositions) {
        this.drawGear(g.x, g.y, g.r, now * g.s);
      }
    }

    drawGear(cx, cy, radius, angle) {
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(angle);
      ctx.fillStyle = PALETTE.gear;
      ctx.strokeStyle = 'rgba(18,32,36,0.12)';
      ctx.lineWidth = 2;
      // gear teeth
      const teeth = 10;
      const inner = radius * 0.6;
      ctx.beginPath();
      for (let i = 0; i < teeth; i++) {
        const a = (i / teeth) * Math.PI * 2;
        const x = Math.cos(a) * (radius + (i % 2 ? 6 : 0));
        const y = Math.sin(a) * (radius + (i % 2 ? 6 : 0));
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      // center
      ctx.beginPath();
      ctx.fillStyle = '#dfeff2';
      ctx.arc(0, 0, inner, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    drawBelt() {
      // belt base
      ctx.save();
      ctx.fillStyle = PALETTE.belt;
      roundRect(ctx, 0, BELT_Y, WIDTH, BELT_HEIGHT, 8);
      ctx.fill();
      // belt shadow
      ctx.fillStyle = PALETTE.beltShadow;
      ctx.fillRect(0, BELT_Y + BELT_HEIGHT - 14, WIDTH, 14);

      // dashed lines to show motion
      ctx.strokeStyle = 'rgba(20,30,30,0.06)';
      ctx.lineWidth = 12;
      ctx.lineCap = 'round';
      const dashOffset = (performance.now() / 40) % 40;
      ctx.setLineDash([30, 30]);
      ctx.lineDashOffset = -dashOffset;
      ctx.beginPath();
      ctx.moveTo(10, BELT_Y + BELT_HEIGHT - 28);
      ctx.lineTo(WIDTH - 10, BELT_Y + BELT_HEIGHT - 28);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }

    drawSelector() {
      // choose either hovered part or selectorIndex
      let p = null;
      if (this.hoverPart) p = this.hoverPart;
      else if (this.parts.length) p = this.parts[clamp(this.selectorIndex, 0, this.parts.length - 1)];
      if (!p) return;
      // robotic claw drawn near the part
      ctx.save();
      const cx = p.x;
      const cy = p.y - 70;
      // arm
      ctx.strokeStyle = '#6b6f72';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx, p.y - 30);
      ctx.stroke();
      // claw
      ctx.translate(cx, p.y - 18);
      ctx.fillStyle = PALETTE.selector;
      ctx.beginPath();
      ctx.arc(-8, 0, 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(8, 0, 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // highlight ring
      ctx.save();
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(255,107,107,0.9)';
      ctx.lineWidth = 3;
      ctx.arc(p.x, p.y, p.radius + 10, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }

    drawHUD() {
      // top bar
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      roundRect(ctx, 10, 8, WIDTH - 20, 78, 10);
      ctx.fill();

      // target display
      ctx.fillStyle = PALETTE.text;
      ctx.font = '24px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText('Machine Power:', 28, 30);
      ctx.font = 'bold 28px monospace';
      ctx.fillText(String(this.target), 28, 62);

      // current sum badge
      ctx.save();
      ctx.fillStyle = '#fff';
      ctx.strokeStyle = '#e6e6e6';
      roundRect(ctx, 220, 20, 150, 56, 8);
      ctx.fill();
      ctx.stroke();
      ctx.font = '18px sans-serif';
      ctx.fillStyle = PALETTE.text;
      ctx.textAlign = 'center';
      ctx.fillText('Selected Power', 295, 36);
      ctx.font = 'bold 22px monospace';
      ctx.fillText(String(this.currentSum), 295, 62);
      ctx.restore();

      // assembled count
      ctx.font = '18px sans-serif';
      ctx.textAlign = 'right';
      ctx.fillStyle = PALETTE.text;
      ctx.fillText(`Assembled: ${this.assembled} / ${TARGET_MACHINES}`, WIDTH - 22, 36);

      // Speaker icon
      const spX = WIDTH - 46;
      const spY = 62;
      ctx.save();
      ctx.beginPath();
      ctx.fillStyle = audio.enabled && !audio.muted ? '#2ea3a3' : '#c9c9c9';
      ctx.rect(spX - 18, spY - 10, 36, 20);
      ctx.fill();
      // speaker symbol
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.moveTo(spX - 24, spY);
      ctx.lineTo(spX - 10, spY - 12);
      ctx.lineTo(spX - 10, spY + 12);
      ctx.closePath();
      ctx.fill();
      // bars
      if (audio.enabled && !audio.muted) {
        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(spX - 2, spY - 6);
        ctx.lineTo(spX + 8, spY - 12 + Math.sin(performance.now() / 300) * 3);
        ctx.moveTo(spX - 2, spY);
        ctx.lineTo(spX + 10, spY);
        ctx.moveTo(spX - 2, spY + 6);
        ctx.lineTo(spX + 8, spY + 10 + Math.cos(performance.now() / 400) * 3);
        ctx.stroke();
      } else {
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.fillRect(spX - 6, spY - 8, 6, 16);
      }
      ctx.restore();

      // small help text
      ctx.font = '12px sans-serif';
      ctx.fillStyle = 'rgba(17,40,43,0.6)';
      ctx.textAlign = 'left';
      ctx.fillText('Keys: ← → select, Enter pick, S enable sound, M mute, R restart, H toggle help', 28, HEIGHT - 14);
      ctx.restore();
    }

    drawInstructions() {
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      roundRect(ctx, 120, 120, 480, 200, 12);
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.stroke();

      ctx.fillStyle = PALETTE.text;
      ctx.font = '20px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Robo-Assembly Instructions', WIDTH / 2, 150);

      ctx.font = '14px sans-serif';
      ctx.textAlign = 'left';
      const lines = [
        'Assemble each machine by selecting parts whose numbers add',
        'exactly to the target power shown at the top left.',
        '',
        'Use the arrow keys to move the robotic claw and Enter or Space to pick.',
        'You can also click or tap parts. If the sum is too large, selections reset.',
        '',
        'Assemble 5 machines to win. Press S to enable sound (required on some browsers).',
        'Press H to hide these instructions.'
      ];
      let y = 180;
      for (const line of lines) {
        ctx.fillText(line, 150, y);
        y += 22;
      }
      ctx.restore();
    }

    drawCelebration() {
      // confetti
      for (let i = 0; i < 25; i++) {
        const t = (performance.now() / 2000 + i * 0.3) % 1;
        const x = 100 + (i * 27) % 600;
        const y = 120 + t * 220;
        ctx.fillStyle = pick(['#FF6B6B', '#FFD166', '#06D6A0', '#4D96FF', '#C77DFF']);
        ctx.fillRect(x, y, 6, 12);
      }
      // big victory text
      ctx.save();
      ctx.fillStyle = '#20323a';
      ctx.font = '48px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Victory! All machines assembled!', WIDTH / 2, 220);
      ctx.font = '18px sans-serif';
      ctx.fillText('Press R to play again.', WIDTH / 2, 250);
      ctx.restore();
    }
  }

  // helper to draw rounded rect
  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  // Instantiate game
  const game = new Game();

  // Mouse and touch handling
  let isPointerDown = false;
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    const my = (e.clientY - rect.top) * (canvas.height / rect.height);
    let found = null;
    for (const p of game.parts) {
      if (p.contains(mx, my)) {
        found = p;
        p.hover = true;
      } else {
        p.hover = false;
      }
    }
    game.hoverPart = found;
    // update selector to hovered if any
    if (found) {
      const idx = game.parts.indexOf(found);
      if (idx >= 0) game.selectorIndex = idx;
    }
  });

  canvas.addEventListener('mouseleave', () => {
    for (const p of game.parts) p.hover = false;
    game.hoverPart = null;
  });

  canvas.addEventListener('click', async (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    const my = (e.clientY - rect.top) * (canvas.height / rect.height);
    // Check if clicked on speaker icon area (top-right)
    const spX = WIDTH - 46;
    const spY = 62;
    if (mx >= spX - 30 && mx <= spX + 30 && my >= spY - 20 && my <= spY + 20) {
      // toggle audio enable/mute
      if (!audio.enabled) {
        const ok = await audio.initFromUserGesture();
        if (!ok) {
          game.updateStatus('Audio not available on this device or blocked by browser.');
          audio.showUnavailable();
        } else {
          game.updateStatus('Audio enabled.');
        }
      } else {
        audio.toggleMute();
        game.updateStatus(audio.muted ? 'Audio muted.' : 'Audio unmuted.');
      }
      return;
    }

    // if instructions overlay visible and click inside it, hide
    if (game.showInstructions) {
      // hide if clicking anywhere inside overlay
      const ix = 120, iy = 120, iw = 480, ih = 200;
      if (mx >= ix && mx <= ix + iw && my >= iy && my <= iy + ih) {
        game.showInstructions = false;
        game.updateStatus('Instructions hidden. Good luck!');
        return;
      }
    }

    // check parts
    for (const p of game.parts) {
      if (p.contains(mx, my)) {
        // ensure audio context is resumed if suspended (user gesture)
        if (audio.ctx && audio.ctx.state === 'suspended') {
          audio.ctx.resume().catch(() => {});
        }
        game.handlePick(p);
        return;
      }
    }
  });

  // Keyboard handling
  canvas.addEventListener('keydown', async (e) => {
    if (e.key === 'ArrowRight') {
      game.selectorIndex = clamp(game.selectorIndex + 1, 0, Math.max(0, game.parts.length - 1));
      audio.playClick();
      e.preventDefault();
      game.updateStatus('Moved right.');
    } else if (e.key === 'ArrowLeft') {
      game.selectorIndex = clamp(game.selectorIndex - 1, 0, Math.max(0, game.parts.length - 1));
      audio.playClick();
      e.preventDefault();
      game.updateStatus('Moved left.');
    } else if (e.key === 'Enter' || e.key === ' ' || e.key === 'Spacebar') {
      const p = game.parts[game.selectorIndex];
      if (p) game.handlePick(p);
      e.preventDefault();
    } else if (e.key.toLowerCase() === 's') {
      // enable audio
      const ok = await audio.initFromUserGesture();
      if (!ok) {
        game.updateStatus('Audio unavailable on this device or blocked by browser.');
      } else {
        game.updateStatus('Audio enabled.');
      }
    } else if (e.key.toLowerCase() === 'm') {
      if (!audio.enabled) {
        game.updateStatus('Audio is not enabled. Press S to enable sound.');
      } else {
        audio.toggleMute();
        game.updateStatus(audio.muted ? 'Audio muted.' : 'Audio unmuted.');
      }
    } else if (e.key.toLowerCase() === 'r') {
      game.restart();
      game.updateStatus('Game restarted.');
    } else if (e.key.toLowerCase() === 'h') {
      game.showInstructions = !game.showInstructions;
      game.updateStatus(game.showInstructions ? 'Showing instructions.' : 'Hiding instructions.');
    }
  });

  // Bring focus to canvas for keyboard control
  canvas.addEventListener('focus', () => {
    // hint
  });
  canvas.focus();

  // Resize handling: keep canvas size fixed; no-op but ensure style
  function onResize() {
    // Intentionally empty; canvas fixed size to meet requirement
  }
  window.addEventListener('resize', onResize);

  // Main loop
  let last = performance.now();
  function loop(now) {
    const dt = Math.min(60, now - last);
    last = now;

    game.update(dt);
    game.draw();

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Initial status text for screen readers
  game.updateStatus('Welcome to Robo-Assembly! Press H for instructions. Use arrow keys and Enter to play.');

  // Error / Resource handling demonstration: audio creation errors already handled in AudioManager.
  // Expose minimal debug for console
  window.RoboAssemblyGame = {
    restart: () => game.restart(),
    enableAudio: async () => {
      const ok = await audio.initFromUserGesture();
      return ok;
    }
  };
})();
---

