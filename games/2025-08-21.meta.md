# Game of the Day - 2025-08-21

## Metadata
- **Generated Date:** 2025-08-21
- **Generated Time:** 2025-08-21T00:26:35.470746
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-21.js
- **File Size:** 30649 bytes
- **Tokens Used:** 10345

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-21.js` - The playable game
- `2025-08-21.meta.json` - Machine-readable metadata
- `2025-08-21.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 21523

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 23408

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Electricity Math Game for ages 7-9
// Renders entirely inside the element with id "game-of-the-day-stage"
// Canvas 720x480, all graphics via canvas, sounds via Web Audio API.
// Accessible: keyboard controls, instructions on canvas, aria attributes on container.
// Author: Educational Game Designer AI
(function () {
  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const CANVAS_ID = 'game-canvas';
  const STAGE_ID = 'game-of-the-day-stage';

  // Find container
  const container = document.getElementById(STAGE_ID);
  if (!container) {
    console.error('Game container element with id "' + STAGE_ID + '" not found.');
    return;
  }
  // Make container focusable and accessible
  container.tabIndex = 0;
  container.setAttribute('role', 'application');
  container.setAttribute('aria-label', 'Spark Circuit: an electricity-themed math game for children ages 7 to 9.');
  container.style.outline = 'none';

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.id = CANVAS_ID;
  canvas.style.display = 'block';
  canvas.style.width = WIDTH + 'px';
  canvas.style.height = HEIGHT + 'px';
  container.innerHTML = ''; // clear children
  container.appendChild(canvas);

  const ctx = canvas.getContext('2d');
  if (!ctx) {
    console.error('Canvas context not available.');
    return;
  }

  // Web Audio setup with error handling
  let audioAvailable = true;
  let audioCtx = null;
  let bgGain = null;
  let bgOsc = null;
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AudioContext();
    // start silent background hum but keep low volume; create nodes now but don't start oscillators until user gesture (resume)
    bgGain = audioCtx.createGain();
    bgGain.gain.value = 0.02; // gentle background
    bgGain.connect(audioCtx.destination);
    bgOsc = audioCtx.createOscillator();
    bgOsc.type = 'sine';
    bgOsc.frequency.value = 110; // low hum
    const bgFilter = audioCtx.createBiquadFilter();
    bgFilter.type = 'lowpass';
    bgFilter.frequency.value = 600;
    bgOsc.connect(bgFilter);
    bgFilter.connect(bgGain);
    // We'll start oscillator upon first user interaction
  } catch (e) {
    console.warn('Web Audio API not available or blocked: ' + e);
    audioAvailable = false;
    audioCtx = null;
    bgGain = null;
    bgOsc = null;
  }

  // Audio helper functions with error handling
  function safeResumeAudio() {
    if (!audioAvailable || !audioCtx) return;
    if (audioCtx.state === 'suspended') {
      audioCtx.resume().catch((e) => {
        console.warn('AudioContext resume failed:', e);
      });
    }
    // start background oscillator if not started
    if (bgOsc && bgOsc.start) {
      try {
        // start only once
        if (!bgOsc._started) {
          bgOsc.start();
          bgOsc._started = true;
        }
      } catch (e) {
        // ignore if already started
      }
    }
  }

  function playBeep({freq = 880, type = 'sine', duration = 0.12, gain = 0.08, slide = 0} = {}) {
    if (!audioAvailable || !audioCtx) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g);
      g.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      if (slide !== 0) {
        o.frequency.linearRampToValueAtTime(freq + slide, now + duration);
      }
      g.gain.setValueAtTime(gain, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + duration);
      o.start(now);
      o.stop(now + duration + 0.02);
    } catch (e) {
      console.warn('playBeep failed', e);
    }
  }

  function playCorrectSound() {
    // friendly ascending beep
    playBeep({freq: 660, type: 'sine', duration: 0.25, gain: 0.09, slide: 220});
    // small sparkle layers
    setTimeout(() => playBeep({freq: 880, type: 'triangle', duration: 0.12, gain: 0.05}), 70);
  }

  function playIncorrectSound() {
    // buzzy low buzz
    if (!audioAvailable || !audioCtx) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'square';
      o.frequency.value = 120;
      g.gain.value = 0.12;
      const f = audioCtx.createBiquadFilter();
      f.type = 'lowpass';
      f.frequency.value = 600;
      o.connect(f);
      f.connect(g);
      g.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      g.gain.setValueAtTime(0.12, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
      o.start(now);
      o.stop(now + 0.36);
    } catch (e) {
      console.warn('playIncorrectSound failed', e);
    }
  }

  function playSelectSound() {
    playBeep({freq: 440, type: 'sine', duration: 0.08, gain: 0.06});
  }

  // Game state
  const totalRounds = 6;
  let currentRound = 0;
  let score = 0;
  let roundTarget = 0;
  let givenAddend = 0;
  let choices = []; // battery choices: {value, x, y, selected, dragging, id}
  let correctChoiceIndex = 0;
  let bulbs = []; // bulbs with required charge and lit state
  let message = 'Click or press Space to start. Use Left/Right and Enter to choose.';
  let gamePhase = 'intro'; // intro, playing, animating, finished
  let selectedIndex = 0;
  let draggingBattery = null;
  let mouse = {x: 0, y: 0};
  let lastTime = 0;
  let animationParticles = [];

  // Visual styles and helper drawing functions
  function drawRoundedRect(ctx, x, y, w, h, r) {
    r = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  // Create next round
  function seedRound() {
    currentRound++;
    // target between 6 and 18
    roundTarget = 6 + Math.floor(Math.random() * 13);
    givenAddend = 1 + Math.floor(Math.random() * Math.min(9, roundTarget - 1));
    const correct = roundTarget - givenAddend;
    // build choices with one correct and two distractors
    const distractors = new Set();
    while (distractors.size < 2) {
      let d = correct + (Math.floor(Math.random() * 7) - 3);
      if (d < 0) d = Math.abs(d);
      if (d === correct) continue;
      distractors.add(d);
    }
    const arr = Array.from(distractors);
    arr.push(correct);
    // shuffle
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    choices = [];
    // place batteries near bottom center
    const baseY = 380;
    const spacing = 140;
    for (let i = 0; i < 3; i++) {
      choices.push({
        id: i,
        value: arr[i],
        x: 160 + i * spacing,
        y: baseY,
        r: 32,
        selected: i === 0,
        dragging: false,
        vx: 0,
        vy: 0
      });
    }
    correctChoiceIndex = choices.findIndex(c => c.value === correct);
    selectedIndex = 0;
    message = `Charge the bulb: ${givenAddend} + ? = ${roundTarget}`;
    gamePhase = 'playing';
  }

  // Initialize bulbs: row of 5 bulbs representing the circuit board; some lit already
  function initBulbs() {
    bulbs = [];
    const count = 5;
    const startX = 160;
    const gap = 100;
    for (let i = 0; i < count; i++) {
      bulbs.push({
        id: i,
        x: startX + i * gap,
        y: 160,
        r: 28,
        required: 0,
        lit: false
      });
    }
    // assign required charges to bulbs: random small numbers 5-15
    for (let b of bulbs) {
      b.required = 5 + Math.floor(Math.random() * 11);
      b.lit = false;
    }
  }

  // Utility: collision between battery and bulb
  function pointToBulb(px, py) {
    for (let b of bulbs) {
      const dx = px - b.x;
      const dy = py - b.y;
      if (Math.sqrt(dx * dx + dy * dy) < b.r + 24) {
        return b;
      }
    }
    return null;
  }

  // Start game
  function startGame() {
    score = 0;
    currentRound = 0;
    initBulbs();
    seedRound();
    // start background audio if available
    safeResumeAudio();
    message = 'Make the right choice to charge bulbs. Drag or use keyboard.';
  }

  // Input handling: keyboard and mouse
  function onKeyDown(e) {
    // resume audio on first key
    safeResumeAudio();
    if (gamePhase === 'intro') {
      if (e.key === ' ' || e.key === 'Enter') {
        startGame();
        e.preventDefault();
        return;
      }
    }
    if (gamePhase === 'playing') {
      if (e.key === 'ArrowLeft') {
        selectedIndex = (selectedIndex + choices.length - 1) % choices.length;
        playSelectSound();
      } else if (e.key === 'ArrowRight') {
        selectedIndex = (selectedIndex + 1) % choices.length;
        playSelectSound();
      } else if (e.key === 'Enter' || e.key === ' ') {
        // "launch" chosen battery to the bulb with smallest remaining required that matches ability
        const c = choices[selectedIndex];
        // for keyboard action, we'll auto-target the closest bulb to center that is not lit
        const targetBulb = bulbs.reduce((best, b) => {
          if (b.lit) return best;
          if (!best) return b;
          const distB = Math.abs(b.x - WIDTH / 2);
          const distBest = Math.abs(best.x - WIDTH / 2);
          return distB < distBest ? b : best;
        }, null);
        if (targetBulb) {
          launchBatteryTo(c, targetBulb);
        }
        e.preventDefault();
      }
    } else if (gamePhase === 'finished') {
      if (e.key === 'Enter' || e.key === ' ') {
        // restart
        startGame();
        e.preventDefault();
      }
    }
  }

  // Mouse events for drag and drop
  canvas.addEventListener('mousedown', function (e) {
    const rect = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
    mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
    // resume audio
    safeResumeAudio();
    if (gamePhase === 'intro') {
      startGame();
      return;
    }
    if (gamePhase !== 'playing') return;
    // check if clicked on a battery
    for (let i = 0; i < choices.length; i++) {
      const c = choices[i];
      const dx = mouse.x - c.x;
      const dy = mouse.y - c.y;
      if (Math.sqrt(dx * dx + dy * dy) <= c.r) {
        c.dragging = true;
        draggingBattery = c;
        selectedIndex = i;
        playSelectSound();
        break;
      }
    }
  });

  canvas.addEventListener('mousemove', function (e) {
    const rect = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
    mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
    if (draggingBattery) {
      draggingBattery.x = mouse.x;
      draggingBattery.y = mouse.y;
    }
  });

  canvas.addEventListener('mouseup', function (e) {
    const rect = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
    mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
    if (draggingBattery) {
      const b = pointToBulb(mouse.x, mouse.y);
      if (b) {
        launchBatteryTo(draggingBattery, b);
      } else {
        // animate battery back to original position
        // find index
        playSelectSound();
        const originX = 160 + draggingBattery.id * 140;
        const originY = 380;
        draggingBattery.vx = (originX - draggingBattery.x) * 0.2;
        draggingBattery.vy = (originY - draggingBattery.y) * 0.2;
      }
      draggingBattery.dragging = false;
      draggingBattery = null;
    }
  });

  // Touch support: simple mapping to mouse events
  canvas.addEventListener('touchstart', function (e) {
    e.preventDefault();
    const t = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    mouse.x = (t.clientX - rect.left) * (canvas.width / rect.width);
    mouse.y = (t.clientY - rect.top) * (canvas.height / rect.height);
    // resume audio
    safeResumeAudio();
    if (gamePhase === 'intro') {
      startGame();
      return;
    }
    if (gamePhase !== 'playing') return;
    for (let i = 0; i < choices.length; i++) {
      const c = choices[i];
      const dx = mouse.x - c.x;
      const dy = mouse.y - c.y;
      if (Math.sqrt(dx * dx + dy * dy) <= c.r) {
        c.dragging = true;
        draggingBattery = c;
        selectedIndex = i;
        playSelectSound();
        break;
      }
    }
  }, {passive: false});

  canvas.addEventListener('touchmove', function (e) {
    e.preventDefault();
    const t = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    mouse.x = (t.clientX - rect.left) * (canvas.width / rect.width);
    mouse.y = (t.clientY - rect.top) * (canvas.height / rect.height);
    if (draggingBattery) {
      draggingBattery.x = mouse.x;
      draggingBattery.y = mouse.y;
    }
  }, {passive: false});

  canvas.addEventListener('touchend', function (e) {
    e.preventDefault();
    if (draggingBattery) {
      const b = pointToBulb(mouse.x, mouse.y);
      if (b) {
        launchBatteryTo(draggingBattery, b);
      } else {
        const originX = 160 + draggingBattery.id * 140;
        const originY = 380;
        draggingBattery.vx = (originX - draggingBattery.x) * 0.2;
        draggingBattery.vy = (originY - draggingBattery.y) * 0.2;
      }
      draggingBattery.dragging = false;
      draggingBattery = null;
    }
  }, {passive: false});

  // Launch battery to a bulb (animation)
  function launchBatteryTo(battery, bulb) {
    if (!battery || !bulb || gamePhase !== 'playing') return;
    // create small animation: battery will move toward bulb with velocity set
    const dx = bulb.x - battery.x;
    const dy = bulb.y - battery.y;
    battery.vx = dx * 0.12;
    battery.vy = dy * 0.12;
    // mark as "in-flight" using dragging flag false but special property
    battery.flyingTo = bulb;
    battery.flyingProgress = 0;
  }

  // Handle when a battery reaches a bulb
  function resolveBatteryToBulb(battery, bulb) {
    // check math: givenAddend + battery.value === roundTarget ?
    const sum = givenAddend + battery.value;
    const correct = (sum === roundTarget);
    if (correct) {
      bulb.lit = true;
      // reward points and progress
      score += 10;
      playCorrectSound();
      // add sparkle particles
      createSparkles(bulb.x, bulb.y, 12);
      message = `Great! ${givenAddend} + ${battery.value} = ${roundTarget}. Bulb lit!`;
    } else {
      playIncorrectSound();
      score = Math.max(0, score - 2);
      message = `Not quite. ${givenAddend} + ${battery.value} = ${sum}. Try again!`;
      // small zap particle
      createZap(bulb.x, bulb.y);
    }
    // remove battery visually and make small puff
    battery.used = true;
    // Check if round is successful (a bulb lit) and advance round
    if (correct) {
      // choose next target bulb that is not lit if any
      const notLit = bulbs.filter(b => !b.lit);
      if (notLit.length === 0) {
        // all bulbs lit: finish game
        gamePhase = 'finished';
        message = `All bulbs lit! You scored ${score} points. Press Enter to play again.`;
      } else {
        // advance to next round if rounds remain
        if (currentRound < totalRounds) {
          seedRound();
        } else {
          // end after totalRounds
          gamePhase = 'finished';
          message = `Great job! You scored ${score} points. Press Enter to play again.`;
        }
      }
    } else {
      // incorrect: let player try the same round again with remaining choices
      // If all options used, reset choices
      const available = choices.filter(c => !c.used);
      if (available.length === 0) {
        // reset batteries for same round by seeding same values in new positions
        // Recreate choices keeping values but not used
        const values = [roundTarget - givenAddend]; // correct
        // create fresh distractors
        while (values.length < 3) {
          let d = Math.max(0, Math.floor(Math.random() * 13));
          if (!values.includes(d)) values.push(d);
        }
        // shuffle
        for (let i = values.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [values[i], values[j]] = [values[j], values[i]];
        }
        for (let i = 0; i < 3; i++) {
          choices[i].value = values[i];
          choices[i].used = false;
          choices[i].x = 160 + i * 140;
          choices[i].y = 380;
        }
        message = 'Choices refreshed. Try again!';
      }
    }
  }

  // Particles for fun feedback
  function createSparkles(x, y, count) {
    for (let i = 0; i < count; i++) {
      const ang = Math.random() * Math.PI * 2;
      const speed = 1 + Math.random() * 3;
      animationParticles.push({
        x: x,
        y: y,
        vx: Math.cos(ang) * speed,
        vy: Math.sin(ang) * speed,
        life: 60 + Math.floor(Math.random() * 30),
        color: `hsl(${160 + Math.random() * 80}, 80%, ${60 + Math.random() * 20}%)`,
        size: 2 + Math.random() * 3
      });
    }
  }

  function createZap(x, y) {
    for (let i = 0; i < 8; i++) {
      const ang = -Math.PI / 2 + (Math.random() - 0.5);
      animationParticles.push({
        x: x + Math.random() * 10 - 5,
        y: y + Math.random() * 10 - 5,
        vx: Math.cos(ang) * (1 + Math.random() * 2),
        vy: Math.sin(ang) * (1 + Math.random() * 2),
        life: 30 + Math.floor(Math.random() * 20),
        color: `rgba(255,140,0,${0.6 + Math.random() * 0.4})`,
        size: 2 + Math.random() * 3
      });
    }
  }

  // Main update loop
  function update(dt) {
    // Update batteries that are flying
    for (let c of choices) {
      if (c.used) {
        // slowly fade out to an offscreen position
        c.x += (700 - c.x) * 0.06;
        c.y += (420 - c.y) * 0.06;
      } else if (c.flyingTo) {
        c.flyingProgress += 0.06;
        c.x += c.vx;
        c.y += c.vy;
        // check arrival
        const dx = c.x - c.flyingTo.x;
        const dy = c.y - c.flyingTo.y;
        if (Math.sqrt(dx * dx + dy * dy) < 18 || c.flyingProgress > 1.2) {
          // resolve
          const bulb = c.flyingTo;
          c.flyingTo = null;
          resolveBatteryToBulb(c, bulb);
        }
      } else if (c.dragging) {
        // position updated by mouse handlers
      } else {
        // apply simple spring back to original positions if velocity present
        if (Math.abs(c.vx) > 0.01 || Math.abs(c.vy) > 0.01) {
          c.x += c.vx;
          c.y += c.vy;
          c.vx *= 0.85;
          c.vy *= 0.85;
        } else {
          // naturally rest on base positions
          const originX = 160 + c.id * 140;
          const originY = 380;
          c.x += (originX - c.x) * 0.08;
          c.y += (originY - c.y) * 0.08;
        }
      }
    }

    // Update particles
    for (let i = animationParticles.length - 1; i >= 0; i--) {
      const p = animationParticles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.12; // gravity
      p.life--;
      if (p.life <= 0) {
        animationParticles.splice(i, 1);
      }
    }
  }

  // Draw scene
  function draw() {
    // background
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    // calming gradient sky
    const sky = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    sky.addColorStop(0, '#E6F7FF');
    sky.addColorStop(1, '#DFF7E6');
    ctx.fillStyle = sky;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // playful clouds
    drawCloud(560, 60, 70);
    drawCloud(420, 40, 50);
    drawCloud(120, 80, 60);

    // ground / circuit board
    ctx.save();
    ctx.translate(0, 0);
    drawRoundedRect(ctx, 40, 110, WIDTH - 80, 300, 18);
    ctx.fillStyle = '#0e2b2b';
    ctx.fill();
    // circuit board stripes
    for (let i = 0; i < 6; i++) {
      ctx.beginPath();
      ctx.moveTo(60 + i * 100, 120);
      ctx.lineTo(60 + i * 100, 380);
      ctx.strokeStyle = 'rgba(255,255,255,0.03)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    ctx.restore();

    // Draw professor Volt (left) - a wacky friendly lightning bolt
    drawProfessorVolt(80, 320);

    // Draw Sparky (little electron) near bottom right
    drawSparky(620, 360);

    // Draw bulbs (circuit nodes)
    for (let b of bulbs) {
      drawBulb(b);
      // show required number if not lit
      ctx.font = '14px "Segoe UI", Arial';
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      if (!b.lit) {
        ctx.fillText(b.required, b.x, b.y + 45);
      } else {
        ctx.fillText('ON', b.x, b.y + 45);
      }
    }

    // Draw header panel
    drawHeaderPanel();

    // Draw batteries (choices)
    for (let i = 0; i < choices.length; i++) {
      const c = choices[i];
      drawBattery(c, i === selectedIndex && !c.used);
    }

    // Draw animation particles
    for (let p of animationParticles) {
      ctx.beginPath();
      ctx.fillStyle = p.color;
      ctx.globalAlpha = Math.max(0.05, p.life / 60);
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // Bottom instructions & status
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.font = '14px "Segoe UI", Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Score: ' + score, 18, HEIGHT - 22);
    ctx.textAlign = 'center';
    ctx.fillText(message, WIDTH / 2, HEIGHT - 22);

    // Audio icon and accessibility hint
    drawAudioIcon(HEIGHT - 60, WIDTH - 60);

    // If intro or finished, overlay instructions box
    if (gamePhase === 'intro' || gamePhase === 'finished') {
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.fillRect(80, 100, WIDTH - 160, 220);
      ctx.fillStyle = '#fff';
      ctx.font = '20px "Segoe UI", Arial';
      ctx.textAlign = 'center';
      if (gamePhase === 'intro') {
        ctx.fillText('Spark Circuit', WIDTH / 2, 150);
        ctx.font = '16px "Segoe UI", Arial';
        ctx.fillText('Welcome! Solve the addition puzzles to charge the lightbulbs.', WIDTH / 2, 190);
        ctx.fillText('Drag a battery to a bulb or use Left/Right and Enter. Click or press Space to start.', WIDTH / 2, 220);
        ctx.fillText('Each correct answer lights a bulb. Try to light them all!', WIDTH / 2, 250);
      } else {
        ctx.fillText('All Done!', WIDTH / 2, 150);
        ctx.font = '16px "Segoe UI", Arial';
        ctx.fillText(`You scored ${score} points.`, WIDTH / 2, 190);
        ctx.fillText('Press Enter or click to play again.', WIDTH / 2, 220);
      }
      ctx.restore();
    }

    // Accessibility: draw keyboard hint box
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    drawRoundedRect(ctx, WIDTH - 210, 18, 190, 66, 10);
    ctx.fill();
    ctx.fillStyle = '#073742';
    ctx.font = '12px "Segoe UI", Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Keyboard: ← → to choose; Enter to send', WIDTH - 196, 40);
    ctx.fillText('Space to start/pick; Drag with mouse or touch', WIDTH - 196, 58);
    ctx.restore();
  }

  // Drawing helpers for characters and UI
  function drawProfessorVolt(x, y) {
    ctx.save();
    ctx.translate(x, y);
    // body: lightning bolt
    ctx.beginPath();
    ctx.moveTo(-20, -10);
    ctx.lineTo(0, -70);
    ctx.lineTo(10, -50);
    ctx.lineTo(-5, -40);
    ctx.lineTo(20, -5);
    ctx.lineTo-5;
    ctx.closePath();
    ctx.fillStyle = '#FFD24D';
    ctx.fill();
    // face
    ctx.beginPath();
    ctx.arc(0, -25, 10, 0, Math.PI * 2);
    ctx.fillStyle = '#FFF6E0';
    ctx.fill();
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.arc(-3, -27, 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(3, -27, 2, 0, Math.PI * 2);
    ctx.fill();
    // smile
    ctx.beginPath();
    ctx.arc(0, -22, 4, 0, Math.PI);
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    ctx.stroke();
    // nameplate
    ctx.fillStyle = '#fff';
    ctx.font = '12px "Segoe UI", Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Professor Volt', 0, 0);
    ctx.restore();
  }

  function drawSparky(x, y) {
    ctx.save();
    ctx.translate(x, y);
    // electron ball
    ctx.beginPath();
    ctx.arc(0, 0, 20, 0, Math.PI * 2);
    const grad = ctx.createRadialGradient(-6, -6, 2, 0, 0, 20);
    grad.addColorStop(0, '#FFFFFF');
    grad.addColorStop(0.2, '#99ffff');
    grad.addColorStop(1, '#33aaff');
    ctx.fillStyle = grad;
    ctx.fill();
    // eyes
    ctx.fillStyle = '#062a2a';
    ctx.beginPath();
    ctx.arc(-6, -4, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(4, -4, 3, 0, Math.PI * 2);
    ctx.fill();
    // wacky antenna
    ctx.beginPath();
    ctx.moveTo(12, -12);
    ctx.lineTo(22, -22);
    ctx.strokeStyle = '#ffd24d';
    ctx.lineWidth = 3;
    ctx.stroke();
    ctx.restore();
  }

  function drawBulb(b) {
    // base metal
    ctx.save();
    // bulb glow if lit
    if (b.lit) {
      const g = ctx.createRadialGradient(b.x, b.y, 2, b.x, b.y, 80);
      g.addColorStop(0, 'rgba(255,250,200,0.9)');
      g.addColorStop(1, 'rgba(255,250,200,0.05)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(b.x, b.y, 80, 0, Math.PI * 2);
      ctx.fill();
    }

    // bulb glass
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
    ctx.fillStyle = b.lit ? '#fff9c6' : '#fff';
    ctx.fill();
    // filament (wavy line)
    ctx.beginPath();
    ctx.moveTo(b.x - 10, b.y);
    ctx.quadraticCurveTo(b.x - 3, b.y - 8, b.x, b.y);
    ctx.quadraticCurveTo(b.x + 3, b.y + 8, b.x + 10, b.y);
    ctx.strokeStyle = b.lit ? '#ff9900' : '#999';
    ctx.lineWidth = 2;
    ctx.stroke();
    // base
    ctx.fillStyle = '#cfcfcf';
    drawRoundedRect(ctx, b.x - 12, b.y + b.r - 6, 24, 12, 3);
    ctx.fill();
    ctx.restore();

    // show a faint label of required value
    ctx.font = 'bold 12px "Segoe UI", Arial';
    ctx.textAlign = 'center';
    ctx.fillStyle = b.lit ? '#444' : '#fff';
    // number drawn separately above in main loop
  }

  function drawBattery(b, highlight) {
    ctx.save();
    // shadow
    ctx.beginPath();
    ctx.ellipse(b.x + 8, b.y + 20, 36, 10, 0, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.fill();

    // main body
    ctx.fillStyle = '#FFD24D';
    drawRoundedRect(ctx, b.x - 30, b.y - 18, 60, 36, 8);
    ctx.fill();
    // top terminal
    drawRoundedRect(ctx, b.x + 12, b.y - 10, 10, 20, 3);
    ctx.fillStyle = '#E6E6E6';
    ctx.fill();

    // number label
    ctx.fillStyle = '#073742';
    ctx.font = 'bold 16px "Segoe UI", Arial';
    ctx.textAlign = 'center';
    ctx.fillText('+' + b.value, b.x, b.y + 6);

    // highlight for selected
    if (!b.used && highlight) {
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(255,255,255,0.7)';
      ctx.lineWidth = 3;
      ctx.arc(b.x, b.y, b.r + 6, 0, Math.PI * 2);
      ctx.stroke();
    }

    // dim if used
    if (b.used) {
      ctx.globalAlpha = 0.4;
    }

    ctx.restore();
  }

  function drawCloud(cx, cy, size) {
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.beginPath();
    ctx.arc(cx, cy, size * 0.6, 0, Math.PI * 2);
    ctx.arc(cx - size * 0.5, cy + 10, size * 0.42, 0, Math.PI * 2);
    ctx.arc(cx + size * 0.45, cy + 5, size * 0.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawHeaderPanel() {
    ctx.save();
    // top bar
    drawRoundedRect(ctx, 40, 18, WIDTH - 80, 62, 12);
    const grd = ctx.createLinearGradient(40, 18, WIDTH - 40, 80);
    grd.addColorStop(0, '#073742');
    grd.addColorStop(1, '#0b8793');
    ctx.fillStyle = grd;
    ctx.fill();
    // title and problem text
    ctx.fillStyle = '#fff';
    ctx.font = '20px "Segoe UI", Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Spark Circuit', 64, 44);
    ctx.font = '16px "Segoe UI", Arial';
    ctx.fillText(`Round ${currentRound} / ${totalRounds}`, WIDTH - 170, 44);
    // problem text
    ctx.font = '18px "Segoe UI", Arial';
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    if (gamePhase === 'playing') {
      ctx.fillText(`${givenAddend} + ? = ${roundTarget}`, WIDTH / 2, 69);
    } else {
      ctx.fillText('Click or press Space to begin', WIDTH / 2, 69);
    }
    ctx.restore();
  }

  function drawAudioIcon(rowY, colX) {
    // draw simple speaker icon with visual cue if audio is available
    const x = colX;
    const y = rowY;
    ctx.save();
    ctx.translate(x, y);
    // box
    drawRoundedRect(ctx, -38, -28, 76, 56, 8);
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.fill();
    // speaker
    ctx.fillStyle = '#073742';
    ctx.beginPath();
    ctx.moveTo(-18, -8);
    ctx.lineTo(-2, -18);
    ctx.lineTo(-2, 18);
    ctx.lineTo(-18, 8);
    ctx.closePath();
    ctx.fill();
    // waves if audioAvailable
    if (audioAvailable) {
      ctx.strokeStyle = '#33aaff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(10, 0, 10, -Math.PI / 6, Math.PI / 6);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(10, 0, 16, -Math.PI / 6, Math.PI / 6);
      ctx.stroke();
      ctx.font = '10px "Segoe UI", Arial';
      ctx.fillStyle = '#073742';
      ctx.textAlign = 'left';
      ctx.fillText('Audio On', 18, 4);
    } else {
      // muted icon
      ctx.strokeStyle = 'rgba(200,40,40,0.9)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(4, -8);
      ctx.lineTo(18, 8);
      ctx.stroke();
      ctx.font = '10px "Segoe UI", Arial';
      ctx.fillStyle = '#073742';
      ctx.textAlign = 'left';
      ctx.fillText('Audio Unavailable', 18, 4);
    }
    ctx.restore();
  }

  // Main loop
  function loop(ts) {
    if (!lastTime) lastTime = ts;
    const dt = (ts - lastTime) / 16.666; // scale relative to 60fps
    lastTime = ts;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // Start animation
  requestAnimationFrame(loop);

  // Wire keyboard to container for accessibility
  container.addEventListener('keydown', onKeyDown);
  // Also listen globally for keyboard if canvas focused
  window.addEventListener('keydown', function (e) {
    // only handle if container is focused or canvas hovered
    const active = document.activeElement === container || document.activeElement === canvas;
    if (active) {
      onKeyDown(e);
    }
  });

  // Ensure initial state (intro)
  gamePhase = 'intro';
  message = 'Welcome! Click or press Space to start.';

  // Expose minimal diagnostics on container for assistive tech (aria-live)
  container.setAttribute('aria-live', 'polite');

  // Fallback instructions in case audio fails
  if (!audioAvailable) {
    console.info('Audio is not available. The game will run silently.');
  }
})();
---

