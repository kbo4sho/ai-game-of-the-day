# Game of the Day - 2025-11-01

## Metadata
- **Generated Date:** 2025-11-01
- **Generated Time:** 2025-11-01T00:29:56.054439
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-11-01.js
- **File Size:** 27566 bytes
- **Tokens Used:** 9424

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-11-01.js` - The playable game
- `2025-11-01.meta.json` - Machine-readable metadata
- `2025-11-01.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 21273

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 23863

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function() {
  "use strict";

  // Game constants
  const WIDTH = 720;
  const HEIGHT = 480;
  const GOAL_CORRECT = 10; // win condition
  const MAX_WRONG = 3; // lose condition
  const DRONE_RADIUS = 28;
  const ANSWER_RADIUS = 26;
  const UI_PADDING = 10;
  const BODY_FONT = "16px sans-serif";
  const LARGE_FONT = "22px sans-serif";
  const TITLE_FONT = "28px sans-serif";
  const TICK = 1000 / 60; // approx 60fps

  // Find container
  const container = document.getElementById("game-of-the-day-stage");
  if (!container) {
    console.error("No element with id 'game-of-the-day-stage' found.");
    return;
  }

  // Clear container and set up canvas
  container.innerHTML = "";
  container.style.position = "relative";
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute("role", "application");
  canvas.setAttribute("aria-label", "Drone Math Collector game");
  canvas.style.background = "#eaf6ff";
  container.appendChild(canvas);
  const ctx = canvas.getContext("2d");

  // Audio setup with proper error handling
  let audioEnabled = true;
  let audioContext = null;
  let backgroundOsc = null;
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (AudioContext) {
      audioContext = new AudioContext();
      // Create gentle background hum (low-volume)
      backgroundOsc = audioContext.createOscillator();
      const bgGain = audioContext.createGain();
      backgroundOsc.type = "sine";
      backgroundOsc.frequency.value = 110; // low hum
      bgGain.gain.value = 0.0008; // very quiet
      backgroundOsc.connect(bgGain);
      bgGain.connect(audioContext.destination);
      backgroundOsc.start(0);
    } else {
      audioEnabled = false;
      console.warn("Web Audio API not supported in this browser.");
    }
  } catch (e) {
    audioEnabled = false;
    console.warn("Unable to initialize AudioContext:", e);
  }

  // Sound play functions with safety checks
  function playCorrectSound() {
    if (!audioEnabled || !audioContext) return;
    try {
      const t = audioContext.currentTime;
      const gain = audioContext.createGain();
      gain.gain.setValueAtTime(0.0001, t);
      gain.gain.exponentialRampToValueAtTime(0.08, t + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.6);
      gain.connect(audioContext.destination);
      const o1 = audioContext.createOscillator();
      const o2 = audioContext.createOscillator();
      o1.type = "sine";
      o2.type = "triangle";
      o1.frequency.value = 880;
      o2.frequency.value = 1320;
      o1.connect(gain);
      o2.connect(gain);
      o1.start(t);
      o2.start(t);
      o1.stop(t + 0.6);
      o2.stop(t + 0.6);
    } catch (e) {
      console.warn("Error playing correct sound:", e);
    }
  }

  function playWrongSound() {
    if (!audioEnabled || !audioContext) return;
    try {
      const t = audioContext.currentTime;
      const g = audioContext.createGain();
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(0.09, t + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.4);
      g.connect(audioContext.destination);
      const o = audioContext.createOscillator();
      o.type = "square";
      o.frequency.setValueAtTime(220, t);
      o.frequency.exponentialRampToValueAtTime(80, t + 0.4);
      o.connect(g);
      o.start(t);
      o.stop(t + 0.4);
    } catch (e) {
      console.warn("Error playing wrong sound:", e);
    }
  }

  // Local state
  let keys = {};
  let mouse = { x: 0, y: 0 };
  let gameState = "menu"; // menu, playing, win, gameover
  let score = 0;
  let wrong = 0;
  let currentQuestion = null;
  let answers = [];
  let tickCount = 0;
  let drone = { x: WIDTH / 2, y: HEIGHT / 2, vx: 0, vy: 0, angle: 0 };
  let lastTime = performance.now();
  let soundPulse = 0;

  // Ensure accessible instructions visible as text (drawn on canvas),
  // but also set an offscreen aria-live for screen readers:
  const ariaLive = document.createElement("div");
  ariaLive.setAttribute("aria-live", "polite");
  ariaLive.style.position = "absolute";
  ariaLive.style.left = "-9999px";
  container.appendChild(ariaLive);

  function announce(text) {
    ariaLive.textContent = text;
  }

  // Helper: clamp
  function clamp(v, a, b) {
    return Math.max(a, Math.min(b, v));
  }

  // Create a math question for ages 7-9 (simple addition/subtraction, maybe small multiplication)
  function generateQuestion(difficulty = 1) {
    // difficulty increases as score increases
    const typeRoll = Math.random();
    let a, b, correct, text;
    if (typeRoll < 0.6) {
      // addition/subtraction within small ranges
      a = Math.floor(Math.random() * (5 + difficulty * 2)) + 1;
      b = Math.floor(Math.random() * (5 + difficulty * 2)) + 1;
      if (Math.random() < 0.5) {
        correct = a + b;
        text = `${a} + ${b} = ?`;
      } else {
        // ensure non-negative
        if (a < b) [a, b] = [b, a];
        correct = a - b;
        text = `${a} - ${b} = ?`;
      }
    } else {
      // simple multiplication small
      a = Math.floor(Math.random() * (2 + difficulty)) + 1;
      b = Math.floor(Math.random() * (2 + difficulty)) + 1;
      correct = a * b;
      text = `${a} × ${b} = ?`;
    }
    return { text, correct };
  }

  // Create answer items: circles that the player collects by touching
  function spawnAnswers(question) {
    answers = [];
    const correct = question.correct;
    // generate two distractors reasonably close but not equal
    const distractors = new Set();
    while (distractors.size < 2) {
      const offset = (Math.random() < 0.5 ? -1 : 1) * (Math.floor(Math.random() * 4) + 1);
      let val = correct + offset;
      if (val < 0) val = Math.abs(val) + 1;
      if (val !== correct) distractors.add(val);
    }
    const options = [correct, ...Array.from(distractors)];
    // scramble
    options.sort(() => Math.random() - 0.5);

    // Spawn in three different non-overlapping zones (left, center, right)
    const zones = [
      { x: WIDTH * 0.2, y: HEIGHT * 0.35 },
      { x: WIDTH * 0.5, y: HEIGHT * 0.3 },
      { x: WIDTH * 0.8, y: HEIGHT * 0.4 }
    ];
    for (let i = 0; i < options.length; i++) {
      const startX = zones[i].x + (Math.random() * 80 - 40);
      const startY = zones[i].y + (Math.random() * 80 - 40);
      answers.push({
        id: i,
        value: options[i],
        x: clamp(startX, ANSWER_RADIUS + 40, WIDTH - ANSWER_RADIUS - 40),
        y: clamp(startY, 100 + ANSWER_RADIUS, HEIGHT - 120 - ANSWER_RADIUS),
        vx: (Math.random() - 0.5) * (0.6 + score * 0.06),
        vy: (Math.random() - 0.5) * (0.4 + score * 0.04),
        wobble: Math.random() * Math.PI * 2
      });
    }
  }

  // Start a fresh game
  function startGame() {
    score = 0;
    wrong = 0;
    tickCount = 0;
    drone.x = WIDTH / 2;
    drone.y = HEIGHT / 2;
    drone.vx = 0;
    drone.vy = 0;
    gameState = "playing";
    currentQuestion = generateQuestion(1);
    spawnAnswers(currentQuestion);
    announce("Game started. Use arrow keys or WASD to fly the drone and collect the correct answer.");
    // Ensure audio is resumed on user gesture if necessary
    if (audioContext && audioContext.state === "suspended") {
      audioContext.resume().catch((e) => {
        console.warn("Audio resume failed:", e);
      });
    }
  }

  // Reset to menu
  function goToMenu() {
    gameState = "menu";
    announce("Menu. Press Enter or click Start to begin.");
  }

  goToMenu();

  // Input handlers
  window.addEventListener("keydown", (e) => {
    // space or enter to start from menu
    if (e.key === "Enter" || e.key === " " || e.key === "Spacebar") e.preventDefault();
    keys[e.key.toLowerCase()] = true;

    if (gameState === "menu" && (e.key === "Enter" || e.key.toLowerCase() === " ")) {
      startGame();
    } else if ((gameState === "win" || gameState === "gameover") && (e.key === "r" || e.key === "R" || e.key === "Enter")) {
      startGame();
    }

    // toggle sound with m
    if (e.key.toLowerCase() === "m") {
      audioEnabled = !audioEnabled;
      if (!audioEnabled && audioContext) {
        // mute by setting background gain to zero if available
        try {
          if (backgroundOsc) {
            // can't directly set oscillator gain since we used created gain in closure and didn't store - but we can suspend context
            audioContext.suspend().catch(() => {});
          }
        } catch (err) {
          console.warn(err);
        }
      } else if (audioEnabled && audioContext && audioContext.state === "suspended") {
        audioContext.resume().catch(() => {});
      }
      announce(`Sound ${audioEnabled ? "on" : "off"}`);
    }
  });

  window.addEventListener("keyup", (e) => {
    keys[e.key.toLowerCase()] = false;
  });

  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
    mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
  });

  canvas.addEventListener("mousedown", (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    const my = (e.clientY - rect.top) * (canvas.height / rect.height);

    // restart or menu click detection: check if click is inside button rectangles when showing end screens
    if (gameState === "menu") {
      // check start button area
      const btn = getMenuStartButtonRect();
      if (pointInRect(mx, my, btn)) {
        startGame();
      }
    } else if (gameState === "win" || gameState === "gameover") {
      const btn = getEndButtonRect();
      if (pointInRect(mx, my, btn)) {
        startGame();
      }
    } else if (gameState === "playing") {
      // clicking the sound icon toggles sound
      const sd = getSoundIconRect();
      if (pointInRect(mx, my, sd)) {
        audioEnabled = !audioEnabled;
        if (!audioEnabled && audioContext) audioContext.suspend().catch(() => {});
        else if (audioEnabled && audioContext) audioContext.resume().catch(() => {});
        announce(`Sound ${audioEnabled ? "on" : "off"}`);
      } else {
        // else clicking will "nudge" drone toward click for accessibility
        const dx = mx - drone.x;
        const dy = my - drone.y;
        const dist = Math.hypot(dx, dy) || 1;
        drone.vx += (dx / dist) * 1.8;
        drone.vy += (dy / dist) * 1.8;
      }
    }
  });

  function pointInRect(x, y, r) {
    return x >= r.x && x <= r.x + r.w && y >= r.y && y <= r.y + r.h;
  }

  // UI layout helper rects
  function getScoreRect(text) {
    ctx.font = BODY_FONT;
    const metrics = ctx.measureText(text);
    const w = metrics.width + UI_PADDING * 2;
    const h = 36;
    return { x: UI_PADDING, y: UI_PADDING, w, h };
  }

  function getLivesRect(text) {
    ctx.font = BODY_FONT;
    const metrics = ctx.measureText(text);
    const w = metrics.width + UI_PADDING * 2 + 24;
    const h = 36;
    return { x: WIDTH - w - UI_PADDING, y: UI_PADDING, w, h };
  }

  function getQuestionRect(text) {
    ctx.font = LARGE_FONT;
    const metrics = ctx.measureText(text);
    const w = Math.min(metrics.width + UI_PADDING * 4, WIDTH - 200);
    const h = 48;
    return { x: (WIDTH - w) / 2, y: 10 + 36 + 8, w, h };
  }

  function getInstructionsRect(lines) {
    ctx.font = BODY_FONT;
    // multiple lines stacked bottom-center
    const maxWidth = Math.max(...lines.map(l => ctx.measureText(l).width));
    const w = maxWidth + UI_PADDING * 4;
    const h = lines.length * 20 + UI_PADDING * 2;
    return { x: (WIDTH - w) / 2, y: HEIGHT - h - 10, w, h };
  }

  function getMenuStartButtonRect() {
    const w = 220;
    const h = 56;
    return { x: (WIDTH - w) / 2, y: HEIGHT / 2 - 20, w, h };
  }

  function getEndButtonRect() {
    const w = 240;
    const h = 56;
    return { x: (WIDTH - w) / 2, y: HEIGHT / 2 + 40, w, h };
  }

  function getSoundIconRect() {
    const w = 40;
    const h = 36;
    return { x: WIDTH - w - UI_PADDING - 80, y: UI_PADDING, w, h };
  }

  // Drawing helpers
  function drawRoundedRect(ctx, x, y, w, h, r = 8) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  // Drawing the wacky drone
  function drawDrone(ctx, d) {
    // shadow
    ctx.save();
    ctx.translate(d.x, d.y);
    ctx.rotate(d.angle);
    ctx.shadowColor = "rgba(0,0,0,0.12)";
    ctx.shadowBlur = 10;
    // body
    ctx.fillStyle = "#fefefe";
    drawRoundedRect(ctx, -24, -18, 48, 36, 12);
    ctx.fillStyle = "#c6e7ff";
    ctx.fillRect(-24, -18, 48, 36);
    // cockpit
    ctx.beginPath();
    ctx.ellipse(10, -2, 12, 10, Math.PI / 8, 0, Math.PI * 2);
    ctx.fillStyle = "#d4f3ff";
    ctx.fill();
    // propellers
    ctx.strokeStyle = "#6a6a6a";
    ctx.lineWidth = 2;
    for (let i = -1; i <= 1; i += 2) {
      const px = i * 26;
      const py = -14;
      // bar
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.lineTo(px, py - 18);
      ctx.stroke();
      // rotor (wacky)
      ctx.beginPath();
      ctx.fillStyle = "rgba(255,255,255,0.7)";
      ctx.arc(px, py - 24, 12 + Math.sin(tickCount / 8 + px) * 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
    // smile
    ctx.beginPath();
    ctx.strokeStyle = "#3b3b3b";
    ctx.lineWidth = 1.6;
    ctx.arc(-6, 6, 8, 0, Math.PI);
    ctx.stroke();

    ctx.restore();
    ctx.shadowBlur = 0;
  }

  // Drawing answer bubble
  function drawAnswer(ctx, a, highlight = false) {
    ctx.save();
    // wobble animation
    const wob = Math.sin(a.wobble + tickCount / 30) * 2;
    a.wobble += 0.01;
    ctx.translate(a.x, a.y + wob);
    // outer ring
    ctx.beginPath();
    ctx.fillStyle = highlight ? "#fff6d4" : "#ffffff";
    ctx.strokeStyle = highlight ? "#ffd166" : "#cfe9ff";
    ctx.lineWidth = 3;
    ctx.arc(0, 0, ANSWER_RADIUS + 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    // inner circle
    ctx.beginPath();
    ctx.fillStyle = "#f2fbff";
    ctx.arc(0, 0, ANSWER_RADIUS, 0, Math.PI * 2);
    ctx.fill();
    // number text
    ctx.font = "20px sans-serif";
    ctx.fillStyle = "#1c3e5a";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(String(a.value), 0, 0);
    ctx.restore();
  }

  // Collision detection
  function checkCollisions() {
    for (let i = answers.length - 1; i >= 0; i--) {
      const a = answers[i];
      const dx = a.x - drone.x;
      const dy = a.y - drone.y;
      const dist = Math.hypot(dx, dy);
      if (dist < DRONE_RADIUS + ANSWER_RADIUS - 6) {
        // collision happened
        if (a.value === currentQuestion.correct) {
          score++;
          playCorrectSound();
          announce(`Correct! Your score is ${score}.`);
          // feedback pulse
          soundPulse = 10;
          // next question or win
          if (score >= GOAL_CORRECT) {
            gameState = "win";
            announce("You win! Press R or click Restart to play again.");
            return;
          } else {
            // generate next question with mild difficulty
            currentQuestion = generateQuestion(1 + Math.floor(score / 3));
            spawnAnswers(currentQuestion);
            return;
          }
        } else {
          wrong++;
          playWrongSound();
          announce(`Oops! That was ${a.value}. You have ${wrong} wrong answers.`);
          // visual feedback: shake drone and flash
          drone.vx += (Math.random() - 0.5) * 3;
          drone.vy += (Math.random() - 0.5) * 3;
          // remove collided wrong answer but keep others
          answers.splice(i, 1);
          if (wrong >= MAX_WRONG) {
            gameState = "gameover";
            announce("Game over. Press R or click Restart to try again.");
            return;
          } else {
            // optionally spawn a new distractor to maintain three options
            // spawn one random distractor around edges
            const val = currentQuestion.correct + (Math.random() < 0.5 ? -1 : 1) * (Math.floor(Math.random() * 4) + 1);
            answers.push({
              id: Date.now(),
              value: val === currentQuestion.correct ? val + 2 : val,
              x: clamp(Math.random() * (WIDTH - 80) + 40, ANSWER_RADIUS + 40, WIDTH - ANSWER_RADIUS - 40),
              y: clamp(Math.random() * (HEIGHT - 200) + 120, 100 + ANSWER_RADIUS, HEIGHT - 120 - ANSWER_RADIUS),
              vx: (Math.random() - 0.5) * (0.6 + score * 0.06),
              vy: (Math.random() - 0.5) * (0.4 + score * 0.04),
              wobble: Math.random() * Math.PI * 2
            });
          }
        }
      }
    }
  }

  // Update logic
  function update(dt) {
    tickCount++;
    if (gameState !== "playing") {
      // slow subtle animations only
      for (const a of answers) {
        a.wobble += 0.01;
      }
      return;
    }

    // Player movement: keyboard
    const speed = 2.1 + score * 0.05;
    const accel = 0.25;
    if (keys["arrowup"] || keys["w"]) drone.vy -= accel;
    if (keys["arrowdown"] || keys["s"]) drone.vy += accel;
    if (keys["arrowleft"] || keys["a"]) drone.vx -= accel;
    if (keys["arrowright"] || keys["d"]) drone.vx += accel;

    // Gentle drag
    drone.vx *= 0.92;
    drone.vy *= 0.92;

    // Limit speed
    drone.vx = clamp(drone.vx, -speed * 1.6, speed * 1.6);
    drone.vy = clamp(drone.vy, -speed * 1.6, speed * 1.6);

    drone.x += drone.vx;
    drone.y += drone.vy;

    // Boundaries
    drone.x = clamp(drone.x, DRONE_RADIUS + 6, WIDTH - DRONE_RADIUS - 6);
    drone.y = clamp(drone.y, DRONE_RADIUS + 80, HEIGHT - DRONE_RADIUS - 80);

    // tilt based on vx
    drone.angle = Math.atan2(drone.vy, drone.vx) * 0.05;

    // Update answers movement
    for (const a of answers) {
      a.x += a.vx;
      a.y += a.vy;
      // gentle bounce off walls
      if (a.x < ANSWER_RADIUS + 12 || a.x > WIDTH - ANSWER_RADIUS - 12) a.vx *= -1;
      if (a.y < 120 + ANSWER_RADIUS || a.y > HEIGHT - 120 - ANSWER_RADIUS) a.vy *= -1;
      // keep inside
      a.x = clamp(a.x, ANSWER_RADIUS + 12, WIDTH - ANSWER_RADIUS - 12);
      a.y = clamp(a.y, 120 + ANSWER_RADIUS, HEIGHT - 120 - ANSWER_RADIUS);
      // slight drift to keep things lively
      a.vx += (Math.random() - 0.5) * 0.02;
      a.vy += (Math.random() - 0.5) * 0.02;
    }

    // Collision check
    checkCollisions();

    // background pulse for audio visual indicator
    soundPulse = Math.max(0, soundPulse - 0.25);
  }

  // UI drawing ensuring non overlapping using measureText and rectangles
  function render() {
    // clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Calm sky gradient
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, "#e8faff");
    g.addColorStop(1, "#f7fbff");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Soft fluffy clouds (wacky+calming)
    drawCloud(ctx, 100, 80, 1.0, 0.9);
    drawCloud(ctx, 540, 60, 0.9, 0.85);
    drawCloud(ctx, 360, 120, 1.1, 0.95);

    // UI: score top-left
    ctx.font = BODY_FONT;
    const scoreText = `Correct: ${score}/${GOAL_CORRECT}`;
    const scoreRect = getScoreRect(scoreText);
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    drawRoundedRect(ctx, scoreRect.x, scoreRect.y, scoreRect.w, scoreRect.h, 8);
    ctx.fillStyle = "#1c3e5a";
    ctx.fillText(scoreText, scoreRect.x + UI_PADDING, scoreRect.y + 24);

    // Sound visual icon and push
    const soundRect = getSoundIconRect();
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    drawRoundedRect(ctx, scoreRect.x + scoreRect.w + 8, soundRect.y, soundRect.w, soundRect.h, 8);
    ctx.fillStyle = "#1c3e5a";
    ctx.font = "14px sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    // speaker icon
    ctx.beginPath();
    ctx.moveTo(scoreRect.x + scoreRect.w + 20 - 8, soundRect.y + soundRect.h / 2 - 8);
    ctx.lineTo(scoreRect.x + scoreRect.w + 20 - 2, soundRect.y + soundRect.h / 2 - 14);
    ctx.lineTo(scoreRect.x + scoreRect.w + 20 + 10, soundRect.y + soundRect.h / 2 - 8);
    ctx.closePath();
    ctx.fillStyle = "#256085";
    ctx.fill();
    // bars if on
    if (audioEnabled) {
      ctx.strokeStyle = "#256085";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(scoreRect.x + scoreRect.w + 24, soundRect.y + soundRect.h / 2 - 2);
      ctx.quadraticCurveTo(scoreRect.x + scoreRect.w + 32, soundRect.y + soundRect.h / 2 - 8, scoreRect.x + scoreRect.w + 36, soundRect.y + soundRect.h / 2 - 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(scoreRect.x + scoreRect.w + 24, soundRect.y + soundRect.h / 2 + 4);
      ctx.quadraticCurveTo(scoreRect.x + scoreRect.w + 34, soundRect.y + soundRect.h / 2 + 12, scoreRect.x + scoreRect.w + 40, soundRect.y + soundRect.h / 2 + 4);
      ctx.stroke();
    }

    // Lives top-right
    ctx.font = BODY_FONT;
    const livesText = `Wrong: ${wrong}/${MAX_WRONG}`;
    const livesRect = getLivesRect(livesText);
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    drawRoundedRect(ctx, livesRect.x, livesRect.y, livesRect.w, livesRect.h, 8);
    ctx.fillStyle = "#873b3b";
    ctx.fillText(livesText, livesRect.x + UI_PADDING, livesRect.y + 24);

    // Question top-center (ensuring not overlapping)
    if (currentQuestion) {
      ctx.font = LARGE_FONT;
      const qText = currentQuestion.text;
      const qRect = getQuestionRect(qText);
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      drawRoundedRect(ctx, qRect.x, qRect.y, qRect.w, qRect.h, 10);
      ctx.fillStyle = "#06314a";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(qText, qRect.x + qRect.w / 2, qRect.y + qRect.h / 2);
    }

    // Instructions bottom-center
    const lines = [
      "Fly the drone to collect the correct answer!",
      "Goal: collect 10 correct answers. You lose after 3 wrong picks.",
      "Controls: Arrow keys or WASD to move. Click or press M to toggle sound. Press R to restart."
    ];
    ctx.font = BODY_FONT;
    const instRect = getInstructionsRect(lines);
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    drawRoundedRect(ctx, instRect.x, instRect.y, instRect.w, instRect.h, 8);
    ctx.fillStyle = "#0b3954";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    let yy = instRect.y + UI_PADDING;
    for (const line of lines) {
      ctx.fillText(line, instRect.x + UI_PADDING, yy);
      yy += 20;
    }

    // Draw answers
    for (const a of answers) {
      // highlight if near drone
      const d = Math.hypot(a.x - drone.x, a.y - drone.y);
      drawAnswer(ctx, a, d < 120);
    }

    // Draw drone last (so it's on top)
    drawDrone(ctx, drone);

    // If paused/menu/win/gameover overlay
    if (gameState === "menu") {
      drawMenu();
    } else if (gameState === "win") {
      drawEndScreen(true);
    } else if (gameState === "gameover") {
      drawEndScreen(false);
    }

    // Sound activity visual cue (tiny pulsing circle near sound icon)
    ctx.beginPath();
    const pulseR = 4 + Math.sin(tickCount / 6) * 2 * (audioEnabled ? 1 : 0.2);
    ctx.fillStyle = audioEnabled ? "rgba(37,96,133,0.95)" : "rgba(150,150,150,0.6)";
    ctx.arc(scoreRect.x + scoreRect.w + 28, soundRect.y + soundRect.h + 6 + -UI_PADDING, pulseR, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawMenu() {
    // translucent overlay
    ctx.fillStyle = "rgba(7,20,40,0.28)";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    // title box
    const title = "Drone Math Collector";
    ctx.font = TITLE_FONT;
    const tMetrics = ctx.measureText(title);
    const tW = Math.min(tMetrics.width, WIDTH - 80);
    const tx = (WIDTH - tW) / 2;
    const ty = HEIGHT * 0.22;
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    drawRoundedRect(ctx, tx - 12, ty - 22, tW + 24, 60, 10);
    ctx.fillStyle = "#06314a";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(title, WIDTH / 2, ty + 6);
    // start button
    const btn = getMenuStartButtonRect();
    ctx.fillStyle = "#fff8e1";
    drawRoundedRect(ctx, btn.x, btn.y, btn.w, btn.h, 12);
    ctx.fillStyle = "#2a6f97";
    ctx.font = "20px sans-serif";
    ctx.fillText("Start the Drone Adventure", btn.x + btn.w / 2, btn.y + btn.h / 2);
    // instructions below
    ctx.font = BODY_FONT;
    ctx.fillStyle = "#ffffff";
    ctx.textAlign = "center";
    ctx.fillText("Collect correct answers by flying the drone. Avoid wrong picks!", WIDTH / 2, btn.y + btn.h + 36);
    ctx.fillText("Click the Start button or press Enter to begin.", WIDTH / 2, btn.y + btn.h + 56);
  }

  function drawEndScreen(won) {
    // overlay
    ctx.fillStyle = "rgba(5, 15, 30, 0.45)";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    ctx.font = TITLE_FONT;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#fff";
    const title = won ? "Victory! You mastered drone math!" : "Game Over - Keep practicing!";
    ctx.fillText(title, WIDTH / 2, HEIGHT * 0.28);
    // details
    ctx.font = LARGE_FONT;
    ctx.fillStyle = won ? "#ffd166" : "#ff8a8a";
    ctx.fillText(won ? `Score: ${score}/${GOAL_CORRECT}` : `Correct: ${score}  Wrong: ${wrong}`, WIDTH / 2, HEIGHT * 0.38);
    // restart button
    const btn = getEndButtonRect();
    ctx.fillStyle = won ? "#e6ffe9" : "#fff0f0";
    drawRoundedRect(ctx, btn.x, btn.y, btn.w, btn.h, 12);
    ctx.fillStyle = "#06314a";
    ctx.font = "20px sans-serif";
    ctx.fillText("Restart (R) and try again", btn.x + btn.w / 2, btn.y + btn.h / 2);
    // small hint
    ctx.font = BODY_FONT;
    ctx.fillStyle = "#ffffff";
    ctx.fillText("Click Restart or press R to play again.", WIDTH / 2, btn.y + btn.h + 36);
  }

  // Cloud drawing simple shapes for background
  function drawCloud(ctx, x, y, scale = 1, alpha = 1) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.arc(0, 0, 22, 0, Math.PI * 2);
    ctx.arc(24, -6, 18, 0, Math.PI * 2);
    ctx.arc(40, 2, 20, 0, Math.PI * 2);
    ctx.arc(18, 10, 16, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  // Main loop
  function loop(now) {
    const dt = now - lastTime;
    lastTime = now;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Accessibility: draw focus outlines and ensure canvas informs keyboard users
  // This is drawn as part of render (we provide overlays and text instructions).
  // Provide a keyboard-only help shortcut: pressing "h" will announce controls
  window.addEventListener("keydown", (e) => {
    if (e.key.toLowerCase() === "h") {
      announce("Controls: Arrow keys or W A S D to move, click the screen to nudge the drone, M toggles sound, R to restart.");
    }
  });

  // Resize and layout: ensure canvas stays the desired size
  canvas.style.width = WIDTH + "px";
  canvas.style.height = HEIGHT + "px";
  canvas.setAttribute("width", WIDTH);
  canvas.setAttribute("height", HEIGHT);

  // Start screen assets: spawn some floating answers even on menu for lively feel
  function initMenuAnswers() {
    currentQuestion = generateQuestion(1);
    spawnAnswers(currentQuestion);
  }
  initMenuAnswers();

  // Expose small debug API (non-intrusive)
  window._droneMathGame = {
    start: startGame,
    menu: goToMenu,
    getState: () => ({ score, wrong, gameState })
  };
})();
---

