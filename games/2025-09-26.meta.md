# Game of the Day - 2025-09-26

## Metadata
- **Generated Date:** 2025-09-26
- **Generated Time:** 2025-09-26T00:26:43.075534
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-26.js
- **File Size:** 32151 bytes
- **Tokens Used:** 10219

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-26.js` - The playable game
- `2025-09-26.meta.json` - Machine-readable metadata
- `2025-09-26.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 22485

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 24666

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Machine Math Game for ages 7-9
  // Renders into element with id "game-of-the-day-stage"
  // Canvas-based visuals, Web Audio API sounds (generated), accessible text alternatives, keyboard controls.

  // --------- Setup and Constants ----------
  const STAGE_ID = "game-of-the-day-stage";
  const WIDTH = 720;
  const HEIGHT = 480;

  const COLORS = {
    bg: "#E8F1F2",
    panel: "#E6EEF7",
    machine: "#D3E8DF",
    gear: "#FFD6A5",
    gearAccent: "#FFB86B",
    highlight: "#88C0D0",
    text: "#1E3A44",
    wrong: "#E85A4F",
    correct: "#4BB543",
    muted: "#A0A0A0",
  };

  const MAX_LEVEL = 6;

  // Accessibility live region
  let liveRegion = null;

  // Canvas & context
  const stage = document.getElementById(STAGE_ID);
  if (!stage) {
    console.error(`Element with id "${STAGE_ID}" not found.`);
    return;
  }
  stage.style.position = "relative"; // ensure positioning for hidden live region

  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute("role", "img");
  canvas.setAttribute("aria-label", "Machine Math game canvas");
  canvas.style.width = WIDTH + "px";
  canvas.style.height = HEIGHT + "px";
  canvas.style.display = "block";
  canvas.style.margin = "0 auto";
  stage.appendChild(canvas);

  const ctx = canvas.getContext("2d");
  if (!ctx) {
    console.error("Canvas 2D context not supported.");
    return;
  }

  // Create an aria-live region for screen readers (visually hidden but accessible)
  liveRegion = document.createElement("div");
  liveRegion.setAttribute("aria-live", "polite");
  liveRegion.style.position = "absolute";
  liveRegion.style.left = "-9999px";
  liveRegion.style.width = "1px";
  liveRegion.style.height = "1px";
  liveRegion.style.overflow = "hidden";
  stage.appendChild(liveRegion);

  // --------- Audio Setup (Web Audio API) ----------
  let audioCtx = null;
  let audioEnabled = true;
  let bgGainNode = null;
  let bgOsc = null;

  function safeCreateAudioContext() {
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) throw new Error("Web Audio API not supported in this browser.");
      audioCtx = new AC();
      // resume on user interaction if necessary
      if (audioCtx.state === "suspended") {
        const resume = () => {
          audioCtx.resume().catch(() => {});
          window.removeEventListener("pointerdown", resume);
          window.removeEventListener("keydown", resume);
        };
        window.addEventListener("pointerdown", resume);
        window.addEventListener("keydown", resume);
      }
      return true;
    } catch (err) {
      console.warn("Audio context could not be created:", err);
      audioEnabled = false;
      audioCtx = null;
      return false;
    }
  }

  safeCreateAudioContext();

  function playTone(frequency = 440, duration = 0.25, type = "sine", when = 0, gain = 0.12) {
    if (!audioEnabled || !audioCtx) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = frequency;
      g.gain.value = 0;
      o.connect(g);
      g.connect(audioCtx.destination);
      const start = audioCtx.currentTime + when;
      // envelope
      g.gain.setValueAtTime(0, start);
      g.gain.linearRampToValueAtTime(gain, start + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, start + duration);
      o.start(start);
      o.stop(start + duration + 0.02);
    } catch (err) {
      console.warn("playTone error:", err);
    }
  }

  function playCorrect() {
    if (!audioEnabled || !audioCtx) return;
    try {
      // Cheap arpeggio
      const now = audioCtx.currentTime;
      playTone(880, 0.12, "triangle", 0, 0.08);
      playTone(1100, 0.12, "triangle", 0.12, 0.08);
      playTone(1320, 0.2, "sine", 0.26, 0.12);
    } catch (err) {
      console.warn("playCorrect error:", err);
    }
  }

  function playWrong() {
    if (!audioEnabled || !audioCtx) return;
    try {
      playTone(220, 0.35, "sawtooth", 0, 0.16);
      // small dissonant second
      playTone(260, 0.2, "sawtooth", 0.06, 0.08);
    } catch (err) {
      console.warn("playWrong error:", err);
    }
  }

  function startBackgroundHum() {
    if (!audioEnabled || !audioCtx) return;
    try {
      if (bgOsc) return; // already running
      bgOsc = audioCtx.createOscillator();
      const lfo = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      bgOsc.type = "sine";
      bgOsc.frequency.value = 60;
      lfo.frequency.value = 0.25;
      gain.gain.value = 0.02;
      filter.type = "lowpass";
      filter.frequency.value = 600;

      lfo.connect(gain.gain);
      bgOsc.connect(filter);
      filter.connect(audioCtx.destination);
      bgOsc.start();
      lfo.start();
      bgOsc.connect(audioCtx.destination); // softened by low volumes later
      // Use a separate gain node at destination for control
      bgGainNode = audioCtx.createGain();
      bgGainNode.gain.value = 0.02;
      bgOsc.disconnect();
      bgOsc.connect(filter);
      filter.disconnect();
      filter.connect(bgGainNode);
      bgGainNode.connect(audioCtx.destination);
      lfo.connect(bgGainNode.gain);
      // Ensure background presence but not loud.
    } catch (err) {
      console.warn("startBackgroundHum error:", err);
    }
  }

  function stopBackgroundHum() {
    if (!audioEnabled || !audioCtx) return;
    try {
      if (bgOsc) {
        bgOsc.stop();
        bgOsc.disconnect();
        bgOsc = null;
      }
      if (bgGainNode) {
        bgGainNode.disconnect();
        bgGainNode = null;
      }
    } catch (err) {
      console.warn("stopBackgroundHum error:", err);
    }
  }

  // Start background hum if audio works
  if (audioEnabled && audioCtx) {
    try {
      startBackgroundHum();
    } catch (e) {
      console.warn("Background hum failed:", e);
    }
  }

  // Allow toggling audio with 'M'
  function toggleAudio() {
    audioEnabled = !audioEnabled;
    if (!audioEnabled) {
      stopBackgroundHum();
      announce("Audio muted.");
    } else {
      if (!audioCtx) safeCreateAudioContext();
      if (audioCtx) startBackgroundHum();
      announce("Audio unmuted.");
    }
  }

  // --------- Game State ----------
  let level = 1;
  let availableGears = []; // array of numbers
  let slots = []; // built gears (numbers or null)
  let selectedIndex = 0; // index of selected gear or slot
  let selectedMode = "gear"; // 'gear' or 'slot'
  let target = 0;
  let maxSlots = 3;
  let messageText = "Welcome! Use arrow keys to pick gears and press Space to load into the machine. Press S to start the machine.";
  let showHint = false;
  let gameWon = false;
  let muteVisual = !audioEnabled;

  // Helper for announcing to screen reader
  function announce(text) {
    if (!liveRegion) return;
    try {
      liveRegion.textContent = text;
    } catch (e) {
      console.warn("announce failed:", e);
    }
  }

  // Create a solvable level:
  function generateLevel(lvl) {
    // Determine number of slots based on level (increase gradually up to 5)
    maxSlots = Math.min(3 + Math.floor((lvl - 1) / 2), 5);
    // Choose n numbers that will form the solution
    const solution = [];
    const pool = [];
    // Create a pool of numbers appropriate to level
    const maxVal = Math.min(12 + lvl * 2, 20);
    for (let i = 1; i <= maxVal; i++) pool.push(i);

    // Randomly pick maxSlots numbers from pool to be the solution
    for (let i = 0; i < maxSlots; i++) {
      const idx = Math.floor(Math.random() * pool.length);
      solution.push(pool.splice(idx, 1)[0]);
    }

    // target is sum of solution
    target = solution.reduce((a, b) => a + b, 0);

    // Now create available gears: include the solution numbers, plus some distractors
    const gears = solution.slice();
    // Add distractors: up to 6 available total
    const totalGears = Math.max(6, Math.min(8, 4 + lvl));
    while (gears.length < totalGears) {
      // pick random from pool or from set 1..maxVal
      const candidate = 1 + Math.floor(Math.random() * maxVal);
      // avoid too many duplicates of same value so there's a chance to choose right combos
      if (gears.filter((x) => x === candidate).length < 2) {
        gears.push(candidate);
      }
    }

    // Shuffle gears
    for (let i = gears.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [gears[i], gears[j]] = [gears[j], gears[i]];
    }

    availableGears = gears;
    slots = new Array(maxSlots).fill(null);
    selectedIndex = 0;
    selectedMode = "gear";
    messageText = `Level ${lvl}: Build a sum of ${target} using ${maxSlots} slots.`;
    showHint = false;
    gameWon = false;
    announce(messageText);
  }

  // Place a gear into selected slot (or remove if slot selected)
  function loadGearToSlot(gearIndex, slotIndex) {
    if (gearIndex < 0 || gearIndex >= availableGears.length) return false;
    if (slotIndex < 0 || slotIndex >= slots.length) return false;
    if (slots[slotIndex] !== null) {
      // replace: return current gear to availableGears (in next free spot)
      // to keep it simple, swap
      // find empty or replace
      const temp = slots[slotIndex];
      slots[slotIndex] = availableGears[gearIndex];
      availableGears[gearIndex] = temp;
    } else {
      // place gear into slot and remove from available list (set to null marker)
      slots[slotIndex] = availableGears[gearIndex];
      // mark available slot with null marker to keep indices consistent
      availableGears[gearIndex] = null;
      // compact availableGears so nulls cluster, but keep indices stable enough: we will redraw skipping nulls
      compactAvailableGears();
    }
    // sound
    playTone(660, 0.08, "sine", 0, 0.06);
    messageText = `Placed a gear in slot ${slotIndex + 1}.`;
    announce(messageText);
    return true;
  }

  function removeFromSlot(slotIndex) {
    if (slotIndex < 0 || slotIndex >= slots.length) return false;
    if (slots[slotIndex] === null) return false;
    // Return gear to availableGears; find a null spot or push
    let found = false;
    for (let i = 0; i < availableGears.length; i++) {
      if (availableGears[i] === null) {
        availableGears[i] = slots[slotIndex];
        found = true;
        break;
      }
    }
    if (!found) {
      availableGears.push(slots[slotIndex]);
    }
    slots[slotIndex] = null;
    compactAvailableGears();
    playTone(520, 0.08, "sine", 0, 0.06);
    messageText = `Removed gear from slot ${slotIndex + 1}.`;
    announce(messageText);
    return true;
  }

  function compactAvailableGears() {
    // Remove trailing nulls but keep some nulls if too few gears
    const newGears = availableGears.filter((g) => g !== null && g !== undefined);
    // Keep at least 4 spots for visual consistency
    while (newGears.length < 6) newGears.push(null);
    availableGears = newGears;
  }

  function computeSlotSum() {
    return slots.reduce((sum, v) => (v ? sum + v : sum), 0);
  }

  // Validate the machine: if sum equals target it's correct
  function startMachine() {
    const sum = computeSlotSum();
    if (slots.includes(null)) {
      messageText = `Fill all ${maxSlots} slots before starting!`;
      playWrong();
      announce(messageText);
      return false;
    }
    if (sum === target) {
      // success
      playCorrect();
      // celebratory animation
      messageText = `Nice! You built ${target}.`;
      announce(messageText);
      gameWon = true;
      setTimeout(() => {
        level++;
        if (level > MAX_LEVEL) {
          // game finished
          messageText = "You fixed the Great Machine! You win! Press R to play again.";
          announce(messageText);
        } else {
          generateLevel(level);
        }
      }, 900);
      return true;
    } else {
      playWrong();
      // brief shake effect
      messageText = `Not quite. Your machine produced ${sum}, but the target is ${target}. Try again or press H for a hint.`;
      announce(messageText);
      return false;
    }
  }

  // Provide a hint: show one gear from the solution or show whether sum is too low/high
  function provideHint() {
    showHint = true;
    const sum = computeSlotSum();
    if (slots.includes(null)) {
      messageText = `Hint: Try picking a combination that adds to ${target}.`;
    } else {
      if (sum < target) {
        messageText = `Hint: Your sum ${sum} is too low. Try larger numbers.`;
      } else {
        messageText = `Hint: Your sum ${sum} is too high. Try smaller numbers.`;
      }
    }
    playTone(440, 0.18, "triangle", 0, 0.06);
    announce(messageText);
  }

  // Reset level
  function resetLevel() {
    generateLevel(level);
  }

  // Reset entire game
  function resetGame() {
    level = 1;
    generateLevel(level);
  }

  // Build initial level
  generateLevel(level);

  // ---------- Input Handling (mouse and keyboard) ----------
  // Convert mouse position to gear index or slot index
  function getHitAt(x, y) {
    // Gear area on left bottom
    // Gear bounds layout
    const gearArea = { x: 40, y: 320, w: 640, h: 140 };
    // Each gear drawn horizontally
    const gearCount = availableGears.length;
    const gearWidth = 88;
    const gearGap = 16;
    const baseX = 60;
    const baseY = 340;
    for (let i = 0, drawnIndex = 0; i < availableGears.length; i++) {
      const val = availableGears[i];
      // Skip nulls (empty spots)
      if (val === null || val === undefined) {
        // empty slot area - still clickable for placing returned gear? we skip.
      }
      const gx = baseX + drawnIndex * (gearWidth + gearGap);
      const gy = baseY;
      const gw = gearWidth;
      const gh = gearWidth;
      if (x >= gx && x <= gx + gw && y >= gy && y <= gy + gh) {
        return { type: "gear", index: i, drawnIndex };
      }
      if (val !== null) drawnIndex++;
    }

    // Slot area on machine center
    const slotsWidth = slots.length * 80 + (slots.length - 1) * 20;
    const sx = WIDTH / 2 - slotsWidth / 2;
    const sy = 200;
    for (let i = 0; i < slots.length; i++) {
      const gx = sx + i * 100;
      const gy = sy;
      const gw = 80;
      const gh = 80;
      if (x >= gx && x <= gx + gw && y >= gy && y <= gy + gh) {
        return { type: "slot", index: i };
      }
    }

    // Start button
    const btn = getStartButtonRect();
    if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
      return { type: "start" };
    }

    // Audio toggle
    const aud = getAudioIconRect();
    if (x >= aud.x && x <= aud.x + aud.w && y >= aud.y && y <= aud.y + aud.h) {
      return { type: "audio" };
    }

    return null;
  }

  function canvasPointerHandler(e) {
    let rect = canvas.getBoundingClientRect();
    let x = (e.clientX - rect.left) * (canvas.width / rect.width);
    let y = (e.clientY - rect.top) * (canvas.height / rect.height);
    const hit = getHitAt(x, y);
    if (!hit) return;
    if (hit.type === "gear") {
      // select gear (toggle mode)
      selectedMode = "gear";
      selectedIndex = hit.index;
      announce(`Selected gear ${availableGears[hit.index] || "empty"}`);
      // if currently selected slot, and slot empty, place into slot automatically?
      // Let's just pick and let user place in slot by clicking slot
    } else if (hit.type === "slot") {
      selectedMode = "slot";
      selectedIndex = hit.index;
      announce(`Selected slot ${hit.index + 1}`);
    } else if (hit.type === "start") {
      startMachine();
    } else if (hit.type === "audio") {
      toggleAudio();
      muteVisual = !audioEnabled;
    }
  }

  canvas.addEventListener("pointerdown", canvasPointerHandler);

  // Click-to-place: when gear selected and then clicking slot will place
  canvas.addEventListener("pointerup", (e) => {
    let rect = canvas.getBoundingClientRect();
    let x = (e.clientX - rect.left) * (canvas.width / rect.width);
    let y = (e.clientY - rect.top) * (canvas.height / rect.height);
    const hit = getHitAt(x, y);
    if (!hit) return;
    if (hit.type === "slot" && selectedMode === "gear") {
      // Place selected gear into this slot
      if (availableGears[selectedIndex] == null) {
        messageText = "You selected an empty gear spot.";
        announce(messageText);
        playWrong();
        return;
      }
      loadGearToSlot(selectedIndex, hit.index);
    } else if (hit.type === "gear" && selectedMode === "slot") {
      // If a slot is selected and gear is clicked, swap
      const targetSlot = selectedIndex;
      if (slots[targetSlot] == null) {
        // place gear into slot
        loadGearToSlot(hit.index, targetSlot);
      } else {
        // swap
        const tmp = slots[targetSlot];
        slots[targetSlot] = availableGears[hit.index];
        availableGears[hit.index] = tmp;
        compactAvailableGears();
        playTone(640, 0.08, "sine", 0, 0.06);
      }
    }
  });

  // Keyboard controls
  window.addEventListener("keydown", (e) => {
    if (gameWon && level > MAX_LEVEL) {
      // if fully completed, allow R to restart
      if (e.key.toLowerCase() === "r") resetGame();
      return;
    }
    switch (e.key) {
      case "ArrowLeft":
        // move selection left inside current mode
        if (selectedMode === "gear") {
          selectedIndex = Math.max(0, selectedIndex - 1);
        } else {
          selectedIndex = Math.max(0, selectedIndex - 1);
        }
        announceSelection();
        break;
      case "ArrowRight":
        if (selectedMode === "gear") {
          selectedIndex = Math.min(availableGears.length - 1, selectedIndex + 1);
        } else {
          selectedIndex = Math.min(slots.length - 1, selectedIndex + 1);
        }
        announceSelection();
        break;
      case "ArrowUp":
        // switch to gear mode
        selectedMode = "gear";
        selectedIndex = Math.min(selectedIndex, Math.max(0, availableGears.length - 1));
        announceSelection();
        break;
      case "ArrowDown":
        selectedMode = "slot";
        selectedIndex = Math.min(selectedIndex, Math.max(0, slots.length - 1));
        announceSelection();
        break;
      case " ":
      case "Enter":
        // act: if gear selected and slot selection exists, try placing in currently highlighted slot
        if (selectedMode === "gear") {
          // place into first empty slot or currently selected slot
          let targetSlot = slots.findIndex((s) => s === null);
          if (targetSlot === -1) targetSlot = 0;
          loadGearToSlot(selectedIndex, targetSlot);
        } else {
          // slot selected: if slot has gear, remove it; if empty, try fill with selected gear if any (none)
          if (slots[selectedIndex] !== null) {
            removeFromSlot(selectedIndex);
          } else {
            // try to put currently highlighted gear (if any) into this slot
            const gearIdx = availableGears.findIndex((g) => g !== null && g !== undefined);
            if (gearIdx !== -1) {
              loadGearToSlot(gearIdx, selectedIndex);
            } else {
              messageText = "No available gears to place.";
              playWrong();
              announce(messageText);
            }
          }
        }
        break;
      case "s":
      case "S":
        startMachine();
        break;
      case "r":
      case "R":
        resetLevel();
        break;
      case "h":
      case "H":
        provideHint();
        break;
      case "m":
      case "M":
        toggleAudio();
        muteVisual = !audioEnabled;
        break;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        // quick select gear by number 1..9 mapping to index
        {
          const idx = parseInt(e.key, 10) - 1;
          if (idx >= 0 && idx < availableGears.length) {
            selectedMode = "gear";
            selectedIndex = idx;
            announceSelection();
          }
        }
        break;
      default:
        break;
    }
  });

  function announceSelection() {
    if (selectedMode === "gear") {
      const val = availableGears[selectedIndex];
      announce(val ? `Selected gear ${val}` : "Selected empty gear spot");
    } else {
      const val = slots[selectedIndex];
      announce(val ? `Selected slot ${selectedIndex + 1} with value ${val}` : `Selected empty slot ${selectedIndex + 1}`);
    }
  }

  // ---------- Drawing Utilities ----------
  function drawRoundedRect(x, y, w, h, r = 10, fill = true, stroke = false) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  function drawGear(cx, cy, radius, teeth = 8, holeRadius = 10, baseColor = COLORS.gear, accent = COLORS.gearAccent) {
    // Draw gear using arcs and spikes
    ctx.save();
    ctx.translate(cx, cy);
    // rim with teeth
    for (let i = 0; i < teeth; i++) {
      const angle = (i / teeth) * Math.PI * 2;
      const nextAngle = ((i + 0.6) / teeth) * Math.PI * 2;
      ctx.beginPath();
      ctx.moveTo(Math.cos(angle) * (radius - 6), Math.sin(angle) * (radius - 6));
      ctx.lineTo(Math.cos(nextAngle) * (radius + 6), Math.sin(nextAngle) * (radius + 6));
      ctx.lineTo(Math.cos((i + 1) / teeth * Math.PI * 2) * (radius - 6), Math.sin((i + 1) / teeth * Math.PI * 2) * (radius - 6));
      ctx.closePath();
      ctx.fillStyle = accent;
      ctx.fill();
    }
    // body
    ctx.beginPath();
    ctx.arc(0, 0, radius - 6, 0, Math.PI * 2);
    ctx.fillStyle = baseColor;
    ctx.fill();
    // center hole
    ctx.beginPath();
    ctx.arc(0, 0, holeRadius, 0, Math.PI * 2);
    ctx.fillStyle = COLORS.machine;
    ctx.fill();
    // small screws
    ctx.fillStyle = "rgba(0,0,0,0.08)";
    for (let i = 0; i < 3; i++) {
      const a = (i / 3) * Math.PI * 2;
      ctx.beginPath();
      ctx.arc(Math.cos(a) * (radius - 20), Math.sin(a) * (radius - 20), 2, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  function getStartButtonRect() {
    const w = 130,
      h = 46;
    const x = WIDTH - w - 20;
    const y = HEIGHT - h - 20;
    return { x, y, w, h };
  }

  function getAudioIconRect() {
    const w = 36,
      h = 36;
    const x = 20;
    const y = 20;
    return { x, y, w, h };
  }

  // ---------- Main Render Loop ----------
  let lastTick = performance.now();
  let shake = 0;
  function render() {
    const now = performance.now();
    const dt = (now - lastTick) / 1000;
    lastTick = now;

    // Update simple animations
    if (shake > 0) shake = Math.max(0, shake - dt * 4);

    // Clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // background calming gradient with wacky clouds
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, COLORS.bg);
    g.addColorStop(1, "#F6FAFB");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Light pattern - diagonal stripes
    ctx.save();
    ctx.globalAlpha = 0.06;
    ctx.fillStyle = "#FFF";
    for (let i = -HEIGHT; i < WIDTH; i += 80) {
      ctx.fillRect(i, 0, 40, HEIGHT);
    }
    ctx.restore();

    // big machine panel
    ctx.save();
    const panelX = 60,
      panelY = 40,
      panelW = WIDTH - 120,
      panelH = 240;
    ctx.fillStyle = COLORS.panel;
    drawRoundedRect(panelX, panelY, panelW, panelH, 18, true, false);
    // decorative pipes
    ctx.fillStyle = "#CFEDE6";
    ctx.fillRect(panelX + 14, panelY + panelH - 26, panelW - 28, 12);
    ctx.fillRect(panelX + 18, panelY + 20, 12, panelH - 48);
    ctx.fillRect(panelX + panelW - 30, panelY + 20, 12, panelH - 48);
    ctx.restore();

    // Robot friendly face on top-left
    ctx.save();
    ctx.translate(panelX + 20, panelY + 20);
    ctx.fillStyle = "#EDE7FF";
    drawRoundedRect(-6, -6, 92, 60, 12, true);
    ctx.fillStyle = "#BFC9FF";
    ctx.beginPath();
    ctx.arc(32, 24, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(60, 24, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // Target display
    ctx.save();
    ctx.fillStyle = COLORS.machine;
    ctx.strokeStyle = "#BBD6D2";
    ctx.lineWidth = 2;
    const targetX = WIDTH / 2 - 120;
    const targetY = 90;
    drawRoundedRect(targetX - 8, targetY - 18, 240, 72, 10, true, true);
    ctx.fillStyle = COLORS.text;
    ctx.font = "22px Arial";
    ctx.textAlign = "center";
    ctx.fillText(`Target: ${target}`, targetX + 120, targetY + 30);
    ctx.restore();

    // Slots area with slight shake
    ctx.save();
    const shakeX = Math.sin(performance.now() / 60) * shake * 6;
    ctx.translate(shakeX, 0);
    const sx = WIDTH / 2 - (slots.length * 80 + (slots.length - 1) * 20) / 2;
    const sy = 170;
    for (let i = 0; i < slots.length; i++) {
      const x = sx + i * 100;
      const y = sy;
      // slot background
      ctx.fillStyle = "#EDF7F5";
      drawRoundedRect(x, y, 80, 80, 10, true, false);
      // border highlight if selected
      if (selectedMode === "slot" && selectedIndex === i) {
        ctx.strokeStyle = COLORS.highlight;
        ctx.lineWidth = 4;
        ctx.strokeRect(x + 2, y + 2, 76, 76);
      }
      // if it has a gear, draw
      if (slots[i] !== null && slots[i] !== undefined) {
        drawGear(x + 40, y + 40, 30, 8, 8, COLORS.gear, COLORS.gearAccent);
        ctx.fillStyle = COLORS.text;
        ctx.font = "16px Arial";
        ctx.textAlign = "center";
        ctx.fillText(String(slots[i]), x + 40, y + 48);
      } else {
        // hint ghost or placeholder
        ctx.fillStyle = "#F3FFFB";
        ctx.beginPath();
        ctx.arc(x + 40, y + 40, 18, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    ctx.restore();

    // Available gears - bottom area
    ctx.save();
    const baseX = 60;
    const baseY = 340;
    ctx.fillStyle = "#F7FBFE";
    drawRoundedRect(40, 316, 640, 140, 12, true);
    // draw each available gear
    let drawn = 0;
    for (let i = 0; i < availableGears.length; i++) {
      const val = availableGears[i];
      if (val === null || val === undefined) {
        // leave empty slot placeholder
        const gx = baseX + drawn * 104;
        ctx.fillStyle = "#EEEEF0";
        drawRoundedRect(gx, baseY, 88, 88, 14, true);
        drawn++;
        continue;
      }
      const gx = baseX + drawn * 104;
      const gy = baseY;
      // draw gear
      drawGear(gx + 44, gy + 44, 36, 10, 8, COLORS.gear, COLORS.gearAccent);
      // number
      ctx.fillStyle = COLORS.text;
      ctx.font = "18px Arial";
      ctx.textAlign = "center";
      ctx.fillText(String(val), gx + 44, gy + 52);
      // highlight if selected
      if (selectedMode === "gear" && selectedIndex === i) {
        ctx.strokeStyle = COLORS.highlight;
        ctx.lineWidth = 3;
        ctx.strokeRect(gx + 2, gy + 2, 84, 84);
      }
      drawn++;
    }
    ctx.restore();

    // Start button
    const btn = getStartButtonRect();
    ctx.save();
    ctx.fillStyle = COLORS.highlight;
    drawRoundedRect(btn.x, btn.y, btn.w, btn.h, 8, true);
    ctx.fillStyle = "#072A2A";
    ctx.font = "18px Arial";
    ctx.textAlign = "center";
    ctx.fillText("Start Machine", btn.x + btn.w / 2, btn.y + btn.h / 2 + 7);
    ctx.restore();

    // Audio icon
    const aud = getAudioIconRect();
    ctx.save();
    ctx.fillStyle = muteVisual ? COLORS.muted : COLORS.highlight;
    drawRoundedRect(aud.x, aud.y, aud.w, aud.h, 8, true);
    ctx.fillStyle = muteVisual ? "#FFFFFF" : "#052727";
    // speaker triangle
    ctx.beginPath();
    ctx.moveTo(aud.x + 8, aud.y + 10);
    ctx.lineTo(aud.x + 18, aud.y + 18);
    ctx.lineTo(aud.x + 8, aud.y + 26);
    ctx.closePath();
    ctx.fill();
    if (!audioEnabled) {
      // draw cross
      ctx.strokeStyle = "#FFFFFF";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(aud.x + 22, aud.y + 12);
      ctx.lineTo(aud.x + 30, aud.y + 24);
      ctx.moveTo(aud.x + 30, aud.y + 12);
      ctx.lineTo(aud.x + 22, aud.y + 24);
      ctx.stroke();
    } else {
      // sound waves
      ctx.strokeStyle = muteVisual ? "#FFFFFF" : "#073737";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(aud.x + 28, aud.y + 18, 6, -0.6, 0.6);
      ctx.stroke();
    }
    ctx.restore();

    // Message panel
    ctx.save();
    ctx.fillStyle = "#FFFFFFAA";
    drawRoundedRect(60, 260, 600, 40, 8, true);
    ctx.fillStyle = COLORS.text;
    ctx.font = "14px Arial";
    ctx.textAlign = "left";
    ctx.fillText(messageText, 76, 285);
    ctx.restore();

    // Hint area
    ctx.save();
    const hintX = 60;
    const hintY = 300;
    ctx.fillStyle = "#F9FFFB";
    ctx.font = "13px Arial";
    ctx.textAlign = "left";
    if (showHint) {
      ctx.fillStyle = "#F8FFEE";
      drawRoundedRect(hintX, hintY, 280, 28, 6, true);
      ctx.fillStyle = "#075A4A";
      ctx.fillText("Hint shown above. Press H for another hint.", hintX + 10, hintY + 18);
    } else {
      ctx.fillStyle = "#F3F7F9";
      drawRoundedRect(hintX, hintY, 280, 28, 6, true);
      ctx.fillStyle = "#07424C";
      ctx.fillText("Tip: Press H for a gentle hint. Press M to mute/unmute.", hintX + 10, hintY + 18);
    }
    ctx.restore();

    // Level indicator and progress
    ctx.save();
    ctx.fillStyle = COLORS.text;
    ctx.font = "16px Arial";
    ctx.textAlign = "right";
    ctx.fillText(`Level ${level} / ${MAX_LEVEL}`, WIDTH - 20, 30);
    ctx.restore();

    // If game fully won show confetti-ish shapes
    if (level > MAX_LEVEL) {
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = COLORS.correct;
      for (let i = 0; i < 60; i++) {
        const rx = (Math.sin(i * 12.3 + now / 500) + 1) * WIDTH * Math.random() * 0.5 + WIDTH * 0.25;
        const ry = Math.random() * HEIGHT;
        ctx.fillRect(rx % WIDTH, ry, 4, 8);
      }
      ctx.fillStyle = "#FFFFFF";
      ctx.font = "28px Arial";
      ctx.textAlign = "center";
      ctx.fillText("Great job! The Great Machine is fixed!", WIDTH / 2, HEIGHT / 2);
      ctx.font = "16px Arial";
      ctx.fillText("Press R to play again.", WIDTH / 2, HEIGHT / 2 + 32);
      ctx.restore();
    }

    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);

  // ---------- Error Handling Notes and Robustness ----------
  // Attempt to ensure graceful behavior if audio context lost or restricted
  window.addEventListener("unhandledrejection", (e) => {
    console.warn("Unhandled promise rejection in game:", e.reason);
  });

  window.addEventListener("error", (err) => {
    console.warn("Game error:", err.message);
  });

  // ---------- Initial instructions and accessibility ----------
  announce(
    "Machine Math: Use left/right arrows to choose items, up/down to switch between gears and slots, space to place or remove. Press S to start, H for a hint, M to mute."
  );

  // Expose minimal debug controls on the stage element for screen readers (visually hidden)
  const srControls = document.createElement("div");
  srControls.style.position = "absolute";
  srControls.style.left = "-9999px";
  srControls.innerHTML =
    "Controls: Arrow keys to navigate. Space or Enter to place. S to start. H for hint. R to reset. M to toggle sound.";
  stage.appendChild(srControls);

  // For usability, ensure initial audio context user gesture requirement handled on first pointerdown
  function ensureAudioOnGesture() {
    if (!audioCtx) safeCreateAudioContext();
    if (audioCtx && audioCtx.state === "suspended") {
      audioCtx.resume().catch(() => {});
    }
    window.removeEventListener("pointerdown", ensureAudioOnGesture);
  }
  window.addEventListener("pointerdown", ensureAudioOnGesture);

  // Expose a small API for testing in console (not required)
  window._machineMath = {
    resetGame,
    resetLevel,
    generateLevel,
    toggleAudio,
    getState: () => ({ level, target, slots, availableGears }),
  };
})();
---

