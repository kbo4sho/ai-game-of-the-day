# Game of the Day - 2025-10-13

## Metadata
- **Generated Date:** 2025-10-13
- **Generated Time:** 2025-10-13T00:29:00.924642
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-10-13.js
- **File Size:** 25802 bytes
- **Tokens Used:** 9069

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** âœ… PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** âœ… NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
â€¢ Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
â€¢ Use visually calming and interesting and wacky elements.
â€¢ Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
â€¢ Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
â€¢ Have a game area exactly 720px wide by 480px tall.
â€¢ Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
â€¢ Use modern JavaScript practices and avoid minification.
â€¢ Include proper error handling for audio and resource loading.
â€¢ Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
â€¢ Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
â€¢ Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
â€¢ Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
â€¢ Generate all sounds using Web Audio API oscillators and filters.
â€¢ Include proper error handling for audio context creation.
â€¢ Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
â€¢ Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-10-13.js` - The playable game
- `2025-10-13.meta.json` - Machine-readable metadata
- `2025-10-13.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 18810

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 21343

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** âœ… PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Drone Math Collector - JavaScript Game
  // Renders inside element with ID game-of-the-day-stage
  // Designed for ages 7-9. Uses Canvas and Web Audio API only.
  // Clear win: collect TARGET_SCORE correct numbers.
  // Clear loss: reach MAX_WRONG wrong collections (lives system).
  // Includes keyboard controls, clickable restart, accessible canvas attributes, audio toggle,
  // and careful layout using ctx.measureText to avoid overlapping text.

  // CONFIG
  const WIDTH = 720;
  const HEIGHT = 480;
  const TARGET_SCORE = 10; // win condition
  const MAX_WRONG = 3; // lives
  const STARTING_BALLOONS = 5;
  const MIN_NUMBER = 1;
  const MAX_NUMBER = 20;
  const BODY_FONT = "16px system-ui, sans-serif";
  const TITLE_FONT = "22px system-ui, sans-serif";
  const IMPORTANT_FONT = "28px system-ui, sans-serif";
  const PADDING = 10; // min 10px padding
  const BOTTOM_INSTRUCTIONS_HEIGHT = 80; // reserved bottom area for instructions

  // Get container and create canvas
  const container = document.getElementById("game-of-the-day-stage");
  if (!container) {
    console.error("Container #game-of-the-day-stage not found.");
    return;
  }
  container.style.position = "relative";
  container.style.width = WIDTH + "px";
  container.style.height = HEIGHT + "px";
  container.style.userSelect = "none";

  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.tabIndex = 0; // make keyboard focusable
  canvas.setAttribute("role", "application");
  canvas.setAttribute("aria-label", "Drone Math Collector game. Use arrow keys to move, space to pick up balloons. Press R to restart.");
  container.appendChild(canvas);

  const ctx = canvas.getContext("2d");

  // Audio setup with proper error handling
  let audioEnabled = true;
  let audioContext = null;
  try {
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) throw new Error("Web Audio API not supported");
    audioContext = new AC();
    // unlock audio on interaction for browsers that require it
    const unlock = () => {
      if (audioContext.state === "suspended") {
        audioContext.resume().catch(() => {});
      }
      window.removeEventListener("pointerdown", unlock);
      window.removeEventListener("keydown", unlock);
    };
    window.addEventListener("pointerdown", unlock, { once: true });
    window.addEventListener("keydown", unlock, { once: true });
  } catch (e) {
    console.warn("Audio context creation failed:", e);
    audioEnabled = false;
    audioContext = null;
  }

  // Sound generators (simple oscillator-based)
  function playTone({ type = "sine", freq = 440, duration = 0.25, volume = 0.06, attack = 0.01, decay = 0.05 }) {
    if (!audioEnabled || !audioContext) return;
    try {
      const now = audioContext.currentTime;
      const o = audioContext.createOscillator();
      const g = audioContext.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.linearRampToValueAtTime(volume, now + attack);
      g.gain.linearRampToValueAtTime(0.0001, now + duration - decay);
      o.connect(g);
      g.connect(audioContext.destination);
      o.start(now);
      o.stop(now + duration + 0.02);
      o.onended = () => {
        try {
          o.disconnect();
          g.disconnect();
        } catch (e) {}
      };
    } catch (e) {
      console.warn("Error playing tone:", e);
    }
  }

  function playCorrectSound() {
    // gentle chime: arpeggio-like
    playTone({ type: "sine", freq: 880, duration: 0.18, volume: 0.05 });
    setTimeout(() => playTone({ type: "sine", freq: 1100, duration: 0.16, volume: 0.05 }), 120);
  }

  function playWrongSound() {
    // buzzy short noise
    if (!audioEnabled || !audioContext) return;
    try {
      const now = audioContext.currentTime;
      const o = audioContext.createOscillator();
      const f = audioContext.createBiquadFilter();
      const g = audioContext.createGain();
      o.type = "square";
      o.frequency.value = 220;
      f.type = "highpass";
      f.frequency.value = 1000;
      g.gain.setValueAtTime(0.12, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
      o.connect(f);
      f.connect(g);
      g.connect(audioContext.destination);
      o.start(now);
      o.stop(now + 0.18);
      o.onended = () => {
        try {
          o.disconnect();
          f.disconnect();
          g.disconnect();
        } catch (e) {}
      };
    } catch (e) {
      console.warn("Error playing wrong sound:", e);
    }
  }

  // Game state
  let score = 0;
  let wrongs = 0;
  let balloons = [];
  let player = null;
  let targetQuestion = null;
  let elapsed = 0;
  let lastTime = 0;
  let running = false; // whether gameplay is active
  let gameState = "start"; // "start", "playing", "won", "lost"
  let backgroundOffset = 0;
  let showAudioStatusFlash = 0;

  // Input state
  const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, Space: false };

  // Utility functions
  function rand(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function clamp(v, a, b) {
    return Math.max(a, Math.min(b, v));
  }

  // Create player drone
  function resetPlayer() {
    player = {
      x: WIDTH / 2,
      y: HEIGHT / 2,
      r: 18,
      speed: 180, // px per second
      color: "#6BB7FF",
      wobble: 0
    };
  }

  // Create a new math question and set of balloons
  function spawnQuestion() {
    // Choose addition or subtraction with simple numbers
    const type = Math.random() < 0.6 ? "+" : "-";
    let a, b, answer;
    if (type === "+") {
      a = rand(1, 12);
      b = rand(1, 12);
      answer = a + b;
    } else {
      a = rand(5, 18);
      b = rand(1, 6);
      answer = a - b;
    }
    targetQuestion = { a, b, type, answer };

    // Spawn balloons with numbers, including the correct one
    balloons = [];
    const count = STARTING_BALLOONS;
    const correctIndex = rand(0, count - 1);
    for (let i = 0; i < count; i++) {
      let value;
      if (i === correctIndex) {
        value = answer;
      } else {
        // ensure wrong values not equal answer
        let v;
        do {
          v = rand(MIN_NUMBER, MAX_NUMBER);
        } while (v === answer);
        value = v;
      }
      // positions along top area (not overlapping bottom instructions)
      const spawnX = rand(40, WIDTH - 40);
      const spawnY = rand(60, HEIGHT - BOTTOM_INSTRUCTIONS_HEIGHT - 60);
      const vx = (Math.random() - 0.5) * (20 + score * 2); // slightly faster as score increases
      const vy = (Math.random() - 0.5) * 20;
      balloons.push({
        x: spawnX,
        y: spawnY,
        r: 20,
        vx,
        vy,
        value,
        wobble: Math.random() * Math.PI * 2,
        color: pastelColor(i)
      });
    }
  }

  // Pastel palette generator for wacky calming colors
  function pastelColor(index) {
    const hues = [200, 180, 220, 260, 140, 30, 20, 340];
    const h = hues[index % hues.length] + (index * 10 % 40);
    return `hsl(${h} 70% 75%)`;
  }

  // Draw calming background with soft clouds and grid
  function drawBackground(dt) {
    backgroundOffset += dt * 20; // scroll
    // sky
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, "#E8F7FF");
    g.addColorStop(1, "#F7FDFF");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // soft clouds - use arcs
    ctx.fillStyle = "rgba(255,255,255,0.6)";
    for (let i = 0; i < 6; i++) {
      const cx = (i * 220 - (backgroundOffset % 220));
      const cy = 60 + Math.sin((backgroundOffset / 60) + i) * 8;
      drawCloud(cx + 100, cy, 50 + (i % 3) * 6);
    }

    // gentle grid lines for calming techy look
    ctx.strokeStyle = "rgba(120,170,200,0.06)";
    ctx.lineWidth = 1;
    for (let x = -((backgroundOffset / 4) % 60); x < WIDTH; x += 60) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, HEIGHT);
      ctx.stroke();
    }
    for (let y = 0; y < HEIGHT; y += 60) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(WIDTH, y);
      ctx.stroke();
    }
  }

  function drawCloud(cx, cy, size) {
    ctx.beginPath();
    ctx.arc(cx - size / 2, cy, size * 0.6, 0, Math.PI * 2);
    ctx.arc(cx, cy - size * 0.2, size * 0.8, 0, Math.PI * 2);
    ctx.arc(cx + size / 2, cy, size * 0.6, 0, Math.PI * 2);
    ctx.fill();
  }

  // Draw UI elements with spacing and non-overlap using measureText
  function drawUI() {
    // Top-left: Score
    ctx.font = IMPORTANT_FONT;
    ctx.fillStyle = "#09324B";
    const scoreText = `Score: ${score}/${TARGET_SCORE}`;
    const scoreMetrics = ctx.measureText(scoreText);
    const scoreW = scoreMetrics.width;
    const scoreH = 28;
    const scoreX = PADDING;
    const scoreY = PADDING;
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    roundRectFill(scoreX - 6, scoreY - 6, scoreW + 12, scoreH + 12, 8);
    ctx.fillStyle = "#07405F";
    ctx.fillText(scoreText, scoreX + 0, scoreY + scoreH - 8);

    // Top-center: Audio toggle (visual indicator)
    ctx.font = BODY_FONT;
    const audioText = audioEnabled ? "ðŸ”Š Audio: On" : "ðŸ”ˆ Audio: Off";
    const audioMetrics = ctx.measureText(audioText);
    const audioW = audioMetrics.width;
    const audioX = (WIDTH - audioW) / 2;
    const audioY = PADDING;
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    roundRectFill(audioX - 6, audioY - 6, audioW + 12, 26 + 12 - 6, 8);
    ctx.fillStyle = "#07405F";
    ctx.fillText(audioText, audioX, audioY + 20);

    // If audio is disabled, flash small visual cue occasionally
    if (!audioEnabled && showAudioStatusFlash > 0) {
      ctx.fillStyle = "rgba(255,120,120,0.6)";
      ctx.fillRect(audioX + audioW + 14, audioY + 2, 8, 8);
    }

    // Top-right: Lives/wrongs
    ctx.font = IMPORTANT_FONT;
    const livesText = `Lives: ${Math.max(0, MAX_WRONG - wrongs)}`;
    const livesMetrics = ctx.measureText(livesText);
    const livesW = livesMetrics.width;
    const livesX = WIDTH - livesW - PADDING;
    const livesY = PADDING;
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    roundRectFill(livesX - 6, livesY - 6, livesW + 12, 28 + 12 - 6, 8);
    ctx.fillStyle = "#7A102B";
    ctx.fillText(livesText, livesX, livesY + 20);

    // Bottom-center: Instructions (multi-line)
    ctx.font = BODY_FONT;
    const lines = [];
    if (gameState === "playing") {
      lines.push(`Question: ${targetQuestion.a} ${targetQuestion.type} ${targetQuestion.b} = ?`);
      lines.push("Fly your drone (arrow keys) and collect the correct numbered balloon. Space picks up too.");
    } else if (gameState === "start") {
      lines.push("Welcome! Help your friendly drone collect the correct numbers.");
      lines.push("Collect 10 correct balloons to win. 3 wrong picks and it's game over.");
      lines.push("Press Space or Enter to begin.");
    } else if (gameState === "won") {
      lines.push("You Win! The drone fleet celebrates!");
      lines.push("Press R or click Restart to play again.");
    } else if (gameState === "lost") {
      lines.push("Game Over. The drone needs practice.");
      lines.push("Press R or click Restart to try again.");
    }
    // measure max width
    let maxW = 0;
    for (const l of lines) {
      const m = ctx.measureText(l).width;
      if (m > maxW) maxW = m;
    }
    const boxW = maxW + 24;
    const boxH = lines.length * 20 + 20;
    const boxX = (WIDTH - boxW) / 2;
    const boxY = HEIGHT - boxH - PADDING;
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    roundRectFill(boxX, boxY, boxW, boxH, 10);
    ctx.fillStyle = "#0A3A55";
    for (let i = 0; i < lines.length; i++) {
      ctx.fillText(lines[i], boxX + 12, boxY + 20 + i * 20);
    }

    // If game over or win, draw restart button just above instructions
    if (gameState === "won" || gameState === "lost") {
      const btnText = "Restart";
      ctx.font = "18px system-ui, sans-serif";
      const bW = ctx.measureText(btnText).width + 30;
      const bH = 36;
      const bX = (WIDTH - bW) / 2;
      const bY = boxY - bH - 12;
      ctx.fillStyle = "#FFFFFF";
      roundRectFill(bX, bY, bW, bH, 8);
      ctx.fillStyle = "#07405F";
      ctx.fillText(btnText, bX + 15, bY + 24);
      // store button bounds for click detection
      canvas.restartButton = { x: bX, y: bY, w: bW, h: bH };
    } else {
      canvas.restartButton = null;
    }
  }

  function roundRectFill(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  // Draw player drone
  function drawPlayer(dt) {
    if (!player) return;
    player.wobble += dt * 8;
    // draw shadow
    ctx.fillStyle = "rgba(0,0,0,0.08)";
    ctx.beginPath();
    ctx.ellipse(player.x, player.y + player.r + 10, player.r * 1.1, player.r * 0.5, 0, 0, Math.PI * 2);
    ctx.fill();

    // body
    ctx.fillStyle = player.color;
    ctx.beginPath();
    ctx.ellipse(player.x, player.y, player.r * 1.2, player.r, 0, 0, Math.PI * 2);
    ctx.fill();

    // highlight
    ctx.fillStyle = "rgba(255,255,255,0.3)";
    ctx.beginPath();
    ctx.ellipse(player.x - 6, player.y - 6, player.r * 0.45, player.r * 0.3, 0, 0, Math.PI * 2);
    ctx.fill();

    // propellers (wacky)
    ctx.save();
    ctx.translate(player.x, player.y - player.r * 0.9);
    for (let i = -1; i <= 1; i += 2) {
      ctx.save();
      ctx.rotate(Math.sin(player.wobble + i) * 0.8);
      ctx.fillStyle = "rgba(30,30,40,0.6)";
      ctx.fillRect(i * (player.r + 4), -4, 28, 8);
      ctx.restore();
    }
    ctx.restore();

    // simple face
    ctx.fillStyle = "#052A3B";
    ctx.beginPath();
    ctx.arc(player.x - 6, player.y - 2, 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(player.x + 6, player.y - 2, 2, 0, Math.PI * 2);
    ctx.fill();
    // mouth
    ctx.strokeStyle = "#052A3B";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(player.x, player.y + 4, 4, 0, Math.PI);
    ctx.stroke();
  }

  // Draw balloons (numbers to collect)
  function drawBalloons(dt) {
    ctx.font = "18px system-ui, sans-serif";
    balloons.forEach((b) => {
      // movement
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      b.wobble += dt * 3;
      // bounce from edges
      if (b.x < b.r + 6) {
        b.x = b.r + 6;
        b.vx *= -1;
      } else if (b.x > WIDTH - b.r - 6) {
        b.x = WIDTH - b.r - 6;
        b.vx *= -1;
      }
      if (b.y < b.r + 50) {
        b.y = b.r + 50;
        b.vy *= -1;
      } else if (b.y > HEIGHT - BOTTOM_INSTRUCTIONS_HEIGHT - b.r - 6) {
        b.y = HEIGHT - BOTTOM_INSTRUCTIONS_HEIGHT - b.r - 6;
        b.vy *= -1;
      }
      // tether line
      ctx.strokeStyle = "rgba(60,80,90,0.18)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(b.x, b.y + 18);
      ctx.lineTo(b.x, b.y + 38);
      ctx.stroke();

      // balloon body
      ctx.fillStyle = b.color;
      ctx.beginPath();
      ctx.ellipse(b.x, b.y, b.r, b.r * 1.05, Math.sin(b.wobble) * 0.2, 0, Math.PI * 2);
      ctx.fill();

      // number text background for readability
      const text = String(b.value);
      const metrics = ctx.measureText(text);
      const textW = metrics.width;
      const textH = 18;
      ctx.fillStyle = "rgba(255,255,255,0.65)";
      roundRectFill(b.x - textW / 2 - 8, b.y - textH / 2 - 6, textW + 16, textH + 10, 6);

      // number
      ctx.fillStyle = "#053241";
      ctx.fillText(text, b.x - textW / 2, b.y + 6);
    });
  }

  // Update player position based on keys
  function updatePlayer(dt) {
    if (!player) return;
    let dx = 0,
      dy = 0;
    if (keys.ArrowLeft) dx -= 1;
    if (keys.ArrowRight) dx += 1;
    if (keys.ArrowUp) dy -= 1;
    if (keys.ArrowDown) dy += 1;
    // Normalize
    if (dx !== 0 || dy !== 0) {
      const len = Math.sqrt(dx * dx + dy * dy);
      dx /= len;
      dy /= len;
      player.x += dx * player.speed * dt;
      player.y += dy * player.speed * dt;
      player.x = clamp(player.x, player.r + 8, WIDTH - player.r - 8);
      player.y = clamp(player.y, player.r + 50, HEIGHT - BOTTOM_INSTRUCTIONS_HEIGHT - player.r - 8);
    }
  }

  // Collision detection for collecting balloons
  function checkCollisions() {
    if (!player) return;
    for (let i = balloons.length - 1; i >= 0; i--) {
      const b = balloons[i];
      const dx = player.x - b.x;
      const dy = player.y - b.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < player.r + b.r - 6) {
        // auto-pickup upon touch OR when pressing space near balloon
        // We'll consider immediate pickup on touch for younger players (accessible)
        collectBalloon(i);
      }
    }
  }

  function collectBalloon(index) {
    const b = balloons[index];
    if (!b) return;
    const correct = b.value === targetQuestion.answer;
    // pop animation: remove balloon
    balloons.splice(index, 1);
    if (correct) {
      score += 1;
      playCorrectSound();
      // small celebratory particle or wobble (visual only)
      showAudioStatusFlash = 5;
      if (score >= TARGET_SCORE) {
        endGame(true);
        return;
      } else {
        // spawn next question after small delay
        setTimeout(spawnQuestion, 500);
      }
    } else {
      wrongs += 1;
      playWrongSound();
      showAudioStatusFlash = 5;
      if (wrongs >= MAX_WRONG) {
        endGame(false);
        return;
      } else {
        setTimeout(spawnQuestion, 500);
      }
    }
  }

  function endGame(won) {
    running = false;
    gameState = won ? "won" : "lost";
    // stop background audio if any - we only used oscillators
    // show accessibility hint via canvas title
    canvas.setAttribute("aria-label", won ? "You won! Press R to restart." : "Game over. Press R to restart.");
  }

  // Start a new game
  function startGame() {
    score = 0;
    wrongs = 0;
    resetPlayer();
    spawnQuestion();
    gameState = "playing";
    running = true;
    lastTime = performance.now();
    requestAnimationFrame(loop);
  }

  // Main loop
  function loop(now) {
    if (!lastTime) lastTime = now;
    const dt = (now - lastTime) / 1000;
    lastTime = now;
    elapsed += dt;

    // Update showAudioStatusFlash timer
    if (showAudioStatusFlash > 0) showAudioStatusFlash -= dt;

    // Update and draw
    drawBackground(dt);
    updatePlayer(dt);
    drawBalloons(dt);
    drawPlayer(dt);

    // UI AFTER drawing game elements to ensure readability
    drawUI();

    if (running) {
      checkCollisions();
      requestAnimationFrame(loop);
    }
  }

  // Input handlers
  canvas.addEventListener("keydown", (e) => {
    if (e.key in keys) {
      keys[e.key] = true;
      e.preventDefault();
    } else if (e.key === " " || e.key === "Spacebar") {
      // space can also be used to start game or pick up near balloons
      e.preventDefault();
      if (gameState === "start") {
        startGame();
      } else if (gameState === "playing") {
        // pick-up: check for nearest balloon within small radius
        let nearest = -1;
        let minDist = Infinity;
        for (let i = 0; i < balloons.length; i++) {
          const b = balloons[i];
          const dx = player.x - b.x;
          const dy = player.y - b.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < minDist) {
            minDist = dist;
            nearest = i;
          }
        }
        if (nearest !== -1 && minDist < player.r + balloons[nearest].r + 8) {
          collectBalloon(nearest);
        }
      } else if (gameState === "won" || gameState === "lost") {
        restartGame();
      }
    } else if (e.key === "Enter") {
      if (gameState === "start") startGame();
    } else if (e.key === "r" || e.key === "R") {
      restartGame();
    } else if (e.key.toLowerCase() === "m") {
      // toggle audio with M
      toggleAudio();
    }
  });

  canvas.addEventListener("keyup", (e) => {
    if (e.key in keys) {
      keys[e.key] = false;
      e.preventDefault();
    }
  });

  // Focus canvas to receive keyboard
  canvas.addEventListener("focus", () => {
    // nothing needed, but keep accessibility cue visible
  });

  // Pointer controls for moving (also support clicking restart)
  let pointerActive = false;
  canvas.addEventListener("pointerdown", (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    // Check restart button
    if (canvas.restartButton) {
      const b = canvas.restartButton;
      if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
        restartGame();
        return;
      }
    }
    // Check audio toggle area (top-center)
    ctx.font = BODY_FONT;
    const audioText = audioEnabled ? "ðŸ”Š Audio: On" : "ðŸ”ˆ Audio: Off";
    const audioW = ctx.measureText(audioText).width;
    const audioX = (WIDTH - audioW) / 2;
    const audioY = PADDING;
    if (y >= audioY - 6 && y <= audioY + 28 && x >= audioX - 6 && x <= audioX + audioW + 6) {
      toggleAudio();
      return;
    }
    // Move player toward pointer while pointer active
    pointerActive = true;
    movePlayerTo(x, y);
  });

  canvas.addEventListener("pointermove", (e) => {
    if (!pointerActive) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    movePlayerTo(x, y);
  });

  canvas.addEventListener("pointerup", () => {
    pointerActive = false;
  });

  canvas.addEventListener("click", (e) => {
    // If clicking on a balloon near player, treat as pickup
    if (gameState !== "playing") return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    // find clicked balloon
    for (let i = 0; i < balloons.length; i++) {
      const b = balloons[i];
      const dx = x - b.x;
      const dy = y - b.y;
      if (Math.sqrt(dx * dx + dy * dy) <= b.r + 6) {
        // if player close enough, collect; otherwise move player toward it
        const pdx = player.x - b.x;
        const pdy = player.y - b.y;
        if (Math.sqrt(pdx * pdx + pdy * pdy) < 120) {
          collectBalloon(i);
        } else {
          // move player toward clicked balloon immediately
          movePlayerTo(b.x, b.y);
        }
        break;
      }
    }
  });

  function movePlayerTo(x, y) {
    if (!player) return;
    // teleport a bit towards pointer for touch accessibility: smooth small move
    const dx = x - player.x;
    const dy = y - player.y;
    const len = Math.sqrt(dx * dx + dy * dy);
    if (len < 1) return;
    const step = Math.min(60, len);
    player.x += (dx / len) * step;
    player.y += (dy / len) * step;
    player.x = clamp(player.x, player.r + 8, WIDTH - player.r - 8);
    player.y = clamp(player.y, player.r + 50, HEIGHT - BOTTOM_INSTRUCTIONS_HEIGHT - player.r - 8);
  }

  // Toggle audio on/off
  function toggleAudio() {
    if (!audioContext) {
      audioEnabled = false;
      showAudioStatusFlash = 5;
      return;
    }
    audioEnabled = !audioEnabled;
    showAudioStatusFlash = 5;
    canvas.setAttribute("aria-label", audioEnabled ? "Audio enabled" : "Audio disabled");
  }

  // Restart game (reset state)
  function restartGame() {
    score = 0;
    wrongs = 0;
    resetPlayer();
    spawnQuestion();
    gameState = "playing";
    running = true;
    lastTime = performance.now();
    requestAnimationFrame(loop);
  }

  // Initial draw for start screen
  function initialDraw() {
    // background
    drawBackground(0.016);
    // big friendly drone floating center-left
    resetPlayer();
    player.x = WIDTH / 3;
    player.y = HEIGHT / 2 - 20;
    drawPlayer(0.016);
    // a couple of decorative balloons
    balloons = [
      { x: WIDTH * 0.62, y: HEIGHT * 0.33, r: 22, vx: 0, vy: 0, value: 7, wobble: 0, color: pastelColor(1) },
      { x: WIDTH * 0.75, y: HEIGHT * 0.45, r: 22, vx: 0, vy: 0, value: 3, wobble: 0, color: pastelColor(2) }
    ];
    drawBalloons(0.016);

    // Title and instructions
    ctx.font = IMPORTANT_FONT;
    ctx.fillStyle = "#073146";
    const title = "Drone Math Collector";
    const titleW = ctx.measureText(title).width;
    ctx.fillText(title, (WIDTH - titleW) / 2, 80);

    // Description box bottom
    ctx.font = BODY_FONT;
    const lines = [
      "Welcome! Help your friendly drone collect the correct numbers to solve math questions.",
      `Collect ${TARGET_SCORE} correct balloons to win. ${MAX_WRONG} wrong picks and it's game over.`,
      "Use arrow keys to fly, or tap/click. Press Space to start.",
      "Press M to toggle audio."
    ];
    let maxW = 0;
    for (const l of lines) {
      const m = ctx.measureText(l).width;
      if (m > maxW) maxW = m;
    }
    const w = maxW + 24;
    const h = lines.length * 20 + 20;
    const x = (WIDTH - w) / 2;
    const y = HEIGHT - h - PADDING;
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    roundRectFill(x, y, w, h, 10);
    ctx.fillStyle = "#073146";
    for (let i = 0; i < lines.length; i++) {
      ctx.fillText(lines[i], x + 12, y + 18 + i * 20);
    }

    // Draw UI elements on top
    drawUI();
  }

  // Kick off initial screen
  initialDraw();

  // Set focus to canvas for keyboard
  canvas.focus();

  // Accessibility: inform if audio unavailable
  if (!audioContext) {
    canvas.setAttribute("aria-label", "Audio unavailable in this browser. Use M to toggle (disabled).");
  }

  // Protect against page unload without stopping audio etc.
  window.addEventListener("blur", () => {
    // pause active state
    // nothing heavy to do; audio oscillators are short-lived
  });
})();
---

