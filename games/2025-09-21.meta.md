# Game of the Day - 2025-09-21

## Metadata
- **Generated Date:** 2025-09-21
- **Generated Time:** 2025-09-21T00:28:36.647382
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-21.js
- **File Size:** 27514 bytes
- **Tokens Used:** 9229

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-21.js` - The playable game
- `2025-09-21.meta.json` - Machine-readable metadata
- `2025-09-21.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 18913

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 21068

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Machines Math Game — JavaScript (renders inside #game-of-the-day-stage)
// Note: This script creates a 720x480 canvas, Web Audio sounds, and a playable math game.
// It uses only Canvas and Web Audio API. No external assets.
// Accessible: keyboard controls, aria-live updates, visual cues, and error handling.

// Immediately-invoked function to avoid leaking globals
(function () {
  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const MAX_LEVEL = 6;
  const SLOT_BASE = 2; // starting number of slots (numbers needed)
  const CONTAINER_ID = "game-of-the-day-stage";
  const COLORS = {
    bg: "#E8F5F2",
    machine: "#C7E5E0",
    accent: "#7FB8A4",
    gear: "#F6D1A3",
    gear2: "#D8B4E2",
    text: "#1F2933",
    correct: "#3AB795",
    incorrect: "#FF6B6B",
    slot: "#F3F6F8",
    focus: "#FFD97A",
    muted: "#AAA",
  };

  // Helper: safe DOM retrieval
  const container = document.getElementById(CONTAINER_ID);
  if (!container) {
    console.error(`Container element with id "${CONTAINER_ID}" not found.`);
    return;
  }

  // Create ARIA live region for screen readers (inside container)
  const ariaLive = document.createElement("div");
  ariaLive.setAttribute("aria-live", "polite");
  ariaLive.setAttribute("role", "status");
  ariaLive.style.position = "absolute";
  ariaLive.style.left = "-9999px";
  ariaLive.style.width = "1px";
  ariaLive.style.height = "1px";
  ariaLive.style.overflow = "hidden";
  container.appendChild(ariaLive);

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.tabIndex = 0; // allow keyboard focus
  canvas.style.width = WIDTH + "px";
  canvas.style.height = HEIGHT + "px";
  canvas.style.outline = "none";
  canvas.setAttribute("role", "application");
  canvas.setAttribute("aria-label", "Machines Math Game. Use arrow keys to move, space to pick, M to mute.");
  container.style.position = "relative";
  container.appendChild(canvas);

  const ctx = canvas.getContext("2d");
  // Crisp rendering for high DPI displays
  (function adjustForHiDPI() {
    const dpr = window.devicePixelRatio || 1;
    if (dpr !== 1) {
      canvas.width = WIDTH * dpr;
      canvas.height = HEIGHT * dpr;
      canvas.style.width = WIDTH + "px";
      canvas.style.height = HEIGHT + "px";
      ctx.scale(dpr, dpr);
    }
  })();

  // Audio: Web Audio API setup with error handling
  let audioCtx = null;
  let bgGain = null;
  let bgOsc = null;
  let audioAllowed = false;
  let muted = false;

  function createAudioContextOnUserGesture() {
    if (audioCtx || !window.AudioContext) return;
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      // gentle background drone
      bgGain = audioCtx.createGain();
      bgGain.gain.value = 0.02; // very gentle
      const masterGain = audioCtx.createGain();
      masterGain.gain.value = 1;
      bgGain.connect(masterGain);
      masterGain.connect(audioCtx.destination);

      bgOsc = audioCtx.createOscillator();
      bgOsc.type = "sine";
      bgOsc.frequency.value = 90; // low hum
      // add lowpass for gentle feel
      const lp = audioCtx.createBiquadFilter();
      lp.type = "lowpass";
      lp.frequency.value = 600;
      bgOsc.connect(lp);
      lp.connect(bgGain);
      bgOsc.start();

      // ensure muted respects older state
      updateAudioMuteState();
      audioAllowed = true;
    } catch (e) {
      console.error("Web Audio API error:", e);
      audioAllowed = false;
      audioCtx = null;
    }
  }

  function safePlayTone({ freq = 440, duration = 0.25, type = "sine", volume = 0.2, decay = 0.02 }) {
    if (!audioAllowed || muted || !audioCtx) return;
    try {
      const o = audioCtx.createOscillator();
      o.type = type;
      o.frequency.value = freq;
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(volume, audioCtx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration + decay);
      o.connect(g);
      g.connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime + duration + decay);
    } catch (e) {
      console.error("Tone play error:", e);
    }
  }

  function playCorrect() {
    if (!audioAllowed || muted || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const freqs = [880, 1100, 1320];
      freqs.forEach((f, i) => {
        const o = audioCtx.createOscillator();
        o.type = "sine";
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0.18 / (i + 1), now);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.4 + i * 0.02);
        o.frequency.value = f;
        o.connect(g);
        g.connect(audioCtx.destination);
        o.start(now + i * 0.02);
        o.stop(now + 0.4 + i * 0.02);
      });
    } catch (e) {
      console.error("playCorrect error:", e);
    }
  }

  function playIncorrect() {
    safePlayTone({ freq: 200, duration: 0.28, type: "sawtooth", volume: 0.28 });
    // short buzz
    setTimeout(() => safePlayTone({ freq: 160, duration: 0.18, type: "sawtooth", volume: 0.18 }), 120);
  }

  function playClick() {
    safePlayTone({ freq: 660, duration: 0.08, type: "triangle", volume: 0.09 });
  }

  function updateAudioMuteState() {
    if (!audioCtx) return;
    if (bgGain) bgGain.gain.value = muted ? 0 : 0.02;
  }

  // Game state
  let level = 1;
  let gears = []; // {value, x,y,r, picked}
  let slots = []; // {x,y,w,h, value (null if empty)}
  let requiredSlots = SLOT_BASE; // number of numbers to place
  let target = 0;
  let selectedGearIndex = null; // index in gears currently "holding" (picked up)
  let focusIndex = 0; // for keyboard: focus among interactable items (gears then slots)
  let attemptsLeft = 3;
  let solvedCount = 0;
  let playing = true;
  let message = "Click a gear and put it in the machine to match the target!";
  let showCelebration = false;

  // Accessibility announcement helper
  function announce(text) {
    ariaLive.textContent = text;
  }

  // Generate a level ensuring solvable combination
  function generateLevel(lv) {
    requiredSlots = Math.min(4, SLOT_BASE + Math.floor((lv - 1) / 2)); // increases occasionally
    attemptsLeft = 3;
    selectedGearIndex = null;
    focusIndex = 0;
    showCelebration = false;
    // Create some base numbers
    const poolSize = Math.min(7, requiredSlots + 3);
    let base = [];
    for (let i = 0; i < poolSize; i++) {
      base.push(Math.floor(Math.random() * Math.min(10 + lv * 2, 20)) + 1);
    }
    // To ensure solvable, pick requiredSlots numbers to sum as the target
    const chosenIndices = [];
    while (chosenIndices.length < requiredSlots) {
      const idx = Math.floor(Math.random() * base.length);
      if (!chosenIndices.includes(idx)) chosenIndices.push(idx);
    }
    target = chosenIndices.reduce((s, idx) => s + base[idx], 0);

    // Add or replace with small variations for difficulty as levels rise
    if (lv >= 3) {
      // ensure at least one small number
      base.push(1 + Math.floor(Math.random() * Math.min(8, lv + 2)));
    }
    // Shuffle base
    base = shuffleArray(base);

    // Build gears from base
    gears = [];
    const trayX = 80;
    const trayY = 340;
    const spacing = 80;
    for (let i = 0; i < base.length; i++) {
      const gx = trayX + (i % 7) * spacing;
      const gy = trayY + Math.floor(i / 7) * 70;
      gears.push({
        value: base[i],
        x: gx,
        y: gy,
        r: 28,
        picked: false,
        id: i,
      });
    }

    // Create slots (machine inputs)
    slots = [];
    const slotW = 74;
    const slotH = 54;
    const machineCenterX = 440;
    const machineTopY = 160;
    const slotGap = 12;
    const totalW = requiredSlots * slotW + (requiredSlots - 1) * slotGap;
    const startX = machineCenterX - totalW / 2;
    for (let i = 0; i < requiredSlots; i++) {
      slots.push({
        x: startX + i * (slotW + slotGap),
        y: machineTopY + 68,
        w: slotW,
        h: slotH,
        value: null,
      });
    }

    message = `Level ${lv}: Put ${requiredSlots} numbers into the machine to make ${target}.`;
    announce(message);
  }

  function shuffleArray(arr) {
    const copy = arr.slice();
    for (let i = copy.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [copy[i], copy[j]] = [copy[j], copy[i]];
    }
    return copy;
  }

  // Input handling
  let lastMousePos = { x: 0, y: 0 };

  canvas.addEventListener("mousedown", (e) => {
    canvas.focus();
    createAudioContextOnUserGesture(); // enable audio on first interaction
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    lastMousePos = { x, y };
    handleClick(x, y);
  });

  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    lastMousePos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
  });

  // Keyboard controls
  // Left/Right to move focus among gears and slots. Up/Down to jump between tray and slots.
  // Space or Enter to pick/place. M to mute.
  canvas.addEventListener("keydown", (e) => {
    const totalInteractables = gears.length + slots.length;
    if (!playing) {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        restartGame();
      }
      return;
    }
    if (e.key === "m" || e.key === "M") {
      e.preventDefault();
      muted = !muted;
      updateAudioMuteState();
      announce(muted ? "Muted" : "Sound on");
      return;
    }
    if (e.key === "ArrowRight") {
      e.preventDefault();
      focusIndex = (focusIndex + 1) % (gears.length + slots.length);
      playClick();
    } else if (e.key === "ArrowLeft") {
      e.preventDefault();
      focusIndex = (focusIndex - 1 + gears.length + slots.length) % (gears.length + slots.length);
      playClick();
    } else if (e.key === "ArrowUp" || e.key === "ArrowDown") {
      e.preventDefault();
      // If focus is in gears area go to slots or vice versa
      if (focusIndex < gears.length) {
        // move to a corresponding slot or first slot
        focusIndex = gears.length + Math.min(0, slots.length - 1);
      } else {
        focusIndex = 0;
      }
      playClick();
    } else if (e.key === " " || e.key === "Enter") {
      e.preventDefault();
      // Activate the focused item
      if (focusIndex < gears.length) {
        const gIdx = focusIndex;
        pickGearByIndex(gIdx);
      } else {
        const sIdx = focusIndex - gears.length;
        placeToSlot(sIdx);
      }
    } else if (/^\d$/.test(e.key)) {
      // Press number to quickly pick gear by displayed index (1-based shown on canvas)
      const num = parseInt(e.key, 10);
      if (num >= 1 && num <= gears.length) {
        pickGearByIndex(num - 1);
      }
    }
  });

  // Click handling logic
  function handleClick(x, y) {
    // Check gears first
    for (let i = 0; i < gears.length; i++) {
      const g = gears[i];
      if (pointInCircle(x, y, g.x, g.y, g.r + 6)) {
        pickGearByIndex(i);
        return;
      }
    }
    // Check slots
    for (let i = 0; i < slots.length; i++) {
      const s = slots[i];
      if (pointInRect(x, y, s.x, s.y, s.w, s.h)) {
        placeToSlot(i);
        return;
      }
    }
    // Click elsewhere: if holding a gear, drop it back to tray
    if (selectedGearIndex !== null) {
      // return gear
      gears[selectedGearIndex].picked = false;
      selectedGearIndex = null;
      playClick();
      announce("Returned gear to tray.");
    }
  }

  // Helpers
  function pointInCircle(px, py, cx, cy, r) {
    const dx = px - cx;
    const dy = py - cy;
    return dx * dx + dy * dy <= r * r;
  }
  function pointInRect(px, py, rx, ry, rw, rh) {
    return px >= rx && px <= rx + rw && py >= ry && py <= ry + rh;
  }

  function pickGearByIndex(index) {
    if (index < 0 || index >= gears.length) return;
    createAudioContextOnUserGesture();
    const gear = gears[index];
    if (gear.picked) {
      // if already picked, unpick
      gear.picked = false;
      selectedGearIndex = null;
      playClick();
      announce(`Returned ${gear.value} to tray.`);
    } else {
      // pick it
      // cannot pick if it's already placed in a slot
      if (isGearInSlot(index)) {
        // find and remove from slot
        removeGearFromSlots(index);
        gear.picked = true;
        selectedGearIndex = index;
        playClick();
        announce(`Picked ${gear.value} from machine.`);
      } else {
        gear.picked = true;
        selectedGearIndex = index;
        playClick();
        announce(`Picked ${gear.value}. Click a slot to place it in the machine.`);
      }
    }
  }

  function isGearInSlot(gearIndex) {
    return slots.some((s) => s.value === gearIndex);
  }

  function removeGearFromSlots(gearIndex) {
    for (const s of slots) {
      if (s.value === gearIndex) {
        s.value = null;
        return true;
      }
    }
    return false;
  }

  function placeToSlot(slotIdx) {
    createAudioContextOnUserGesture();
    if (slotIdx < 0 || slotIdx >= slots.length) return;
    const slot = slots[slotIdx];
    if (selectedGearIndex === null) {
      // if none selected, maybe pick gear currently in slot
      if (slot.value !== null) {
        const gIdx = slot.value;
        slot.value = null;
        // pick gear
        gears[gIdx].picked = true;
        selectedGearIndex = gIdx;
        playClick();
        announce(`Lifted ${gears[gIdx].value} from slot ${slotIdx + 1}.`);
      } else {
        // nothing happens
        playClick();
      }
      return;
    } else {
      // place the picked gear into the slot (if slot is empty)
      if (slot.value !== null) {
        // swap: put existing gear back to tray and place new one
        const existing = slot.value;
        // existing goes back to tray
        slots[slotIdx].value = selectedGearIndex;
        gears[selectedGearIndex].picked = false;
        // pick up existing gear instead
        gears[existing].picked = true;
        selectedGearIndex = existing;
        playClick();
        announce(`Swapped ${gears[existing].value} with ${gears[slots[slotIdx].value].value}.`);
      } else {
        slots[slotIdx].value = selectedGearIndex;
        gears[selectedGearIndex].picked = false;
        const placedVal = gears[selectedGearIndex].value;
        selectedGearIndex = null;
        playClick();
        announce(`Placed ${placedVal} into slot ${slotIdx + 1}.`);
      }
    }
    // After placing, check machine if full
    checkMachine();
  }

  function checkMachine() {
    // Check if all slots are filled
    if (slots.some((s) => s.value === null)) {
      return;
    }
    // Calculate sum of values in slots
    const sum = slots.reduce((s, sl) => s + gears[sl.value].value, 0);
    if (sum === target) {
      // success
      playCorrect();
      message = "Perfect! The machine whirs happily — you solved it!";
      announce(`Correct! You solved level ${level}.`);
      solvedCount++;
      showCelebration = true;
      // progress to next level after short delay
      setTimeout(() => {
        if (level >= MAX_LEVEL) {
          // game finished
          playing = false;
          message = `Amazing! You completed all levels! Press Enter to play again.`;
          announce("All levels completed. Congratulations!");
        } else {
          level++;
          generateLevel(level);
        }
        requestRender();
      }, 900);
    } else {
      // incorrect
      playIncorrect();
      attemptsLeft--;
      const hint = generateHint(sum, target);
      message = `Almost — machine output ${sum}. ${hint} Attempts left: ${attemptsLeft}`;
      announce(`Incorrect. Machine output ${sum}.` + (attemptsLeft > 0 ? ` ${attemptsLeft} attempts left.` : " No attempts left."));
      // shake animation or visual cue handled in render
      if (attemptsLeft <= 0) {
        // level failed: reveal solution and move to next or reset
        message = `Oh no — out of attempts. The machine resets. The target was ${target}.`;
        announce(`Out of attempts. The target was ${target}.`);
        setTimeout(() => {
          if (level > 1) {
            level = Math.max(1, level - 1); // gentle rollback
          }
          generateLevel(level);
        }, 1200);
      } else {
        // clear one random slot to give chance
        const filledSlots = slots.map((s, i) => (s.value !== null ? i : -1)).filter((i) => i !== -1);
        if (filledSlots.length > 0) {
          const idxToClear = filledSlots[Math.floor(Math.random() * filledSlots.length)];
          const gearIdx = slots[idxToClear].value;
          slots[idxToClear].value = null;
          gears[gearIdx].picked = false;
          announce(`One number was ejected from slot ${idxToClear + 1}.`);
        }
      }
    }
  }

  function generateHint(sum, targetVal) {
    const diff = Math.abs(sum - targetVal);
    if (diff === 0) return "Perfect!";
    if (diff <= 2) return "You're very close — try a slightly different number.";
    if (diff <= 5) return "A different small number might help.";
    return "Try changing a larger number to get closer.";
  }

  // Render loop
  let lastTick = 0;
  let shakeTime = 0;

  function requestRender() {
    // schedule an immediate redraw
    draw();
  }

  function draw() {
    try {
      // Background
      ctx.clearRect(0, 0, WIDTH, HEIGHT);
      drawBackground();
      drawMachine();
      drawSlots();
      drawGears();
      drawHUD();
      drawInstructions();
      if (showCelebration) drawConfetti();
    } catch (e) {
      console.error("Draw error:", e);
    }
  }

  function drawBackground() {
    // calming gradient
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, COLORS.bg);
    g.addColorStop(1, "#F6FBF9");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // wacky pipes
    ctx.fillStyle = COLORS.machine;
    roundedRect(ctx, 360, 50, 320, 120, 20);
    ctx.fill();

    // small gears pattern top-left
    for (let i = 0; i < 6; i++) {
      drawTinyGear(40 + i * 40, 60 + ((i % 2) * 12), 10, i % 2 === 0 ? COLORS.gear : COLORS.gear2, 0.6);
    }
  }

  function drawMachine() {
    // central machine body
    ctx.save();
    ctx.translate(360, 120);
    ctx.fillStyle = COLORS.accent;
    ctx.fillRect(-200, -20, 400, 160);
    // window
    ctx.fillStyle = "#EDF7F6";
    roundedRect(ctx, 80, 10, 120, 80, 8);
    ctx.fill();
    // target display area
    ctx.fillStyle = "#FFF";
    roundedRect(ctx, 420, 30, 220, 90, 12);
    ctx.fill();

    // target text
    ctx.restore();
    // draw target box with label
    ctx.fillStyle = "#FFFFFF";
    roundedRect(ctx, 430, 38, 200, 74, 12);
    ctx.fill();
    ctx.strokeStyle = "#E0EEF1";
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.fillStyle = COLORS.text;
    ctx.font = "20px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("MATH MACHINE", 520, 75);

    // Target number big
    ctx.fillStyle = COLORS.accent;
    ctx.font = "44px sans-serif";
    ctx.fillText(String(target), 520, 110);
  }

  function drawSlots() {
    for (let i = 0; i < slots.length; i++) {
      const s = slots[i];
      ctx.fillStyle = COLORS.slot;
      roundedRect(ctx, s.x, s.y, s.w, s.h, 8);
      ctx.fill();
      ctx.strokeStyle = "#DCEFF0";
      ctx.stroke();

      // draw the index
      ctx.fillStyle = "#8AAFB0";
      ctx.font = "12px sans-serif";
      ctx.textAlign = "left";
      ctx.fillText(`slot ${i + 1}`, s.x + 6, s.y - 6);

      if (s.value !== null) {
        const g = gears[s.value];
        // draw gear inside slot (slightly larger)
        drawGear(s.x + s.w / 2, s.y + s.h / 2, 24, g.value, true, s.value === selectedGearIndex);
      } else {
        // empty placeholder
        ctx.fillStyle = "#F8FAFC";
        ctx.font = "16px sans-serif";
        ctx.textAlign = "center";
        ctx.fillStyle = "#9FBCC0";
        ctx.fillText("—", s.x + s.w / 2, s.y + s.h / 2 + 6);
      }
    }
  }

  function drawGears() {
    // tray label
    ctx.fillStyle = "#7FAFA1";
    ctx.font = "14px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText("Gear Tray", 60, 320);

    // draw each gear
    for (let i = 0; i < gears.length; i++) {
      const g = gears[i];
      let drawX = g.x;
      let drawY = g.y;
      if (g.picked && selectedGearIndex === i) {
        // follow mouse
        drawX = lastMousePos.x;
        drawY = lastMousePos.y;
      }
      drawGear(drawX, drawY, g.r, g.value, false, focusIndex === i);
      // index text near gear for keyboard number
      ctx.fillStyle = "#375455";
      ctx.font = "12px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(String(i + 1), drawX, drawY + 44);
    }
  }

  function drawHUD() {
    // attempts and level info
    ctx.fillStyle = COLORS.text;
    ctx.font = "16px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText(`Level ${level} of ${MAX_LEVEL}`, 16, 24);

    // attempts hearts
    for (let i = 0; i < 3; i++) {
      const x = 16 + i * 28;
      drawHeart(x, 36, 10, i < attemptsLeft ? COLORS.correct : "#EEE");
    }

    // mute state icon
    ctx.fillStyle = muted ? COLORS.muted : COLORS.accent;
    roundedRect(ctx, WIDTH - 110, 16, 92, 36, 8);
    ctx.fill();
    ctx.fillStyle = "#FFFFFF";
    ctx.font = "14px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(muted ? "Muted (M)" : "Sound (M)", WIDTH - 60, 40);

    // small progress
    ctx.fillStyle = "#1F2933";
    ctx.font = "14px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(`Solved: ${solvedCount}`, WIDTH - 60, 68);

    // message box bottom
    ctx.fillStyle = "#FFFFFF";
    roundedRect(ctx, 18, HEIGHT - 86, WIDTH - 36, 62, 10);
    ctx.fill();
    ctx.strokeStyle = "#E5F0EF";
    ctx.stroke();
    ctx.fillStyle = COLORS.text;
    ctx.font = "14px sans-serif";
    ctx.textAlign = "left";
    wrapText(ctx, message, 34, HEIGHT - 54, WIDTH - 68, 18);
  }

  function drawInstructions() {
    ctx.fillStyle = "#123";
    ctx.font = "12px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText("Controls: Click or use keyboard. Arrow keys to move, Space/Enter to pick/place.", 18, HEIGHT - 12);
  }

  // Draw a decorated gear (simple)
  function drawGear(cx, cy, radius, number, inSlot = false, focused = false) {
    // Teeth
    ctx.save();
    ctx.translate(cx, cy);
    ctx.beginPath();
    const teeth = 10;
    for (let i = 0; i < teeth; i++) {
      const angle = (i / teeth) * Math.PI * 2;
      const rOuter = radius + 8;
      const rInner = radius - 2;
      const px = Math.cos(angle) * rOuter;
      const py = Math.sin(angle) * rOuter;
      const ix = Math.cos(angle + 0.12) * rInner;
      const iy = Math.sin(angle + 0.12) * rInner;
      if (i === 0) ctx.moveTo(px, py);
      ctx.lineTo(px, py);
      ctx.lineTo(ix, iy);
    }
    ctx.closePath();
    ctx.fillStyle = inSlot ? COLORS.gear2 : COLORS.gear;
    ctx.fill();
    // center circle
    ctx.beginPath();
    ctx.arc(0, 0, radius - 6, 0, Math.PI * 2);
    ctx.fillStyle = inSlot ? "#FFFFFF" : "#FFF8F0";
    ctx.fill();
    ctx.strokeStyle = "#E9EFEF";
    ctx.stroke();

    // number
    ctx.fillStyle = COLORS.text;
    ctx.font = "16px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(String(number), 0, 6);

    if (focused) {
      ctx.beginPath();
      ctx.arc(0, 0, radius + 12, 0, Math.PI * 2);
      ctx.strokeStyle = COLORS.focus;
      ctx.lineWidth = 3;
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawTinyGear(x, y, r, color, alpha = 1) {
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawHeart(cx, cy, size, color) {
    ctx.save();
    ctx.fillStyle = color;
    ctx.beginPath();
    const x = cx;
    const y = cy;
    ctx.moveTo(x, y);
    ctx.bezierCurveTo(x, y - size / 2, x - size, y - size / 2, x - size, y + size / 4);
    ctx.bezierCurveTo(x - size, y + size, x, y + size * 1.3, x, y + size * 1.6);
    ctx.bezierCurveTo(x, y + size * 1.3, x + size, y + size, x + size, y + size / 4);
    ctx.bezierCurveTo(x + size, y - size / 2, x, y - size / 2, x, y);
    ctx.fill();
    ctx.restore();
  }

  function drawConfetti() {
    // simple celebratory dots near machine
    for (let i = 0; i < 30; i++) {
      const x = 420 + Math.sin(i) * 120 + (Math.random() * 40 - 20);
      const y = 120 + (i % 5) * 12 + (Math.random() * 30 - 10);
      ctx.fillStyle = i % 2 === 0 ? "#FFD97A" : "#80D4C6";
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Utilities
  function roundedRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  function wrapText(context, text, x, y, maxWidth, lineHeight) {
    const words = text.split(" ");
    let line = "";
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + " ";
      const metrics = context.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        context.fillText(line, x, y);
        line = words[n] + " ";
        y += lineHeight;
      } else {
        line = testLine;
      }
    }
    context.fillText(line, x, y);
  }

  // Game control
  function restartGame() {
    level = 1;
    solvedCount = 0;
    playing = true;
    generateLevel(level);
    announce("New game started. " + message);
    requestRender();
  }

  // Initialize
  generateLevel(level);
  draw();

  // Expose mute toggle via click on the mute area
  canvas.addEventListener("click", (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    // check mute area
    if (x >= WIDTH - 110 && x <= WIDTH - 18 && y >= 16 && y <= 52) {
      muted = !muted;
      createAudioContextOnUserGesture();
      updateAudioMuteState();
      announce(muted ? "Muted" : "Sound on");
      draw();
    }
  });

  // Handle window resize for accessibility (keep canvas fixed but re-render)
  window.addEventListener("resize", () => {
    draw();
  });

  // Add safe try/catch for audio start when user interacts with canvas
  canvas.addEventListener("pointerdown", () => {
    try {
      createAudioContextOnUserGesture();
    } catch (e) {
      console.error("Audio gesture error:", e);
    }
  });

  // Animation loop for subtle effects (e.g., moving background)
  let animFrame = null;
  function animate(t) {
    // subtle pulsing background by slightly changing ambient color
    lastTick = t;
    // reduce CPU usage by redrawing only when needed: we'll redraw each frame to keep interaction smooth
    draw();
    animFrame = requestAnimationFrame(animate);
  }
  animFrame = requestAnimationFrame(animate);

  // Clean-up when page unloads
  window.addEventListener("beforeunload", () => {
    if (audioCtx) {
      try {
        audioCtx.close();
      } catch (e) {
        // ignore
      }
    }
    if (animFrame) cancelAnimationFrame(animFrame);
  });

  // Informational console help (non-essential)
  console.info("Machines Math Game initialized. Click the canvas to interact. Use M to mute/unmute.");

})();
---

