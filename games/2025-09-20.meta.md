# Game of the Day - 2025-09-20

## Metadata
- **Generated Date:** 2025-09-20
- **Generated Time:** 2025-09-20T00:27:07.831405
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-20.js
- **File Size:** 30137 bytes
- **Tokens Used:** 9896

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-20.js` - The playable game
- `2025-09-20.meta.json` - Machine-readable metadata
- `2025-09-20.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 21746

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 25681

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Machine Math — JavaScript game for ages 7-9
// Renders inside the element with ID "game-of-the-day-stage"
// Creates a 720x480 canvas, uses Web Audio API oscillators, accessible controls, keyboard + mouse input.
// All visuals drawn with Canvas API. No external resources.

(() => {
  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const ROUNDS = 5;
  const DIAL_MIN = 0;
  const DIAL_MAX = 12; // kid-friendly range
  const FONT = "16px 'Segoe UI', Roboto, Arial, sans-serif";

  // Find container
  const container = document.getElementById("game-of-the-day-stage");
  if (!container) {
    console.error("Game container with ID 'game-of-the-day-stage' not found.");
    return;
  }

  // Clear container and create canvas
  container.innerHTML = "";
  container.style.position = "relative";

  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute("role", "img");
  canvas.setAttribute("aria-label", "Machine Math: interactive math game with dials and gears");
  container.appendChild(canvas);

  // Accessible live region (visually hidden but inside container)
  const liveRegion = document.createElement("div");
  liveRegion.setAttribute("aria-live", "polite");
  liveRegion.setAttribute("aria-atomic", "true");
  liveRegion.style.position = "absolute";
  liveRegion.style.left = "-9999px";
  liveRegion.style.width = "1px";
  liveRegion.style.height = "1px";
  container.appendChild(liveRegion);

  const ctx = canvas.getContext("2d");

  // Utility
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const randInt = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;

  // Audio Manager with error handling
  class AudioManager {
    constructor() {
      this.enabled = true;
      this.ctx = null;
      this.bgGain = null;
      this.bgOsc = null;
      this.lfo = null;
      this.muted = false;
      this.initialized = false;
      try {
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        if (!AudioCtx) throw new Error("Web Audio API not supported");
        this.ctx = new AudioCtx();
      } catch (e) {
        console.warn("Audio initialization failed:", e);
        this.enabled = false;
        this.ctx = null;
      }
    }

    async ensureInitialized() {
      if (!this.enabled || !this.ctx) return false;
      if (this.initialized) return true;
      try {
        // Resume if suspended; user gesture may be required
        if (this.ctx.state === "suspended") {
          try {
            await this.ctx.resume();
          } catch (e) {
            console.warn("AudioContext resume failed:", e);
          }
        }
        // Create gentle background hum
        this.bgOsc = this.ctx.createOscillator();
        this.bgOsc.type = "sine";
        this.bgOsc.frequency.value = 60; // low hum
        this.bgGain = this.ctx.createGain();
        this.bgGain.gain.value = 0.02; // very gentle
        // subtle filter for warmth
        const filter = this.ctx.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.value = 800;

        // LFO for slow wobble
        this.lfo = this.ctx.createOscillator();
        this.lfo.type = "sine";
        this.lfo.frequency.value = 0.08;
        const lfoGain = this.ctx.createGain();
        lfoGain.gain.value = 12;
        this.lfo.connect(lfoGain);
        lfoGain.connect(this.bgOsc.frequency);

        this.bgOsc.connect(filter);
        filter.connect(this.bgGain);
        this.bgGain.connect(this.ctx.destination);

        this.bgOsc.start();
        this.lfo.start();

        this.initialized = true;
        return true;
      } catch (e) {
        console.warn("Audio background setup failed:", e);
        this.enabled = false;
        return false;
      }
    }

    async playTone({ type = "sine", freq = 440, duration = 0.25, volume = 0.15, attack = 0.01, release = 0.1, detune = 0 }) {
      if (!this.enabled || !this.ctx) return;
      try {
        if (this.ctx.state === "suspended") {
          try {
            await this.ctx.resume();
          } catch (e) {
            // ignore
          }
        }
        const now = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        osc.detune.value = detune;
        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.linearRampToValueAtTime(volume, now + attack);
        gain.gain.linearRampToValueAtTime(0.0001, now + attack + duration + release);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start(now);
        osc.stop(now + attack + duration + release + 0.05);
      } catch (e) {
        console.warn("playTone error", e);
      }
    }

    // Correct melody: simple ascending notes
    async playCorrect() {
      if (!this.enabled) return;
      await this.ensureInitialized();
      const melody = [523, 659, 784]; // C5, E5, G5
      let t = 0;
      for (let i = 0; i < melody.length; i++) {
        setTimeout(() => this.playTone({ type: "triangle", freq: melody[i], duration: 0.18, volume: 0.12 }), t * 1000);
        t += 0.18;
      }
    }

    // Wrong: a short buzz
    async playWrong() {
      if (!this.enabled) return;
      await this.ensureInitialized();
      // Create a quick descending buzz by detune
      this.playTone({ type: "sawtooth", freq: 220, duration: 0.18, volume: 0.12, detune: 0 });
      setTimeout(() => this.playTone({ type: "sawtooth", freq: 170, duration: 0.14, volume: 0.09 }), 160);
    }

    async playClick() {
      if (!this.enabled) return;
      await this.ensureInitialized();
      this.playTone({ type: "square", freq: 880, duration: 0.06, volume: 0.06 });
    }

    async toggleMute() {
      if (!this.enabled || !this.ctx) return;
      // Toggle background gain
      if (!this.initialized) await this.ensureInitialized();
      if (!this.bgGain) return;
      if (!this.muted) {
        this.bgGain.gain.setValueAtTime(0.0001, this.ctx.currentTime);
        this.muted = true;
      } else {
        this.bgGain.gain.setValueAtTime(0.02, this.ctx.currentTime);
        this.muted = false;
      }
    }
  }

  const audio = new AudioManager();

  // Game model
  class Game {
    constructor(ctx, width, height, audio) {
      this.ctx = ctx;
      this.width = width;
      this.height = height;
      this.audio = audio;

      this.round = 0;
      this.score = 0;
      this.attempts = 0;
      this.maxAttempts = 3;
      this.state = "intro"; // intro, playing, success, finished
      this.dials = [0, 0];
      this.selectedDial = 0;
      this.operation = "+"; // "+", "-", "×"
      this.target = 0;
      this.solution = [0, 0]; // correct values
      this.timeStart = 0;
      this.hintsUsed = 0;
      this.roundsTotal = ROUNDS;
      this.gearAngle = 0;
      this.animTime = 0;
      this.audioAvailable = !!(this.audio && this.audio.enabled);

      // bind events
      this.keysDown = {};
      this.lastInputTime = Date.now();

      // pre-generate rounds
      this.roundSpecs = [];
      this.generateRounds();

      // start rendering
      this.loop = this.loop.bind(this);
      requestAnimationFrame(this.loop);
    }

    generateRounds() {
      this.roundSpecs = [];
      for (let i = 0; i < this.roundsTotal; i++) {
        const ops = ["+", "-", "×"];
        const op = ops[randInt(0, ops.length - 1)];
        let a, b;
        if (op === "+") {
          a = randInt(0, 12);
          b = randInt(0, 12);
        } else if (op === "-") {
          a = randInt(0, 12);
          b = randInt(0, a); // ensure non-negative
        } else if (op === "×") {
          // keep multiplication small
          a = randInt(0, 6);
          b = randInt(0, 6);
        }
        const target = this.computeOp(a, b, op);
        this.roundSpecs.push({ op, a, b, target });
      }
    }

    startRound(index) {
      this.round = index;
      const spec = this.roundSpecs[index];
      this.operation = spec.op;
      this.target = spec.target;
      this.solution = [spec.a, spec.b];
      // choose random starting dial values different from solution to encourage play
      this.dials = [randInt(DIAL_MIN, DIAL_MAX), randInt(DIAL_MIN, DIAL_MAX)];
      if (this.dials[0] === this.solution[0] && this.dials[1] === this.solution[1]) {
        // nudge one
        this.dials[1] = clamp(this.dials[1] + 1, DIAL_MIN, DIAL_MAX);
      }
      this.selectedDial = 0;
      this.attempts = 0;
      this.hintsUsed = 0;
      this.timeStart = performance.now();
      this.state = "playing";
      liveRegion.textContent = `Round ${index + 1} started. Target is ${this.target}. Operation ${this.operation}. Use arrow keys or click dials to adjust. Press Enter to submit.`;
      try { this.audio.playClick(); } catch (e) {}
    }

    computeOp(a, b, op) {
      if (op === "+") return a + b;
      if (op === "-") return a - b;
      return a * b;
    }

    selectDial(idx) {
      if (this.state !== "playing") return;
      this.selectedDial = idx;
      liveRegion.textContent = `Selected dial ${idx + 1}. Value ${this.dials[idx]}. Use up/down keys to change.`;
      try { this.audio.playClick(); } catch (e) {}
    }

    changeSelected(delta) {
      if (this.state !== "playing") return;
      this.dials[this.selectedDial] = clamp(this.dials[this.selectedDial] + delta, DIAL_MIN, DIAL_MAX);
      liveRegion.textContent = `Dial ${this.selectedDial + 1} is now ${this.dials[this.selectedDial]}.`;
      try { this.audio.playClick(); } catch (e) {}
    }

    submitAttempt() {
      if (this.state !== "playing") return;
      this.attempts++;
      const result = this.computeOp(this.dials[0], this.dials[1], this.operation);
      if (result === this.target) {
        // correct
        this.score++;
        this.state = "success";
        liveRegion.textContent = `Correct! Round ${this.round + 1} solved.`;
        try { this.audio.playCorrect(); } catch (e) {}
        // proceed after short delay
        setTimeout(() => {
          if (this.round + 1 < this.roundsTotal) {
            this.startRound(this.round + 1);
          } else {
            this.state = "finished";
            liveRegion.textContent = `All rounds complete! Score ${this.score} out of ${this.roundsTotal}. Press Enter to play again.`;
          }
        }, 900);
      } else {
        // wrong
        try { this.audio.playWrong(); } catch (e) {}
        liveRegion.textContent = `Not quite. You made ${result}. Try again. Attempts left ${this.maxAttempts - this.attempts}.`;
        if (this.attempts >= this.maxAttempts) {
          // reveal solution and advance
          this.state = "success";
          liveRegion.textContent = `No attempts left. The solution was ${this.solution[0]} ${this.operation} ${this.solution[1]} = ${this.target}.`;
          setTimeout(() => {
            if (this.round + 1 < this.roundsTotal) {
              this.startRound(this.round + 1);
            } else {
              this.state = "finished";
              liveRegion.textContent = `Finished. Score ${this.score} out of ${this.roundsTotal}. Press Enter to play again.`;
            }
          }, 1200);
        }
      }
    }

    useHint() {
      if (this.state !== "playing") return;
      // reveal one dial to correct value
      const which = Math.random() < 0.5 ? 0 : 1;
      this.dials[which] = this.solution[which];
      this.hintsUsed++;
      liveRegion.textContent = `Hint used: dial ${which + 1} set to ${this.dials[which]}.`;
      try { this.audio.playClick(); } catch (e) {}
    }

    restart() {
      this.score = 0;
      this.round = 0;
      this.generateRounds();
      this.startRound(0);
    }

    // Input handlers
    handleKeyDown(e) {
      if (this.state === "intro" && (e.key === "Enter" || e.key === " ")) {
        // try to initialize audio on user gesture
        this.audio.ensureInitialized().then(() => {}).catch(() => {});
        this.startRound(0);
        return e.preventDefault();
      }
      if (this.state === "finished" && (e.key === "Enter" || e.key === " ")) {
        this.restart();
        return e.preventDefault();
      }
      if (e.key === "Tab") {
        // cycle selection
        e.preventDefault();
        this.selectedDial = (this.selectedDial + 1) % this.dials.length;
        liveRegion.textContent = `Selected dial ${this.selectedDial + 1}. Value ${this.dials[this.selectedDial]}.`;
        try { this.audio.playClick(); } catch (err) {}
        return;
      }
      if (this.state !== "playing") return;
      if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Enter", " "].includes(e.key)) {
        e.preventDefault();
      }
      switch (e.key) {
        case "ArrowUp":
          this.changeSelected(+1);
          break;
        case "ArrowDown":
          this.changeSelected(-1);
          break;
        case "ArrowLeft":
          this.selectedDial = (this.selectedDial + this.dials.length - 1) % this.dials.length;
          liveRegion.textContent = `Selected dial ${this.selectedDial + 1}. Value ${this.dials[this.selectedDial]}.`;
          try { this.audio.playClick(); } catch (err) {}
          break;
        case "ArrowRight":
          this.selectedDial = (this.selectedDial + 1) % this.dials.length;
          liveRegion.textContent = `Selected dial ${this.selectedDial + 1}. Value ${this.dials[this.selectedDial]}.`;
          try { this.audio.playClick(); } catch (err) {}
          break;
        case "Enter":
        case " ":
          this.submitAttempt();
          break;
        case "h":
        case "H":
          this.useHint();
          break;
        case "m":
        case "M":
          this.audio.toggleMute();
          liveRegion.textContent = `Sound ${this.audio.muted ? "muted" : "unmuted"}.`;
          break;
        default:
          break;
      }
    }

    // Mouse interactions: click on dial or buttons
    handleMouseDown(x, y) {
      // detect dial circles
      // left dial center at (200, 280), right dial at (360, 280)
      const left = { x: 200, y: 280, r: 46 };
      const right = { x: 360, y: 280, r: 46 };
      if (this.pointInCircle(x, y, left)) {
        this.selectDial(0);
        return;
      }
      if (this.pointInCircle(x, y, right)) {
        this.selectDial(1);
        return;
      }
      // submit button area
      if (x >= 520 && x <= 660 && y >= 240 && y <= 300) {
        this.submitAttempt();
        return;
      }
      // hint button
      if (x >= 520 && x <= 660 && y >= 310 && y <= 360) {
        this.useHint();
        return;
      }
      // speaker icon area top-right
      if (x >= 660 && x <= 700 && y >= 10 && y <= 50) {
        this.audio.toggleMute();
        liveRegion.textContent = `Sound ${this.audio.muted ? "muted" : "unmuted"}.`;
        return;
      }
      // click dial arrows (small)
      // up arrow for left dial
      if (x >= 170 && x <= 230 && y >= 220 && y <= 250) {
        this.selectedDial = 0;
        this.changeSelected(+1);
        return;
      }
      if (x >= 330 && x <= 390 && y >= 220 && y <= 250) {
        this.selectedDial = 1;
        this.changeSelected(+1);
        return;
      }
      if (x >= 170 && x <= 230 && y >= 330 && y <= 360) {
        this.selectedDial = 0;
        this.changeSelected(-1);
        return;
      }
      if (x >= 330 && x <= 390 && y >= 330 && y <= 360) {
        this.selectedDial = 1;
        this.changeSelected(-1);
        return;
      }
    }

    pointInCircle(px, py, circle) {
      const dx = px - circle.x;
      const dy = py - circle.y;
      return dx * dx + dy * dy <= circle.r * circle.r;
    }

    // Drawing helpers
    drawBackground() {
      const g = this.ctx.createLinearGradient(0, 0, 0, this.height);
      g.addColorStop(0, "#eaf6ff");
      g.addColorStop(1, "#f4fbf6");
      this.ctx.fillStyle = g;
      this.ctx.fillRect(0, 0, this.width, this.height);

      // Soft polka dots (wacky machines)
      for (let i = 0; i < 6; i++) {
        this.ctx.fillStyle = `rgba(220,230,250,${0.08 + 0.02 * (i % 3)})`;
        const rx = (i * 120 + (this.animTime * 30)) % this.width;
        this.ctx.beginPath();
        this.ctx.arc(rx, 60 + (i % 2) * 40, 30 + (i % 3) * 6, 0, Math.PI * 2);
        this.ctx.fill();
      }
    }

    drawMachineFrame() {
      // base plate
      this.ctx.fillStyle = "#dde4f2";
      this.ctx.fillRect(60, 120, 600, 300);
      // rounded control box
      this.ctx.fillStyle = "#cfe3d6";
      roundRect(this.ctx, 80, 140, 560, 260, 12);
      this.ctx.fill();

      // Pipes
      this.ctx.strokeStyle = "#b7c6c9";
      this.ctx.lineWidth = 8;
      this.ctx.beginPath();
      this.ctx.moveTo(80, 240);
      this.ctx.lineTo(140, 240);
      this.ctx.lineTo(140, 200);
      this.ctx.lineTo(200, 200);
      this.ctx.stroke();

      this.ctx.beginPath();
      this.ctx.moveTo(420, 200);
      this.ctx.lineTo(500, 200);
      this.ctx.lineTo(500, 240);
      this.ctx.lineTo(660, 240);
      this.ctx.stroke();
    }

    drawGears() {
      // left gear near left pipe
      this.drawGear(160, 180, 36, 12, "#f2c94c", this.gearAngle);
      // center gear
      this.drawGear(300, 160, 48, 14, "#ff9478", -this.gearAngle * 0.8);
      // right gear small
      this.drawGear(500, 180, 30, 10, "#7bd389", this.gearAngle * 1.2);
    }

    drawGear(cx, cy, radius, teeth, color, angle) {
      const ctx = this.ctx;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(angle);
      // body
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(0, 0, radius - 6, 0, Math.PI * 2);
      ctx.fill();
      // teeth
      ctx.fillStyle = shadeColor(color, -10);
      for (let i = 0; i < teeth; i++) {
        ctx.save();
        ctx.rotate((i / teeth) * Math.PI * 2);
        ctx.beginPath();
        ctx.rect(radius - 6, -4, 10, 8);
        ctx.fill();
        ctx.restore();
      }
      // center bolt
      ctx.fillStyle = "#3b3b3b";
      ctx.beginPath();
      ctx.arc(0, 0, Math.max(6, radius * 0.18), 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    drawDials() {
      // positions
      const left = { x: 200, y: 280 };
      const right = { x: 360, y: 280 };
      [left, right].forEach((pos, idx) => {
        // outer ring
        this.ctx.save();
        this.ctx.translate(pos.x, pos.y);
        const sel = idx === this.selectedDial && this.state === "playing";
        this.ctx.beginPath();
        this.ctx.fillStyle = sel ? "#fffef2" : "#ffffff";
        this.ctx.strokeStyle = sel ? "#3b82f6" : "#c9d6db";
        this.ctx.lineWidth = sel ? 4 : 2;
        this.ctx.arc(0, 0, 46, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.stroke();
        // numbers markings
        this.ctx.fillStyle = "#4a4a4a";
        this.ctx.font = "bold 20px monospace";
        this.ctx.textAlign = "center";
        this.ctx.textBaseline = "middle";
        this.ctx.fillText(String(this.dials[idx]), 0, 0);
        // knob small circle
        this.ctx.fillStyle = "#a3b5c6";
        this.ctx.beginPath();
        this.ctx.arc(20, -20, 8, 0, Math.PI * 2);
        this.ctx.fill();

        // up arrow
        this.ctx.fillStyle = "#6b7d89";
        this.ctx.beginPath();
        this.ctx.moveTo(-30, -40);
        this.ctx.lineTo(-10, -52);
        this.ctx.lineTo(-10, -28);
        this.ctx.closePath();
        this.ctx.fill();
        // down arrow
        this.ctx.beginPath();
        this.ctx.moveTo(-30, 40);
        this.ctx.lineTo(-10, 52);
        this.ctx.lineTo(-10, 28);
        this.ctx.closePath();
        this.ctx.fill();

        // accessible text near dial
        this.ctx.restore();
      });
    }

    drawControls() {
      // Operation display
      this.ctx.fillStyle = "#232323";
      this.ctx.font = "bold 30px sans-serif";
      this.ctx.textAlign = "center";
      this.ctx.fillText(this.operation, 280, 140);

      // Target window
      this.ctx.fillStyle = "#ffffff";
      roundRect(this.ctx, 470, 120, 190, 80, 10);
      this.ctx.fillStyle = "#ddeffb";
      roundRect(this.ctx, 472, 122, 186, 76, 8);
      this.ctx.fillStyle = "#243b55";
      this.ctx.font = "bold 28px monospace";
      this.ctx.textAlign = "center";
      this.ctx.fillText("Target", 565, 145);
      this.ctx.font = "bold 34px monospace";
      this.ctx.fillStyle = "#0b2b2e";
      this.ctx.fillText(String(this.target), 565, 180);

      // Submit button
      roundRect(this.ctx, 520, 240, 140, 60, 10);
      this.ctx.fillStyle = "#96c8ff";
      roundRect(this.ctx, 522, 242, 136, 56, 8);
      this.ctx.fillStyle = "#083d77";
      this.ctx.font = "bold 18px sans-serif";
      this.ctx.textAlign = "center";
      this.ctx.fillText("Engage Machine", 590, 272);

      // Hint button
      roundRect(this.ctx, 520, 310, 140, 46, 8);
      this.ctx.fillStyle = "#fff3c7";
      roundRect(this.ctx, 522, 312, 136, 42, 6);
      this.ctx.fillStyle = "#6b4f1d";
      this.ctx.font = "bold 16px sans-serif";
      this.ctx.fillText("Hint (H)", 590, 336);

      // Speaker icon
      this.ctx.save();
      this.ctx.translate(680, 30);
      this.ctx.fillStyle = this.audio.muted ? "#9a9a9a" : "#1f6f8b";
      this.ctx.beginPath();
      this.ctx.moveTo(-18, -8);
      this.ctx.lineTo(-6, -8);
      this.ctx.lineTo(6, -16);
      this.ctx.lineTo(6, 16);
      this.ctx.lineTo(-6, 8);
      this.ctx.lineTo(-18, 8);
      this.ctx.closePath();
      this.ctx.fill();
      // sound waves
      this.ctx.strokeStyle = this.audio.muted ? "#b6b6b6" : "#1f6f8b";
      this.ctx.lineWidth = 2;
      this.ctx.beginPath();
      this.ctx.arc(12, 0, 8, -0.6, 0.6);
      this.ctx.stroke();
      this.ctx.beginPath();
      this.ctx.arc(16, 0, 12, -0.6, 0.6);
      this.ctx.stroke();
      this.ctx.restore();

      // Instructions
      this.ctx.fillStyle = "#123240";
      this.ctx.font = "14px sans-serif";
      this.ctx.textAlign = "left";
      this.ctx.fillText("Controls: Tab to switch, Arrow keys to change, Enter to submit, H for hint, M to mute.", 20, 30);

      // Round & Score
      this.ctx.fillStyle = "#0f3b3e";
      this.ctx.font = "bold 16px sans-serif";
      this.ctx.fillText(`Round ${Math.min(this.round + 1, this.roundsTotal)} / ${this.roundsTotal}`, 20, 55);
      this.ctx.fillText(`Score: ${this.score}`, 20, 75);
      this.ctx.fillText(`Attempts: ${this.attempts} / ${this.maxAttempts}`, 20, 95);
    }

    drawRobotFriend() {
      // small friendly robot to make machines wacky
      const x = 80, y = 200;
      // body
      this.ctx.fillStyle = "#fff";
      roundRect(this.ctx, x - 20, y - 50, 80, 80, 8);
      this.ctx.fillStyle = "#d8eff2";
      roundRect(this.ctx, x - 18, y - 48, 76, 76, 6);
      // eyes
      this.ctx.fillStyle = "#223";
      this.ctx.beginPath();
      this.ctx.arc(x+2, y - 10, 6, 0, Math.PI * 2);
      this.ctx.fill();
      this.ctx.beginPath();
      this.ctx.arc(x+32, y - 10, 6, 0, Math.PI * 2);
      this.ctx.fill();
      // mouth
      this.ctx.strokeStyle = "#163a45";
      this.ctx.lineWidth = 2;
      this.ctx.beginPath();
      this.ctx.arc(x+17, y+6, 12, 0.2 * Math.PI, 0.8 * Math.PI);
      this.ctx.stroke();
      // antenna
      this.ctx.strokeStyle = "#7b9ea0";
      this.ctx.lineWidth = 3;
      this.ctx.beginPath();
      this.ctx.moveTo(x+17, y - 50);
      this.ctx.lineTo(x+17, y - 70);
      this.ctx.stroke();
      this.ctx.fillStyle = "#ff6f61";
      this.ctx.beginPath();
      this.ctx.arc(x+17, y - 74, 6, 0, Math.PI * 2);
      this.ctx.fill();
    }

    drawAccessibilityInfo() {
      // Visual cues for audio (small text)
      this.ctx.fillStyle = "#2c3e50";
      this.ctx.font = "12px sans-serif";
      this.ctx.textAlign = "right";
      const audioState = this.audio.muted ? "Muted (M to unmute)" : "Sound on (M to mute)";
      this.ctx.fillText(audioState, this.width - 18, this.height - 12);

      // If audio not available, show warning
      if (!this.audio.enabled) {
        this.ctx.fillStyle = "#8b1e1e";
        this.ctx.font = "bold 14px sans-serif";
        this.ctx.textAlign = "center";
        this.ctx.fillText("Audio not available in this browser. Visual feedback enabled.", this.width / 2, this.height - 12);
      }
    }

    loop(ts) {
      this.animTime = ts / 1000;
      this.gearAngle += 0.01 + 0.003 * Math.sin(this.animTime);
      // Draw everything
      this.drawBackground();
      this.drawMachineFrame();
      this.drawGears();
      this.drawDials();
      this.drawControls();
      this.drawRobotFriend();
      this.drawAccessibilityInfo();

      // Draw state-dependent overlays
      if (this.state === "intro") {
        this.ctx.fillStyle = "rgba(20,30,40,0.75)";
        this.ctx.fillRect(60, 120, 600, 260);

        this.ctx.fillStyle = "#fff";
        this.ctx.font = "22px sans-serif";
        this.ctx.textAlign = "center";
        this.ctx.fillText("Welcome to Machine Math!", this.width / 2, 200);
        this.ctx.font = "16px sans-serif";
        this.ctx.fillText("Adjust the dials to make the machine output match the target number.", this.width / 2, 230);
        this.ctx.fillText("Operations: +, -, ×. Use keyboard or click. Press Enter to begin.", this.width / 2, 260);

      } else if (this.state === "playing") {
        // highlight selected dial visually
        const selPos = this.selectedDial === 0 ? { x: 200, y: 280 } : { x: 360, y: 280 };
        this.ctx.save();
        this.ctx.beginPath();
        this.ctx.strokeStyle = "rgba(59,130,246,0.6)";
        this.ctx.lineWidth = 4;
        this.ctx.arc(selPos.x, selPos.y, 54, 0, Math.PI * 2);
        this.ctx.stroke();
        this.ctx.restore();
      } else if (this.state === "success") {
        // quick celebratory overlay
        this.ctx.fillStyle = "rgba(255,255,255,0.7)";
        this.ctx.fillRect(120, 160, 480, 160);
        this.ctx.fillStyle = "#1a6b4f";
        this.ctx.font = "22px sans-serif";
        this.ctx.textAlign = "center";
        this.ctx.fillText("Nice work!", this.width / 2, 210);
        this.ctx.font = "18px sans-serif";
        this.ctx.fillText(`The answer was ${this.solution[0]} ${this.operation} ${this.solution[1]} = ${this.target}`, this.width / 2, 245);
      } else if (this.state === "finished") {
        this.ctx.fillStyle = "rgba(10, 20, 30, 0.85)";
        this.ctx.fillRect(80, 120, 560, 240);
        this.ctx.fillStyle = "#fff";
        this.ctx.font = "bold 28px sans-serif";
        this.ctx.textAlign = "center";
        this.ctx.fillText("All Machines Complete!", this.width / 2, 190);
        this.ctx.font = "20px sans-serif";
        this.ctx.fillText(`Final Score: ${this.score} / ${this.roundsTotal}`, this.width / 2, 230);
        this.ctx.font = "16px sans-serif";
        this.ctx.fillText("Press Enter to play again. Thanks for playing!", this.width / 2, 270);
      }

      // small floating feedback (current dial values)
      this.ctx.fillStyle = "#112b2b";
      this.ctx.font = "bold 18px monospace";
      this.ctx.textAlign = "center";
      this.ctx.fillText(`${this.dials[0]}   ${this.operation}   ${this.dials[1]} = ?`, 280, 340);

      requestAnimationFrame(this.loop);
    }
  }

  // helpers
  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  function shadeColor(hex, percent) {
    // hex as string like #rrggbb
    const c = hex.charAt(0) === "#" ? hex.substring(1) : hex;
    const num = parseInt(c, 16);
    let r = (num >> 16) + percent;
    let g = ((num >> 8) & 0x00ff) + percent;
    let b = (num & 0x0000ff) + percent;
    r = Math.max(Math.min(255, r), 0);
    g = Math.max(Math.min(255, g), 0);
    b = Math.max(Math.min(255, b), 0);
    return "#" + (r << 16 | g << 8 | b).toString(16).padStart(6, "0");
  }

  // Instantiate game
  const game = new Game(ctx, WIDTH, HEIGHT, audio);

  // Event listeners
  window.addEventListener("keydown", (e) => {
    game.handleKeyDown(e);
  });

  canvas.addEventListener("mousedown", (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = Math.round((e.clientX - rect.left) * (canvas.width / rect.width));
    const y = Math.round((e.clientY - rect.top) * (canvas.height / rect.height));
    // attempt to initialize audio on user gesture
    if (audio && audio.enabled) {
      audio.ensureInitialized().catch(() => {});
    }
    game.handleMouseDown(x, y);
  });

  // Touch support for mobile
  canvas.addEventListener("touchstart", (ev) => {
    ev.preventDefault();
    const t = ev.touches[0];
    const rect = canvas.getBoundingClientRect();
    const x = Math.round((t.clientX - rect.left) * (canvas.width / rect.width));
    const y = Math.round((t.clientY - rect.top) * (canvas.height / rect.height));
    if (audio && audio.enabled) {
      audio.ensureInitialized().catch(() => {});
    }
    game.handleMouseDown(x, y);
  }, { passive: false });

  // Start with intro live message
  liveRegion.textContent = "Welcome to Machine Math! Press Enter to begin. Use Tab to switch dials, arrow keys to change values, Enter to submit, H for hint, M to mute.";

  // Handle focus for keyboard accessibility
  canvas.setAttribute("tabindex", "0");
  canvas.style.outline = "none";
  canvas.addEventListener("focus", () => {
    liveRegion.textContent = "Canvas focused. " + liveRegion.textContent;
  });

  // Try to resume audio on first user gesture globally (best effort)
  const resumeAudioOnGesture = () => {
    if (audio && audio.enabled) {
      audio.ensureInitialized().catch(() => {});
      window.removeEventListener("pointerdown", resumeAudioOnGesture);
      window.removeEventListener("keydown", resumeAudioOnGesture);
    }
  };
  window.addEventListener("pointerdown", resumeAudioOnGesture);
  window.addEventListener("keydown", resumeAudioOnGesture);

  // Provide initial visual tidy-up
  ctx.clearRect(0, 0, WIDTH, HEIGHT);

})();
---

