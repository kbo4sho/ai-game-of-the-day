{
  "generated_date": "2025-10-25",
  "generated_timestamp": "2025-10-25T00:27:48.434161",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9864,
  "game_filename": "2025-10-25.js",
  "game_size_bytes": 27311,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function() {\n  // Drone Math Collector\n  // Renders into element with id \"game-of-the-day-stage\"\n  // Strictly uses canvas drawing and Web Audio API (no external resources).\n  // Accessible via keyboard: Arrow keys / WASD to move, 1-4 to pick answers, R to restart, Space to toggle audio.\n  'use strict';\n\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const GOAL_CORRECT = 10;\n  const MAX_WRONG = 3;\n  const PACKAGE_COUNT = 4;\n  const HEADER_HEIGHT = 64; // reserved top area for non-overlap\n  const FOOTER_HEIGHT = 100; // reserved bottom area for question/instructions\n  const UI_PADDING = 12; // min 10px required; use 12\n  const DRONE_RADIUS = 20;\n  const PACKAGE_RADIUS = 28;\n  const BG_COLOR = '#E8F6FF';\n  const FONT_BASE = '16px \"Segoe UI\", Roboto, Arial, sans-serif';\n  const FONT_LARGE = '22px \"Segoe UI\", Roboto, Arial, sans-serif';\n  const FONT_BIGGER = '28px \"Segoe UI\", Roboto, Arial, sans-serif';\n\n  // Find container\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Container with ID \"game-of-the-day-stage\" not found.');\n    return;\n  }\n\n  // Make container accessible for screen readers with a short description\n  container.setAttribute('role', 'application');\n  container.setAttribute('aria-label', 'Drone Math Collector. Move the drone to collect packages with correct answers. Use arrow keys or number keys 1 to 4. Press R to restart.');\n\n  // Clear any existing content, create canvas\n  container.innerHTML = '';\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute('width', WIDTH);\n  canvas.setAttribute('height', HEIGHT);\n  canvas.style.width = WIDTH + 'px';\n  canvas.style.height = HEIGHT + 'px';\n  canvas.style.display = 'block';\n  canvas.style.touchAction = 'none'; // avoid touch scrolling issues\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    console.error('2D canvas context not available.');\n    return;\n  }\n\n  // Audio setup with error handling\n  let AudioContextCtor = window.AudioContext || window.webkitAudioContext || null;\n  let audioCtx = null;\n  let audioAvailable = false;\n  let audioStateText = 'Audio: OFF (press Space to enable)';\n  let bgGain = null;\n  let bgOsc = null;\n\n  function initAudio() {\n    if (!AudioContextCtor) {\n      audioAvailable = false;\n      audioStateText = 'Audio not supported by browser.';\n      return;\n    }\n    try {\n      if (!audioCtx) {\n        audioCtx = new AudioContextCtor();\n      }\n      // Create gentle background hum with low volume\n      bgGain = audioCtx.createGain();\n      bgGain.gain.value = 0.02;\n      bgGain.connect(audioCtx.destination);\n\n      bgOsc = audioCtx.createOscillator();\n      bgOsc.type = 'sine';\n      bgOsc.frequency.value = 110; // low hum\n      const bgFilter = audioCtx.createBiquadFilter();\n      bgFilter.type = 'lowpass';\n      bgFilter.frequency.value = 600;\n      bgOsc.connect(bgFilter);\n      bgFilter.connect(bgGain);\n      bgOsc.start();\n\n      audioAvailable = true;\n      audioStateText = 'Audio: ON (press Space to mute)';\n    } catch (e) {\n      console.error('AudioContext creation failed:', e);\n      audioAvailable = false;\n      audioStateText = 'Audio unavailable.';\n    }\n  }\n\n  // Toggle audio on user gesture - required by some browsers\n  function toggleAudio() {\n    if (!AudioContextCtor) {\n      audioAvailable = false;\n      audioStateText = 'Audio not supported.';\n      return;\n    }\n    if (!audioCtx) {\n      try {\n        initAudio();\n      } catch (e) {\n        audioAvailable = false;\n        audioStateText = 'Audio unavailable.';\n      }\n    } else {\n      if (audioCtx.state === 'suspended') {\n        audioCtx.resume().then(() => {\n          audioAvailable = true;\n          audioStateText = 'Audio: ON (press Space to mute)';\n          startBackgroundIfNeeded();\n        }).catch((err) => {\n          console.warn('Audio resume failed:', err);\n          audioAvailable = false;\n          audioStateText = 'Audio unavailable.';\n        });\n      } else if (audioCtx.state === 'running' && bgGain) {\n        // Mute / unmute by toggling gain\n        if (bgGain.gain.value > 0.001) {\n          bgGain.gain.value = 0;\n          audioStateText = 'Audio: OFF (press Space to enable)';\n        } else {\n          bgGain.gain.value = 0.02;\n          audioStateText = 'Audio: ON (press Space to mute)';\n        }\n      }\n    }\n  }\n\n  function startBackgroundIfNeeded() {\n    if (!audioAvailable || !audioCtx) return;\n    if (!bgOsc) {\n      initAudio();\n    }\n  }\n\n  // Create short sound effects using Web Audio API\n  function playBeep(type = 'correct') {\n    if (!audioAvailable || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = type === 'correct' ? 'triangle' : 'square';\n      o.frequency.value = type === 'correct' ? 880 : 300;\n      g.gain.value = 0;\n      o.connect(g);\n      g.connect(audioCtx.destination);\n      // envelope\n      g.gain.setValueAtTime(0, now);\n      g.gain.linearRampToValueAtTime(type === 'correct' ? 0.18 : 0.14, now + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.001, now + 0.35);\n      o.start(now);\n      o.stop(now + 0.4);\n    } catch (e) {\n      console.warn('playBeep failed', e);\n      audioAvailable = false;\n      audioStateText = 'Audio error.';\n    }\n  }\n\n  function playClick() {\n    if (!audioAvailable || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = 'sawtooth';\n      o.frequency.value = 1200;\n      g.gain.value = 0;\n      o.connect(g);\n      g.connect(audioCtx.destination);\n      g.gain.setValueAtTime(0, now);\n      g.gain.linearRampToValueAtTime(0.1, now + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.001, now + 0.12);\n      o.start(now);\n      o.stop(now + 0.13);\n    } catch (e) {\n      console.warn('playClick failed', e);\n    }\n  }\n\n  // Utility functions\n  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }\n  function rand(min, max) { return Math.random() * (max - min) + min; }\n  function randInt(min, max) { return Math.floor(rand(min, max + 1)); }\n  function distance(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }\n\n  // Game state\n  let running = true;\n  let correctCount = 0;\n  let wrongCount = 0;\n  let question = null; // {text, answer}\n  let packages = []; // array of {x,y,value,isCorrect,angle,ox,oy}\n  let drone = {\n    x: WIDTH / 2,\n    y: HEADER_HEIGHT + (HEIGHT - HEADER_HEIGHT - FOOTER_HEIGHT) / 2,\n    vx: 0, vy: 0,\n    speed: 180 // pixels/sec\n  };\n  let lastTime = performance.now();\n\n  let keys = {};\n  // For touch/mouse selection highlight\n  let hoverIndex = -1;\n  let showEndScreen = false;\n  let endState = null; // 'win' or 'lose'\n\n  // Generate a math problem appropriate for ages 7-9 (simple arithmetic)\n  function generateProblem() {\n    const types = ['add', 'sub', 'mixed'];\n    const t = types[randInt(0, types.length - 1)];\n    let a, b, text, ans;\n    if (t === 'add') {\n      a = randInt(1, 15);\n      b = randInt(1, Math.max(3, 16 - a));\n      ans = a + b;\n      text = `${a} + ${b} = ?`;\n    } else if (t === 'sub') {\n      a = randInt(2, 20);\n      b = randInt(1, a - 1);\n      ans = a - b;\n      text = `${a} - ${b} = ?`;\n    } else {\n      // mixed: one add or sub but include small multiplication like *2, *3 to diversify\n      if (Math.random() < 0.6) {\n        a = randInt(2, 9);\n        b = randInt(2, 4);\n        ans = a * b;\n        text = `${a} \u00d7 ${b} = ?`;\n      } else {\n        a = randInt(1, 12);\n        b = randInt(1, 12);\n        ans = a + b;\n        text = `${a} + ${b} = ?`;\n      }\n    }\n    return { text, answer: ans };\n  }\n\n  // Create package positions ensuring they are in the play area and non-overlapping\n  function spawnPackages(correctAnswer) {\n    packages = [];\n    const attemptsMax = 1000;\n    let attempts = 0;\n    while (packages.length < PACKAGE_COUNT && attempts < attemptsMax) {\n      attempts++;\n      // spawn inside play area (below header, above footer)\n      const x = randInt(PACKAGE_RADIUS + UI_PADDING, WIDTH - PACKAGE_RADIUS - UI_PADDING);\n      const y = randInt(HEADER_HEIGHT + PACKAGE_RADIUS + UI_PADDING, HEIGHT - FOOTER_HEIGHT - PACKAGE_RADIUS - UI_PADDING);\n      // ensure not too close to drone start area\n      const pos = { x, y };\n      let ok = true;\n      if (distance(pos, drone) < DRONE_RADIUS + PACKAGE_RADIUS + 30) ok = false;\n      for (const p of packages) {\n        if (distance(pos, p) < PACKAGE_RADIUS * 2 + 12) { ok = false; break; }\n      }\n      if (!ok) continue;\n      // create tentative value: for first package we will later assign correct answer to one random slot\n      packages.push({ x, y, value: null, isCorrect: false, angle: rand(0, Math.PI * 2), ox: x, oy: y });\n    }\n    // Assign values: one correct, others distractors\n    const correctIndex = randInt(0, packages.length - 1);\n    for (let i = 0; i < packages.length; i++) {\n      if (i === correctIndex) {\n        packages[i].value = correctAnswer;\n        packages[i].isCorrect = true;\n      } else {\n        // distractor: generate a value reasonably close but not equal\n        let val = correctAnswer;\n        let tries = 0;\n        while ((val === correctAnswer || val < 0) && tries < 50) {\n          tries++;\n          const delta = randInt(-6, 6);\n          // bias to avoid too large values\n          val = correctAnswer + delta;\n          if (Math.random() < 0.2) {\n            // sometimes choose different operation result\n            val = correctAnswer + randInt(2, 7) * (Math.random() < 0.5 ? 1 : -1);\n          }\n        }\n        if (val === correctAnswer) val = correctAnswer + 5;\n        packages[i].value = val;\n        packages[i].isCorrect = false;\n      }\n    }\n  }\n\n  function startNewQuestion() {\n    question = generateProblem();\n    spawnPackages(question.answer);\n  }\n\n  // Initialize game\n  function resetGame() {\n    correctCount = 0;\n    wrongCount = 0;\n    drone.x = WIDTH / 2;\n    drone.y = HEADER_HEIGHT + (HEIGHT - HEADER_HEIGHT - FOOTER_HEIGHT) / 2;\n    drone.vx = 0;\n    drone.vy = 0;\n    keys = {};\n    showEndScreen = false;\n    endState = null;\n    startNewQuestion();\n    lastTime = performance.now();\n    startBackgroundIfNeeded();\n  }\n\n  // Collision detection: circle overlap\n  function collides(aX, aY, aR, bX, bY, bR) {\n    return (aX - bX) * (aX - bX) + (aY - bY) * (aY - bY) <= (aR + bR) * (aR + bR);\n  }\n\n  // Handling collection\n  function collectPackage(index) {\n    if (showEndScreen || !packages[index]) return;\n    const pkg = packages[index];\n    if (!pkg) return;\n    if (pkg.isCorrect) {\n      correctCount++;\n      playBeep('correct');\n      // gentle bounce visual: move drone slightly\n      drone.x = clamp(drone.x - 6, DRONE_RADIUS + UI_PADDING, WIDTH - DRONE_RADIUS - UI_PADDING);\n      // Victory check\n      if (correctCount >= GOAL_CORRECT) {\n        showEnd('win');\n        return;\n      }\n    } else {\n      wrongCount++;\n      playBeep('incorrect');\n      // small penalty push\n      drone.y = clamp(drone.y + 18, HEADER_HEIGHT + DRONE_RADIUS, HEIGHT - FOOTER_HEIGHT - DRONE_RADIUS);\n      if (wrongCount >= MAX_WRONG) {\n        showEnd('lose');\n        return;\n      }\n    }\n    // Spawn next question (reset packages after a small delay to allow sound)\n    startNewQuestion();\n  }\n\n  function showEnd(state) {\n    showEndScreen = true;\n    endState = state;\n    // Pause background audio slightly\n    if (bgGain) {\n      bgGain.gain.value = 0.005;\n    }\n    if (state === 'win') {\n      // celebratory tones\n      playBeep('correct');\n      setTimeout(() => playBeep('correct'), 120);\n    } else {\n      // consoling tone\n      playBeep('incorrect');\n    }\n  }\n\n  // Event listeners\n  window.addEventListener('keydown', (e) => {\n    if (e.key === 'r' || e.key === 'R') {\n      resetGame();\n      e.preventDefault();\n      return;\n    }\n    if (e.key === ' ' || e.code === 'Space') {\n      // Toggle audio (user gesture)\n      toggleAudio();\n      e.preventDefault();\n      return;\n    }\n    // Number keys 1-4 for quick pickup\n    if (!showEndScreen) {\n      if (['1','2','3','4'].includes(e.key)) {\n        const idx = parseInt(e.key, 10) - 1;\n        if (idx >= 0 && idx < packages.length) {\n          collectPackage(idx);\n        }\n      }\n    } else {\n      // If end screen, allow Enter to restart\n      if (e.key === 'Enter') {\n        resetGame();\n      }\n    }\n    // Movement keys\n    const movement = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D'];\n    if (movement.includes(e.key)) {\n      keys[e.key] = true;\n      e.preventDefault();\n    }\n  });\n\n  window.addEventListener('keyup', (e) => {\n    const movement = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D'];\n    if (movement.includes(e.key)) {\n      keys[e.key] = false;\n      e.preventDefault();\n    }\n  });\n\n  // Mouse interactions: clicking on a package collects it; clicking on bg toggles audio if click on audio area\n  canvas.addEventListener('pointermove', (ev) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = ev.clientX - rect.left;\n    const my = ev.clientY - rect.top;\n    hoverIndex = -1;\n    for (let i = 0; i < packages.length; i++) {\n      const p = packages[i];\n      if (collides(mx, my, 0, p.x, p.y, PACKAGE_RADIUS)) {\n        hoverIndex = i;\n        break;\n      }\n    }\n  });\n  canvas.addEventListener('pointerdown', (ev) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = ev.clientX - rect.left;\n    const my = ev.clientY - rect.top;\n\n    // Check if clicked on restart button when end screen\n    if (showEndScreen) {\n      const btn = getRestartButtonRect();\n      if (mx >= btn.x && mx <= btn.x + btn.w && my >= btn.y && my <= btn.y + btn.h) {\n        resetGame();\n        playClick();\n        return;\n      }\n    }\n\n    // Check audio toggle small icon at top-left area (we'll reserve a small square)\n    const audioBox = { x: UI_PADDING, y: HEIGHT - FOOTER_HEIGHT + 10, w: 170, h: 28 };\n    if (mx >= audioBox.x && mx <= audioBox.x + audioBox.w && my >= audioBox.y && my <= audioBox.y + audioBox.h) {\n      toggleAudio();\n      playClick();\n      return;\n    }\n\n    // Otherwise, check packages\n    for (let i = 0; i < packages.length; i++) {\n      const p = packages[i];\n      if (collides(mx, my, 0, p.x, p.y, PACKAGE_RADIUS)) {\n        collectPackage(i);\n        playClick();\n        return;\n      }\n    }\n  });\n\n  // Ensure packages don't overlap header/footer text by defining spawn area earlier.\n\n  // Drawing functions\n  function drawBackground(dt) {\n    // Calming pastel sky\n    ctx.fillStyle = BG_COLOR;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Gentle wavy layers with moving offset for calm motion\n    const t = performance.now() * 0.0002;\n    for (let i = 0; i < 3; i++) {\n      ctx.beginPath();\n      const baseY = HEADER_HEIGHT + 24 + i * 38;\n      ctx.fillStyle = i === 0 ? 'rgba(180,220,255,0.35)' : (i === 1 ? 'rgba(200,240,240,0.20)' : 'rgba(230,245,255,0.12)');\n      ctx.moveTo(0, HEIGHT);\n      for (let x = 0; x <= WIDTH; x += 20) {\n        const y = baseY + Math.sin((x * 0.02) + t * (1 + i)) * (12 + i * 6);\n        ctx.lineTo(x, y);\n      }\n      ctx.lineTo(WIDTH, HEIGHT);\n      ctx.closePath();\n      ctx.fill();\n    }\n\n    // Draw clouds (simple arcs) in top area, slightly animated\n    for (let i = 0; i < 5; i++) {\n      const cx = (i * 180 + t * 90) % (WIDTH + 120) - 60;\n      const cy = 24 + (i % 2) * 12 + Math.sin(t * 1.2 + i) * 6;\n      drawCloud(cx, cy, 34, `rgba(255,255,255,0.85)`);\n    }\n  }\n\n  function drawCloud(cx, cy, size, color) {\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.arc(cx - size * 0.6, cy, size * 0.6, 0, Math.PI * 2);\n    ctx.arc(cx, cy - size * 0.3, size * 0.8, 0, Math.PI * 2);\n    ctx.arc(cx + size * 0.6, cy, size * 0.6, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  function drawHeader() {\n    // Score top-left background\n    ctx.font = FONT_BASE;\n    const scoreText = `Correct: ${correctCount}/${GOAL_CORRECT}`;\n    const scoreMetrics = ctx.measureText(scoreText);\n    const scoreW = scoreMetrics.width + UI_PADDING * 2;\n    const scoreH = 36;\n    ctx.fillStyle = 'rgba(255,255,255,0.8)';\n    roundRect(ctx, UI_PADDING, UI_PADDING, scoreW, scoreH, 8, true, false);\n    ctx.fillStyle = '#004466';\n    ctx.font = FONT_LARGE;\n    ctx.fillText(scoreText, UI_PADDING + UI_PADDING / 2, UI_PADDING + scoreH / 2 + 7);\n\n    // Lives top-right\n    const lives = MAX_WRONG - wrongCount;\n    const livesText = `Lives: ${lives}`;\n    ctx.font = FONT_LARGE;\n    const livesW = ctx.measureText(livesText).width + UI_PADDING * 2;\n    const lx = WIDTH - livesW - UI_PADDING;\n    const ly = UI_PADDING;\n    ctx.fillStyle = 'rgba(255,255,255,0.85)';\n    roundRect(ctx, lx, ly, livesW, scoreH, 8, true, false);\n    ctx.fillStyle = '#882222';\n    ctx.fillText(livesText, lx + UI_PADDING / 2, ly + scoreH / 2 + 7);\n\n    // Audio status bottom-left in footer area (visual cue for audio)\n    ctx.font = FONT_BASE;\n    let audioText = audioStateText;\n    ctx.fillStyle = 'rgba(255,255,255,0.8)';\n    const abx = UI_PADDING;\n    const aby = HEIGHT - FOOTER_HEIGHT + 10;\n    const abW = 360;\n    const abH = 28;\n    roundRect(ctx, abx, aby, abW, abH, 6, true, false);\n    ctx.fillStyle = '#224455';\n    ctx.font = '14px \"Segoe UI\", Roboto, Arial, sans-serif';\n    ctx.fillText(audioText, abx + 8, aby + abH / 2 + 5);\n  }\n\n  function drawDrone(dt) {\n    // Simple wacky drone: circular body, two propellers with rotation based on time\n    const now = performance.now() * 0.002;\n    // shadow\n    ctx.beginPath();\n    ctx.fillStyle = 'rgba(0,0,0,0.08)';\n    ctx.ellipse(drone.x, drone.y + DRONE_RADIUS + 8, DRONE_RADIUS * 1.2, DRONE_RADIUS * 0.45, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // body\n    ctx.beginPath();\n    ctx.fillStyle = '#fffef2';\n    ctx.strokeStyle = '#006699';\n    ctx.lineWidth = 3;\n    ctx.arc(drone.x, drone.y, DRONE_RADIUS, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n\n    // face (wacky)\n    ctx.beginPath();\n    ctx.fillStyle = '#006699';\n    ctx.arc(drone.x - 6, drone.y - 2, 4, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = '#ffaa00';\n    ctx.fillRect(drone.x + 2, drone.y + 2, 8, 6);\n\n    // props\n    for (let i = -1; i <= 1; i += 2) {\n      const px = drone.x + i * (DRONE_RADIUS + 12);\n      const py = drone.y - DRONE_RADIUS + 2;\n      const r = 14;\n      ctx.save();\n      ctx.translate(px, py);\n      ctx.rotate(now * (i * -2));\n      ctx.fillStyle = 'rgba(0,0,0,0.18)';\n      roundRect(ctx, -r, -6, r * 2, 12, 6, true, false);\n      ctx.restore();\n    }\n  }\n\n  function drawPackages(dt) {\n    // gentle bobbing animation\n    const t = performance.now() * 0.0012;\n    for (let i = 0; i < packages.length; i++) {\n      const p = packages[i];\n      p.angle += (i + 1) * 0.001 * dt; // slow rotation\n      const bob = Math.sin(t * (1 + i * 0.2) + i) * 6;\n      const px = p.ox + Math.cos(p.angle * 0.7) * 6;\n      const py = p.oy + bob;\n      p.x = px;\n      p.y = py;\n\n      // draw crate: box with number and quirky stickers\n      // crate shadow\n      ctx.beginPath();\n      ctx.fillStyle = 'rgba(0,0,0,0.06)';\n      ctx.ellipse(px, py + PACKAGE_RADIUS + 6, PACKAGE_RADIUS * 1.0, PACKAGE_RADIUS * 0.4, 0, 0, Math.PI * 2);\n      ctx.fill();\n\n      // crate body\n      ctx.save();\n      ctx.translate(px, py);\n      ctx.rotate(Math.sin(p.angle) * 0.04);\n      ctx.fillStyle = p.isCorrect ? '#fff9e6' : '#fff';\n      ctx.strokeStyle = '#884422';\n      ctx.lineWidth = 3;\n      roundRect(ctx, -PACKAGE_RADIUS, -PACKAGE_RADIUS, PACKAGE_RADIUS * 2, PACKAGE_RADIUS * 2, 8, true, true);\n\n      // sticker circle\n      ctx.beginPath();\n      ctx.fillStyle = p.isCorrect ? '#a3e635' : '#ffd166';\n      ctx.arc(0, -10, 12, 0, Math.PI * 2);\n      ctx.fill();\n\n      // number text\n      ctx.fillStyle = '#002233';\n      ctx.font = '20px \"Segoe UI\", Roboto, Arial, sans-serif';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(String(p.value), 0, 6);\n      ctx.restore();\n\n      // highlight when hovered\n      if (hoverIndex === i) {\n        ctx.beginPath();\n        ctx.strokeStyle = 'rgba(20,100,150,0.6)';\n        ctx.lineWidth = 3;\n        ctx.arc(p.x, p.y, PACKAGE_RADIUS + 6, 0, Math.PI * 2);\n        ctx.stroke();\n      }\n\n      // label index for keyboard access (1..4)\n      ctx.font = '14px \"Segoe UI\", Roboto, Arial, sans-serif';\n      ctx.fillStyle = 'rgba(0,0,0,0.6)';\n      ctx.fillText(String(i + 1), p.x + PACKAGE_RADIUS - 10, p.y - PACKAGE_RADIUS + 14);\n    }\n  }\n\n  function drawQuestionAndInstructions() {\n    // Draw a footer box centered with question and instructions\n    ctx.font = FONT_BIGGER;\n    ctx.fillStyle = 'rgba(255,255,255,0.92)';\n    const qText = question ? question.text : '';\n    const metrics = ctx.measureText(qText);\n    const boxW = Math.max(metrics.width + UI_PADDING * 4, 360);\n    const bx = (WIDTH - boxW) / 2;\n    const by = HEIGHT - FOOTER_HEIGHT + 10;\n    const bh = 64;\n    roundRect(ctx, bx, by, boxW, bh, 10, true, false);\n\n    // Question text\n    ctx.fillStyle = '#003344';\n    ctx.font = FONT_BIGGER;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(qText, WIDTH / 2, by + bh / 2 - 6);\n\n    // Below: instructions text (keyboard controls)\n    ctx.font = FONT_BASE;\n    ctx.textAlign = 'center';\n    ctx.fillStyle = 'rgba(0,0,0,0.7)';\n    const instr = 'Move: Arrow Keys or WASD \u2022 Collect correct package \u2022 Quick keys: 1-4 \u2022 R to restart';\n    const instrY = by + bh + 22;\n    ctx.fillText(instr, WIDTH / 2, instrY);\n\n    // Additional accessibility hint\n    ctx.font = '14px \"Segoe UI\", Roboto, Arial, sans-serif';\n    ctx.fillStyle = 'rgba(0,0,0,0.5)';\n    ctx.fillText('Touch or click a package to collect it. Press Space to toggle audio.', WIDTH / 2, instrY + 18);\n  }\n\n  function drawEndScreen() {\n    if (!showEndScreen) return;\n    // translucent overlay\n    ctx.fillStyle = 'rgba(6,18,28,0.65)';\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // central panel\n    const panelW = 520;\n    const panelH = 260;\n    const px = (WIDTH - panelW) / 2;\n    const py = (HEIGHT - panelH) / 2;\n    ctx.fillStyle = '#fff';\n    roundRect(ctx, px, py, panelW, panelH, 12, true, false);\n\n    // Title\n    ctx.font = FONT_BIGGER;\n    ctx.fillStyle = '#002233';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'top';\n    const title = endState === 'win' ? 'Victory! Drone Delivered!' : 'Game Over \u2014 Try Again';\n    ctx.fillText(title, WIDTH / 2, py + 22);\n\n    // Message\n    ctx.font = FONT_BASE;\n    ctx.fillStyle = '#004466';\n    const sub = endState === 'win' ? `You collected ${correctCount} correct packages!` : `You made ${wrongCount} mistakes. You collected ${correctCount} correct packages.`;\n    wrapText(ctx, sub, WIDTH / 2, py + 72, panelW - 60, 20);\n\n    // Restart button\n    const btn = getRestartButtonRect();\n    ctx.fillStyle = '#e6f7ff';\n    roundRect(ctx, btn.x, btn.y, btn.w, btn.h, 8, true, false);\n    ctx.fillStyle = '#004466';\n    ctx.font = FONT_LARGE;\n    ctx.fillText('Restart (R)', btn.x + btn.w / 2, btn.y + 10);\n\n    // Friendly tip\n    ctx.font = '14px \"Segoe UI\", Roboto, Arial, sans-serif';\n    ctx.fillStyle = '#333';\n    ctx.fillText('Tip: use 1-4 keys to quickly collect matching packages.', WIDTH / 2, btn.y + btn.h + 12);\n  }\n\n  function getRestartButtonRect() {\n    const btnW = 180;\n    const btnH = 48;\n    const bx = (WIDTH - btnW) / 2;\n    const by = (HEIGHT / 2) + 30;\n    return { x: bx, y: by, w: btnW, h: btnH };\n  }\n\n  // Helpers: rounded rectangle and text wrap\n  function roundRect(ctx, x, y, w, h, r, fill, stroke) {\n    if (typeof stroke === 'undefined') stroke = true;\n    if (typeof r === 'undefined') r = 6;\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  function wrapText(ctx, text, x, y, maxWidth, lineHeight) {\n    const words = text.split(' ');\n    let line = '';\n    let offsetY = 0;\n    for (let n = 0; n < words.length; n++) {\n      const testLine = line + words[n] + ' ';\n      const metrics = ctx.measureText(testLine);\n      const testWidth = metrics.width;\n      if (testWidth > maxWidth && n > 0) {\n        ctx.fillText(line, x, y + offsetY);\n        line = words[n] + ' ';\n        offsetY += lineHeight;\n      } else {\n        line = testLine;\n      }\n    }\n    ctx.fillText(line, x, y + offsetY);\n  }\n\n  // Update loop\n  function update(dt) {\n    if (showEndScreen) {\n      // slight floating drone while paused\n      drone.x = drone.x + Math.sin(performance.now() * 0.001) * 0.02;\n      return;\n    }\n    // Movement processing\n    let moveX = 0, moveY = 0;\n    if (keys['ArrowLeft'] || keys['a'] || keys['A']) moveX -= 1;\n    if (keys['ArrowRight'] || keys['d'] || keys['D']) moveX += 1;\n    if (keys['ArrowUp'] || keys['w'] || keys['W']) moveY -= 1;\n    if (keys['ArrowDown'] || keys['s'] || keys['S']) moveY += 1;\n\n    const len = Math.hypot(moveX, moveY) || 1;\n    drone.vx = (moveX / len) * drone.speed;\n    drone.vy = (moveY / len) * drone.speed;\n\n    drone.x += drone.vx * dt;\n    drone.y += drone.vy * dt;\n\n    // Keep drone within play area boundaries (respect header/footer)\n    drone.x = clamp(drone.x, DRONE_RADIUS + UI_PADDING, WIDTH - DRONE_RADIUS - UI_PADDING);\n    drone.y = clamp(drone.y, HEADER_HEIGHT + DRONE_RADIUS, HEIGHT - FOOTER_HEIGHT - DRONE_RADIUS);\n\n    // Check collision with any package\n    for (let i = 0; i < packages.length; i++) {\n      const p = packages[i];\n      if (collides(drone.x, drone.y, DRONE_RADIUS - 6, p.x, p.y, PACKAGE_RADIUS - 6)) {\n        collectPackage(i);\n        break;\n      }\n    }\n  }\n\n  function render(now) {\n    const tNow = performance.now();\n    const dtMs = tNow - lastTime;\n    const dt = Math.min(dtMs / 1000, 0.05);\n    lastTime = tNow;\n\n    update(dtMs);\n\n    // Draw everything\n    drawBackground(dtMs);\n    drawHeader();\n    drawPackages(dtMs);\n    drawDrone(dtMs);\n    drawQuestionAndInstructions();\n\n    if (showEndScreen) {\n      drawEndScreen();\n    }\n\n    // Next frame\n    if (running) {\n      requestAnimationFrame(render);\n    }\n  }\n\n  // Start things\n  try {\n    initAudio();\n  } catch (e) {\n    console.warn('Audio initialization failed:', e);\n  }\n  resetGame();\n  requestAnimationFrame(render);\n\n  // Provide a safe stop function bound to container for debugging if needed\n  container.stopGame = function() { running = false; };\n\n  // Small final accessibility / safety: keyboard focus instructions\n  canvas.setAttribute('tabindex', '0');\n  canvas.addEventListener('focus', () => {\n    // ensure audio context resumes on focus for some platforms if user toggled earlier\n    if (audioCtx && audioCtx.state === 'suspended') {\n      audioCtx.resume().catch(() => {});\n    }\n  });\n\n  // Error handling for resource loading: we have no external resources; but guard against exceptions\n  window.addEventListener('error', (e) => {\n    console.error('Runtime error in Drone Math Collector:', e.error || e.message);\n  });\n})();\n---\n",
  "improve_response_tokens": 18366,
  "formatted_code": true,
  "formatting_response_tokens": 19227,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}