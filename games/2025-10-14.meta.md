# Game of the Day - 2025-10-14

## Metadata
- **Generated Date:** 2025-10-14
- **Generated Time:** 2025-10-14T00:26:05.276231
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-10-14.js
- **File Size:** 23746 bytes
- **Tokens Used:** 8730

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-10-14.js` - The playable game
- `2025-10-14.meta.json` - Machine-readable metadata
- `2025-10-14.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 18015

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 20010

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Drone Math Adventure
  // Educational game for ages 7-9. Rendered into #game-of-the-day-stage
  // Uses Canvas and Web Audio API. No external assets.

  // Configuration constants
  const CANVAS_WIDTH = 720;
  const CANVAS_HEIGHT = 480;
  const GOAL_SCORE = 10;
  const MAX_LIVES = 3;
  const QUESTION_FONT = "22px Arial";
  const BODY_FONT = "16px Arial";
  const IMPORTANT_FONT = "26px Arial";
  const UI_PADDING = 10; // minimum spacing between UI elements (pixels)
  const OPTION_FONT = "20px Arial";
  const AUDIO_ENABLED_DEFAULT = true;

  // Access the stage element and create canvas
  const stage = document.getElementById("game-of-the-day-stage");
  if (!stage) {
    console.error("No element with id 'game-of-the-day-stage' found.");
    return;
  }
  // Clear stage and create canvas
  stage.innerHTML = "";
  stage.style.position = "relative";
  const canvas = document.createElement("canvas");
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;
  canvas.setAttribute("role", "img");
  canvas.setAttribute("aria-label", "Drone Math Adventure: solve addition and subtraction questions. Use number keys 1 to 4 to answer. Press M to toggle sound. Press R to restart.");
  canvas.setAttribute("tabindex", "0"); // allow keyboard focus
  stage.appendChild(canvas);
  const ctx = canvas.getContext("2d");

  // Audio setup with proper error handling
  let audioCtx = null;
  let audioAllowed = AUDIO_ENABLED_DEFAULT;
  let ambientGain = null;
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (!AudioContext) {
      throw new Error("Web Audio API not supported");
    }
    audioCtx = new AudioContext();
    // create gentle ambient drone (subtle)
    ambientGain = audioCtx.createGain();
    ambientGain.gain.value = 0.02; // subtle background
    ambientGain.connect(audioCtx.destination);
    const ambientOsc = audioCtx.createOscillator();
    ambientOsc.type = "sine";
    ambientOsc.frequency.value = 120; // low tone
    const ambientLFO = audioCtx.createOscillator();
    ambientLFO.type = "sine";
    ambientLFO.frequency.value = 0.2;
    const ambientLFPGain = audioCtx.createGain();
    ambientLFPGain.gain.value = 30;
    ambientLFO.connect(ambientLFPGain);
    ambientLFPGain.connect(ambientOsc.frequency);
    ambientOsc.connect(ambientGain);
    // Start oscillators only if audioAllowed will be true and context is running.
    // We'll start after a first user gesture to avoid autoplay blocking.
    ambientOsc.start();
    ambientLFO.start();

    // mute ambient until resumed
    ambientGain.gain.value = audioAllowed ? 0.02 : 0;
    // store oscillators for later control
    audioCtx._ambientOsc = ambientOsc;
    audioCtx._ambientLFO = ambientLFO;
  } catch (err) {
    console.warn("Audio disabled or failed to initialize:", err);
    audioCtx = null;
    audioAllowed = false;
  }

  // Utility for short sound effects (correct/incorrect)
  function playBeep(type = "correct") {
    if (!audioAllowed || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const f = type === "correct" ? 880 : 240; // higher for correct
      o.frequency.setValueAtTime(f, now);
      o.type = type === "correct" ? "triangle" : "sawtooth";
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.2, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.22);
      o.connect(g);
      g.connect(audioCtx.destination);
      o.start(now);
      o.stop(now + 0.24);
    } catch (err) {
      console.warn("Failed to play beeps:", err);
    }
  }

  // Ensure audio context resumes on first user gesture if suspended
  async function ensureAudioRunning() {
    if (!audioCtx) return;
    try {
      if (audioCtx.state === "suspended") {
        await audioCtx.resume();
      }
    } catch (err) {
      console.warn("Audio resume failed:", err);
    }
    // ensure ambient gain reflects audioAllowed
    if (audioCtx._ambientOsc && ambientGain) {
      ambientGain.gain.value = audioAllowed ? 0.02 : 0;
    }
  }

  // Game state
  let score = 0;
  let lives = MAX_LIVES;
  let question = null;
  let options = [];
  let selectedOptionIndex = -1;
  let questionCount = 0;
  let gameState = "playing"; // playing, victory, gameover
  let lastTime = performance.now();
  let hoverIndex = -1;
  let animationTime = 0;
  let particles = [];
  let drones = []; // for option visuals

  // Accessibility: update canvas aria-label with current state
  function updateAriaLabel() {
    let label = `Drone Math Adventure. Score ${score}. Lives ${lives}. `;
    if (gameState === "playing") {
      label += `Question: ${question ? question.text : ""} `;
      label += `Options: `;
      options.forEach((opt, i) => {
        label += `${i + 1}: ${opt}. `;
      });
      label += "Press number keys 1 to 4 to answer.";
    } else if (gameState === "victory") {
      label += "You won! Press R to restart.";
    } else if (gameState === "gameover") {
      label += "Game over. Press R to restart.";
    }
    canvas.setAttribute("aria-label", label);
  }

  // Question generator: simple addition/subtraction within 20
  function generateQuestion() {
    const a = Math.floor(Math.random() * 18) + 1; // 1..18
    const b = Math.floor(Math.random() * 9) + 1;  // 1..9
    const add = Math.random() > 0.5;
    const answer = add ? a + b : a - b;
    const text = add ? `${a} + ${b} = ?` : `${a} - ${b} = ?`;
    // create 3 distractors within +/- 5 but unique and >= -20 and <= 40
    const set = new Set([answer]);
    while (set.size < 4) {
      let delta = Math.floor(Math.random() * 11) - 5; // -5..5
      if (delta === 0) delta = (Math.random() > 0.5) ? 1 : -1;
      let v = answer + delta;
      if (v < -20) v = answer + Math.abs(delta) + 1;
      set.add(v);
    }
    const arr = Array.from(set);
    // shuffle options
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    // calculate which index is correct
    const correctIndex = arr.indexOf(answer);
    return {
      text,
      answer,
      options: arr,
      correctIndex
    };
  }

  // Setup new question and visual drones for options
  function nextQuestion() {
    question = generateQuestion();
    options = question.options.slice();
    selectedOptionIndex = -1;
    hoverIndex = -1;
    questionCount++;
    // create drones for each option with positions
    drones = [];
    const positions = [
      { x: 180, y: 210 },
      { x: 540, y: 210 },
      { x: 180, y: 340 },
      { x: 540, y: 340 }
    ];
    for (let i = 0; i < 4; i++) {
      const p = positions[i];
      drones.push({
        x: p.x,
        y: p.y,
        targetY: p.y,
        angle: Math.random() * Math.PI * 2,
        wobble: Math.random() * 0.5 + 0.5,
        label: String(options[i])
      });
    }
    updateAriaLabel();
  }

  // Initialize new game
  function restartGame() {
    score = 0;
    lives = MAX_LIVES;
    questionCount = 0;
    gameState = "playing";
    nextQuestion();
    particles = [];
    animationTime = 0;
    selectedOptionIndex = -1;
    hoverIndex = -1;
    updateAriaLabel();
  }

  // Start the game initially
  restartGame();

  // Mouse and keyboard events
  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    hoverIndex = -1;
    for (let i = 0; i < drones.length; i++) {
      const d = drones[i];
      // option bounding box
      const w = 220;
      const h = 80;
      if (mx >= d.x - w / 2 && mx <= d.x + w / 2 && my >= d.y - h / 2 && my <= d.y + h / 2) {
        hoverIndex = i;
        canvas.style.cursor = "pointer";
        return;
      }
    }
    canvas.style.cursor = "default";
  });

  canvas.addEventListener("click", async (e) => {
    await ensureAudioRunning();
    if (gameState !== "playing") {
      // check restart button click
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      // restart button center
      const btnW = 180, btnH = 48;
      const btnX = CANVAS_WIDTH / 2 - btnW / 2;
      const btnY = CANVAS_HEIGHT / 2 + 60;
      if (mx >= btnX && mx <= btnX + btnW && my >= btnY && my <= btnY + btnH) {
        restartGame();
      }
      return;
    }
    // playing: check option click
    if (hoverIndex >= 0) {
      chooseOption(hoverIndex);
    }
  });

  // keyboard controls: 1-4 to choose, M to toggle audio, R to restart
  canvas.addEventListener("keydown", async (e) => {
    await ensureAudioRunning();
    if (e.key >= "1" && e.key <= "4") {
      const idx = parseInt(e.key, 10) - 1;
      if (gameState === "playing") chooseOption(idx);
    } else if (e.key.toLowerCase() === "m") {
      toggleAudio();
    } else if (e.key.toLowerCase() === "r") {
      restartGame();
    } else if (e.key === "ArrowLeft") {
      // optional: navigate hover for accessibility
      if (gameState === "playing") {
        hoverIndex = (hoverIndex <= 0) ? drones.length - 1 : hoverIndex - 1;
      }
    } else if (e.key === "ArrowRight") {
      if (gameState === "playing") {
        hoverIndex = (hoverIndex + 1) % drones.length;
      }
    } else if (e.key === "Enter") {
      if (gameState === "playing" && hoverIndex >= 0) {
        chooseOption(hoverIndex);
      } else if (gameState !== "playing") {
        restartGame();
      }
    }
    updateAriaLabel();
  });

  // make sure canvas is focusable and focused so keyboard works
  canvas.addEventListener("focus", () => {
    canvas.style.outline = "2px solid rgba(0,0,0,0.1)";
  });
  canvas.addEventListener("blur", () => {
    canvas.style.outline = "none";
  });
  // Autofocus to allow keyboard immediately if possible
  setTimeout(() => {
    try {
      canvas.focus();
    } catch (err) {}
  }, 100);

  // Choose an option index (player action)
  function chooseOption(idx) {
    if (gameState !== "playing") return;
    selectedOptionIndex = idx;
    // Visual: make chosen drone bounce upward slightly
    const d = drones[idx];
    d.targetY = d.y - 30;
    // Check correctness
    if (idx === question.correctIndex) {
      score++;
      playBeep("correct");
      spawnParticles(d.x, d.y, "#FFD700"); // golden stars
      // Move drone off-screen to "deliver" package
      d.delivering = true;
      d.deliveryTarget = { x: CANVAS_WIDTH - 60, y: 60 };
    } else {
      lives--;
      playBeep("incorrect");
      spawnParticles(d.x, d.y, "#FF6B6B");
      // shake the drone
      d.shakeTime = 0.4;
    }
    // Check win/lose conditions after small timeout so player sees effect
    setTimeout(() => {
      if (score >= GOAL_SCORE) {
        gameState = "victory";
      } else if (lives <= 0) {
        gameState = "gameover";
      } else {
        nextQuestion();
      }
      updateAriaLabel();
    }, 500);
  }

  // Particle effect for feedback
  function spawnParticles(x, y, color) {
    for (let i = 0; i < 12; i++) {
      particles.push({
        x,
        y,
        vx: (Math.random() - 0.5) * 200,
        vy: (Math.random() - 0.8) * -180,
        life: Math.random() * 0.8 + 0.4,
        ttl: Math.random() * 0.8 + 0.4,
        color,
        size: Math.random() * 4 + 2
      });
    }
  }

  // Toggle audio on/off
  function toggleAudio() {
    if (!audioCtx) return;
    audioAllowed = !audioAllowed;
    try {
      if (ambientGain) ambientGain.gain.value = audioAllowed ? 0.02 : 0;
    } catch (err) {
      console.warn("Failed to toggle ambient:", err);
    }
    updateAriaLabel();
  }

  // Draw helper functions with measured backgrounds to avoid overlapping text
  function drawTextWithBackground(text, x, y, font, padding = 8, align = "left", bgColor = "rgba(255,255,255,0.6)", textColor = "#000") {
    ctx.font = font;
    const metrics = ctx.measureText(text);
    const width = metrics.width;
    const height = parseInt(font, 10);
    let drawX = x;
    if (align === "center") drawX = x - (width / 2);
    if (align === "right") drawX = x - width;
    const rectX = drawX - padding;
    const rectY = y - height + -2 - padding / 2;
    const rectW = width + padding * 2;
    const rectH = height + padding;
    // background
    ctx.fillStyle = bgColor;
    roundRect(ctx, rectX, rectY, rectW, rectH, 6);
    ctx.fill();
    // text
    ctx.fillStyle = textColor;
    ctx.textAlign = align;
    ctx.fillText(text, x, y);
    return { x: rectX, y: rectY, w: rectW, h: rectH };
  }

  // Rounded rectangle utility
  function roundRect(ctx, x, y, w, h, r) {
    r = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  // Main render loop
  function render(now) {
    const dt = Math.min(0.05, (now - lastTime) / 1000);
    lastTime = now;
    animationTime += dt;

    // Update particles
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.vy += 500 * dt; // gravity
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.life -= dt;
      if (p.life <= 0) particles.splice(i, 1);
    }

    // Update drones
    for (let i = 0; i < drones.length; i++) {
      const d = drones[i];
      // gentle bobbing
      d.angle += dt * 2 * d.wobble;
      const bob = Math.sin(animationTime * 2 + i) * 6;
      // shake effect
      if (d.shakeTime && d.shakeTime > 0) {
        d.shakeTime -= dt;
      }
      if (d.delivering) {
        // move toward delivery target
        const tx = d.deliveryTarget.x;
        const ty = d.deliveryTarget.y;
        d.x += (tx - d.x) * Math.min(1, dt * 2.5);
        d.y += (ty - d.y) * Math.min(1, dt * 2.5);
      } else {
        // return to base targetY
        d.y += (d.targetY - d.y) * Math.min(1, dt * 4);
      }
      d.renderY = d.y + bob;
    }

    // Clear canvas and draw background with gentle gradient
    const skyGrad = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
    skyGrad.addColorStop(0, "#E6F7FF");
    skyGrad.addColorStop(1, "#CFEFFA");
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // Draw whimsical clouds (wacky shapes)
    drawWackyCloud(80 + Math.sin(animationTime) * 10, 70, 80, 40, "#FFFFFF", "#EAF6FF");
    drawWackyCloud(560 + Math.cos(animationTime * 0.7) * 12, 60, 120, 54, "#FFFFFF", "#F0FBFF");
    drawWackyCloud(340, 45 + Math.sin(animationTime * 0.9) * 8, 60, 30, "#FFFFFF", "#F8FDFF");

    // Draw question box at top center
    ctx.textBaseline = "alphabetic";
    ctx.font = IMPORTANT_FONT;
    ctx.fillStyle = "#000";
    ctx.textAlign = "center";
    const questionBox = drawTextWithBackground(question.text, CANVAS_WIDTH / 2, 60, IMPORTANT_FONT, 14, "center", "rgba(255,255,255,0.8)", "#0B3D91");

    // Draw score top-left and lives top-right using measureText to avoid overlapping
    ctx.font = BODY_FONT;
    ctx.textBaseline = "alphabetic";
    ctx.textAlign = "left";
    const scoreText = `Score: ${score}/${GOAL_SCORE}`;
    const scoreBox = drawTextWithBackground(scoreText, UI_PADDING + 2, UI_PADDING + 20, BODY_FONT, 8, "left", "rgba(255,255,255,0.8)", "#003366");

    ctx.textAlign = "right";
    const livesText = `Lives: ${lives}`;
    // Place lives at top-right with padding
    const livesX = CANVAS_WIDTH - UI_PADDING - 2;
    const livesBox = drawTextWithBackground(livesText, livesX, UI_PADDING + 20, BODY_FONT, 8, "right", "rgba(255,255,255,0.8)", "#7A0000");

    // Draw audio state icon (top-left near score) - use small text
    ctx.font = "14px Arial";
    const audioText = audioAllowed ? "🔊 Sound: On (M)" : "🔈 Sound: Off (M)";
    ctx.textAlign = "left";
    drawTextWithBackground(audioText, UI_PADDING + 2, scoreBox.y + scoreBox.h + 20, "14px Arial", 6, "left", "rgba(255,255,255,0.75)", "#004d40");

    // Draw instructions bottom-center
    ctx.font = BODY_FONT;
    ctx.textAlign = "center";
    const instructions = "Choose the correct answer. Use keys 1-4 or click a drone. Press R to restart.";
    drawTextWithBackground(instructions, CANVAS_WIDTH / 2, CANVAS_HEIGHT - UI_PADDING - 10, BODY_FONT, 10, "center", "rgba(255,255,255,0.8)", "#002b3a");

    // Draw option drones with labels and option numbers
    for (let i = 0; i < drones.length; i++) {
      const d = drones[i];
      const x = d.x;
      const y = d.renderY;
      // Option background box
      const boxW = 220;
      const boxH = 80;
      const isHover = hoverIndex === i;
      const isSelected = selectedOptionIndex === i;
      ctx.save();
      ctx.translate(x, y);
      // draw drone body
      // shadow
      ctx.fillStyle = "rgba(0,0,0,0.08)";
      roundRect(ctx, -boxW / 2 + 8, boxH / 2 - 6, boxW - 16, 8, 6);
      ctx.fill();
      // box
      const bg = isSelected ? "#E8FFF2" : isHover ? "#FFF7E6" : "#FFFFFF";
      ctx.fillStyle = bg;
      roundRect(ctx, -boxW / 2, -boxH / 2, boxW, boxH, 12);
      ctx.fill();
      ctx.strokeStyle = "#D0D6DE";
      ctx.lineWidth = 2;
      ctx.stroke();
      // draw drone "roof" - semi circle
      ctx.beginPath();
      ctx.fillStyle = "#8CCBF3";
      ctx.arc(-boxW / 2 + 60, -boxH / 2 + 12, 18, Math.PI, 0, false);
      ctx.fill();
      ctx.closePath();

      // propeller (animated)
      ctx.save();
      ctx.translate(-boxW / 2 + 60, -boxH / 2 + 12);
      ctx.rotate(animationTime * 12 + d.angle);
      ctx.fillStyle = "#333333";
      for (let k = 0; k < 3; k++) {
        ctx.beginPath();
        ctx.ellipse(0, -10, 4, 14, k * Math.PI / 3, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();

      // draw label text (option number and value)
      ctx.font = "18px Arial";
      ctx.fillStyle = "#00334d";
      ctx.textAlign = "left";
      ctx.fillText(`${i + 1}.`, -boxW / 2 + 12, 10);
      ctx.font = OPTION_FONT;
      ctx.fillStyle = "#002b36";
      ctx.textAlign = "center";
      ctx.fillText(d.label, 0, 12);

      // subtle decorative antenna
      ctx.strokeStyle = "#B7E0FA";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(boxW / 2 - 18, -boxH / 2 + 6);
      ctx.quadraticCurveTo(boxW / 2 - 12, -boxH / 2 - 16, boxW / 2 - 36, -boxH / 2 - 12);
      ctx.stroke();

      // if wrong recently, add red flash
      if (d.shakeTime && d.shakeTime > 0) {
        ctx.fillStyle = "rgba(255,100,100,0.08)";
        roundRect(ctx, -boxW / 2, -boxH / 2, boxW, boxH, 12);
        ctx.fill();
      }

      ctx.restore();
    }

    // Draw floating stars indicating progress top-center under question
    for (let i = 0; i < GOAL_SCORE; i++) {
      const starX = CANVAS_WIDTH / 2 - ((GOAL_SCORE - 1) * 18) + i * 36;
      const starY = questionBox.y + questionBox.h + 40;
      drawStar(ctx, starX, starY, 5, 8, 4, i < score ? "#FFD24D" : "rgba(255,255,255,0.35)");
    }

    // Draw particles
    particles.forEach((p) => {
      ctx.globalAlpha = Math.max(0, p.life / p.ttl);
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    });

    // If game ended, draw overlay screens
    if (gameState === "victory") {
      drawOverlay("Victory!", `You delivered ${score} drone packages!`, "🎉");
      drawRestartButton();
    } else if (gameState === "gameover") {
      drawOverlay("Game Over", `You ran out of lives after ${questionCount} questions.`, "💥");
      drawRestartButton();
    }

    requestAnimationFrame(render);
  }

  // Draw overlay for victory/game over
  function drawOverlay(title, subtitle, emoji) {
    // translucent background
    ctx.fillStyle = "rgba(2,12,22,0.4)";
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    // central box
    ctx.fillStyle = "rgba(255,255,255,0.98)";
    const boxW = 560;
    const boxH = 220;
    const bx = CANVAS_WIDTH / 2 - boxW / 2;
    const by = CANVAS_HEIGHT / 2 - boxH / 2 - 20;
    roundRect(ctx, bx, by, boxW, boxH, 12);
    ctx.fill();

    // Title and subtitle
    ctx.textAlign = "center";
    ctx.fillStyle = "#04395E";
    ctx.font = "34px Arial";
    ctx.fillText(`${emoji} ${title}`, CANVAS_WIDTH / 2, by + 60);

    ctx.font = "18px Arial";
    ctx.fillStyle = "#074b6a";
    wrapText(ctx, subtitle, CANVAS_WIDTH / 2, by + 100, boxW - 60, 22);

    // hint
    ctx.font = "16px Arial";
    ctx.fillStyle = "#0b3d91";
    ctx.fillText("Press R or click Restart to play again.", CANVAS_WIDTH / 2, by + boxH - 20);
  }

  // Draw restart button
  function drawRestartButton() {
    const btnW = 180, btnH = 48;
    const btnX = CANVAS_WIDTH / 2 - btnW / 2;
    const btnY = CANVAS_HEIGHT / 2 + 60;
    ctx.fillStyle = "#00A896";
    roundRect(ctx, btnX, btnY, btnW, btnH, 10);
    ctx.fill();
    ctx.fillStyle = "#FFFFFF";
    ctx.font = "18px Arial";
    ctx.textAlign = "center";
    ctx.fillText("Restart (R)", CANVAS_WIDTH / 2, btnY + 32);
  }

  // Draw star helper
  function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius, color) {
    let rot = Math.PI / 2 * 3;
    let x = cx;
    let y = cy;
    let step = Math.PI / spikes;
    ctx.beginPath();
    ctx.moveTo(cx, cy - outerRadius);
    for (let i = 0; i < spikes; i++) {
      x = cx + Math.cos(rot) * outerRadius;
      y = cy + Math.sin(rot) * outerRadius;
      ctx.lineTo(x, y);
      rot += step;

      x = cx + Math.cos(rot) * innerRadius;
      y = cy + Math.sin(rot) * innerRadius;
      ctx.lineTo(x, y);
      rot += step;
    }
    ctx.lineTo(cx, cy - outerRadius);
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
    ctx.strokeStyle = "rgba(0,0,0,0.08)";
    ctx.stroke();
  }

  // Draw a wacky cloud using Bezier curves
  function drawWackyCloud(cx, cy, w, h, color1, color2) {
    const grad = ctx.createRadialGradient(cx, cy - 10, 10, cx, cy, w);
    grad.addColorStop(0, color1);
    grad.addColorStop(1, color2);
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.ellipse(cx, cy, w, h, 0, 0, Math.PI * 2);
    // add small lumps
    ctx.ellipse(cx - w * 0.4, cy - h * 0.2, w * 0.55, h * 0.55, -0.2, 0, Math.PI * 2);
    ctx.ellipse(cx + w * 0.35, cy - h * 0.25, w * 0.45, h * 0.45, 0.3, 0, Math.PI * 2);
    ctx.fill();
  }

  // Wrap text in canvas
  function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = text.split(" ");
    let line = "";
    let test = "";
    let currentY = y;
    ctx.textAlign = "center";
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + " ";
      const metrics = ctx.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        ctx.fillText(line, x, currentY);
        line = words[n] + " ";
        currentY += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line, x, currentY);
  }

  // Start animation loop
  requestAnimationFrame(render);

  // Ensure canvas does not overflow stage and is exact size
  canvas.style.width = `${CANVAS_WIDTH}px`;
  canvas.style.height = `${CANVAS_HEIGHT}px`;
  canvas.style.display = "block";

  // Provide visual cue for audio toggle when clicking stage background
  // Also handle first click to resume audio context
  stage.addEventListener("click", async () => {
    await ensureAudioRunning();
  }, { once: true });

  // Expose some debug methods for console if needed
  window._droneMathGame = {
    restart: restartGame,
    toggleAudio: toggleAudio,
    getState: () => ({ score, lives, questionCount, gameState })
  };

})();
---

