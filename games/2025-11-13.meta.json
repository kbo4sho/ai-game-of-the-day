{
  "generated_date": "2025-11-13",
  "generated_timestamp": "2025-11-13T00:28:10.634143",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9915,
  "game_filename": "2025-11-13.js",
  "game_size_bytes": 28212,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Drone Math Game for ages 7-9\n  // Renders inside element with id 'game-of-the-day-stage'\n  // All visuals drawn on canvas. Sounds generated with Web Audio API oscillators.\n  // Author: Educational Game Designer AI\n\n  // --- Setup container and canvas ---\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Game container #game-of-the-day-stage not found.');\n    return;\n  }\n  // Clear container\n  container.innerHTML = '';\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = 720;\n  canvas.height = 480;\n  canvas.style.display = 'block';\n  canvas.style.outline = 'none';\n  canvas.setAttribute('tabindex', '0'); // focusable for keyboard input\n  canvas.setAttribute('role', 'img');\n  canvas.setAttribute('aria-label', 'Drone math game. Use arrow keys to move the drone, space to scan a crate. Answer 10 questions to win. Three wrong answers and the game is over.');\n  container.appendChild(canvas);\n\n  // Hidden live region for accessibility updates\n  const live = document.createElement('div');\n  live.style.position = 'absolute';\n  live.style.left = '-9999px';\n  live.setAttribute('aria-live', 'polite');\n  container.appendChild(live);\n\n  const ctx = canvas.getContext('2d');\n\n  // --- Audio setup ---\n  let AudioContextClass = window.AudioContext || window.webkitAudioContext;\n  let audioCtx = null;\n  let audioEnabled = true;\n  try {\n    if (AudioContextClass) {\n      audioCtx = new AudioContextClass();\n      // Start suspended; will resume on first user gesture\n      if (audioCtx.state === 'suspended') {\n        // Will be resumed on first user interaction\n      }\n    } else {\n      audioEnabled = false;\n    }\n  } catch (e) {\n    console.warn('AudioContext failed to initialize:', e);\n    audioEnabled = false;\n  }\n\n  // Audio nodes for background hum and effects\n  let bgOsc = null;\n  let bgGain = null;\n\n  function safePlayEffect(type) {\n    // Ensure audio context resumed on user gesture\n    if (!audioEnabled || !audioCtx) return;\n    if (audioCtx.state === 'suspended') {\n      audioCtx.resume().catch((e) => {\n        console.warn('AudioContext resume failed:', e);\n      });\n    }\n    try {\n      if (type === 'correct') playCorrectTone();\n      else if (type === 'wrong') playWrongTone();\n      else if (type === 'pickup') playPickupTone();\n      else if (type === 'click') playClickTone();\n    } catch (e) {\n      console.warn('Audio playback error:', e);\n    }\n  }\n\n  function startBackgroundHum() {\n    if (!audioEnabled || !audioCtx) return;\n    stopBackgroundHum();\n    try {\n      bgOsc = audioCtx.createOscillator();\n      const lfo = audioCtx.createOscillator();\n      const lfoGain = audioCtx.createGain();\n      bgGain = audioCtx.createGain();\n\n      bgOsc.type = 'sine';\n      bgOsc.frequency.value = 110; // low gentle hum\n      bgGain.gain.value = 0.02; // very quiet\n\n      lfo.type = 'sine';\n      lfo.frequency.value = 0.08; // slow modulation\n      lfoGain.gain.value = 0.03;\n      lfo.connect(lfoGain);\n      lfoGain.connect(bgGain.gain);\n\n      bgOsc.connect(bgGain);\n      bgGain.connect(audioCtx.destination);\n\n      bgOsc.start();\n      lfo.start();\n    } catch (e) {\n      console.warn('Background hum failed:', e);\n    }\n  }\n\n  function stopBackgroundHum() {\n    try {\n      if (bgOsc) {\n        bgOsc.stop();\n        bgOsc.disconnect();\n        bgOsc = null;\n      }\n      if (bgGain) {\n        bgGain.disconnect();\n        bgGain = null;\n      }\n    } catch (e) {\n      // ignore\n    }\n  }\n\n  function playCorrectTone() {\n    const o = audioCtx.createOscillator();\n    const g = audioCtx.createGain();\n    o.type = 'triangle';\n    o.frequency.setValueAtTime(880, audioCtx.currentTime);\n    o.frequency.exponentialRampToValueAtTime(1320, audioCtx.currentTime + 0.15);\n    g.gain.value = 0.0001;\n    g.gain.exponentialRampToValueAtTime(0.08, audioCtx.currentTime + 0.01);\n    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.5);\n    o.connect(g);\n    g.connect(audioCtx.destination);\n    o.start();\n    o.stop(audioCtx.currentTime + 0.5);\n  }\n\n  function playWrongTone() {\n    const o = audioCtx.createOscillator();\n    const g = audioCtx.createGain();\n    o.type = 'sawtooth';\n    o.frequency.setValueAtTime(220, audioCtx.currentTime);\n    o.frequency.exponentialRampToValueAtTime(110, audioCtx.currentTime + 0.25);\n    g.gain.value = 0.0001;\n    g.gain.exponentialRampToValueAtTime(0.09, audioCtx.currentTime + 0.02);\n    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.6);\n    o.connect(g);\n    g.connect(audioCtx.destination);\n    o.start();\n    o.stop(audioCtx.currentTime + 0.6);\n  }\n\n  function playPickupTone() {\n    const o = audioCtx.createOscillator();\n    const g = audioCtx.createGain();\n    o.type = 'sine';\n    o.frequency.setValueAtTime(660, audioCtx.currentTime);\n    o.frequency.exponentialRampToValueAtTime(990, audioCtx.currentTime + 0.12);\n    g.gain.value = 0.0001;\n    g.gain.exponentialRampToValueAtTime(0.06, audioCtx.currentTime + 0.01);\n    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.25);\n    o.connect(g);\n    g.connect(audioCtx.destination);\n    o.start();\n    o.stop(audioCtx.currentTime + 0.25);\n  }\n\n  function playClickTone() {\n    const o = audioCtx.createOscillator();\n    const g = audioCtx.createGain();\n    o.type = 'square';\n    o.frequency.setValueAtTime(440, audioCtx.currentTime);\n    g.gain.value = 0.0001;\n    g.gain.exponentialRampToValueAtTime(0.03, audioCtx.currentTime + 0.01);\n    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.12);\n    o.connect(g);\n    g.connect(audioCtx.destination);\n    o.start();\n    o.stop(audioCtx.currentTime + 0.12);\n  }\n\n  // --- Game configuration ---\n  const CONFIG = {\n    width: canvas.width,\n    height: canvas.height,\n    padding: 10,\n    goalCorrect: 10,\n    maxWrong: 3,\n    minBodyFont: 16,\n    importantFont: 22,\n    crateY: 320,\n    crateCount: 3,\n  };\n\n  // --- Game state ---\n  let state = {\n    score: 0,\n    wrong: 0,\n    running: true,\n    win: false,\n    lose: false,\n    question: null,\n    crates: [],\n    drone: {\n      x: canvas.width / 2,\n      y: 240,\n      width: 64,\n      height: 28,\n      vx: 0,\n      vy: 0,\n      speed: 220, // pixels per second\n    },\n    keys: {},\n    mouse: { x: 0, y: 0 },\n    audioOn: !!audioEnabled,\n    lastTime: 0,\n    flashTimer: 0,\n  };\n\n  // --- Utilities ---\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  function clamp(v, a, b) {\n    return Math.max(a, Math.min(b, v));\n  }\n\n  function generateQuestion() {\n    // For ages 7-9: addition/subtraction with small numbers\n    const op = Math.random() < 0.55 ? '+' : '-';\n    let a = randInt(2, 18);\n    let b = randInt(1, 12);\n    if (op === '-' && b > a) {\n      const tmp = a;\n      a = b;\n      b = tmp;\n    }\n    const answer = op === '+' ? a + b : a - b;\n    return { a, b, op, answer };\n  }\n\n  function spawnCratesForQuestion(q) {\n    const crateValues = new Set();\n    crateValues.add(q.answer);\n    while (crateValues.size < CONFIG.crateCount) {\n      // Random wrong answers close to correct\n      const delta = randInt(1, 8);\n      const sign = Math.random() < 0.5 ? -1 : 1;\n      let candidate = q.answer + sign * delta;\n      if (candidate < 0) candidate = Math.abs(candidate) + 1;\n      crateValues.add(candidate);\n    }\n    const values = Array.from(crateValues);\n    // Shuffle\n    for (let i = values.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [values[i], values[j]] = [values[j], values[i]];\n    }\n    const spacing = canvas.width / (CONFIG.crateCount + 1);\n    const crates = values.map((val, i) => {\n      return {\n        value: val,\n        x: spacing * (i + 1),\n        y: CONFIG.crateY,\n        w: 84,\n        h: 56,\n        picked: false,\n      };\n    });\n    return crates;\n  }\n\n  function newQuestion() {\n    state.question = generateQuestion();\n    state.crates = spawnCratesForQuestion(state.question);\n    live.textContent = `New question: ${state.question.a} ${state.question.op} ${state.question.b}.`;\n  }\n\n  // --- Input handling ---\n  function onKeyDown(e) {\n    if (!state.running && (state.win || state.lose)) {\n      if (e.key === 'r' || e.key === 'R') {\n        restartGame();\n      }\n    }\n    if (e.key === 'm' || e.key === 'M') {\n      // toggle audio\n      state.audioOn = !state.audioOn;\n      if (state.audioOn) {\n        audioEnabled = true;\n        if (!audioCtx && AudioContextClass) {\n          try {\n            audioCtx = new AudioContextClass();\n          } catch (err) {\n            audioEnabled = false;\n            console.warn('AudioContext creation failed on toggle:', err);\n          }\n        }\n        startBackgroundHum();\n      } else {\n        stopBackgroundHum();\n      }\n      live.textContent = state.audioOn ? 'Audio enabled' : 'Audio disabled';\n      e.preventDefault();\n    }\n\n    // Movement and actions\n    if (e.key === 'ArrowLeft') state.keys.left = true;\n    else if (e.key === 'ArrowRight') state.keys.right = true;\n    else if (e.key === 'ArrowUp') state.keys.up = true;\n    else if (e.key === 'ArrowDown') state.keys.down = true;\n    else if (e.key === ' ') {\n      // scan\n      attemptScan();\n      e.preventDefault();\n    } else if (e.key === 'Enter') {\n      attemptScan();\n    }\n  }\n\n  function onKeyUp(e) {\n    if (e.key === 'ArrowLeft') state.keys.left = false;\n    else if (e.key === 'ArrowRight') state.keys.right = false;\n    else if (e.key === 'ArrowUp') state.keys.up = false;\n    else if (e.key === 'ArrowDown') state.keys.down = false;\n  }\n\n  function onMouseMove(e) {\n    const rect = canvas.getBoundingClientRect();\n    state.mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);\n    state.mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);\n  }\n\n  function onClick(e) {\n    // If on end screen and clicking restart area, restart\n    if (!state.running && (state.win || state.lose)) {\n      const rect = canvas.getBoundingClientRect();\n      const mx = (e.clientX - rect.left) * (canvas.width / rect.width);\n      const my = (e.clientY - rect.top) * (canvas.height / rect.height);\n      // Restart button area calculation\n      const btnW = 180;\n      const btnH = 44;\n      const bx = canvas.width / 2 - btnW / 2;\n      const by = canvas.height / 2 + 40;\n      if (mx >= bx && mx <= bx + btnW && my >= by && my <= by + btnH) {\n        restartGame();\n        safePlayEffect('click');\n        return;\n      }\n    }\n\n    // Click a crate to scan it\n    const rect = canvas.getBoundingClientRect();\n    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);\n    const my = (e.clientY - rect.top) * (canvas.height / rect.height);\n\n    // Check crates\n    for (const crate of state.crates) {\n      if (\n        mx >= crate.x - crate.w / 2 &&\n        mx <= crate.x + crate.w / 2 &&\n        my >= crate.y - crate.h / 2 &&\n        my <= crate.y + crate.h / 2\n      ) {\n        // Move drone to crate visually and attempt scan\n        state.drone.x = crate.x;\n        state.drone.y = crate.y - 90;\n        attemptScan(crate);\n        safePlayEffect('click');\n        break;\n      }\n    }\n  }\n\n  // Attach listeners\n  canvas.addEventListener('keydown', onKeyDown);\n  canvas.addEventListener('keyup', onKeyUp);\n  canvas.addEventListener('mousemove', onMouseMove);\n  canvas.addEventListener('click', onClick);\n  // Also support global key events for convenience\n  window.addEventListener('keydown', onKeyDown);\n  window.addEventListener('keyup', onKeyUp);\n\n  // --- Game logic ---\n  function attemptScan(targetCrate = null) {\n    if (!state.running) return;\n    // Determine which crate is under drone center\n    const droneCenterX = state.drone.x;\n    const droneCenterY = state.drone.y + state.drone.height / 2;\n    let hit = null;\n\n    if (targetCrate) {\n      hit = targetCrate;\n    } else {\n      for (const crate of state.crates) {\n        if (crate.picked) continue;\n        if (\n          droneCenterX >= crate.x - crate.w / 2 &&\n          droneCenterX <= crate.x + crate.w / 2 &&\n          droneCenterY >= crate.y - crate.h / 2 &&\n          droneCenterY <= crate.y + crate.h / 2\n        ) {\n          hit = crate;\n          break;\n        }\n      }\n    }\n\n    if (!hit) {\n      // No crate under drone - small feedback\n      state.flashTimer = 0.18;\n      safePlayEffect('click');\n      live.textContent = 'No crate in range. Move the drone over a crate and press Space.';\n      return;\n    }\n\n    // Evaluate\n    if (hit.value === state.question.answer) {\n      hit.picked = true;\n      state.score += 1;\n      state.flashTimer = 0.25;\n      safePlayEffect('correct');\n      safePlayEffect('pickup');\n      live.textContent = `Correct! ${state.question.a} ${state.question.op} ${state.question.b} = ${state.question.answer}. Score ${state.score}/${CONFIG.goalCorrect}.`;\n      // Animate pickup: move crate up and shrink (handled in draw)\n      setTimeout(() => {\n        // Check win\n        if (state.score >= CONFIG.goalCorrect) {\n          winGame();\n        } else {\n          newQuestion();\n        }\n      }, 450);\n    } else {\n      state.wrong += 1;\n      state.flashTimer = 0.6;\n      safePlayEffect('wrong');\n      live.textContent = `Oops! That was ${hit.value}. Wrong answers: ${state.wrong}/${CONFIG.maxWrong}.`;\n      if (state.wrong >= CONFIG.maxWrong) {\n        loseGame();\n      } else {\n        // brief penalty: move drone back up\n        state.drone.y = clamp(state.drone.y - 20, 60, canvas.height - 60);\n      }\n    }\n  }\n\n  function winGame() {\n    state.running = false;\n    state.win = true;\n    state.lose = false;\n    stopBackgroundHum();\n    safePlayEffect('correct');\n    live.textContent = `You won! Score ${state.score}/${CONFIG.goalCorrect}. Press R or click Restart to play again.`;\n  }\n\n  function loseGame() {\n    state.running = false;\n    state.win = false;\n    state.lose = true;\n    stopBackgroundHum();\n    safePlayEffect('wrong');\n    live.textContent = `Game over. Wrong answers ${state.wrong}/${CONFIG.maxWrong}. Press R or click Restart to play again.`;\n  }\n\n  function restartGame() {\n    state.score = 0;\n    state.wrong = 0;\n    state.running = true;\n    state.win = false;\n    state.lose = false;\n    state.drone.x = canvas.width / 2;\n    state.drone.y = 240;\n    state.drone.vx = 0;\n    state.drone.vy = 0;\n    state.keys = {};\n    state.flashTimer = 0;\n    // Reset audio background if enabled\n    if (state.audioOn && audioEnabled) {\n      startBackgroundHum();\n    }\n    newQuestion();\n    live.textContent = 'Game restarted. Answer the questions to collect 10 correct crates.';\n  }\n\n  // --- Drawing helpers with spacing & background rectangles using measureText ---\n  function drawTextBox(text, x, y, options = {}) {\n    // options: align ('left','center','right'), fontSize, padding, bg, fg\n    const fontSize = options.fontSize || CONFIG.minBodyFont;\n    const font = `${fontSize}px sans-serif`;\n    ctx.font = font;\n    const metrics = ctx.measureText(text);\n    const textW = metrics.width;\n    const padding = options.padding != null ? options.padding : CONFIG.padding;\n    const boxW = textW + padding * 2;\n    const boxH = fontSize + padding * 2;\n    let ax = x;\n    if (options.align === 'center') ax = x - boxW / 2;\n    else if (options.align === 'right') ax = x - boxW;\n    // Draw background\n    if (options.bg !== false) {\n      ctx.fillStyle = options.bg || 'rgba(255,255,255,0.85)';\n      roundRect(ctx, ax, y, boxW, boxH, 6, true, false);\n    }\n    // Draw text\n    ctx.fillStyle = options.fg || '#123';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(text, ax + padding, y + boxH / 2);\n    return { x: ax, y: y, w: boxW, h: boxH };\n  }\n\n  function roundRect(ctx, x, y, w, h, r, fill, stroke) {\n    if (r === undefined) r = 5;\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  // Draw crate\n  function drawCrate(crate, dt) {\n    // crate: x,y,w,h,value,picked\n    const x = crate.x;\n    const y = crate.y;\n    const w = crate.w;\n    const h = crate.h;\n    ctx.save();\n    // If picked, float upward and shrink\n    let localY = y;\n    let scale = 1;\n    if (crate.picked) {\n      const t = (Date.now() % 100000) / 1000;\n      // simple animated upward for a moment\n      localY = y - 40 - Math.min(40, (Date.now() / 6) % 100);\n      scale = 0.7;\n    }\n    // crate base\n    ctx.translate(x, localY);\n    ctx.scale(scale, scale);\n    // crate body\n    ctx.fillStyle = '#C49A6C';\n    roundRect(ctx, -w / 2, -h / 2, w, h, 6, true, false);\n    // crate band\n    ctx.fillStyle = '#7B4F2C';\n    roundRect(ctx, -w / 2 + 6, -h / 10, w - 12, h / 5, 4, true, false);\n    // label background box\n    const label = String(crate.value);\n    ctx.font = '20px sans-serif';\n    const metrics = ctx.measureText(label);\n    const lw = metrics.width + 14;\n    roundRect(ctx, -lw / 2, -10, lw, 26, 4, true, false);\n    ctx.fillStyle = '#123';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(label, -metrics.width / 2, 3);\n    ctx.restore();\n  }\n\n  // Draw drone\n  function drawDrone() {\n    const d = state.drone;\n    const x = d.x;\n    const y = d.y;\n    const w = d.width;\n    const h = d.height;\n    ctx.save();\n    // body\n    ctx.fillStyle = '#8FBFE0';\n    roundRect(ctx, x - w / 2, y - h / 2, w, h, 10, true, false);\n    // propellers - wacky colorful\n    const propSize = 14;\n    const colors = ['#FFD166', '#EF476F', '#06D6A0', '#118AB2'];\n    for (let i = -1; i <= 1; i += 2) {\n      const px = x + i * (w / 2 + 6);\n      const py = y - h / 2 - propSize / 2;\n      ctx.fillStyle = colors[(i + 1) / 2 + 1] || '#FFD166';\n      ctx.beginPath();\n      ctx.arc(px, py, propSize / 2, 0, Math.PI * 2);\n      ctx.fill();\n      // blades\n      ctx.strokeStyle = 'rgba(0,0,0,0.2)';\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(px - propSize / 1.4, py);\n      ctx.lineTo(px + propSize / 1.4, py);\n      ctx.stroke();\n    }\n    // windows\n    ctx.fillStyle = '#06283D';\n    ctx.beginPath();\n    ctx.arc(x + 10, y - 2, 6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n\n    // scanner beam\n    ctx.save();\n    ctx.globalAlpha = 0.22;\n    ctx.fillStyle = '#9AE6B4';\n    const bx = x - 30;\n    const bw = 60;\n    const by = y + h / 2;\n    const bh = 120;\n    ctx.beginPath();\n    ctx.moveTo(x - 8, y + h / 2);\n    ctx.lineTo(x + 8, y + h / 2);\n    ctx.lineTo(x + bw / 2, y + h / 2 + bh);\n    ctx.lineTo(x - bw / 2, y + h / 2 + bh);\n    ctx.closePath();\n    ctx.fill();\n    ctx.restore();\n  }\n\n  // --- Main render loop ---\n  function update(dt) {\n    if (!state.running) {\n      // subtle idle animation\n      state.drone.x += Math.sin(Date.now() / 800) * 0.2;\n      return;\n    }\n    // Movement based on keys and mouse\n    let targetVX = 0;\n    if (state.keys.left) targetVX -= 1;\n    if (state.keys.right) targetVX += 1;\n    // Also keyboard up/down adjust vertical movement slightly\n    let targetVY = 0;\n    if (state.keys.up) targetVY -= 1;\n    if (state.keys.down) targetVY += 1;\n\n    // Smooth velocity\n    const accel = 10;\n    state.drone.vx += (targetVX * state.drone.speed - state.drone.vx) * Math.min(1, accel * dt);\n    state.drone.vy += (targetVY * state.drone.speed - state.drone.vy) * Math.min(1, accel * dt);\n\n    // Mouse guiding if mouse near top half: subtle attraction to mouse x\n    if (canvas === document.activeElement) {\n      // only when canvas focused\n      const dx = state.mouse.x - state.drone.x;\n      state.drone.vx += dx * 0.002;\n    }\n\n    // Update positions\n    state.drone.x += state.drone.vx * dt;\n    state.drone.y += state.drone.vy * dt;\n\n    // Boundaries\n    state.drone.x = clamp(state.drone.x, state.drone.width / 2 + 10, canvas.width - state.drone.width / 2 - 10);\n    state.drone.y = clamp(state.drone.y, 60, CONFIG.crateY - 70);\n\n    // Update crate animations if picked\n    for (const crate of state.crates) {\n      if (crate.picked) {\n        crate.y -= 60 * dt;\n        crate.w *= 0.995;\n        crate.h *= 0.995;\n      }\n    }\n\n    // Flash timer reduce\n    if (state.flashTimer > 0) state.flashTimer = Math.max(0, state.flashTimer - dt);\n  }\n\n  function draw() {\n    // Clear background - calming gradient sky\n    const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);\n    grad.addColorStop(0, '#E8F6FF');\n    grad.addColorStop(0.6, '#F7FFF7');\n    ctx.fillStyle = grad;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // Decorative wacky elements - floating balloons/drones\n    for (let i = 0; i < 6; i++) {\n      const bx = (i * 137 + Date.now() / 40) % canvas.width;\n      const by = 40 + (i % 3) * 16 + Math.sin((Date.now() / 1000) + i) * 8;\n      ctx.globalAlpha = 0.25;\n      ctx.fillStyle = ['#FFDDE2', '#E0FFE6', '#E9F5FF'][i % 3];\n      ctx.beginPath();\n      ctx.ellipse(bx, by, 22, 12, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.globalAlpha = 1;\n    }\n\n    // UI Layout with strict non-overlapping positions\n    // Score top-left\n    ctx.font = `${CONFIG.importantFont}px sans-serif`;\n    const scoreText = `Score: ${state.score}/${CONFIG.goalCorrect}`;\n    const scoreBox = drawTextBox(scoreText, CONFIG.padding, CONFIG.padding, {\n      align: 'left',\n      fontSize: CONFIG.importantFont,\n      padding: 12,\n      bg: 'rgba(255,255,255,0.9)',\n      fg: '#0A2749',\n    });\n\n    // Audio icon top-center\n    const audioText = state.audioOn ? 'Audio: On (M to toggle)' : 'Audio: Off (M to toggle)';\n    ctx.font = `${16}px sans-serif`;\n    const audioMetrics = ctx.measureText(audioText);\n    const audioBoxW = audioMetrics.width + 16 + 24; // icon width\n    const audioX = canvas.width / 2 - audioBoxW / 2;\n    const audioY = CONFIG.padding;\n    // background\n    ctx.fillStyle = 'rgba(255,255,255,0.9)';\n    roundRect(ctx, audioX, audioY, audioBoxW, 36, 8, true, false);\n    // icon\n    ctx.fillStyle = state.audioOn ? '#2E8B57' : '#B23A48';\n    ctx.fillRect(audioX + 6, audioY + 8, 20, 20);\n    ctx.fillStyle = '#06283D';\n    ctx.font = '14px sans-serif';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(audioText, audioX + 34, audioY + 18);\n\n    // Lives top-right\n    ctx.font = `${CONFIG.importantFont}px sans-serif`;\n    const livesLeft = Math.max(0, CONFIG.maxWrong - state.wrong);\n    const livesText = `Lives: ${livesLeft}`;\n    const livesMetrics = ctx.measureText(livesText);\n    const livesBoxW = livesMetrics.width + 24;\n    const livesX = canvas.width - CONFIG.padding - livesBoxW;\n    const livesY = CONFIG.padding;\n    ctx.fillStyle = 'rgba(255,255,255,0.9)';\n    roundRect(ctx, livesX, livesY, livesBoxW, 36, 8, true, false);\n    ctx.fillStyle = '#06283D';\n    ctx.fillText(livesText, livesX + 12, livesY + 22);\n\n    // Question top-center, below audio\n    ctx.font = `${20}px sans-serif`;\n    const qText = state.question ? `Question: ${state.question.a} ${state.question.op} ${state.question.b} = ?` : 'Loading...';\n    const qBox = drawTextBox(qText, canvas.width / 2, 70, {\n      align: 'center',\n      fontSize: 20,\n      padding: 12,\n      bg: 'rgba(255,255,255,0.95)',\n      fg: '#06283D',\n    });\n\n    // Draw drone\n    drawDrone();\n\n    // Draw crates\n    for (const crate of state.crates) {\n      drawCrate(crate);\n    }\n\n    // Instructions bottom-center\n    const instr = 'Controls: Arrow keys to move, Space or Enter to scan a crate. Click a crate to move over it. Reach 10 correct answers. Press M to toggle audio.';\n    ctx.font = `${CONFIG.minBodyFont}px sans-serif`;\n    // Break into lines to avoid overlap. We'll wrap roughly to width 640.\n    const wrapWidth = 640;\n    const words = instr.split(' ');\n    let line = '';\n    const lines = [];\n    for (const word of words) {\n      const test = line ? line + ' ' + word : word;\n      const w = ctx.measureText(test).width;\n      if (w > wrapWidth) {\n        lines.push(line);\n        line = word;\n      } else {\n        line = test;\n      }\n    }\n    if (line) lines.push(line);\n    // Draw background rectangle big enough\n    const lineHeight = CONFIG.minBodyFont + 8;\n    const boxH = lines.length * lineHeight + 20;\n    const boxW = wrapWidth + 24;\n    const bx = canvas.width / 2 - boxW / 2;\n    const by = canvas.height - boxH - 16;\n    ctx.fillStyle = 'rgba(255,255,255,0.9)';\n    roundRect(ctx, bx, by, boxW, boxH, 10, true, false);\n    ctx.fillStyle = '#06283D';\n    ctx.textBaseline = 'top';\n    for (let i = 0; i < lines.length; i++) {\n      ctx.fillText(lines[i], bx + 12, by + 10 + i * lineHeight);\n    }\n\n    // If flashTimer active, overlay flash\n    if (state.flashTimer > 0) {\n      ctx.globalAlpha = Math.min(0.5, state.flashTimer * 2);\n      ctx.fillStyle = '#FFFBCC';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n      ctx.globalAlpha = 1;\n    }\n\n    // End screens\n    if (!state.running && (state.win || state.lose)) {\n      // Dim background\n      ctx.fillStyle = 'rgba(10,10,10,0.36)';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n      // Message box\n      const title = state.win ? 'Victory!' : 'Game Over';\n      ctx.font = `${36}px sans-serif`;\n      const titleMetrics = ctx.measureText(title);\n      const msg = state.win ? `You collected ${state.score} correct crates!` : `You made ${state.wrong} wrong answers.`;\n      ctx.font = `${22}px sans-serif`;\n      const msgMetrics = ctx.measureText(msg);\n      const boxW = Math.max(titleMetrics.width, msgMetrics.width) + 80;\n      const boxH = 160;\n      const bx2 = canvas.width / 2 - boxW / 2;\n      const by2 = canvas.height / 2 - boxH / 2;\n      ctx.fillStyle = 'rgba(255,255,255,0.98)';\n      roundRect(ctx, bx2, by2, boxW, boxH, 12, true, false);\n      ctx.fillStyle = '#06283D';\n      ctx.font = '36px sans-serif';\n      ctx.textBaseline = 'top';\n      ctx.fillText(title, canvas.width / 2 - ctx.measureText(title).width / 2, by2 + 16);\n      ctx.font = '20px sans-serif';\n      ctx.fillText(msg, canvas.width / 2 - ctx.measureText(msg).width / 2, by2 + 64);\n      // Restart button\n      const btnW = 180;\n      const btnH = 44;\n      const bxbtn = canvas.width / 2 - btnW / 2;\n      const bybtn = by2 + boxH - 56;\n      ctx.fillStyle = '#2E8B57';\n      roundRect(ctx, bxbtn, bybtn, btnW, btnH, 8, true, false);\n      ctx.fillStyle = '#fff';\n      ctx.font = '20px sans-serif';\n      ctx.fillText('Restart (R)', canvas.width / 2 - ctx.measureText('Restart (R)').width / 2, bybtn + 12);\n    }\n\n    // Ensure alpha reset\n    ctx.globalAlpha = 1;\n  }\n\n  // --- Main loop ---\n  function loop(timestamp) {\n    if (!state.lastTime) state.lastTime = timestamp;\n    const dt = Math.min(0.05, (timestamp - state.lastTime) / 1000); // clamp dt\n    state.lastTime = timestamp;\n\n    update(dt);\n    draw();\n\n    requestAnimationFrame(loop);\n  }\n\n  // Start game\n  try {\n    newQuestion();\n    if (state.audioOn && audioEnabled && audioCtx) {\n      // Start background hum when user interacts; resume on initial click or keypress\n      // We'll try to resume immediately; browsers require user gesture, so we attach one-time handler.\n      function resumeAudioOnGesture() {\n        if (audioCtx && audioCtx.state === 'suspended') {\n          audioCtx.resume().then(() => {\n            startBackgroundHum();\n          }).catch(() => {\n            // ignore\n          });\n        } else {\n          startBackgroundHum();\n        }\n        window.removeEventListener('pointerdown', resumeAudioOnGesture);\n        window.removeEventListener('keydown', resumeAudioOnGesture);\n      }\n      window.addEventListener('pointerdown', resumeAudioOnGesture);\n      window.addEventListener('keydown', resumeAudioOnGesture);\n    }\n    requestAnimationFrame(loop);\n  } catch (e) {\n    console.error('Game start error:', e);\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = '#fff';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = '#000';\n    ctx.font = '18px sans-serif';\n    ctx.fillText('An error occurred starting the game. Please try reloading.', 20, 40);\n  }\n\n  // Expose restart to console for debugging\n  window.__droneMathRestart = restartGame;\n})();\n---\n",
  "improve_response_tokens": 19736,
  "formatted_code": true,
  "formatting_response_tokens": 21855,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}