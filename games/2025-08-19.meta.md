# Game of the Day - 2025-08-19

## Metadata
- **Generated Date:** 2025-08-19
- **Generated Time:** 2025-08-19T03:16:47.065267
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-19.js
- **File Size:** 24001 bytes
- **Tokens Used:** 8975

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-19.js` - The playable game
- `2025-08-19.meta.json` - Machine-readable metadata
- `2025-08-19.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 17860

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 19768

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Electricity Math Game for ages 7-9
  // Render entirely inside element with ID 'game-of-the-day-stage'
  // Uses canvas for visuals and Web Audio API for sounds (no external resources)
  // Accessible: keyboard controls, aria labels, on-screen instructions, audio visual cue

  // --- Configuration ---
  const WIDTH = 720;
  const HEIGHT = 480;
  const BATTERY_COUNT = 6;
  const TARGET_MIN = 5;
  const TARGET_MAX = 12;
  const CHAR_COLORS = { sparky: '#FFB86B', amp: '#FFF39A', bolt: '#A0E7E5' };
  const BG_COLOR = '#0B1020';
  const TEXT_COLOR = '#E6F0FF';

  // --- Container and Canvas Setup ---
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Game container element with id "game-of-the-day-stage" not found.');
    return;
  }
  container.innerHTML = '';
  container.style.fontFamily = 'sans-serif';

  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.tabIndex = 0; // focusable for keyboard
  canvas.setAttribute('role', 'application');
  canvas.setAttribute('aria-label', 'Power-Up Math: connect batteries to charge the bulb. Keyboard controls available.');
  canvas.style.outline = 'none';
  container.appendChild(canvas);

  // Hidden live region for screen reader updates
  const srLive = document.createElement('div');
  srLive.setAttribute('aria-live', 'polite');
  srLive.style.position = 'absolute';
  srLive.style.left = '-9999px';
  container.appendChild(srLive);

  const ctx = canvas.getContext('2d');

  // --- Audio Setup and Utilities ---
  let audioCtx = null;
  let masterGain = null;
  let backgroundGain = null;
  let backgroundOsc = null;
  let audioEnabled = true;
  let audioAvailable = true;

  function initAudioIfNeeded() {
    if (audioCtx) return;
    try {
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AudioCtx();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.9;
      masterGain.connect(audioCtx.destination);

      // gentle background hum
      backgroundGain = audioCtx.createGain();
      backgroundGain.gain.value = 0.05;
      backgroundGain.connect(masterGain);

      backgroundOsc = audioCtx.createOscillator();
      backgroundOsc.type = 'sine';
      backgroundOsc.frequency.value = 110; // low hum
      const bgFilter = audioCtx.createBiquadFilter();
      bgFilter.type = 'lowpass';
      bgFilter.frequency.value = 900;
      backgroundOsc.connect(bgFilter);
      bgFilter.connect(backgroundGain);
      backgroundOsc.start();

      // start muted: will be audible only if audioEnabled true
      updateAudioGain();
    } catch (err) {
      console.warn('AudioContext unavailable:', err);
      audioAvailable = false;
      audioCtx = null;
    }
  }

  function updateAudioGain() {
    if (!masterGain) return;
    masterGain.gain.value = audioEnabled ? 0.9 : 0.0;
  }

  function safeResumeAudio() {
    if (!audioCtx) return;
    if (typeof audioCtx.resume === 'function') {
      audioCtx.resume().catch((e) => {
        console.warn('Audio resume failed:', e);
      });
    }
  }

  // play a short tone with envelope
  function playTone(frequency, type = 'sine', duration = 0.18, gain = 0.12) {
    if (!audioAvailable) return;
    try {
      initAudioIfNeeded();
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 1200;
      osc.type = type;
      osc.frequency.value = frequency;
      g.gain.setValueAtTime(0.0001, audioCtx.currentTime);
      g.gain.exponentialRampToValueAtTime(gain, audioCtx.currentTime + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
      osc.connect(filter);
      filter.connect(g);
      g.connect(masterGain);
      osc.start();
      osc.stop(audioCtx.currentTime + duration + 0.05);
    } catch (err) {
      console.warn('playTone error:', err);
    }
  }

  function playCorrect() {
    if (!audioAvailable) return;
    try {
      initAudioIfNeeded();
      safeResumeAudio();
      // simple arpeggio
      playTone(880, 'triangle', 0.12, 0.12);
      setTimeout(() => playTone(1100, 'sine', 0.12, 0.14), 90);
      setTimeout(() => playTone(1320, 'sine', 0.18, 0.16), 180);
    } catch (err) {
      console.warn('playCorrect error:', err);
    }
  }

  function playWrong() {
    if (!audioAvailable) return;
    try {
      initAudioIfNeeded();
      safeResumeAudio();
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = 'square';
      osc.frequency.value = 220;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.18, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);
      osc.connect(g);
      g.connect(masterGain);
      osc.start();
      osc.frequency.setValueAtTime(220, now);
      osc.frequency.linearRampToValueAtTime(80, now + 0.45);
      osc.stop(now + 0.55);
    } catch (err) {
      console.warn('playWrong error:', err);
    }
  }

  function playClick() {
    playTone(600, 'sine', 0.08, 0.08);
  }

  // --- Game State ---
  let batteries = []; // {x,y,r,value,selected,index}
  let targetNumber = 0;
  let selectedSum = 0;
  let score = 0;
  let round = 0;
  let message = 'Click batteries or use arrow keys and Enter. Press C to check.';
  let shakeTimer = 0;
  let sparkles = [];
  let keyIndex = 0; // keyboard highlight index
  let muteIconPulse = 0;

  // --- Utility functions ---
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  // Create a battery values list that guarantees at least one subset sums to target
  function generateValuesForTarget(target) {
    // Choose how many items in valid subset (1 to 3)
    const subsetCount = randInt(1, Math.min(3, BATTERY_COUNT));
    let remain = target;
    const subset = [];
    for (let i = 0; i < subsetCount; i++) {
      const maxAllow = Math.min(6, remain - (subsetCount - i - 1) * 1);
      const val = randInt(1, Math.max(1, maxAllow));
      subset.push(val);
      remain -= val;
    }
    // If remain > 0 add to last
    if (remain > 0) {
      subset[subset.length - 1] += remain;
    }
    // Fill remaining batteries
    const values = subset.slice();
    while (values.length < BATTERY_COUNT) {
      values.push(randInt(1, 6));
    }
    shuffle(values);
    return values;
  }

  // Generate a round (target and battery positions)
  function newRound() {
    round += 1;
    targetNumber = randInt(TARGET_MIN, TARGET_MAX);
    const values = generateValuesForTarget(targetNumber);
    batteries = [];
    const padding = 30;
    const areaLeft = 140; // left area reserved for character
    const gridCols = 3;
    const gridRows = 2;
    const cellW = (WIDTH - areaLeft - padding * 2) / gridCols;
    const cellH = (HEIGHT - padding * 2) / gridRows;
    let i = 0;
    for (let r = 0; r < gridRows; r++) {
      for (let c = 0; c < gridCols; c++) {
        const x = areaLeft + padding + c * cellW + cellW / 2;
        const y = padding + r * cellH + cellH / 2;
        const b = {
          x,
          y,
          r: 26,
          value: values[i],
          selected: false,
          index: i,
          id: i,
        };
        batteries.push(b);
        i++;
      }
    }
    selectedSum = 0;
    keyIndex = 0;
    message = 'Power up the bulb to reach ' + targetNumber + '. Select batteries to add.';
    srLive.textContent = `Round ${round}. Target ${targetNumber}. ${message}`;
  }

  // Validate if subset equals target (used when checking)
  function checkSelection() {
    if (selectedSum === targetNumber) {
      score += 1;
      message = 'Perfect! Amp is charged!';
      playCorrect();
      spawnSparkles(batteries.filter((b) => b.selected));
      setTimeout(() => {
        newRound();
      }, 1100);
    } else {
      message = `Not quite. Sum is ${selectedSum}. Try again.`;
      playWrong();
      shakeTimer = 20;
    }
    srLive.textContent = message;
  }

  function toggleBatterySelection(index) {
    const b = batteries[index];
    if (!b) return;
    b.selected = !b.selected;
    recalcSum();
    playClick();
    srLive.textContent = `Battery ${index + 1} is now ${b.selected ? 'selected' : 'deselected'}. Sum is ${selectedSum}.`;
  }

  function recalcSum() {
    selectedSum = batteries.reduce((s, b) => s + (b.selected ? b.value : 0), 0);
  }

  // Sparkle effect on correct
  function spawnSparkles(targetBatteries) {
    for (let i = 0; i < 12; i++) {
      const b = targetBatteries[i % targetBatteries.length] || batteries[0];
      sparkles.push({
        x: b.x + randInt(-10, 10),
        y: b.y + randInt(-10, 10),
        vx: (Math.random() - 0.5) * 3,
        vy: -Math.random() * 3 - 1,
        life: randInt(40, 80),
        color: '#FFF7A1',
        size: randInt(2, 5),
      });
    }
  }

  // --- Drawing Functions ---
  function drawBackground() {
    // gradient sky
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#091233');
    g.addColorStop(1, '#0F1A2B');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // wacky glowing shapes (no images)
    for (let i = 0; i < 4; i++) {
      ctx.beginPath();
      ctx.fillStyle = i % 2 === 0 ? 'rgba(160,231,229,0.06)' : 'rgba(255,184,107,0.04)';
      const cx = 80 + i * 160 + (Math.sin(Date.now() / 1000 + i) * 12);
      const cy = 60 + (Math.cos(Date.now() / 1200 + i) * 8);
      ctx.ellipse(cx, cy, 120, 40, Math.sin(i) * 0.5, 0, Math.PI * 2);
      ctx.fill();
    }

    // faint grid lines to feel technical
    ctx.strokeStyle = 'rgba(255,255,255,0.02)';
    ctx.lineWidth = 1;
    for (let x = 0; x < WIDTH; x += 40) {
      ctx.beginPath();
      ctx.moveTo(x + (Date.now() / 1200) % 40, 0);
      ctx.lineTo(x + (Date.now() / 1200) % 40, HEIGHT);
      ctx.stroke();
    }
  }

  function drawCharacters() {
    // Sparky the Squirrel electrician left
    const sparkyX = 80;
    const sparkyY = 200;
    ctx.save();
    // body
    ctx.fillStyle = CHAR_COLORS.sparky;
    ctx.beginPath();
    ctx.ellipse(sparkyX, sparkyY, 52, 66, 0.2, 0, Math.PI * 2);
    ctx.fill();
    // tail wacky
    ctx.fillStyle = '#FF7A59';
    ctx.beginPath();
    ctx.ellipse(sparkyX - 50, sparkyY - 10, 24, 42, -0.6, 0, Math.PI * 2);
    ctx.fill();
    // eyes
    ctx.fillStyle = '#111';
    ctx.beginPath();
    ctx.arc(sparkyX + 14, sparkyY - 10, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(sparkyX - 6, sparkyY - 6, 5, 0, Math.PI * 2);
    ctx.fill();
    // helmet
    ctx.fillStyle = '#C6E4FF';
    ctx.fillRect(sparkyX - 34, sparkyY - 52, 68, 16);
    ctx.restore();

    // Amp the Bulb center-top
    const ampX = WIDTH - 170;
    const ampY = 110;
    ctx.save();
    // bulb body
    const bulbLight = Math.max(0.2, selectedSum / Math.max(targetNumber, 1));
    const bulbGlow = 0.1 + bulbLight * 0.6;
    const bulbColor = `rgba(255,244,150,${0.8})`;
    ctx.beginPath();
    ctx.fillStyle = bulbColor;
    ctx.ellipse(ampX, ampY, 38 + bulbLight * 8, 50 + bulbLight * 10, 0, 0, Math.PI * 2);
    ctx.fill();
    // filament simple
    ctx.strokeStyle = '#FFB84D';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(ampX - 8, ampY);
    ctx.quadraticCurveTo(ampX, ampY + 8, ampX + 8, ampY);
    ctx.stroke();
    // base
    ctx.fillStyle = '#9AA6B2';
    ctx.fillRect(ampX - 22, ampY + 45, 44, 12);
    // eyes
    ctx.fillStyle = '#111';
    ctx.beginPath();
    ctx.arc(ampX - 12, ampY - 4, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(ampX + 8, ampY - 6, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // Bolt the Cloud top-left wacky
    const boltX = WIDTH - 90;
    const boltY = HEIGHT - 70;
    ctx.save();
    ctx.fillStyle = CHAR_COLORS.bolt;
    ctx.beginPath();
    ctx.ellipse(boltX, boltY, 60, 32, 0.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#B4FFF7';
    ctx.beginPath();
    ctx.ellipse(boltX - 30, boltY - 10, 30, 18, 0.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.fillStyle = '#111';
    ctx.fillRect(boltX - 16, boltY - 8, 8, 6);
    ctx.restore();
  }

  function drawBattery(b) {
    // shadow
    ctx.beginPath();
    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    ctx.ellipse(b.x + 6, b.y + 18, b.r + 8, 10, 0, 0, Math.PI * 2);
    ctx.fill();

    // battery body
    ctx.save();
    ctx.translate(b.x, b.y);
    // main body
    const bodyW = b.r * 1.8;
    const bodyH = b.r * 1.1;
    ctx.fillStyle = b.selected ? '#FFD86B' : '#CFE9FF';
    ctx.beginPath();
    ctx.roundRect(-bodyW / 2, -bodyH / 2, bodyW, bodyH, 8);
    ctx.fill();
    // top terminal
    ctx.fillStyle = '#B0C6FF';
    ctx.fillRect(-12, -bodyH / 2 - 10, 24, 10);
    // number
    ctx.fillStyle = '#07203E';
    ctx.font = 'bold 18px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(String(b.value), 0, 0);
    ctx.restore();

    // highlight when keyboard selected
    if (b.index === keyIndex) {
      ctx.strokeStyle = 'rgba(255,255,255,0.6)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.ellipse(b.x, b.y, b.r + 8, b.r + 8, 0, 0, Math.PI * 2);
      ctx.stroke();
    }

    // show small bolt line if selected
    if (b.selected) {
      ctx.strokeStyle = '#FFF29B';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(b.x + 6, b.y - 6);
      ctx.lineTo(b.x - 6, b.y + 2);
      ctx.lineTo(b.x + 6, b.y + 2);
      ctx.stroke();
    }
  }

  function drawConnections() {
    // draw zigzag wires from selected batteries to bulb
    const bulbX = WIDTH - 170;
    const bulbY = 110;
    batteries.forEach((b) => {
      if (!b.selected) return;
      ctx.save();
      ctx.strokeStyle = '#FFF99C';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(b.x, b.y + 18);
      // create a zigzag path
      const midX = (b.x + bulbX) / 2 + (Math.sin(b.index + Date.now() / 200) * 10);
      const midY = (b.y + bulbY) / 2 + (Math.cos(b.index + Date.now() / 300) * 6);
      ctx.lineTo(midX - 10, midY - 6);
      ctx.lineTo(midX + 10, midY + 6);
      ctx.lineTo(bulbX - 10, bulbY + 30);
      ctx.stroke();
      ctx.restore();
    });
  }

  function drawHUD() {
    // top bar
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    ctx.fillRect(0, 0, WIDTH, 46);
    // target
    ctx.fillStyle = TEXT_COLOR;
    ctx.font = 'bold 22px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`Target: ${targetNumber}`, 18, 30);
    ctx.font = '16px sans-serif';
    ctx.fillStyle = '#A9C2E6';
    ctx.fillText(`Sum: ${selectedSum}`, 150, 30);
    ctx.fillText(`Score: ${score}`, 250, 30);
    ctx.fillText(`Round: ${round}`, 340, 30);

    // instructions
    ctx.font = '13px sans-serif';
    ctx.fillStyle = '#C9E0FF';
    ctx.fillText(message, 18, HEIGHT - 18);

    // audio icon (visual cue)
    const iconX = WIDTH - 48;
    const iconY = 18;
    ctx.save();
    // box
    ctx.beginPath();
    ctx.fillStyle = audioAvailable ? (audioEnabled ? '#9EE6A1' : '#FFD6A5') : '#666';
    ctx.roundRect(iconX - 18, iconY - 12, 36, 24, 6);
    ctx.fill();
    // speaker glyph
    ctx.fillStyle = '#1A2230';
    ctx.beginPath();
    ctx.moveTo(iconX - 8, iconY + 6);
    ctx.lineTo(iconX - 2, iconY + 6);
    ctx.lineTo(iconX + 2, iconY + 12);
    ctx.lineTo(iconX + 2, iconY - 12);
    ctx.lineTo(iconX - 2, iconY - 6);
    ctx.lineTo(iconX - 8, iconY - 6);
    ctx.closePath();
    ctx.fill();
    // waves for sound on
    if (audioAvailable && audioEnabled) {
      ctx.strokeStyle = '#1A2230';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(iconX + 6, iconY - 2, 8 + Math.sin(muteIconPulse) * 1.8, -0.7, 0.7);
      ctx.stroke();
    } else if (audioAvailable && !audioEnabled) {
      ctx.strokeStyle = '#1A2230';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(iconX + 8, iconY - 10);
      ctx.lineTo(iconX - 8, iconY + 10);
      ctx.stroke();
    } else {
      ctx.fillStyle = '#333';
      ctx.font = '10px sans-serif';
      ctx.fillText('NoAudio', iconX - 16, iconY + 4);
    }
    ctx.restore();
  }

  function drawSparkles() {
    for (let i = sparkles.length - 1; i >= 0; i--) {
      const s = sparkles[i];
      ctx.fillStyle = s.color;
      ctx.globalAlpha = Math.max(0, s.life / 80);
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      s.x += s.vx;
      s.y += s.vy;
      s.vy += 0.08;
      s.life -= 1;
      if (s.life <= 0) sparkles.splice(i, 1);
    }
  }

  // --- Main Render Loop ---
  function render() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    if (shakeTimer > 0) {
      const shakeX = Math.sin(shakeTimer * 3) * 6;
      ctx.save();
      ctx.translate(shakeX, 0);
    }

    drawBackground();
    drawCharacters();

    // draw batteries and connections
    drawConnections();
    batteries.forEach(drawBattery);
    drawSparkles();

    if (shakeTimer > 0) {
      ctx.restore();
      shakeTimer--;
    }

    drawHUD();

    // draw check button hint
    ctx.font = '12px sans-serif';
    ctx.fillStyle = '#E8F4FF';
    ctx.textAlign = 'right';
    ctx.fillText('Keys: Arrow keys / Enter select, C check, M mute, R reset', WIDTH - 10, HEIGHT - 10);

    muteIconPulse += 0.12;
    requestAnimationFrame(render);
  }

  // --- Input Handling ---
  function getBatteryAt(x, y) {
    for (const b of batteries) {
      const dx = x - b.x;
      const dy = y - b.y;
      if (dx * dx + dy * dy <= (b.r + 8) * (b.r + 8)) return b;
    }
    return null;
  }

  canvas.addEventListener('pointerdown', (ev) => {
    ev.preventDefault();
    // ensure audio initialised on user gesture
    try {
      initAudioIfNeeded();
      safeResumeAudio();
    } catch (e) {
      // handled elsewhere
    }
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;
    // if clicked on audio icon?
    const iconX = WIDTH - 48;
    const iconY = 18;
    if (x >= iconX - 18 && x <= iconX + 18 && y >= iconY - 12 && y <= iconY + 12) {
      if (audioAvailable) {
        audioEnabled = !audioEnabled;
        updateAudioGain();
        playClick();
        message = audioEnabled ? 'Audio on' : 'Audio off';
        srLive.textContent = message;
      } else {
        message = 'Audio not available on this device.';
        srLive.textContent = message;
      }
      return;
    }

    const b = getBatteryAt(x, y);
    if (b) {
      toggleBatterySelection(b.index);
    } else {
      // clicking other area toggles nothing but plays a click
      playClick();
    }
  });

  // keyboard controls
  canvas.addEventListener('keydown', (ev) => {
    if (ev.key === 'ArrowRight' || ev.key === 'ArrowDown') {
      keyIndex = (keyIndex + 1) % batteries.length;
      playClick();
      recalcSum();
      ev.preventDefault();
    } else if (ev.key === 'ArrowLeft' || ev.key === 'ArrowUp') {
      keyIndex = (keyIndex - 1 + batteries.length) % batteries.length;
      playClick();
      recalcSum();
      ev.preventDefault();
    } else if (ev.key === 'Enter' || ev.key === ' ') {
      toggleBatterySelection(keyIndex);
      ev.preventDefault();
    } else if (ev.key.toLowerCase() === 'c') {
      checkSelection();
      ev.preventDefault();
    } else if (ev.key.toLowerCase() === 'r') {
      newRound();
      playClick();
      ev.preventDefault();
    } else if (ev.key.toLowerCase() === 'm') {
      if (audioAvailable) {
        audioEnabled = !audioEnabled;
        updateAudioGain();
        playClick();
        message = audioEnabled ? 'Audio on' : 'Audio off';
        srLive.textContent = message;
      }
      ev.preventDefault();
    }
  });

  // focus handling for keyboard users
  canvas.addEventListener('focus', () => {
    canvas.style.boxShadow = '0 0 6px rgba(200,230,255,0.4)';
  });
  canvas.addEventListener('blur', () => {
    canvas.style.boxShadow = 'none';
  });

  // Provide accessible start button inside canvas (drawn) - but require first click to begin audio on some browsers
  // initial prompt overlay until user interacts (click or key)
  let waitingForInteraction = true;
  function drawStartOverlay() {
    ctx.fillStyle = 'rgba(4,6,12,0.75)';
    ctx.fillRect(40, 70, WIDTH - 80, HEIGHT - 140);
    ctx.fillStyle = '#FFF';
    ctx.font = 'bold 26px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Power-Up Math!', WIDTH / 2, HEIGHT / 2 - 40);
    ctx.font = '16px sans-serif';
    ctx.fillText('Help Sparky connect batteries to charge Amp the Bulb.', WIDTH / 2, HEIGHT / 2 - 10);
    ctx.font = '14px sans-serif';
    ctx.fillText('Select batteries so their numbers add up to the target.', WIDTH / 2, HEIGHT / 2 + 18);
    ctx.fillStyle = '#F3F5FF';
    ctx.fillRect(WIDTH / 2 - 80, HEIGHT / 2 + 40, 160, 40);
    ctx.fillStyle = '#0A1220';
    ctx.font = 'bold 16px sans-serif';
    ctx.fillText('Click to Start', WIDTH / 2, HEIGHT / 2 + 68);
    ctx.font = '12px sans-serif';
    ctx.fillStyle = '#E0E8F9';
    ctx.fillText('Keyboard: Arrows+Enter, C=Check, M=Mute, R=Reset', WIDTH / 2, HEIGHT / 2 + 110);
  }

  // Listen for first interaction to initialize audio and start
  function onFirstInteraction() {
    if (!waitingForInteraction) return;
    try {
      initAudioIfNeeded();
      safeResumeAudio();
    } catch (e) {
      // ignore
    }
    waitingForInteraction = false;
    // slight welcome sound
    playTone(520, 'sine', 0.12, 0.08);
    canvas.removeEventListener('pointerdown', onFirstInteraction);
    canvas.removeEventListener('keydown', onFirstInteraction);
    // start game
    newRound();
    requestAnimationFrame(render);
  }

  canvas.addEventListener('pointerdown', onFirstInteraction);
  canvas.addEventListener('keydown', onFirstInteraction);

  // Add helpful instructions if audio fails
  if (!window.AudioContext && !window.webkitAudioContext) {
    audioAvailable = false;
    message = 'Audio not supported in this browser. Use keyboard or mouse to play.';
    srLive.textContent = message;
  }

  // Canvas polyfill for roundRect in older browsers
  if (typeof CanvasRenderingContext2D.prototype.roundRect !== 'function') {
    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
      if (typeof r === 'number') r = { tl: r, tr: r, br: r, bl: r };
      else {
        var defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };
        for (var side in defaultRadius) {
          r[side] = r[side] || defaultRadius[side];
        }
      }
      this.beginPath();
      this.moveTo(x + r.tl, y);
      this.lineTo(x + w - r.tr, y);
      this.quadraticCurveTo(x + w, y, x + w, y + r.tr);
      this.lineTo(x + w, y + h - r.br);
      this.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
      this.lineTo(x + r.bl, y + h);
      this.quadraticCurveTo(x, y + h, x, y + h - r.bl);
      this.lineTo(x, y + r.tl);
      this.quadraticCurveTo(x, y, x + r.tl, y);
      this.closePath();
    };
  }

  // Initial draw while waiting for interaction
  function initialDrawLoop() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    drawBackground();
    drawCharacters();
    batteries.forEach(drawBattery);
    drawHUD();
    drawStartOverlay();
    requestAnimationFrame(initialDrawLoop);
  }
  initialDrawLoop();

  // Ensure keyboard focus
  setTimeout(() => {
    try {
      canvas.focus();
    } catch (e) {}
  }, 300);

  // Expose some state for debugging in console (safe)
  window.powerUpMath = {
    newRound,
    toggleAudio: () => {
      if (!audioAvailable) return;
      audioEnabled = !audioEnabled;
      updateAudioGain();
    },
  };
})();
---

