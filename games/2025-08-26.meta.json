{
  "generated_date": "2025-08-26",
  "generated_timestamp": "2025-08-26T00:27:57.328774",
  "model": "gpt-5-mini",
  "theme": "electricity",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 10187,
  "game_filename": "2025-08-26.js",
  "game_size_bytes": 31380,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Electricity Math Game for ages 7-9\n// Renders into element with id \"game-of-the-day-stage\" as a 720x480 canvas\n// Uses Web Audio API for sounds. All graphics drawn with canvas.\n// Accessible: keyboard controls, canvas ARIA label, visual audio cues, instructions.\n\n(function () {\n  'use strict';\n\n  // --- Setup DOM and Canvas ---\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Game container element with id \"game-of-the-day-stage\" not found.');\n    return;\n  }\n  // Clear container and create canvas\n  container.innerHTML = '';\n  const canvas = document.createElement('canvas');\n  canvas.width = 720;\n  canvas.height = 480;\n  canvas.tabIndex = 0; // make focusable\n  canvas.setAttribute('role', 'img');\n  canvas.setAttribute(\n    'aria-label',\n    'Electricity math game. Drag numbered charges to lamps to match a target. Use mouse or keyboard. Press space to pick up or drop a charge. Click enable sound to play audio.'\n  );\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Some constants\n  const GAME_W = 720;\n  const GAME_H = 480;\n\n  // Accessibility text area (drawn in canvas) - also store messages\n  let accessibilityMessage = 'Welcome! Use mouse or keyboard. Press space to pick up/drop charges.';\n\n  // --- Audio Setup with error handling ---\n  let audioCtx = null;\n  let masterGain = null;\n  let backgroundGain = null;\n  let soundEnabled = false;\n  let bgOsc = null;\n  // Simple function to safely create audio context on user gesture\n  function tryCreateAudioContext() {\n    if (audioCtx) return audioCtx;\n    try {\n      const AudioCtx = window.AudioContext || window.webkitAudioContext;\n      if (!AudioCtx) throw new Error('Web Audio API not supported');\n      audioCtx = new AudioCtx();\n      masterGain = audioCtx.createGain();\n      masterGain.gain.value = 0.9;\n      masterGain.connect(audioCtx.destination);\n\n      // Background gentle hum\n      backgroundGain = audioCtx.createGain();\n      backgroundGain.gain.value = 0.06;\n      backgroundGain.connect(masterGain);\n\n      bgOsc = audioCtx.createOscillator();\n      bgOsc.type = 'sine';\n      bgOsc.frequency.value = 52; // low hum\n      const bgLfo = audioCtx.createOscillator();\n      bgLfo.type = 'sine';\n      bgLfo.frequency.value = 0.2;\n      const bgLfoGain = audioCtx.createGain();\n      bgLfoGain.gain.value = 6;\n      bgOsc.frequency.value = 52;\n      bgLfo.connect(bgLfoGain);\n      bgLfoGain.connect(bgOsc.frequency);\n      bgOsc.connect(backgroundGain);\n\n      bgOsc.start();\n      bgLfo.start();\n\n      soundEnabled = true;\n    } catch (err) {\n      console.warn('Audio initialization failed:', err);\n      audioCtx = null;\n      soundEnabled = false;\n    }\n    return audioCtx;\n  }\n\n  // envelope helper\n  function playTone({ type = 'sine', frequency = 440, duration = 0.2, volume = 0.3, detune = 0 }) {\n    if (!audioCtx) return;\n    try {\n      const o = audioCtx.createOscillator();\n      o.type = type;\n      o.frequency.value = frequency;\n      o.detune.value = detune;\n      const g = audioCtx.createGain();\n      g.gain.value = 0.0001;\n      o.connect(g);\n      g.connect(masterGain);\n      const now = audioCtx.currentTime;\n      g.gain.cancelScheduledValues(now);\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(volume, now + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);\n      o.start(now);\n      o.stop(now + duration + 0.05);\n    } catch (err) {\n      console.warn('playTone error', err);\n    }\n  }\n\n  // Specialized sounds\n  function playCorrect() {\n    if (!audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const o1 = audioCtx.createOscillator();\n      o1.type = 'sine';\n      o1.frequency.setValueAtTime(420, now);\n      o1.frequency.exponentialRampToValueAtTime(840, now + 0.18);\n      const g1 = audioCtx.createGain();\n      g1.gain.value = 0.0001;\n      o1.connect(g1);\n      g1.connect(masterGain);\n      g1.gain.exponentialRampToValueAtTime(0.25, now + 0.02);\n      g1.gain.exponentialRampToValueAtTime(0.0001, now + 0.3);\n      o1.start(now);\n      o1.stop(now + 0.35);\n    } catch (err) {\n      console.warn('playCorrect error', err);\n    }\n  }\n  function playIncorrect() {\n    if (!audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const o = audioCtx.createOscillator();\n      o.type = 'square';\n      o.frequency.setValueAtTime(220, now);\n      o.frequency.exponentialRampToValueAtTime(80, now + 0.25);\n      const g = audioCtx.createGain();\n      g.gain.value = 0.0001;\n      o.connect(g);\n      g.connect(masterGain);\n      g.gain.exponentialRampToValueAtTime(0.16, now + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);\n      o.start(now);\n      o.stop(now + 0.4);\n    } catch (err) {\n      console.warn('playIncorrect error', err);\n    }\n  }\n  function playClick() {\n    if (!audioCtx) return;\n    playTone({ type: 'triangle', frequency: 880, duration: 0.08, volume: 0.06 });\n  }\n\n  // --- Game Data & Characters ---\n  const characters = {\n    spark: { name: 'Spark', desc: 'A tiny zig-zag lightning buddy who giggles when lamps light.' },\n    watt: { name: 'Professor Watt', desc: 'A wise glowing bulb owl who asks for exact power.' },\n    gigi: { name: 'Gigi the Gizmo', desc: 'A wacky robot helper who hands you charges.' },\n  };\n\n  // Lamps: target values and state\n  // We'll create 5 lamps with varying targets\n  function generateLampTargets() {\n    // Simple list between 4 and 12 tailored for ages 7-9\n    const list = [5, 7, 9, 6, 10];\n    // shuffle a bit\n    for (let i = list.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [list[i], list[j]] = [list[j], list[i]];\n    }\n    return list;\n  }\n  let lampTargets = generateLampTargets();\n\n  // charges queue - numbers 1..9 randomized\n  function generateCharges(count = 8) {\n    const arr = [];\n    for (let i = 0; i < count; i++) {\n      arr.push(1 + Math.floor(Math.random() * 9));\n    }\n    return arr;\n  }\n\n  let charges = generateCharges(9);\n\n  // Charge objects\n  const chargeObjects = []; // each with x,y,w,h,num,held,fromQueue,index\n  const QUEUE_START_X = 40;\n  const QUEUE_START_Y = 360;\n  function layoutCharges() {\n    chargeObjects.length = 0;\n    for (let i = 0; i < charges.length; i++) {\n      const num = charges[i];\n      const x = QUEUE_START_X + i * 70;\n      const y = QUEUE_START_Y;\n      chargeObjects.push({\n        id: 'c' + i,\n        num,\n        x,\n        y,\n        w: 56,\n        h: 56,\n        held: false,\n        homeX: x,\n        homeY: y,\n      });\n    }\n  }\n\n  layoutCharges();\n\n  // Lamps positions and states\n  const lamps = [];\n  function layoutLamps() {\n    lamps.length = 0;\n    const startX = 80;\n    const startY = 80;\n    const gapX = 120;\n    for (let i = 0; i < lampTargets.length; i++) {\n      const x = startX + i * gapX;\n      const y = startY;\n      lamps.push({\n        id: 'L' + i,\n        x,\n        y,\n        w: 96,\n        h: 140,\n        target: lampTargets[i],\n        current: 0,\n        filled: false,\n        // sockets for charges to snap into visually (we'll allow up to 3 sockets)\n        sockets: [\n          { dx: -20, dy: 60, occupied: null },\n          { dx: 0, dy: 60, occupied: null },\n          { dx: 20, dy: 60, occupied: null },\n        ],\n      });\n    }\n  }\n  layoutLamps();\n\n  // UI state\n  let heldCharge = null;\n  let pointer = { x: 0, y: 0, isDown: false };\n  let score = 0;\n  let mistakes = 0;\n  let level = 1;\n  let lastSparkTime = 0;\n\n  // Keyboard selection state\n  let selectedIndex = 0; // index in chargeObjects\n  function clampSelected() {\n    if (chargeObjects.length === 0) {\n      selectedIndex = -1;\n      return;\n    }\n    selectedIndex = Math.max(0, Math.min(chargeObjects.length - 1, selectedIndex));\n  }\n  clampSelected();\n\n  // Helper: is point in rect\n  function pointInRect(px, py, r) {\n    return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;\n  }\n\n  // Drag & Drop logic\n  function pickUpCharge(chg) {\n    if (!chg) return;\n    heldCharge = chg;\n    chg.held = true;\n    // bring to top by reordering\n    const idx = chargeObjects.indexOf(chg);\n    if (idx >= 0) {\n      chargeObjects.splice(idx, 1);\n      chargeObjects.push(chg);\n    }\n    accessibilityMessage = `Picked up charge ${chg.num}. Use pointer or arrow keys to move, press space to drop.`;\n    if (soundEnabled) playClick();\n  }\n  function dropChargeAt(x, y) {\n    if (!heldCharge) return;\n    // snap to nearest socket if within range\n    const chg = heldCharge;\n    let placed = false;\n    for (const lamp of lamps) {\n      // check each socket\n      for (let si = 0; si < lamp.sockets.length; si++) {\n        const s = lamp.sockets[si];\n        const sx = lamp.x + lamp.w / 2 + s.dx;\n        const sy = lamp.y + s.dy;\n        const dx = x - sx;\n        const dy = y - sy;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        if (dist < 34 && !s.occupied && !lamp.filled) {\n          // Place here\n          s.occupied = chg;\n          chg.x = sx - chg.w / 2;\n          chg.y = sy - chg.h / 2;\n          chg.homeX = chg.x;\n          chg.homeY = chg.y;\n          chg.placedOn = lamp.id;\n          // update lamp current\n          lamp.current += chg.num;\n          placed = true;\n          accessibilityMessage = `${characters.watt.name} says: added ${chg.num} charge to lamp needing ${lamp.target}. Current total ${lamp.current}.`;\n          if (soundEnabled) playClick();\n          // Check lamp status\n          checkLamp(lamp);\n          break;\n        }\n      }\n      if (placed) break;\n    }\n    if (!placed) {\n      // return to queue spot\n      chg.x = chg.homeX;\n      chg.y = chg.homeY;\n      chg.held = false;\n      chg.placedOn = null;\n      accessibilityMessage = 'Charge returned to the queue.';\n      if (soundEnabled) playClick();\n    } else {\n      chg.held = false;\n      // remove from queue if it was from queue (we will keep it shown but it's now placed)\n    }\n    heldCharge = null;\n  }\n\n  // Check lamp completion or overflows\n  function checkLamp(lamp) {\n    if (lamp.current === lamp.target) {\n      lamp.filled = true;\n      score += 10;\n      accessibilityMessage = `${characters.spark.name} giggles! Lamp completed! You earned 10 points.`;\n      if (soundEnabled) playCorrect();\n      // visual spark\n      lastSparkTime = performance.now();\n      // disable sockets\n      for (const s of lamp.sockets) s.occupied = s.occupied; // keep occupied charges\n    } else if (lamp.current > lamp.target) {\n      // overcharged: flash and return charges\n      mistakes += 1;\n      accessibilityMessage = `${characters.gigi.name} buzzes! Too much power. Charges will be returned.`;\n      if (soundEnabled) playIncorrect();\n      // find occupied sockets, return charges back to queue positions\n      for (let si = 0; si < lamp.sockets.length; si++) {\n        const s = lamp.sockets[si];\n        if (s.occupied) {\n          const ch = s.occupied;\n          // find a free queue spot (we'll place back at rightmost free)\n          let freeX = QUEUE_START_X + chargeObjects.indexOf(ch) * 70;\n          // We'll simply animate them back home: homeX/homeY pre-existing\n          ch.x = ch.homeX;\n          ch.y = ch.homeY;\n          ch.held = false;\n          ch.placedOn = null;\n          s.occupied = null;\n        }\n      }\n      lamp.current = 0;\n      lamp.filled = false;\n    } else {\n      // still under target: play small click\n      if (soundEnabled) playClick();\n    }\n  }\n\n  // Reset level\n  function resetLevel() {\n    lampTargets = generateLampTargets();\n    lampTargets.length = 5;\n    for (let i = 0; i < lampTargets.length; i++) lampTargets[i] = lampTargets[i] || 5;\n    lamps.forEach((l, idx) => {\n      l.target = lampTargets[idx];\n      l.current = 0;\n      l.filled = false;\n      for (const s of l.sockets) s.occupied = null;\n    });\n    charges = generateCharges(9);\n    layoutCharges();\n    score = 0;\n    mistakes = 0;\n    accessibilityMessage = 'New challenge! Place charges to match each lamp\\'s target power.';\n  }\n\n  // --- Input Handling (pointer and keyboard) ---\n  // Pointer events\n  canvas.addEventListener('pointerdown', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const px = e.clientX - rect.left;\n    const py = e.clientY - rect.top;\n    pointer.isDown = true;\n    pointer.x = px;\n    pointer.y = py;\n\n    // enable audio if not already\n    if (!audioCtx) {\n      tryCreateAudioContext();\n      if (audioCtx && audioCtx.state === 'suspended') {\n        audioCtx.resume().catch(() => {});\n      }\n      if (soundEnabled) accessibilityMessage = 'Sound enabled. Good luck!';\n      else accessibilityMessage = 'Sound not available. Continue playing silently.';\n    }\n\n    // If clicked on a charge\n    for (let i = chargeObjects.length - 1; i >= 0; i--) {\n      const ch = chargeObjects[i];\n      if (pointInRect(px, py, ch)) {\n        pickUpCharge(ch);\n        ch.x = px - ch.w / 2;\n        ch.y = py - ch.h / 2;\n        return;\n      }\n    }\n\n    // If clicked on a socket (to remove a charge)\n    for (const lamp of lamps) {\n      for (const s of lamp.sockets) {\n        if (s.occupied) {\n          const sx = lamp.x + lamp.w / 2 + s.dx;\n          const sy = lamp.y + s.dy;\n          const rect = { x: sx - 28, y: sy - 28, w: 56, h: 56 };\n          if (px >= rect.x && px <= rect.x + rect.w && py >= rect.y && py <= rect.y + rect.h) {\n            // pick up that charge\n            const ch = s.occupied;\n            s.occupied = null;\n            lamp.current -= ch.num;\n            ch.held = true;\n            heldCharge = ch;\n            // set position to mouse\n            ch.x = px - ch.w / 2;\n            ch.y = py - ch.h / 2;\n            accessibilityMessage = `Picked up charge ${ch.num} from lamp.`;\n            if (soundEnabled) playClick();\n            return;\n          }\n        }\n      }\n    }\n  });\n\n  canvas.addEventListener('pointermove', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const px = e.clientX - rect.left;\n    const py = e.clientY - rect.top;\n    pointer.x = px;\n    pointer.y = py;\n    if (heldCharge) {\n      heldCharge.x = px - heldCharge.w / 2;\n      heldCharge.y = py - heldCharge.h / 2;\n    }\n  });\n\n  canvas.addEventListener('pointerup', (e) => {\n    pointer.isDown = false;\n    const rect = canvas.getBoundingClientRect();\n    const px = e.clientX - rect.left;\n    const py = e.clientY - rect.top;\n    if (heldCharge) {\n      dropChargeAt(px, py);\n    }\n  });\n\n  canvas.addEventListener('mouseleave', (e) => {\n    pointer.isDown = false;\n  });\n\n  // Keyboard controls\n  canvas.addEventListener('keydown', (e) => {\n    const key = e.key;\n    const gridMove = 8;\n    if (key === 'ArrowLeft') {\n      // if holding, move held object\n      if (heldCharge) {\n        heldCharge.x -= gridMove;\n      } else {\n        selectedIndex = Math.max(0, selectedIndex - 1);\n        accessibilityMessage = `Selected charge ${chargeObjects[selectedIndex] ? chargeObjects[selectedIndex].num : ''}.`;\n      }\n      e.preventDefault();\n    } else if (key === 'ArrowRight') {\n      if (heldCharge) {\n        heldCharge.x += gridMove;\n      } else {\n        selectedIndex = Math.min(chargeObjects.length - 1, selectedIndex + 1);\n        accessibilityMessage = `Selected charge ${chargeObjects[selectedIndex] ? chargeObjects[selectedIndex].num : ''}.`;\n      }\n      e.preventDefault();\n    } else if (key === 'ArrowUp') {\n      if (heldCharge) heldCharge.y -= gridMove;\n      else {\n        // move selection up maybe to lamp row for placing\n        accessibilityMessage = 'Tip: Press space to pick up the selected charge.';\n      }\n      e.preventDefault();\n    } else if (key === 'ArrowDown') {\n      if (heldCharge) heldCharge.y += gridMove;\n      e.preventDefault();\n    } else if (key === ' ' || key === 'Spacebar') {\n      // pick up or drop with space\n      e.preventDefault();\n      if (!heldCharge && selectedIndex >= 0 && chargeObjects[selectedIndex]) {\n        pickUpCharge(chargeObjects[selectedIndex]);\n      } else if (heldCharge) {\n        // drop at current center of canvas or near selection area\n        const dropX = heldCharge.x + heldCharge.w / 2;\n        const dropY = heldCharge.y + heldCharge.h / 2;\n        dropChargeAt(dropX, dropY);\n      }\n    } else if (key.toLowerCase() === 'r') {\n      // reset level\n      resetLevel();\n      if (soundEnabled) playTone({ frequency: 330, duration: 0.12, volume: 0.06 });\n    } else if (key.toLowerCase() === 's') {\n      // toggle sound\n      if (!audioCtx) {\n        tryCreateAudioContext();\n      }\n      if (audioCtx) {\n        if (audioCtx.state === 'suspended') {\n          audioCtx.resume().then(() => {\n            soundEnabled = true;\n            accessibilityMessage = 'Sound turned on.';\n            if (soundEnabled) playClick();\n          }).catch(()=>{});\n        } else {\n          audioCtx.suspend().then(() => {\n            soundEnabled = false;\n            accessibilityMessage = 'Sound turned off.';\n          }).catch(()=>{});\n        }\n      } else {\n        accessibilityMessage = 'Sound unavailable on this device/browser.';\n      }\n    }\n  });\n\n  // Focus canvas for keyboard\n  canvas.addEventListener('focus', () => {\n    accessibilityMessage = 'Use arrows and space to pick up and place charges. Press R to reset, S to toggle sound.';\n  });\n\n  // --- Drawing functions ---\n  function drawBackground() {\n    // calming gradient background with wacky stars\n    const g = ctx.createLinearGradient(0, 0, 0, GAME_H);\n    g.addColorStop(0, '#E9F5FF');\n    g.addColorStop(1, '#F6FBFF');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, GAME_W, GAME_H);\n\n    // Wacky swirls: simple arcs representing currents\n    ctx.save();\n    ctx.globalAlpha = 0.12;\n    ctx.strokeStyle = '#9FE8FF';\n    ctx.lineWidth = 4;\n    for (let i = 0; i < 6; i++) {\n      ctx.beginPath();\n      const cx = 60 + i * 110;\n      ctx.arc(cx, 240 + Math.sin((performance.now() / 1200) + i) * 10, 56, 0, Math.PI * 1.25);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  function drawCharacters() {\n    // Draw three characters on left bottom: Spark (zigzag), Watt (owl bulb), Gigi (robot)\n    // Spark\n    const sx = 30;\n    const sy = 420;\n    ctx.save();\n    ctx.fillStyle = '#FFD24D';\n    ctx.strokeStyle = '#FFB400';\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.moveTo(sx, sy - 10);\n    ctx.lineTo(sx + 12, sy);\n    ctx.lineTo(sx + 4, sy - 2);\n    ctx.lineTo(sx + 22, sy + 12);\n    ctx.lineTo(sx + 6, sy + 4);\n    ctx.lineTo(sx + 16, sy + 18);\n    ctx.lineTo(sx - 6, sy + 2);\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n    // eyes\n    ctx.fillStyle = '#333';\n    ctx.beginPath();\n    ctx.arc(sx + 2, sy - 2, 3, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(sx + 14, sy - 4, 3, 0, Math.PI * 2);\n    ctx.fill();\n    // label\n    ctx.fillStyle = '#444';\n    ctx.font = '12px sans-serif';\n    ctx.fillText(characters.spark.name, sx - 6, sy + 34);\n    ctx.restore();\n\n    // Watt (bulb owl)\n    const wx = 110;\n    const wy = 410;\n    ctx.save();\n    // bulb body\n    ctx.fillStyle = '#FFF3B0';\n    ctx.strokeStyle = '#D3B700';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.ellipse(wx, wy - 8, 18, 26, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n    // owl eyes\n    ctx.fillStyle = '#fff';\n    ctx.beginPath();\n    ctx.arc(wx - 6, wy - 14, 6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(wx + 6, wy - 14, 6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = '#333';\n    ctx.beginPath();\n    ctx.arc(wx - 6, wy - 14, 3, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(wx + 6, wy - 14, 3, 0, Math.PI * 2);\n    ctx.fill();\n    // beak\n    ctx.fillStyle = '#FFB400';\n    ctx.beginPath();\n    ctx.moveTo(wx, wy - 8);\n    ctx.lineTo(wx - 6, wy - 2);\n    ctx.lineTo(wx + 6, wy - 2);\n    ctx.closePath();\n    ctx.fill();\n    ctx.fillStyle = '#444';\n    ctx.font = '12px sans-serif';\n    ctx.fillText(characters.watt.name, wx - 26, wy + 22);\n    ctx.restore();\n\n    // Gigi robot\n    const gx = 190;\n    const gy = 414;\n    ctx.save();\n    ctx.fillStyle = '#E3F2FF';\n    ctx.strokeStyle = '#8AC3FF';\n    ctx.lineWidth = 2;\n    ctx.fillRect(gx - 14, gy - 24, 28, 28);\n    ctx.strokeRect(gx - 14, gy - 24, 28, 28);\n    // eye\n    ctx.fillStyle = '#333';\n    ctx.fillRect(gx - 6, gy - 18, 12, 8);\n    // antenna\n    ctx.beginPath();\n    ctx.moveTo(gx, gy - 24);\n    ctx.lineTo(gx, gy - 34);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.arc(gx, gy - 36, 3, 0, Math.PI * 2);\n    ctx.fillStyle = '#FFB6C1';\n    ctx.fill();\n    ctx.fillStyle = '#444';\n    ctx.font = '12px sans-serif';\n    ctx.fillText(characters.gigi.name, gx - 22, gy + 10);\n    ctx.restore();\n  }\n\n  function drawLamps(now) {\n    // lamps array\n    for (const lamp of lamps) {\n      ctx.save();\n      // lamp body\n      ctx.fillStyle = lamp.filled ? '#FFF8C6' : '#FFFFFF';\n      ctx.strokeStyle = '#A7C8FF';\n      ctx.lineWidth = 2;\n      roundRect(ctx, lamp.x, lamp.y, lamp.w, lamp.h, 12, true, true);\n\n      // socket area (glass)\n      ctx.fillStyle = '#E8F6FF';\n      ctx.globalAlpha = 0.9;\n      ctx.beginPath();\n      ctx.ellipse(lamp.x + lamp.w / 2, lamp.y + 36, 34, 28, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.globalAlpha = 1;\n\n      // filament or smiley when lit\n      if (lamp.filled) {\n        // glow\n        const fade = Math.max(0, 1 - (now - lastSparkTime) / 800);\n        ctx.fillStyle = `rgba(255,220,80,${0.2 + 0.4 * fade})`;\n        ctx.beginPath();\n        ctx.ellipse(lamp.x + lamp.w / 2, lamp.y + 54, 46, 28, 0, 0, Math.PI * 2);\n        ctx.fill();\n      }\n\n      // target number\n      ctx.fillStyle = '#3A3A3A';\n      ctx.font = '18px sans-serif';\n      ctx.fillText(`Target: ${lamp.target}`, lamp.x + 12, lamp.y + 22);\n\n      // current number big\n      ctx.font = '20px sans-serif';\n      ctx.fillStyle = lamp.filled ? '#D86B00' : '#3A3A3A';\n      ctx.fillText(`Power: ${lamp.current}`, lamp.x + 12, lamp.y + 46);\n\n      // sockets\n      for (let si = 0; si < lamp.sockets.length; si++) {\n        const s = lamp.sockets[si];\n        const sx = lamp.x + lamp.w / 2 + s.dx;\n        const sy = lamp.y + s.dy;\n        // socket base\n        ctx.fillStyle = '#F0F8FF';\n        ctx.strokeStyle = '#9FCBFF';\n        ctx.lineWidth = 2;\n        roundRect(ctx, sx - 28, sy - 28, 56, 56, 10, true, true);\n\n        // if occupied, draw the charge here\n        if (s.occupied) {\n          const ch = s.occupied;\n          drawCharge(ch, sx - ch.w / 2, sy - ch.h / 2);\n        } else {\n          // draw placeholder\n          ctx.fillStyle = '#EAF6FF';\n          ctx.beginPath();\n          ctx.arc(sx, sy, 8, 0, Math.PI * 2);\n          ctx.fill();\n        }\n      }\n\n      ctx.restore();\n    }\n  }\n\n  // draw charge object\n  function drawCharge(ch, drawX = null, drawY = null) {\n    const x = drawX !== null ? drawX : ch.x;\n    const y = drawY !== null ? drawY : ch.y;\n    // glow when selected\n    ctx.save();\n    if (ch.held) {\n      ctx.shadowColor = 'rgba(255,255,120,0.8)';\n      ctx.shadowBlur = 18;\n    } else {\n      ctx.shadowColor = 'rgba(0,0,0,0.06)';\n      ctx.shadowBlur = 6;\n    }\n    // charge body (rounded)\n    ctx.fillStyle = '#FFF7EC';\n    ctx.strokeStyle = '#FFB84D';\n    ctx.lineWidth = 2;\n    roundRect(ctx, x, y, ch.w, ch.h, 10, true, true);\n    // lightning icon\n    ctx.fillStyle = '#FF8C00';\n    ctx.beginPath();\n    ctx.moveTo(x + ch.w / 2 - 6, y + 12);\n    ctx.lineTo(x + ch.w / 2 + 4, y + ch.h / 2 - 4);\n    ctx.lineTo(x + ch.w / 2 - 2, y + ch.h / 2 - 6);\n    ctx.lineTo(x + ch.w / 2 + 8, y + ch.h - 10);\n    ctx.lineTo(x + ch.w / 2 - 6, y + ch.h / 2 + 6);\n    ctx.lineTo(x + ch.w / 2 - 2, y + ch.h / 2 + 4);\n    ctx.closePath();\n    ctx.fill();\n\n    // number\n    ctx.fillStyle = '#3A3A3A';\n    ctx.font = '20px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(ch.num.toString(), x + ch.w / 2, y + ch.h / 2);\n    ctx.restore();\n  }\n\n  function drawQueue() {\n    // header\n    ctx.save();\n    ctx.fillStyle = '#333';\n    ctx.font = '16px sans-serif';\n    ctx.fillText('Charge Queue', QUEUE_START_X, QUEUE_START_Y - 24);\n    // draw each charge\n    for (let i = 0; i < chargeObjects.length; i++) {\n      const ch = chargeObjects[i];\n      // highlight selected\n      if (selectedIndex === i && !ch.held) {\n        ctx.save();\n        ctx.strokeStyle = '#66C2FF';\n        ctx.lineWidth = 3;\n        roundRect(ctx, ch.x - 4, ch.y - 4, ch.w + 8, ch.h + 8, 12, false, true);\n        ctx.restore();\n      }\n      if (!ch.placedOn) drawCharge(ch);\n      else {\n        // If placedOn is not null but still in queue array, show faint\n        drawCharge({ ...ch, x: ch.x, y: ch.y, w: ch.w, h: ch.h, held: false });\n      }\n    }\n    ctx.restore();\n  }\n\n  function drawHUD() {\n    // top right status: score, mistakes, level\n    ctx.save();\n    ctx.fillStyle = '#48658A';\n    ctx.font = '16px sans-serif';\n    ctx.fillText(`Score: ${score}`, 560, 28);\n    ctx.fillText(`Mistakes: ${mistakes}`, 560, 50);\n    ctx.fillText(`Level: ${level}`, 560, 72);\n\n    // audio visual cue\n    ctx.fillStyle = soundEnabled ? '#2E8B57' : '#B22222';\n    ctx.beginPath();\n    ctx.arc(640, 100, 12, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = '#FFF';\n    ctx.font = '12px sans-serif';\n    ctx.fillText(soundEnabled ? '\ud83d\udd0a' : '\ud83d\udd07', 636, 104);\n\n    ctx.restore();\n  }\n\n  function drawInstructions() {\n    ctx.save();\n    ctx.fillStyle = '#333';\n    ctx.font = '14px sans-serif';\n    const lines = [\n      'Instructions: Drag or keyboard-select a charge and place it into a lamp socket to match the Target power.',\n      'If the lamp reaches exactly the target, it lights up! Too much power returns charges and resets that lamp.',\n      'Keyboard: \u2190 \u2192 select, Space to pick/place, R reset, S toggle sound.',\n      'Characters: Spark (lightning), Professor Watt (bulb owl), Gigi the Gizmo (robot).',\n    ];\n    for (let i = 0; i < lines.length; i++) {\n      ctx.fillText(lines[i], 20, 140 + i * 18);\n    }\n    // accessibility message box\n    ctx.fillStyle = '#FFF';\n    ctx.strokeStyle = '#D0E8FF';\n    ctx.lineWidth = 1;\n    roundRect(ctx, 20, 220, 680, 60, 8, true, true);\n    ctx.fillStyle = '#333';\n    ctx.font = '13px sans-serif';\n    ctx.fillText('Status: ' + accessibilityMessage, 28, 248);\n    ctx.restore();\n  }\n\n  function drawSparkEffects(now) {\n    // when lamp completed recently, draw sparks\n    if (now - lastSparkTime < 700) {\n      const intensity = 1 - (now - lastSparkTime) / 700;\n      for (let i = 0; i < 18; i++) {\n        const angle = (i / 18) * Math.PI * 2 + (now / 800);\n        const r = 18 + Math.random() * 40 * intensity;\n        const cx = 360 + Math.cos(angle) * r + Math.sin(now / 200 + i) * 6;\n        const cy = 120 + Math.sin(angle * 1.2) * r * 0.6 + Math.cos(now / 250 + i) * 2;\n        ctx.beginPath();\n        ctx.fillStyle = `rgba(255,${180 + i * 2},20,${0.06 + 0.3 * intensity})`;\n        ctx.arc(cx, cy, 4 + Math.random() * 4 * intensity, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n  }\n\n  // utility: rounded rectangle\n  function roundRect(ctx, x, y, w, h, r, fill, stroke) {\n    if (typeof r === 'undefined') r = 5;\n    if (typeof stroke === 'undefined') stroke = true;\n    if (typeof fill === 'undefined') fill = true;\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  // --- Main Loop ---\n  function update(delta) {\n    // nothing heavy for now - simple physics for charges if held, hover\n    if (!heldCharge) {\n      // small bobbing for queue charges\n      for (let i = 0; i < chargeObjects.length; i++) {\n        const ch = chargeObjects[i];\n        if (!ch.placedOn) {\n          // bounce slightly\n          ch.y = ch.homeY + Math.sin(performance.now() / 400 + i) * 3;\n        }\n      }\n    } else {\n      // make sure heldCharge on top\n      // already reordering in pickUpCharge\n    }\n  }\n\n  let lastTime = performance.now();\n  function loop(now) {\n    const delta = now - lastTime;\n    lastTime = now;\n    update(delta);\n\n    // Draw everything\n    ctx.clearRect(0, 0, GAME_W, GAME_H);\n    drawBackground();\n    drawCharacters();\n    drawLamps(now);\n    drawQueue();\n    drawHUD();\n    drawInstructions();\n    drawSparkEffects(now);\n\n    // If selected via keyboard and not held, draw focus ring\n    if (selectedIndex >= 0 && chargeObjects[selectedIndex] && !chargeObjects[selectedIndex].held) {\n      const ch = chargeObjects[selectedIndex];\n      ctx.save();\n      ctx.strokeStyle = '#7FD1FF';\n      ctx.lineWidth = 2;\n      ctx.setLineDash([6, 4]);\n      roundRect(ctx, ch.x - 6, ch.y - 6, ch.w + 12, ch.h + 12, 12, false, true);\n      ctx.restore();\n    }\n\n    // visual cue for audio enable: draw button-like area\n    ctx.save();\n    ctx.fillStyle = '#FFFFFF';\n    ctx.strokeStyle = '#D0E8FF';\n    ctx.lineWidth = 1;\n    roundRect(ctx, 520, 110, 180, 36, 8, true, true);\n    ctx.fillStyle = '#444';\n    ctx.font = '14px sans-serif';\n    ctx.fillText(soundEnabled ? 'Sound: ON (press S to toggle)' : 'Sound: OFF - click here to enable', 535, 132);\n    ctx.restore();\n\n    // pointer represented\n    ctx.save();\n    ctx.globalAlpha = 0.9;\n    ctx.fillStyle = '#FFFFFF';\n    ctx.strokeStyle = '#66C2FF';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.arc(pointer.x, pointer.y, 8, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n    ctx.restore();\n\n    requestAnimationFrame(loop);\n  }\n\n  // Start main loop\n  requestAnimationFrame(loop);\n\n  // Click on the audio text box to enable audio\n  canvas.addEventListener('click', (e) => {\n    // compute if click was inside audio box\n    const rect = canvas.getBoundingClientRect();\n    const px = e.clientX - rect.left;\n    const py = e.clientY - rect.top;\n    if (px >= 520 && px <= 700 && py >= 110 && py <= 146) {\n      // toggle or enable\n      if (!audioCtx) {\n        tryCreateAudioContext();\n      }\n      if (audioCtx) {\n        if (audioCtx.state === 'suspended') {\n          audioCtx.resume().then(() => {\n            soundEnabled = true;\n            accessibilityMessage = 'Sound enabled.';\n            playClick();\n          }).catch(() => {\n            accessibilityMessage = 'Unable to enable sound due to browser restrictions.';\n          });\n        } else {\n          soundEnabled = !soundEnabled;\n          accessibilityMessage = soundEnabled ? 'Sound enabled.' : 'Sound disabled.';\n          if (soundEnabled) playClick();\n        }\n      } else {\n        accessibilityMessage = 'Sound unavailable on this device/browser.';\n      }\n    }\n  });\n\n  // Expose some functions to the container for assistive tech (debug)\n  container.gameApi = {\n    reset: resetLevel,\n    enableSound: () => {\n      tryCreateAudioContext();\n      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();\n      soundEnabled = !!audioCtx;\n    },\n  };\n\n  // initial vocal accessibility message\n  accessibilityMessage = 'Welcome to Spark City! Place the numbered charges into lamp sockets to match each lamp\\'s target power.';\n\n  // Make sure errors with AudioContext creation are handled:\n  window.addEventListener('unhandledrejection', (ev) => {\n    console.warn('Unhandled rejection in game:', ev.reason);\n  });\n})();\n---\n",
  "improve_response_tokens": 20506,
  "formatted_code": true,
  "formatting_response_tokens": 20501,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}