{
  "generated_date": "2025-08-24",
  "generated_timestamp": "2025-08-24T00:29:44.380934",
  "model": "gpt-5-mini",
  "theme": "electricity",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8626,
  "game_filename": "2025-08-24.js",
  "game_size_bytes": 24491,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function() {\n  // Electricity Math Game for ages 7-9\n  // Renders into element with ID \"game-of-the-day-stage\"\n  // Canvas size: 720x480\n  // Uses Web Audio API oscillators for sounds\n  // All graphics are canvas drawn. No external resources.\n\n  // ------ Setup and safety checks ------\n  const STAGE_ID = 'game-of-the-day-stage';\n  const WIDTH = 720;\n  const HEIGHT = 480;\n\n  const stage = document.getElementById(STAGE_ID);\n  if (!stage) {\n    console.error(`Element with id \"${STAGE_ID}\" not found.`);\n    return;\n  }\n\n  // clear stage\n  stage.innerHTML = '';\n  stage.style.position = 'relative';\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute('role', 'application');\n  canvas.setAttribute('aria-label', 'Electric Math Game. Use arrow keys to select a bulb and Space or Enter to connect electricity.');\n  stage.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Create an ARIA live region for accessibility updates\n  const live = document.createElement('div');\n  live.setAttribute('aria-live', 'polite');\n  live.style.position = 'absolute';\n  live.style.left = '-9999px';\n  live.style.width = '1px';\n  live.style.height = '1px';\n  live.style.overflow = 'hidden';\n  stage.appendChild(live);\n\n  // Attempt to create AudioContext; handle errors gracefully\n  let audioCtx = null;\n  let audioAllowed = true;\n  try {\n    const AudioContext = window.AudioContext || window.webkitAudioContext;\n    if (AudioContext) {\n      audioCtx = new AudioContext();\n      // Some browsers require a gesture to resume; we'll manage resume on first interaction.\n    } else {\n      audioAllowed = false;\n      console.warn('Web Audio API not supported in this browser.');\n    }\n  } catch (e) {\n    audioAllowed = false;\n    console.warn('Failed to create AudioContext:', e);\n  }\n\n  // Audio control objects\n  const audioState = {\n    enabled: audioAllowed,\n    resumed: false,\n    bgGain: null,\n    bgOsc: null\n  };\n\n  // Utility: safe resume audio on interaction\n  async function tryResumeAudio() {\n    if (!audioCtx || audioState.resumed || !audioState.enabled) return;\n    try {\n      await audioCtx.resume();\n      audioState.resumed = true;\n      startBackgroundHum();\n    } catch (e) {\n      console.warn('Audio resume failed:', e);\n    }\n  }\n\n  // ------- Sound generation using Web Audio API -------\n  function safeCreateGain() {\n    if (!audioCtx) return null;\n    try {\n      return audioCtx.createGain();\n    } catch (e) {\n      console.warn('Failed to create GainNode:', e);\n      return null;\n    }\n  }\n\n  function startBackgroundHum() {\n    if (!audioCtx || !audioState.enabled) return;\n    stopBackgroundHum();\n    try {\n      const osc = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n      const filter = audioCtx.createBiquadFilter();\n      osc.type = 'sine';\n      osc.frequency.value = 60; // gentle hum frequency\n      filter.type = 'lowpass';\n      filter.frequency.value = 600;\n      gain.gain.value = 0.02; // very gentle\n      osc.connect(filter);\n      filter.connect(gain);\n      gain.connect(audioCtx.destination);\n      osc.start();\n      audioState.bgOsc = osc;\n      audioState.bgGain = gain;\n    } catch (e) {\n      console.warn('Failed to start background hum:', e);\n    }\n  }\n\n  function stopBackgroundHum() {\n    if (audioState.bgOsc) {\n      try {\n        audioState.bgOsc.stop();\n      } catch (e) {}\n      try {\n        audioState.bgOsc.disconnect();\n      } catch (e) {}\n      audioState.bgOsc = null;\n    }\n    if (audioState.bgGain) {\n      try { audioState.bgGain.disconnect(); } catch (e) {}\n      audioState.bgGain = null;\n    }\n  }\n\n  function playCorrectSound() {\n    if (!audioCtx || !audioState.enabled) return;\n    tryResumeAudio();\n    try {\n      const now = audioCtx.currentTime;\n      const master = safeCreateGain();\n      if (!master) return;\n      master.gain.value = 0.0001;\n      master.connect(audioCtx.destination);\n\n      // three quick rising tones\n      const freqs = [660, 880, 1100];\n      freqs.forEach((f, i) => {\n        const osc = audioCtx.createOscillator();\n        const g = audioCtx.createGain();\n        const filter = audioCtx.createBiquadFilter();\n        osc.type = 'sine';\n        osc.frequency.setValueAtTime(f - 80, now + i * 0.06);\n        osc.frequency.exponentialRampToValueAtTime(f, now + i * 0.06 + 0.08);\n        g.gain.setValueAtTime(0.001, now + i * 0.06);\n        g.gain.exponentialRampToValueAtTime(0.12, now + i * 0.06 + 0.02);\n        g.gain.exponentialRampToValueAtTime(0.0001, now + i * 0.06 + 0.22);\n        filter.type = 'highpass';\n        filter.frequency.value = 300;\n        osc.connect(filter);\n        filter.connect(g);\n        g.connect(master);\n        osc.start(now + i * 0.06);\n        osc.stop(now + i * 0.06 + 0.3);\n      });\n      // smooth master envelope\n      master.gain.setValueAtTime(0.0001, now);\n      master.gain.exponentialRampToValueAtTime(1, now + 0.01);\n      master.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);\n      setTimeout(() => {\n        try { master.disconnect(); } catch (e) {}\n      }, 700);\n    } catch (e) {\n      console.warn('Correct sound failed:', e);\n    }\n  }\n\n  function playIncorrectSound() {\n    if (!audioCtx || !audioState.enabled) return;\n    tryResumeAudio();\n    try {\n      const now = audioCtx.currentTime;\n      const osc = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      const filter = audioCtx.createBiquadFilter();\n      osc.type = 'square';\n      osc.frequency.setValueAtTime(160, now);\n      filter.type = 'bandpass';\n      filter.frequency.value = 300;\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(0.12, now + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);\n      osc.connect(filter);\n      filter.connect(g);\n      g.connect(audioCtx.destination);\n      osc.start(now);\n      osc.frequency.exponentialRampToValueAtTime(80, now + 0.4);\n      osc.stop(now + 0.5);\n      setTimeout(() => {\n        try { osc.disconnect(); } catch (e) {}\n      }, 600);\n    } catch (e) {\n      console.warn('Incorrect sound failed:', e);\n    }\n  }\n\n  // Toggle audio on/off\n  function toggleAudio() {\n    audioState.enabled = !audioState.enabled;\n    if (audioState.enabled) {\n      tryResumeAudio();\n      startBackgroundHum();\n    } else {\n      stopBackgroundHum();\n    }\n  }\n\n  // ------- Game Logic -------\n  const GAME = {\n    level: 1,\n    score: 0,\n    lives: 3,\n    round: 0,\n    playing: true,\n    selectedIndex: 0,\n    options: [],\n    correctIndex: 0,\n    a: 0,\n    b: 0,\n    animParticles: [],\n    ui: {}\n  };\n\n  // Characters definition (visual only)\n  const CHARACTERS = [\n    { name: 'Sparky', color: '#FFD34D' },\n    { name: 'Bulby', color: '#FCE8A8' },\n    { name: 'Dr. Ohm', color: '#B4E4FF' }\n  ];\n\n  // Initialize game\n  function resetGame() {\n    GAME.level = 1;\n    GAME.score = 0;\n    GAME.lives = 3;\n    GAME.round = 0;\n    GAME.playing = true;\n    GAME.selectedIndex = 0;\n    GAME.animParticles = [];\n    nextRound();\n    live.textContent = 'Game started. Use left and right arrow keys to choose a bulb, Space or Enter to connect.';\n  }\n\n  // Generate a round: addition problems with increasing difficulty\n  function nextRound() {\n    GAME.round++;\n    // Difficulty scales with level and round\n    const maxAddend = Math.min(10 + Math.floor(GAME.level * 2), 20);\n    const a = Math.floor(Math.random() * (Math.min(6 + GAME.level, maxAddend)));\n    const b = Math.floor(Math.random() * (Math.min(6 + GAME.level, maxAddend)));\n    GAME.a = a;\n    GAME.b = b;\n    // Create three options including the correct sum\n    const sum = a + b;\n    const options = new Set();\n    options.add(sum);\n    while (options.size < 3) {\n      // distractors near sum\n      let delta = Math.floor(Math.random() * 5) - 2;\n      if (Math.random() < 0.2) delta += (Math.random() < 0.5 ? -4 : 4);\n      let val = sum + delta;\n      if (val < 0) val = Math.abs(val) + 1;\n      options.add(val);\n    }\n    const arr = Array.from(options);\n    // shuffle\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    GAME.options = arr;\n    GAME.correctIndex = arr.indexOf(sum);\n    GAME.selectedIndex = 0;\n    // Slightly increase level every few rounds\n    if (GAME.round % 5 === 0) GAME.level++;\n    announceRound();\n  }\n\n  function announceRound() {\n    live.textContent = `Round ${GAME.round}. ${GAME.a} plus ${GAME.b} equals ?. Options are ${GAME.options.join(', ')}. Selected ${GAME.options[GAME.selectedIndex]}.`;\n  }\n\n  // Visual positions of bulbs\n  const bulbs = [\n    { x: WIDTH * 0.2, y: HEIGHT * 0.65 },\n    { x: WIDTH * 0.5, y: HEIGHT * 0.6 },\n    { x: WIDTH * 0.8, y: HEIGHT * 0.65 }\n  ];\n\n  // Draw loop\n  let lastTime = performance.now();\n  function loop(now) {\n    const dt = (now - lastTime) / 1000;\n    lastTime = now;\n    update(dt);\n    draw();\n    requestAnimationFrame(loop);\n  }\n\n  // Update animations\n  function update(dt) {\n    // update particles\n    GAME.animParticles.forEach(p => {\n      p.vx += p.ax * dt;\n      p.vy += p.ay * dt;\n      p.x += p.vx * dt;\n      p.y += p.vy * dt;\n      p.life -= dt;\n      p.size *= (1 - dt * 0.9);\n    });\n    GAME.animParticles = GAME.animParticles.filter(p => p.life > 0 && p.size > 0.5);\n  }\n\n  // Drawing helpers\n  function clear() {\n    // calming background gradient with wacky shapes\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, '#E8F7FF');\n    g.addColorStop(1, '#F1FFF6');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // faint circuit pattern\n    ctx.save();\n    ctx.globalAlpha = 0.08;\n    ctx.strokeStyle = '#BEEADE';\n    ctx.lineWidth = 2;\n    for (let i = 0; i < 6; i++) {\n      ctx.beginPath();\n      const y = 60 + i * 60;\n      for (let x = 0; x < WIDTH; x += 40) {\n        ctx.lineTo(x, y + Math.sin((x + i * 30) / 60) * 6);\n      }\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  function drawCharacters() {\n    // Sparky the lightning bolt at left\n    // body\n    ctx.save();\n    ctx.translate(90, 140);\n    ctx.rotate(Math.sin(Date.now() / 400) * 0.03);\n    ctx.fillStyle = '#FFD34D';\n    ctx.beginPath();\n    ctx.moveTo(-10, -30);\n    ctx.lineTo(10, -30);\n    ctx.lineTo(0, -5);\n    ctx.lineTo(18, -5);\n    ctx.lineTo(-8, 30);\n    ctx.lineTo(2, 0);\n    ctx.lineTo(-20, 0);\n    ctx.closePath();\n    ctx.fill();\n    // eyes\n    ctx.fillStyle = '#333';\n    ctx.beginPath();\n    ctx.arc(-4, -10, 3, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(6, -8, 3, 0, Math.PI * 2);\n    ctx.fill();\n    // smile\n    ctx.beginPath();\n    ctx.strokeStyle = '#333';\n    ctx.lineWidth = 1.5;\n    ctx.arc(1, 2, 7, 0.2, 3.0);\n    ctx.stroke();\n    ctx.restore();\n\n    // Dr. Ohm - robot on right\n    ctx.save();\n    ctx.translate(WIDTH - 130, 120);\n    ctx.fillStyle = '#B4E4FF';\n    ctx.fillRect(-28, -36, 56, 60);\n    // eyes\n    ctx.fillStyle = '#333';\n    ctx.fillRect(-18, -20, 10, 6);\n    ctx.fillRect(8, -20, 10, 6);\n    // mouth\n    ctx.fillStyle = '#333';\n    ctx.fillRect(-8, 0, 16, 6);\n    // little antenna\n    ctx.beginPath();\n    ctx.moveTo(18, -36);\n    ctx.lineTo(26, -52);\n    ctx.strokeStyle = '#666';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.arc(26, -52, 4, 0, Math.PI * 2);\n    ctx.fillStyle = '#FFCC66';\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function drawHub() {\n    // power hub in middle top\n    const hubX = WIDTH * 0.5;\n    const hubY = HEIGHT * 0.25;\n    // outer ring\n    ctx.save();\n    const grd = ctx.createRadialGradient(hubX, hubY, 10, hubX, hubY, 80);\n    grd.addColorStop(0, '#FFF9C4');\n    grd.addColorStop(1, '#FFE082');\n    ctx.fillStyle = grd;\n    ctx.beginPath();\n    ctx.arc(hubX, hubY, 60, 0, Math.PI * 2);\n    ctx.fill();\n    // inner spark\n    ctx.fillStyle = '#FFD54D';\n    ctx.beginPath();\n    ctx.arc(hubX, hubY, 36, 0, Math.PI * 2);\n    ctx.fill();\n    // label\n    ctx.fillStyle = '#333';\n    ctx.font = 'bold 18px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('Power Hub', hubX, hubY - 70);\n    // equation text\n    ctx.font = '26px sans-serif';\n    ctx.fillText(`${GAME.a} + ${GAME.b} = ?`, hubX, hubY + 6);\n    ctx.restore();\n  }\n\n  function drawBulbs() {\n    bulbs.forEach((b, idx) => {\n      const isSelected = (idx === GAME.selectedIndex);\n      const isCorrect = (idx === GAME.correctIndex);\n      // cable from hub to bulb\n      const hubX = WIDTH * 0.5;\n      const hubY = HEIGHT * 0.25;\n      ctx.save();\n      ctx.lineWidth = 6;\n      ctx.lineCap = 'round';\n      // cable color glows if selected\n      if (isSelected) {\n        ctx.strokeStyle = '#FFD34D';\n        ctx.shadowColor = '#FFD34D';\n        ctx.shadowBlur = 12;\n      } else {\n        ctx.strokeStyle = '#9E9E9E';\n        ctx.shadowBlur = 0;\n      }\n      ctx.beginPath();\n      ctx.moveTo(hubX, hubY + 30);\n      // curve\n      ctx.quadraticCurveTo((hubX + b.x) / 2, hubY + 80 + (idx - 1) * 10, b.x - 12, b.y - 40);\n      ctx.stroke();\n      ctx.restore();\n\n      // bulb glass\n      ctx.save();\n      ctx.translate(b.x, b.y);\n      // glow if lit (when correct and selected recently)\n      let lit = false;\n      // lit if correct and we have a small flashing effect or if correct and selected and recent particle present\n      if (isCorrect && (GAME.lastCorrectTime && (Date.now() - GAME.lastCorrectTime) < 1200)) lit = true;\n      if (isSelected && GAME.recentIncorrect && (Date.now() - GAME.recentIncorrect) < 800) lit = true;\n      // bulb body\n      const bulbGrad = ctx.createRadialGradient(-6, -12, 4, 6, 8, 60);\n      bulbGrad.addColorStop(0, lit ? '#FFF8B0' : '#FFFFFF');\n      bulbGrad.addColorStop(1, '#E6EEE9');\n      ctx.fillStyle = bulbGrad;\n      ctx.beginPath();\n      ctx.ellipse(0, -6, 34, 46, 0, 0, Math.PI * 2);\n      ctx.fill();\n      // filament (cute face)\n      ctx.strokeStyle = '#B8860B';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(-12, -4);\n      ctx.quadraticCurveTo(0, -12, 12, -4);\n      ctx.stroke();\n      // screw base\n      ctx.fillStyle = '#9E9E9E';\n      ctx.fillRect(-16, 30, 32, 8);\n      ctx.fillStyle = '#777';\n      ctx.fillRect(-14, 24, 28, 6);\n      // face\n      ctx.fillStyle = '#333';\n      ctx.beginPath();\n      ctx.arc(-8, -10, 3, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.beginPath();\n      ctx.arc(8, -10, 3, 0, Math.PI * 2);\n      ctx.fill();\n      // smile or surprised\n      ctx.beginPath();\n      ctx.strokeStyle = '#333';\n      ctx.lineWidth = 1.6;\n      if (isSelected) {\n        ctx.arc(0, -2, 8, 0.1, 3.04);\n      } else {\n        ctx.moveTo(-6, -2);\n        ctx.lineTo(6, -2);\n      }\n      ctx.stroke();\n\n      // answer label\n      ctx.fillStyle = '#222';\n      ctx.font = 'bold 20px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText(GAME.options[idx], 0, 52);\n      // selection ring\n      if (isSelected) {\n        ctx.strokeStyle = '#FFEE88';\n        ctx.lineWidth = 4;\n        ctx.beginPath();\n        ctx.ellipse(0, -6, 46, 58, 0, 0, Math.PI * 2);\n        ctx.stroke();\n      }\n      ctx.restore();\n    });\n  }\n\n  function drawUI() {\n    // Top left: score and lives\n    ctx.save();\n    ctx.fillStyle = '#333';\n    ctx.font = '18px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText(`Score: ${GAME.score}`, 16, 28);\n    // Lives as little battery icons\n    for (let i = 0; i < 3; i++) {\n      const x = 120 + i * 28;\n      const y = 12;\n      ctx.save();\n      ctx.translate(x, y);\n      // battery outline\n      ctx.strokeStyle = '#555';\n      ctx.lineWidth = 2;\n      ctx.strokeRect(0, 0, 22, 14);\n      ctx.fillStyle = (i < GAME.lives) ? '#66BB6A' : '#EEE';\n      ctx.fillRect(2, 2, 18, 10);\n      if (i < GAME.lives) {\n        // little lightning\n        ctx.fillStyle = '#FFF';\n        ctx.beginPath();\n        ctx.moveTo(10, 3);\n        ctx.lineTo(6, 10);\n        ctx.lineTo(11, 10);\n        ctx.lineTo(8, 13);\n        ctx.closePath();\n        ctx.fill();\n      }\n      ctx.restore();\n    }\n    // audio indicator top-right\n    ctx.textAlign = 'right';\n    ctx.fillStyle = '#333';\n    ctx.font = '16px sans-serif';\n    ctx.fillText(`Level: ${GAME.level}`, WIDTH - 110, 28);\n\n    // speaker icon\n    ctx.save();\n    const sx = WIDTH - 40, sy = 16;\n    ctx.translate(sx, sy);\n    ctx.fillStyle = audioState.enabled ? '#FFCC66' : '#DDD';\n    ctx.strokeStyle = '#666';\n    ctx.lineWidth = 1.5;\n    ctx.beginPath();\n    ctx.moveTo(-12, -6);\n    ctx.lineTo(-2, -6);\n    ctx.lineTo(6, -12);\n    ctx.lineTo(6, 12);\n    ctx.lineTo(-2, 6);\n    ctx.lineTo(-12, 6);\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n    if (audioState.enabled) {\n      ctx.beginPath();\n      ctx.arc(12, 0, 8, -0.6, 0.6);\n      ctx.strokeStyle = '#FFCC66';\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.arc(16, 0, 12, -0.7, 0.7);\n      ctx.stroke();\n    }\n    ctx.restore();\n\n    // Instructions bottom area\n    ctx.fillStyle = 'rgba(255,255,255,0.7)';\n    ctx.fillRect(12, HEIGHT - 78, WIDTH - 24, 66);\n    ctx.fillStyle = '#333';\n    ctx.font = '14px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText('Choose the bulb that shows the correct answer. Use \u2190 and \u2192 to select. Press Space or Enter to connect. Click bulbs to select. Press M to toggle sound.', 20, HEIGHT - 46);\n    ctx.restore();\n  }\n\n  function drawParticles() {\n    GAME.animParticles.forEach(p => {\n      ctx.save();\n      ctx.globalAlpha = Math.max(0, Math.min(1, p.life / p.maxLife));\n      ctx.fillStyle = p.color;\n      ctx.beginPath();\n      ctx.arc(p.x, p.y, Math.max(1, p.size), 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n    });\n  }\n\n  function draw() {\n    clear();\n    drawCharacters();\n    drawHub();\n    drawBulbs();\n    drawUI();\n    drawParticles();\n\n    // show friendly footer\n    ctx.save();\n    ctx.fillStyle = '#666';\n    ctx.font = '12px sans-serif';\n    ctx.textAlign = 'right';\n    ctx.fillText('Theme: Electricity - Learn addition by lighting bulbs!', WIDTH - 10, HEIGHT - 8);\n    ctx.restore();\n\n    // If game over overlay\n    if (!GAME.playing) {\n      ctx.save();\n      ctx.fillStyle = 'rgba(20,20,20,0.6)';\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n      ctx.fillStyle = '#FFF';\n      ctx.font = 'bold 36px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText('Game Over', WIDTH / 2, HEIGHT / 2 - 20);\n      ctx.font = '22px sans-serif';\n      ctx.fillText(`Score: ${GAME.score}`, WIDTH / 2, HEIGHT / 2 + 18);\n      ctx.font = '16px sans-serif';\n      ctx.fillText('Press R to play again', WIDTH / 2, HEIGHT / 2 + 48);\n      ctx.restore();\n    }\n  }\n\n  // ------ Interaction handlers ------\n\n  // click detection for bulbs\n  function handleClick(e) {\n    // resume audio on first interaction\n    tryResumeAudio();\n\n    const rect = canvas.getBoundingClientRect();\n    const x = (e.clientX - rect.left) * (canvas.width / rect.width);\n    const y = (e.clientY - rect.top) * (canvas.height / rect.height);\n\n    for (let i = 0; i < bulbs.length; i++) {\n      const b = bulbs[i];\n      // simple hit via distance\n      const dx = x - b.x;\n      const dy = y - b.y;\n      if (Math.sqrt(dx * dx + dy * dy) < 60) {\n        // select and confirm\n        GAME.selectedIndex = i;\n        announceRound();\n        // quick confirm on second click: if same selected again or immediate click triggers connect\n        handleConfirm();\n        return;\n      }\n    }\n\n    // clicking speaker area toggles audio\n    const sx = WIDTH - 40, sy = 16;\n    if (x > sx - 20 && x < sx + 30 && y > sy - 20 && y < sy + 20) {\n      toggleAudio();\n      live.textContent = audioState.enabled ? 'Sound on' : 'Sound off';\n    }\n  }\n\n  function handleKeyDown(e) {\n    // resume audio on first gesture\n    tryResumeAudio();\n\n    if (!GAME.playing) {\n      if (e.key === 'r' || e.key === 'R') {\n        resetGame();\n      }\n      return;\n    }\n\n    if (e.key === 'ArrowLeft') {\n      GAME.selectedIndex = (GAME.selectedIndex + bulbs.length - 1) % bulbs.length;\n      announceRound();\n      e.preventDefault();\n    } else if (e.key === 'ArrowRight') {\n      GAME.selectedIndex = (GAME.selectedIndex + 1) % bulbs.length;\n      announceRound();\n      e.preventDefault();\n    } else if (e.key === ' ' || e.key === 'Enter') {\n      handleConfirm();\n      e.preventDefault();\n    } else if (e.key === 'm' || e.key === 'M') {\n      toggleAudio();\n      live.textContent = audioState.enabled ? 'Sound on' : 'Sound off';\n      e.preventDefault();\n    }\n  }\n\n  function handleConfirm() {\n    if (!GAME.playing) return;\n    const chosen = GAME.selectedIndex;\n    const correct = GAME.correctIndex;\n    if (chosen === correct) {\n      // success\n      GAME.score += 10;\n      GAME.lastCorrectTime = Date.now();\n      playCorrectSound();\n      // particles around bulb\n      const b = bulbs[chosen];\n      for (let i = 0; i < 18; i++) {\n        GAME.animParticles.push({\n          x: b.x + (Math.random() - 0.5) * 30,\n          y: b.y + (Math.random() - 0.5) * 20,\n          vx: (Math.random() - 0.5) * 60,\n          vy: (Math.random() - 1.5) * 60,\n          ax: 0,\n          ay: 80,\n          life: 1.0,\n          maxLife: 1.0,\n          size: 4 + Math.random() * 4,\n          color: `hsl(${Math.random() * 60 + 40}, 80%, ${60 + Math.random() * 10}%)`\n        });\n      }\n      // next round shortly\n      setTimeout(nextRound, 700);\n      live.textContent = `Correct! ${GAME.a} + ${GAME.b} = ${GAME.options[chosen]}. Score ${GAME.score}.`;\n    } else {\n      // incorrect\n      GAME.lives -= 1;\n      GAME.recentIncorrect = Date.now();\n      playIncorrectSound();\n      // sparks\n      const b = bulbs[chosen];\n      for (let i = 0; i < 16; i++) {\n        GAME.animParticles.push({\n          x: b.x + (Math.random() - 0.5) * 30,\n          y: b.y + (Math.random() - 0.5) * 20,\n          vx: (Math.random() - 0.5) * 100,\n          vy: (Math.random() - 1) * 60,\n          ax: 0,\n          ay: 200,\n          life: 0.8 + Math.random() * 0.6,\n          maxLife: 1.0,\n          size: 3 + Math.random() * 3,\n          color: `hsl(${Math.random() * 40 + 10}, 90%, ${40 + Math.random() * 20}%)`\n        });\n      }\n      live.textContent = `Oops! ${GAME.options[chosen]} is not ${GAME.a} + ${GAME.b}. Lives: ${GAME.lives}.`;\n      if (GAME.lives <= 0) {\n        GAME.playing = false;\n        stopBackgroundHum();\n        live.textContent = `Game over. Final score ${GAME.score}. Press R to play again.`;\n      } else {\n        // give a clue: highlight which one is correct\n        setTimeout(() => {\n          // small hint: briefly set selected to correct so children notice\n          GAME.selectedIndex = GAME.correctIndex;\n          setTimeout(() => {\n            GAME.selectedIndex = 0;\n            announceRound();\n          }, 700);\n        }, 300);\n      }\n    }\n  }\n\n  // Event listeners\n  canvas.addEventListener('click', handleClick);\n  canvas.addEventListener('touchstart', function(e) {\n    if (e.touches && e.touches.length > 0) {\n      const t = e.touches[0];\n      handleClick({ clientX: t.clientX, clientY: t.clientY });\n    }\n    e.preventDefault();\n  }, { passive: false });\n\n  window.addEventListener('keydown', handleKeyDown);\n\n  // Resume audio upon any user gesture on the canvas\n  function userGestureHandler() {\n    if (audioCtx && audioCtx.state === 'suspended') {\n      tryResumeAudio();\n    }\n    canvas.removeEventListener('pointerdown', userGestureHandler);\n    canvas.removeEventListener('mousedown', userGestureHandler);\n    canvas.removeEventListener('touchstart', userGestureHandler);\n  }\n  canvas.addEventListener('pointerdown', userGestureHandler);\n  canvas.addEventListener('mousedown', userGestureHandler);\n  canvas.addEventListener('touchstart', userGestureHandler);\n\n  // Initialize game and start loop\n  resetGame();\n  if (audioState.enabled) {\n    // start gently if allowed; may require resume gesture\n    try {\n      startBackgroundHum();\n    } catch (e) {\n      console.warn('Background hum start error:', e);\n    }\n  }\n  requestAnimationFrame(loop);\n\n  // Expose a minimal API for possible external controls (non-essential)\n  window.__ElectricMathGame = {\n    reset: resetGame,\n    toggleAudio: toggleAudio,\n    getState: () => ({ score: GAME.score, lives: GAME.lives, level: GAME.level, round: GAME.round })\n  };\n\n  // Error handling demonstration: watch for context errors\n  window.addEventListener('unhandledrejection', function(e) {\n    console.warn('Unhandled promise rejection:', e.reason);\n  });\n})();\n---\n",
  "improve_response_tokens": 17923,
  "formatted_code": true,
  "formatting_response_tokens": 19741,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}