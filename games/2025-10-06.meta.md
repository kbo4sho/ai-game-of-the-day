# Game of the Day - 2025-10-06

## Metadata
- **Generated Date:** 2025-10-06
- **Generated Time:** 2025-10-06T00:27:07.556257
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-10-06.js
- **File Size:** 30567 bytes
- **Tokens Used:** 9880

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-10-06.js` - The playable game
- `2025-10-06.meta.json` - Machine-readable metadata
- `2025-10-06.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 19872

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 21576

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Machine Math - Playable educational game for ages 7-9
// Renders into the element with ID "game-of-the-day-stage"
// All visuals drawn on canvas. Sounds via Web Audio API oscillators/filters.
// Accessible: keyboard controls, aria-live text updates, audio visual cue.
// No external assets. Modern, readable JS with comments and error handling.

(() => {
  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const ROUNDS = 6;
  const MAX_PIECES = 6; // number of selectable pieces shown around machine

  // Colors and style (calming, wacky)
  const COLORS = {
    bg: "#E9F3F2",
    machine: "#A7D3D1",
    accent: "#F6C28B",
    gear: "#C9E3E0",
    text: "#233B3B",
    piece: "#F7F6E7",
    pieceStroke: "#4A6B6B",
    correctGlow: "#B8F7D4",
    wrongGlow: "#F7C0C0",
    slot: "#EFF7F6",
    confetti: ["#F6C28B", "#F7E9A1", "#A7D3D1", "#C9E3E0", "#D6B8F6"],
  };

  // Get stage
  const stage = document.getElementById("game-of-the-day-stage");
  if (!stage) {
    console.error("Container with ID 'game-of-the-day-stage' not found.");
    return;
  }

  // Clear stage and set attributes for accessibility
  stage.innerHTML = "";
  stage.setAttribute("role", "application");
  stage.setAttribute("aria-label", "Machine Math: a math puzzle game for kids.");
  stage.style.touchAction = "none";

  // Create aria-live region for descriptive text updates
  const ariaLive = document.createElement("div");
  ariaLive.setAttribute("aria-live", "polite");
  ariaLive.style.position = "absolute";
  ariaLive.style.left = "-9999px";
  ariaLive.style.width = "1px";
  ariaLive.style.height = "1px";
  ariaLive.style.overflow = "hidden";
  stage.appendChild(ariaLive);

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.width = WIDTH + "px";
  canvas.style.height = HEIGHT + "px";
  canvas.setAttribute("role", "img");
  canvas.setAttribute("aria-label", "Interactive machine math canvas.");
  canvas.tabIndex = 0; // focusable for keyboard controls
  stage.appendChild(canvas);
  const ctx = canvas.getContext("2d");

  // Audio setup with error handling
  let audioContext = null;
  let audioAvailable = false;
  let bgGain = null;
  let bgOsc = null;

  async function initAudio() {
    if (audioContext) return;
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) throw new Error("Web Audio API not supported in this browser.");
      audioContext = new AC();

      // Create gentle background hum using oscillator + lowpass + gain
      bgOsc = audioContext.createOscillator();
      const humFreq = 110; // gentle low hum
      bgOsc.type = "sine";
      bgOsc.frequency.value = humFreq;

      const bgFilter = audioContext.createBiquadFilter();
      bgFilter.type = "lowpass";
      bgFilter.frequency.value = 400;

      bgGain = audioContext.createGain();
      bgGain.gain.value = 0.02; // gentle

      bgOsc.connect(bgFilter).connect(bgGain).connect(audioContext.destination);

      // Start background oscillator only when context is resumed/allowed
      try {
        if (audioContext.state === "suspended") {
          await audioContext.resume();
        }
        bgOsc.start();
      } catch (e) {
        // If starting causes issues, report but continue without audio
        console.warn("Audio could not be started immediately:", e);
      }

      audioAvailable = true;
      setAudioVisual(true);
    } catch (err) {
      console.warn("Audio initialization failed:", err);
      audioAvailable = false;
      audioContext = null;
      setAudioVisual(false);
      // Provide text feedback for accessibility
      announce("Audio not available. You can still play the game with on-screen cues.");
    }
  }

  // Toggle audio on/off visually
  let audioOn = true;
  function setAudioVisual(state) {
    audioOn = !!state && audioAvailable;
    // Draw will reflect audioOn via small speaker icon
  }

  // Play correct sound — pleasant chord using multiple oscillators
  function playCorrect() {
    if (!audioOn || !audioContext) return;
    try {
      const now = audioContext.currentTime;
      const master = audioContext.createGain();
      master.gain.value = 0.0001;
      master.gain.setValueAtTime(0.0001, now);
      master.gain.exponentialRampToValueAtTime(0.08, now + 0.02);
      master.gain.exponentialRampToValueAtTime(0.0001, now + 0.8);
      master.connect(audioContext.destination);

      const freqs = [440, 660, 880]; // simple major-ish chord
      freqs.forEach((f) => {
        const osc = audioContext.createOscillator();
        osc.type = Math.random() > 0.5 ? "sine" : "triangle";
        osc.frequency.value = f + (Math.random() * 8 - 4);
        const filt = audioContext.createBiquadFilter();
        filt.type = "lowpass";
        filt.frequency.value = 2000;
        osc.connect(filt).connect(master);
        osc.start(now);
        osc.stop(now + 0.8 + Math.random() * 0.2);
      });
    } catch (e) {
      console.warn("Play correct sound failed:", e);
    }
  }

  // Play incorrect sound — soft buzz
  function playIncorrect() {
    if (!audioOn || !audioContext) return;
    try {
      const now = audioContext.currentTime;
      const osc = audioContext.createOscillator();
      osc.type = "sawtooth";
      osc.frequency.value = 220;
      const gain = audioContext.createGain();
      gain.gain.value = 0.0001;
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(0.05, now + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);
      const filter = audioContext.createBiquadFilter();
      filter.type = "highpass";
      filter.frequency.value = 200;
      osc.connect(filter).connect(gain).connect(audioContext.destination);
      osc.start(now);
      osc.frequency.setValueAtTime(220, now);
      osc.frequency.exponentialRampToValueAtTime(880, now + 0.2);
      osc.stop(now + 0.4);
    } catch (e) {
      console.warn("Play incorrect sound failed:", e);
    }
  }

  // Utility: announce text for screen readers
  function announce(text) {
    ariaLive.textContent = text;
  }

  // Game state
  const state = {
    round: 0,
    roundsTotal: ROUNDS,
    puzzles: [], // each puzzle: {target, op, slots, choices}
    selectedPieceIndex: 0,
    chosenSlot: 0,
    placed: [], // values in slots or null
    pieces: [], // pieces array with {value,x,y,r,dragging}
    draggingPiece: null,
    solvedRounds: 0,
    feedback: null, // {type: 'correct'|'wrong', t: timestamp}
    confetti: [],
    finished: false,
    awaitingAudioGesture: true, // encourage first gesture to init audio
  };

  // Generate puzzles
  function generatePuzzles() {
    const puzzles = [];
    const ops = ["+","-"]; // addition and subtraction, kid-friendly
    for (let i = 0; i < ROUNDS; i++) {
      // Alternate ops for variety; ensure subtraction has positive answers
      const op = i % 3 === 2 ? "-" : "+";
      if (op === "+") {
        // pick two or three numbers depending on difficulty
        const slotCount = i < 3 ? 2 : 3;
        const values = [];
        for (let s = 0; s < slotCount; s++) {
          values.push(randInt(1, 9));
        }
        const target = values.reduce((a,b)=>a+b,0);
        puzzles.push({op, slots: slotCount, solution: values, target});
      } else {
        // subtraction: pick two numbers where minuend > subtrahend
        const a = randInt(5, 12);
        const b = randInt(1, Math.min(8, a-1));
        const target = a - b;
        puzzles.push({op, slots: 2, solution: [a,b], target});
      }
    }
    return puzzles;
  }

  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // Initialize puzzle pieces and placement for current round
  function startRound() {
    const idx = state.round;
    if (idx >= state.roundsTotal) {
      // all done
      state.finished = true;
      announce("All machines fixed! Great job!");
      startConfetti();
      return;
    }
    const p = state.puzzles[idx];
    state.placed = new Array(p.slots).fill(null);
    state.selectedPieceIndex = 0;
    state.chosenSlot = 0;
    state.feedback = null;

    // Build pieces: include solution numbers and distractors (small numbers)
    const pieces = [];
    // Solution numbers for addition/subtraction might be larger than 9; split if needed
    const baseSolution = p.solution.slice();
    // For subtraction, solution is [a,b] where a might be >9; present pieces as numbers maybe >9 allowed
    baseSolution.forEach((v) => pieces.push(v));
    // Add distractors until we have MAX_PIECES
    while (pieces.length < MAX_PIECES) {
      let cand;
      if (p.op === "-") {
        // encourage numbers around target
        cand = randInt(1, Math.max(9, Math.max(...p.solution)));
      } else {
        cand = randInt(1, 9);
      }
      // avoid exact copy of solution more times than needed
      if (pieces.filter(x=>x===cand).length > 2) continue;
      pieces.push(cand);
    }
    // Shuffle pieces
    shuffleArray(pieces);

    // Layout pieces in a semicircle bottom-left
    const centerX = 360;
    const centerY = 380;
    const radius = 220;
    const angleStart = Math.PI * 0.25;
    const angleEnd = Math.PI * 0.75;
    const pieceObjs = [];
    const r = 26;
    for (let i = 0; i < pieces.length; i++) {
      const t = i / (pieces.length - 1 || 1);
      const angle = angleStart + t * (angleEnd - angleStart);
      const x = centerX - Math.cos(angle) * radius;
      const y = centerY - Math.sin(angle) * (radius * 0.6) + 40;
      pieceObjs.push({
        id: "p" + i,
        value: pieces[i],
        x, y, r,
        homeX: x, homeY: y,
        dragging: false,
        placedInSlot: -1,
      });
    }

    state.pieces = pieceObjs;
    state.draggingPiece = null;
    announce(`Round ${idx+1}. Machine asks for ${p.op} to make ${p.target}. Use mouse or keyboard to place pieces.`);
  }

  // Shuffle helper
  function shuffleArray(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  // Main initialization
  function init() {
    state.puzzles = generatePuzzles();
    state.round = 0;
    state.solvedRounds = 0;
    state.finished = false;
    state.confetti = [];
    generateControls(); // keyboard & pointer handlers
    startRound();
    lastTime = performance.now();
    requestAnimationFrame(loop);
  }

  // Game input handlers
  function generateControls() {
    // Pointer events (mouse/touch)
    canvas.addEventListener("pointerdown", onPointerDown);
    window.addEventListener("pointermove", onPointerMove);
    window.addEventListener("pointerup", onPointerUp);
    canvas.addEventListener("click", onCanvasClick);

    // Keyboard controls
    canvas.addEventListener("keydown", (e) => {
      // Initialize audio on first gesture
      if (state.awaitingAudioGesture) {
        initAudio().catch(()=>{});
        state.awaitingAudioGesture = false;
      }
      const key = e.key;
      if (state.finished) {
        if (key === "Enter") {
          // restart
          restartGame();
        }
        if (key.toLowerCase() === "m") {
          toggleAudio();
        }
        return;
      }
      // Navigation among pieces: left/right arrows move selection
      if (key === "ArrowLeft") {
        e.preventDefault();
        state.selectedPieceIndex = (state.selectedPieceIndex - 1 + state.pieces.length) % state.pieces.length;
      } else if (key === "ArrowRight") {
        e.preventDefault();
        state.selectedPieceIndex = (state.selectedPieceIndex + 1) % state.pieces.length;
      } else if (key === "ArrowUp") {
        e.preventDefault();
        state.chosenSlot = (state.chosenSlot - 1 + state.placed.length) % state.placed.length;
      } else if (key === "ArrowDown") {
        e.preventDefault();
        state.chosenSlot = (state.chosenSlot + 1) % state.placed.length;
      } else if (key === "Enter" || key === " ") {
        e.preventDefault();
        // Place selected piece into chosen slot (or remove if already placed)
        const piece = state.pieces[state.selectedPieceIndex];
        if (!piece) return;
        if (piece.placedInSlot >= 0) {
          // remove
          const oldSlot = piece.placedInSlot;
          piece.placedInSlot = -1;
          state.placed[oldSlot] = null;
          announce(`Removed piece ${piece.value} from slot ${oldSlot+1}.`);
        } else {
          // if slot occupied, swap or reject; we'll swap
          const slot = state.chosenSlot;
          // find placed piece in that slot
          const otherIdx = state.pieces.findIndex(pp => pp.placedInSlot === slot);
          if (otherIdx >= 0) {
            state.pieces[otherIdx].placedInSlot = -1;
          }
          piece.placedInSlot = slot;
          state.placed[slot] = piece.value;
          announce(`Placed piece ${piece.value} into slot ${slot+1}.`);
        }
      } else if (key === "Backspace" || key === "Delete") {
        e.preventDefault();
        // remove any piece from chosen slot
        const slot = state.chosenSlot;
        const idx = state.pieces.findIndex(pp => pp.placedInSlot === slot);
        if (idx >= 0) {
          const val = state.pieces[idx].value;
          state.pieces[idx].placedInSlot = -1;
          state.placed[slot] = null;
          announce(`Removed piece ${val} from slot ${slot+1}.`);
        }
      } else if (key.toLowerCase() === "m") {
        toggleAudio();
      } else if (key === "s") {
        // Submit attempt
        attemptSolve();
      }
    });

    // Focus canvas for keyboard
    canvas.addEventListener("focus", () => {
      // ensure audio init on focus if first gesture pending
      if (state.awaitingAudioGesture) {
        initAudio().catch(()=>{});
        state.awaitingAudioGesture = false;
      }
    });

    // Also add pointer event to init audio on first gesture
    canvas.addEventListener("pointerdown", async () => {
      if (state.awaitingAudioGesture) {
        try { await initAudio(); } catch(e){/*ignore*/ }
        state.awaitingAudioGesture = false;
      }
    });
  }

  // Pointer handlers for dragging
  function onPointerDown(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    // Check if clicked on audio icon area (top-right)
    if (x > WIDTH - 60 && y < 40) {
      toggleAudio();
      return;
    }
    // Check pieces
    for (let i = 0; i < state.pieces.length; i++) {
      const p = state.pieces[i];
      if (distance(p.x, p.y, x, y) <= p.r + 6) {
        p.dragging = true;
        state.draggingPiece = p;
        p.offsetX = x - p.x;
        p.offsetY = y - p.y;
        canvas.setPointerCapture(e.pointerId);
        return;
      }
    }
    // Check if clicked on submit button area
    if (x > 560 && x < 700 && y > 380 && y < 440) {
      attemptSolve();
    }
  }

  function onPointerMove(e) {
    if (!state.draggingPiece) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    state.draggingPiece.x = x - state.draggingPiece.offsetX;
    state.draggingPiece.y = y - state.draggingPiece.offsetY;
  }

  function onPointerUp(e) {
    if (!state.draggingPiece) return;
    const p = state.draggingPiece;
    p.dragging = false;
    // If released over a slot area, snap into slot
    const slotIdx = slotIndexAtPoint(p.x, p.y);
    if (slotIdx >= 0) {
      // if another piece is in that slot, send it home
      const other = state.pieces.find(pp => pp.placedInSlot === slotIdx);
      if (other) other.placedInSlot = -1;
      p.placedInSlot = slotIdx;
      state.placed[slotIdx] = p.value;
      announce(`Placed piece ${p.value} into slot ${slotIdx+1}.`);
    } else {
      // return to home spot
      p.x = p.homeX;
      p.y = p.homeY;
      if (p.placedInSlot >= 0) {
        // if it was placed in a slot but dragged out, remove
        state.placed[p.placedInSlot] = null;
        p.placedInSlot = -1;
      }
    }
    state.draggingPiece = null;
  }

  function onCanvasClick(e) {
    // Click on a piece toggles selection; click on piece while not dragging toggles place in chosen slot
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    for (let i = 0; i < state.pieces.length; i++) {
      const p = state.pieces[i];
      if (distance(p.x, p.y, x, y) <= p.r + 6) {
        state.selectedPieceIndex = i;
        // click places into current chosen slot (swap if occupied)
        const slot = state.chosenSlot;
        const otherIdx = state.pieces.findIndex(pp => pp.placedInSlot === slot);
        if (p.placedInSlot >= 0) {
          // remove
          state.placed[p.placedInSlot] = null;
          p.placedInSlot = -1;
          announce(`Removed piece ${p.value}.`);
        } else {
          if (otherIdx >= 0) {
            state.pieces[otherIdx].placedInSlot = -1;
          }
          p.placedInSlot = slot;
          state.placed[slot] = p.value;
          announce(`Placed piece ${p.value} in slot ${slot+1}.`);
        }
        return;
      }
    }
    // Click on submit area tries solve
    if (x > 560 && x < 700 && y > 380 && y < 440) {
      attemptSolve();
    }
    // Click on machine slots to change chosen slot
    const sl = slotIndexAtPoint(x, y);
    if (sl >= 0) {
      state.chosenSlot = sl;
      announce(`Selected slot ${sl+1}.`);
    }
  }

  function slotIndexAtPoint(x, y) {
    // compute slot positions and test
    const slotPositions = getSlotPositions();
    for (let i = 0; i < slotPositions.length; i++) {
      const sp = slotPositions[i];
      if (x >= sp.x - sp.w/2 && x <= sp.x + sp.w/2 && y >= sp.y - sp.h/2 && y <= sp.y + sp.h/2) {
        return i;
      }
    }
    return -1;
  }

  // Attempt to check placed pieces
  function attemptSolve() {
    if (state.finished) return;
    const puzzle = state.puzzles[state.round];
    // Check if all slots filled
    if (state.placed.some(v => v === null)) {
      announce("Fill all slots before submitting.");
      state.feedback = {type: "wrong", t: performance.now()};
      playIncorrect();
      return;
    }
    const values = state.placed.slice();
    let result;
    if (puzzle.op === "+") {
      result = values.reduce((a,b)=>a+b,0);
    } else {
      // subtraction: assume two slots, compute first - second - (third?) For safety, compute left-to-right
      result = values.reduce((a,b)=>a-b);
    }
    if (result === puzzle.target) {
      // correct
      state.feedback = {type: "correct", t: performance.now()};
      playCorrect();
      announce("Correct! Machine is fixed.");
      state.solvedRounds++;
      // animate solved machine then next round after short delay
      setTimeout(() => {
        state.round++;
        if (state.round >= state.roundsTotal) {
          state.finished = true;
          announce("All machines fixed! You win!");
          startConfetti();
        } else {
          startRound();
        }
      }, 1100);
    } else {
      // incorrect
      state.feedback = {type: "wrong", t: performance.now()};
      playIncorrect();
      announce(`Not quite. Try again. Your result was ${result}.`);
    }
  }

  // Toggle audio on/off
  function toggleAudio() {
    if (!audioAvailable) {
      announce("Audio not available on this device.");
      return;
    }
    audioOn = !audioOn;
    if (bgGain) {
      bgGain.gain.value = audioOn ? 0.02 : 0.00001;
    }
    setAudioVisual(audioOn);
    announce(audioOn ? "Audio on." : "Audio muted.");
  }

  // Utility: distance
  function distance(x1,y1,x2,y2) {
    const dx = x1 - x2;
    const dy = y1 - y2;
    return Math.sqrt(dx*dx + dy*dy);
  }

  // Drawing helpers
  function drawRoundedRect(ctx, x,y,w,h,r) {
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  // Draw gear (wacky element) at (cx,cy)
  function drawGear(cx, cy, outerR, teeth, innerR, color) {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(Math.sin((Date.now()/1000)+cx+cy) * 0.05);
    ctx.fillStyle = color;
    ctx.beginPath();
    for (let i = 0; i < teeth; i++) {
      const angle = (i / teeth) * Math.PI * 2;
      const angle2 = ((i + 0.5) / teeth) * Math.PI * 2;
      const x1 = Math.cos(angle) * outerR;
      const y1 = Math.sin(angle) * outerR;
      const x2 = Math.cos(angle2) * (outerR - 8);
      const y2 = Math.sin(angle2) * (outerR - 8);
      if (i === 0) ctx.moveTo(x1, y1);
      ctx.lineTo(x1, y1);
      ctx.lineTo(x2, y2);
    }
    ctx.closePath();
    ctx.fill();
    // inner circle
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.arc(0,0,innerR,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // Get slot positions for current machine
  function getSlotPositions() {
    const baseX = 360;
    const baseY = 210;
    const spacing = 110;
    const p = state.puzzles[state.round];
    const slots = [];
    const total = p.slots;
    const startX = baseX - (total - 1) * spacing / 2;
    for (let i = 0; i < total; i++) {
      slots.push({x: startX + i * spacing, y: baseY + 10, w: 84, h: 84});
    }
    return slots;
  }

  // Confetti for win
  function startConfetti() {
    state.confetti = [];
    for (let i = 0; i < 60; i++) {
      state.confetti.push({
        x: randInt(0, WIDTH),
        y: randInt(-200, 0),
        vx: (Math.random() - 0.5) * 1.5,
        vy: 1 + Math.random()*2,
        size: randInt(6, 12),
        color: COLORS.confetti[Math.floor(Math.random()*COLORS.confetti.length)],
        rot: Math.random()*Math.PI,
        angVel: (Math.random() - 0.5) * 0.1,
      });
    }
  }

  // Restart game
  function restartGame() {
    state.puzzles = generatePuzzles();
    state.round = 0;
    state.solvedRounds = 0;
    state.finished = false;
    startRound();
    announce("Game restarted. Fix the machines!");
  }

  // Rendering loop
  let lastTime = 0;
  function loop(now) {
    const dt = (now - lastTime) / 1000;
    lastTime = now;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  function update(dt) {
    // Animate confetti
    if (state.confetti.length) {
      state.confetti.forEach(c => {
        c.x += c.vx;
        c.y += c.vy;
        c.rot += c.angVel;
        if (c.y > HEIGHT + 20) {
          c.y = -20;
          c.x = randInt(0, WIDTH);
        }
      });
    }
  }

  function render() {
    // Clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Background
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Decorative wavy stripes (calming)
    ctx.save();
    ctx.fillStyle = "rgba(167,211,209,0.12)";
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.ellipse(140 + i*220, 130 + Math.sin(Date.now()/1000 + i)*6, 260, 80, Math.sin(i)*0.2, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // Draw machine body
    const machineX = 160;
    const machineY = 120;
    ctx.save();
    ctx.fillStyle = COLORS.machine;
    drawRoundedRect(ctx, machineX, machineY, 380, 220, 20);

    // Machine faceplate details
    ctx.fillStyle = COLORS.slot;
    drawRoundedRect(ctx, machineX + 16, machineY + 16, 350, 70, 12);
    ctx.fillStyle = COLORS.accent;
    drawRoundedRect(ctx, machineX + 20, machineY + 24, 120, 42, 10);
    ctx.fillStyle = "#ffffff88";
    ctx.fillRect(machineX + 160, machineY + 24, 140, 42);

    ctx.restore();

    // Decorative gears
    drawGear(110, 100, 32, 10, 12, COLORS.gear);
    drawGear(610, 80, 20, 8, 8, COLORS.gear);
    drawGear(620, 260, 28, 9, 10, COLORS.gear);

    // Machine display: target + operation
    const puzzle = state.puzzles[state.round];
    ctx.fillStyle = COLORS.text;
    ctx.font = "22px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText("Machine Goal:", machineX + 24, machineY + 48);
    ctx.font = "bold 36px sans-serif";
    ctx.fillStyle = COLORS.text;
    ctx.fillText(`${puzzle.op}  →  ${puzzle.target}`, machineX + 160, machineY + 56);

    // Draw conveyor belt / slot area
    ctx.fillStyle = "#DDEDEB";
    drawRoundedRect(ctx, machineX + 40, machineY + 110, 300, 84, 12);

    // Draw slots
    const slots = getSlotPositions();
    for (let i = 0; i < slots.length; i++) {
      const sp = slots[i];
      ctx.save();
      // Glow if chosen
      if (state.chosenSlot === i) {
        ctx.shadowColor = state.feedback && state.feedback.type === "correct" ? COLORS.correctGlow : "#ffffffAA";
        ctx.shadowBlur = 12;
      } else {
        ctx.shadowBlur = 0;
      }
      // Fill slot background
      ctx.fillStyle = COLORS.slot;
      drawRoundedRect(ctx, sp.x - sp.w/2, sp.y - sp.h/2, sp.w, sp.h, 10);
      // If placed show piece inside
      const placedValue = state.placed[i];
      if (placedValue !== null && placedValue !== undefined) {
        ctx.fillStyle = COLORS.piece;
        drawRoundedRect(ctx, sp.x - sp.w/2 + 6, sp.y - sp.h/2 + 6, sp.w - 12, sp.h - 12, 8);
        ctx.strokeStyle = COLORS.pieceStroke;
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = COLORS.text;
        ctx.font = "bold 28px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(String(placedValue), sp.x, sp.y + 10);
      } else {
        ctx.fillStyle = "#FFFFFF22";
        ctx.beginPath();
        ctx.arc(sp.x, sp.y, 8, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = "#5D7D7D44";
        ctx.font = "14px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("drop", sp.x, sp.y + 6);
      }
      ctx.restore();
    }

    // Draw pieces
    state.pieces.forEach((p, idx) => {
      ctx.save();
      // Shadow or glow if selected
      if (idx === state.selectedPieceIndex) {
        ctx.shadowColor = "#FFFFFF88";
        ctx.shadowBlur = 12;
      } else {
        ctx.shadowBlur = 0;
      }
      ctx.fillStyle = COLORS.piece;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = COLORS.pieceStroke;
      ctx.stroke();

      // Number
      ctx.fillStyle = COLORS.text;
      ctx.font = "bold 18px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(String(p.value), p.x, p.y + 6);

      // If placed, draw small tag
      if (p.placedInSlot >= 0) {
        ctx.fillStyle = "#7FD7C6";
        ctx.beginPath();
        ctx.arc(p.x + p.r - 6, p.y - p.r + 6, 8, 0, Math.PI*2);
        ctx.fill();
      }

      ctx.restore();
    });

    // Draw submit button
    ctx.save();
    ctx.fillStyle = "#FFFFFF";
    drawRoundedRect(ctx, 560, 380, 140, 60, 12);
    ctx.strokeStyle = "#7DA59E";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillStyle = "#2E4D4C";
    ctx.font = "bold 20px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("Fix Machine", 630, 418);
    ctx.restore();

    // Draw HUD: round, score, instructions
    ctx.fillStyle = COLORS.text;
    ctx.font = "16px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText(`Round ${state.round + 1} / ${state.roundsTotal}`, 20, 28);
    ctx.fillText(`Solved: ${state.solvedRounds}`, 20, 52);

    // Small instructions
    ctx.font = "13px sans-serif";
    ctx.fillStyle = "#335353";
    ctx.fillText("Use mouse drag or keyboard arrows + Enter to place pieces. Press 'S' to submit.", 20, HEIGHT - 20);

    // Audio icon and visual cue
    drawAudioIcon(WIDTH - 56, 12, audioOn);

    // Feedback overlay (correct/wrong)
    if (state.feedback) {
      const age = (performance.now() - state.feedback.t) / 1000;
      if (age < 1.0) {
        ctx.save();
        ctx.globalAlpha = 0.9 - age;
        if (state.feedback.type === "correct") {
          ctx.fillStyle = COLORS.correctGlow;
        } else {
          ctx.fillStyle = COLORS.wrongGlow;
        }
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
        ctx.restore();
      }
    }

    // Confetti if finished
    if (state.finished) {
      ctx.save();
      state.confetti.forEach(c => {
        ctx.fillStyle = c.color;
        ctx.beginPath();
        ctx.ellipse(c.x, c.y, c.size, c.size*0.6, c.rot, 0, Math.PI*2);
        ctx.fill();
      });
      ctx.restore();

      // Victory text
      ctx.save();
      ctx.fillStyle = "#1f3a3a";
      ctx.font = "bold 42px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Machines Fixed! Well done!", WIDTH/2, 120);
      ctx.font = "18px sans-serif";
      ctx.fillText("Press Enter to play again. Press M to toggle audio.", WIDTH/2, 160);
      ctx.restore();
    }

    // Draw small accessibility cue: text of current selected piece and slot
    ctx.save();
    ctx.fillStyle = "#334747";
    ctx.font = "13px sans-serif";
    ctx.textAlign = "left";
    const sel = state.pieces[state.selectedPieceIndex];
    ctx.fillText(`Selected piece: ${sel ? sel.value : "-"} — Slot: ${state.chosenSlot+1}`, 20, HEIGHT - 40);
    ctx.restore();
  }

  function drawAudioIcon(x, y, on) {
    ctx.save();
    ctx.translate(x, y);
    ctx.strokeStyle = "#2F4D4D";
    ctx.fillStyle = on ? "#7FD7C6" : "#D7EDEC";
    ctx.lineWidth = 2;
    // speaker body
    ctx.beginPath();
    ctx.moveTo(-12, -8);
    ctx.lineTo(-4, -8);
    ctx.lineTo(0, -12);
    ctx.lineTo(8, -12);
    ctx.lineTo(8, 12);
    ctx.lineTo(0, 12);
    ctx.lineTo(-4, 8);
    ctx.lineTo(-12, 8);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    // sound waves
    if (audioAvailable) {
      ctx.beginPath();
      ctx.arc(14, 0, 8, -0.6, 0.6);
      ctx.strokeStyle = on ? "#2F4D4D" : "#B0CFCF";
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(14, 0, 12, -0.6, 0.6);
      ctx.strokeStyle = on ? "#2F4D4D" : "#B0CFCF";
      ctx.stroke();
    } else {
      // show cross for unavailable
      ctx.strokeStyle = "#E06A6A";
      ctx.beginPath();
      ctx.moveTo(12, -8);
      ctx.lineTo(20, 0);
      ctx.moveTo(20, -8);
      ctx.lineTo(12, 0);
      ctx.stroke();
    }
    ctx.restore();
  }

  // Start audio on first user gesture attempt (to cope with autoplay restrictions)
  canvas.addEventListener("pointerdown", async () => {
    if (state.awaitingAudioGesture) {
      try {
        await initAudio();
      } catch (e) {
        console.warn(e);
      }
      state.awaitingAudioGesture = false;
    }
  }, {once: true});

  // Start the game
  init();

})();
---

