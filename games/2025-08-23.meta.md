# Game of the Day - 2025-08-23

## Metadata
- **Generated Date:** 2025-08-23
- **Generated Time:** 2025-08-23T00:27:45.733918
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-23.js
- **File Size:** 24904 bytes
- **Tokens Used:** 9413

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-23.js` - The playable game
- `2025-08-23.meta.json` - Machine-readable metadata
- `2025-08-23.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 18875

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 21926

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Electricity Math Game for ages 7-9
// Renders inside element with ID "game-of-the-day-stage"
// Canvas-only visuals and Web Audio API sounds
// Accessible with keyboard, has ARIA status, and error handling for audio

(function () {
  // Config
  const WIDTH = 720;
  const HEIGHT = 480;
  const CONTAINER_ID = "game-of-the-day-stage";
  const MAX_ORBS = 7;
  const ROBOT_SPEED = 160; // pixels per second
  const ORB_RADIUS = 20;
  const ROBOT_RADIUS = 24;
  const BG_COLOR = "#edf6fb";
  const ORB_COLORS = ["#FFD166", "#06D6A0", "#118AB2", "#EF476F", "#06B6D4", "#7C4DFF"];
  const FONT = "16px Georgia";
  const TITLE_FONT = "26px Georgia";
  const SMALL_FONT = "14px Georgia";

  // State
  let container, canvas, ctx, lastTime = 0, rafId;
  let keys = {};
  let gameState = "title"; // title, playing, success
  let robot = { x: WIDTH / 2, y: HEIGHT - 80, r: ROBOT_RADIUS, vx: 0, vy: 0 };
  let orbs = [];
  let collected = []; // orb indices
  let target = 0;
  let statusMessage = "";
  let level = 1;
  let audioAvailable = false;
  let audioEnabled = true;
  let audioCtx = null;
  let humGainNode = null;
  let speakerIconHover = false;
  let sparks = []; // visual particle sparks
  let accessibleStatusEl;

  // Utility helpers
  function randRange(a, b) {
    return Math.floor(Math.random() * (b - a + 1)) + a;
  }
  function pick(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
  }
  function clamp(v, a, b) {
    return Math.max(a, Math.min(b, v));
  }
  function dist(ax, ay, bx, by) {
    const dx = ax - bx;
    const dy = ay - by;
    return Math.sqrt(dx * dx + dy * dy);
  }

  // Audio helpers with proper error handling
  function initAudio() {
    try {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      if (!AudioContext) throw new Error("Web Audio API not supported");
      audioCtx = new AudioContext();
      audioAvailable = true;
      // create gentle background hum
      try {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.value = 600;
        osc.type = "sine";
        osc.frequency.value = 60; // low hum
        gain.gain.value = 0.01; // very quiet by default
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        humGainNode = gain;
        // Start muted until explicit enable by user (audioEnabled flag)
        setHumOn(audioEnabled);
      } catch (err) {
        console.warn("Background hum init error:", err);
      }
    } catch (err) {
      console.warn("Audio init failed:", err);
      audioAvailable = false;
      audioCtx = null;
    }
  }

  function resumeAudioContextIfNeeded() {
    if (!audioCtx) return;
    if (audioCtx.state === "suspended") {
      audioCtx.resume().catch((e) => {
        console.warn("Audio resume failed:", e);
      });
    }
  }

  function setHumOn(on) {
    if (!audioAvailable || !humGainNode) return;
    humGainNode.gain.setTargetAtTime(on ? 0.01 : 0.0, audioCtx.currentTime, 0.05);
  }

  // Create a short beep using oscillator
  function playBeep(freq = 440, time = 0.12, type = "sine", volume = 0.08) {
    if (!audioAvailable || !audioEnabled) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = volume;
      o.connect(g);
      g.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      g.gain.setValueAtTime(volume, now);
      g.gain.exponentialRampToValueAtTime(0.0001, now + time);
      o.start(now);
      o.stop(now + time + 0.02);
    } catch (err) {
      console.warn("playBeep error", err);
    }
  }

  // Chime for success (sequence of notes)
  function playChime() {
    if (!audioAvailable || !audioEnabled) return;
    try {
      const freqs = [660, 880, 990, 880];
      freqs.forEach((f, i) => {
        setTimeout(() => playBeep(f, 0.18, "triangle", 0.06), i * 160);
      });
    } catch (err) {
      console.warn("playChime error", err);
    }
  }

  // Buzz for error
  function playBuzz() {
    if (!audioAvailable || !audioEnabled) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      filter.type = "lowpass";
      filter.frequency.value = 600;
      o.type = "square";
      o.frequency.value = 120;
      g.gain.value = 0.08;
      o.connect(filter);
      filter.connect(g);
      g.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      g.gain.setValueAtTime(0.08, now);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);
      o.start(now);
      o.stop(now + 0.25);
    } catch (err) {
      console.warn("playBuzz error", err);
    }
  }

  // Announce status for screen readers
  function announce(text) {
    if (accessibleStatusEl) {
      accessibleStatusEl.textContent = text;
    }
  }

  // DOM & Canvas Setup
  function initDOM() {
    container = document.getElementById(CONTAINER_ID);
    if (!container) {
      console.error("Container element with ID", CONTAINER_ID, "not found.");
      return;
    }
    // Clear container
    container.innerHTML = "";
    container.style.position = "relative";
    container.style.width = WIDTH + "px";
    container.style.height = HEIGHT + "px";

    // Create canvas
    canvas = document.createElement("canvas");
    canvas.width = WIDTH;
    canvas.height = HEIGHT;
    canvas.setAttribute("aria-label", "Electric Sparks Math Game");
    canvas.style.outline = "none";
    canvas.tabIndex = 0; // make focusable
    container.appendChild(canvas);
    ctx = canvas.getContext("2d", { alpha: false });

    // Accessible live region (offscreen)
    accessibleStatusEl = document.createElement("div");
    accessibleStatusEl.setAttribute("role", "status");
    accessibleStatusEl.setAttribute("aria-live", "polite");
    accessibleStatusEl.style.position = "absolute";
    accessibleStatusEl.style.left = "-9999px";
    accessibleStatusEl.style.width = "1px";
    accessibleStatusEl.style.height = "1px";
    container.appendChild(accessibleStatusEl);
  }

  // Level generation guaranteeing solvable target (subset sum)
  function generateLevel() {
    orbs = [];
    collected = [];
    // Create orb values
    for (let i = 0; i < MAX_ORBS; i++) {
      const v = randRange(1, 9);
      const x = randRange(60, WIDTH - 60);
      const y = randRange(80, HEIGHT - 160);
      const color = ORB_COLORS[i % ORB_COLORS.length];
      orbs.push({ x, y, origX: x, origY: y, yOffset: 0, value: v, color, r: ORB_RADIUS, collected: false });
    }
    // pick random subset to be target
    const indices = [];
    for (let i = 0; i < orbs.length; i++) indices.push(i);
    // shuffle
    for (let i = indices.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [indices[i], indices[j]] = [indices[j], indices[i]];
    }
    const subsetCount = randRange(2, 4);
    const subset = indices.slice(0, subsetCount);
    target = subset.reduce((s, idx) => s + orbs[idx].value, 0);
    // Slightly move orbs if overlap
    for (let i = 0; i < orbs.length; i++) {
      for (let j = i + 1; j < orbs.length; j++) {
        const a = orbs[i], b = orbs[j];
        const d = dist(a.x, a.y, b.x, b.y);
        if (d < a.r + b.r + 6) {
          // push b away
          const angle = Math.atan2(b.y - a.y, b.x - a.x) || Math.random() * Math.PI * 2;
          b.x += Math.cos(angle) * (a.r + b.r + 8 - d);
          b.y += Math.sin(angle) * (a.r + b.r + 8 - d);
          b.x = clamp(b.x, 60, WIDTH - 60);
          b.y = clamp(b.y, 80, HEIGHT - 160);
        }
      }
    }

    statusMessage = `Level ${level}: Power the house with ${target} energy. Collect orbs that add to ${target}. Use arrows or WASD to move. Press Backspace to undo last orb. Press M to toggle sound.`;
    announce(statusMessage);
    robot.x = WIDTH / 2;
    robot.y = HEIGHT - 80;
    sparks = [];
  }

  // Input handling
  function setupInput() {
    window.addEventListener("keydown", (e) => {
      if (e.repeat) return;
      keys[e.key.toLowerCase()] = true;
      // Prevent scrolling with arrows and space/backspace
      if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " ", "Backspace"].includes(e.key)) {
        e.preventDefault();
      }
      // On first user gesture, resume audio context if possible
      resumeAudioContextIfNeeded();

      if (e.key === "m" || e.key === "M") {
        audioEnabled = !audioEnabled;
        setHumOn(audioEnabled);
        announce("Sound " + (audioEnabled ? "on" : "off"));
      }

      if (gameState === "title" && (e.key === "Enter" || e.key === " ")) {
        startGame();
      } else if (gameState === "success") {
        if (e.key === "Enter" || e.key === " ") {
          level++;
          generateLevel();
          gameState = "playing";
        }
      } else if (gameState === "playing") {
        if (e.key === "Backspace" || e.key === "Delete") {
          undoLastOrb();
        } else if (e.key === "r" || e.key === "R") {
          level = 1;
          startGame();
        }
      }
    });

    window.addEventListener("keyup", (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    // Canvas focus styling and mouse control
    canvas.addEventListener("click", (e) => {
      canvas.focus();
      resumeAudioContextIfNeeded();
      // Toggle speaker if click in its area
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      if (mx > WIDTH - 60 && my < 40) {
        audioEnabled = !audioEnabled;
        setHumOn(audioEnabled);
        announce("Sound " + (audioEnabled ? "on" : "off"));
      } else if (gameState === "title") {
        startGame();
      } else if (gameState === "success") {
        level++;
        generateLevel();
        gameState = "playing";
      }
    });

    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      speakerIconHover = mx > WIDTH - 60 && my < 40;
    });

    // Touch support: simple joystick by touching left/right halves
    canvas.addEventListener("touchstart", (e) => {
      resumeAudioContextIfNeeded();
      if (e.touches.length > 0) {
        const t = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const mx = t.clientX - rect.left;
        const my = t.clientY - rect.top;
        // If touch near top-right toggle speaker
        if (mx > WIDTH - 60 && my < 40) {
          audioEnabled = !audioEnabled;
          setHumOn(audioEnabled);
          announce("Sound " + (audioEnabled ? "on" : "off"));
        } else {
          // move robot toward touch location
          robot.x = clamp(mx, robot.r, WIDTH - robot.r);
          robot.y = clamp(my, robot.r, HEIGHT - robot.r);
        }
      }
    });
  }

  // Undo last collected orb
  function undoLastOrb() {
    if (collected.length === 0) {
      statusMessage = "No orbs to undo.";
      announce(statusMessage);
      playBuzz();
      return;
    }
    const lastIndex = collected.pop();
    const orb = orbs[lastIndex];
    orb.collected = false;
    orb.x = orb.origX;
    orb.y = orb.origY;
    statusMessage = `Removed orb ${orb.value}. Current total: ${getCollectedSum()}.`;
    announce(statusMessage);
    playBeep(240, 0.12, "sine", 0.06);
  }

  function getCollectedSum() {
    return collected.reduce((s, idx) => s + orbs[idx].value, 0);
  }

  // Collect orb when robot touches
  function tryCollectOrb(idx) {
    const orb = orbs[idx];
    if (orb.collected) return;
    orb.collected = true;
    collected.push(idx);
    // animate orb moving near robot by setting original coords
    playBeep(420 + orb.value * 20, 0.12, "sine", 0.06);
    // create sparks
    for (let i = 0; i < 8; i++) {
      sparks.push({
        x: orb.x,
        y: orb.y,
        vx: (Math.random() - 0.5) * 80,
        vy: (Math.random() - 0.5) * 80,
        life: 0.6 + Math.random() * 0.6,
        color: orb.color,
      });
    }
    const sum = getCollectedSum();
    statusMessage = `Picked ${orb.value}. Current total: ${sum}.`;
    announce(statusMessage);
    // Check win or over
    if (sum === target) {
      // success
      playChime();
      gameState = "success";
      statusMessage = `Great! You powered the house with exactly ${target} energy! Press Enter to continue.`;
      announce(statusMessage);
    } else if (sum > target) {
      // overshoot
      playBuzz();
      statusMessage = `Too much energy! You have ${sum}, target is ${target}. Undo the last orb with Backspace.`;
      announce(statusMessage);
      // visual shake
      shakeScreen = 8;
    }
  }

  // Draw helpers
  function clearScreen() {
    ctx.fillStyle = BG_COLOR;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
  }

  function drawHeader() {
    ctx.fillStyle = "#073b4c";
    ctx.font = TITLE_FONT;
    ctx.textAlign = "left";
    ctx.fillText("Sparky Circuit: Add the Energy!", 18, 36);

    // Speaker icon
    const sx = WIDTH - 46;
    const sy = 8;
    // background circle
    ctx.beginPath();
    ctx.fillStyle = speakerIconHover ? "#ffd166" : "#ffffff";
    ctx.fillRect(sx - 6, sy - 6, 48, 32);
    // draw speaker
    ctx.fillStyle = audioAvailable ? (audioEnabled ? "#06D6A0" : "#EF476F") : "#999";
    // speaker box
    ctx.fillRect(sx, sy + 6, 12, 16);
    // triangle
    ctx.beginPath();
    ctx.moveTo(sx + 12, sy + 6);
    ctx.lineTo(sx + 28, sy + 2);
    ctx.lineTo(sx + 28, sy + 30);
    ctx.lineTo(sx + 12, sy + 26);
    ctx.closePath();
    ctx.fill();

    // cross if audio not available
    if (!audioAvailable) {
      ctx.strokeStyle = "#555";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(sx + 4, sy + 8);
      ctx.lineTo(sx + 36, sy + 28);
      ctx.moveTo(sx + 36, sy + 8);
      ctx.lineTo(sx + 4, sy + 28);
      ctx.stroke();
    }

    // small controls hint
    ctx.font = SMALL_FONT;
    ctx.fillStyle = "#073b4c";
    ctx.textAlign = "left";
    ctx.fillText("Use arrows/WASD to move • Backspace to undo • M toggles sound", 18, 60);
  }

  function drawHouse() {
    // House needs power target shown
    const hx = 80;
    const hy = 130;
    const hw = 120;
    const hh = 100;
    // house body
    ctx.fillStyle = "#FFE8A1";
    ctx.fillRect(hx, hy, hw, hh);
    // roof
    ctx.beginPath();
    ctx.moveTo(hx - 10, hy);
    ctx.lineTo(hx + hw / 2, hy - 40);
    ctx.lineTo(hx + hw + 10, hy);
    ctx.closePath();
    ctx.fillStyle = "#ef476f";
    ctx.fill();
    // door
    ctx.fillStyle = "#7C4DFF";
    ctx.fillRect(hx + hw / 2 - 14, hy + hh - 36, 28, 36);
    // windows (eyes)
    ctx.fillStyle = "#fff";
    ctx.fillRect(hx + 18, hy + 20, 22, 18);
    ctx.fillRect(hx + hw - 40, hy + 20, 22, 18);
    // smiling mouth to show happy when powered
    const sum = getCollectedSum();
    ctx.beginPath();
    ctx.strokeStyle = sum === target && sum > 0 ? "#06D6A0" : "#073b4c";
    ctx.lineWidth = 3;
    ctx.arc(hx + hw / 2, hy + hh / 2 + 10, 20, 0, Math.PI, false);
    ctx.stroke();
    // target label
    ctx.font = FONT;
    ctx.fillStyle = "#073b4c";
    ctx.textAlign = "left";
    ctx.fillText("House needs:", hx, hy + hh + 30);
    ctx.font = "22px Georgia";
    ctx.fillStyle = "#ef476f";
    ctx.fillText(target + " energy", hx + 110, hy + hh + 30);
  }

  // Draw robot character 'Volt'
  function drawRobot() {
    // body
    ctx.save();
    ctx.translate(robot.x, robot.y);
    // shadow
    ctx.beginPath();
    ctx.fillStyle = "rgba(0,0,0,0.08)";
    ctx.ellipse(0, robot.r + 18, robot.r + 12, 8, 0, 0, Math.PI * 2);
    ctx.fill();

    // body circle
    ctx.beginPath();
    ctx.fillStyle = "#06B6D4";
    ctx.arc(0, 0, robot.r, 0, Math.PI * 2);
    ctx.fill();

    // face
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(-12, -8, 24, 12);
    ctx.fillStyle = "#073b4c";
    ctx.fillRect(-6, -6, 4, 6);
    ctx.fillRect(2, -6, 4, 6);
    // smile
    ctx.beginPath();
    ctx.strokeStyle = "#073b4c";
    ctx.lineWidth = 2;
    ctx.arc(0, 2, 8, 0, Math.PI, false);
    ctx.stroke();

    // antenna
    ctx.beginPath();
    ctx.strokeStyle = "#ffd166";
    ctx.lineWidth = 4;
    ctx.moveTo(12, -robot.r + 4);
    ctx.lineTo(18, -robot.r - 18);
    ctx.stroke();
    ctx.beginPath();
    ctx.fillStyle = "#ffd166";
    ctx.arc(18, -robot.r - 18, 5, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  // Draw orbs (collected ones fade/float near top right)
  function drawOrbs(delta) {
    // animate y offset for orbs
    for (let i = 0; i < orbs.length; i++) {
      const o = orbs[i];
      if (!o.collected) {
        o.yOffset = Math.sin((Date.now() / 800) + i) * 4;
        // jitter a little
      } else {
        // animate collected orb to the top-right HUD region
        const idxInCollected = collected.indexOf(i);
        const vxTarget = WIDTH - 200 + idxInCollected * 36;
        const vyTarget = 92;
        // approach target location
        o.x += (vxTarget - o.x) * 6 * delta;
        o.y += (vyTarget - o.y) * 6 * delta;
      }
    }

    // draw orbs
    for (let i = 0; i < orbs.length; i++) {
      const o = orbs[i];
      ctx.beginPath();
      ctx.fillStyle = o.color;
      ctx.strokeStyle = "#073b4c";
      ctx.lineWidth = 2;
      ctx.arc(o.x, o.y + o.yOffset, o.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = "#073b4c";
      ctx.font = "bold 18px Georgia";
      ctx.textAlign = "center";
      ctx.fillText(String(o.value), o.x, o.y + o.yOffset + 6);
      if (!o.collected) {
        // little electric halo
        ctx.beginPath();
        ctx.strokeStyle = "rgba(6,214,160,0.06)";
        ctx.lineWidth = 6;
        ctx.arc(o.x, o.y + o.yOffset, o.r + 8, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
  }

  // Draw HUD showing collected sum and collected orbs icons
  function drawHUD() {
    ctx.textAlign = "left";
    ctx.font = "18px Georgia";
    ctx.fillStyle = "#073b4c";
    ctx.fillText("Collected total: " + getCollectedSum(), WIDTH - 260, 84);

    // drawn small slot for each collected orb
    for (let i = 0; i < collected.length; i++) {
      const idx = collected[i];
      const ox = WIDTH - 200 + i * 36;
      const oy = 92;
      ctx.beginPath();
      ctx.fillStyle = orbs[idx].color;
      ctx.strokeStyle = "#073b4c";
      ctx.arc(ox, oy, 14, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = "#073b4c";
      ctx.font = "bold 14px Georgia";
      ctx.textAlign = "center";
      ctx.fillText(String(orbs[idx].value), ox, oy + 5);
    }
  }

  // Draw recycle bin
  function drawBin() {
    const bx = WIDTH - 80;
    const by = HEIGHT - 72;
    // bin box
    ctx.fillStyle = "#b8bedd";
    ctx.fillRect(bx - 28, by - 10, 56, 48);
    // lid
    ctx.fillStyle = "#9aa0b4";
    ctx.fillRect(bx - 34, by - 22, 68, 12);
    // label
    ctx.fillStyle = "#073b4c";
    ctx.font = "12px Georgia";
    ctx.textAlign = "center";
    ctx.fillText("Recycle", bx, by + 44);
    // hint
    ctx.font = "12px Georgia";
    ctx.fillText("Backspace to undo", bx, by + 58);
  }

  // Sparks particles
  function updateSparks(delta) {
    for (let i = sparks.length - 1; i >= 0; i--) {
      const s = sparks[i];
      s.life -= delta;
      if (s.life <= 0) {
        sparks.splice(i, 1);
        continue;
      }
      s.x += s.vx * delta;
      s.y += s.vy * delta;
      s.vy += 80 * delta; // gravity-ish
    }
  }

  function drawSparks() {
    for (const s of sparks) {
      ctx.beginPath();
      ctx.fillStyle = s.color;
      ctx.globalAlpha = Math.max(0.12, s.life);
      ctx.arc(s.x, s.y, 3 + Math.random() * 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  // Main update/draw loop
  let shakeScreen = 0;
  function gameLoop(ts) {
    if (!lastTime) lastTime = ts;
    const delta = Math.min(0.05, (ts - lastTime) / 1000);
    lastTime = ts;

    // Update
    if (gameState === "playing") {
      // movement
      let moveX = 0,
        moveY = 0;
      if (keys["arrowleft"] || keys["a"]) moveX -= 1;
      if (keys["arrowright"] || keys["d"]) moveX += 1;
      if (keys["arrowup"] || keys["w"]) moveY -= 1;
      if (keys["arrowdown"] || keys["s"]) moveY += 1;
      const len = Math.hypot(moveX, moveY) || 1;
      robot.x += (moveX / len) * ROBOT_SPEED * delta;
      robot.y += (moveY / len) * ROBOT_SPEED * delta;
      robot.x = clamp(robot.x, robot.r, WIDTH - robot.r);
      robot.y = clamp(robot.y, robot.r, HEIGHT - robot.r);

      // Check collisions with orbs
      for (let i = 0; i < orbs.length; i++) {
        const o = orbs[i];
        if (!o.collected) {
          if (dist(robot.x, robot.y, o.x, o.y + o.yOffset) < robot.r + o.r - 4) {
            tryCollectOrb(i);
          }
        }
      }

      // Check if robot over recycle bin and hitting backspace
      // (Alternate: pressing backspace triggers undo regardless of location)
      updateSparks(delta);
    }

    // Draw
    clearScreen();

    // optional screen shake
    ctx.save();
    if (shakeScreen > 0) {
      const sx = (Math.random() - 0.5) * shakeScreen;
      const sy = (Math.random() - 0.5) * shakeScreen;
      ctx.translate(sx, sy);
      shakeScreen -= 0.3;
    }

    drawHeader();
    drawHouse();
    drawOrbs(delta);
    drawBin();
    drawRobot();
    drawSparks();
    drawHUD();

    // bottom instructions / status message
    ctx.fillStyle = "#073b4c";
    ctx.font = FONT;
    ctx.textAlign = "left";
    ctx.fillText(statusMessage, 18, HEIGHT - 18);

    ctx.restore();

    // Title / success overlays
    if (gameState === "title") {
      ctx.fillStyle = "rgba(3,59,76,0.7)";
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = "#fff";
      ctx.font = "34px Georgia";
      ctx.textAlign = "center";
      ctx.fillText("Spark & Volt", WIDTH / 2, HEIGHT / 2 - 40);
      ctx.font = "18px Georgia";
      ctx.fillText("Help Volt collect orbs that add up to power the house!", WIDTH / 2, HEIGHT / 2 - 8);
      ctx.fillStyle = "#ffd166";
      ctx.fillRect(WIDTH / 2 - 90, HEIGHT / 2 + 18, 180, 42);
      ctx.fillStyle = "#073b4c";
      ctx.font = "20px Georgia";
      ctx.fillText("Start Game", WIDTH / 2, HEIGHT / 2 + 48);
      ctx.font = "14px Georgia";
      ctx.fillStyle = "#fff";
      ctx.fillText("Press Enter or click to begin", WIDTH / 2, HEIGHT / 2 + 78);
    } else if (gameState === "success") {
      ctx.fillStyle = "rgba(6,214,160,0.08)";
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = "#073b4c";
      ctx.font = "28px Georgia";
      ctx.textAlign = "center";
      ctx.fillText("Great job!", WIDTH / 2, HEIGHT / 2 - 16);
      ctx.font = "18px Georgia";
      ctx.fillText(`You powered the house with ${target} energy!`, WIDTH / 2, HEIGHT / 2 + 12);
      ctx.fillStyle = "#ffd166";
      ctx.fillRect(WIDTH / 2 - 120, HEIGHT / 2 + 28, 240, 42);
      ctx.fillStyle = "#073b4c";
      ctx.font = "20px Georgia";
      ctx.fillText("Next Level", WIDTH / 2, HEIGHT / 2 + 58);
      ctx.font = "14px Georgia";
      ctx.fillStyle = "#073b4c";
      ctx.fillText("Press Enter or click to play the next level", WIDTH / 2, HEIGHT / 2 + 88);
    }

    rafId = requestAnimationFrame(gameLoop);
  }

  function startGame() {
    // ensure audio context exists (but may be suspended until user gesture)
    if (!audioCtx) initAudio();
    resumeAudioContextIfNeeded();
    level = 1;
    generateLevel();
    gameState = "playing";
    announce(statusMessage);
  }

  // Initialize and start
  function init() {
    initDOM();
    initAudio();
    setupInput();
    // initial screen
    statusMessage = "Press Enter or click to start. Help Volt (the friendly robot) collect energy orbs to power the house.";
    announce(statusMessage);
    gameState = "title";
    lastTime = 0;
    if (rafId) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(gameLoop);
  }

  // Start
  try {
    init();
  } catch (err) {
    console.error("Game initialization error:", err);
    // If critical error, show fallback message in container
    if (container) {
      container.innerHTML = "";
      const message = document.createElement("div");
      message.style.width = WIDTH + "px";
      message.style.height = HEIGHT + "px";
      message.style.display = "flex";
      message.style.alignItems = "center";
      message.style.justifyContent = "center";
      message.style.background = "#fff3cd";
      message.style.color = "#856404";
      message.textContent = "An error occurred while loading the game. Please try refreshing the page.";
      container.appendChild(message);
    }
  }
})();
---

