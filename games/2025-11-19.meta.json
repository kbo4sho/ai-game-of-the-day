{
  "generated_date": "2025-11-19",
  "generated_timestamp": "2025-11-19T00:29:36.773828",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9346,
  "game_filename": "2025-11-19.js",
  "game_size_bytes": 25545,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 4
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Educational Math Drone Game for ages 7-9\n  // Renders inside element with id \"game-of-the-day-stage\"\n  // All visuals drawn on canvas (720x480). Sounds via Web Audio API.\n  // Author: AI assistant (example). Clean, commented, accessible.\n\n  // Config\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const PADDING = 10; // minimum padding between UI elements\n  const GOAL_CORRECT = 10; // win condition\n  const MAX_LIVES = 3; // lose condition\n  const FONT_BODY = '16px \"Segoe UI\", Roboto, Arial, sans-serif';\n  const FONT_LARGE = '22px \"Segoe UI\", Roboto, Arial, sans-serif';\n  const FONT_TITLE = '28px \"Segoe UI\", Roboto, Arial, sans-serif';\n\n  // Get container\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Game container with id \"game-of-the-day-stage\" not found.');\n    return;\n  }\n  // Clear container\n  container.innerHTML = '';\n  container.style.position = 'relative';\n  container.setAttribute('aria-label', 'Drone math game');\n  container.setAttribute('role', 'application');\n\n  // Accessible live region for screen readers (offscreen but inside container)\n  const liveRegion = document.createElement('div');\n  liveRegion.setAttribute('aria-live', 'polite');\n  liveRegion.style.position = 'absolute';\n  liveRegion.style.left = '-9999px';\n  liveRegion.style.top = 'auto';\n  liveRegion.style.width = '1px';\n  liveRegion.style.height = '1px';\n  container.appendChild(liveRegion);\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.display = 'block';\n  canvas.style.background = 'transparent';\n  canvas.tabIndex = 0; // make focusable for keyboard controls\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    console.error('Canvas 2D context not available.');\n    return;\n  }\n\n  // Game state\n  let score = 0;\n  let lives = MAX_LIVES;\n  let currentQuestion = null; // {text, answer, options}\n  let selectedOptionIndex = 0;\n  let gameState = 'intro'; // intro, playing, victory, gameover, waiting (for first interaction)\n  let audioAllowed = false;\n  let audioError = null;\n\n  // Audio variables\n  let audioCtx = null;\n  let masterGain = null;\n  let ambientOsc = null;\n  let ambientGain = null;\n  let soundEnabled = true; // default on, user can toggle\n  let lastUserGesture = false;\n\n  // UI layout calculators (non-overlapping)\n  const topBarHeight = 60; // reserve top area\n  const bottomBarHeight = 70; // reserve bottom area\n  const centerArea = {\n    x: PADDING,\n    y: topBarHeight + PADDING,\n    width: WIDTH - 2 * PADDING,\n    height: HEIGHT - topBarHeight - bottomBarHeight - 2 * PADDING,\n  };\n\n  // Option button rectangles for click detection\n  let optionButtons = []; // each: {x,y,w,h,index}\n\n  // Animated elements\n  const clouds = [\n    {x: 50, y: 40, scale: 1.0, speed: 0.15},\n    {x: 300, y: 20, scale: 1.2, speed: 0.1},\n    {x: 600, y: 60, scale: 0.9, speed: 0.12},\n  ];\n  const drones = [\n    {x: 120, y: 200, phase: 0, color: '#8ecae6'},\n    {x: 580, y: 240, phase: 1.5, color: '#ffd6a5'},\n  ];\n  const starParticles = []; // for collecting animations\n\n  // Timing\n  let lastTime = performance.now();\n\n  // Helper: try to initialize audio context on user gesture\n  function initAudio() {\n    if (audioCtx) return;\n    try {\n      const AudioContext = window.AudioContext || window.webkitAudioContext;\n      if (!AudioContext) {\n        audioError = 'Web Audio API not supported';\n        console.warn(audioError);\n        audioAllowed = false;\n        return;\n      }\n      audioCtx = new AudioContext();\n      masterGain = audioCtx.createGain();\n      masterGain.gain.value = 0.9;\n      masterGain.connect(audioCtx.destination);\n\n      // Ambient gentle hum\n      ambientOsc = audioCtx.createOscillator();\n      ambientOsc.type = 'sine';\n      ambientOsc.frequency.value = 120; // low hum\n      const ambientFilter = audioCtx.createBiquadFilter();\n      ambientFilter.type = 'lowpass';\n      ambientFilter.frequency.value = 800;\n      ambientGain = audioCtx.createGain();\n      ambientGain.gain.value = 0.02; // very gentle\n      ambientOsc.connect(ambientFilter);\n      ambientFilter.connect(ambientGain);\n      ambientGain.connect(masterGain);\n      ambientOsc.start();\n\n      audioAllowed = true;\n      audioError = null;\n    } catch (e) {\n      audioAllowed = false;\n      audioError = 'Audio context error: ' + (e && e.message ? e.message : String(e));\n      console.warn(audioError);\n    }\n  }\n\n  // Play a short beep for correct/incorrect\n  function playFeedback(type = 'correct') {\n    if (!audioAllowed || !audioCtx || !soundEnabled) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      const f = audioCtx.createBiquadFilter();\n      o.connect(f);\n      f.connect(g);\n      g.connect(masterGain);\n\n      if (type === 'correct') {\n        o.type = 'triangle';\n        o.frequency.value = 880;\n        f.type = 'lowpass';\n        f.frequency.value = 1000;\n        g.gain.value = 0;\n        const now = audioCtx.currentTime;\n        g.gain.setValueAtTime(0, now);\n        g.gain.linearRampToValueAtTime(0.08, now + 0.01);\n        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);\n        o.start(now);\n        o.stop(now + 0.45);\n      } else {\n        // incorrect\n        o.type = 'sawtooth';\n        o.frequency.value = 220;\n        f.type = 'highpass';\n        f.frequency.value = 400;\n        const now = audioCtx.currentTime;\n        g.gain.setValueAtTime(0, now);\n        g.gain.linearRampToValueAtTime(0.07, now + 0.01);\n        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);\n        o.start(now);\n        o.stop(now + 0.5);\n      }\n    } catch (e) {\n      console.warn('Sound play error', e);\n    }\n  }\n\n  // Announce to screen reader live region\n  function announce(text) {\n    liveRegion.textContent = '';\n    setTimeout(() => {\n      liveRegion.textContent = text;\n    }, 50);\n  }\n\n  // Generate a simple math question appropriate for 7-9 year olds\n  function generateQuestion() {\n    // Mix addition, subtraction, simple multiplication\n    const types = ['add', 'sub', 'mul'];\n    const t = types[Math.floor(Math.random() * types.length)];\n    let a, b, answer;\n    if (t === 'add') {\n      a = rand(1, 20);\n      b = rand(1, 20);\n      answer = a + b;\n      return formatQuestion(`${a} + ${b} = ?`, answer);\n    } else if (t === 'sub') {\n      a = rand(5, 25);\n      b = rand(1, a); // ensure non-negative\n      answer = a - b;\n      return formatQuestion(`${a} - ${b} = ?`, answer);\n    } else {\n      // multiplication but small\n      a = rand(2, 7);\n      b = rand(2, 7);\n      answer = a * b;\n      return formatQuestion(`${a} \u00d7 ${b} = ?`, answer);\n    }\n  }\n\n  function formatQuestion(text, answer) {\n    // Create 4 options with one correct, rest distractors\n    const options = [];\n    options.push(answer);\n    while (options.length < 4) {\n      let delta = rand(-6, 6);\n      if (delta === 0) delta = 1;\n      let val = answer + delta;\n      if (val < 0) val = Math.abs(val) + 1;\n      if (!options.includes(val)) options.push(val);\n    }\n    // Shuffle\n    for (let i = options.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [options[i], options[j]] = [options[j], options[i]];\n    }\n    return {text, answer, options};\n  }\n\n  function rand(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  // Start or restart the game\n  function startGame() {\n    score = 0;\n    lives = MAX_LIVES;\n    selectedOptionIndex = 0;\n    gameState = 'playing';\n    nextQuestion();\n    announce('Game started. Press number keys 1 to 4 to answer. Collect ' + GOAL_CORRECT + ' correct answers to win.');\n  }\n\n  function restartGame() {\n    // For user gesture to initialize audio\n    if (!lastUserGesture) {\n      // focus canvas to receive keyboard\n      canvas.focus();\n    }\n    startGame();\n  }\n\n  // Move to next question\n  function nextQuestion() {\n    currentQuestion = generateQuestion();\n    selectedOptionIndex = 0;\n    // Update live region with question and options\n    announce('New question: ' + currentQuestion.text + ' Options: ' + currentQuestion.options.join(', '));\n  }\n\n  // Handle selection\n  function chooseOption(index) {\n    if (gameState !== 'playing') return;\n    if (!currentQuestion) return;\n    const chosen = currentQuestion.options[index];\n    if (chosen === currentQuestion.answer) {\n      // correct\n      score++;\n      spawnStars(6, WIDTH / 2, centerArea.y + 60);\n      playFeedback('correct');\n      announce('Correct! Score ' + score + '.');\n      if (score >= GOAL_CORRECT) {\n        gameState = 'victory';\n        announce('Victory! You collected ' + GOAL_CORRECT + ' correct answers. Press R to restart or click restart button.');\n        return;\n      }\n      // next question after short delay to allow animation\n      setTimeout(nextQuestion, 650);\n    } else {\n      lives--;\n      playFeedback('incorrect');\n      spawnStars(10, WIDTH - 80, 40, false);\n      announce('Oops, that was wrong. Lives left: ' + lives + '.');\n      if (lives <= 0) {\n        gameState = 'gameover';\n        announce('Game over. You ran out of lives. Press R to restart or click restart button.');\n        return;\n      }\n      // still next question\n      setTimeout(nextQuestion, 650);\n    }\n  }\n\n  // Spawn star particles for animation (correct/incorrect)\n  function spawnStars(count, sx, sy, golden = true) {\n    for (let i = 0; i < count; i++) {\n      starParticles.push({\n        x: sx + rand(-30, 30),\n        y: sy + rand(-20, 20),\n        vx: (Math.random() - 0.5) * 2,\n        vy: -Math.random() * 2 - 1.5,\n        life: 1 + Math.random() * 0.8,\n        golden: golden,\n        size: 6 + Math.random() * 6,\n      });\n    }\n  }\n\n  // Draw helpers\n  function drawRoundedRect(x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  // Main render loop\n  function render(now) {\n    const dt = Math.min(0.05, (now - lastTime) / 1000);\n    lastTime = now;\n\n    // Update animations\n    clouds.forEach(c => {\n      c.x += c.speed;\n      if (c.x - 200 > WIDTH) c.x = -200;\n    });\n    drones.forEach(d => {\n      d.phase += dt * 2;\n      d.y += Math.sin(d.phase) * 0.6;\n    });\n    // update particles\n    for (let i = starParticles.length - 1; i >= 0; i--) {\n      const p = starParticles[i];\n      p.vy += 0.05;\n      p.x += p.vx;\n      p.y += p.vy;\n      p.life -= dt * 0.8;\n      if (p.life <= 0) starParticles.splice(i, 1);\n    }\n\n    // Clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // Background sky gradient\n    const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    grad.addColorStop(0, '#e6f7ff');\n    grad.addColorStop(1, '#f8fff7');\n    ctx.fillStyle = grad;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Draw clouds - calming/wacky shapes using arcs\n    clouds.forEach((c, i) => {\n      ctx.save();\n      ctx.globalAlpha = 0.9 - i * 0.15;\n      ctx.fillStyle = '#ffffff';\n      const cx = c.x;\n      const cy = c.y;\n      const s = c.scale;\n      drawCloud(cx, cy, 90 * s, 40 * s);\n      ctx.restore();\n    });\n\n    // Draw soft hills / ground\n    ctx.fillStyle = '#d7f8d7';\n    ctx.beginPath();\n    ctx.moveTo(0, HEIGHT);\n    ctx.quadraticCurveTo(WIDTH * 0.25, HEIGHT - 80, WIDTH * 0.5, HEIGHT - 40);\n    ctx.quadraticCurveTo(WIDTH * 0.75, HEIGHT - 10, WIDTH, HEIGHT - 70);\n    ctx.lineTo(WIDTH, HEIGHT);\n    ctx.closePath();\n    ctx.fill();\n\n    // Draw wacky drones (calming colors)\n    drawDrone(100, 160 + Math.sin(now / 600) * 6, 1.0, '#89cff0', 'DR-1');\n    drawDrone(540, 190 + Math.sin(now / 700) * 6, 1.1, '#ffd1dc', 'DR-2');\n\n    // Draw top bar UI: score (top-left), lives (top-right), audio icon (top-center right)\n    // Score area\n    ctx.font = FONT_LARGE;\n    ctx.textBaseline = 'top';\n    const scoreText = 'Score: ' + score + ' / ' + GOAL_CORRECT;\n    const scoreMetrics = ctx.measureText(scoreText);\n    const scoreW = Math.ceil(scoreMetrics.width) + 16; // background padding\n    const scoreH = 36;\n    const scoreX = PADDING;\n    const scoreY = PADDING;\n    // background\n    ctx.fillStyle = 'rgba(255,255,255,0.85)';\n    drawRoundedRect(scoreX, scoreY, scoreW, scoreH, 8);\n    // text\n    ctx.fillStyle = '#1b3b6f';\n    ctx.fillText(scoreText, scoreX + 8, scoreY + 6);\n\n    // Lives area - top-right\n    ctx.font = FONT_LARGE;\n    const livesText = 'Lives: ';\n    const livesMetrics = ctx.measureText(livesText);\n    // we'll draw small drone-heart for each life\n    const livesX = WIDTH - PADDING - 120;\n    const livesY = PADDING;\n    const livesW = 120;\n    const livesH = 36;\n    ctx.fillStyle = 'rgba(255,255,255,0.85)';\n    drawRoundedRect(livesX, livesY, livesW, livesH, 8);\n    ctx.fillStyle = '#2c3e50';\n    ctx.fillText(livesText, livesX + 8, livesY + 6);\n    // draw life icons right after text\n    const iconStartX = livesX + 8 + livesMetrics.width + 8;\n    for (let i = 0; i < MAX_LIVES; i++) {\n      const lx = iconStartX + i * 26;\n      drawLifeIcon(lx, livesY + 6, i < lives ? '#ffb4a2' : '#e0e0e0');\n    }\n\n    // Audio icon (visual cue for audio availability) top-center-right\n    ctx.font = FONT_BODY;\n    const audioLabel = soundEnabled ? 'Sound: on (M)' : 'Sound: off (M)';\n    const audioMetrics = ctx.measureText(audioLabel);\n    const audioW = Math.ceil(audioMetrics.width) + 20;\n    const audioH = 28;\n    const audioX = WIDTH - PADDING - audioW - 10;\n    const audioY = livesY + livesH + 8;\n    ctx.fillStyle = 'rgba(255,255,255,0.75)';\n    drawRoundedRect(audioX, audioY, audioW, audioH, 8);\n    ctx.fillStyle = '#1b3b6f';\n    ctx.fillText(audioLabel, audioX + 10, audioY + 4);\n\n    // Center area: question box and options\n    ctx.font = FONT_TITLE;\n    ctx.textBaseline = 'top';\n    const qBoxX = centerArea.x + 12;\n    const qBoxY = centerArea.y + 6;\n    const qBoxW = centerArea.width - 24;\n    const qBoxH = 120;\n    ctx.fillStyle = 'rgba(255,255,255,0.95)';\n    drawRoundedRect(qBoxX, qBoxY, qBoxW, qBoxH, 12);\n\n    if (gameState === 'intro' || gameState === 'waiting') {\n      // Intro screen: instructions\n      ctx.fillStyle = '#0b3d91';\n      ctx.font = FONT_TITLE;\n      const title = 'Drone Math Mission';\n      const titleMetrics = ctx.measureText(title);\n      ctx.fillText(title, qBoxX + (qBoxW - titleMetrics.width) / 2, qBoxY + 12);\n\n      ctx.font = FONT_BODY;\n      const lines = [\n        'Help the friendly drones collect correct numbers!',\n        'Answer 10 questions correctly to win. You have 3 lives.',\n        'Use number keys 1-4 or click options. Press M to toggle sound.',\n        'Click the canvas or press any key to begin.',\n      ];\n      ctx.fillStyle = '#123a6a';\n      let ly = qBoxY + 54;\n      lines.forEach(line => {\n        ctx.fillText(line, qBoxX + 16, ly);\n        ly += 22;\n      });\n    } else {\n      // Gameplay: draw question\n      ctx.fillStyle = '#0b3d91';\n      ctx.font = FONT_TITLE;\n      const questionText = currentQuestion ? currentQuestion.text : '';\n      // measure and center\n      const mq = ctx.measureText(questionText);\n      ctx.fillText(questionText, qBoxX + (qBoxW - mq.width) / 2, qBoxY + 14);\n\n      // Draw options as buttons in two rows\n      ctx.font = FONT_BODY;\n      optionButtons = [];\n      const optW = (qBoxW - 36) / 2;\n      const optH = 44;\n      const optStartX = qBoxX + 12;\n      const optStartY = qBoxY + 64;\n      for (let i = 0; i < 4; i++) {\n        const col = i % 2;\n        const row = Math.floor(i / 2);\n        const x = optStartX + col * (optW + 12);\n        const y = optStartY + row * (optH + 12);\n        // background\n        if (i === selectedOptionIndex) {\n          ctx.fillStyle = 'rgba(143, 188, 143, 0.95)'; // highlighted\n        } else {\n          ctx.fillStyle = 'rgba(255,255,255,0.9)';\n        }\n        drawRoundedRect(x, y, optW, optH, 10);\n        // text\n        ctx.fillStyle = '#0b3d91';\n        const optText = (i + 1) + '. ' + (currentQuestion ? currentQuestion.options[i] : '');\n        const m = ctx.measureText(optText);\n        // ensure text fits\n        let tx = x + 12;\n        ctx.fillText(optText, tx, y + 12);\n        optionButtons.push({x, y, w: optW, h: optH, index: i});\n      }\n    }\n\n    // Bottom instructions area (bottom-center)\n    ctx.font = FONT_BODY;\n    ctx.textBaseline = 'top';\n    const instText = 'Controls: 1-4 to choose, \u2190/\u2192 to change selection, Enter to confirm, M to mute, R to restart';\n    const instMetrics = ctx.measureText(instText);\n    const instW = Math.ceil(instMetrics.width) + 20;\n    const instH = 28;\n    const instX = (WIDTH - instW) / 2;\n    const instY = HEIGHT - bottomBarHeight + 10;\n    ctx.fillStyle = 'rgba(255,255,255,0.9)';\n    drawRoundedRect(instX, instY, instW, instH, 8);\n    ctx.fillStyle = '#173b6a';\n    ctx.fillText(instText, instX + 10, instY + 4);\n\n    // Draw star particles on top\n    starParticles.forEach(p => {\n      ctx.save();\n      ctx.globalAlpha = Math.max(0, p.life);\n      ctx.fillStyle = p.golden ? '#ffd166' : '#a0e7e5';\n      drawStar(p.x, p.y, p.size / 2, p.size, 5);\n      ctx.restore();\n    });\n\n    // Draw overlays for victory or gameover\n    if (gameState === 'victory' || gameState === 'gameover') {\n      ctx.save();\n      ctx.fillStyle = 'rgba(10, 10, 30, 0.6)';\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n      ctx.font = FONT_TITLE;\n      ctx.fillStyle = '#fff';\n      const message = gameState === 'victory' ? 'Victory! Drones Celebrating!' : 'Game Over';\n      const mm = ctx.measureText(message);\n      ctx.fillText(message, (WIDTH - mm.width) / 2, HEIGHT / 2 - 60);\n      ctx.font = FONT_LARGE;\n      const sub = gameState === 'victory' ? 'You answered ' + score + ' correctly!' : 'You answered ' + score + ' correctly.';\n      const sm = ctx.measureText(sub);\n      ctx.fillText(sub, (WIDTH - sm.width) / 2, HEIGHT / 2 - 20);\n\n      // restart button\n      ctx.font = FONT_LARGE;\n      const btnLabel = 'Restart (R)';\n      const bm = ctx.measureText(btnLabel);\n      const bw = bm.width + 24;\n      const bh = 44;\n      const bx = (WIDTH - bw) / 2;\n      const by = HEIGHT / 2 + 30;\n      ctx.fillStyle = '#ffffff';\n      drawRoundedRect(bx, by, bw, bh, 12);\n      ctx.fillStyle = '#0b3d91';\n      ctx.fillText(btnLabel, bx + 12, by + 8);\n      // store restart button rect for clicks\n      restartButtonRect = {x: bx, y: by, w: bw, h: bh};\n      ctx.restore();\n    } else {\n      restartButtonRect = null;\n    }\n\n    // Draw small help/hint at corner regarding audio availability\n    ctx.font = '14px sans-serif';\n    ctx.fillStyle = '#123a6a';\n    const hint = audioError ? 'Audio not available' : (audioAllowed ? 'Audio ready' : 'Click or press any key to enable audio');\n    const mh = ctx.measureText(hint);\n    ctx.fillStyle = 'rgba(255,255,255,0.9)';\n    drawRoundedRect(10, HEIGHT - 36, mh.width + 16, 26, 8);\n    ctx.fillStyle = '#123a6a';\n    ctx.fillText(hint, 18, HEIGHT - 34);\n\n    // Loop\n    requestAnimationFrame(render);\n  }\n\n  // Draw cloud helper\n  function drawCloud(cx, cy, w, h) {\n    ctx.beginPath();\n    ctx.ellipse(cx, cy, w * 0.6, h * 0.6, 0, 0, Math.PI * 2);\n    ctx.ellipse(cx - w * 0.4, cy + 10, w * 0.45, h * 0.45, -0.3, 0, Math.PI * 2);\n    ctx.ellipse(cx + w * 0.4, cy + 8, w * 0.48, h * 0.48, 0.3, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  // Draw a wacky drone (simple shapes)\n  function drawDrone(x, y, scale, color, label) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.scale(scale, scale);\n\n    // body\n    ctx.fillStyle = color;\n    drawRoundedRect(-36, -18, 72, 40, 10);\n\n    // dome\n    ctx.beginPath();\n    ctx.fillStyle = '#ffffff';\n    ctx.arc(0, -6, 14, Math.PI, 2 * Math.PI);\n    ctx.fill();\n\n    // propellers - wacky gentle arcs\n    ctx.fillStyle = '#bdbdbd';\n    for (let i = -1; i <= 1; i += 2) {\n      ctx.beginPath();\n      ctx.ellipse(-42 * i, -26, 8, 4, Math.PI / 6 * i, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // eyes on dome\n    ctx.fillStyle = '#2c3e50';\n    ctx.beginPath();\n    ctx.arc(-5, -8, 2.6, 0, Math.PI * 2);\n    ctx.arc(6, -8, 2.6, 0, Math.PI * 2);\n    ctx.fill();\n\n    // little label\n    ctx.font = '11px sans-serif';\n    ctx.fillStyle = '#0b3d91';\n    ctx.fillText(label || '', -12, 10);\n\n    ctx.restore();\n  }\n\n  // Draw life icon (heart-like)\n  function drawLifeIcon(x, y, fill) {\n    ctx.save();\n    ctx.fillStyle = fill;\n    ctx.beginPath();\n    ctx.moveTo(x + 6, y + 3);\n    ctx.bezierCurveTo(x + 6, y - 2, x - 4, y - 2, x - 4, y + 4);\n    ctx.bezierCurveTo(x - 4, y + 9, x + 6, y + 12, x + 6, y + 14);\n    ctx.bezierCurveTo(x + 6, y + 12, x + 16, y + 9, x + 16, y + 4);\n    ctx.bezierCurveTo(x + 16, y - 2, x + 6, y - 2, x + 6, y + 3);\n    ctx.closePath();\n    ctx.fill();\n    ctx.restore();\n  }\n\n  // Draw star helper\n  function drawStar(cx, cy, innerR, outerR, points) {\n    ctx.beginPath();\n    const step = Math.PI / points;\n    for (let i = 0; i < 2 * points; i++) {\n      const r = i % 2 === 0 ? outerR : innerR;\n      const a = i * step - Math.PI / 2;\n      ctx.lineTo(cx + Math.cos(a) * r, cy + Math.sin(a) * r);\n    }\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  // Input handling\n  let restartButtonRect = null;\n\n  canvas.addEventListener('click', function (e) {\n    lastUserGesture = true;\n    ensureAudioInited();\n    canvas.focus();\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    if (gameState === 'intro' || gameState === 'waiting') {\n      startGame();\n      return;\n    }\n\n    if (gameState === 'victory' || gameState === 'gameover') {\n      if (restartButtonRect && pointInRect(x, y, restartButtonRect)) {\n        restartGame();\n      }\n      return;\n    }\n\n    // check if clicked on option button\n    for (const b of optionButtons) {\n      if (pointInRect(x, y, b)) {\n        selectedOptionIndex = b.index;\n        chooseOption(b.index);\n        return;\n      }\n    }\n\n    // else if clicked audio area (approx by top-right audio rectangle)\n    // We'll allow toggling if click near top-right area\n    if (x > WIDTH - 200 && y < 110) {\n      soundEnabled = !soundEnabled;\n      announce('Sound ' + (soundEnabled ? 'on' : 'off'));\n      return;\n    }\n  });\n\n  // Keyboard controls\n  canvas.addEventListener('keydown', function (e) {\n    lastUserGesture = true;\n    ensureAudioInited();\n    if (e.key >= '1' && e.key <= '4') {\n      if (gameState === 'playing') {\n        const idx = parseInt(e.key, 10) - 1;\n        selectedOptionIndex = idx;\n        chooseOption(idx);\n      }\n      e.preventDefault();\n      return;\n    }\n    if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {\n      if (gameState === 'playing') {\n        selectedOptionIndex = (selectedOptionIndex + 3) % 4;\n      }\n      e.preventDefault();\n      return;\n    }\n    if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {\n      if (gameState === 'playing') {\n        selectedOptionIndex = (selectedOptionIndex + 1) % 4;\n      }\n      e.preventDefault();\n      return;\n    }\n    if (e.key === 'Enter') {\n      if (gameState === 'playing') {\n        chooseOption(selectedOptionIndex);\n      } else if (gameState === 'victory' || gameState === 'gameover') {\n        restartGame();\n      } else if (gameState === 'intro' || gameState === 'waiting') {\n        startGame();\n      }\n      e.preventDefault();\n      return;\n    }\n    if (e.key === 'm' || e.key === 'M') {\n      soundEnabled = !soundEnabled;\n      announce('Sound ' + (soundEnabled ? 'on' : 'off'));\n      e.preventDefault();\n      return;\n    }\n    if (e.key === 'r' || e.key === 'R') {\n      restartGame();\n      e.preventDefault();\n      return;\n    }\n    // any other key starts audio\n    if (gameState === 'intro' && !lastUserGesture) {\n      lastUserGesture = true;\n      ensureAudioInited();\n      startGame();\n    }\n  });\n\n  function pointInRect(px, py, r) {\n    return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;\n  }\n\n  // Ensure audio started after user gesture\n  function ensureAudioInited() {\n    try {\n      if (!audioCtx) initAudio();\n      if (audioCtx && audioCtx.state === 'suspended') {\n        audioCtx.resume().catch(e => {\n          audioAllowed = false;\n          audioError = 'Audio resume error: ' + e.message;\n          console.warn(audioError);\n        });\n      }\n    } catch (e) {\n      audioAllowed = false;\n      audioError = 'Audio init error: ' + (e && e.message ? e.message : e);\n      console.warn(audioError);\n    }\n  }\n\n  // Start rendering\n  requestAnimationFrame(render);\n\n  // Start in intro/waiting state\n  gameState = 'intro';\n  announce('Welcome to Drone Math Mission. Click or press any key to begin.');\n\n  // Accessibility: focus to canvas to allow keyboard interactions\n  canvas.addEventListener('focus', () => {\n    // no-op but helpful\n  });\n\n  // Expose minimal controls via container for assistive tech (non-intrusive)\n  container.addEventListener('keydown', function (e) {\n    // forward to canvas handlers\n    canvas.dispatchEvent(new KeyboardEvent('keydown', e));\n  });\n\n  // Error handling demonstration (audio)\n  window.addEventListener('unhandledrejection', function (ev) {\n    console.warn('Unhandled promise rejection in game', ev.reason);\n  });\n\n  // Utility: Start the audio context if the user clicks anywhere in the container\n  container.addEventListener('pointerdown', function () {\n    lastUserGesture = true;\n    ensureAudioInited();\n  }, {passive: true});\n\n})();\n---\n",
  "improve_response_tokens": 17641,
  "formatted_code": true,
  "formatting_response_tokens": 18389,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}