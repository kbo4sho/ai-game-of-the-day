{
  "generated_date": "2025-09-21",
  "generated_timestamp": "2025-09-21T00:28:36.647382",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9229,
  "game_filename": "2025-09-21.js",
  "game_size_bytes": 27514,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Machines Math Game \u2014 JavaScript (renders inside #game-of-the-day-stage)\n// Note: This script creates a 720x480 canvas, Web Audio sounds, and a playable math game.\n// It uses only Canvas and Web Audio API. No external assets.\n// Accessible: keyboard controls, aria-live updates, visual cues, and error handling.\n\n// Immediately-invoked function to avoid leaking globals\n(function () {\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const MAX_LEVEL = 6;\n  const SLOT_BASE = 2; // starting number of slots (numbers needed)\n  const CONTAINER_ID = \"game-of-the-day-stage\";\n  const COLORS = {\n    bg: \"#E8F5F2\",\n    machine: \"#C7E5E0\",\n    accent: \"#7FB8A4\",\n    gear: \"#F6D1A3\",\n    gear2: \"#D8B4E2\",\n    text: \"#1F2933\",\n    correct: \"#3AB795\",\n    incorrect: \"#FF6B6B\",\n    slot: \"#F3F6F8\",\n    focus: \"#FFD97A\",\n    muted: \"#AAA\",\n  };\n\n  // Helper: safe DOM retrieval\n  const container = document.getElementById(CONTAINER_ID);\n  if (!container) {\n    console.error(`Container element with id \"${CONTAINER_ID}\" not found.`);\n    return;\n  }\n\n  // Create ARIA live region for screen readers (inside container)\n  const ariaLive = document.createElement(\"div\");\n  ariaLive.setAttribute(\"aria-live\", \"polite\");\n  ariaLive.setAttribute(\"role\", \"status\");\n  ariaLive.style.position = \"absolute\";\n  ariaLive.style.left = \"-9999px\";\n  ariaLive.style.width = \"1px\";\n  ariaLive.style.height = \"1px\";\n  ariaLive.style.overflow = \"hidden\";\n  container.appendChild(ariaLive);\n\n  // Create canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.tabIndex = 0; // allow keyboard focus\n  canvas.style.width = WIDTH + \"px\";\n  canvas.style.height = HEIGHT + \"px\";\n  canvas.style.outline = \"none\";\n  canvas.setAttribute(\"role\", \"application\");\n  canvas.setAttribute(\"aria-label\", \"Machines Math Game. Use arrow keys to move, space to pick, M to mute.\");\n  container.style.position = \"relative\";\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext(\"2d\");\n  // Crisp rendering for high DPI displays\n  (function adjustForHiDPI() {\n    const dpr = window.devicePixelRatio || 1;\n    if (dpr !== 1) {\n      canvas.width = WIDTH * dpr;\n      canvas.height = HEIGHT * dpr;\n      canvas.style.width = WIDTH + \"px\";\n      canvas.style.height = HEIGHT + \"px\";\n      ctx.scale(dpr, dpr);\n    }\n  })();\n\n  // Audio: Web Audio API setup with error handling\n  let audioCtx = null;\n  let bgGain = null;\n  let bgOsc = null;\n  let audioAllowed = false;\n  let muted = false;\n\n  function createAudioContextOnUserGesture() {\n    if (audioCtx || !window.AudioContext) return;\n    try {\n      audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n      // gentle background drone\n      bgGain = audioCtx.createGain();\n      bgGain.gain.value = 0.02; // very gentle\n      const masterGain = audioCtx.createGain();\n      masterGain.gain.value = 1;\n      bgGain.connect(masterGain);\n      masterGain.connect(audioCtx.destination);\n\n      bgOsc = audioCtx.createOscillator();\n      bgOsc.type = \"sine\";\n      bgOsc.frequency.value = 90; // low hum\n      // add lowpass for gentle feel\n      const lp = audioCtx.createBiquadFilter();\n      lp.type = \"lowpass\";\n      lp.frequency.value = 600;\n      bgOsc.connect(lp);\n      lp.connect(bgGain);\n      bgOsc.start();\n\n      // ensure muted respects older state\n      updateAudioMuteState();\n      audioAllowed = true;\n    } catch (e) {\n      console.error(\"Web Audio API error:\", e);\n      audioAllowed = false;\n      audioCtx = null;\n    }\n  }\n\n  function safePlayTone({ freq = 440, duration = 0.25, type = \"sine\", volume = 0.2, decay = 0.02 }) {\n    if (!audioAllowed || muted || !audioCtx) return;\n    try {\n      const o = audioCtx.createOscillator();\n      o.type = type;\n      o.frequency.value = freq;\n      const g = audioCtx.createGain();\n      g.gain.setValueAtTime(volume, audioCtx.currentTime);\n      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration + decay);\n      o.connect(g);\n      g.connect(audioCtx.destination);\n      o.start();\n      o.stop(audioCtx.currentTime + duration + decay);\n    } catch (e) {\n      console.error(\"Tone play error:\", e);\n    }\n  }\n\n  function playCorrect() {\n    if (!audioAllowed || muted || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const freqs = [880, 1100, 1320];\n      freqs.forEach((f, i) => {\n        const o = audioCtx.createOscillator();\n        o.type = \"sine\";\n        const g = audioCtx.createGain();\n        g.gain.setValueAtTime(0.18 / (i + 1), now);\n        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.4 + i * 0.02);\n        o.frequency.value = f;\n        o.connect(g);\n        g.connect(audioCtx.destination);\n        o.start(now + i * 0.02);\n        o.stop(now + 0.4 + i * 0.02);\n      });\n    } catch (e) {\n      console.error(\"playCorrect error:\", e);\n    }\n  }\n\n  function playIncorrect() {\n    safePlayTone({ freq: 200, duration: 0.28, type: \"sawtooth\", volume: 0.28 });\n    // short buzz\n    setTimeout(() => safePlayTone({ freq: 160, duration: 0.18, type: \"sawtooth\", volume: 0.18 }), 120);\n  }\n\n  function playClick() {\n    safePlayTone({ freq: 660, duration: 0.08, type: \"triangle\", volume: 0.09 });\n  }\n\n  function updateAudioMuteState() {\n    if (!audioCtx) return;\n    if (bgGain) bgGain.gain.value = muted ? 0 : 0.02;\n  }\n\n  // Game state\n  let level = 1;\n  let gears = []; // {value, x,y,r, picked}\n  let slots = []; // {x,y,w,h, value (null if empty)}\n  let requiredSlots = SLOT_BASE; // number of numbers to place\n  let target = 0;\n  let selectedGearIndex = null; // index in gears currently \"holding\" (picked up)\n  let focusIndex = 0; // for keyboard: focus among interactable items (gears then slots)\n  let attemptsLeft = 3;\n  let solvedCount = 0;\n  let playing = true;\n  let message = \"Click a gear and put it in the machine to match the target!\";\n  let showCelebration = false;\n\n  // Accessibility announcement helper\n  function announce(text) {\n    ariaLive.textContent = text;\n  }\n\n  // Generate a level ensuring solvable combination\n  function generateLevel(lv) {\n    requiredSlots = Math.min(4, SLOT_BASE + Math.floor((lv - 1) / 2)); // increases occasionally\n    attemptsLeft = 3;\n    selectedGearIndex = null;\n    focusIndex = 0;\n    showCelebration = false;\n    // Create some base numbers\n    const poolSize = Math.min(7, requiredSlots + 3);\n    let base = [];\n    for (let i = 0; i < poolSize; i++) {\n      base.push(Math.floor(Math.random() * Math.min(10 + lv * 2, 20)) + 1);\n    }\n    // To ensure solvable, pick requiredSlots numbers to sum as the target\n    const chosenIndices = [];\n    while (chosenIndices.length < requiredSlots) {\n      const idx = Math.floor(Math.random() * base.length);\n      if (!chosenIndices.includes(idx)) chosenIndices.push(idx);\n    }\n    target = chosenIndices.reduce((s, idx) => s + base[idx], 0);\n\n    // Add or replace with small variations for difficulty as levels rise\n    if (lv >= 3) {\n      // ensure at least one small number\n      base.push(1 + Math.floor(Math.random() * Math.min(8, lv + 2)));\n    }\n    // Shuffle base\n    base = shuffleArray(base);\n\n    // Build gears from base\n    gears = [];\n    const trayX = 80;\n    const trayY = 340;\n    const spacing = 80;\n    for (let i = 0; i < base.length; i++) {\n      const gx = trayX + (i % 7) * spacing;\n      const gy = trayY + Math.floor(i / 7) * 70;\n      gears.push({\n        value: base[i],\n        x: gx,\n        y: gy,\n        r: 28,\n        picked: false,\n        id: i,\n      });\n    }\n\n    // Create slots (machine inputs)\n    slots = [];\n    const slotW = 74;\n    const slotH = 54;\n    const machineCenterX = 440;\n    const machineTopY = 160;\n    const slotGap = 12;\n    const totalW = requiredSlots * slotW + (requiredSlots - 1) * slotGap;\n    const startX = machineCenterX - totalW / 2;\n    for (let i = 0; i < requiredSlots; i++) {\n      slots.push({\n        x: startX + i * (slotW + slotGap),\n        y: machineTopY + 68,\n        w: slotW,\n        h: slotH,\n        value: null,\n      });\n    }\n\n    message = `Level ${lv}: Put ${requiredSlots} numbers into the machine to make ${target}.`;\n    announce(message);\n  }\n\n  function shuffleArray(arr) {\n    const copy = arr.slice();\n    for (let i = copy.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [copy[i], copy[j]] = [copy[j], copy[i]];\n    }\n    return copy;\n  }\n\n  // Input handling\n  let lastMousePos = { x: 0, y: 0 };\n\n  canvas.addEventListener(\"mousedown\", (e) => {\n    canvas.focus();\n    createAudioContextOnUserGesture(); // enable audio on first interaction\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    lastMousePos = { x, y };\n    handleClick(x, y);\n  });\n\n  canvas.addEventListener(\"mousemove\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    lastMousePos = { x: e.clientX - rect.left, y: e.clientY - rect.top };\n  });\n\n  // Keyboard controls\n  // Left/Right to move focus among gears and slots. Up/Down to jump between tray and slots.\n  // Space or Enter to pick/place. M to mute.\n  canvas.addEventListener(\"keydown\", (e) => {\n    const totalInteractables = gears.length + slots.length;\n    if (!playing) {\n      if (e.key === \"Enter\" || e.key === \" \") {\n        e.preventDefault();\n        restartGame();\n      }\n      return;\n    }\n    if (e.key === \"m\" || e.key === \"M\") {\n      e.preventDefault();\n      muted = !muted;\n      updateAudioMuteState();\n      announce(muted ? \"Muted\" : \"Sound on\");\n      return;\n    }\n    if (e.key === \"ArrowRight\") {\n      e.preventDefault();\n      focusIndex = (focusIndex + 1) % (gears.length + slots.length);\n      playClick();\n    } else if (e.key === \"ArrowLeft\") {\n      e.preventDefault();\n      focusIndex = (focusIndex - 1 + gears.length + slots.length) % (gears.length + slots.length);\n      playClick();\n    } else if (e.key === \"ArrowUp\" || e.key === \"ArrowDown\") {\n      e.preventDefault();\n      // If focus is in gears area go to slots or vice versa\n      if (focusIndex < gears.length) {\n        // move to a corresponding slot or first slot\n        focusIndex = gears.length + Math.min(0, slots.length - 1);\n      } else {\n        focusIndex = 0;\n      }\n      playClick();\n    } else if (e.key === \" \" || e.key === \"Enter\") {\n      e.preventDefault();\n      // Activate the focused item\n      if (focusIndex < gears.length) {\n        const gIdx = focusIndex;\n        pickGearByIndex(gIdx);\n      } else {\n        const sIdx = focusIndex - gears.length;\n        placeToSlot(sIdx);\n      }\n    } else if (/^\\d$/.test(e.key)) {\n      // Press number to quickly pick gear by displayed index (1-based shown on canvas)\n      const num = parseInt(e.key, 10);\n      if (num >= 1 && num <= gears.length) {\n        pickGearByIndex(num - 1);\n      }\n    }\n  });\n\n  // Click handling logic\n  function handleClick(x, y) {\n    // Check gears first\n    for (let i = 0; i < gears.length; i++) {\n      const g = gears[i];\n      if (pointInCircle(x, y, g.x, g.y, g.r + 6)) {\n        pickGearByIndex(i);\n        return;\n      }\n    }\n    // Check slots\n    for (let i = 0; i < slots.length; i++) {\n      const s = slots[i];\n      if (pointInRect(x, y, s.x, s.y, s.w, s.h)) {\n        placeToSlot(i);\n        return;\n      }\n    }\n    // Click elsewhere: if holding a gear, drop it back to tray\n    if (selectedGearIndex !== null) {\n      // return gear\n      gears[selectedGearIndex].picked = false;\n      selectedGearIndex = null;\n      playClick();\n      announce(\"Returned gear to tray.\");\n    }\n  }\n\n  // Helpers\n  function pointInCircle(px, py, cx, cy, r) {\n    const dx = px - cx;\n    const dy = py - cy;\n    return dx * dx + dy * dy <= r * r;\n  }\n  function pointInRect(px, py, rx, ry, rw, rh) {\n    return px >= rx && px <= rx + rw && py >= ry && py <= ry + rh;\n  }\n\n  function pickGearByIndex(index) {\n    if (index < 0 || index >= gears.length) return;\n    createAudioContextOnUserGesture();\n    const gear = gears[index];\n    if (gear.picked) {\n      // if already picked, unpick\n      gear.picked = false;\n      selectedGearIndex = null;\n      playClick();\n      announce(`Returned ${gear.value} to tray.`);\n    } else {\n      // pick it\n      // cannot pick if it's already placed in a slot\n      if (isGearInSlot(index)) {\n        // find and remove from slot\n        removeGearFromSlots(index);\n        gear.picked = true;\n        selectedGearIndex = index;\n        playClick();\n        announce(`Picked ${gear.value} from machine.`);\n      } else {\n        gear.picked = true;\n        selectedGearIndex = index;\n        playClick();\n        announce(`Picked ${gear.value}. Click a slot to place it in the machine.`);\n      }\n    }\n  }\n\n  function isGearInSlot(gearIndex) {\n    return slots.some((s) => s.value === gearIndex);\n  }\n\n  function removeGearFromSlots(gearIndex) {\n    for (const s of slots) {\n      if (s.value === gearIndex) {\n        s.value = null;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function placeToSlot(slotIdx) {\n    createAudioContextOnUserGesture();\n    if (slotIdx < 0 || slotIdx >= slots.length) return;\n    const slot = slots[slotIdx];\n    if (selectedGearIndex === null) {\n      // if none selected, maybe pick gear currently in slot\n      if (slot.value !== null) {\n        const gIdx = slot.value;\n        slot.value = null;\n        // pick gear\n        gears[gIdx].picked = true;\n        selectedGearIndex = gIdx;\n        playClick();\n        announce(`Lifted ${gears[gIdx].value} from slot ${slotIdx + 1}.`);\n      } else {\n        // nothing happens\n        playClick();\n      }\n      return;\n    } else {\n      // place the picked gear into the slot (if slot is empty)\n      if (slot.value !== null) {\n        // swap: put existing gear back to tray and place new one\n        const existing = slot.value;\n        // existing goes back to tray\n        slots[slotIdx].value = selectedGearIndex;\n        gears[selectedGearIndex].picked = false;\n        // pick up existing gear instead\n        gears[existing].picked = true;\n        selectedGearIndex = existing;\n        playClick();\n        announce(`Swapped ${gears[existing].value} with ${gears[slots[slotIdx].value].value}.`);\n      } else {\n        slots[slotIdx].value = selectedGearIndex;\n        gears[selectedGearIndex].picked = false;\n        const placedVal = gears[selectedGearIndex].value;\n        selectedGearIndex = null;\n        playClick();\n        announce(`Placed ${placedVal} into slot ${slotIdx + 1}.`);\n      }\n    }\n    // After placing, check machine if full\n    checkMachine();\n  }\n\n  function checkMachine() {\n    // Check if all slots are filled\n    if (slots.some((s) => s.value === null)) {\n      return;\n    }\n    // Calculate sum of values in slots\n    const sum = slots.reduce((s, sl) => s + gears[sl.value].value, 0);\n    if (sum === target) {\n      // success\n      playCorrect();\n      message = \"Perfect! The machine whirs happily \u2014 you solved it!\";\n      announce(`Correct! You solved level ${level}.`);\n      solvedCount++;\n      showCelebration = true;\n      // progress to next level after short delay\n      setTimeout(() => {\n        if (level >= MAX_LEVEL) {\n          // game finished\n          playing = false;\n          message = `Amazing! You completed all levels! Press Enter to play again.`;\n          announce(\"All levels completed. Congratulations!\");\n        } else {\n          level++;\n          generateLevel(level);\n        }\n        requestRender();\n      }, 900);\n    } else {\n      // incorrect\n      playIncorrect();\n      attemptsLeft--;\n      const hint = generateHint(sum, target);\n      message = `Almost \u2014 machine output ${sum}. ${hint} Attempts left: ${attemptsLeft}`;\n      announce(`Incorrect. Machine output ${sum}.` + (attemptsLeft > 0 ? ` ${attemptsLeft} attempts left.` : \" No attempts left.\"));\n      // shake animation or visual cue handled in render\n      if (attemptsLeft <= 0) {\n        // level failed: reveal solution and move to next or reset\n        message = `Oh no \u2014 out of attempts. The machine resets. The target was ${target}.`;\n        announce(`Out of attempts. The target was ${target}.`);\n        setTimeout(() => {\n          if (level > 1) {\n            level = Math.max(1, level - 1); // gentle rollback\n          }\n          generateLevel(level);\n        }, 1200);\n      } else {\n        // clear one random slot to give chance\n        const filledSlots = slots.map((s, i) => (s.value !== null ? i : -1)).filter((i) => i !== -1);\n        if (filledSlots.length > 0) {\n          const idxToClear = filledSlots[Math.floor(Math.random() * filledSlots.length)];\n          const gearIdx = slots[idxToClear].value;\n          slots[idxToClear].value = null;\n          gears[gearIdx].picked = false;\n          announce(`One number was ejected from slot ${idxToClear + 1}.`);\n        }\n      }\n    }\n  }\n\n  function generateHint(sum, targetVal) {\n    const diff = Math.abs(sum - targetVal);\n    if (diff === 0) return \"Perfect!\";\n    if (diff <= 2) return \"You're very close \u2014 try a slightly different number.\";\n    if (diff <= 5) return \"A different small number might help.\";\n    return \"Try changing a larger number to get closer.\";\n  }\n\n  // Render loop\n  let lastTick = 0;\n  let shakeTime = 0;\n\n  function requestRender() {\n    // schedule an immediate redraw\n    draw();\n  }\n\n  function draw() {\n    try {\n      // Background\n      ctx.clearRect(0, 0, WIDTH, HEIGHT);\n      drawBackground();\n      drawMachine();\n      drawSlots();\n      drawGears();\n      drawHUD();\n      drawInstructions();\n      if (showCelebration) drawConfetti();\n    } catch (e) {\n      console.error(\"Draw error:\", e);\n    }\n  }\n\n  function drawBackground() {\n    // calming gradient\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, COLORS.bg);\n    g.addColorStop(1, \"#F6FBF9\");\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // wacky pipes\n    ctx.fillStyle = COLORS.machine;\n    roundedRect(ctx, 360, 50, 320, 120, 20);\n    ctx.fill();\n\n    // small gears pattern top-left\n    for (let i = 0; i < 6; i++) {\n      drawTinyGear(40 + i * 40, 60 + ((i % 2) * 12), 10, i % 2 === 0 ? COLORS.gear : COLORS.gear2, 0.6);\n    }\n  }\n\n  function drawMachine() {\n    // central machine body\n    ctx.save();\n    ctx.translate(360, 120);\n    ctx.fillStyle = COLORS.accent;\n    ctx.fillRect(-200, -20, 400, 160);\n    // window\n    ctx.fillStyle = \"#EDF7F6\";\n    roundedRect(ctx, 80, 10, 120, 80, 8);\n    ctx.fill();\n    // target display area\n    ctx.fillStyle = \"#FFF\";\n    roundedRect(ctx, 420, 30, 220, 90, 12);\n    ctx.fill();\n\n    // target text\n    ctx.restore();\n    // draw target box with label\n    ctx.fillStyle = \"#FFFFFF\";\n    roundedRect(ctx, 430, 38, 200, 74, 12);\n    ctx.fill();\n    ctx.strokeStyle = \"#E0EEF1\";\n    ctx.lineWidth = 2;\n    ctx.stroke();\n\n    ctx.fillStyle = COLORS.text;\n    ctx.font = \"20px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"MATH MACHINE\", 520, 75);\n\n    // Target number big\n    ctx.fillStyle = COLORS.accent;\n    ctx.font = \"44px sans-serif\";\n    ctx.fillText(String(target), 520, 110);\n  }\n\n  function drawSlots() {\n    for (let i = 0; i < slots.length; i++) {\n      const s = slots[i];\n      ctx.fillStyle = COLORS.slot;\n      roundedRect(ctx, s.x, s.y, s.w, s.h, 8);\n      ctx.fill();\n      ctx.strokeStyle = \"#DCEFF0\";\n      ctx.stroke();\n\n      // draw the index\n      ctx.fillStyle = \"#8AAFB0\";\n      ctx.font = \"12px sans-serif\";\n      ctx.textAlign = \"left\";\n      ctx.fillText(`slot ${i + 1}`, s.x + 6, s.y - 6);\n\n      if (s.value !== null) {\n        const g = gears[s.value];\n        // draw gear inside slot (slightly larger)\n        drawGear(s.x + s.w / 2, s.y + s.h / 2, 24, g.value, true, s.value === selectedGearIndex);\n      } else {\n        // empty placeholder\n        ctx.fillStyle = \"#F8FAFC\";\n        ctx.font = \"16px sans-serif\";\n        ctx.textAlign = \"center\";\n        ctx.fillStyle = \"#9FBCC0\";\n        ctx.fillText(\"\u2014\", s.x + s.w / 2, s.y + s.h / 2 + 6);\n      }\n    }\n  }\n\n  function drawGears() {\n    // tray label\n    ctx.fillStyle = \"#7FAFA1\";\n    ctx.font = \"14px sans-serif\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(\"Gear Tray\", 60, 320);\n\n    // draw each gear\n    for (let i = 0; i < gears.length; i++) {\n      const g = gears[i];\n      let drawX = g.x;\n      let drawY = g.y;\n      if (g.picked && selectedGearIndex === i) {\n        // follow mouse\n        drawX = lastMousePos.x;\n        drawY = lastMousePos.y;\n      }\n      drawGear(drawX, drawY, g.r, g.value, false, focusIndex === i);\n      // index text near gear for keyboard number\n      ctx.fillStyle = \"#375455\";\n      ctx.font = \"12px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(String(i + 1), drawX, drawY + 44);\n    }\n  }\n\n  function drawHUD() {\n    // attempts and level info\n    ctx.fillStyle = COLORS.text;\n    ctx.font = \"16px sans-serif\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(`Level ${level} of ${MAX_LEVEL}`, 16, 24);\n\n    // attempts hearts\n    for (let i = 0; i < 3; i++) {\n      const x = 16 + i * 28;\n      drawHeart(x, 36, 10, i < attemptsLeft ? COLORS.correct : \"#EEE\");\n    }\n\n    // mute state icon\n    ctx.fillStyle = muted ? COLORS.muted : COLORS.accent;\n    roundedRect(ctx, WIDTH - 110, 16, 92, 36, 8);\n    ctx.fill();\n    ctx.fillStyle = \"#FFFFFF\";\n    ctx.font = \"14px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(muted ? \"Muted (M)\" : \"Sound (M)\", WIDTH - 60, 40);\n\n    // small progress\n    ctx.fillStyle = \"#1F2933\";\n    ctx.font = \"14px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(`Solved: ${solvedCount}`, WIDTH - 60, 68);\n\n    // message box bottom\n    ctx.fillStyle = \"#FFFFFF\";\n    roundedRect(ctx, 18, HEIGHT - 86, WIDTH - 36, 62, 10);\n    ctx.fill();\n    ctx.strokeStyle = \"#E5F0EF\";\n    ctx.stroke();\n    ctx.fillStyle = COLORS.text;\n    ctx.font = \"14px sans-serif\";\n    ctx.textAlign = \"left\";\n    wrapText(ctx, message, 34, HEIGHT - 54, WIDTH - 68, 18);\n  }\n\n  function drawInstructions() {\n    ctx.fillStyle = \"#123\";\n    ctx.font = \"12px sans-serif\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(\"Controls: Click or use keyboard. Arrow keys to move, Space/Enter to pick/place.\", 18, HEIGHT - 12);\n  }\n\n  // Draw a decorated gear (simple)\n  function drawGear(cx, cy, radius, number, inSlot = false, focused = false) {\n    // Teeth\n    ctx.save();\n    ctx.translate(cx, cy);\n    ctx.beginPath();\n    const teeth = 10;\n    for (let i = 0; i < teeth; i++) {\n      const angle = (i / teeth) * Math.PI * 2;\n      const rOuter = radius + 8;\n      const rInner = radius - 2;\n      const px = Math.cos(angle) * rOuter;\n      const py = Math.sin(angle) * rOuter;\n      const ix = Math.cos(angle + 0.12) * rInner;\n      const iy = Math.sin(angle + 0.12) * rInner;\n      if (i === 0) ctx.moveTo(px, py);\n      ctx.lineTo(px, py);\n      ctx.lineTo(ix, iy);\n    }\n    ctx.closePath();\n    ctx.fillStyle = inSlot ? COLORS.gear2 : COLORS.gear;\n    ctx.fill();\n    // center circle\n    ctx.beginPath();\n    ctx.arc(0, 0, radius - 6, 0, Math.PI * 2);\n    ctx.fillStyle = inSlot ? \"#FFFFFF\" : \"#FFF8F0\";\n    ctx.fill();\n    ctx.strokeStyle = \"#E9EFEF\";\n    ctx.stroke();\n\n    // number\n    ctx.fillStyle = COLORS.text;\n    ctx.font = \"16px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(String(number), 0, 6);\n\n    if (focused) {\n      ctx.beginPath();\n      ctx.arc(0, 0, radius + 12, 0, Math.PI * 2);\n      ctx.strokeStyle = COLORS.focus;\n      ctx.lineWidth = 3;\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  function drawTinyGear(x, y, r, color, alpha = 1) {\n    ctx.save();\n    ctx.globalAlpha = alpha;\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.arc(x, y, r, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function drawHeart(cx, cy, size, color) {\n    ctx.save();\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    const x = cx;\n    const y = cy;\n    ctx.moveTo(x, y);\n    ctx.bezierCurveTo(x, y - size / 2, x - size, y - size / 2, x - size, y + size / 4);\n    ctx.bezierCurveTo(x - size, y + size, x, y + size * 1.3, x, y + size * 1.6);\n    ctx.bezierCurveTo(x, y + size * 1.3, x + size, y + size, x + size, y + size / 4);\n    ctx.bezierCurveTo(x + size, y - size / 2, x, y - size / 2, x, y);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function drawConfetti() {\n    // simple celebratory dots near machine\n    for (let i = 0; i < 30; i++) {\n      const x = 420 + Math.sin(i) * 120 + (Math.random() * 40 - 20);\n      const y = 120 + (i % 5) * 12 + (Math.random() * 30 - 10);\n      ctx.fillStyle = i % 2 === 0 ? \"#FFD97A\" : \"#80D4C6\";\n      ctx.beginPath();\n      ctx.arc(x, y, 4, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n\n  // Utilities\n  function roundedRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n  }\n\n  function wrapText(context, text, x, y, maxWidth, lineHeight) {\n    const words = text.split(\" \");\n    let line = \"\";\n    for (let n = 0; n < words.length; n++) {\n      const testLine = line + words[n] + \" \";\n      const metrics = context.measureText(testLine);\n      const testWidth = metrics.width;\n      if (testWidth > maxWidth && n > 0) {\n        context.fillText(line, x, y);\n        line = words[n] + \" \";\n        y += lineHeight;\n      } else {\n        line = testLine;\n      }\n    }\n    context.fillText(line, x, y);\n  }\n\n  // Game control\n  function restartGame() {\n    level = 1;\n    solvedCount = 0;\n    playing = true;\n    generateLevel(level);\n    announce(\"New game started. \" + message);\n    requestRender();\n  }\n\n  // Initialize\n  generateLevel(level);\n  draw();\n\n  // Expose mute toggle via click on the mute area\n  canvas.addEventListener(\"click\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    // check mute area\n    if (x >= WIDTH - 110 && x <= WIDTH - 18 && y >= 16 && y <= 52) {\n      muted = !muted;\n      createAudioContextOnUserGesture();\n      updateAudioMuteState();\n      announce(muted ? \"Muted\" : \"Sound on\");\n      draw();\n    }\n  });\n\n  // Handle window resize for accessibility (keep canvas fixed but re-render)\n  window.addEventListener(\"resize\", () => {\n    draw();\n  });\n\n  // Add safe try/catch for audio start when user interacts with canvas\n  canvas.addEventListener(\"pointerdown\", () => {\n    try {\n      createAudioContextOnUserGesture();\n    } catch (e) {\n      console.error(\"Audio gesture error:\", e);\n    }\n  });\n\n  // Animation loop for subtle effects (e.g., moving background)\n  let animFrame = null;\n  function animate(t) {\n    // subtle pulsing background by slightly changing ambient color\n    lastTick = t;\n    // reduce CPU usage by redrawing only when needed: we'll redraw each frame to keep interaction smooth\n    draw();\n    animFrame = requestAnimationFrame(animate);\n  }\n  animFrame = requestAnimationFrame(animate);\n\n  // Clean-up when page unloads\n  window.addEventListener(\"beforeunload\", () => {\n    if (audioCtx) {\n      try {\n        audioCtx.close();\n      } catch (e) {\n        // ignore\n      }\n    }\n    if (animFrame) cancelAnimationFrame(animFrame);\n  });\n\n  // Informational console help (non-essential)\n  console.info(\"Machines Math Game initialized. Click the canvas to interact. Use M to mute/unmute.\");\n\n})();\n---\n",
  "improve_response_tokens": 18913,
  "formatted_code": true,
  "formatting_response_tokens": 21068,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}