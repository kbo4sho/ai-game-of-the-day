{
  "generated_date": "2025-09-11",
  "generated_timestamp": "2025-09-11T00:27:07.466890",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8835,
  "game_filename": "2025-09-11.js",
  "game_size_bytes": 27210,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // MACHINE MATH - JavaScript Game\n  // Ages 7-9. Theme: Machines. All graphics drawn on canvas. Sounds via Web Audio API.\n  // Render inside element with ID 'game-of-the-day-stage'.\n  // Accessible: keyboard controls, screen-reader live region, visual audio indicator.\n  // Author: Expert educational game designer (assistant).\n  'use strict';\n\n  /* -------------------------\n     Basic setup and utilities\n     ------------------------- */\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Game container element with ID \"game-of-the-day-stage\" not found.');\n    return;\n  }\n\n  // Clear container and prepare DOM elements\n  container.innerHTML = '';\n  container.style.position = 'relative';\n  container.style.width = '720px';\n  container.style.height = '480px';\n  container.setAttribute('aria-label', 'Machine Math Game. A number puzzle game for children.');\n  container.setAttribute('role', 'application');\n\n  // Visually hidden live region for screen readers (kept inside container for accessibility)\n  const liveRegion = document.createElement('div');\n  liveRegion.setAttribute('aria-live', 'polite');\n  liveRegion.style.position = 'absolute';\n  liveRegion.style.left = '-9999px';\n  liveRegion.style.width = '1px';\n  liveRegion.style.height = '1px';\n  liveRegion.style.overflow = 'hidden';\n  liveRegion.style.whiteSpace = 'nowrap';\n  container.appendChild(liveRegion);\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = 720;\n  canvas.height = 480;\n  canvas.style.width = '720px';\n  canvas.style.height = '480px';\n  canvas.style.outline = 'none';\n  canvas.setAttribute('role', 'img');\n  canvas.setAttribute('aria-label', 'Machine Math game area. Use keyboard or mouse to play.');\n  canvas.tabIndex = 0; // make focusable for keyboard\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Utility helpers\n  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));\n  const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n  const copy = obj => JSON.parse(JSON.stringify(obj));\n\n  /* -------------------------\n     Audio manager using Web Audio API\n     ------------------------- */\n  class AudioManager {\n    constructor() {\n      this.enabled = false;\n      this.context = null;\n      this.bgNodes = null;\n      this.gainMaster = null;\n      this.muted = false;\n      this.initAttempted = false;\n    }\n\n    async init() {\n      // Create audio context on first user gesture ideally.\n      if (this.initAttempted) return;\n      this.initAttempted = true;\n      try {\n        // Some browsers require resume; prefer constructing only when allowed.\n        this.context = new (window.AudioContext || window.webkitAudioContext)();\n        // Master gain\n        this.gainMaster = this.context.createGain();\n        this.gainMaster.gain.value = 0.6;\n        this.gainMaster.connect(this.context.destination);\n        // Start gentle background hum\n        this.startBackground();\n        this.enabled = true;\n      } catch (e) {\n        console.warn('AudioContext could not be created:', e);\n        this.enabled = false;\n        this.context = null;\n      }\n    }\n\n    // play a short tone (frequency, duration, type)\n    _playTone(freq = 440, duration = 0.2, type = 'sine', when = 0, options = {}) {\n      if (!this.context || this.muted) return;\n      try {\n        const osc = this.context.createOscillator();\n        const gain = this.context.createGain();\n        osc.type = type;\n        osc.frequency.setValueAtTime(freq, this.context.currentTime + when);\n        gain.gain.setValueAtTime(0.0001, this.context.currentTime + when);\n        gain.gain.exponentialRampToValueAtTime(0.12, this.context.currentTime + when + 0.01);\n        gain.gain.exponentialRampToValueAtTime(0.0001, this.context.currentTime + when + duration);\n        // filter for color\n        const filter = this.context.createBiquadFilter();\n        filter.type = options.filterType || 'lowpass';\n        filter.frequency.value = options.filterFreq || 1200;\n        osc.connect(filter);\n        filter.connect(gain);\n        gain.connect(this.gainMaster);\n        osc.start(this.context.currentTime + when);\n        osc.stop(this.context.currentTime + when + duration + 0.02);\n      } catch (e) {\n        console.warn('Error playing tone:', e);\n      }\n    }\n\n    playClick() {\n      if (!this.context) return;\n      this._playTone(800, 0.06, 'square', 0, { filterFreq: 2000 });\n    }\n\n    playError() {\n      if (!this.context) return;\n      // descending minor chord-ish effect\n      this._playTone(220, 0.16, 'sawtooth', 0, { filterFreq: 800 });\n      this._playTone(180, 0.16, 'sawtooth', 0.06, { filterFreq: 800 });\n    }\n\n    playSuccess() {\n      if (!this.context) return;\n      this._playTone(880, 0.12, 'sine', 0, { filterFreq: 4000 });\n      this._playTone(1320, 0.14, 'sine', 0.08, { filterFreq: 6000 });\n    }\n\n    startBackground() {\n      if (!this.context) return;\n      try {\n        if (this.bgNodes) return;\n        const osc = this.context.createOscillator();\n        const gain = this.context.createGain();\n        const filter = this.context.createBiquadFilter();\n        osc.type = 'sine';\n        osc.frequency.value = 55 + Math.random() * 10;\n        filter.type = 'lowpass';\n        filter.frequency.value = 300;\n        gain.gain.value = 0.02;\n        osc.connect(filter);\n        filter.connect(gain);\n        gain.connect(this.gainMaster);\n        osc.start();\n        this.bgNodes = { osc, gain, filter };\n      } catch (e) {\n        console.warn('Background audio failed:', e);\n      }\n    }\n\n    stopBackground() {\n      if (!this.bgNodes) return;\n      try {\n        this.bgNodes.osc.stop();\n        this.bgNodes.osc.disconnect();\n        this.bgNodes.gain.disconnect();\n        this.bgNodes.filter.disconnect();\n      } catch (e) {\n        console.warn('Stopping bg failed:', e);\n      }\n      this.bgNodes = null;\n    }\n\n    toggleMute() {\n      this.muted = !this.muted;\n      // if muted, set master gain to near zero; else normal\n      if (this.gainMaster) {\n        this.gainMaster.gain.value = this.muted ? 0.0001 : 0.6;\n      }\n      return this.muted;\n    }\n\n    // Attempt to resume context (useful when created by gesture)\n    async resumeIfNeeded() {\n      if (!this.context) return;\n      try {\n        if (this.context.state === 'suspended' && typeof this.context.resume === 'function') {\n          await this.context.resume();\n        }\n      } catch (e) {\n        console.warn('Audio resume failed:', e);\n      }\n    }\n  }\n\n  const audio = new AudioManager();\n\n  /* -------------------------\n     Game logic and generation\n     ------------------------- */\n\n  // Available operation types for children 7-9: add, subtract, times2, times3, minus2 etc.\n  const OP_TYPES = [\n    { type: 'add', value: 1, label: '+1' },\n    { type: 'add', value: 2, label: '+2' },\n    { type: 'add', value: 3, label: '+3' },\n    { type: 'add', value: 4, label: '+4' },\n    { type: 'sub', value: 1, label: '-1' },\n    { type: 'sub', value: 2, label: '-2' },\n    { type: 'sub', value: 3, label: '-3' },\n    { type: 'mul', value: 2, label: '\u00d72' },\n    { type: 'mul', value: 3, label: '\u00d73' }\n  ];\n\n  // Apply operation to a number (returns integer).\n  function applyOp(num, op) {\n    let result = num;\n    switch (op.type) {\n      case 'add':\n        result = num + op.value;\n        break;\n      case 'sub':\n        result = num - op.value;\n        break;\n      case 'mul':\n        result = num * op.value;\n        break;\n    }\n    // Keep numbers within a friendly range for children\n    result = clamp(Math.round(result), -50, 200);\n    return result;\n  }\n\n  // Compose a random solvable puzzle: pick an input, pick a random sequence of ops, generate target.\n  // Then generate a pool of components includes the sequence (in random order) plus distractors.\n  function generatePuzzle(level) {\n    const seqLen = clamp(2 + Math.floor(level / 2), 2, 5); // easier at low levels\n    // choose start number 1..10 for younger kids\n    const start = randInt(1, 10);\n    let cur = start;\n    const seq = [];\n    // Choose operations ensuring intermediate stays reasonable\n    for (let i = 0; i < seqLen; i++) {\n      const candidate = OP_TYPES[randInt(0, OP_TYPES.length - 1)];\n      // Avoid sequences that produce too large numbers by favoring add/sub\n      let chosen = candidate;\n      // Slight bias: at higher level more multipliers allowed\n      if (Math.random() < 0.1 + level * 0.05) {\n        chosen = OP_TYPES[randInt(0, OP_TYPES.length - 1)];\n      }\n      seq.push(chosen);\n      cur = applyOp(cur, chosen);\n    }\n    const target = cur;\n    // Build pool: include the needed ops (but may include duplicates)\n    const pool = [];\n    // Add the necessary operations as distinct objects\n    seq.forEach(op => pool.push(copy(op)));\n    // Add distractors\n    while (pool.length < Math.min(6, seqLen + 3)) {\n      const p = copy(OP_TYPES[randInt(0, OP_TYPES.length - 1)]);\n      // Don't add identical amount of all required ops more than twice\n      pool.push(p);\n    }\n    // Shuffle pool\n    for (let i = pool.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [pool[i], pool[j]] = [pool[j], pool[i]];\n    }\n\n    return {\n      start,\n      target,\n      sequence: seq,\n      pool\n    };\n  }\n\n  /* -------------------------\n     Game State\n     ------------------------- */\n  const Game = {\n    level: 1,\n    maxLevel: 5,\n    puzzle: null,\n    current: 0,\n    moves: [],\n    selectedIndex: 0,\n    status: 'playing', // 'playing','won','levelComplete'\n    attempts: 0,\n    hintsUsed: 0,\n    audioEnabled: false,\n    // UI animation helpers\n    lastActionTime: 0,\n    // for gentle machine animation\n    time: 0\n  };\n\n  // Initialize a new level\n  function startLevel(level) {\n    Game.level = level;\n    Game.puzzle = generatePuzzle(level);\n    Game.current = Game.puzzle.start;\n    Game.moves = [];\n    Game.selectedIndex = 0;\n    Game.status = 'playing';\n    Game.attempts = 0;\n    Game.hintsUsed = 0;\n    updateLive(`Level ${level}. Start number ${Game.current}. Target ${Game.puzzle.target}. Use operations to reach the target.`);\n    // Ensure audio is available by prompting on first play when possible\n    // Do not auto-init audio; wait for user gesture (keypress/click)\n    requestRender();\n  }\n\n  // Apply an operation from pool (index)\n  function applyFromPool(index) {\n    if (!Game.puzzle || Game.status !== 'playing') return;\n    if (index < 0 || index >= Game.puzzle.pool.length) return;\n    const op = Game.puzzle.pool[index];\n    Game.current = applyOp(Game.current, op);\n    Game.moves.push(op);\n    Game.attempts++;\n    Game.lastActionTime = performance.now();\n    audio.playClick();\n    // Check win condition: if number equals target AND length of moves >= sequence length\n    if (Game.current === Game.puzzle.target && Game.moves.length >= Game.puzzle.sequence.length) {\n      // Level complete\n      Game.status = 'levelComplete';\n      audio.playSuccess();\n      updateLive(`Great! You made ${Game.current}. Level ${Game.level} complete.`);\n      // Proceed to next level after short delay\n      setTimeout(() => {\n        if (Game.level < Game.maxLevel) {\n          startLevel(Game.level + 1);\n        } else {\n          Game.status = 'won';\n          updateLive('You repaired the big machine! You finished all levels.');\n        }\n      }, 1200);\n    } else {\n      // If too many moves, check if player is stuck and provide gentle feedback\n      if (Game.moves.length > Game.puzzle.sequence.length + 2) {\n        audio.playError();\n        updateLive('Try a different sequence. You can undo with Backspace or U.');\n      }\n    }\n  }\n\n  // Undo last move\n  function undoMove() {\n    if (Game.moves.length === 0) return;\n    // Recompute from start by removing last move and replaying\n    Game.moves.pop();\n    let cur = Game.puzzle.start;\n    for (const m of Game.moves) cur = applyOp(cur, m);\n    Game.current = cur;\n    audio.playClick();\n    updateLive(`Undid last move. Current value ${Game.current}.`);\n  }\n\n  // Provide hint: apply the next correct operation from sequence (but limited)\n  function hint() {\n    if (!Game.puzzle || Game.status !== 'playing') return;\n    if (Game.hintsUsed >= 2) {\n      updateLive('No more hints available for this level.');\n      return;\n    }\n    // Determine next needed op from sequence at index moves.length\n    const nextIndex = Game.moves.length;\n    if (nextIndex >= Game.puzzle.sequence.length) {\n      updateLive('You are at or beyond the sequence length. Try different steps or undo.');\n      return;\n    }\n    const needed = Game.puzzle.sequence[nextIndex];\n    // Try to find a matching op in pool and apply\n    const poolIndex = Game.puzzle.pool.findIndex(p => p.type === needed.type && p.value === needed.value);\n    if (poolIndex >= 0) {\n      Game.hintsUsed++;\n      // apply\n      applyFromPool(poolIndex);\n      updateLive(`Hint used. Applied ${needed.label}.`);\n    } else {\n      // If not directly available, just reveal label\n      Game.hintsUsed++;\n      updateLive(`Hint: You need ${needed.label} next.`);\n    }\n  }\n\n  // Restart current level\n  function restartLevel() {\n    startLevel(Game.level);\n    audio.playClick();\n  }\n\n  function updateLive(msg) {\n    liveRegion.textContent = msg;\n  }\n\n  /* -------------------------\n     Drawing / Rendering\n     ------------------------- */\n\n  // Colors and theme\n  const theme = {\n    background1: '#eaf6ff',\n    background2: '#fff7ea',\n    machine: '#cfd8dc',\n    accent: '#ff7f50',\n    calm: '#6ca0dc',\n    dark: '#333',\n    panel: '#f4f7f9',\n    button: '#ffd36a',\n    selected: '#ffb86b',\n    error: '#ff6b6b',\n    success: '#7bd389'\n  };\n\n  // Draw helper functions\n  function roundedRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  // Draw gear (simple stylized)\n  function drawGear(ctx, cx, cy, radius, teeth, angle, color) {\n    ctx.save();\n    ctx.translate(cx, cy);\n    ctx.rotate(angle);\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    for (let i = 0; i < teeth; i++) {\n      const a1 = (i / teeth) * Math.PI * 2;\n      const a2 = ((i + 0.5) / teeth) * Math.PI * 2;\n      const a3 = ((i + 1) / teeth) * Math.PI * 2;\n      ctx.arc(0, 0, radius * 0.75, a1, a2);\n      ctx.lineTo(Math.cos(a2) * radius, Math.sin(a2) * radius);\n      ctx.arc(0, 0, radius, a2, a3);\n      ctx.lineTo(Math.cos(a3) * radius * 0.75, Math.sin(a3) * radius * 0.75);\n    }\n    ctx.closePath();\n    ctx.fill();\n    // center hole\n    ctx.fillStyle = '#222';\n    ctx.beginPath();\n    ctx.arc(0, 0, radius * 0.22, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  // Primary render function\n  let rafId = null;\n  function render() {\n    Game.time += 0.016;\n    // Background\n    const g = ctx.createLinearGradient(0, 0, 0, canvas.height);\n    g.addColorStop(0, theme.background1);\n    g.addColorStop(1, theme.background2);\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // Wacky clouds / circuits\n    ctx.fillStyle = 'rgba(255,255,255,0.6)';\n    for (let i = 0; i < 4; i++) {\n      const x = 80 + i * 150;\n      const y = 40 + Math.sin(Game.time + i) * 8;\n      ctx.beginPath();\n      ctx.ellipse(x, y, 60, 20, 0, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // Big machine body\n    ctx.fillStyle = theme.panel;\n    roundedRect(ctx, 60, 90, 600, 330, 18);\n    ctx.strokeStyle = '#c8d7de';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n\n    // Gears on left\n    drawGear(ctx, 140, 230, 40, 10, Game.time * 1.2, '#a7d0ff');\n    drawGear(ctx, 200, 275, 28, 8, -Game.time * 1.6, '#ffd6a5');\n    drawGear(ctx, 240, 210, 18, 6, Game.time * 2.2, '#d0f0c0');\n\n    // Pipes to display numbers\n    ctx.fillStyle = '#e6eef8';\n    roundedRect(ctx, 120, 110, 480, 60, 12);\n    ctx.fillStyle = '#fff';\n    roundedRect(ctx, 130, 120, 460, 40, 10);\n    // labels\n    ctx.fillStyle = theme.dark;\n    ctx.font = 'bold 18px Arial';\n    ctx.textAlign = 'left';\n    ctx.fillText('Machine Input \u2192 Current Value \u2192 Target', 140, 100);\n\n    // Draw input, current, target panels\n    function drawNumberBox(x, y, w, h, label, value, highlight) {\n      // box\n      ctx.fillStyle = theme.button;\n      ctx.strokeStyle = '#d2a34a';\n      roundedRect(ctx, x, y, w, h, 10);\n      ctx.lineWidth = 2;\n      ctx.stroke();\n      // label\n      ctx.fillStyle = '#2f2f2f';\n      ctx.font = '14px Arial';\n      ctx.textAlign = 'center';\n      ctx.fillText(label, x + w / 2, y + 18);\n      // value\n      ctx.fillStyle = highlight ? theme.success : '#222';\n      ctx.font = '28px Arial';\n      ctx.fillText(String(value), x + w / 2, y + 42);\n      // small wobble for highlight\n      if (highlight) {\n        ctx.strokeStyle = 'rgba(0,0,0,0.05)';\n        ctx.lineWidth = 1;\n        roundedRect(ctx, x - 2, y - 2, w + 4, h + 4, 12);\n      }\n    }\n\n    drawNumberBox(150, 130, 120, 60, 'Input', Game.puzzle ? Game.puzzle.start : '-', false);\n    drawNumberBox(300, 130, 150, 60, 'Current', Game.current, Game.current === (Game.puzzle ? Game.puzzle.target : null));\n    drawNumberBox(480, 130, 120, 60, 'Target', Game.puzzle ? Game.puzzle.target : '-', true);\n\n    // Draw operation tiles as levers/buttons on machine\n    const tileX = 130;\n    const tileY = 220;\n    const tileW = 100;\n    const tileH = 60;\n    ctx.font = '20px Arial';\n    ctx.textAlign = 'center';\n\n    if (Game.puzzle) {\n      for (let i = 0; i < Game.puzzle.pool.length; i++) {\n        const col = i % 3;\n        const row = Math.floor(i / 3);\n        const x = tileX + col * (tileW + 20);\n        const y = tileY + row * (tileH + 16);\n        const isSelected = i === Game.selectedIndex;\n        // tile shadow\n        ctx.fillStyle = 'rgba(0,0,0,0.06)';\n        roundedRect(ctx, x + 4, y + 6, tileW, tileH, 8);\n        // tile\n        ctx.fillStyle = isSelected ? theme.selected : theme.panel;\n        ctx.strokeStyle = isSelected ? theme.accent : '#cfd8dc';\n        ctx.lineWidth = 2;\n        roundedRect(ctx, x, y, tileW, tileH, 8);\n        // op label\n        ctx.fillStyle = '#222';\n        ctx.fillText(Game.puzzle.pool[i].label, x + tileW / 2, y + 38);\n        // small icon: little lever\n        ctx.fillStyle = '#9aa9b3';\n        ctx.fillRect(x + 8, y + 8, 18, 6);\n        ctx.beginPath();\n        ctx.arc(x + 17, y + 20, 8, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n\n    // Small instruction panel\n    ctx.fillStyle = 'rgba(255,255,255,0.8)';\n    roundedRect(ctx, 430, 210, 210, 120, 10);\n    ctx.fillStyle = '#333';\n    ctx.font = '14px Arial';\n    ctx.textAlign = 'left';\n    ctx.fillText('Controls:', 440, 232);\n    ctx.font = '12px Arial';\n    ctx.fillText('\u2190/\u2192 : Move selection', 440, 252);\n    ctx.fillText('Enter : Apply operation', 440, 268);\n    ctx.fillText('U / Backspace : Undo', 440, 284);\n    ctx.fillText('H : Hint (2 max)', 440, 300);\n    ctx.fillText('Space : Toggle sound', 440, 316);\n\n    // Status / feedback\n    ctx.fillStyle = '#222';\n    ctx.font = '14px Arial';\n    ctx.textAlign = 'left';\n    const statusMsg = Game.status === 'won' ? 'You finished all levels! Press R to play again.' :\n      Game.status === 'levelComplete' ? `Level ${Game.level} complete!` :\n        `Level ${Game.level}. Moves: ${Game.moves.length}. Attempts: ${Game.attempts}.`;\n    ctx.fillText(statusMsg, 70, 370);\n\n    // Draw small audio icon showing state\n    const audioOn = audio.enabled && !audio.muted;\n    ctx.save();\n    ctx.translate(660, 20);\n    ctx.fillStyle = audioOn ? theme.success : '#aaa';\n    ctx.beginPath();\n    ctx.moveTo(0, 6);\n    ctx.lineTo(6, 6);\n    ctx.lineTo(12, 0);\n    ctx.lineTo(12, 24);\n    ctx.lineTo(6, 18);\n    ctx.lineTo(0, 18);\n    ctx.closePath();\n    ctx.fill();\n    if (!audioOn) {\n      ctx.strokeStyle = '#fff';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(2, 2);\n      ctx.lineTo(20, 20);\n      ctx.stroke();\n    }\n    ctx.restore();\n\n    // If game finished\n    if (Game.status === 'won') {\n      ctx.fillStyle = 'rgba(0,0,0,0.35)';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n      ctx.fillStyle = '#fff';\n      ctx.font = 'bold 36px Arial';\n      ctx.textAlign = 'center';\n      ctx.fillText('You fixed the Mega Machine!', canvas.width / 2, canvas.height / 2 - 10);\n      ctx.font = '20px Arial';\n      ctx.fillText('Press R to play again.', canvas.width / 2, canvas.height / 2 + 30);\n    }\n\n    // tiny animation: pipes glowing when last action occurred\n    if (Game.lastActionTime && performance.now() - Game.lastActionTime < 600) {\n      const t = (performance.now() - Game.lastActionTime) / 600;\n      ctx.strokeStyle = `rgba(255,150,80,${1 - t})`;\n      ctx.lineWidth = 6 * (1 - t);\n      ctx.beginPath();\n      ctx.moveTo(260, 160);\n      ctx.lineTo(430, 160);\n      ctx.stroke();\n    }\n\n    rafId = requestAnimationFrame(render);\n  }\n\n  function requestRender() {\n    if (!rafId) rafId = requestAnimationFrame(render);\n  }\n\n  /* -------------------------\n     Input handling (keyboard & mouse)\n     ------------------------- */\n\n  // Map keyboard commands\n  function handleKey(e) {\n    // Ensure audio context created on first user gesture\n    audio.init().then(() => audio.resumeIfNeeded()).catch(() => { /* ignore */ });\n\n    // Ignore when no puzzle loaded\n    if (!Game.puzzle) return;\n    const key = e.key.toLowerCase();\n    if (key === 'arrowleft') {\n      Game.selectedIndex = (Game.selectedIndex - 1 + Game.puzzle.pool.length) % Game.puzzle.pool.length;\n      audio.playClick();\n      e.preventDefault();\n      updateLive(`Selected ${Game.puzzle.pool[Game.selectedIndex].label}.`);\n    } else if (key === 'arrowright') {\n      Game.selectedIndex = (Game.selectedIndex + 1) % Game.puzzle.pool.length;\n      audio.playClick();\n      e.preventDefault();\n      updateLive(`Selected ${Game.puzzle.pool[Game.selectedIndex].label}.`);\n    } else if (key === 'enter') {\n      applyFromPool(Game.selectedIndex);\n      e.preventDefault();\n    } else if (key === 'backspace' || key === 'u') {\n      undoMove();\n      e.preventDefault();\n    } else if (key === 'h') {\n      hint();\n      e.preventDefault();\n    } else if (key === ' ') {\n      // toggle audio\n      audio.init().then(() => {\n        const muted = audio.toggleMute();\n        updateLive(muted ? 'Audio muted.' : 'Audio unmuted.');\n      }).catch(() => {\n        // If audio init failed, provide message\n        updateLive('Audio not available on this device.');\n      });\n      e.preventDefault();\n    } else if (key === 'r') {\n      // restart or replay from win\n      if (Game.status === 'won') {\n        startLevel(1);\n      } else {\n        restartLevel();\n      }\n      e.preventDefault();\n    }\n  }\n\n  // Mouse/touch interactions\n  function handleClick(e) {\n    audio.init().then(() => audio.resumeIfNeeded()).catch(() => { /* ignore */ });\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    // If clicked inside any tile\n    if (Game.puzzle) {\n      const tileX = 130;\n      const tileY = 220;\n      const tileW = 100;\n      const tileH = 60;\n      for (let i = 0; i < Game.puzzle.pool.length; i++) {\n        const col = i % 3;\n        const row = Math.floor(i / 3);\n        const x = tileX + col * (tileW + 20);\n        const y = tileY + row * (tileH + 16);\n        if (mx >= x && mx <= x + tileW && my >= y && my <= y + tileH) {\n          Game.selectedIndex = i;\n          applyFromPool(i);\n          return;\n        }\n      }\n      // audio toggle area\n      if (mx >= 660 && mx <= 700 && my >= 2 && my <= 38) {\n        audio.init().then(() => {\n          const muted = audio.toggleMute();\n          updateLive(muted ? 'Audio muted.' : 'Audio unmuted.');\n        }).catch(() => updateLive('Audio not available.'));\n      }\n    }\n  }\n\n  canvas.addEventListener('keydown', handleKey);\n  canvas.addEventListener('click', handleClick);\n  // also allow container click to focus canvas for keyboard\n  container.addEventListener('click', () => {\n    canvas.focus();\n  });\n\n  // Provide on-screen buttons accessibility via keyboard focusable hints\n  canvas.addEventListener('focus', () => {\n    updateLive('Canvas focused. Use arrow keys to select an operation, Enter to apply.');\n  });\n\n  // Touch events map to click\n  canvas.addEventListener('touchstart', function (e) {\n    if (e.touches && e.touches.length > 0) {\n      const t = e.touches[0];\n      handleClick({ clientX: t.clientX, clientY: t.clientY, preventDefault: () => { } });\n      e.preventDefault();\n    }\n  }, { passive: false });\n\n  /* -------------------------\n     Initialization and error handling\n     ------------------------- */\n\n  // Ensure Web Audio context created only after gesture; provide a big friendly start button overlay prompting\n  function showStartOverlay() {\n    // Draw an overlay on canvas instructing to press any key or click to start\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = theme.background1;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = '#222';\n    ctx.font = 'bold 28px Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText('Machine Math!', canvas.width / 2, 140);\n    ctx.font = '18px Arial';\n    ctx.fillText('Help the wacky machine reach a target number by choosing operations.', canvas.width / 2, 180);\n    ctx.font = '16px Arial';\n    ctx.fillText('Click or press any key to begin. Use the keyboard or tap the tiles.', canvas.width / 2, 220);\n\n    ctx.fillStyle = theme.calm;\n    roundedRect(ctx, canvas.width / 2 - 80, 260, 160, 50, 10);\n    ctx.fillStyle = '#fff';\n    ctx.fillText('Start Game', canvas.width / 2, 293);\n\n    // Listener to initialize on first user gesture\n    function beginOnce(e) {\n      // initialize audio now\n      audio.init().then(() => audio.resumeIfNeeded()).catch(() => {\n        updateLive('Audio could not start. The game will still work without sound.');\n      });\n      // start first level\n      startLevel(1);\n      // remove this listener\n      window.removeEventListener('keydown', beginOnce);\n      canvas.removeEventListener('click', beginOnce);\n    }\n    window.addEventListener('keydown', beginOnce);\n    canvas.addEventListener('click', beginOnce);\n  }\n\n  // Kick off\n  showStartOverlay();\n\n  // Ensure clean up on unload\n  window.addEventListener('unload', () => {\n    if (rafId) cancelAnimationFrame(rafId);\n    if (audio && audio.context) {\n      try {\n        audio.stopBackground();\n        if (audio.context.close) audio.context.close();\n      } catch (e) { /* ignore */ }\n    }\n  });\n\n  // Expose some helpful instructions for screen reader users via live region\n  updateLive('Welcome to Machine Math. Press any key or click to start. After starting, use arrow keys and Enter or tap tiles to play. Press Space to toggle sound.');\n\n  // Ensure initial render so canvas is not blank\n  requestRender();\n\n  // Safety: set a periodic animation if render loop didn't start\n  setTimeout(() => { if (!rafId) requestRender(); }, 500);\n\n})();\n---\n",
  "improve_response_tokens": 17858,
  "formatted_code": true,
  "formatting_response_tokens": 19387,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}