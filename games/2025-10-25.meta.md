# Game of the Day - 2025-10-25

## Metadata
- **Generated Date:** 2025-10-25
- **Generated Time:** 2025-10-25T00:27:48.434161
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-10-25.js
- **File Size:** 27311 bytes
- **Tokens Used:** 9864

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-10-25.js` - The playable game
- `2025-10-25.meta.json` - Machine-readable metadata
- `2025-10-25.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 18366

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 19227

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function() {
  // Drone Math Collector
  // Renders into element with id "game-of-the-day-stage"
  // Strictly uses canvas drawing and Web Audio API (no external resources).
  // Accessible via keyboard: Arrow keys / WASD to move, 1-4 to pick answers, R to restart, Space to toggle audio.
  'use strict';

  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const GOAL_CORRECT = 10;
  const MAX_WRONG = 3;
  const PACKAGE_COUNT = 4;
  const HEADER_HEIGHT = 64; // reserved top area for non-overlap
  const FOOTER_HEIGHT = 100; // reserved bottom area for question/instructions
  const UI_PADDING = 12; // min 10px required; use 12
  const DRONE_RADIUS = 20;
  const PACKAGE_RADIUS = 28;
  const BG_COLOR = '#E8F6FF';
  const FONT_BASE = '16px "Segoe UI", Roboto, Arial, sans-serif';
  const FONT_LARGE = '22px "Segoe UI", Roboto, Arial, sans-serif';
  const FONT_BIGGER = '28px "Segoe UI", Roboto, Arial, sans-serif';

  // Find container
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Container with ID "game-of-the-day-stage" not found.');
    return;
  }

  // Make container accessible for screen readers with a short description
  container.setAttribute('role', 'application');
  container.setAttribute('aria-label', 'Drone Math Collector. Move the drone to collect packages with correct answers. Use arrow keys or number keys 1 to 4. Press R to restart.');

  // Clear any existing content, create canvas
  container.innerHTML = '';
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute('width', WIDTH);
  canvas.setAttribute('height', HEIGHT);
  canvas.style.width = WIDTH + 'px';
  canvas.style.height = HEIGHT + 'px';
  canvas.style.display = 'block';
  canvas.style.touchAction = 'none'; // avoid touch scrolling issues
  container.appendChild(canvas);

  const ctx = canvas.getContext('2d');
  if (!ctx) {
    console.error('2D canvas context not available.');
    return;
  }

  // Audio setup with error handling
  let AudioContextCtor = window.AudioContext || window.webkitAudioContext || null;
  let audioCtx = null;
  let audioAvailable = false;
  let audioStateText = 'Audio: OFF (press Space to enable)';
  let bgGain = null;
  let bgOsc = null;

  function initAudio() {
    if (!AudioContextCtor) {
      audioAvailable = false;
      audioStateText = 'Audio not supported by browser.';
      return;
    }
    try {
      if (!audioCtx) {
        audioCtx = new AudioContextCtor();
      }
      // Create gentle background hum with low volume
      bgGain = audioCtx.createGain();
      bgGain.gain.value = 0.02;
      bgGain.connect(audioCtx.destination);

      bgOsc = audioCtx.createOscillator();
      bgOsc.type = 'sine';
      bgOsc.frequency.value = 110; // low hum
      const bgFilter = audioCtx.createBiquadFilter();
      bgFilter.type = 'lowpass';
      bgFilter.frequency.value = 600;
      bgOsc.connect(bgFilter);
      bgFilter.connect(bgGain);
      bgOsc.start();

      audioAvailable = true;
      audioStateText = 'Audio: ON (press Space to mute)';
    } catch (e) {
      console.error('AudioContext creation failed:', e);
      audioAvailable = false;
      audioStateText = 'Audio unavailable.';
    }
  }

  // Toggle audio on user gesture - required by some browsers
  function toggleAudio() {
    if (!AudioContextCtor) {
      audioAvailable = false;
      audioStateText = 'Audio not supported.';
      return;
    }
    if (!audioCtx) {
      try {
        initAudio();
      } catch (e) {
        audioAvailable = false;
        audioStateText = 'Audio unavailable.';
      }
    } else {
      if (audioCtx.state === 'suspended') {
        audioCtx.resume().then(() => {
          audioAvailable = true;
          audioStateText = 'Audio: ON (press Space to mute)';
          startBackgroundIfNeeded();
        }).catch((err) => {
          console.warn('Audio resume failed:', err);
          audioAvailable = false;
          audioStateText = 'Audio unavailable.';
        });
      } else if (audioCtx.state === 'running' && bgGain) {
        // Mute / unmute by toggling gain
        if (bgGain.gain.value > 0.001) {
          bgGain.gain.value = 0;
          audioStateText = 'Audio: OFF (press Space to enable)';
        } else {
          bgGain.gain.value = 0.02;
          audioStateText = 'Audio: ON (press Space to mute)';
        }
      }
    }
  }

  function startBackgroundIfNeeded() {
    if (!audioAvailable || !audioCtx) return;
    if (!bgOsc) {
      initAudio();
    }
  }

  // Create short sound effects using Web Audio API
  function playBeep(type = 'correct') {
    if (!audioAvailable || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type === 'correct' ? 'triangle' : 'square';
      o.frequency.value = type === 'correct' ? 880 : 300;
      g.gain.value = 0;
      o.connect(g);
      g.connect(audioCtx.destination);
      // envelope
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(type === 'correct' ? 0.18 : 0.14, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
      o.start(now);
      o.stop(now + 0.4);
    } catch (e) {
      console.warn('playBeep failed', e);
      audioAvailable = false;
      audioStateText = 'Audio error.';
    }
  }

  function playClick() {
    if (!audioAvailable || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'sawtooth';
      o.frequency.value = 1200;
      g.gain.value = 0;
      o.connect(g);
      g.connect(audioCtx.destination);
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(0.1, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
      o.start(now);
      o.stop(now + 0.13);
    } catch (e) {
      console.warn('playClick failed', e);
    }
  }

  // Utility functions
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function rand(min, max) { return Math.random() * (max - min) + min; }
  function randInt(min, max) { return Math.floor(rand(min, max + 1)); }
  function distance(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }

  // Game state
  let running = true;
  let correctCount = 0;
  let wrongCount = 0;
  let question = null; // {text, answer}
  let packages = []; // array of {x,y,value,isCorrect,angle,ox,oy}
  let drone = {
    x: WIDTH / 2,
    y: HEADER_HEIGHT + (HEIGHT - HEADER_HEIGHT - FOOTER_HEIGHT) / 2,
    vx: 0, vy: 0,
    speed: 180 // pixels/sec
  };
  let lastTime = performance.now();

  let keys = {};
  // For touch/mouse selection highlight
  let hoverIndex = -1;
  let showEndScreen = false;
  let endState = null; // 'win' or 'lose'

  // Generate a math problem appropriate for ages 7-9 (simple arithmetic)
  function generateProblem() {
    const types = ['add', 'sub', 'mixed'];
    const t = types[randInt(0, types.length - 1)];
    let a, b, text, ans;
    if (t === 'add') {
      a = randInt(1, 15);
      b = randInt(1, Math.max(3, 16 - a));
      ans = a + b;
      text = `${a} + ${b} = ?`;
    } else if (t === 'sub') {
      a = randInt(2, 20);
      b = randInt(1, a - 1);
      ans = a - b;
      text = `${a} - ${b} = ?`;
    } else {
      // mixed: one add or sub but include small multiplication like *2, *3 to diversify
      if (Math.random() < 0.6) {
        a = randInt(2, 9);
        b = randInt(2, 4);
        ans = a * b;
        text = `${a} × ${b} = ?`;
      } else {
        a = randInt(1, 12);
        b = randInt(1, 12);
        ans = a + b;
        text = `${a} + ${b} = ?`;
      }
    }
    return { text, answer: ans };
  }

  // Create package positions ensuring they are in the play area and non-overlapping
  function spawnPackages(correctAnswer) {
    packages = [];
    const attemptsMax = 1000;
    let attempts = 0;
    while (packages.length < PACKAGE_COUNT && attempts < attemptsMax) {
      attempts++;
      // spawn inside play area (below header, above footer)
      const x = randInt(PACKAGE_RADIUS + UI_PADDING, WIDTH - PACKAGE_RADIUS - UI_PADDING);
      const y = randInt(HEADER_HEIGHT + PACKAGE_RADIUS + UI_PADDING, HEIGHT - FOOTER_HEIGHT - PACKAGE_RADIUS - UI_PADDING);
      // ensure not too close to drone start area
      const pos = { x, y };
      let ok = true;
      if (distance(pos, drone) < DRONE_RADIUS + PACKAGE_RADIUS + 30) ok = false;
      for (const p of packages) {
        if (distance(pos, p) < PACKAGE_RADIUS * 2 + 12) { ok = false; break; }
      }
      if (!ok) continue;
      // create tentative value: for first package we will later assign correct answer to one random slot
      packages.push({ x, y, value: null, isCorrect: false, angle: rand(0, Math.PI * 2), ox: x, oy: y });
    }
    // Assign values: one correct, others distractors
    const correctIndex = randInt(0, packages.length - 1);
    for (let i = 0; i < packages.length; i++) {
      if (i === correctIndex) {
        packages[i].value = correctAnswer;
        packages[i].isCorrect = true;
      } else {
        // distractor: generate a value reasonably close but not equal
        let val = correctAnswer;
        let tries = 0;
        while ((val === correctAnswer || val < 0) && tries < 50) {
          tries++;
          const delta = randInt(-6, 6);
          // bias to avoid too large values
          val = correctAnswer + delta;
          if (Math.random() < 0.2) {
            // sometimes choose different operation result
            val = correctAnswer + randInt(2, 7) * (Math.random() < 0.5 ? 1 : -1);
          }
        }
        if (val === correctAnswer) val = correctAnswer + 5;
        packages[i].value = val;
        packages[i].isCorrect = false;
      }
    }
  }

  function startNewQuestion() {
    question = generateProblem();
    spawnPackages(question.answer);
  }

  // Initialize game
  function resetGame() {
    correctCount = 0;
    wrongCount = 0;
    drone.x = WIDTH / 2;
    drone.y = HEADER_HEIGHT + (HEIGHT - HEADER_HEIGHT - FOOTER_HEIGHT) / 2;
    drone.vx = 0;
    drone.vy = 0;
    keys = {};
    showEndScreen = false;
    endState = null;
    startNewQuestion();
    lastTime = performance.now();
    startBackgroundIfNeeded();
  }

  // Collision detection: circle overlap
  function collides(aX, aY, aR, bX, bY, bR) {
    return (aX - bX) * (aX - bX) + (aY - bY) * (aY - bY) <= (aR + bR) * (aR + bR);
  }

  // Handling collection
  function collectPackage(index) {
    if (showEndScreen || !packages[index]) return;
    const pkg = packages[index];
    if (!pkg) return;
    if (pkg.isCorrect) {
      correctCount++;
      playBeep('correct');
      // gentle bounce visual: move drone slightly
      drone.x = clamp(drone.x - 6, DRONE_RADIUS + UI_PADDING, WIDTH - DRONE_RADIUS - UI_PADDING);
      // Victory check
      if (correctCount >= GOAL_CORRECT) {
        showEnd('win');
        return;
      }
    } else {
      wrongCount++;
      playBeep('incorrect');
      // small penalty push
      drone.y = clamp(drone.y + 18, HEADER_HEIGHT + DRONE_RADIUS, HEIGHT - FOOTER_HEIGHT - DRONE_RADIUS);
      if (wrongCount >= MAX_WRONG) {
        showEnd('lose');
        return;
      }
    }
    // Spawn next question (reset packages after a small delay to allow sound)
    startNewQuestion();
  }

  function showEnd(state) {
    showEndScreen = true;
    endState = state;
    // Pause background audio slightly
    if (bgGain) {
      bgGain.gain.value = 0.005;
    }
    if (state === 'win') {
      // celebratory tones
      playBeep('correct');
      setTimeout(() => playBeep('correct'), 120);
    } else {
      // consoling tone
      playBeep('incorrect');
    }
  }

  // Event listeners
  window.addEventListener('keydown', (e) => {
    if (e.key === 'r' || e.key === 'R') {
      resetGame();
      e.preventDefault();
      return;
    }
    if (e.key === ' ' || e.code === 'Space') {
      // Toggle audio (user gesture)
      toggleAudio();
      e.preventDefault();
      return;
    }
    // Number keys 1-4 for quick pickup
    if (!showEndScreen) {
      if (['1','2','3','4'].includes(e.key)) {
        const idx = parseInt(e.key, 10) - 1;
        if (idx >= 0 && idx < packages.length) {
          collectPackage(idx);
        }
      }
    } else {
      // If end screen, allow Enter to restart
      if (e.key === 'Enter') {
        resetGame();
      }
    }
    // Movement keys
    const movement = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D'];
    if (movement.includes(e.key)) {
      keys[e.key] = true;
      e.preventDefault();
    }
  });

  window.addEventListener('keyup', (e) => {
    const movement = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D'];
    if (movement.includes(e.key)) {
      keys[e.key] = false;
      e.preventDefault();
    }
  });

  // Mouse interactions: clicking on a package collects it; clicking on bg toggles audio if click on audio area
  canvas.addEventListener('pointermove', (ev) => {
    const rect = canvas.getBoundingClientRect();
    const mx = ev.clientX - rect.left;
    const my = ev.clientY - rect.top;
    hoverIndex = -1;
    for (let i = 0; i < packages.length; i++) {
      const p = packages[i];
      if (collides(mx, my, 0, p.x, p.y, PACKAGE_RADIUS)) {
        hoverIndex = i;
        break;
      }
    }
  });
  canvas.addEventListener('pointerdown', (ev) => {
    const rect = canvas.getBoundingClientRect();
    const mx = ev.clientX - rect.left;
    const my = ev.clientY - rect.top;

    // Check if clicked on restart button when end screen
    if (showEndScreen) {
      const btn = getRestartButtonRect();
      if (mx >= btn.x && mx <= btn.x + btn.w && my >= btn.y && my <= btn.y + btn.h) {
        resetGame();
        playClick();
        return;
      }
    }

    // Check audio toggle small icon at top-left area (we'll reserve a small square)
    const audioBox = { x: UI_PADDING, y: HEIGHT - FOOTER_HEIGHT + 10, w: 170, h: 28 };
    if (mx >= audioBox.x && mx <= audioBox.x + audioBox.w && my >= audioBox.y && my <= audioBox.y + audioBox.h) {
      toggleAudio();
      playClick();
      return;
    }

    // Otherwise, check packages
    for (let i = 0; i < packages.length; i++) {
      const p = packages[i];
      if (collides(mx, my, 0, p.x, p.y, PACKAGE_RADIUS)) {
        collectPackage(i);
        playClick();
        return;
      }
    }
  });

  // Ensure packages don't overlap header/footer text by defining spawn area earlier.

  // Drawing functions
  function drawBackground(dt) {
    // Calming pastel sky
    ctx.fillStyle = BG_COLOR;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Gentle wavy layers with moving offset for calm motion
    const t = performance.now() * 0.0002;
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      const baseY = HEADER_HEIGHT + 24 + i * 38;
      ctx.fillStyle = i === 0 ? 'rgba(180,220,255,0.35)' : (i === 1 ? 'rgba(200,240,240,0.20)' : 'rgba(230,245,255,0.12)');
      ctx.moveTo(0, HEIGHT);
      for (let x = 0; x <= WIDTH; x += 20) {
        const y = baseY + Math.sin((x * 0.02) + t * (1 + i)) * (12 + i * 6);
        ctx.lineTo(x, y);
      }
      ctx.lineTo(WIDTH, HEIGHT);
      ctx.closePath();
      ctx.fill();
    }

    // Draw clouds (simple arcs) in top area, slightly animated
    for (let i = 0; i < 5; i++) {
      const cx = (i * 180 + t * 90) % (WIDTH + 120) - 60;
      const cy = 24 + (i % 2) * 12 + Math.sin(t * 1.2 + i) * 6;
      drawCloud(cx, cy, 34, `rgba(255,255,255,0.85)`);
    }
  }

  function drawCloud(cx, cy, size, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(cx - size * 0.6, cy, size * 0.6, 0, Math.PI * 2);
    ctx.arc(cx, cy - size * 0.3, size * 0.8, 0, Math.PI * 2);
    ctx.arc(cx + size * 0.6, cy, size * 0.6, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawHeader() {
    // Score top-left background
    ctx.font = FONT_BASE;
    const scoreText = `Correct: ${correctCount}/${GOAL_CORRECT}`;
    const scoreMetrics = ctx.measureText(scoreText);
    const scoreW = scoreMetrics.width + UI_PADDING * 2;
    const scoreH = 36;
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    roundRect(ctx, UI_PADDING, UI_PADDING, scoreW, scoreH, 8, true, false);
    ctx.fillStyle = '#004466';
    ctx.font = FONT_LARGE;
    ctx.fillText(scoreText, UI_PADDING + UI_PADDING / 2, UI_PADDING + scoreH / 2 + 7);

    // Lives top-right
    const lives = MAX_WRONG - wrongCount;
    const livesText = `Lives: ${lives}`;
    ctx.font = FONT_LARGE;
    const livesW = ctx.measureText(livesText).width + UI_PADDING * 2;
    const lx = WIDTH - livesW - UI_PADDING;
    const ly = UI_PADDING;
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    roundRect(ctx, lx, ly, livesW, scoreH, 8, true, false);
    ctx.fillStyle = '#882222';
    ctx.fillText(livesText, lx + UI_PADDING / 2, ly + scoreH / 2 + 7);

    // Audio status bottom-left in footer area (visual cue for audio)
    ctx.font = FONT_BASE;
    let audioText = audioStateText;
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    const abx = UI_PADDING;
    const aby = HEIGHT - FOOTER_HEIGHT + 10;
    const abW = 360;
    const abH = 28;
    roundRect(ctx, abx, aby, abW, abH, 6, true, false);
    ctx.fillStyle = '#224455';
    ctx.font = '14px "Segoe UI", Roboto, Arial, sans-serif';
    ctx.fillText(audioText, abx + 8, aby + abH / 2 + 5);
  }

  function drawDrone(dt) {
    // Simple wacky drone: circular body, two propellers with rotation based on time
    const now = performance.now() * 0.002;
    // shadow
    ctx.beginPath();
    ctx.fillStyle = 'rgba(0,0,0,0.08)';
    ctx.ellipse(drone.x, drone.y + DRONE_RADIUS + 8, DRONE_RADIUS * 1.2, DRONE_RADIUS * 0.45, 0, 0, Math.PI * 2);
    ctx.fill();

    // body
    ctx.beginPath();
    ctx.fillStyle = '#fffef2';
    ctx.strokeStyle = '#006699';
    ctx.lineWidth = 3;
    ctx.arc(drone.x, drone.y, DRONE_RADIUS, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // face (wacky)
    ctx.beginPath();
    ctx.fillStyle = '#006699';
    ctx.arc(drone.x - 6, drone.y - 2, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ffaa00';
    ctx.fillRect(drone.x + 2, drone.y + 2, 8, 6);

    // props
    for (let i = -1; i <= 1; i += 2) {
      const px = drone.x + i * (DRONE_RADIUS + 12);
      const py = drone.y - DRONE_RADIUS + 2;
      const r = 14;
      ctx.save();
      ctx.translate(px, py);
      ctx.rotate(now * (i * -2));
      ctx.fillStyle = 'rgba(0,0,0,0.18)';
      roundRect(ctx, -r, -6, r * 2, 12, 6, true, false);
      ctx.restore();
    }
  }

  function drawPackages(dt) {
    // gentle bobbing animation
    const t = performance.now() * 0.0012;
    for (let i = 0; i < packages.length; i++) {
      const p = packages[i];
      p.angle += (i + 1) * 0.001 * dt; // slow rotation
      const bob = Math.sin(t * (1 + i * 0.2) + i) * 6;
      const px = p.ox + Math.cos(p.angle * 0.7) * 6;
      const py = p.oy + bob;
      p.x = px;
      p.y = py;

      // draw crate: box with number and quirky stickers
      // crate shadow
      ctx.beginPath();
      ctx.fillStyle = 'rgba(0,0,0,0.06)';
      ctx.ellipse(px, py + PACKAGE_RADIUS + 6, PACKAGE_RADIUS * 1.0, PACKAGE_RADIUS * 0.4, 0, 0, Math.PI * 2);
      ctx.fill();

      // crate body
      ctx.save();
      ctx.translate(px, py);
      ctx.rotate(Math.sin(p.angle) * 0.04);
      ctx.fillStyle = p.isCorrect ? '#fff9e6' : '#fff';
      ctx.strokeStyle = '#884422';
      ctx.lineWidth = 3;
      roundRect(ctx, -PACKAGE_RADIUS, -PACKAGE_RADIUS, PACKAGE_RADIUS * 2, PACKAGE_RADIUS * 2, 8, true, true);

      // sticker circle
      ctx.beginPath();
      ctx.fillStyle = p.isCorrect ? '#a3e635' : '#ffd166';
      ctx.arc(0, -10, 12, 0, Math.PI * 2);
      ctx.fill();

      // number text
      ctx.fillStyle = '#002233';
      ctx.font = '20px "Segoe UI", Roboto, Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(p.value), 0, 6);
      ctx.restore();

      // highlight when hovered
      if (hoverIndex === i) {
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(20,100,150,0.6)';
        ctx.lineWidth = 3;
        ctx.arc(p.x, p.y, PACKAGE_RADIUS + 6, 0, Math.PI * 2);
        ctx.stroke();
      }

      // label index for keyboard access (1..4)
      ctx.font = '14px "Segoe UI", Roboto, Arial, sans-serif';
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillText(String(i + 1), p.x + PACKAGE_RADIUS - 10, p.y - PACKAGE_RADIUS + 14);
    }
  }

  function drawQuestionAndInstructions() {
    // Draw a footer box centered with question and instructions
    ctx.font = FONT_BIGGER;
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    const qText = question ? question.text : '';
    const metrics = ctx.measureText(qText);
    const boxW = Math.max(metrics.width + UI_PADDING * 4, 360);
    const bx = (WIDTH - boxW) / 2;
    const by = HEIGHT - FOOTER_HEIGHT + 10;
    const bh = 64;
    roundRect(ctx, bx, by, boxW, bh, 10, true, false);

    // Question text
    ctx.fillStyle = '#003344';
    ctx.font = FONT_BIGGER;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(qText, WIDTH / 2, by + bh / 2 - 6);

    // Below: instructions text (keyboard controls)
    ctx.font = FONT_BASE;
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    const instr = 'Move: Arrow Keys or WASD • Collect correct package • Quick keys: 1-4 • R to restart';
    const instrY = by + bh + 22;
    ctx.fillText(instr, WIDTH / 2, instrY);

    // Additional accessibility hint
    ctx.font = '14px "Segoe UI", Roboto, Arial, sans-serif';
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillText('Touch or click a package to collect it. Press Space to toggle audio.', WIDTH / 2, instrY + 18);
  }

  function drawEndScreen() {
    if (!showEndScreen) return;
    // translucent overlay
    ctx.fillStyle = 'rgba(6,18,28,0.65)';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // central panel
    const panelW = 520;
    const panelH = 260;
    const px = (WIDTH - panelW) / 2;
    const py = (HEIGHT - panelH) / 2;
    ctx.fillStyle = '#fff';
    roundRect(ctx, px, py, panelW, panelH, 12, true, false);

    // Title
    ctx.font = FONT_BIGGER;
    ctx.fillStyle = '#002233';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    const title = endState === 'win' ? 'Victory! Drone Delivered!' : 'Game Over — Try Again';
    ctx.fillText(title, WIDTH / 2, py + 22);

    // Message
    ctx.font = FONT_BASE;
    ctx.fillStyle = '#004466';
    const sub = endState === 'win' ? `You collected ${correctCount} correct packages!` : `You made ${wrongCount} mistakes. You collected ${correctCount} correct packages.`;
    wrapText(ctx, sub, WIDTH / 2, py + 72, panelW - 60, 20);

    // Restart button
    const btn = getRestartButtonRect();
    ctx.fillStyle = '#e6f7ff';
    roundRect(ctx, btn.x, btn.y, btn.w, btn.h, 8, true, false);
    ctx.fillStyle = '#004466';
    ctx.font = FONT_LARGE;
    ctx.fillText('Restart (R)', btn.x + btn.w / 2, btn.y + 10);

    // Friendly tip
    ctx.font = '14px "Segoe UI", Roboto, Arial, sans-serif';
    ctx.fillStyle = '#333';
    ctx.fillText('Tip: use 1-4 keys to quickly collect matching packages.', WIDTH / 2, btn.y + btn.h + 12);
  }

  function getRestartButtonRect() {
    const btnW = 180;
    const btnH = 48;
    const bx = (WIDTH - btnW) / 2;
    const by = (HEIGHT / 2) + 30;
    return { x: bx, y: by, w: btnW, h: btnH };
  }

  // Helpers: rounded rectangle and text wrap
  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    if (typeof stroke === 'undefined') stroke = true;
    if (typeof r === 'undefined') r = 6;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = text.split(' ');
    let line = '';
    let offsetY = 0;
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + ' ';
      const metrics = ctx.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        ctx.fillText(line, x, y + offsetY);
        line = words[n] + ' ';
        offsetY += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line, x, y + offsetY);
  }

  // Update loop
  function update(dt) {
    if (showEndScreen) {
      // slight floating drone while paused
      drone.x = drone.x + Math.sin(performance.now() * 0.001) * 0.02;
      return;
    }
    // Movement processing
    let moveX = 0, moveY = 0;
    if (keys['ArrowLeft'] || keys['a'] || keys['A']) moveX -= 1;
    if (keys['ArrowRight'] || keys['d'] || keys['D']) moveX += 1;
    if (keys['ArrowUp'] || keys['w'] || keys['W']) moveY -= 1;
    if (keys['ArrowDown'] || keys['s'] || keys['S']) moveY += 1;

    const len = Math.hypot(moveX, moveY) || 1;
    drone.vx = (moveX / len) * drone.speed;
    drone.vy = (moveY / len) * drone.speed;

    drone.x += drone.vx * dt;
    drone.y += drone.vy * dt;

    // Keep drone within play area boundaries (respect header/footer)
    drone.x = clamp(drone.x, DRONE_RADIUS + UI_PADDING, WIDTH - DRONE_RADIUS - UI_PADDING);
    drone.y = clamp(drone.y, HEADER_HEIGHT + DRONE_RADIUS, HEIGHT - FOOTER_HEIGHT - DRONE_RADIUS);

    // Check collision with any package
    for (let i = 0; i < packages.length; i++) {
      const p = packages[i];
      if (collides(drone.x, drone.y, DRONE_RADIUS - 6, p.x, p.y, PACKAGE_RADIUS - 6)) {
        collectPackage(i);
        break;
      }
    }
  }

  function render(now) {
    const tNow = performance.now();
    const dtMs = tNow - lastTime;
    const dt = Math.min(dtMs / 1000, 0.05);
    lastTime = tNow;

    update(dtMs);

    // Draw everything
    drawBackground(dtMs);
    drawHeader();
    drawPackages(dtMs);
    drawDrone(dtMs);
    drawQuestionAndInstructions();

    if (showEndScreen) {
      drawEndScreen();
    }

    // Next frame
    if (running) {
      requestAnimationFrame(render);
    }
  }

  // Start things
  try {
    initAudio();
  } catch (e) {
    console.warn('Audio initialization failed:', e);
  }
  resetGame();
  requestAnimationFrame(render);

  // Provide a safe stop function bound to container for debugging if needed
  container.stopGame = function() { running = false; };

  // Small final accessibility / safety: keyboard focus instructions
  canvas.setAttribute('tabindex', '0');
  canvas.addEventListener('focus', () => {
    // ensure audio context resumes on focus for some platforms if user toggled earlier
    if (audioCtx && audioCtx.state === 'suspended') {
      audioCtx.resume().catch(() => {});
    }
  });

  // Error handling for resource loading: we have no external resources; but guard against exceptions
  window.addEventListener('error', (e) => {
    console.error('Runtime error in Drone Math Collector:', e.error || e.message);
  });
})();
---

