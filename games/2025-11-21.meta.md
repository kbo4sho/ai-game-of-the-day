# Game of the Day - 2025-11-21

## Metadata
- **Generated Date:** 2025-11-21
- **Generated Time:** 2025-11-21T00:27:58.607656
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-11-21.js
- **File Size:** 26338 bytes
- **Tokens Used:** 8995

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-11-21.js` - The playable game
- `2025-11-21.meta.json` - Machine-readable metadata
- `2025-11-21.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 18725

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 20811

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Drone Math Game for ages 7-9
  // Renders into element with id 'game-of-the-day-stage'.
  // All graphics via canvas. Sounds via Web Audio API oscillators.
  // Clear win: score >= TARGET_SCORE. Loss: wrong >= MAX_WRONG.
  // Accessible via keyboard and mouse. Includes instructions and restart.

  // Config
  const WIDTH = 720;
  const HEIGHT = 480;
  const PADDING = 12; // >=10 px padding
  const TARGET_SCORE = 10; // goal to win
  const MAX_WRONG = 3; // lives before game over
  const FONT_BODY = "16px sans-serif"; // >=14px
  const FONT_IMPORTANT = "22px bold sans-serif"; // >=18px
  const CHOICE_FONT = "18px sans-serif";
  const FRAME_RATE_MS = 1000 / 60;

  // Find container
  const container = document.getElementById("game-of-the-day-stage");
  if (!container) {
    throw new Error("Container element with id 'game-of-the-day-stage' not found.");
  }
  container.innerHTML = ""; // clear
  container.style.position = "relative";
  container.setAttribute("role", "application");
  container.setAttribute("aria-label", "Drone math game. Answer simple math questions to collect stars. Use number keys 1-4 to choose answers.");
  container.tabIndex = 0;

  // Create live region for screen readers
  const liveRegion = document.createElement("div");
  liveRegion.setAttribute("aria-live", "polite");
  liveRegion.style.position = "absolute";
  liveRegion.style.left = "-9999px";
  liveRegion.style.top = "auto";
  liveRegion.style.width = "1px";
  liveRegion.style.height = "1px";
  liveRegion.style.overflow = "hidden";
  container.appendChild(liveRegion);

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.display = "block";
  canvas.style.background = "#e6f2ff"; // calming sky-blue
  canvas.style.border = "1px solid #333";
  container.appendChild(canvas);
  const ctx = canvas.getContext("2d");
  if (!ctx) {
    throw new Error("2D context not available.");
  }

  // Audio setup with error handling
  let audioCtx = null;
  let bgGain = null;
  let bgOsc = null;
  let audioEnabled = false;

  function tryCreateAudioContext() {
    if (audioCtx) return;
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) {
        console.warn("Web Audio API not supported in this browser.");
        return;
      }
      audioCtx = new AC();
      // create gentle background hum
      bgGain = audioCtx.createGain();
      bgGain.gain.value = 0.02; // very gentle
      bgGain.connect(audioCtx.destination);
      bgOsc = audioCtx.createOscillator();
      bgOsc.type = "sine";
      bgOsc.frequency.value = 110; // low hum
      const bgFilter = audioCtx.createBiquadFilter();
      bgFilter.type = "lowpass";
      bgFilter.frequency.value = 600;
      bgOsc.connect(bgFilter);
      bgFilter.connect(bgGain);
      bgOsc.start();
      // start muted until audioEnabled true
      bgGain.gain.value = 0;
    } catch (e) {
      console.warn("Audio context failed to initialize:", e);
      audioCtx = null;
    }
  }

  // Call on user gesture
  function resumeAudioIfNeeded() {
    tryCreateAudioContext();
    if (audioCtx && audioCtx.state === "suspended") {
      audioCtx.resume().catch((e) => console.warn("Audio resume failed:", e));
    }
  }

  // Play short sound effect (correct/wrong)
  function playBeep({ type = "correct" } = {}) {
    if (!audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      filter.type = "highpass";
      filter.frequency.value = 200;
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);
      if (type === "correct") {
        osc.type = "triangle";
        osc.frequency.setValueAtTime(880, now);
        osc.frequency.exponentialRampToValueAtTime(440, now + 0.18);
        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(0.12, now + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);
      } else {
        osc.type = "square";
        osc.frequency.setValueAtTime(220, now);
        osc.frequency.exponentialRampToValueAtTime(80, now + 0.25);
        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(0.08, now + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.45);
      }
      osc.start(now);
      osc.stop(now + 0.5);
    } catch (e) {
      console.warn("playBeep failed:", e);
    }
  }

  function setBackgroundSound(on) {
    tryCreateAudioContext();
    if (!audioCtx || !bgGain) {
      audioEnabled = false;
      return;
    }
    if (on) {
      audioEnabled = true;
      // fade in
      bgGain.gain.cancelScheduledValues(audioCtx.currentTime);
      bgGain.gain.setValueAtTime(bgGain.gain.value, audioCtx.currentTime);
      bgGain.gain.linearRampToValueAtTime(0.02, audioCtx.currentTime + 0.5);
    } else {
      audioEnabled = false;
      bgGain.gain.cancelScheduledValues(audioCtx.currentTime);
      bgGain.gain.setValueAtTime(bgGain.gain.value, audioCtx.currentTime);
      bgGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
    }
  }

  // Game state
  let score = 0;
  let wrong = 0;
  let question = null;
  let choices = [];
  let selectedChoice = 0;
  let gameState = "playing"; // playing, won, lost
  let drone = {
    x: WIDTH / 2,
    y: 150,
    targetX: WIDTH / 2,
    targetY: 150,
    vx: 0,
    vy: 0,
    w: 70,
    h: 36,
    bobOffset: 0,
    bobDir: 1,
  };
  let flyAnim = null;
  let lastTick = performance.now();

  // Accessibility announcement
  function announce(text) {
    liveRegion.textContent = text;
  }

  // Utilities
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function clamp(v, a, b) {
    return Math.max(a, Math.min(b, v));
  }

  // Generate a simple math question appropriate for 7-9
  function generateQuestion() {
    // choose operation weighted: addition/subtraction mostly, some multiplication
    const opRoll = Math.random();
    let a, b, op, answer;
    if (opRoll < 0.55) {
      // addition
      a = randInt(1, 20);
      b = randInt(1, 20);
      op = "+";
      answer = a + b;
    } else if (opRoll < 0.9) {
      // subtraction but ensure non-negative
      a = randInt(1, 20);
      b = randInt(1, a);
      op = "-";
      answer = a - b;
    } else {
      // multiplication small
      a = randInt(2, 8);
      b = randInt(2, 8);
      op = "×";
      answer = a * b;
    }
    return { a, b, op, answer };
  }

  function generateChoices(correct) {
    const set = new Set();
    set.add(correct);
    while (set.size < 4) {
      // generate plausible distractors
      const offset = randInt(-6, 8);
      let cand = correct + offset;
      if (Math.random() < 0.1) cand = correct + (Math.random() < 0.5 ? 10 : -10);
      if (cand < 0) cand = Math.abs(cand) + 1;
      set.add(cand);
    }
    const arr = Array.from(set);
    // shuffle
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function nextQuestion() {
    question = generateQuestion();
    choices = generateChoices(question.answer);
    selectedChoice = 0;
    // assign random target positions for packages (choices)
    // but keep layout consistent horizontally
    // announce
    announce(`New question: ${question.a} ${question.op} ${question.b}. Press 1 to 4 to choose.`);
  }

  // Initialize
  function resetGame() {
    score = 0;
    wrong = 0;
    gameState = "playing";
    drone.x = WIDTH / 2;
    drone.y = 150;
    drone.targetX = WIDTH / 2;
    drone.targetY = 150;
    setBackgroundSound(true); // start gentle hum (may require user gesture)
    nextQuestion();
    announce(`Game started. Answer ${TARGET_SCORE} questions correctly. You have ${MAX_WRONG} lives.`);
  }

  // Drawing helpers with measureText checks and background rectangles
  function drawTextBox(x, y, text, font, textColor = "#072", bgColor = "rgba(255,255,255,0.85)") {
    ctx.font = font;
    const metrics = ctx.measureText(text);
    const textW = metrics.width;
    const textH = parseInt(font, 10) || 16;
    const pad = 8;
    const boxW = textW + pad * 2;
    const boxH = textH + pad * 2;
    ctx.fillStyle = bgColor;
    ctx.fillRect(x, y, boxW, boxH);
    ctx.fillStyle = textColor;
    ctx.textBaseline = "top";
    ctx.fillText(text, x + pad, y + pad);
    return { x, y, w: boxW, h: boxH };
  }

  // Drone drawing function (wacky and calming)
  function drawDrone(x, y, w, h, label = "") {
    // shadow
    ctx.save();
    ctx.beginPath();
    ctx.ellipse(x, y + h / 1.8, w * 0.6, h * 0.3, 0, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(0,0,0,0.12)";
    ctx.fill();
    ctx.restore();

    // body
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = "#2b4a7a"; // mellow navy
    ctx.strokeStyle = "#0f1e33";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(0, 0, w / 2, h / 2, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // cockpit glass
    ctx.beginPath();
    ctx.fillStyle = "#9fd7ff";
    ctx.ellipse(w * -0.12, -2, w * 0.28, h * 0.32, -0.2, 0, Math.PI * 2);
    ctx.fill();

    // propellers - wacky wobble
    const t = performance.now() / 150;
    for (let i = -1; i <= 1; i += 2) {
      ctx.save();
      ctx.translate((w / 2) * i, -h * 0.5);
      ctx.rotate(Math.sin(t + i) * 0.8);
      ctx.fillStyle = "#c8f0ff";
      ctx.fillRect(-8, -2, 16, 4);
      ctx.restore();
    }

    // little eyes
    ctx.fillStyle = "#091b30";
    ctx.beginPath();
    ctx.arc(-w * 0.12, -2, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(6, -3, 2.2, 0, Math.PI * 2);
    ctx.fill();

    // cargo hook
    ctx.strokeStyle = "#1b2b3f";
    ctx.beginPath();
    ctx.moveTo(6, h / 2 - 2);
    ctx.lineTo(6, h / 2 + 18);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(6, h / 2 + 22, 6, 0, Math.PI);
    ctx.stroke();

    ctx.restore();

    // label
    if (label) {
      ctx.font = "12px sans-serif";
      const m = ctx.measureText(label);
      ctx.fillStyle = "#072";
      ctx.fillText(label, x - m.width / 2, y + h / 1.6);
    }
  }

  // Draw package (choice)
  function drawPackage(x, y, w, h, text, index, isSelected, isCorrectHint = false) {
    ctx.save();
    // base
    ctx.fillStyle = isSelected ? "#ffe6a9" : "#fff2dd";
    ctx.strokeStyle = "#8b5e3c";
    ctx.lineWidth = 2;
    ctx.fillRect(x - w / 2, y - h / 2, w, h);
    ctx.strokeRect(x - w / 2, y - h / 2, w, h);
    // tape
    ctx.fillStyle = "#c88222";
    ctx.fillRect(x - 6, y - h / 2, 12, h);
    // label
    ctx.fillStyle = "#3a2b14";
    ctx.font = CHOICE_FONT;
    ctx.textBaseline = "middle";
    const textWidth = ctx.measureText(text).width;
    // center text, but ensure fits
    const maxTextW = w - 12;
    let displayText = text;
    if (textWidth > maxTextW) {
      // truncate with ellipsis
      while (ctx.measureText(displayText + "...").width > maxTextW && displayText.length > 0) {
        displayText = displayText.slice(0, -1);
      }
      displayText = displayText + "...";
    }
    ctx.fillText(displayText, x - ctx.measureText(displayText).width / 2, y);
    // index small
    ctx.font = "12px sans-serif";
    ctx.fillStyle = "#0f2b3f";
    ctx.fillText(index + 1, x - w / 2 + 8, y - h / 2 + 12);
    // highlight correct hint when game over
    if (isCorrectHint) {
      ctx.strokeStyle = "rgba(0,150,0,0.8)";
      ctx.lineWidth = 3;
      ctx.strokeRect(x - w / 2 + 4, y - h / 2 + 4, w - 8, h - 8);
    }
    ctx.restore();
  }

  // Positions for UI elements ensuring no overlap
  function drawUI() {
    // Score top-left
    ctx.font = FONT_IMPORTANT;
    const scoreText = `Score: ${score}/${TARGET_SCORE}`;
    const scoreBox = drawTextBox(PADDING, PADDING, scoreText, FONT_IMPORTANT, "#063", "rgba(255,255,255,0.9)");

    // Lives top-right
    ctx.font = FONT_IMPORTANT;
    const livesText = `Lives: ${Math.max(0, MAX_WRONG - wrong)}`;
    const livesMetrics = ctx.measureText(livesText);
    const livesW = livesMetrics.width + 8 * 2;
    const livesX = WIDTH - PADDING - livesW;
    drawTextBox(livesX, PADDING, livesText, FONT_IMPORTANT, "#6a0222", "rgba(255,255,255,0.9)");

    // Audio toggle indicator next to lives (non-overlapping)
    ctx.font = "14px sans-serif";
    const audioText = `Sound: ${audioEnabled ? "On (S)" : "Off (S)"}`;
    const audioW = ctx.measureText(audioText).width + 8 * 2;
    const audioX = livesX - 10 - audioW;
    drawTextBox(audioX, PADDING, audioText, "14px sans-serif", "#07364d", "rgba(255,255,255,0.85)");

    // Question area centered under top bar
    ctx.font = FONT_IMPORTANT;
    const qText = `${question.a} ${question.op} ${question.b} = ?`;
    ctx.font = FONT_IMPORTANT;
    const qMetrics = ctx.measureText(qText);
    const qW = qMetrics.width + 16;
    const qX = (WIDTH - qW) / 2;
    const qY = PADDING + 8;
    // place question low enough to avoid UI top overlap: ensure qY + boxH < some value
    drawTextBox(qX, qY + 40, qText, FONT_IMPORTANT, "#05244a", "rgba(255,255,255,0.95)");

    // Instructions bottom-center
    const instrText = "Choose the correct package (1-4 or click). Press S to toggle sound. Press R to restart.";
    ctx.font = FONT_BODY;
    const instrMetrics = ctx.measureText(instrText);
    const instrW = Math.min(instrMetrics.width, WIDTH - PADDING * 2);
    const instrX = (WIDTH - instrW) / 2;
    const instrY = HEIGHT - PADDING - 40;
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.fillRect(instrX - 6, instrY - 6, instrW + 12, 40);
    ctx.fillStyle = "#00324d";
    ctx.font = FONT_BODY;
    ctx.textBaseline = "top";
    // Wrap if necessary
    const maxLineWidth = instrW;
    const words = instrText.split(" ");
    let line = "";
    let lineY = instrY + 4;
    for (let w of words) {
      const test = line ? line + " " + w : w;
      if (ctx.measureText(test).width > maxLineWidth) {
        ctx.fillText(line, instrX, lineY);
        line = w;
        lineY += 18;
      } else {
        line = test;
      }
    }
    if (line) {
      ctx.fillText(line, instrX, lineY);
    }
  }

  function drawScene() {
    // clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // sky gradient
    const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    grad.addColorStop(0, "#e6f2ff");
    grad.addColorStop(1, "#f7fbff");
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // distant hills / city (wacky elements)
    ctx.save();
    ctx.fillStyle = "#dceef8";
    ctx.beginPath();
    ctx.ellipse(140, HEIGHT - 50, 220, 40, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(560, HEIGHT - 70, 260, 45, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // draw drone (animated)
    drawDrone(drone.x, drone.y + Math.sin(drone.bobOffset) * 6, drone.w, drone.h);

    // packages (choices)
    const baseY = 320;
    const packageW = 140;
    const packageH = 60;
    const margin = 20;
    const totalW = choices.length * packageW + (choices.length - 1) * margin;
    const startX = (WIDTH - totalW) / 2 + packageW / 2;
    // compute positions and draw
    for (let i = 0; i < choices.length; i++) {
      const x = startX + i * (packageW + margin);
      const y = baseY + (i % 2 === 0 ? 8 : -8); // slight vertical wobble
      const isSelected = i === selectedChoice;
      const isCorrectHint = gameState !== "playing" && choices[i] === question.answer;
      drawPackage(x, y, packageW, packageH, String(choices[i]), i, isSelected, isCorrectHint);
    }

    // draw UI elements (score, lives, instructions)
    drawUI();

    // Draw progress: stars collected as cute icons
    const starStartX = PADDING;
    const starY = PADDING + 60;
    for (let i = 0; i < TARGET_SCORE; i++) {
      const sX = starStartX + i * 18;
      ctx.beginPath();
      ctx.fillStyle = i < score ? "#ffd200" : "#fff6cc";
      // simple star-like circle for simplicity
      ctx.arc(sX, starY, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "#8b6b00";
      ctx.stroke();
    }
  }

  function update(dt) {
    // gentle bob
    drone.bobOffset += dt * 0.01;

    // smooth movement towards target
    const dx = drone.targetX - drone.x;
    const dy = drone.targetY - drone.y;
    drone.vx = dx * 0.08;
    drone.vy = dy * 0.08;
    drone.x += drone.vx;
    drone.y += drone.vy;
  }

  // Try to pick current selected choice (by index)
  function pickChoice(index) {
    if (gameState !== "playing") return;
    if (!question) return;
    index = clamp(index, 0, choices.length - 1);
    selectedChoice = index;
    // move drone to above package
    const baseY = 320;
    const packageW = 140;
    const margin = 20;
    const totalW = choices.length * packageW + (choices.length - 1) * margin;
    const startX = (WIDTH - totalW) / 2 + packageW / 2;
    const targetX = startX + index * (packageW + margin);
    drone.targetX = targetX;
    drone.targetY = 220; // hover higher, then descend when confirming

    // on click we submit selection immediately
  }

  function submitChoice(index) {
    if (gameState !== "playing") return;
    pickChoice(index);
    // small delay to let drone move visually (200ms) then evaluate
    setTimeout(() => {
      const chosen = choices[index];
      if (chosen === question.answer) {
        score += 1;
        playBeep({ type: "correct" });
        announce(`Correct! ${question.a} ${question.op} ${question.b} equals ${question.answer}. Score ${score} of ${TARGET_SCORE}.`);
        // drone picks up a star and flies up wacky
        rewardAnimation(index);
      } else {
        wrong += 1;
        playBeep({ type: "wrong" });
        announce(`Oops. ${question.a} ${question.op} ${question.b} is ${question.answer}. Lives left ${Math.max(0, MAX_WRONG - wrong)}.`);
        // shake drone
        wrongAnimation();
        if (wrong >= MAX_WRONG) {
          // game over
          gameState = "lost";
          announce(`Game over. You answered ${score} correctly. Press R to restart.`);
          setBackgroundSound(false);
        } else {
          nextQuestion();
        }
      }
      // check win
      if (score >= TARGET_SCORE) {
        gameState = "won";
        announce(`Victory! You collected ${score} stars. Press R to play again.`);
        setBackgroundSound(false);
      }
    }, 260);
  }

  // Animations for reward and wrong answers
  function rewardAnimation(index) {
    // Drone descends, attach star, fly up to celebrate
    const baseY = 320;
    const packageW = 140;
    const margin = 20;
    const totalW = choices.length * packageW + (choices.length - 1) * margin;
    const startX = (WIDTH - totalW) / 2 + packageW / 2;
    const px = startX + index * (packageW + margin);
    const py = baseY;
    // sequence: descend to py-10, then ascend with star and small spiral
    let t = 0;
    const dur = 900;
    const startX0 = drone.x;
    const startY0 = drone.y;
    const start = performance.now();
    function anim() {
      const now = performance.now();
      t = now - start;
      const p = Math.min(1, t / dur);
      if (p < 0.4) {
        // move to package
        drone.x = startX0 + (px - startX0) * (p / 0.4);
        drone.y = startY0 + (py - 20 - startY0) * (p / 0.4);
      } else {
        // ascend
        const pp = (p - 0.4) / 0.6;
        // spiral up
        drone.x = px + Math.sin(pp * Math.PI * 4) * 20 * (1 - pp);
        drone.y = py - 60 * pp - 40 * pp * pp;
      }
      if (p < 1) {
        flyAnim = requestAnimationFrame(anim);
      } else {
        cancelAnimationFrame(flyAnim);
        flyAnim = null;
        // mark score and continue
        nextQuestion();
      }
    }
    anim();
  }

  function wrongAnimation() {
    // shake drone a bit
    const startX0 = drone.x;
    const startY0 = drone.y;
    let t0 = performance.now();
    const dur = 420;
    function anim() {
      const t = performance.now() - t0;
      const p = Math.min(1, t / dur);
      drone.x = startX0 + Math.sin(p * Math.PI * 8) * 10 * (1 - p);
      drone.y = startY0 + Math.sin(p * Math.PI * 4) * 4 * (1 - p);
      if (p < 1) {
        requestAnimationFrame(anim);
      } else {
        // reset to hover spot and nextQuestion handled by caller
        drone.targetX = WIDTH / 2;
        drone.targetY = 150;
      }
    }
    anim();
  }

  // Handle mouse clicks mapped to canvas coordinates
  canvas.addEventListener("click", (ev) => {
    const rect = canvas.getBoundingClientRect();
    const mx = ev.clientX - rect.left;
    const my = ev.clientY - rect.top;
    // If game over or won, check if restart button clicked
    if (gameState !== "playing") {
      // check restart button area: center rect
      const btnW = 260;
      const btnH = 54;
      const btnX = (WIDTH - btnW) / 2;
      const btnY = (HEIGHT - btnH) / 2 + 80;
      if (mx >= btnX && mx <= btnX + btnW && my >= btnY && my <= btnY + btnH) {
        resetGame();
        return;
      }
    }
    // Determine if clicked on a package
    const baseY = 320;
    const packageW = 140;
    const packageH = 60;
    const margin = 20;
    const totalW = choices.length * packageW + (choices.length - 1) * margin;
    const startX = (WIDTH - totalW) / 2 + packageW / 2;
    for (let i = 0; i < choices.length; i++) {
      const x = startX + i * (packageW + margin);
      const y = baseY + (i % 2 === 0 ? 8 : -8);
      if (mx >= x - packageW / 2 && mx <= x + packageW / 2 && my >= y - packageH / 2 && my <= y + packageH / 2) {
        // ensure audio user gesture resumes audio
        resumeAudioIfNeeded();
        submitChoice(i);
        return;
      }
    }
  });

  // Keyboard controls
  window.addEventListener("keydown", (ev) => {
    // Provide a key to resume audio: any game action should resume
    resumeAudioIfNeeded();
    if (ev.key >= "1" && ev.key <= "4") {
      const idx = parseInt(ev.key, 10) - 1;
      if (gameState === "playing") {
        submitChoice(idx);
      } else {
        // when ended pressing number does nothing
      }
      ev.preventDefault();
      return;
    }
    if (ev.key === "ArrowLeft") {
      if (gameState === "playing") {
        selectedChoice = (selectedChoice - 1 + choices.length) % choices.length;
      }
      ev.preventDefault();
      return;
    }
    if (ev.key === "ArrowRight") {
      if (gameState === "playing") {
        selectedChoice = (selectedChoice + 1) % choices.length;
      }
      ev.preventDefault();
      return;
    }
    if (ev.key === "Enter") {
      if (gameState === "playing") {
        submitChoice(selectedChoice);
      }
      ev.preventDefault();
      return;
    }
    if (ev.key === "s" || ev.key === "S") {
      // toggle sound
      setBackgroundSound(!audioEnabled);
      announce(`Sound ${audioEnabled ? "on" : "off"}.`);
      ev.preventDefault();
      return;
    }
    if (ev.key === "r" || ev.key === "R") {
      // restart
      resetGame();
      ev.preventDefault();
      return;
    }
  });

  // Main loop
  function tick(now) {
    const dt = now - lastTick;
    lastTick = now;
    if (gameState === "playing") {
      update(dt);
    }
    drawScene();

    // If game ended, overlay victory or game over screen
    if (gameState === "won" || gameState === "lost") {
      // dark overlay
      ctx.fillStyle = "rgba(6,10,20,0.6)";
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      // big text
      ctx.font = "36px bold sans-serif";
      ctx.fillStyle = "#fff";
      ctx.textBaseline = "middle";
      const title = gameState === "won" ? "You did it! Drone victory!" : "Game Over";
      const m = ctx.measureText(title);
      ctx.fillText(title, (WIDTH - m.width) / 2, HEIGHT / 2 - 40);
      ctx.font = "20px sans-serif";
      const msg = gameState === "won" ? `You collected ${score} stars!` : `You collected ${score} stars. Try again!`;
      const mm = ctx.measureText(msg);
      ctx.fillText(msg, (WIDTH - mm.width) / 2, HEIGHT / 2 - 5);

      // restart button
      const btnW = 260;
      const btnH = 54;
      const btnX = (WIDTH - btnW) / 2;
      const btnY = (HEIGHT - btnH) / 2 + 80;
      ctx.fillStyle = "#ffdd59";
      ctx.fillRect(btnX, btnY, btnW, btnH);
      ctx.strokeStyle = "#996000";
      ctx.lineWidth = 3;
      ctx.strokeRect(btnX, btnY, btnW, btnH);
      ctx.font = "20px bold sans-serif";
      ctx.fillStyle = "#000";
      const btnText = "Restart (R)";
      const bm = ctx.measureText(btnText);
      ctx.fillText(btnText, btnX + (btnW - bm.width) / 2, btnY + btnH / 2 - 8);
    }

    requestAnimationFrame(tick);
  }

  // Start
  tryCreateAudioContext();
  resetGame();
  lastTick = performance.now();
  requestAnimationFrame(tick);

  // Provide error handling for visibility changes (suspend audio)
  document.addEventListener("visibilitychange", () => {
    if (!audioCtx) return;
    try {
      if (document.hidden) {
        audioCtx.suspend && audioCtx.suspend();
      } else {
        if (audioEnabled) audioCtx.resume && audioCtx.resume();
      }
    } catch (e) {
      console.warn("visibility audio handling error:", e);
    }
  });

  // Expose a small debug on container for screen reader: text alternatives for current question
  function updateAria() {
    if (question && gameState === "playing") {
      container.setAttribute(
        "aria-label",
        `Drone math game. Question: ${question.a} ${question.op} ${question.b}. Choices: ${choices
          .map((c, i) => `${i + 1}: ${c}`)
          .join(", ")}. Score ${score}. Lives left ${Math.max(0, MAX_WRONG - wrong)}.`
      );
    } else {
      container.setAttribute("aria-label", `Drone math game. ${gameState}. Score ${score}. Lives left ${Math.max(0, MAX_WRONG - wrong)}.`);
    }
  }

  // Update aria periodically
  setInterval(updateAria, 1200);

  // Ensure keyboard focus for accessibility
  container.addEventListener("click", () => {
    container.focus();
    resumeAudioIfNeeded();
  });

  // Safety: if audio unavailable, provide visual cue in the UI
  if (!window.AudioContext && !window.webkitAudioContext) {
    announce("Audio not supported. Visual cues provided.");
  }
})();
---

