{
  "generated_date": "2025-08-21",
  "generated_timestamp": "2025-08-21T00:26:35.470746",
  "model": "gpt-5-mini",
  "theme": "electricity",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 10345,
  "game_filename": "2025-08-21.js",
  "game_size_bytes": 30649,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Electricity Math Game for ages 7-9\n// Renders entirely inside the element with id \"game-of-the-day-stage\"\n// Canvas 720x480, all graphics via canvas, sounds via Web Audio API.\n// Accessible: keyboard controls, instructions on canvas, aria attributes on container.\n// Author: Educational Game Designer AI\n(function () {\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const CANVAS_ID = 'game-canvas';\n  const STAGE_ID = 'game-of-the-day-stage';\n\n  // Find container\n  const container = document.getElementById(STAGE_ID);\n  if (!container) {\n    console.error('Game container element with id \"' + STAGE_ID + '\" not found.');\n    return;\n  }\n  // Make container focusable and accessible\n  container.tabIndex = 0;\n  container.setAttribute('role', 'application');\n  container.setAttribute('aria-label', 'Spark Circuit: an electricity-themed math game for children ages 7 to 9.');\n  container.style.outline = 'none';\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.id = CANVAS_ID;\n  canvas.style.display = 'block';\n  canvas.style.width = WIDTH + 'px';\n  canvas.style.height = HEIGHT + 'px';\n  container.innerHTML = ''; // clear children\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    console.error('Canvas context not available.');\n    return;\n  }\n\n  // Web Audio setup with error handling\n  let audioAvailable = true;\n  let audioCtx = null;\n  let bgGain = null;\n  let bgOsc = null;\n  try {\n    const AudioContext = window.AudioContext || window.webkitAudioContext;\n    audioCtx = new AudioContext();\n    // start silent background hum but keep low volume; create nodes now but don't start oscillators until user gesture (resume)\n    bgGain = audioCtx.createGain();\n    bgGain.gain.value = 0.02; // gentle background\n    bgGain.connect(audioCtx.destination);\n    bgOsc = audioCtx.createOscillator();\n    bgOsc.type = 'sine';\n    bgOsc.frequency.value = 110; // low hum\n    const bgFilter = audioCtx.createBiquadFilter();\n    bgFilter.type = 'lowpass';\n    bgFilter.frequency.value = 600;\n    bgOsc.connect(bgFilter);\n    bgFilter.connect(bgGain);\n    // We'll start oscillator upon first user interaction\n  } catch (e) {\n    console.warn('Web Audio API not available or blocked: ' + e);\n    audioAvailable = false;\n    audioCtx = null;\n    bgGain = null;\n    bgOsc = null;\n  }\n\n  // Audio helper functions with error handling\n  function safeResumeAudio() {\n    if (!audioAvailable || !audioCtx) return;\n    if (audioCtx.state === 'suspended') {\n      audioCtx.resume().catch((e) => {\n        console.warn('AudioContext resume failed:', e);\n      });\n    }\n    // start background oscillator if not started\n    if (bgOsc && bgOsc.start) {\n      try {\n        // start only once\n        if (!bgOsc._started) {\n          bgOsc.start();\n          bgOsc._started = true;\n        }\n      } catch (e) {\n        // ignore if already started\n      }\n    }\n  }\n\n  function playBeep({freq = 880, type = 'sine', duration = 0.12, gain = 0.08, slide = 0} = {}) {\n    if (!audioAvailable || !audioCtx) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = type;\n      o.frequency.value = freq;\n      g.gain.value = gain;\n      o.connect(g);\n      g.connect(audioCtx.destination);\n      const now = audioCtx.currentTime;\n      if (slide !== 0) {\n        o.frequency.linearRampToValueAtTime(freq + slide, now + duration);\n      }\n      g.gain.setValueAtTime(gain, now);\n      g.gain.exponentialRampToValueAtTime(0.001, now + duration);\n      o.start(now);\n      o.stop(now + duration + 0.02);\n    } catch (e) {\n      console.warn('playBeep failed', e);\n    }\n  }\n\n  function playCorrectSound() {\n    // friendly ascending beep\n    playBeep({freq: 660, type: 'sine', duration: 0.25, gain: 0.09, slide: 220});\n    // small sparkle layers\n    setTimeout(() => playBeep({freq: 880, type: 'triangle', duration: 0.12, gain: 0.05}), 70);\n  }\n\n  function playIncorrectSound() {\n    // buzzy low buzz\n    if (!audioAvailable || !audioCtx) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = 'square';\n      o.frequency.value = 120;\n      g.gain.value = 0.12;\n      const f = audioCtx.createBiquadFilter();\n      f.type = 'lowpass';\n      f.frequency.value = 600;\n      o.connect(f);\n      f.connect(g);\n      g.connect(audioCtx.destination);\n      const now = audioCtx.currentTime;\n      g.gain.setValueAtTime(0.12, now);\n      g.gain.exponentialRampToValueAtTime(0.001, now + 0.35);\n      o.start(now);\n      o.stop(now + 0.36);\n    } catch (e) {\n      console.warn('playIncorrectSound failed', e);\n    }\n  }\n\n  function playSelectSound() {\n    playBeep({freq: 440, type: 'sine', duration: 0.08, gain: 0.06});\n  }\n\n  // Game state\n  const totalRounds = 6;\n  let currentRound = 0;\n  let score = 0;\n  let roundTarget = 0;\n  let givenAddend = 0;\n  let choices = []; // battery choices: {value, x, y, selected, dragging, id}\n  let correctChoiceIndex = 0;\n  let bulbs = []; // bulbs with required charge and lit state\n  let message = 'Click or press Space to start. Use Left/Right and Enter to choose.';\n  let gamePhase = 'intro'; // intro, playing, animating, finished\n  let selectedIndex = 0;\n  let draggingBattery = null;\n  let mouse = {x: 0, y: 0};\n  let lastTime = 0;\n  let animationParticles = [];\n\n  // Visual styles and helper drawing functions\n  function drawRoundedRect(ctx, x, y, w, h, r) {\n    r = Math.min(r, w / 2, h / 2);\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n  }\n\n  // Create next round\n  function seedRound() {\n    currentRound++;\n    // target between 6 and 18\n    roundTarget = 6 + Math.floor(Math.random() * 13);\n    givenAddend = 1 + Math.floor(Math.random() * Math.min(9, roundTarget - 1));\n    const correct = roundTarget - givenAddend;\n    // build choices with one correct and two distractors\n    const distractors = new Set();\n    while (distractors.size < 2) {\n      let d = correct + (Math.floor(Math.random() * 7) - 3);\n      if (d < 0) d = Math.abs(d);\n      if (d === correct) continue;\n      distractors.add(d);\n    }\n    const arr = Array.from(distractors);\n    arr.push(correct);\n    // shuffle\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    choices = [];\n    // place batteries near bottom center\n    const baseY = 380;\n    const spacing = 140;\n    for (let i = 0; i < 3; i++) {\n      choices.push({\n        id: i,\n        value: arr[i],\n        x: 160 + i * spacing,\n        y: baseY,\n        r: 32,\n        selected: i === 0,\n        dragging: false,\n        vx: 0,\n        vy: 0\n      });\n    }\n    correctChoiceIndex = choices.findIndex(c => c.value === correct);\n    selectedIndex = 0;\n    message = `Charge the bulb: ${givenAddend} + ? = ${roundTarget}`;\n    gamePhase = 'playing';\n  }\n\n  // Initialize bulbs: row of 5 bulbs representing the circuit board; some lit already\n  function initBulbs() {\n    bulbs = [];\n    const count = 5;\n    const startX = 160;\n    const gap = 100;\n    for (let i = 0; i < count; i++) {\n      bulbs.push({\n        id: i,\n        x: startX + i * gap,\n        y: 160,\n        r: 28,\n        required: 0,\n        lit: false\n      });\n    }\n    // assign required charges to bulbs: random small numbers 5-15\n    for (let b of bulbs) {\n      b.required = 5 + Math.floor(Math.random() * 11);\n      b.lit = false;\n    }\n  }\n\n  // Utility: collision between battery and bulb\n  function pointToBulb(px, py) {\n    for (let b of bulbs) {\n      const dx = px - b.x;\n      const dy = py - b.y;\n      if (Math.sqrt(dx * dx + dy * dy) < b.r + 24) {\n        return b;\n      }\n    }\n    return null;\n  }\n\n  // Start game\n  function startGame() {\n    score = 0;\n    currentRound = 0;\n    initBulbs();\n    seedRound();\n    // start background audio if available\n    safeResumeAudio();\n    message = 'Make the right choice to charge bulbs. Drag or use keyboard.';\n  }\n\n  // Input handling: keyboard and mouse\n  function onKeyDown(e) {\n    // resume audio on first key\n    safeResumeAudio();\n    if (gamePhase === 'intro') {\n      if (e.key === ' ' || e.key === 'Enter') {\n        startGame();\n        e.preventDefault();\n        return;\n      }\n    }\n    if (gamePhase === 'playing') {\n      if (e.key === 'ArrowLeft') {\n        selectedIndex = (selectedIndex + choices.length - 1) % choices.length;\n        playSelectSound();\n      } else if (e.key === 'ArrowRight') {\n        selectedIndex = (selectedIndex + 1) % choices.length;\n        playSelectSound();\n      } else if (e.key === 'Enter' || e.key === ' ') {\n        // \"launch\" chosen battery to the bulb with smallest remaining required that matches ability\n        const c = choices[selectedIndex];\n        // for keyboard action, we'll auto-target the closest bulb to center that is not lit\n        const targetBulb = bulbs.reduce((best, b) => {\n          if (b.lit) return best;\n          if (!best) return b;\n          const distB = Math.abs(b.x - WIDTH / 2);\n          const distBest = Math.abs(best.x - WIDTH / 2);\n          return distB < distBest ? b : best;\n        }, null);\n        if (targetBulb) {\n          launchBatteryTo(c, targetBulb);\n        }\n        e.preventDefault();\n      }\n    } else if (gamePhase === 'finished') {\n      if (e.key === 'Enter' || e.key === ' ') {\n        // restart\n        startGame();\n        e.preventDefault();\n      }\n    }\n  }\n\n  // Mouse events for drag and drop\n  canvas.addEventListener('mousedown', function (e) {\n    const rect = canvas.getBoundingClientRect();\n    mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);\n    mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);\n    // resume audio\n    safeResumeAudio();\n    if (gamePhase === 'intro') {\n      startGame();\n      return;\n    }\n    if (gamePhase !== 'playing') return;\n    // check if clicked on a battery\n    for (let i = 0; i < choices.length; i++) {\n      const c = choices[i];\n      const dx = mouse.x - c.x;\n      const dy = mouse.y - c.y;\n      if (Math.sqrt(dx * dx + dy * dy) <= c.r) {\n        c.dragging = true;\n        draggingBattery = c;\n        selectedIndex = i;\n        playSelectSound();\n        break;\n      }\n    }\n  });\n\n  canvas.addEventListener('mousemove', function (e) {\n    const rect = canvas.getBoundingClientRect();\n    mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);\n    mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);\n    if (draggingBattery) {\n      draggingBattery.x = mouse.x;\n      draggingBattery.y = mouse.y;\n    }\n  });\n\n  canvas.addEventListener('mouseup', function (e) {\n    const rect = canvas.getBoundingClientRect();\n    mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);\n    mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);\n    if (draggingBattery) {\n      const b = pointToBulb(mouse.x, mouse.y);\n      if (b) {\n        launchBatteryTo(draggingBattery, b);\n      } else {\n        // animate battery back to original position\n        // find index\n        playSelectSound();\n        const originX = 160 + draggingBattery.id * 140;\n        const originY = 380;\n        draggingBattery.vx = (originX - draggingBattery.x) * 0.2;\n        draggingBattery.vy = (originY - draggingBattery.y) * 0.2;\n      }\n      draggingBattery.dragging = false;\n      draggingBattery = null;\n    }\n  });\n\n  // Touch support: simple mapping to mouse events\n  canvas.addEventListener('touchstart', function (e) {\n    e.preventDefault();\n    const t = e.touches[0];\n    const rect = canvas.getBoundingClientRect();\n    mouse.x = (t.clientX - rect.left) * (canvas.width / rect.width);\n    mouse.y = (t.clientY - rect.top) * (canvas.height / rect.height);\n    // resume audio\n    safeResumeAudio();\n    if (gamePhase === 'intro') {\n      startGame();\n      return;\n    }\n    if (gamePhase !== 'playing') return;\n    for (let i = 0; i < choices.length; i++) {\n      const c = choices[i];\n      const dx = mouse.x - c.x;\n      const dy = mouse.y - c.y;\n      if (Math.sqrt(dx * dx + dy * dy) <= c.r) {\n        c.dragging = true;\n        draggingBattery = c;\n        selectedIndex = i;\n        playSelectSound();\n        break;\n      }\n    }\n  }, {passive: false});\n\n  canvas.addEventListener('touchmove', function (e) {\n    e.preventDefault();\n    const t = e.touches[0];\n    const rect = canvas.getBoundingClientRect();\n    mouse.x = (t.clientX - rect.left) * (canvas.width / rect.width);\n    mouse.y = (t.clientY - rect.top) * (canvas.height / rect.height);\n    if (draggingBattery) {\n      draggingBattery.x = mouse.x;\n      draggingBattery.y = mouse.y;\n    }\n  }, {passive: false});\n\n  canvas.addEventListener('touchend', function (e) {\n    e.preventDefault();\n    if (draggingBattery) {\n      const b = pointToBulb(mouse.x, mouse.y);\n      if (b) {\n        launchBatteryTo(draggingBattery, b);\n      } else {\n        const originX = 160 + draggingBattery.id * 140;\n        const originY = 380;\n        draggingBattery.vx = (originX - draggingBattery.x) * 0.2;\n        draggingBattery.vy = (originY - draggingBattery.y) * 0.2;\n      }\n      draggingBattery.dragging = false;\n      draggingBattery = null;\n    }\n  }, {passive: false});\n\n  // Launch battery to a bulb (animation)\n  function launchBatteryTo(battery, bulb) {\n    if (!battery || !bulb || gamePhase !== 'playing') return;\n    // create small animation: battery will move toward bulb with velocity set\n    const dx = bulb.x - battery.x;\n    const dy = bulb.y - battery.y;\n    battery.vx = dx * 0.12;\n    battery.vy = dy * 0.12;\n    // mark as \"in-flight\" using dragging flag false but special property\n    battery.flyingTo = bulb;\n    battery.flyingProgress = 0;\n  }\n\n  // Handle when a battery reaches a bulb\n  function resolveBatteryToBulb(battery, bulb) {\n    // check math: givenAddend + battery.value === roundTarget ?\n    const sum = givenAddend + battery.value;\n    const correct = (sum === roundTarget);\n    if (correct) {\n      bulb.lit = true;\n      // reward points and progress\n      score += 10;\n      playCorrectSound();\n      // add sparkle particles\n      createSparkles(bulb.x, bulb.y, 12);\n      message = `Great! ${givenAddend} + ${battery.value} = ${roundTarget}. Bulb lit!`;\n    } else {\n      playIncorrectSound();\n      score = Math.max(0, score - 2);\n      message = `Not quite. ${givenAddend} + ${battery.value} = ${sum}. Try again!`;\n      // small zap particle\n      createZap(bulb.x, bulb.y);\n    }\n    // remove battery visually and make small puff\n    battery.used = true;\n    // Check if round is successful (a bulb lit) and advance round\n    if (correct) {\n      // choose next target bulb that is not lit if any\n      const notLit = bulbs.filter(b => !b.lit);\n      if (notLit.length === 0) {\n        // all bulbs lit: finish game\n        gamePhase = 'finished';\n        message = `All bulbs lit! You scored ${score} points. Press Enter to play again.`;\n      } else {\n        // advance to next round if rounds remain\n        if (currentRound < totalRounds) {\n          seedRound();\n        } else {\n          // end after totalRounds\n          gamePhase = 'finished';\n          message = `Great job! You scored ${score} points. Press Enter to play again.`;\n        }\n      }\n    } else {\n      // incorrect: let player try the same round again with remaining choices\n      // If all options used, reset choices\n      const available = choices.filter(c => !c.used);\n      if (available.length === 0) {\n        // reset batteries for same round by seeding same values in new positions\n        // Recreate choices keeping values but not used\n        const values = [roundTarget - givenAddend]; // correct\n        // create fresh distractors\n        while (values.length < 3) {\n          let d = Math.max(0, Math.floor(Math.random() * 13));\n          if (!values.includes(d)) values.push(d);\n        }\n        // shuffle\n        for (let i = values.length - 1; i > 0; i--) {\n          const j = Math.floor(Math.random() * (i + 1));\n          [values[i], values[j]] = [values[j], values[i]];\n        }\n        for (let i = 0; i < 3; i++) {\n          choices[i].value = values[i];\n          choices[i].used = false;\n          choices[i].x = 160 + i * 140;\n          choices[i].y = 380;\n        }\n        message = 'Choices refreshed. Try again!';\n      }\n    }\n  }\n\n  // Particles for fun feedback\n  function createSparkles(x, y, count) {\n    for (let i = 0; i < count; i++) {\n      const ang = Math.random() * Math.PI * 2;\n      const speed = 1 + Math.random() * 3;\n      animationParticles.push({\n        x: x,\n        y: y,\n        vx: Math.cos(ang) * speed,\n        vy: Math.sin(ang) * speed,\n        life: 60 + Math.floor(Math.random() * 30),\n        color: `hsl(${160 + Math.random() * 80}, 80%, ${60 + Math.random() * 20}%)`,\n        size: 2 + Math.random() * 3\n      });\n    }\n  }\n\n  function createZap(x, y) {\n    for (let i = 0; i < 8; i++) {\n      const ang = -Math.PI / 2 + (Math.random() - 0.5);\n      animationParticles.push({\n        x: x + Math.random() * 10 - 5,\n        y: y + Math.random() * 10 - 5,\n        vx: Math.cos(ang) * (1 + Math.random() * 2),\n        vy: Math.sin(ang) * (1 + Math.random() * 2),\n        life: 30 + Math.floor(Math.random() * 20),\n        color: `rgba(255,140,0,${0.6 + Math.random() * 0.4})`,\n        size: 2 + Math.random() * 3\n      });\n    }\n  }\n\n  // Main update loop\n  function update(dt) {\n    // Update batteries that are flying\n    for (let c of choices) {\n      if (c.used) {\n        // slowly fade out to an offscreen position\n        c.x += (700 - c.x) * 0.06;\n        c.y += (420 - c.y) * 0.06;\n      } else if (c.flyingTo) {\n        c.flyingProgress += 0.06;\n        c.x += c.vx;\n        c.y += c.vy;\n        // check arrival\n        const dx = c.x - c.flyingTo.x;\n        const dy = c.y - c.flyingTo.y;\n        if (Math.sqrt(dx * dx + dy * dy) < 18 || c.flyingProgress > 1.2) {\n          // resolve\n          const bulb = c.flyingTo;\n          c.flyingTo = null;\n          resolveBatteryToBulb(c, bulb);\n        }\n      } else if (c.dragging) {\n        // position updated by mouse handlers\n      } else {\n        // apply simple spring back to original positions if velocity present\n        if (Math.abs(c.vx) > 0.01 || Math.abs(c.vy) > 0.01) {\n          c.x += c.vx;\n          c.y += c.vy;\n          c.vx *= 0.85;\n          c.vy *= 0.85;\n        } else {\n          // naturally rest on base positions\n          const originX = 160 + c.id * 140;\n          const originY = 380;\n          c.x += (originX - c.x) * 0.08;\n          c.y += (originY - c.y) * 0.08;\n        }\n      }\n    }\n\n    // Update particles\n    for (let i = animationParticles.length - 1; i >= 0; i--) {\n      const p = animationParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy += 0.12; // gravity\n      p.life--;\n      if (p.life <= 0) {\n        animationParticles.splice(i, 1);\n      }\n    }\n  }\n\n  // Draw scene\n  function draw() {\n    // background\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    // calming gradient sky\n    const sky = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    sky.addColorStop(0, '#E6F7FF');\n    sky.addColorStop(1, '#DFF7E6');\n    ctx.fillStyle = sky;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // playful clouds\n    drawCloud(560, 60, 70);\n    drawCloud(420, 40, 50);\n    drawCloud(120, 80, 60);\n\n    // ground / circuit board\n    ctx.save();\n    ctx.translate(0, 0);\n    drawRoundedRect(ctx, 40, 110, WIDTH - 80, 300, 18);\n    ctx.fillStyle = '#0e2b2b';\n    ctx.fill();\n    // circuit board stripes\n    for (let i = 0; i < 6; i++) {\n      ctx.beginPath();\n      ctx.moveTo(60 + i * 100, 120);\n      ctx.lineTo(60 + i * 100, 380);\n      ctx.strokeStyle = 'rgba(255,255,255,0.03)';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    }\n    ctx.restore();\n\n    // Draw professor Volt (left) - a wacky friendly lightning bolt\n    drawProfessorVolt(80, 320);\n\n    // Draw Sparky (little electron) near bottom right\n    drawSparky(620, 360);\n\n    // Draw bulbs (circuit nodes)\n    for (let b of bulbs) {\n      drawBulb(b);\n      // show required number if not lit\n      ctx.font = '14px \"Segoe UI\", Arial';\n      ctx.fillStyle = '#fff';\n      ctx.textAlign = 'center';\n      if (!b.lit) {\n        ctx.fillText(b.required, b.x, b.y + 45);\n      } else {\n        ctx.fillText('ON', b.x, b.y + 45);\n      }\n    }\n\n    // Draw header panel\n    drawHeaderPanel();\n\n    // Draw batteries (choices)\n    for (let i = 0; i < choices.length; i++) {\n      const c = choices[i];\n      drawBattery(c, i === selectedIndex && !c.used);\n    }\n\n    // Draw animation particles\n    for (let p of animationParticles) {\n      ctx.beginPath();\n      ctx.fillStyle = p.color;\n      ctx.globalAlpha = Math.max(0.05, p.life / 60);\n      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.globalAlpha = 1;\n    }\n\n    // Bottom instructions & status\n    ctx.fillStyle = 'rgba(255,255,255,0.9)';\n    ctx.font = '14px \"Segoe UI\", Arial';\n    ctx.textAlign = 'left';\n    ctx.fillText('Score: ' + score, 18, HEIGHT - 22);\n    ctx.textAlign = 'center';\n    ctx.fillText(message, WIDTH / 2, HEIGHT - 22);\n\n    // Audio icon and accessibility hint\n    drawAudioIcon(HEIGHT - 60, WIDTH - 60);\n\n    // If intro or finished, overlay instructions box\n    if (gamePhase === 'intro' || gamePhase === 'finished') {\n      ctx.save();\n      ctx.fillStyle = 'rgba(0,0,0,0.45)';\n      ctx.fillRect(80, 100, WIDTH - 160, 220);\n      ctx.fillStyle = '#fff';\n      ctx.font = '20px \"Segoe UI\", Arial';\n      ctx.textAlign = 'center';\n      if (gamePhase === 'intro') {\n        ctx.fillText('Spark Circuit', WIDTH / 2, 150);\n        ctx.font = '16px \"Segoe UI\", Arial';\n        ctx.fillText('Welcome! Solve the addition puzzles to charge the lightbulbs.', WIDTH / 2, 190);\n        ctx.fillText('Drag a battery to a bulb or use Left/Right and Enter. Click or press Space to start.', WIDTH / 2, 220);\n        ctx.fillText('Each correct answer lights a bulb. Try to light them all!', WIDTH / 2, 250);\n      } else {\n        ctx.fillText('All Done!', WIDTH / 2, 150);\n        ctx.font = '16px \"Segoe UI\", Arial';\n        ctx.fillText(`You scored ${score} points.`, WIDTH / 2, 190);\n        ctx.fillText('Press Enter or click to play again.', WIDTH / 2, 220);\n      }\n      ctx.restore();\n    }\n\n    // Accessibility: draw keyboard hint box\n    ctx.save();\n    ctx.fillStyle = 'rgba(255,255,255,0.85)';\n    drawRoundedRect(ctx, WIDTH - 210, 18, 190, 66, 10);\n    ctx.fill();\n    ctx.fillStyle = '#073742';\n    ctx.font = '12px \"Segoe UI\", Arial';\n    ctx.textAlign = 'left';\n    ctx.fillText('Keyboard: \u2190 \u2192 to choose; Enter to send', WIDTH - 196, 40);\n    ctx.fillText('Space to start/pick; Drag with mouse or touch', WIDTH - 196, 58);\n    ctx.restore();\n  }\n\n  // Drawing helpers for characters and UI\n  function drawProfessorVolt(x, y) {\n    ctx.save();\n    ctx.translate(x, y);\n    // body: lightning bolt\n    ctx.beginPath();\n    ctx.moveTo(-20, -10);\n    ctx.lineTo(0, -70);\n    ctx.lineTo(10, -50);\n    ctx.lineTo(-5, -40);\n    ctx.lineTo(20, -5);\n    ctx.lineTo-5;\n    ctx.closePath();\n    ctx.fillStyle = '#FFD24D';\n    ctx.fill();\n    // face\n    ctx.beginPath();\n    ctx.arc(0, -25, 10, 0, Math.PI * 2);\n    ctx.fillStyle = '#FFF6E0';\n    ctx.fill();\n    ctx.fillStyle = '#333';\n    ctx.beginPath();\n    ctx.arc(-3, -27, 2, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(3, -27, 2, 0, Math.PI * 2);\n    ctx.fill();\n    // smile\n    ctx.beginPath();\n    ctx.arc(0, -22, 4, 0, Math.PI);\n    ctx.strokeStyle = '#333';\n    ctx.lineWidth = 1;\n    ctx.stroke();\n    // nameplate\n    ctx.fillStyle = '#fff';\n    ctx.font = '12px \"Segoe UI\", Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText('Professor Volt', 0, 0);\n    ctx.restore();\n  }\n\n  function drawSparky(x, y) {\n    ctx.save();\n    ctx.translate(x, y);\n    // electron ball\n    ctx.beginPath();\n    ctx.arc(0, 0, 20, 0, Math.PI * 2);\n    const grad = ctx.createRadialGradient(-6, -6, 2, 0, 0, 20);\n    grad.addColorStop(0, '#FFFFFF');\n    grad.addColorStop(0.2, '#99ffff');\n    grad.addColorStop(1, '#33aaff');\n    ctx.fillStyle = grad;\n    ctx.fill();\n    // eyes\n    ctx.fillStyle = '#062a2a';\n    ctx.beginPath();\n    ctx.arc(-6, -4, 3, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(4, -4, 3, 0, Math.PI * 2);\n    ctx.fill();\n    // wacky antenna\n    ctx.beginPath();\n    ctx.moveTo(12, -12);\n    ctx.lineTo(22, -22);\n    ctx.strokeStyle = '#ffd24d';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  function drawBulb(b) {\n    // base metal\n    ctx.save();\n    // bulb glow if lit\n    if (b.lit) {\n      const g = ctx.createRadialGradient(b.x, b.y, 2, b.x, b.y, 80);\n      g.addColorStop(0, 'rgba(255,250,200,0.9)');\n      g.addColorStop(1, 'rgba(255,250,200,0.05)');\n      ctx.fillStyle = g;\n      ctx.beginPath();\n      ctx.arc(b.x, b.y, 80, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // bulb glass\n    ctx.beginPath();\n    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);\n    ctx.fillStyle = b.lit ? '#fff9c6' : '#fff';\n    ctx.fill();\n    // filament (wavy line)\n    ctx.beginPath();\n    ctx.moveTo(b.x - 10, b.y);\n    ctx.quadraticCurveTo(b.x - 3, b.y - 8, b.x, b.y);\n    ctx.quadraticCurveTo(b.x + 3, b.y + 8, b.x + 10, b.y);\n    ctx.strokeStyle = b.lit ? '#ff9900' : '#999';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    // base\n    ctx.fillStyle = '#cfcfcf';\n    drawRoundedRect(ctx, b.x - 12, b.y + b.r - 6, 24, 12, 3);\n    ctx.fill();\n    ctx.restore();\n\n    // show a faint label of required value\n    ctx.font = 'bold 12px \"Segoe UI\", Arial';\n    ctx.textAlign = 'center';\n    ctx.fillStyle = b.lit ? '#444' : '#fff';\n    // number drawn separately above in main loop\n  }\n\n  function drawBattery(b, highlight) {\n    ctx.save();\n    // shadow\n    ctx.beginPath();\n    ctx.ellipse(b.x + 8, b.y + 20, 36, 10, 0, 0, Math.PI * 2);\n    ctx.fillStyle = 'rgba(0,0,0,0.12)';\n    ctx.fill();\n\n    // main body\n    ctx.fillStyle = '#FFD24D';\n    drawRoundedRect(ctx, b.x - 30, b.y - 18, 60, 36, 8);\n    ctx.fill();\n    // top terminal\n    drawRoundedRect(ctx, b.x + 12, b.y - 10, 10, 20, 3);\n    ctx.fillStyle = '#E6E6E6';\n    ctx.fill();\n\n    // number label\n    ctx.fillStyle = '#073742';\n    ctx.font = 'bold 16px \"Segoe UI\", Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText('+' + b.value, b.x, b.y + 6);\n\n    // highlight for selected\n    if (!b.used && highlight) {\n      ctx.beginPath();\n      ctx.strokeStyle = 'rgba(255,255,255,0.7)';\n      ctx.lineWidth = 3;\n      ctx.arc(b.x, b.y, b.r + 6, 0, Math.PI * 2);\n      ctx.stroke();\n    }\n\n    // dim if used\n    if (b.used) {\n      ctx.globalAlpha = 0.4;\n    }\n\n    ctx.restore();\n  }\n\n  function drawCloud(cx, cy, size) {\n    ctx.save();\n    ctx.fillStyle = 'rgba(255,255,255,0.9)';\n    ctx.beginPath();\n    ctx.arc(cx, cy, size * 0.6, 0, Math.PI * 2);\n    ctx.arc(cx - size * 0.5, cy + 10, size * 0.42, 0, Math.PI * 2);\n    ctx.arc(cx + size * 0.45, cy + 5, size * 0.5, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function drawHeaderPanel() {\n    ctx.save();\n    // top bar\n    drawRoundedRect(ctx, 40, 18, WIDTH - 80, 62, 12);\n    const grd = ctx.createLinearGradient(40, 18, WIDTH - 40, 80);\n    grd.addColorStop(0, '#073742');\n    grd.addColorStop(1, '#0b8793');\n    ctx.fillStyle = grd;\n    ctx.fill();\n    // title and problem text\n    ctx.fillStyle = '#fff';\n    ctx.font = '20px \"Segoe UI\", Arial';\n    ctx.textAlign = 'left';\n    ctx.fillText('Spark Circuit', 64, 44);\n    ctx.font = '16px \"Segoe UI\", Arial';\n    ctx.fillText(`Round ${currentRound} / ${totalRounds}`, WIDTH - 170, 44);\n    // problem text\n    ctx.font = '18px \"Segoe UI\", Arial';\n    ctx.fillStyle = '#fff';\n    ctx.textAlign = 'center';\n    if (gamePhase === 'playing') {\n      ctx.fillText(`${givenAddend} + ? = ${roundTarget}`, WIDTH / 2, 69);\n    } else {\n      ctx.fillText('Click or press Space to begin', WIDTH / 2, 69);\n    }\n    ctx.restore();\n  }\n\n  function drawAudioIcon(rowY, colX) {\n    // draw simple speaker icon with visual cue if audio is available\n    const x = colX;\n    const y = rowY;\n    ctx.save();\n    ctx.translate(x, y);\n    // box\n    drawRoundedRect(ctx, -38, -28, 76, 56, 8);\n    ctx.fillStyle = 'rgba(255,255,255,0.9)';\n    ctx.fill();\n    // speaker\n    ctx.fillStyle = '#073742';\n    ctx.beginPath();\n    ctx.moveTo(-18, -8);\n    ctx.lineTo(-2, -18);\n    ctx.lineTo(-2, 18);\n    ctx.lineTo(-18, 8);\n    ctx.closePath();\n    ctx.fill();\n    // waves if audioAvailable\n    if (audioAvailable) {\n      ctx.strokeStyle = '#33aaff';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.arc(10, 0, 10, -Math.PI / 6, Math.PI / 6);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.arc(10, 0, 16, -Math.PI / 6, Math.PI / 6);\n      ctx.stroke();\n      ctx.font = '10px \"Segoe UI\", Arial';\n      ctx.fillStyle = '#073742';\n      ctx.textAlign = 'left';\n      ctx.fillText('Audio On', 18, 4);\n    } else {\n      // muted icon\n      ctx.strokeStyle = 'rgba(200,40,40,0.9)';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(4, -8);\n      ctx.lineTo(18, 8);\n      ctx.stroke();\n      ctx.font = '10px \"Segoe UI\", Arial';\n      ctx.fillStyle = '#073742';\n      ctx.textAlign = 'left';\n      ctx.fillText('Audio Unavailable', 18, 4);\n    }\n    ctx.restore();\n  }\n\n  // Main loop\n  function loop(ts) {\n    if (!lastTime) lastTime = ts;\n    const dt = (ts - lastTime) / 16.666; // scale relative to 60fps\n    lastTime = ts;\n    update(dt);\n    draw();\n    requestAnimationFrame(loop);\n  }\n\n  // Start animation\n  requestAnimationFrame(loop);\n\n  // Wire keyboard to container for accessibility\n  container.addEventListener('keydown', onKeyDown);\n  // Also listen globally for keyboard if canvas focused\n  window.addEventListener('keydown', function (e) {\n    // only handle if container is focused or canvas hovered\n    const active = document.activeElement === container || document.activeElement === canvas;\n    if (active) {\n      onKeyDown(e);\n    }\n  });\n\n  // Ensure initial state (intro)\n  gamePhase = 'intro';\n  message = 'Welcome! Click or press Space to start.';\n\n  // Expose minimal diagnostics on container for assistive tech (aria-live)\n  container.setAttribute('aria-live', 'polite');\n\n  // Fallback instructions in case audio fails\n  if (!audioAvailable) {\n    console.info('Audio is not available. The game will run silently.');\n  }\n})();\n---\n",
  "improve_response_tokens": 21523,
  "formatted_code": true,
  "formatting_response_tokens": 23408,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}