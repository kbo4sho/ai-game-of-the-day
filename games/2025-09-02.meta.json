{
  "generated_date": "2025-09-02",
  "generated_timestamp": "2025-09-02T00:26:51.854883",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9442,
  "game_filename": "2025-09-02.js",
  "game_size_bytes": 26055,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(() => {\n  // Machine Math \u2014 a calming, wacky math game for ages 7\u20139.\n  // Renders inside element with ID \"game-of-the-day-stage\".\n  // All visuals drawn on canvas. Sounds generated with Web Audio API.\n  // Written with modern JS practices, clear structure, and error handling.\n\n  // Config\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const STAGE_ID = \"game-of-the-day-stage\";\n  const MAX_LEVEL = 6;\n  const LIVES = 3;\n\n  // Grab stage element\n  const stage = document.getElementById(STAGE_ID);\n  if (!stage) {\n    console.error(`Missing container element with id \"${STAGE_ID}\"`);\n    return;\n  }\n  // Clear stage\n  stage.innerHTML = \"\";\n\n  // Create a visually hidden live region for screen readers (text alternatives)\n  const liveRegion = document.createElement(\"div\");\n  liveRegion.setAttribute(\"role\", \"status\");\n  liveRegion.setAttribute(\"aria-live\", \"polite\");\n  liveRegion.style.position = \"absolute\";\n  liveRegion.style.left = \"-9999px\";\n  liveRegion.style.width = \"1px\";\n  liveRegion.style.height = \"1px\";\n  stage.appendChild(liveRegion);\n\n  // Create canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.tabIndex = 0; // allow keyboard focus\n  canvas.style.outline = \"none\";\n  canvas.style.display = \"block\";\n  canvas.setAttribute(\"aria-label\", \"Machine Math. Use arrow keys to pick parts and Enter to feed the machine.\");\n  stage.appendChild(canvas);\n  const ctx = canvas.getContext(\"2d\");\n\n  // Accessibility: focus canvas so keyboard events work\n  canvas.focus();\n\n  // Audio setup\n  let audioCtx = null;\n  let masterGain = null;\n  let bgGainNode = null;\n  let isAudioAllowed = false;\n  let audioEnabled = true; // user can toggle\n  // Visual cue for audio: small icon drawn on canvas, and live updates.\n\n  // Try to create AudioContext with error handling\n  function createAudioContext() {\n    if (audioCtx) return audioCtx;\n    try {\n      // Some browsers require user gesture to start audio. Create but suspended.\n      const AC = window.AudioContext || window.webkitAudioContext;\n      audioCtx = new AC();\n      masterGain = audioCtx.createGain();\n      masterGain.connect(audioCtx.destination);\n      masterGain.gain.value = 0.95;\n      // background gentle hum\n      bgGainNode = audioCtx.createGain();\n      bgGainNode.gain.value = 0.02; // gentle\n      bgGainNode.connect(masterGain);\n    } catch (e) {\n      audioCtx = null;\n      console.warn(\"Web Audio not available:\", e);\n      liveAnnounce(\"Audio is not available in this browser.\");\n    }\n    return audioCtx;\n  }\n\n  // Call to ensure audio allowed (on user gesture)\n  async function tryResumeAudio() {\n    try {\n      createAudioContext();\n      if (audioCtx && audioCtx.state === \"suspended\") {\n        await audioCtx.resume();\n      }\n      isAudioAllowed = true;\n      liveAnnounce(\"Audio enabled.\");\n      startBackgroundHum();\n    } catch (e) {\n      console.warn(\"Audio resume failed\", e);\n      liveAnnounce(\"Unable to enable audio.\");\n    }\n  }\n\n  // Sound generators\n  function playClick() {\n    if (!audioCtx || !audioEnabled) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = \"sine\";\n      o.frequency.value = 880;\n      g.gain.value = 0.0001;\n      o.connect(g);\n      g.connect(masterGain);\n      const now = audioCtx.currentTime;\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(0.02, now + 0.02);\n      o.start(now);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.16);\n      o.stop(now + 0.18);\n    } catch (e) {\n      console.warn(\"playClick error\", e);\n    }\n  }\n\n  function playWrong() {\n    if (!audioCtx || !audioEnabled) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const f = audioCtx.createBiquadFilter();\n      const g = audioCtx.createGain();\n      o.type = \"sawtooth\";\n      o.frequency.value = 200;\n      f.type = \"lowpass\";\n      f.frequency.value = 1200;\n      o.connect(f);\n      f.connect(g);\n      g.connect(masterGain);\n      const now = audioCtx.currentTime;\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(0.08, now + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);\n      o.start(now);\n      o.stop(now + 0.62);\n    } catch (e) {\n      console.warn(\"playWrong error\", e);\n    }\n  }\n\n  function playSuccess() {\n    if (!audioCtx || !audioEnabled) return;\n    try {\n      const now = audioCtx.currentTime;\n      // Play a short major chord using three oscillators\n      const freqs = [660, 830, 990]; // harmonically pleasing\n      const gains = freqs.map(() => audioCtx.createGain());\n      const oscs = freqs.map((f, i) => {\n        const o = audioCtx.createOscillator();\n        o.type = i === 1 ? \"triangle\" : \"sine\";\n        o.frequency.value = f;\n        o.connect(gains[i]);\n        gains[i].connect(masterGain);\n        gains[i].gain.setValueAtTime(0.0001, now);\n        gains[i].gain.exponentialRampToValueAtTime(0.04, now + 0.02);\n        gains[i].gain.exponentialRampToValueAtTime(0.0001, now + 0.7);\n        o.start(now);\n        o.stop(now + 0.72);\n        return o;\n      });\n    } catch (e) {\n      console.warn(\"playSuccess error\", e);\n    }\n  }\n\n  function startBackgroundHum() {\n    if (!audioCtx || !audioEnabled) return;\n    try {\n      // A subtle drifting oscillator for calming machine hum\n      const o = audioCtx.createOscillator();\n      const lfo = audioCtx.createOscillator();\n      const lfoGain = audioCtx.createGain();\n      const g = bgGainNode || audioCtx.createGain();\n      if (!bgGainNode) {\n        bgGainNode = g;\n        bgGainNode.connect(masterGain);\n      }\n      o.type = \"sine\";\n      o.frequency.value = 90;\n      lfo.type = \"sine\";\n      lfo.frequency.value = 0.08;\n      lfoGain.gain.value = 10;\n      lfo.connect(lfoGain);\n      lfoGain.connect(o.frequency);\n      o.connect(g);\n      g.gain.value = 0.02;\n      try {\n        o.start();\n        lfo.start();\n      } catch (e) {\n        // ignore already started\n      }\n      // keep references so the oscillator doesn't get GC'd\n      bgHumOsc = { o, lfo, g };\n    } catch (e) {\n      console.warn(\"startBackgroundHum error\", e);\n    }\n  }\n  let bgHumOsc = null;\n\n  function stopBackgroundHum() {\n    try {\n      if (bgHumOsc) {\n        // No built-in stop for lfo later? We can disconnect instead.\n        bgHumOsc.o.disconnect();\n        bgHumOsc.lfo.disconnect();\n        bgHumOsc.g.disconnect();\n        bgHumOsc = null;\n      }\n    } catch (e) {\n      console.warn(\"stopBackgroundHum error\", e);\n    }\n  }\n\n  // Utility: announce to screen reader\n  function liveAnnounce(text) {\n    liveRegion.innerText = text;\n  }\n\n  // Game state\n  const state = {\n    level: 1,\n    lives: LIVES,\n    target: 10,\n    currentSum: 0,\n    parts: [], // array of {value, id, x, y, picked}\n    selectorIndex: 0,\n    animParticles: [],\n    gameOver: false,\n    levelComplete: false,\n    paused: false,\n    ticks: 0,\n    audioOn: true,\n  };\n\n  // Create parts such that there is at least one exact combination\n  function generateLevel(level) {\n    state.currentSum = 0;\n    state.level = level;\n    state.lives = state.lives; // unchanged\n    state.gameOver = false;\n    state.levelComplete = false;\n    state.ticks = 0;\n    // Target increases with level\n    const base = 5 + level * 2; // 7,9,11...\n    const target = base + Math.floor(Math.random() * 6); // up to +5\n    state.target = Math.max(5, Math.min(20, target));\n    // Create a solvable combination: pick 2-3 numbers that sum to target\n    const comboLen = Math.random() < 0.5 ? 2 : 3;\n    const combo = [];\n    let rem = state.target;\n    for (let i = comboLen - 1; i >= 0; i--) {\n      const maxVal = Math.max(1, rem - i); // ensure at least 1 per remaining\n      const val = Math.floor(Math.random() * Math.min(6 + level, maxVal)) + 1;\n      combo.push(val);\n      rem -= val;\n    }\n    // If leftover, add to first\n    if (rem > 0) combo[0] += rem;\n\n    // Build parts: include combo numbers and distractors\n    const parts = [];\n    let idCounter = 0;\n    // Add combo parts\n    for (const v of combo) {\n      parts.push({ value: v, id: idCounter++, picked: false });\n    }\n    // Add distractors (to total 5)\n    while (parts.length < 5) {\n      const v = Math.floor(Math.random() * (6 + level)) + 1;\n      // avoid making another trivial duplicate that makes many solutions; allow duplicates sometimes\n      parts.push({ value: v, id: idCounter++, picked: false });\n    }\n    // Shuffle parts\n    for (let i = parts.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [parts[i], parts[j]] = [parts[j], parts[i]];\n    }\n    // Assign positions for conveyor and floating animation properties\n    const startY = HEIGHT - 120;\n    const spacing = 120;\n    const startX = WIDTH / 2 - (parts.length - 1) * spacing / 2;\n    parts.forEach((p, i) => {\n      p.x = startX + i * spacing;\n      p.y = startY + Math.sin(i) * 6;\n      p.offset = 0;\n      p.faceOffset = Math.random() * Math.PI * 2;\n    });\n\n    state.parts = parts;\n    state.selectorIndex = 0;\n    liveAnnounce(`Level ${state.level}. Target ${state.target}. You have ${state.lives} lives.`);\n  }\n\n  // Draw utilities (calming pastel palette)\n  const palette = {\n    sky: \"#EAF6FF\",\n    machine: \"#9AD3DE\",\n    accent: \"#FFB6C1\",\n    metal: \"#C6C8CA\",\n    bolt: \"#FFD27F\",\n    text: \"#1B2430\",\n    cloud: \"#FFFFFF\",\n    shadow: \"rgba(27,36,48,0.12)\",\n  };\n\n  function drawRoundedRect(x, y, w, h, r, fillStyle, strokeStyle) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fillStyle) {\n      ctx.fillStyle = fillStyle;\n      ctx.fill();\n    }\n    if (strokeStyle) {\n      ctx.strokeStyle = strokeStyle;\n      ctx.stroke();\n    }\n  }\n\n  // Draw machine, conveyor, parts, selector, UI\n  function render() {\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    // Background sky\n    ctx.fillStyle = palette.sky;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Soft hills\n    ctx.fillStyle = \"#DFF3E8\";\n    ctx.beginPath();\n    ctx.ellipse(140, 420, 180, 70, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.ellipse(540, 440, 200, 90, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Clouds (wacky)\n    drawCloud(120, 80, 100, 50, 0.9);\n    drawCloud(480, 60, 140, 60, 0.8);\n    drawCloud(320, 120, 120, 50, 0.85);\n\n    // Machine body\n    drawMachine();\n\n    // Conveyor belt\n    drawConveyor();\n\n    // Parts on conveyor\n    for (let i = 0; i < state.parts.length; i++) {\n      drawPart(state.parts[i], i === state.selectorIndex);\n    }\n\n    // Machine display with target and current sum\n    drawDisplay();\n\n    // Lives and level\n    drawHUD();\n\n    // Visual audio icon\n    drawAudioIcon(650, 16);\n\n    // Tooltip / instructions small\n    ctx.fillStyle = palette.text;\n    ctx.font = \"14px Arial\";\n    ctx.fillText(\"Controls: \u2190 \u2192 to move \u2022 Enter / Space to feed \u2022 1-5 to pick \u2022 M to mute \u2022 R to restart\", 14, HEIGHT - 12);\n\n    // Particle animations\n    renderParticles();\n\n    // If paused overlay\n    if (state.paused) {\n      ctx.fillStyle = \"rgba(20,20,30,0.5)\";\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n      ctx.fillStyle = \"#FFF\";\n      ctx.font = \"28px Arial\";\n      ctx.fillText(\"Paused\", WIDTH / 2 - 40, HEIGHT / 2 - 10);\n    }\n\n    // If level complete overlay\n    if (state.levelComplete) {\n      ctx.fillStyle = \"rgba(255,255,255,0.9)\";\n      drawRoundedRect(WIDTH / 2 - 180, HEIGHT / 2 - 90, 360, 180, 14, \"rgba(255,255,255,0.98)\", palette.shadow);\n      ctx.fillStyle = \"#223\";\n      ctx.font = \"24px Arial\";\n      ctx.fillText(`Level ${state.level} Complete!`, WIDTH / 2 - 120, HEIGHT / 2 - 20);\n      ctx.font = \"18px Arial\";\n      ctx.fillText(\"Press Enter to continue\", WIDTH / 2 - 110, HEIGHT / 2 + 20);\n    }\n\n    if (state.gameOver) {\n      ctx.fillStyle = \"rgba(0,0,0,0.55)\";\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n      ctx.fillStyle = \"#FFF\";\n      ctx.font = \"28px Arial\";\n      ctx.fillText(\"Game Over\", WIDTH / 2 - 80, HEIGHT / 2 - 20);\n      ctx.font = \"18px Arial\";\n      ctx.fillText(\"Press R to try again.\", WIDTH / 2 - 90, HEIGHT / 2 + 20);\n    }\n  }\n\n  function drawCloud(x, y, w, h, alpha) {\n    ctx.save();\n    ctx.globalAlpha = alpha;\n    ctx.fillStyle = palette.cloud;\n    ctx.beginPath();\n    ctx.ellipse(x, y, w * 0.5, h * 0.5, 0, 0, Math.PI * 2);\n    ctx.ellipse(x + w * 0.3, y - 10, w * 0.3, h * 0.35, 0, 0, Math.PI * 2);\n    ctx.ellipse(x - w * 0.35, y - 8, w * 0.28, h * 0.32, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function drawMachine() {\n    // Body\n    drawRoundedRect(120, 80, 480, 220, 18, palette.machine, palette.shadow);\n    // Front panel\n    drawRoundedRect(160, 140, 400, 120, 12, palette.metal, null);\n    // Gears (wacky)\n    drawGear(200, 190, 36, 8, \"#E6A6FF\", 0.03 * state.ticks);\n    drawGear(330, 170, 50, 10, \"#BFD8FF\", -0.02 * state.ticks);\n    drawGear(470, 200, 28, 6, \"#FFD7A6\", 0.05 * state.ticks);\n    // Pipe and nozzle\n    ctx.fillStyle = \"#9BB3A9\";\n    ctx.fillRect(520, 170, 90, 18);\n    ctx.beginPath();\n    ctx.moveTo(610, 170);\n    ctx.lineTo(640, 150);\n    ctx.lineTo(640, 188);\n    ctx.closePath();\n    ctx.fill();\n    // Steam puffs near top-right\n    for (let i = 0; i < 3; i++) {\n      const a = Math.sin((state.ticks / 60) + i) * 6;\n      ctx.globalAlpha = 0.45;\n      ctx.fillStyle = \"#FFF\";\n      ctx.beginPath();\n      ctx.ellipse(540 + i * 18, 90 - (state.ticks % 40) * 0.5 - a, 18, 10, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.globalAlpha = 1;\n    }\n  }\n\n  function drawGear(cx, cy, r, teeth, color, rotation) {\n    ctx.save();\n    ctx.translate(cx, cy);\n    ctx.rotate(rotation || 0);\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    for (let i = 0; i < teeth * 2; i++) {\n      const angle = (i / (teeth * 2)) * Math.PI * 2;\n      const rad = i % 2 === 0 ? r : r * 0.74;\n      ctx.lineTo(Math.cos(angle) * rad, Math.sin(angle) * rad);\n    }\n    ctx.closePath();\n    ctx.fill();\n    ctx.fillStyle = \"rgba(255,255,255,0.2)\";\n    ctx.beginPath();\n    ctx.arc(0, 0, r * 0.4, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function drawConveyor() {\n    // Belt\n    const beltY = HEIGHT - 140;\n    ctx.fillStyle = \"#6C6F70\"; // dark belt\n    drawRoundedRect(40, beltY - 24, WIDTH - 80, 48, 12, \"#6C6F70\");\n    // Little teeth pattern\n    ctx.fillStyle = \"#4B4D4E\";\n    for (let i = 0; i < 16; i++) {\n      ctx.fillRect(60 + i * 40, beltY - 10, 18, 20);\n    }\n    // Machine receiving tray\n    drawRoundedRect(560, beltY - 64, 120, 64, 10, \"#DDEBF2\");\n  }\n\n  function drawPart(part, isSelected) {\n    // Floating wobble\n    part.offset += 0.03;\n    const bob = Math.sin(part.offset + part.faceOffset) * 6;\n    const x = part.x;\n    const y = part.y + bob;\n    // Shadow\n    ctx.fillStyle = \"rgba(0,0,0,0.08)\";\n    ctx.beginPath();\n    ctx.ellipse(x, y + 36, 36, 12, 0, 0, Math.PI * 2);\n    ctx.fill();\n    // Body\n    drawRoundedRect(x - 36, y - 28, 72, 56, 12, palette.bolt);\n    // Funny face: eyes and mouth\n    ctx.fillStyle = \"#3b3b3b\";\n    ctx.beginPath();\n    ctx.arc(x - 12, y - 6, 4, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(x + 12, y - 6, 4, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = \"#3b3b3b\";\n    ctx.beginPath();\n    ctx.moveTo(x - 8, y + 6);\n    ctx.quadraticCurveTo(x, y + 12, x + 8, y + 6);\n    ctx.stroke();\n    // Value text\n    ctx.fillStyle = palette.text;\n    ctx.font = \"20px Arial\";\n    ctx.fillText(String(part.value), x - 6, y + 6);\n    // selection ring\n    if (isSelected && !part.picked) {\n      ctx.strokeStyle = \"#3B82F6\";\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.arc(x, y, 48, 0, Math.PI * 2);\n      ctx.stroke();\n      ctx.lineWidth = 1;\n    }\n\n    // If picked, animate toward machine\n    if (part.picked) {\n      // Particle puff\n      createParticles(x, y, 6, palette.accent);\n    }\n  }\n\n  // Simple particle system for visual feedback\n  function createParticles(x, y, n, color) {\n    for (let i = 0; i < n; i++) {\n      state.animParticles.push({\n        x,\n        y,\n        vx: (Math.random() - 0.5) * 2,\n        vy: -Math.random() * 2 - 0.5,\n        life: 40 + Math.random() * 20,\n        color,\n      });\n    }\n  }\n  function renderParticles() {\n    for (let i = state.animParticles.length - 1; i >= 0; i--) {\n      const p = state.animParticles[i];\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy += 0.06;\n      p.life--;\n      if (p.life <= 0) {\n        state.animParticles.splice(i, 1);\n        continue;\n      }\n      ctx.globalAlpha = Math.max(0, p.life / 80);\n      ctx.fillStyle = p.color;\n      ctx.beginPath();\n      ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.globalAlpha = 1;\n    }\n  }\n\n  function drawDisplay() {\n    // Screen on machine\n    const sx = 210;\n    const sy = 110;\n    const sw = 300;\n    const sh = 80;\n    drawRoundedRect(sx, sy, sw, sh, 8, \"#071A2B\");\n    // Target and sum\n    ctx.fillStyle = \"#A6F0C3\";\n    ctx.font = \"26px Arial\";\n    ctx.fillText(\"TARGET:\", sx + 18, sy + 30);\n    ctx.fillStyle = \"#FFF\";\n    ctx.font = \"bold 34px Arial\";\n    ctx.fillText(String(state.target), sx + 150, sy + 30);\n    ctx.fillStyle = \"#FFD9A6\";\n    ctx.font = \"22px Arial\";\n    ctx.fillText(\"SUM:\", sx + 18, sy + 64);\n    ctx.fillStyle = \"#FFF\";\n    ctx.font = \"24px Arial\";\n    ctx.fillText(String(state.currentSum), sx + 150, sy + 64);\n\n    // Visual meter showing progress\n    const meterX = sx + sw + 10;\n    const meterY = sy + 12;\n    const meterW = 32;\n    const meterH = sh - 24;\n    ctx.fillStyle = \"#2B8F74\";\n    ctx.fillRect(meterX, meterY + (meterH * (1 - Math.min(1, state.currentSum / state.target))), meterW, meterH * Math.min(1, state.currentSum / state.target));\n    ctx.strokeStyle = \"#FFF3\";\n    ctx.strokeRect(meterX, meterY, meterW, meterH);\n  }\n\n  function drawHUD() {\n    // Lives hearts\n    const heartX = 18;\n    const heartY = 18;\n    for (let i = 0; i < LIVES; i++) {\n      drawHeart(heartX + i * 28, heartY, i < state.lives ? \"#FF6B6B\" : \"#F0CFCF\");\n    }\n    // Level\n    ctx.fillStyle = palette.text;\n    ctx.font = \"18px Arial\";\n    ctx.fillText(`Level ${state.level} / ${MAX_LEVEL}`, 110, 32);\n  }\n\n  function drawHeart(x, y, color) {\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(x, y + 4);\n    ctx.bezierCurveTo(x, y - 6, x + 18, y - 6, x + 18, y + 4);\n    ctx.bezierCurveTo(x + 18, y + 22, x + 9, y + 28, x, y + 36);\n    ctx.bezierCurveTo(x - 9, y + 28, x - 18, y + 22, x - 18, y + 4);\n    ctx.bezierCurveTo(x - 18, y - 6, x - 9, y - 6, x, y + 4);\n    ctx.fill();\n  }\n\n  function drawAudioIcon(x, y) {\n    ctx.save();\n    ctx.translate(x, y);\n    // Speaker\n    ctx.fillStyle = audioEnabled ? \"#333\" : \"#AAA\";\n    ctx.beginPath();\n    ctx.moveTo(0, 8);\n    ctx.lineTo(0, -8);\n    ctx.lineTo(10, -8);\n    ctx.lineTo(18, -16);\n    ctx.lineTo(18, 16);\n    ctx.lineTo(10, 8);\n    ctx.closePath();\n    ctx.fill();\n    // Bars (visual cue)\n    if (audioEnabled) {\n      const barCount = 3;\n      for (let i = 0; i < barCount; i++) {\n        const h = 6 + Math.abs(Math.sin((state.ticks / 40) + i)) * 12;\n        ctx.fillRect(22 + i * 8, -h / 2, 6, h);\n      }\n    } else {\n      // muted X\n      ctx.strokeStyle = \"#FAFAFA\";\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(22, -14);\n      ctx.lineTo(38, 4);\n      ctx.moveTo(22, 4);\n      ctx.lineTo(38, -14);\n      ctx.stroke();\n      ctx.lineWidth = 1;\n    }\n    ctx.restore();\n  }\n\n  // Input handling\n  function onKeyDown(e) {\n    // ensure audio can start on first user gesture\n    tryResumeAudio();\n    if (state.gameOver) {\n      if (e.key === \"r\" || e.key === \"R\") {\n        restartGame();\n      }\n      return;\n    }\n    if (state.levelComplete) {\n      if (e.key === \"Enter\" || e.key === \" \") {\n        nextLevel();\n      }\n      return;\n    }\n    if (e.key === \"m\" || e.key === \"M\") {\n      toggleAudio();\n      return;\n    }\n    if (e.key === \"p\" || e.key === \"P\") {\n      state.paused = !state.paused;\n      liveAnnounce(state.paused ? \"Game paused\" : \"Game resumed\");\n      return;\n    }\n    if (state.paused) return;\n\n    if (e.key === \"ArrowLeft\") {\n      state.selectorIndex = Math.max(0, state.selectorIndex - 1);\n      playClick();\n    } else if (e.key === \"ArrowRight\") {\n      state.selectorIndex = Math.min(state.parts.length - 1, state.selectorIndex + 1);\n      playClick();\n    } else if (e.key === \"Enter\" || e.key === \" \") {\n      pickPart(state.selectorIndex);\n    } else if (/^[1-5]$/.test(e.key)) {\n      const idx = parseInt(e.key, 10) - 1;\n      if (idx >= 0 && idx < state.parts.length) {\n        state.selectorIndex = idx;\n        pickPart(idx);\n      }\n    } else if (e.key === \"r\" || e.key === \"R\") {\n      restartGame();\n    }\n  }\n\n  // Mouse click handling for picking parts and audio icon\n  function onMouseDown(e) {\n    tryResumeAudio();\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    // Check audio icon area\n    if (mx >= 650 && my <= 40) {\n      toggleAudio();\n      return;\n    }\n    // If clicking on part area, pick nearest part\n    let nearestIdx = -1;\n    let nearestDist = 1e9;\n    for (let i = 0; i < state.parts.length; i++) {\n      const p = state.parts[i];\n      const dx = mx - p.x;\n      const dy = my - p.y;\n      const d = Math.sqrt(dx * dx + dy * dy);\n      if (d < nearestDist && d < 60) {\n        nearestDist = d;\n        nearestIdx = i;\n      }\n    }\n    if (nearestIdx >= 0) {\n      state.selectorIndex = nearestIdx;\n      pickPart(nearestIdx);\n    }\n  }\n\n  function toggleAudio() {\n    audioEnabled = !audioEnabled;\n    if (audioEnabled) {\n      liveAnnounce(\"Audio on. Press M to mute.\");\n      startBackgroundHum();\n      tryResumeAudio();\n    } else {\n      liveAnnounce(\"Audio muted. Press M to unmute.\");\n      stopBackgroundHum();\n    }\n  }\n\n  // Picking a part: add value to sum, animate and check results\n  function pickPart(index) {\n    if (state.paused || state.levelComplete || state.gameOver) return;\n    const part = state.parts[index];\n    if (!part || part.picked) {\n      // nothing happens\n      playWrong();\n      return;\n    }\n    // Mark picked\n    part.picked = true;\n    playClick();\n\n    // Animate movement toward machine (we will update currentSum immediately and animate particles)\n    state.currentSum += part.value;\n    createParticles(part.x, part.y - 10, 8, palette.accent);\n\n    // Check for match or over\n    if (state.currentSum === state.target) {\n      // Level success\n      playSuccess();\n      state.levelComplete = true;\n      liveAnnounce(`Great! You matched the target ${state.target}. Press Enter to continue.`);\n      // small celebratory particles\n      createParticles(WIDTH / 2, HEIGHT / 2 - 40, 30, \"#A6F0C3\");\n    } else if (state.currentSum > state.target) {\n      // Wrong, reduce a life and reset currentSum to 0 and un-pick some parts\n      playWrong();\n      state.lives--;\n      liveAnnounce(`Too much! You exceeded ${state.target}. Lives left: ${state.lives}.`);\n      // Create big puff\n      createParticles(WIDTH / 2, HEIGHT / 2, 40, \"#FFB6C1\");\n      if (state.lives <= 0) {\n        state.gameOver = true;\n        liveAnnounce(\"Game over. Press R to try again.\");\n      } else {\n        // Reset: unpick all parts and currentSum back to 0\n        setTimeout(() => {\n          state.parts.forEach((p) => (p.picked = false));\n          state.currentSum = 0;\n        }, 700);\n      }\n    } else {\n      // Still below target \u2014 continue\n      liveAnnounce(`Added ${part.value}. Current sum ${state.currentSum}.`);\n    }\n  }\n\n  function nextLevel() {\n    if (state.level >= MAX_LEVEL) {\n      liveAnnounce(\"You finished all levels! Well done!\");\n      // Victory screen: reset or let user restart\n      state.gameOver = true;\n      return;\n    }\n    state.level++;\n    if (state.level > MAX_LEVEL) state.level = MAX_LEVEL;\n    // Keep lives (but not exceed)\n    generateLevel(state.level);\n  }\n\n  function restartGame() {\n    state.level = 1;\n    state.lives = LIVES;\n    state.gameOver = false;\n    state.levelComplete = false;\n    state.currentSum = 0;\n    generateLevel(1);\n  }\n\n  // Animation loop\n  function tick() {\n    state.ticks++;\n    // Small automatic conveyor motion: shift x slightly as if moving\n    for (let i = 0; i < state.parts.length; i++) {\n      const p = state.parts[i];\n      p.x += Math.sin((state.ticks + i * 10) / 40) * 0.2;\n    }\n    render();\n    requestAnimationFrame(tick);\n  }\n\n  // Initialize interactions\n  canvas.addEventListener(\"keydown\", onKeyDown);\n  window.addEventListener(\"keydown\", (e) => {\n    // let canvas handle keys when focused; also global for convenience\n    if (document.activeElement !== canvas) {\n      // resume audio on any first keypress\n      tryResumeAudio();\n    }\n    onKeyDown(e);\n  });\n  canvas.addEventListener(\"mousedown\", (e) => onMouseDown(e));\n  canvas.addEventListener(\"touchstart\", (e) => {\n    tryResumeAudio();\n    const touch = e.touches[0];\n    if (touch) {\n      // synthesize mouse down\n      onMouseDown({ clientX: touch.clientX, clientY: touch.clientY });\n    }\n    e.preventDefault();\n  }, { passive: false });\n\n  // Initialize game and audio handling\n  generateLevel(1);\n  // Ensure audio tries to start on user gesture (click or keydown)\n  canvas.addEventListener(\"pointerdown\", tryResumeAudio, { once: true });\n  window.addEventListener(\"keydown\", tryResumeAudio, { once: true });\n\n  // Start background hum only if audio allowed after user gesture\n  // We'll attempt to create audio context immediately but will remain suspended until gesture.\n  createAudioContext();\n\n  // Provide initial live instruction\n  liveAnnounce(\"Welcome to Machine Math. Use arrow keys to select parts and Enter to feed the machine. Press M to mute. Click or press any key to enable sound.\");\n\n  // Start main loop\n  tick();\n\n  // Expose for debugging (non-intrusive)\n  window.__machineMathState = state;\n})();\n---\n",
  "improve_response_tokens": 19683,
  "formatted_code": true,
  "formatting_response_tokens": 20585,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}