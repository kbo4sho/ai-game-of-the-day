{
  "generated_date": "2025-11-18",
  "generated_timestamp": "2025-11-18T00:28:20.679873",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9017,
  "game_filename": "2025-11-18.js",
  "game_size_bytes": 26779,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Drone Math Adventure\n  // Designed for children ages 7-9.\n  // The game is rendered inside the element with id \"game-of-the-day-stage\".\n  // Goal: Answer 10 questions correctly to collect 10 drone batteries (WIN).\n  // Lose: 3 wrong answers (GAME OVER).\n  // Controls: Click answer boxes or press keys 1-4. Press R to restart. Press M to mute/unmute.\n  // Audio: Uses Web Audio API oscillators. Graceful fallback if audio unavailable.\n\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const GOAL = 10;\n  const MAX_WRONG = 3;\n  const ANSWER_COUNT = 4;\n  const PADDING = 12; // min 10px required\n\n  // Get stage element\n  const stage = document.getElementById('game-of-the-day-stage');\n  if (!stage) {\n    console.error('Cannot find element with id \"game-of-the-day-stage\". Game will not start.');\n    return;\n  }\n\n  // Clean up existing children\n  stage.innerHTML = '';\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.tabIndex = 0; // make focusable for keyboard controls\n  canvas.setAttribute('role', 'application');\n  canvas.setAttribute('aria-label', 'Drone math game. Answer math questions by clicking or pressing keys 1 to 4. Press M to toggle sound, R to restart.');\n  stage.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Audio context creation with error handling\n  let audioCtx = null;\n  let audioAllowed = true;\n  try {\n    const AudioContext = window.AudioContext || window.webkitAudioContext;\n    if (!AudioContext) throw new Error('Web Audio API not supported');\n    audioCtx = new AudioContext();\n    // Some browsers require resume on user gesture; we will attempt to resume on first interaction.\n    audioCtx.suspend();\n  } catch (e) {\n    audioCtx = null;\n    audioAllowed = false;\n    console.warn('Audio unavailable:', e);\n  }\n\n  // Sound manager using oscillators and gain nodes\n  const Sound = {\n    masterGain: null,\n    backgroundOsc: null,\n    backgroundGain: null,\n    enabled: true,\n    init() {\n      if (!audioCtx) return;\n      try {\n        this.masterGain = audioCtx.createGain();\n        this.masterGain.gain.value = 0.7; // overall volume\n        this.masterGain.connect(audioCtx.destination);\n\n        // Gentle hum background\n        this.backgroundOsc = audioCtx.createOscillator();\n        this.backgroundGain = audioCtx.createGain();\n        this.backgroundOsc.type = 'sine';\n        this.backgroundOsc.frequency.value = 60; // low hum\n        this.backgroundGain.gain.value = 0.02; // subtle\n        this.backgroundOsc.connect(this.backgroundGain);\n        this.backgroundGain.connect(this.masterGain);\n        this.backgroundOsc.start();\n      } catch (e) {\n        console.error('Error initializing audio nodes:', e);\n        audioAllowed = false;\n      }\n    },\n    resumeIfNeeded() {\n      if (!audioCtx || audioCtx.state === 'running') return Promise.resolve();\n      try {\n        return audioCtx.resume().catch((e) => {\n          console.warn('Audio resume failed:', e);\n        });\n      } catch (e) {\n        console.warn('Audio resume error:', e);\n      }\n    },\n    playCorrect() {\n      if (!audioAllowed || !this.enabled || !audioCtx) return;\n      try {\n        const osc = audioCtx.createOscillator();\n        const gain = audioCtx.createGain();\n        const filter = audioCtx.createBiquadFilter();\n        osc.type = 'triangle';\n        osc.frequency.setValueAtTime(880, audioCtx.currentTime);\n        osc.frequency.exponentialRampToValueAtTime(1320, audioCtx.currentTime + 0.12);\n        gain.gain.setValueAtTime(0.0001, audioCtx.currentTime);\n        gain.gain.exponentialRampToValueAtTime(0.18, audioCtx.currentTime + 0.02);\n        gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.4);\n        filter.type = 'lowpass';\n        filter.frequency.value = 3000;\n        osc.connect(filter);\n        filter.connect(gain);\n        gain.connect(this.masterGain);\n        osc.start();\n        osc.stop(audioCtx.currentTime + 0.45);\n      } catch (e) {\n        console.warn('playCorrect error:', e);\n      }\n    },\n    playIncorrect() {\n      if (!audioAllowed || !this.enabled || !audioCtx) return;\n      try {\n        const osc = audioCtx.createOscillator();\n        const gain = audioCtx.createGain();\n        osc.type = 'sawtooth';\n        osc.frequency.setValueAtTime(220, audioCtx.currentTime);\n        osc.frequency.exponentialRampToValueAtTime(110, audioCtx.currentTime + 0.2);\n        gain.gain.setValueAtTime(0.0001, audioCtx.currentTime);\n        gain.gain.exponentialRampToValueAtTime(0.2, audioCtx.currentTime + 0.01);\n        gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.6);\n        osc.connect(gain);\n        gain.connect(this.masterGain);\n        osc.start();\n        osc.stop(audioCtx.currentTime + 0.6);\n      } catch (e) {\n        console.warn('playIncorrect error:', e);\n      }\n    },\n    clickTone() {\n      if (!audioAllowed || !this.enabled || !audioCtx) return;\n      try {\n        const osc = audioCtx.createOscillator();\n        const gain = audioCtx.createGain();\n        osc.type = 'square';\n        osc.frequency.value = 660;\n        gain.gain.value = 0.05;\n        osc.connect(gain);\n        gain.connect(this.masterGain);\n        osc.start();\n        setTimeout(() => {\n          try {\n            osc.stop();\n          } catch (e) {}\n        }, 80);\n      } catch (e) {\n        console.warn('clickTone error:', e);\n      }\n    },\n    toggle() {\n      this.enabled = !this.enabled;\n    }\n  };\n\n  if (audioAllowed) Sound.init();\n\n  // Game state\n  let score = 0;\n  let wrongs = 0;\n  let question = null;\n  let choices = [];\n  let gameState = 'start'; // start, playing, win, gameover\n  let droneX = 80;\n  let droneY = HEIGHT / 2;\n  let bobOffset = 0;\n  let hoverTime = 0;\n  let lastAnswerTime = 0;\n  let flashy = 0;\n  let muteVisualFlash = 0;\n  let audioUnavailable = !audioAllowed;\n\n  // Buttons for answers\n  const buttons = []; // each: {x,y,w,h,label,index}\n\n  // Colors\n  const palette = {\n    sky: '#cfeffd',\n    cloud: '#f7ffff',\n    drone: '#ff9b85',\n    prop: '#5b9bd5',\n    accent: '#ffdf6b',\n    text: '#09314f',\n    button: '#8ce7b0',\n    wrong: '#ff7b7b',\n    win: '#88e18a',\n    board: '#eaf6ff'\n  };\n\n  // Fonts\n  const fonts = {\n    title: '22px sans-serif',\n    body: '16px sans-serif',\n    big: '28px sans-serif',\n    button: '18px sans-serif'\n  };\n\n  // Utility: measure text and draw background rectangle\n  function drawTextBox(text, x, y, font, padding = PADDING, align = 'left', fillStyle = palette.text, bg = palette.board) {\n    ctx.font = font;\n    const metrics = ctx.measureText(text);\n    const textW = metrics.width;\n    let drawX = x;\n    if (align === 'center') drawX = x - textW / 2;\n    else if (align === 'right') drawX = x - textW;\n    const boxX = drawX - padding;\n    const boxY = y - parseInt(font, 10) - padding / 2;\n    const boxW = textW + padding * 2;\n    const boxH = parseInt(font, 10) + padding;\n    // background\n    roundRect(ctx, boxX, boxY, boxW, boxH, 6, bg);\n    // text\n    ctx.fillStyle = fillStyle;\n    ctx.fillText(text, drawX, y);\n    return { boxX, boxY, boxW, boxH, textW };\n  }\n\n  // Round rect helper\n  function roundRect(ctx, x, y, w, h, r, color) {\n    ctx.save();\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n    ctx.restore();\n  }\n\n  // Generate question based on current progress\n  function generateQuestion() {\n    // For ages 7-9: use addition and subtraction within 0-20, maybe small multiplication later\n    const level = Math.min(5, Math.floor(score / 2) + 1);\n    const typeRoll = Math.random();\n    let a, b, op, answer;\n    if (typeRoll < 0.6) {\n      op = Math.random() < 0.5 ? '+' : '-';\n      if (op === '+') {\n        a = randInt(1, 15);\n        b = randInt(1, Math.max(4, 16 - a));\n        answer = a + b;\n      } else {\n        a = randInt(1, 20);\n        b = randInt(1, Math.min(a, 12));\n        answer = a - b;\n      }\n    } else {\n      // small multiplication occasionally\n      op = 'x';\n      a = randInt(2, Math.min(6, level + 3));\n      b = randInt(2, Math.min(6, level + 2));\n      answer = a * b;\n    }\n\n    // Create choices with one correct and three distractors\n    const correct = answer;\n    const choiceSet = new Set([correct]);\n    while (choiceSet.size < ANSWER_COUNT) {\n      let perturb;\n      if (Math.random() < 0.6) {\n        perturb = correct + randInt(-5, 6);\n      } else {\n        perturb = correct + randInt(-10, 11);\n      }\n      if (op === 'x') {\n        // ensure positive\n        if (perturb <= 0) perturb = Math.abs(perturb) + 2;\n      } else {\n        if (perturb < 0) perturb = Math.abs(perturb);\n      }\n      choiceSet.add(perturb);\n    }\n    const arr = shuffle(Array.from(choiceSet));\n    return {\n      text: `${a} ${op} ${b} = ?`,\n      correctIndex: arr.indexOf(correct),\n      choices: arr\n    };\n  }\n\n  // Helpers\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n  function shuffle(arr) {\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    return arr;\n  }\n\n  // UI layout ensures no overlap: reserve top area for score/lives, center for play, bottom for instructions\n  function layoutButtons() {\n    buttons.length = 0;\n    const areaY = 240; // center\n    const totalWidth = WIDTH - PADDING * 4;\n    const btnW = Math.min(240, Math.floor((totalWidth - (ANSWER_COUNT - 1) * PADDING) / ANSWER_COUNT));\n    const btnH = 56;\n    const startX = (WIDTH - (btnW * ANSWER_COUNT + PADDING * (ANSWER_COUNT - 1))) / 2;\n    for (let i = 0; i < ANSWER_COUNT; i++) {\n      const x = startX + i * (btnW + PADDING);\n      const y = areaY;\n      buttons.push({ x, y, w: btnW, h: btnH, label: '', index: i });\n    }\n  }\n\n  layoutButtons();\n\n  // Input handling\n  canvas.addEventListener('click', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = (e.clientX - rect.left) * (canvas.width / rect.width);\n    const y = (e.clientY - rect.top) * (canvas.height / rect.height);\n    handleClick(x, y);\n  });\n\n  canvas.addEventListener('keydown', (e) => {\n    if (e.key === 'm' || e.key === 'M') {\n      Sound.toggle();\n      muteVisualFlash = 12;\n      Sound.clickTone();\n    } else if (e.key === 'r' || e.key === 'R') {\n      if (gameState === 'win' || gameState === 'gameover' || gameState === 'start') {\n        restartGame();\n      }\n    } else if (['1', '2', '3', '4'].includes(e.key)) {\n      const idx = parseInt(e.key, 10) - 1;\n      if (gameState === 'playing') selectAnswer(idx);\n    } else if (e.key === 'Enter') {\n      if (gameState === 'start') {\n        startGame();\n      }\n    }\n  });\n\n  canvas.addEventListener('focus', () => {\n    // resume audio on focus if possible\n    if (audioAllowed && audioCtx) Sound.resumeIfNeeded();\n  });\n\n  // For keyboard resume on first click (some browsers require user gesture)\n  canvas.addEventListener('pointerdown', async () => {\n    if (audioAllowed && audioCtx) {\n      try {\n        await Sound.resumeIfNeeded();\n      } catch (e) {\n        // ignore\n      }\n    }\n  });\n\n  function handleClick(x, y) {\n    if (gameState === 'start') {\n      startGame();\n      return;\n    }\n    if (gameState === 'playing') {\n      for (const b of buttons) {\n        if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {\n          selectAnswer(b.index);\n          return;\n        }\n      }\n    } else if (gameState === 'win' || gameState === 'gameover') {\n      // Check restart button\n      const btn = getRestartButtonRect();\n      if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {\n        restartGame();\n      }\n    }\n  }\n\n  function selectAnswer(idx) {\n    const now = Date.now();\n    if (!question || !choices.length) return;\n    if (now - lastAnswerTime < 400) return; // debounce\n    lastAnswerTime = now;\n    if (idx === question.correctIndex) {\n      // correct\n      score++;\n      droneX += Math.floor((WIDTH - 160) / GOAL); // advance drone\n      flashy = 18;\n      Sound.playCorrect();\n      if (score >= GOAL) {\n        gameState = 'win';\n        Sound.clickTone();\n      } else {\n        // next question\n        question = generateQuestion();\n        choices = question.choices.slice();\n      }\n    } else {\n      wrongs++;\n      Sound.playIncorrect();\n      hoverTime = 16;\n      if (wrongs >= MAX_WRONG) {\n        gameState = 'gameover';\n      } else {\n        // small penalty: drone moves back a bit\n        droneX = Math.max(80, droneX - 30);\n      }\n    }\n  }\n\n  function startGame() {\n    score = 0;\n    wrongs = 0;\n    droneX = 80;\n    bobOffset = 0;\n    question = generateQuestion();\n    choices = question.choices.slice();\n    gameState = 'playing';\n    Sound.playCorrect(); // friendly beep to indicate start\n  }\n\n  function restartGame() {\n    // reset variables and go to start screen\n    score = 0;\n    wrongs = 0;\n    droneX = 80;\n    question = null;\n    choices = [];\n    gameState = 'start';\n  }\n\n  function getRestartButtonRect() {\n    const w = 220;\n    const h = 56;\n    return { x: (WIDTH - w) / 2, y: HEIGHT / 2 + 60, w, h };\n  }\n\n  // Drawing functions\n  function clear() {\n    ctx.fillStyle = palette.sky;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n  }\n\n  function drawBackground(elapsed) {\n    // Wacky clouds and gentle parallax\n    ctx.save();\n    for (let i = 0; i < 6; i++) {\n      const cx = ((i * 150 + (elapsed / 40) * (i + 1)) % (WIDTH + 200)) - 100;\n      const cy = 60 + (i % 3) * 40;\n      drawCloud(cx, cy, 60 + (i % 3) * 8, palette.cloud, 0.95 - (i % 3) * 0.1);\n    }\n    ctx.restore();\n  }\n\n  function drawCloud(x, y, size, color, alpha = 1) {\n    ctx.save();\n    ctx.globalAlpha = alpha;\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.ellipse(x, y, size, size * 0.6, 0, 0, Math.PI * 2);\n    ctx.ellipse(x + size * 0.6, y - size * 0.15, size * 0.7, size * 0.45, 0, 0, Math.PI * 2);\n    ctx.ellipse(x - size * 0.6, y - size * 0.15, size * 0.7, size * 0.45, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function drawDrone() {\n    // Drone body: drawn using shapes, wacky colors, and propellers\n    ctx.save();\n    const x = droneX;\n    const y = droneY + Math.sin(bobOffset / 8) * 6;\n    // shadow\n    ctx.fillStyle = 'rgba(0,0,0,0.08)';\n    ctx.beginPath();\n    ctx.ellipse(x, y + 36, 48, 10, 0, 0, Math.PI * 2);\n    ctx.fill();\n    // body\n    ctx.fillStyle = palette.drone;\n    roundRect(ctx, x - 46, y - 16, 92, 36, 10, palette.drone);\n    // window\n    ctx.fillStyle = '#ffffff';\n    ctx.beginPath();\n    ctx.ellipse(x - 14, y - 2, 14, 10, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = '#bfe9ff';\n    ctx.beginPath();\n    ctx.ellipse(x - 14, y - 2, 10, 7, 0, 0, Math.PI * 2);\n    ctx.fill();\n    // battery symbol\n    ctx.fillStyle = palette.accent;\n    roundRect(ctx, x + 6, y - 8, 28, 16, 4, palette.accent);\n    ctx.fillStyle = palette.text;\n    ctx.font = '12px sans-serif';\n    ctx.fillText(`${score}/${GOAL}`, x + 12, y + 5);\n    // propellers\n    ctx.fillStyle = palette.prop;\n    for (let i = -1; i <= 1; i += 2) {\n      const px = x + i * 56;\n      const py = y - 6;\n      ctx.beginPath();\n      ctx.arc(px, py, 8, 0, Math.PI * 2);\n      ctx.fill();\n      // blades (rotate)\n      ctx.save();\n      ctx.translate(px, py);\n      ctx.rotate(bobOffset / 3 * i);\n      ctx.fillStyle = 'rgba(255,255,255,0.9)';\n      ctx.fillRect(-18, -2, 36, 4);\n      ctx.fillRect(-2, -18, 4, 36);\n      ctx.restore();\n    }\n\n    // wacky antenna\n    ctx.strokeStyle = palette.accent;\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.moveTo(x - 22, y - 18);\n    ctx.quadraticCurveTo(x - 30, y - 40, x - 6, y - 36);\n    ctx.stroke();\n    ctx.fillStyle = palette.accent;\n    ctx.beginPath();\n    ctx.arc(x - 6, y - 36, 5, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  function drawBatteryRow() {\n    const startX = 32;\n    const y = 20;\n    const h = 28;\n    let x = startX;\n    for (let i = 0; i < GOAL; i++) {\n      const filled = i < score;\n      roundRect(ctx, x, y, 28, h, 6, filled ? palette.win : '#ffffff');\n      // inner notch\n      ctx.fillStyle = filled ? palette.text : '#d0eaf6';\n      ctx.fillRect(x + 2, y + 6, 24, 16);\n      x += 34;\n    }\n  }\n\n  function drawTopUI() {\n    // Score top-left\n    ctx.font = fonts.body;\n    ctx.fillStyle = palette.text;\n    const scoreText = `Batteries: ${score}/${GOAL}`;\n    const scoreBox = drawTextBox(scoreText, PADDING + 6, 28 + 6, fonts.body, PADDING, 'left');\n\n    // Lives top-right\n    const livesText = `Lives: ${MAX_WRONG - wrongs}`;\n    const metrics = ctx.measureText(livesText);\n    const livesX = WIDTH - metrics.width - (PADDING * 3) - 6;\n    drawTextBox(livesText, livesX + metrics.width, 28 + 6, fonts.body, PADDING, 'right');\n\n    // Audio status small indicator to the right of lives\n    const audioText = audioUnavailable ? 'Audio unavailable' : (Sound.enabled ? 'Sound: On (M)' : 'Sound: Off (M)');\n    ctx.font = '14px sans-serif';\n    const atMetrics = ctx.measureText(audioText);\n    const ax = WIDTH - atMetrics.width - 10;\n    const ay = 28 + 6 + 24;\n    // avoid overlapping with lives: ensure separation > PADDING\n    drawTextBox(audioText, ax, ay, '14px sans-serif', 10, 'right', Sound.enabled ? palette.text : palette.wrong, '#ffffff');\n  }\n\n  function drawQuestionArea() {\n    const centerX = WIDTH / 2;\n    const y = 170;\n    ctx.font = fonts.big;\n    ctx.fillStyle = palette.text;\n    // Use drawTextBox to ensure no overlap and readability\n    drawTextBox(question.text, centerX, y, fonts.big, PADDING + 6, 'center', palette.text, '#ffffff');\n  }\n\n  function drawAnswerButtons() {\n    ctx.font = fonts.button;\n    for (let i = 0; i < buttons.length; i++) {\n      const b = buttons[i];\n      // label\n      const label = `${i + 1}. ${choices[i]}`;\n      b.label = label;\n      // background color\n      const bg = (gameState !== 'playing') ? '#efefef' : palette.button;\n      roundRect(ctx, b.x, b.y, b.w, b.h, 8, bg);\n      // label text with measurement to prevent overlap\n      ctx.fillStyle = palette.text;\n      ctx.font = fonts.button;\n      const metrics = ctx.measureText(label);\n      // ensure padding\n      const tx = b.x + (b.w - metrics.width) / 2;\n      const ty = b.y + (b.h + parseInt(fonts.button, 10) / 1.6);\n      // background behind label for clarity if long\n      drawTextBox(label, b.x + b.w / 2, ty, fonts.button, PADDING / 2, 'center', palette.text, bg);\n    }\n  }\n\n  function drawInstructions() {\n    const text = gameState === 'start'\n      ? 'Welcome! Help the drone collect batteries by answering math questions. Click to start. Use keys 1-4 or click answers. Press M to mute. Press R to restart.'\n      : 'Pick the correct answer. Collect 10 batteries. 3 wrong answers and the drone loses power. Press M to toggle sound. Use keys 1-4.';\n    ctx.font = fonts.body;\n    ctx.fillStyle = palette.text;\n    const lines = wrapTextToWidth(text, WIDTH - PADDING * 4, fonts.body);\n    // bottom-center instructions\n    const totalHeight = lines.length * 20 + PADDING;\n    const boxW = WIDTH - PADDING * 4;\n    const boxX = PADDING * 2;\n    const boxY = HEIGHT - totalHeight - 12;\n    roundRect(ctx, boxX, boxY, boxW, totalHeight + 6, 8, '#ffffff');\n    ctx.fillStyle = palette.text;\n    for (let i = 0; i < lines.length; i++) {\n      ctx.fillText(lines[i], boxX + PADDING, boxY + 20 + i * 20);\n    }\n  }\n\n  function wrapTextToWidth(text, maxW, font) {\n    ctx.font = font;\n    const words = text.split(' ');\n    const lines = [];\n    let current = '';\n    for (const w of words) {\n      const test = current ? current + ' ' + w : w;\n      const m = ctx.measureText(test).width;\n      if (m > maxW - PADDING * 2) {\n        if (current) lines.push(current);\n        current = w;\n      } else {\n        current = test;\n      }\n    }\n    if (current) lines.push(current);\n    return lines;\n  }\n\n  function drawWinScreen() {\n    ctx.save();\n    roundRect(ctx, 80, 80, WIDTH - 160, HEIGHT - 160, 12, '#ffffff');\n    ctx.font = fonts.big;\n    ctx.fillStyle = palette.text;\n    const txt = 'Victory! Drone is fully charged!';\n    drawTextBox(txt, WIDTH / 2, HEIGHT / 2 - 40, fonts.big, PADDING + 6, 'center', palette.win, '#ffffff');\n    ctx.font = fonts.title;\n    drawTextBox('You collected all 10 batteries. Great flying!', WIDTH / 2, HEIGHT / 2, fonts.title, PADDING + 6, 'center', palette.text, '#ffffff');\n    const btn = getRestartButtonRect();\n    roundRect(ctx, btn.x, btn.y, btn.w, btn.h, 10, palette.button);\n    ctx.font = fonts.button;\n    ctx.fillStyle = palette.text;\n    ctx.fillText('Restart (R)', btn.x + btn.w / 2 - ctx.measureText('Restart (R)').width / 2, btn.y + btn.h / 2 + 6);\n    ctx.restore();\n  }\n\n  function drawGameOverScreen() {\n    ctx.save();\n    roundRect(ctx, 80, 80, WIDTH - 160, HEIGHT - 160, 12, '#ffffff');\n    ctx.font = fonts.big;\n    ctx.fillStyle = palette.text;\n    drawTextBox('Game Over', WIDTH / 2, HEIGHT / 2 - 40, fonts.big, PADDING + 6, 'center', palette.wrong, '#ffffff');\n    ctx.font = fonts.title;\n    drawTextBox('The drone ran out of power after 3 wrong answers.', WIDTH / 2, HEIGHT / 2, fonts.title, PADDING + 6, 'center', palette.text, '#ffffff');\n    const btn = getRestartButtonRect();\n    roundRect(ctx, btn.x, btn.y, btn.w, btn.h, 10, palette.wrong);\n    ctx.font = fonts.button;\n    ctx.fillStyle = '#ffffff';\n    ctx.fillText('Try Again (R)', btn.x + btn.w / 2 - ctx.measureText('Try Again (R)').width / 2, btn.y + btn.h / 2 + 6);\n    ctx.restore();\n  }\n\n  // Visual cue for audio: small speaker icon\n  function drawAudioCue() {\n    const x = WIDTH - 44;\n    const y = 56;\n    ctx.save();\n    roundRect(ctx, x - 8, y - 18, 48, 36, 8, '#ffffff');\n    ctx.fillStyle = Sound.enabled ? '#2e8b57' : '#ff7b7b';\n    ctx.beginPath();\n    ctx.moveTo(x, y - 6);\n    ctx.lineTo(x + 8, y - 6);\n    ctx.lineTo(x + 16, y - 12);\n    ctx.lineTo(x + 16, y + 12);\n    ctx.lineTo(x + 8, y + 6);\n    ctx.lineTo(x, y + 6);\n    ctx.closePath();\n    ctx.fill();\n    ctx.restore();\n  }\n\n  // Main loop\n  let lastTime = performance.now();\n  function loop(now) {\n    const dt = now - lastTime;\n    lastTime = now;\n    update(dt);\n    render(now);\n    requestAnimationFrame(loop);\n  }\n\n  function update(dt) {\n    bobOffset += dt / 6;\n    if (flashy > 0) flashy -= 1;\n    if (hoverTime > 0) hoverTime -= 1;\n    if (muteVisualFlash > 0) muteVisualFlash -= 1;\n    // slowly return drone to bounds\n    droneX = Math.max(80, Math.min(WIDTH - 120, droneX));\n    // layout buttons may need recalculation if window changed; keep static\n  }\n\n  function render(elapsed) {\n    clear();\n    drawBackground(elapsed);\n    drawBatteryRow();\n    drawTopUI();\n\n    // center game area\n    if (gameState === 'start') {\n      // show title and instructions\n      ctx.font = fonts.big;\n      drawTextBox('Drone Math Adventure', WIDTH / 2, 120, fonts.big, PADDING + 6, 'center', palette.text, '#ffffff');\n      ctx.font = fonts.title;\n      drawTextBox('Collect 10 batteries by answering math questions!', WIDTH / 2, 160, fonts.title, PADDING + 6, 'center', palette.text, '#ffffff');\n      ctx.font = fonts.body;\n      drawTextBox('Click anywhere or press Enter to start', WIDTH / 2, 200, fonts.body, PADDING + 6, 'center', palette.text, '#ffffff');\n      // draw a friendly drone hovering\n      drawDrone();\n    } else if (gameState === 'playing') {\n      drawDrone();\n      // question\n      drawQuestionArea();\n      // buttons\n      drawAnswerButtons();\n      // show small flash when correct\n      if (flashy > 0) {\n        ctx.save();\n        ctx.globalAlpha = 0.15 + (flashy / 18) * 0.2;\n        roundRect(ctx, 60, 120, WIDTH - 120, 220, 12, palette.win);\n        ctx.restore();\n      }\n      // show wrong flash\n      if (hoverTime > 0) {\n        ctx.save();\n        ctx.globalAlpha = 0.08 + (hoverTime / 16) * 0.14;\n        roundRect(ctx, 60, 120, WIDTH - 120, 220, 12, palette.wrong);\n        ctx.restore();\n      }\n    } else if (gameState === 'win') {\n      drawDrone();\n      drawWinScreen();\n    } else if (gameState === 'gameover') {\n      drawDrone();\n      drawGameOverScreen();\n    }\n\n    drawInstructions();\n    drawAudioCue();\n\n    // accessibility text overlays (non-overlapping)\n    ctx.font = '14px sans-serif';\n    ctx.fillStyle = '#000000';\n    // small note near bottom-left\n    ctx.fillText('Keyboard: 1-4 to answer, M toggle sound, R restart', 14, HEIGHT - 12);\n    // if audio unavailable, show notice\n    if (audioUnavailable) {\n      drawTextBox('Audio is unavailable on this device or browser.', WIDTH / 2, HEIGHT - 40, '14px sans-serif', PADDING, 'center', palette.text, '#fff2f0');\n    }\n  }\n\n  // Start initial state\n  restartGame();\n  requestAnimationFrame(loop);\n\n  // Resize handling: keep canvas size fixed but respond to pixel ratio for crispness\n  function fixHiDPICanvas() {\n    const ratio = window.devicePixelRatio || 1;\n    canvas.width = WIDTH * ratio;\n    canvas.height = HEIGHT * ratio;\n    canvas.style.width = WIDTH + 'px';\n    canvas.style.height = HEIGHT + 'px';\n    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);\n  }\n  fixHiDPICanvas();\n\n  // Ensure proper layout spacing and measureText usage example: we used measureText widely when drawing boxes.\n\n  // Expose a global for debug (optional)\n  window.__droneMathGame = {\n    restart: restartGame,\n    start: startGame,\n    getState: () => ({ score, wrongs, gameState })\n  };\n\n  // Utility: ensure audio context created on first gesture if suspended\n  // Listen to the first user gesture on document\n  function enableAudioOnGesture() {\n    function resume() {\n      if (audioAllowed && audioCtx) {\n        Sound.resumeIfNeeded();\n      }\n      document.removeEventListener('pointerdown', resume);\n      document.removeEventListener('keydown', resume);\n    }\n    document.addEventListener('pointerdown', resume, { once: true });\n    document.addEventListener('keydown', resume, { once: true });\n  }\n  enableAudioOnGesture();\n\n  // Proper error handling example: catch unhandled exceptions and show message\n  window.addEventListener('error', function (e) {\n    console.error('Unhandled error in game:', e.message);\n    try {\n      ctx.save();\n      roundRect(ctx, 40, 40, WIDTH - 80, 80, 8, '#fff0f0');\n      ctx.font = '16px sans-serif';\n      ctx.fillStyle = '#900';\n      ctx.fillText('An error occurred. Please reload the page.', 60, 84);\n      ctx.restore();\n    } catch (ex) {\n      // ignore rendering errors\n    }\n  });\n\n  // Ensure buttons recalc if fonts or sizes changed\n  window.addEventListener('resize', layoutButtons);\n\n})();\n---\n",
  "improve_response_tokens": 20288,
  "formatted_code": true,
  "formatting_response_tokens": 23355,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}