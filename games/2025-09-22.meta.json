{
  "generated_date": "2025-09-22",
  "generated_timestamp": "2025-09-22T00:29:20.021769",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8091,
  "game_filename": "2025-09-22.js",
  "game_size_bytes": 24481,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Fix-the-Machine: a fun math game for ages 7-9\n// Renders into the element with id \"game-of-the-day-stage\"\n// All visuals are drawn on a canvas 720x480. Sounds use the Web Audio API (generated).\n// Accessible via keyboard and includes on-screen instructions and ARIA live updates.\n\n// Immediately-invoked function to avoid polluting global scope\n(() => {\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const NUM_GEARS = 3;\n  const MAX_LEVELS = 6;\n\n  // Helper: clamp\n  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));\n\n  // Get container element\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Container element with id \"game-of-the-day-stage\" not found.');\n    return;\n  }\n  // Clear and set basic styles for container\n  container.innerHTML = '';\n  container.style.position = 'relative';\n  container.style.width = WIDTH + 'px';\n  container.style.height = HEIGHT + 'px';\n  container.setAttribute('role', 'application');\n  container.setAttribute('aria-label', 'Fix the Machine math game');\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.display = 'block';\n  canvas.style.outline = 'none';\n  canvas.setAttribute('tabindex', '0'); // make keyboard focusable\n  canvas.setAttribute('aria-label', 'Machine play area. Use arrow keys to set numbers and Enter to run.');\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Create a small UI area for controls and instructions inside container\n  const ui = document.createElement('div');\n  ui.style.position = 'absolute';\n  ui.style.left = '10px';\n  ui.style.top = '10px';\n  ui.style.width = (WIDTH - 20) + 'px';\n  ui.style.pointerEvents = 'none'; // let canvas handle clicks; UI only for text\n  ui.style.color = '#114';\n  ui.style.fontFamily = 'Arial, sans-serif';\n  container.appendChild(ui);\n\n  // Accessible live region for screen readers\n  const live = document.createElement('div');\n  live.setAttribute('aria-live', 'polite');\n  live.style.position = 'absolute';\n  live.style.left = '-9999px';\n  live.style.top = 'auto';\n  container.appendChild(live);\n\n  // Small visible instruction box within canvas area (drawn on canvas too).\n  // But also provide an always-available textual instructions block (pointerEvents none).\n  const instructions = document.createElement('div');\n  instructions.style.pointerEvents = 'none';\n  instructions.innerHTML = 'Goal: Set the three dials so their SUM equals the machine target. Click a dial or use Tab to choose it, then use \u2191/\u2193 to change. Press Space or Enter to RUN.';\n  instructions.style.fontSize = '13px';\n  instructions.style.padding = '6px';\n  instructions.style.background = 'rgba(255,255,255,0.75)';\n  instructions.style.borderRadius = '6px';\n  instructions.style.width = 'calc(100% - 12px)';\n  ui.appendChild(instructions);\n\n  // Visual indicator for audio (muted/unavailable)\n  const audioIndicator = document.createElement('div');\n  audioIndicator.style.pointerEvents = 'none';\n  audioIndicator.style.marginTop = '6px';\n  audioIndicator.style.fontSize = '13px';\n  audioIndicator.textContent = 'Audio: initializing...';\n  ui.appendChild(audioIndicator);\n\n  // Game state\n  const state = {\n    level: 0,\n    target: 0,\n    dials: [0, 0, 0],\n    selected: 0,\n    running: false,\n    runProgress: 0,\n    solvedCount: 0,\n    moves: 0,\n    maxMoves: 20,\n    animationTime: 0,\n    systemOK: true,\n    backgroundOn: true,\n  };\n\n  // Generate solvable level: pick random digits then target = sum.\n  const makeLevel = (levelIndex) => {\n    // levels gradually increase complexity by widening digit range or targets\n    const rangeMax = 9; // keep simple digits for ages 7-9\n    const dials = [];\n    for (let i = 0; i < NUM_GEARS; i++) {\n      // random start value biased toward mid-values for easier play\n      dials.push(Math.floor(Math.random() * (rangeMax + 1)));\n    }\n    const target = dials.reduce((a, b) => a + b, 0);\n    // Optionally nudge target upward for later levels by adding small increments\n    // But since we want solvable, adjust by storing \"solution\" internally:\n    return { dialsStart: dials, target };\n  };\n\n  // Audio manager\n  class AudioManager {\n    constructor() {\n      this.ctx = null;\n      this.master = null;\n      this.bgOsc = null;\n      this.bgGain = null;\n      this.available = false;\n      this.initialized = false;\n    }\n\n    // Initialize on first user gesture to satisfy autoplay policies.\n    async init() {\n      if (this.initialized) return;\n      this.initialized = true;\n      try {\n        const AudioCtx = window.AudioContext || window.webkitAudioContext;\n        if (!AudioCtx) throw new Error('Web Audio API not supported.');\n        this.ctx = new AudioCtx();\n        // create master gain\n        this.master = this.ctx.createGain();\n        this.master.gain.value = 0.6;\n        this.master.connect(this.ctx.destination);\n        // gentle background hum\n        this.bgOsc = this.ctx.createOscillator();\n        this.bgOsc.type = 'sine';\n        this.bgGain = this.ctx.createGain();\n        this.bgGain.gain.value = 0.02; // very gentle\n        this.bgOsc.frequency.value = 90; // low hum\n        // subtle filter to make it warm\n        const filter = this.ctx.createBiquadFilter();\n        filter.type = 'lowpass';\n        filter.frequency.value = 800;\n        this.bgOsc.connect(filter);\n        filter.connect(this.bgGain);\n        this.bgGain.connect(this.master);\n        this.bgOsc.start();\n        this.available = true;\n        audioIndicator.textContent = 'Audio: on';\n      } catch (err) {\n        console.warn('Audio init failed:', err);\n        this.available = false;\n        audioIndicator.textContent = 'Audio: unavailable';\n      }\n    }\n\n    // Play a short tick sound when dial changes\n    playTick() {\n      if (!this.available) return;\n      const t = this.ctx.currentTime;\n      try {\n        const osc = this.ctx.createOscillator();\n        const gain = this.ctx.createGain();\n        osc.type = 'triangle';\n        osc.frequency.value = 880 + Math.random() * 220;\n        gain.gain.value = 0.0001;\n        osc.connect(gain);\n        gain.connect(this.master);\n        gain.gain.setValueAtTime(0.0001, t);\n        gain.gain.linearRampToValueAtTime(0.08, t + 0.005);\n        gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.18);\n        osc.start(t);\n        osc.stop(t + 0.2);\n      } catch (err) {\n        console.warn('tick sound failed', err);\n      }\n    }\n\n    // Play success chime (ascending arpeggio)\n    playSuccess() {\n      if (!this.available) return;\n      const t = this.ctx.currentTime;\n      try {\n        const freqs = [440, 660, 880, 1100].map((f) => f * (1 + (Math.random() - 0.5) * 0.04));\n        freqs.forEach((freq, i) => {\n          const osc = this.ctx.createOscillator();\n          const gain = this.ctx.createGain();\n          osc.type = i % 2 === 0 ? 'sine' : 'triangle';\n          osc.frequency.value = freq;\n          gain.gain.value = 0.0001;\n          osc.connect(gain);\n          gain.connect(this.master);\n          const start = t + i * 0.08;\n          gain.gain.setValueAtTime(0.0001, start);\n          gain.gain.linearRampToValueAtTime(0.12, start + 0.02);\n          gain.gain.exponentialRampToValueAtTime(0.0001, start + 0.32);\n          osc.start(start);\n          osc.stop(start + 0.34);\n        });\n      } catch (err) {\n        console.warn('success sound failed', err);\n      }\n    }\n\n    // Play incorrect buzzer\n    playBuzzer() {\n      if (!this.available) return;\n      const t = this.ctx.currentTime;\n      try {\n        const osc = this.ctx.createOscillator();\n        const gain = this.ctx.createGain();\n        const filter = this.ctx.createBiquadFilter();\n        filter.type = 'bandpass';\n        filter.frequency.value = 220;\n        osc.connect(filter);\n        filter.connect(gain);\n        gain.connect(this.master);\n        osc.type = 'sawtooth';\n        osc.frequency.setValueAtTime(140, t);\n        gain.gain.setValueAtTime(0.0001, t);\n        gain.gain.linearRampToValueAtTime(0.2, t + 0.02);\n        gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.5);\n        osc.frequency.exponentialRampToValueAtTime(60, t + 0.45);\n        osc.start(t);\n        osc.stop(t + 0.5);\n      } catch (err) {\n        console.warn('buzzer sound failed', err);\n      }\n    }\n\n    // Toggle background hum on/off\n    setBackground(on) {\n      if (!this.available || !this.bgGain) return;\n      try {\n        this.bgGain.gain.setTargetAtTime(on ? 0.02 : 0.0001, this.ctx.currentTime, 0.2);\n      } catch (err) {\n        console.warn('background toggle failed', err);\n      }\n    }\n  }\n\n  const audio = new AudioManager();\n\n  // Start audio on first user gesture\n  const ensureAudioOnUserGesture = async () => {\n    if (!audio.initialized) {\n      await audio.init();\n      audio.setBackground(state.backgroundOn);\n    }\n  };\n\n  // Game class managing logic and rendering\n  class Game {\n    constructor(ctx) {\n      this.ctx = ctx;\n      this.lastTime = performance.now();\n      this.running = false;\n      this.levelData = [];\n      for (let i = 0; i < MAX_LEVELS; i++) {\n        this.levelData.push(makeLevel(i));\n      }\n      this.resetToLevel(0);\n      this.bindEvents();\n      this.animationId = requestAnimationFrame((t) => this.loop(t));\n      this.confetti = [];\n    }\n\n    resetToLevel(index) {\n      state.level = index;\n      const data = this.levelData[index];\n      // For increasing difficulty, sometimes alter the target to be sum+small number and allow changes negative? To keep solvable, we store solution as target and start values differ.\n      state.dials = data.dialsStart.map((v) => {\n        // start value randomly offset by -3..3 but clamp 0..9\n        const offset = Math.floor(Math.random() * 7) - 3;\n        return clamp(v + offset, 0, 9);\n      });\n      state.target = data.target;\n      state.selected = 0;\n      state.running = false;\n      state.runProgress = 0;\n      state.moves = 0;\n      state.solvedCount = 0;\n      state.animationTime = 0;\n      live.textContent = `Level ${state.level + 1}: target ${state.target}. Use arrow keys or click dials.`;\n    }\n\n    nextLevel() {\n      if (state.level < MAX_LEVELS - 1) {\n        this.resetToLevel(state.level + 1);\n      } else {\n        // finished all levels: show congratulations then restart\n        live.textContent = 'All machines fixed! Great job! Press Enter to play again.';\n        state.solvedCount = 0;\n        // create confetti burst\n        this.spawnConfetti(60);\n        // reset to start after small delay\n        setTimeout(() => {\n          this.resetToLevel(0);\n        }, 3000);\n      }\n    }\n\n    bindEvents() {\n      // Keyboard controls on canvas\n      canvas.addEventListener('keydown', async (e) => {\n        // Ensure audio init\n        await ensureAudioOnUserGesture();\n        const key = e.key;\n        if (key === 'Tab') {\n          e.preventDefault();\n          // cycle selection\n          state.selected = (state.selected + 1) % NUM_GEARS;\n          this.announceSelection();\n        } else if (key === 'ArrowRight') {\n          state.selected = (state.selected + 1) % NUM_GEARS;\n          this.announceSelection();\n        } else if (key === 'ArrowLeft') {\n          state.selected = (state.selected - 1 + NUM_GEARS) % NUM_GEARS;\n          this.announceSelection();\n        } else if (key === 'ArrowUp') {\n          state.dials[state.selected] = clamp(state.dials[state.selected] + 1, 0, 9);\n          audio.playTick();\n          state.moves++;\n        } else if (key === 'ArrowDown') {\n          state.dials[state.selected] = clamp(state.dials[state.selected] - 1, 0, 9);\n          audio.playTick();\n          state.moves++;\n        } else if (key === ' ' || key === 'Enter') {\n          // Run the machine\n          this.runMachine();\n        } else if (key.toLowerCase() === 'r') {\n          // Reset current dials to initial solution start\n          this.resetToLevel(state.level);\n        } else if (key.toLowerCase() === 'm') {\n          // toggle background audio\n          state.backgroundOn = !state.backgroundOn;\n          audio.setBackground(state.backgroundOn);\n          audioIndicator.textContent = 'Audio: ' + (state.backgroundOn ? 'on' : 'muted');\n        }\n      });\n\n      // Mouse interactions over canvas\n      canvas.addEventListener('click', async (e) => {\n        await ensureAudioOnUserGesture();\n        const rect = canvas.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n        // If click is on one of the dial areas, select it or adjust\n        const dialIndex = this.dialIndexAt(x, y);\n        if (dialIndex !== -1) {\n          // If click on dial center, select. If clicked upper half, increment; lower half decrement.\n          const dialCenter = this.dialCenter(dialIndex);\n          if (y < dialCenter.y) {\n            state.dials[dialIndex] = clamp(state.dials[dialIndex] + 1, 0, 9);\n          } else {\n            state.dials[dialIndex] = clamp(state.dials[dialIndex] - 1, 0, 9);\n          }\n          state.selected = dialIndex;\n          state.moves++;\n          audio.playTick();\n          this.announceSelection();\n          return;\n        }\n        // Click on \"run\" machine area (big button area near bottom)\n        if (x > WIDTH / 2 - 80 && x < WIDTH / 2 + 80 && y > HEIGHT - 100 && y < HEIGHT - 40) {\n          this.runMachine();\n          return;\n        }\n      });\n\n      // Support mouse wheel to change selected dial when hovering\n      canvas.addEventListener('wheel', async (e) => {\n        e.preventDefault();\n        await ensureAudioOnUserGesture();\n        const rect = canvas.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n        const idx = this.dialIndexAt(x, y);\n        if (idx !== -1) {\n          state.dials[idx] = clamp(state.dials[idx] + (e.deltaY < 0 ? 1 : -1), 0, 9);\n          audio.playTick();\n          state.moves++;\n        }\n      });\n\n      // Accessibility: focus canvas on pointer enter so keyboard works easily\n      canvas.addEventListener('mouseenter', () => {\n        canvas.focus();\n      });\n    }\n\n    announceSelection() {\n      live.textContent = `Selected dial ${state.selected + 1}. Value ${state.dials[state.selected]}. Target ${state.target}.`;\n    }\n\n    dialCenter(index) {\n      // compute positions for three dials\n      const spacing = 160;\n      const centerY = HEIGHT / 2 + 10;\n      const startX = WIDTH / 2 - spacing;\n      return { x: startX + index * spacing, y: centerY };\n    }\n\n    dialIndexAt(x, y) {\n      // check click near dials (circle radius 48)\n      for (let i = 0; i < NUM_GEARS; i++) {\n        const c = this.dialCenter(i);\n        const dx = x - c.x;\n        const dy = y - c.y;\n        if (dx * dx + dy * dy <= 48 * 48) return i;\n      }\n      return -1;\n    }\n\n    runMachine() {\n      if (state.running) return;\n      state.running = true;\n      state.runProgress = 0;\n      state.animationTime = 0;\n      // Play start sequence\n      audio.playTick();\n      live.textContent = 'Machine starting...';\n    }\n\n    spawnConfetti(n) {\n      for (let i = 0; i < n; i++) {\n        this.confetti.push({\n          x: WIDTH / 2,\n          y: HEIGHT / 2,\n          vx: (Math.random() - 0.5) * 6,\n          vy: (Math.random() - 1.8) * 6,\n          size: 4 + Math.random() * 6,\n          color: `hsl(${Math.random() * 360},70%,60%)`,\n          rot: Math.random() * Math.PI * 2,\n          life: 60 + Math.random() * 40,\n        });\n      }\n    }\n\n    update(dt) {\n      // update running animation\n      if (state.running) {\n        state.runProgress += dt * 0.002; // progress 0..1\n        state.animationTime += dt;\n        if (state.runProgress >= 1) {\n          state.running = false;\n          state.runProgress = 1;\n          // Evaluate result\n          const sum = state.dials.reduce((a, b) => a + b, 0);\n          if (sum === state.target) {\n            audio.playSuccess();\n            this.spawnConfetti(20);\n            live.textContent = `Nice! The sum is ${sum}. Machine fixed! Press Enter for next machine.`;\n            // prepare to advance to next level automatically after small delay\n            setTimeout(() => {\n              this.nextLevel();\n            }, 1000);\n          } else {\n            audio.playBuzzer();\n            live.textContent = `Oops! The sum is ${sum}. Try again.`;\n            // small shake animation\n            this.shake = 10;\n          }\n        } else {\n          // While running, produce metallic ticks occasionally\n          if (Math.random() < 0.02) audio.playTick();\n        }\n      }\n      // update confetti\n      for (let i = this.confetti.length - 1; i >= 0; i--) {\n        const p = this.confetti[i];\n        p.vy += 0.18; // gravity\n        p.x += p.vx;\n        p.y += p.vy;\n        p.rot += 0.2;\n        p.life -= 1;\n        if (p.life <= 0 || p.y > HEIGHT + 50) this.confetti.splice(i, 1);\n      }\n      if (this.shake) {\n        this.shake = Math.max(0, this.shake - dt * 0.02);\n      }\n    }\n\n    draw() {\n      const c = this.ctx;\n      // calming background gradient with wacky details\n      c.clearRect(0, 0, WIDTH, HEIGHT);\n      const g = c.createLinearGradient(0, 0, 0, HEIGHT);\n      g.addColorStop(0, '#E8F6F3');\n      g.addColorStop(1, '#F6F9FF');\n      c.fillStyle = g;\n      c.fillRect(0, 0, WIDTH, HEIGHT);\n\n      // subtle large gear shapes in background (wacky)\n      for (let i = 0; i < 6; i++) {\n        c.save();\n        const gx = 60 + i * 120;\n        const gy = 60 + (i % 2) * 40;\n        c.globalAlpha = 0.06 + (i % 3) * 0.02;\n        this.drawSimpleGear(c, gx, gy, 26 + (i % 3) * 8, i * 20);\n        c.restore();\n      }\n\n      // central machine base\n      c.save();\n      const shakeX = this.shake ? Math.sin(this.animationTime * 0.03) * this.shake : 0;\n      c.translate(shakeX, 0);\n      c.fillStyle = '#FFF';\n      this.roundRect(c, 40, 80, WIDTH - 80, HEIGHT - 160, 18);\n      c.fillStyle = 'rgba(210,230,240,0.8)';\n      this.roundRect(c, 44, 84, WIDTH - 88, HEIGHT - 168, 16);\n      c.fill();\n\n      // Machine face (display)\n      c.fillStyle = '#112';\n      c.fillRect(WIDTH / 2 - 160, 100, 320, 64);\n      c.fillStyle = '#AEE';\n      c.font = '28px \"Comic Sans MS\", Arial';\n      c.textAlign = 'center';\n      c.fillText('TARGET: ' + state.target, WIDTH / 2, 138);\n\n      // small wacky pipes left\n      c.strokeStyle = '#89B';\n      c.lineWidth = 6;\n      c.beginPath();\n      c.moveTo(80, 160);\n      c.quadraticCurveTo(120, 140, 180, 180);\n      c.stroke();\n      // right pipe\n      c.beginPath();\n      c.moveTo(WIDTH - 80, 160);\n      c.quadraticCurveTo(WIDTH - 120, 140, WIDTH - 180, 180);\n      c.stroke();\n\n      // Dials / gears in center\n      for (let i = 0; i < NUM_GEARS; i++) {\n        const pos = this.dialCenter(i);\n        const dialValue = state.dials[i];\n        const isSelected = state.selected === i;\n        // animated rotation while running\n        const rot = (state.running ? state.runProgress * (i + 1) * Math.PI * 2 : 0) + (isSelected ? Math.sin(Date.now() / 300) * 0.08 : 0);\n        this.drawBigDial(c, pos.x, pos.y, 48, dialValue, rot, isSelected);\n      }\n\n      // progress bar / running indicator below dials\n      c.fillStyle = '#dde';\n      c.fillRect(WIDTH / 2 - 180, HEIGHT / 2 + 90, 360, 14);\n      c.fillStyle = '#4DB';\n      c.fillRect(WIDTH / 2 - 180, HEIGHT / 2 + 90, 360 * state.runProgress, 14);\n\n      // Run button region\n      c.beginPath();\n      const btnX = WIDTH / 2 - 80;\n      const btnY = HEIGHT - 100;\n      this.roundRect(c, btnX, btnY, 160, 48, 10);\n      c.fillStyle = '#2A6';\n      c.fill();\n      c.fillStyle = '#fff';\n      c.font = '20px Arial';\n      c.textAlign = 'center';\n      c.fillText('RUN MACHINE', WIDTH / 2, btnY + 32);\n\n      // small hint text\n      c.fillStyle = '#224';\n      c.font = '13px Arial';\n      c.textAlign = 'left';\n      c.fillText('Moves: ' + state.moves + (state.moves > state.maxMoves ? ' (too many moves!)' : ''), 60, HEIGHT - 40);\n\n      // speaker icon (visual cue for audio)\n      c.save();\n      c.translate(WIDTH - 90, 40);\n      c.fillStyle = state.backgroundOn ? '#1b5' : '#999';\n      c.beginPath();\n      c.moveTo(-18, -8);\n      c.lineTo(-8, -8);\n      c.lineTo(0, -18);\n      c.lineTo(0, 18);\n      c.lineTo(-8, 8);\n      c.lineTo(-18, 8);\n      c.closePath();\n      c.fill();\n      if (audio.available && state.backgroundOn) {\n        c.beginPath();\n        c.strokeStyle = '#1b5';\n        c.lineWidth = 2;\n        c.arc(6, 0, 12, -0.6, 0.6);\n        c.stroke();\n      }\n      c.restore();\n\n      // confetti draw\n      for (const p of this.confetti) {\n        c.save();\n        c.translate(p.x, p.y);\n        c.rotate(p.rot);\n        c.fillStyle = p.color;\n        c.fillRect(-p.size / 2, -p.size / 2, p.size, p.size * 0.6);\n        c.restore();\n      }\n\n      c.restore(); // end main container transform\n    }\n\n    // utility: draw big dial with teeth and number\n    drawBigDial(c, x, y, r, value, rotation = 0, selected = false) {\n      c.save();\n      c.translate(x, y);\n      c.rotate(rotation);\n      // outer ring\n      c.beginPath();\n      c.fillStyle = selected ? '#FFE8A6' : '#FFF';\n      c.strokeStyle = '#88A';\n      c.lineWidth = 4;\n      c.arc(0, 0, r + 8, 0, Math.PI * 2);\n      c.fill();\n      c.stroke();\n      // gear teeth\n      const teeth = 12;\n      for (let i = 0; i < teeth; i++) {\n        const ang = (i / teeth) * Math.PI * 2;\n        const tx = Math.cos(ang) * (r + 12);\n        const ty = Math.sin(ang) * (r + 12);\n        c.beginPath();\n        c.fillStyle = '#CCD';\n        c.ellipse(tx, ty, 6, 3, ang, 0, Math.PI * 2);\n        c.fill();\n      }\n      // dial face\n      c.beginPath();\n      c.fillStyle = '#EAF7FF';\n      c.arc(0, 0, r, 0, Math.PI * 2);\n      c.fill();\n      c.lineWidth = 2;\n      c.strokeStyle = '#779';\n      c.stroke();\n      // number\n      c.fillStyle = '#113';\n      c.font = '36px \"Comic Sans MS\", Arial';\n      c.textAlign = 'center';\n      c.textBaseline = 'middle';\n      c.fillText(String(value), 0, 0);\n      c.restore();\n    }\n\n    // small simple gear in background\n    drawSimpleGear(c, x, y, r, rot) {\n      c.save();\n      c.translate(x, y);\n      c.rotate(rot * 0.017);\n      c.fillStyle = '#cfe';\n      c.beginPath();\n      c.arc(0, 0, r, 0, Math.PI * 2);\n      c.fill();\n      const teeth = 10;\n      c.fillStyle = '#bcd';\n      for (let i = 0; i < teeth; i++) {\n        const ang = (i / teeth) * Math.PI * 2;\n        const tx = Math.cos(ang) * (r + 6);\n        const ty = Math.sin(ang) * (r + 6);\n        c.fillRect(tx - 3, ty - 2, 6, 4);\n      }\n      c.restore();\n    }\n\n    // helper to draw rounded rect path\n    roundRect(c, x, y, w, h, r) {\n      c.beginPath();\n      c.moveTo(x + r, y);\n      c.arcTo(x + w, y, x + w, y + h, r);\n      c.arcTo(x + w, y + h, x, y + h, r);\n      c.arcTo(x, y + h, x, y, r);\n      c.arcTo(x, y, x + w, y, r);\n      c.closePath();\n    }\n\n    loop(time) {\n      const dt = time - this.lastTime;\n      this.lastTime = time;\n      this.update(dt);\n      this.draw();\n      this.animationId = requestAnimationFrame((t) => this.loop(t));\n    }\n  }\n\n  // Instantiate game\n  const game = new Game(ctx);\n\n  // Provide initial text content for screen readers\n  live.textContent = 'Welcome to Fix-the-Machine! Focus the game area and follow the instructions to set the dials so their sum matches the target number.';\n\n  // Click-to-enable audio hint: add a semi-transparent overlay telling the user to interact to enable audio if audio unavailable\n  const hint = document.createElement('div');\n  hint.style.position = 'absolute';\n  hint.style.left = '0';\n  hint.style.bottom = '8px';\n  hint.style.width = '100%';\n  hint.style.textAlign = 'center';\n  hint.style.pointerEvents = 'none';\n  hint.style.fontSize = '12px';\n  hint.style.color = '#113';\n  hint.textContent = 'Tip: Press M to toggle background sound. Press R to reset. Click or press Enter to run.';\n  container.appendChild(hint);\n\n  // Informational console: log errors for audio and resource handling\n  window.addEventListener('unhandledrejection', (ev) => {\n    console.error('Unhandled promise rejection:', ev.reason);\n  });\n\n  // Fallback: if Web Audio cannot start because of autoplay policy until user gesture, show a small note\n  canvas.addEventListener('pointerdown', async () => {\n    await ensureAudioOnUserGesture();\n  }, { once: true });\n\n})();\n---\n",
  "improve_response_tokens": 15536,
  "formatted_code": true,
  "formatting_response_tokens": 16526,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}