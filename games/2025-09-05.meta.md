# Game of the Day - 2025-09-05

## Metadata
- **Generated Date:** 2025-09-05
- **Generated Time:** 2025-09-05T00:27:21.291083
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-05.js
- **File Size:** 33376 bytes
- **Tokens Used:** 10784

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-05.js` - The playable game
- `2025-09-05.meta.json` - Machine-readable metadata
- `2025-09-05.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 22415

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 23706

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Machine Math: A calming, wacky math game for ages 7-9
// Renders in the element with ID "game-of-the-day-stage"
// All visuals are canvas-drawn. Sounds use Web Audio API oscillators and filters.
// Accessible: keyboard controls, aria-live updates, clear instructions, audio on/off.

// Immediately initialize when page loads
(function () {
  // Config
  const WIDTH = 720;
  const HEIGHT = 480;
  const CONTAINER_ID = 'game-of-the-day-stage';
  const MAX_LEVELS = 5; // game beatable in 5 levels
  const PALETTE_SIZE = 6; // number of parts presented each level
  const SLOT_COUNT_BASE = 3; // base number of slots, increases with level
  const COLOR_BG = '#E9F3F0'; // calming background
  const COLOR_ACCENT = '#5C6B8A';
  const COLOR_GEAR = '#A3C6C2';
  const COLOR_PART = '#F6C9C2';
  const COLOR_TEXT = '#203040';
  const FONT = '16px system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial';
  const AUDIO_ICON_SIZE = 28;

  // State and elements
  let container, canvas, ctx;
  let audioCtx = null;
  let audioAllowed = true; // will be toggled if audio context creation fails or user mutes
  let bgOsc = null;
  let masterGain = null;
  let lfo = null;
  let level = 1;
  let score = 0;
  let parts = []; // palette parts
  let slots = []; // machine slots
  let target = 0;
  let currentSum = 0;
  let selectedPaletteIndex = 0;
  let focusedSlotIndex = 0;
  let dragging = null; // {type:'palette'|'slot', index, offsetX, offsetY}
  let mouse = { x: 0, y: 0, down: false };
  let finished = false;
  let lastUpdateTime = 0;
  let animationOffset = 0;
  let ariaLive; // hidden element for screen reader updates
  let showAudioDisabledMessage = false;

  // Utility: safe text drawing for accessibility / high contrast
  function drawText(ctx, text, x, y, size = 16, color = COLOR_TEXT, align = 'left') {
    ctx.fillStyle = color;
    ctx.font = `${size}px system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial`;
    ctx.textAlign = align;
    ctx.fillText(text, x, y);
  }

  // Initialize the game
  function init() {
    try {
      container = document.getElementById(CONTAINER_ID);
      if (!container) {
        console.error('Game container not found:', CONTAINER_ID);
        return;
      }

      // Clear container
      container.innerHTML = '';
      container.style.position = 'relative';
      container.style.width = WIDTH + 'px';
      container.style.height = HEIGHT + 'px';
      container.setAttribute('role', 'application');
      container.setAttribute('aria-label', 'Machine Math game area');

      // Create canvas
      canvas = document.createElement('canvas');
      canvas.width = WIDTH;
      canvas.height = HEIGHT;
      canvas.style.width = WIDTH + 'px';
      canvas.style.height = HEIGHT + 'px';
      canvas.setAttribute('tabindex', '0'); // enable keyboard focus
      container.appendChild(canvas);
      ctx = canvas.getContext('2d', { alpha: false });

      // Create offscreen/invisible live region for screen readers
      ariaLive = document.createElement('div');
      ariaLive.setAttribute('aria-live', 'polite');
      ariaLive.setAttribute('aria-atomic', 'true');
      // visually hide but remain accessible
      Object.assign(ariaLive.style, {
        position: 'absolute',
        left: '0px',
        top: (HEIGHT + 2) + 'px',
        width: '1px',
        height: '1px',
        overflow: 'hidden',
        clip: 'rect(1px, 1px, 1px, 1px)',
        whiteSpace: 'nowrap'
      });
      container.appendChild(ariaLive);

      // Setup audio
      try {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (!AudioContext) throw new Error('Web Audio API not supported');
        audioCtx = new AudioContext();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.18; // gentle background + effects
        masterGain.connect(audioCtx.destination);

        // gentle background hum using oscillator + lowpass
        bgOsc = audioCtx.createOscillator();
        bgOsc.type = 'sine';
        bgOsc.frequency.value = 110; // low tone
        const bgGain = audioCtx.createGain();
        bgGain.gain.value = 0.03;
        const bgFilter = audioCtx.createBiquadFilter();
        bgFilter.type = 'lowpass';
        bgFilter.frequency.value = 600;

        lfo = audioCtx.createOscillator();
        lfo.frequency.value = 0.12; // slow wobble
        const lfoGain = audioCtx.createGain();
        lfoGain.gain.value = 40;
        lfo.connect(lfoGain);
        lfoGain.connect(bgOsc.frequency);

        bgOsc.connect(bgFilter);
        bgFilter.connect(bgGain);
        bgGain.connect(masterGain);

        bgOsc.start();
        lfo.start();
      } catch (err) {
        console.warn('Audio initialization failed:', err);
        audioAllowed = false;
        showAudioDisabledMessage = true;
      }

      // Event listeners
      canvas.addEventListener('mousedown', onMouseDown);
      canvas.addEventListener('mousemove', onMouseMove);
      canvas.addEventListener('mouseup', onMouseUp);
      canvas.addEventListener('mouseleave', onMouseUp);
      canvas.addEventListener('touchstart', onTouchStart, { passive: false });
      canvas.addEventListener('touchmove', onTouchMove, { passive: false });
      canvas.addEventListener('touchend', onTouchEnd);
      canvas.addEventListener('keydown', onKeyDown);
      canvas.addEventListener('focus', () => {
        // Provide instructions when focused
        announce('Canvas focused. Use number keys to pick parts, arrow keys to move slots, Enter to place, M to mute.');
      });

      // Start
      resetGame();
      lastUpdateTime = performance.now();
      requestAnimationFrame(loop);
    } catch (err) {
      console.error('Initialization error:', err);
    }
  }

  // Reset game state for new playthrough
  function resetGame() {
    level = 1;
    score = 0;
    finished = false;
    prepareLevel();
  }

  // Prepare parts and slots making sure level is solvable
  function prepareLevel() {
    // Determine slot count and target complexity
    const slotCount = SLOT_COUNT_BASE + Math.floor((level - 1) / 1); // increase occasionally
    const partCount = PALETTE_SIZE;
    const minValue = 1 + Math.floor((level - 1) * 0.5);
    const maxValue = 6 + level; // increase max
    // Create a guaranteed solution: pick random numbers that sum to target
    const solutionParts = [];
    // We ensure the solution uses between 2 and slotCount parts
    const solutionLen = Math.min(slotCount, 2 + (level % slotCount));
    // Choose target by summing random ints
    let chosenTarget = 0;
    for (let i = 0; i < solutionLen; i++) {
      const v = randInt(minValue, Math.max(minValue + 1, maxValue));
      solutionParts.push(v);
      chosenTarget += v;
    }
    // Now create palette parts: include solution parts plus decoys
    const palette = [];
    // Add solution parts as separate items
    for (let v of solutionParts) {
      palette.push({ value: v, id: uniqueId() });
    }
    // Add decoys ensuring not to accidentally provide extra solution combinations that break challenge
    while (palette.length < partCount) {
      let v = randInt(minValue, maxValue);
      // avoid exact duplication too often: allow duplicates but ensure not too many
      if (palette.filter(p => p.value === v).length < 3) {
        palette.push({ value: v, id: uniqueId() });
      } else {
        // pick different
        v = randInt(minValue, maxValue);
        palette.push({ value: v, id: uniqueId() });
      }
    }
    // Shuffle palette
    shuffleArray(palette);
    // Create parts with positions in palette area (left side)
    parts = palette.map((p, i) => {
      return {
        id: p.id,
        value: p.value,
        x: 24,
        y: 120 + i * 60,
        w: 92,
        h: 44,
        placed: false
      };
    });
    // Create slots on machine area (right side)
    slots = [];
    const slotStartX = 380;
    const slotStartY = 140;
    const slotGap = 74;
    for (let i = 0; i < slotCount; i++) {
      slots.push({
        index: i,
        x: slotStartX + (i % 3) * 110,
        y: slotStartY + Math.floor(i / 3) * slotGap,
        w: 96,
        h: 56,
        part: null // will hold part id
      });
    }
    target = chosenTarget;
    currentSum = 0;
    selectedPaletteIndex = 0;
    focusedSlotIndex = 0;
    announce(`Level ${level}. Make the machine show ${target} by placing parts. Use numbers keys to pick parts and Enter to place.`);
  }

  // Unique ID generator
  function uniqueId() {
    return Math.random().toString(36).slice(2, 9);
  }

  // Random integer inclusive
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // Shuffle array
  function shuffleArray(a) {
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
  }

  // Main loop and render
  function loop(ts) {
    const dt = (ts - lastUpdateTime) / 1000;
    lastUpdateTime = ts;
    animationOffset += dt * 30;
    draw();
    requestAnimationFrame(loop);
  }

  // Draw entire scene
  function draw() {
    // Clear background
    ctx.fillStyle = COLOR_BG;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Gentle moving clouds / machine background shapes
    drawBackgroundShapes();

    // Draw title and instructions
    drawHeader();

    // Draw left palette of parts
    drawPalette();

    // Draw machine with slots and gears
    drawMachine();

    // Draw footer: level, score, target and sum
    drawFooter();

    // Draw audio icon
    drawAudioIcon();

    // Draw accessibility cues (outline if audio disabled)
    if (showAudioDisabledMessage) {
      // show small alert box
      ctx.fillStyle = 'rgba(255, 240, 220, 0.9)';
      ctx.fillRect(12, HEIGHT - 74, 320, 52);
      ctx.strokeStyle = '#B35A4A';
      ctx.strokeRect(12, HEIGHT - 74, 320, 52);
      drawText(ctx, 'Audio is unavailable. Use M to toggle sound if your browser allows it.', 20, HEIGHT - 46, 14, '#442211');
    }
  }

  // Draw decorative background shapes - wacky, calming machines
  function drawBackgroundShapes() {
    // Soft large rounded shapes
    ctx.save();
    const t = animationOffset;
    ctx.globalAlpha = 0.65;
    ctx.fillStyle = '#CFECE9';
    roundRect(ctx, 40 + Math.sin(t * 0.2) * 6, 30 + Math.cos(t * 0.12) * 6, 260, 92, 16);
    ctx.fill();
    ctx.fillStyle = '#DDEBF3';
    roundRect(ctx, 360 + Math.cos(t * 0.15) * 4, 24 + Math.sin(t * 0.08) * 6, 320, 116, 18);
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.restore();

    // Wacky little bolts and chips
    for (let i = 0; i < 6; i++) {
      drawBolt(520 + 40 * Math.cos(t * 0.2 + i), 80 + 18 * Math.sin(t * 0.15 + i), 10 + (i % 3));
    }
  }

  function drawBolt(x, y, s) {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = '#F7E6C3';
    ctx.beginPath();
    ctx.moveTo(0, -s * 1.2);
    for (let j = 0; j < 8; j++) {
      ctx.rotate(Math.PI / 4);
      ctx.lineTo(0, -s * (j % 2 ? 0.75 : 1.12));
    }
    ctx.fill();
    ctx.restore();
  }

  // Draw title and small instructions
  function drawHeader() {
    drawText(ctx, 'Machine Math', 24, 40, 26, COLOR_ACCENT);
    drawText(ctx, 'Fix the friendly machine by placing number parts that add to the target.', 24, 64, 14, '#405063');
    drawText(ctx, 'Controls: Number keys to pick parts, Enter to place, Click/drag allowed. M toggles sound.', 24, 84, 12, '#405063');
  }

  function drawFooter() {
    // Panel with level, score, target and sum
    ctx.save();
    ctx.fillStyle = '#FFFFFFCC';
    roundRect(ctx, 12, HEIGHT - 86, WIDTH - 24, 68, 10);
    ctx.fill();

    // Level and score
    drawText(ctx, `Level: ${level} / ${MAX_LEVELS}`, 28, HEIGHT - 50, 16, COLOR_TEXT);
    drawText(ctx, `Score: ${score}`, 168, HEIGHT - 50, 16, COLOR_TEXT);

    // Target and sum in machine style
    ctx.fillStyle = '#F0F6F5';
    roundRect(ctx, 320, HEIGHT - 80, 380, 56, 8);
    ctx.fill();

    drawText(ctx, `Target: ${target}`, 340, HEIGHT - 50, 18, '#1F3B3A');
    drawText(ctx, `Current sum: ${currentSum}`, 540, HEIGHT - 50, 18, '#1F3B3A');

    ctx.restore();
  }

  // Draw palette list of parts
  function drawPalette() {
    drawText(ctx, 'Parts', 24, 108, 18, '#2F4A4A');

    for (let i = 0; i < parts.length; i++) {
      const p = parts[i];
      // If part is placed, draw faded
      ctx.save();
      const isSelected = i === selectedPaletteIndex && !dragging;
      ctx.globalAlpha = p.placed ? 0.3 : 1.0;
      // palette background
      ctx.fillStyle = isSelected ? '#FFF6EA' : COLOR_PART;
      roundRect(ctx, p.x, p.y, p.w, p.h, 8);
      ctx.fill();
      // number circle
      ctx.fillStyle = '#FFFBF6';
      ctx.beginPath();
      ctx.arc(p.x + 44, p.y + p.h / 2, 18, 0, Math.PI * 2);
      ctx.fill();
      // gear doodle behind number
      drawSmallGear(p.x + 44, p.y + p.h / 2, 8, '#E3E3E3', animationOffset * 0.2 + i);
      // number text
      drawText(ctx, `${p.value}`, p.x + 44, p.y + p.h / 2 + 6, 18, '#3A3840', 'center');

      // keyboard hint
      drawText(ctx, `${i + 1}`, p.x + p.w - 18, p.y + p.h - 6, 12, '#6D6D6D', 'center');

      ctx.restore();
    }
  }

  // Draw small decorative gear
  function drawSmallGear(cx, cy, r, color, rotation = 0) {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(rotation * 0.1);
    ctx.fillStyle = color;
    for (let i = 0; i < 8; i++) {
      ctx.rotate(Math.PI / 4);
      ctx.fillRect(r * 0.8, -r * 0.2, r * 0.5, r * 0.4);
    }
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.6, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.fillStyle = '#AAB9B7';
    ctx.arc(0, 0, r * 0.28, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  // Draw main machine area with slots
  function drawMachine() {
    // machine body
    ctx.save();
    ctx.fillStyle = '#F7FBFB';
    roundRect(ctx, 340, 110, 360, 220, 18);
    ctx.fill();

    // wacky display showing target (big gear)
    drawGearDisplay(480, 180, 70, target, '#9FC7C1');

    // slots
    for (let i = 0; i < slots.length; i++) {
      const s = slots[i];
      ctx.save();
      // slot background
      ctx.fillStyle = '#F2F6F6';
      roundRect(ctx, s.x, s.y, s.w, s.h, 10);
      ctx.fill();

      // focus highlight
      if (i === focusedSlotIndex) {
        ctx.strokeStyle = '#7AA5A2';
        ctx.lineWidth = 2;
        ctx.strokeRect(s.x - 2, s.y - 2, s.w + 4, s.h + 4);
      }

      // if there's a placed part, draw it inside slot
      if (s.part) {
        const part = parts.find(p => p.id === s.part);
        if (part) {
          ctx.fillStyle = '#FFF8F2';
          roundRect(ctx, s.x + 10, s.y + 6, s.w - 20, s.h - 12, 8);
          ctx.fill();
          drawText(ctx, `${part.value}`, s.x + s.w / 2, s.y + s.h / 2 + 6, 18, '#333333', 'center');
          // little connector drawing
          ctx.strokeStyle = '#D2E2E0';
          ctx.beginPath();
          ctx.moveTo(s.x + s.w / 2, s.y - 8);
          ctx.lineTo(s.x + s.w / 2, s.y + s.h + 4);
          ctx.stroke();
        }
      } else {
        // placeholder text
        drawText(ctx, 'slot', s.x + 12, s.y + s.h / 2 + 6, 12, '#B2B9B8');
      }

      ctx.restore();
    }

    // Wacky levers and pipes
    drawPipe(420, 240, 540, 320);
    ctx.restore();
  }

  // Gear display for the target
  function drawGearDisplay(cx, cy, r, number, color) {
    // big gear
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(animationOffset * 0.03);
    // teeth
    ctx.fillStyle = color;
    for (let i = 0; i < 12; i++) {
      ctx.rotate((Math.PI * 2) / 12);
      ctx.beginPath();
      ctx.rect(r - 10, -6, 12, 12);
      ctx.fill();
    }
    // center
    ctx.beginPath();
    ctx.arc(0, 0, r - 20, 0, Math.PI * 2);
    ctx.fill();
    // number
    drawText(ctx, `${number}`, 0, 8, 26, COLOR_ACCENT, 'center');
    ctx.restore();
  }

  // Draw a pipe between points with decoration
  function drawPipe(x1, y1, x2, y2) {
    ctx.save();
    ctx.strokeStyle = '#D7E7E6';
    ctx.lineWidth = 12;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    const mx = (x1 + x2) / 2;
    ctx.quadraticCurveTo(mx, y1 + 40, x2, y2);
    ctx.stroke();

    // small bolts along pipe
    ctx.fillStyle = '#E8F2F1';
    for (let t = 0; t < 1; t += 0.18) {
      const px = x1 + (x2 - x1) * t;
      const py = y1 + (y2 - y1) * t + Math.sin(animationOffset * 0.4 + t * 10) * 6;
      ctx.beginPath();
      ctx.arc(px, py, 4, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  // Drawing audio icon and state
  function drawAudioIcon() {
    const x = WIDTH - AUDIO_ICON_SIZE - 12;
    const y = 12;
    ctx.save();
    ctx.fillStyle = audioAllowed ? '#7BA89E' : '#CBB0A6';
    roundRect(ctx, x - 6, y - 6, AUDIO_ICON_SIZE + 12, AUDIO_ICON_SIZE + 12, 8);
    ctx.fill();
    // speaker icon
    ctx.fillStyle = '#FFF';
    ctx.beginPath();
    ctx.moveTo(x + 6, y + 10);
    ctx.lineTo(x + 16, y + 6);
    ctx.lineTo(x + 16, y + 22);
    ctx.closePath();
    ctx.fill();
    // waves or muted cross
    if (audioAllowed) {
      ctx.strokeStyle = '#FFF';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x + 18, y + 14, 8, -0.7, 0.7);
      ctx.stroke();
    } else {
      ctx.strokeStyle = '#FFF';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x + 12, y + 8);
      ctx.lineTo(x + 24, y + 20);
      ctx.moveTo(x + 24, y + 8);
      ctx.lineTo(x + 12, y + 20);
      ctx.stroke();
    }
    ctx.restore();

    // clickable area: provide accessible label for screen readers via ariaLive when toggled
  }

  // Rectangle helper
  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  // Mouse and touch handling
  function onMouseDown(e) {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);
    mouse.down = true;
    mouse.x = x;
    mouse.y = y;
    // check palette parts hit
    for (let i = 0; i < parts.length; i++) {
      const p = parts[i];
      if (!p.placed && hitTest(x, y, p.x, p.y, p.w, p.h)) {
        dragging = { type: 'palette', index: i, offsetX: x - p.x, offsetY: y - p.y };
        selectedPaletteIndex = i;
        // visual immediate pick
        playPlaceSound();
        return;
      }
    }
    // check placed parts to remove (click a slot)
    for (let i = 0; i < slots.length; i++) {
      const s = slots[i];
      if (hitTest(x, y, s.x, s.y, s.w, s.h) && s.part) {
        // remove
        const part = parts.find(p => p.id === s.part);
        if (part) {
          part.placed = false;
          // return to palette location
          // find an available palette spot index for this part to place visually near original spot
          const idx = parts.findIndex(p => p.id === part.id);
          parts[idx].x = 24;
          parts[idx].y = 120 + idx * 60;
        }
        s.part = null;
        updateSum();
        playIncorrectSound(); // gentle error / undo sound
        announce(`Removed part. Current sum ${currentSum}.`);
        return;
      }
    }
    // check audio icon click
    const ax = WIDTH - AUDIO_ICON_SIZE - 12;
    const ay = 12;
    if (hitTest(x, y, ax - 6, ay - 6, AUDIO_ICON_SIZE + 12, AUDIO_ICON_SIZE + 12)) {
      toggleAudio();
      return;
    }
  }

  function onMouseMove(e) {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);
    mouse.x = x;
    mouse.y = y;
    if (dragging) {
      // move part with mouse
      const p = parts[dragging.index];
      p.x = x - dragging.offsetX;
      p.y = y - dragging.offsetY;
    }
  }

  function onMouseUp(e) {
    mouse.down = false;
    if (dragging) {
      placeDraggingPart(dragging);
      dragging = null;
    }
  }

  // Touch wrappers
  function onTouchStart(e) {
    e.preventDefault();
    if (e.touches.length > 0) {
      const t = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = (t.clientX - rect.left) * (canvas.width / rect.width);
      const y = (t.clientY - rect.top) * (canvas.height / rect.height);
      mouse.down = true;
      mouse.x = x;
      mouse.y = y;
      // emulate mousedown
      onMouseDown({ clientX: t.clientX, clientY: t.clientY });
    }
  }

  function onTouchMove(e) {
    e.preventDefault();
    if (e.touches.length > 0) {
      const t = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = (t.clientX - rect.left) * (canvas.width / rect.width);
      const y = (t.clientY - rect.top) * (canvas.height / rect.height);
      // emulate mousemove
      onMouseMove({ clientX: t.clientX, clientY: t.clientY });
    }
  }

  function onTouchEnd(e) {
    e.preventDefault();
    mouse.down = false;
    if (dragging) {
      placeDraggingPart(dragging);
      dragging = null;
    }
  }

  // Place a dragged part into nearest slot if valid
  function placeDraggingPart(dragInfo) {
    const p = parts[dragInfo.index];
    // check collision with any slot
    for (let i = 0; i < slots.length; i++) {
      const s = slots[i];
      if (hitTest(mouse.x, mouse.y, s.x, s.y, s.w, s.h)) {
        if (s.part) {
          // slot occupied: reject
          playIncorrectSound();
          announce(`That slot already has a part. Try another slot.`);
          // return part to original palette position
          resetPartPosition(dragInfo.index);
          return;
        } else {
          // place part
          p.placed = true;
          s.part = p.id;
          // snap part into slot
          p.x = s.x + 10;
          p.y = s.y + 6;
          updateSum();
          playPlaceSound();
          announce(`Placed ${p.value}. Current sum ${currentSum}.`);
          checkForLevelComplete();
          return;
        }
      }
    }
    // if no slot, return to palette position
    resetPartPosition(dragInfo.index);
    playIncorrectSound();
  }

  function resetPartPosition(index) {
    parts[index].x = 24;
    parts[index].y = 120 + index * 60;
  }

  function hitTest(px, py, x, y, w, h) {
    return px >= x && px <= x + w && py >= y && py <= y + h;
  }

  // Keyboard handling
  function onKeyDown(e) {
    // ensure the canvas is focused
    // Number keys: choose part 1..n
    if (e.key >= '1' && e.key <= String(parts.length)) {
      const idx = parseInt(e.key, 10) - 1;
      if (parts[idx] && !parts[idx].placed) {
        selectedPaletteIndex = idx;
        announce(`Selected part ${parts[idx].value}. Use Enter to place in the focused slot.`);
        playPlaceSound();
      } else {
        announce('Part already used or not available.');
        playIncorrectSound();
      }
      e.preventDefault();
      return;
    }

    switch (e.key) {
      case 'ArrowRight':
        focusedSlotIndex = (focusedSlotIndex + 1) % slots.length;
        announce(`Focused slot ${focusedSlotIndex + 1}.`);
        e.preventDefault();
        break;
      case 'ArrowLeft':
        focusedSlotIndex = (focusedSlotIndex - 1 + slots.length) % slots.length;
        announce(`Focused slot ${focusedSlotIndex + 1}.`);
        e.preventDefault();
        break;
      case 'ArrowDown':
        // move focus roughly to next slot
        focusedSlotIndex = Math.min(slots.length - 1, focusedSlotIndex + 1);
        announce(`Focused slot ${focusedSlotIndex + 1}.`);
        e.preventDefault();
        break;
      case 'ArrowUp':
        focusedSlotIndex = Math.max(0, focusedSlotIndex - 1);
        announce(`Focused slot ${focusedSlotIndex + 1}.`);
        e.preventDefault();
        break;
      case 'Enter':
        // try to place selected palette item into focused slot
        const p = parts[selectedPaletteIndex];
        if (!p) {
          announce('No part selected.');
          playIncorrectSound();
        } else if (p.placed) {
          announce('Selected part is already placed. Pick another part.');
          playIncorrectSound();
        } else {
          const s = slots[focusedSlotIndex];
          if (s.part) {
            announce('Focused slot is already occupied.');
            playIncorrectSound();
          } else {
            // place
            p.placed = true;
            s.part = p.id;
            p.x = s.x + 10;
            p.y = s.y + 6;
            updateSum();
            playPlaceSound();
            announce(`Placed ${p.value}. Current sum ${currentSum}.`);
            checkForLevelComplete();
          }
        }
        e.preventDefault();
        break;
      case 'Backspace':
      case 'Delete':
        // remove from focused slot if any
        const s = slots[focusedSlotIndex];
        if (s.part) {
          const part = parts.find(p => p.id === s.part);
          if (part) {
            part.placed = false;
            part.x = 24;
            part.y = 120 + parts.findIndex(pp => pp.id === part.id) * 60;
          }
          s.part = null;
          updateSum();
          announce(`Removed part from slot ${focusedSlotIndex + 1}. Current sum ${currentSum}.`);
          playIncorrectSound();
        } else {
          announce('No part in the focused slot to remove.');
        }
        e.preventDefault();
        break;
      case 'm':
      case 'M':
        toggleAudio();
        e.preventDefault();
        break;
      case 'h':
      case 'H':
        announce('Help: choose parts using number keys and place them using Enter. Remove with Delete. You can also click and drag parts.');
        e.preventDefault();
        break;
      default:
        break;
    }
  }

  function toggleAudio() {
    if (!audioCtx) {
      // try to create audio context again (some browsers require user gesture)
      try {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (!AudioContext) throw new Error('Web Audio API not supported');
        audioCtx = new AudioContext();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.18;
        masterGain.connect(audioCtx.destination);
        bgOsc = audioCtx.createOscillator();
        bgOsc.type = 'sine';
        bgOsc.frequency.value = 110;
        const bgGain = audioCtx.createGain();
        bgGain.gain.value = 0.03;
        const bgFilter = audioCtx.createBiquadFilter();
        bgFilter.type = 'lowpass';
        bgFilter.frequency.value = 600;
        lfo = audioCtx.createOscillator();
        lfo.frequency.value = 0.12;
        const lfoGain = audioCtx.createGain();
        lfoGain.gain.value = 40;
        lfo.connect(lfoGain);
        lfoGain.connect(bgOsc.frequency);
        bgOsc.connect(bgFilter);
        bgFilter.connect(bgGain);
        bgGain.connect(masterGain);
        bgOsc.start();
        lfo.start();
        audioAllowed = true;
      } catch (err) {
        audioAllowed = false;
        showAudioDisabledMessage = true;
        announce('Audio is not available in this browser.');
        return;
      }
    } else {
      audioAllowed = !audioAllowed;
      if (!audioAllowed) {
        // mute
        if (masterGain) masterGain.gain.value = 0;
      } else {
        if (masterGain) masterGain.gain.value = 0.18;
      }
    }
    announce(audioAllowed ? 'Audio on' : 'Audio muted');
  }

  // Update current sum based on placed parts
  function updateSum() {
    let sum = 0;
    for (let s of slots) {
      if (s.part) {
        const p = parts.find(pp => pp.id === s.part);
        if (p) sum += p.value;
      }
    }
    currentSum = sum;
  }

  // Check if the level is complete or impossible
  function checkForLevelComplete() {
    if (currentSum === target) {
      // success
      score += 10 * level;
      playCorrectSequence();
      announce(`Great! Level ${level} complete. Score ${score}.`);
      // proceed to next after short delay
      setTimeout(() => {
        level++;
        if (level > MAX_LEVELS) {
          finished = true;
          announce(`You fixed all the machines! Final score ${score}. Press R to play again.`);
          // Offer restart via keypress - attach temporary handler
          window.addEventListener('keydown', onRestartKey);
        } else {
          prepareLevel();
        }
      }, 900);
    } else if (currentSum > target) {
      // too much
      playIncorrectSound();
      announce(`Oops! The machine is overloaded. Current sum ${currentSum}. Try removing or placing smaller parts.`);
    } else {
      // still less than target - encourage
      playPlaceSound();
    }
  }

  // Restart handler for final screen
  function onRestartKey(e) {
    if (e.key.toLowerCase() === 'r') {
      window.removeEventListener('keydown', onRestartKey);
      resetGame();
    }
  }

  // Accessibility: announce text to screen readers
  function announce(text) {
    if (!ariaLive) return;
    ariaLive.textContent = text;
    // also console log for debugging
    console.log('ANNOUNCE:', text);
  }

  // Audio: play short tone for placing parts
  function playPlaceSound() {
    if (!audioAllowed || !audioCtx) return;
    try {
      const o = audioCtx.createOscillator();
      o.type = 'triangle';
      o.frequency.value = 440 + Math.random() * 30;
      const g = audioCtx.createGain();
      g.gain.value = 0.0001;
      o.connect(g);
      g.connect(masterGain);
      const now = audioCtx.currentTime;
      g.gain.cancelScheduledValues(now);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.linearRampToValueAtTime(0.06, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.26);
      o.start(now);
      o.stop(now + 0.27);
    } catch (err) {
      console.warn('Place sound failed', err);
    }
  }

  // Correct sequence: small arpeggio
  function playCorrectSequence() {
    if (!audioAllowed || !audioCtx) return;
    try {
      const base = 440;
      let t = audioCtx.currentTime;
      [0, 3, 6].forEach((step, i) => {
        const o = audioCtx.createOscillator();
        o.type = 'sine';
        o.frequency.value = base * Math.pow(2, step / 12);
        const g = audioCtx.createGain();
        g.gain.value = 0.0001;
        o.connect(g);
        g.connect(masterGain);
        const start = t + i * 0.12;
        g.gain.setValueAtTime(0.0001, start);
        g.gain.linearRampToValueAtTime(0.09, start + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, start + 0.12);
        o.start(start);
        o.stop(start + 0.14);
      });
    } catch (err) {
      console.warn('Correct sound failed', err);
    }
  }

  // Incorrect short buzzer
  function playIncorrectSound() {
    if (!audioAllowed || !audioCtx) return;
    try {
      const o = audioCtx.createOscillator();
      o.type = 'square';
      o.frequency.value = 220;
      const f = audioCtx.createBiquadFilter();
      f.type = 'lowpass';
      f.frequency.value = 1000;
      const g = audioCtx.createGain();
      g.gain.value = 0.0001;
      o.connect(f);
      f.connect(g);
      g.connect(masterGain);
      const now = audioCtx.currentTime;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.linearRampToValueAtTime(0.08, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.28);
      o.start(now);
      o.frequency.exponentialRampToValueAtTime(80, now + 0.18);
      o.stop(now + 0.32);
    } catch (err) {
      console.warn('Incorrect sound failed', err);
    }
  }

  // General correct tone (short)
  function playCorrectTone() {
    if (!audioAllowed || !audioCtx) return;
    try {
      const o = audioCtx.createOscillator();
      o.type = 'sine';
      o.frequency.value = 660;
      const g = audioCtx.createGain();
      g.gain.value = 0.0001;
      o.connect(g);
      g.connect(masterGain);
      const now = audioCtx.currentTime;
      g.gain.linearRampToValueAtTime(0.08, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.2);
      o.start(now);
      o.stop(now + 0.22);
    } catch (err) {
      console.warn('Correct tone failed', err);
    }
  }

  // small beep reused
  function playBeep(freq = 440, duration = 0.12) {
    if (!audioAllowed || !audioCtx) return;
    try {
      const o = audioCtx.createOscillator();
      o.type = 'sine';
      o.frequency.value = freq;
      const g = audioCtx.createGain();
      g.gain.value = 0.0001;
      o.connect(g);
      g.connect(masterGain);
      const now = audioCtx.currentTime;
      g.gain.linearRampToValueAtTime(0.06, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);
      o.start(now);
      o.stop(now + duration + 0.02);
    } catch (err) {
      console.warn('Beep failed', err);
    }
  }

  // small happy sound
  function playPlaceHappy() {
    if (!audioAllowed || !audioCtx) return;
    playBeep(520, 0.08);
    setTimeout(() => playBeep(620, 0.1), 100);
  }

  // Convenience to indicate place sound used earlier alias
  function playPlaceSound() {
    playBeep(480 + Math.random() * 80, 0.12);
  }

  // Window load safe init
  if (document.readyState === 'loading') {
    window.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
---

