{
  "generated_date": "2025-11-21",
  "generated_timestamp": "2025-11-21T00:27:58.607656",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8995,
  "game_filename": "2025-11-21.js",
  "game_size_bytes": 26338,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Drone Math Game for ages 7-9\n  // Renders into element with id 'game-of-the-day-stage'.\n  // All graphics via canvas. Sounds via Web Audio API oscillators.\n  // Clear win: score >= TARGET_SCORE. Loss: wrong >= MAX_WRONG.\n  // Accessible via keyboard and mouse. Includes instructions and restart.\n\n  // Config\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const PADDING = 12; // >=10 px padding\n  const TARGET_SCORE = 10; // goal to win\n  const MAX_WRONG = 3; // lives before game over\n  const FONT_BODY = \"16px sans-serif\"; // >=14px\n  const FONT_IMPORTANT = \"22px bold sans-serif\"; // >=18px\n  const CHOICE_FONT = \"18px sans-serif\";\n  const FRAME_RATE_MS = 1000 / 60;\n\n  // Find container\n  const container = document.getElementById(\"game-of-the-day-stage\");\n  if (!container) {\n    throw new Error(\"Container element with id 'game-of-the-day-stage' not found.\");\n  }\n  container.innerHTML = \"\"; // clear\n  container.style.position = \"relative\";\n  container.setAttribute(\"role\", \"application\");\n  container.setAttribute(\"aria-label\", \"Drone math game. Answer simple math questions to collect stars. Use number keys 1-4 to choose answers.\");\n  container.tabIndex = 0;\n\n  // Create live region for screen readers\n  const liveRegion = document.createElement(\"div\");\n  liveRegion.setAttribute(\"aria-live\", \"polite\");\n  liveRegion.style.position = \"absolute\";\n  liveRegion.style.left = \"-9999px\";\n  liveRegion.style.top = \"auto\";\n  liveRegion.style.width = \"1px\";\n  liveRegion.style.height = \"1px\";\n  liveRegion.style.overflow = \"hidden\";\n  container.appendChild(liveRegion);\n\n  // Create canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.display = \"block\";\n  canvas.style.background = \"#e6f2ff\"; // calming sky-blue\n  canvas.style.border = \"1px solid #333\";\n  container.appendChild(canvas);\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    throw new Error(\"2D context not available.\");\n  }\n\n  // Audio setup with error handling\n  let audioCtx = null;\n  let bgGain = null;\n  let bgOsc = null;\n  let audioEnabled = false;\n\n  function tryCreateAudioContext() {\n    if (audioCtx) return;\n    try {\n      const AC = window.AudioContext || window.webkitAudioContext;\n      if (!AC) {\n        console.warn(\"Web Audio API not supported in this browser.\");\n        return;\n      }\n      audioCtx = new AC();\n      // create gentle background hum\n      bgGain = audioCtx.createGain();\n      bgGain.gain.value = 0.02; // very gentle\n      bgGain.connect(audioCtx.destination);\n      bgOsc = audioCtx.createOscillator();\n      bgOsc.type = \"sine\";\n      bgOsc.frequency.value = 110; // low hum\n      const bgFilter = audioCtx.createBiquadFilter();\n      bgFilter.type = \"lowpass\";\n      bgFilter.frequency.value = 600;\n      bgOsc.connect(bgFilter);\n      bgFilter.connect(bgGain);\n      bgOsc.start();\n      // start muted until audioEnabled true\n      bgGain.gain.value = 0;\n    } catch (e) {\n      console.warn(\"Audio context failed to initialize:\", e);\n      audioCtx = null;\n    }\n  }\n\n  // Call on user gesture\n  function resumeAudioIfNeeded() {\n    tryCreateAudioContext();\n    if (audioCtx && audioCtx.state === \"suspended\") {\n      audioCtx.resume().catch((e) => console.warn(\"Audio resume failed:\", e));\n    }\n  }\n\n  // Play short sound effect (correct/wrong)\n  function playBeep({ type = \"correct\" } = {}) {\n    if (!audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const osc = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n      const filter = audioCtx.createBiquadFilter();\n      filter.type = \"highpass\";\n      filter.frequency.value = 200;\n      osc.connect(filter);\n      filter.connect(gain);\n      gain.connect(audioCtx.destination);\n      if (type === \"correct\") {\n        osc.type = \"triangle\";\n        osc.frequency.setValueAtTime(880, now);\n        osc.frequency.exponentialRampToValueAtTime(440, now + 0.18);\n        gain.gain.setValueAtTime(0.0001, now);\n        gain.gain.exponentialRampToValueAtTime(0.12, now + 0.02);\n        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);\n      } else {\n        osc.type = \"square\";\n        osc.frequency.setValueAtTime(220, now);\n        osc.frequency.exponentialRampToValueAtTime(80, now + 0.25);\n        gain.gain.setValueAtTime(0.0001, now);\n        gain.gain.exponentialRampToValueAtTime(0.08, now + 0.02);\n        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.45);\n      }\n      osc.start(now);\n      osc.stop(now + 0.5);\n    } catch (e) {\n      console.warn(\"playBeep failed:\", e);\n    }\n  }\n\n  function setBackgroundSound(on) {\n    tryCreateAudioContext();\n    if (!audioCtx || !bgGain) {\n      audioEnabled = false;\n      return;\n    }\n    if (on) {\n      audioEnabled = true;\n      // fade in\n      bgGain.gain.cancelScheduledValues(audioCtx.currentTime);\n      bgGain.gain.setValueAtTime(bgGain.gain.value, audioCtx.currentTime);\n      bgGain.gain.linearRampToValueAtTime(0.02, audioCtx.currentTime + 0.5);\n    } else {\n      audioEnabled = false;\n      bgGain.gain.cancelScheduledValues(audioCtx.currentTime);\n      bgGain.gain.setValueAtTime(bgGain.gain.value, audioCtx.currentTime);\n      bgGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);\n    }\n  }\n\n  // Game state\n  let score = 0;\n  let wrong = 0;\n  let question = null;\n  let choices = [];\n  let selectedChoice = 0;\n  let gameState = \"playing\"; // playing, won, lost\n  let drone = {\n    x: WIDTH / 2,\n    y: 150,\n    targetX: WIDTH / 2,\n    targetY: 150,\n    vx: 0,\n    vy: 0,\n    w: 70,\n    h: 36,\n    bobOffset: 0,\n    bobDir: 1,\n  };\n  let flyAnim = null;\n  let lastTick = performance.now();\n\n  // Accessibility announcement\n  function announce(text) {\n    liveRegion.textContent = text;\n  }\n\n  // Utilities\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  function clamp(v, a, b) {\n    return Math.max(a, Math.min(b, v));\n  }\n\n  // Generate a simple math question appropriate for 7-9\n  function generateQuestion() {\n    // choose operation weighted: addition/subtraction mostly, some multiplication\n    const opRoll = Math.random();\n    let a, b, op, answer;\n    if (opRoll < 0.55) {\n      // addition\n      a = randInt(1, 20);\n      b = randInt(1, 20);\n      op = \"+\";\n      answer = a + b;\n    } else if (opRoll < 0.9) {\n      // subtraction but ensure non-negative\n      a = randInt(1, 20);\n      b = randInt(1, a);\n      op = \"-\";\n      answer = a - b;\n    } else {\n      // multiplication small\n      a = randInt(2, 8);\n      b = randInt(2, 8);\n      op = \"\u00d7\";\n      answer = a * b;\n    }\n    return { a, b, op, answer };\n  }\n\n  function generateChoices(correct) {\n    const set = new Set();\n    set.add(correct);\n    while (set.size < 4) {\n      // generate plausible distractors\n      const offset = randInt(-6, 8);\n      let cand = correct + offset;\n      if (Math.random() < 0.1) cand = correct + (Math.random() < 0.5 ? 10 : -10);\n      if (cand < 0) cand = Math.abs(cand) + 1;\n      set.add(cand);\n    }\n    const arr = Array.from(set);\n    // shuffle\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    return arr;\n  }\n\n  function nextQuestion() {\n    question = generateQuestion();\n    choices = generateChoices(question.answer);\n    selectedChoice = 0;\n    // assign random target positions for packages (choices)\n    // but keep layout consistent horizontally\n    // announce\n    announce(`New question: ${question.a} ${question.op} ${question.b}. Press 1 to 4 to choose.`);\n  }\n\n  // Initialize\n  function resetGame() {\n    score = 0;\n    wrong = 0;\n    gameState = \"playing\";\n    drone.x = WIDTH / 2;\n    drone.y = 150;\n    drone.targetX = WIDTH / 2;\n    drone.targetY = 150;\n    setBackgroundSound(true); // start gentle hum (may require user gesture)\n    nextQuestion();\n    announce(`Game started. Answer ${TARGET_SCORE} questions correctly. You have ${MAX_WRONG} lives.`);\n  }\n\n  // Drawing helpers with measureText checks and background rectangles\n  function drawTextBox(x, y, text, font, textColor = \"#072\", bgColor = \"rgba(255,255,255,0.85)\") {\n    ctx.font = font;\n    const metrics = ctx.measureText(text);\n    const textW = metrics.width;\n    const textH = parseInt(font, 10) || 16;\n    const pad = 8;\n    const boxW = textW + pad * 2;\n    const boxH = textH + pad * 2;\n    ctx.fillStyle = bgColor;\n    ctx.fillRect(x, y, boxW, boxH);\n    ctx.fillStyle = textColor;\n    ctx.textBaseline = \"top\";\n    ctx.fillText(text, x + pad, y + pad);\n    return { x, y, w: boxW, h: boxH };\n  }\n\n  // Drone drawing function (wacky and calming)\n  function drawDrone(x, y, w, h, label = \"\") {\n    // shadow\n    ctx.save();\n    ctx.beginPath();\n    ctx.ellipse(x, y + h / 1.8, w * 0.6, h * 0.3, 0, 0, Math.PI * 2);\n    ctx.fillStyle = \"rgba(0,0,0,0.12)\";\n    ctx.fill();\n    ctx.restore();\n\n    // body\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.fillStyle = \"#2b4a7a\"; // mellow navy\n    ctx.strokeStyle = \"#0f1e33\";\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.ellipse(0, 0, w / 2, h / 2, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n\n    // cockpit glass\n    ctx.beginPath();\n    ctx.fillStyle = \"#9fd7ff\";\n    ctx.ellipse(w * -0.12, -2, w * 0.28, h * 0.32, -0.2, 0, Math.PI * 2);\n    ctx.fill();\n\n    // propellers - wacky wobble\n    const t = performance.now() / 150;\n    for (let i = -1; i <= 1; i += 2) {\n      ctx.save();\n      ctx.translate((w / 2) * i, -h * 0.5);\n      ctx.rotate(Math.sin(t + i) * 0.8);\n      ctx.fillStyle = \"#c8f0ff\";\n      ctx.fillRect(-8, -2, 16, 4);\n      ctx.restore();\n    }\n\n    // little eyes\n    ctx.fillStyle = \"#091b30\";\n    ctx.beginPath();\n    ctx.arc(-w * 0.12, -2, 3, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(6, -3, 2.2, 0, Math.PI * 2);\n    ctx.fill();\n\n    // cargo hook\n    ctx.strokeStyle = \"#1b2b3f\";\n    ctx.beginPath();\n    ctx.moveTo(6, h / 2 - 2);\n    ctx.lineTo(6, h / 2 + 18);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.arc(6, h / 2 + 22, 6, 0, Math.PI);\n    ctx.stroke();\n\n    ctx.restore();\n\n    // label\n    if (label) {\n      ctx.font = \"12px sans-serif\";\n      const m = ctx.measureText(label);\n      ctx.fillStyle = \"#072\";\n      ctx.fillText(label, x - m.width / 2, y + h / 1.6);\n    }\n  }\n\n  // Draw package (choice)\n  function drawPackage(x, y, w, h, text, index, isSelected, isCorrectHint = false) {\n    ctx.save();\n    // base\n    ctx.fillStyle = isSelected ? \"#ffe6a9\" : \"#fff2dd\";\n    ctx.strokeStyle = \"#8b5e3c\";\n    ctx.lineWidth = 2;\n    ctx.fillRect(x - w / 2, y - h / 2, w, h);\n    ctx.strokeRect(x - w / 2, y - h / 2, w, h);\n    // tape\n    ctx.fillStyle = \"#c88222\";\n    ctx.fillRect(x - 6, y - h / 2, 12, h);\n    // label\n    ctx.fillStyle = \"#3a2b14\";\n    ctx.font = CHOICE_FONT;\n    ctx.textBaseline = \"middle\";\n    const textWidth = ctx.measureText(text).width;\n    // center text, but ensure fits\n    const maxTextW = w - 12;\n    let displayText = text;\n    if (textWidth > maxTextW) {\n      // truncate with ellipsis\n      while (ctx.measureText(displayText + \"...\").width > maxTextW && displayText.length > 0) {\n        displayText = displayText.slice(0, -1);\n      }\n      displayText = displayText + \"...\";\n    }\n    ctx.fillText(displayText, x - ctx.measureText(displayText).width / 2, y);\n    // index small\n    ctx.font = \"12px sans-serif\";\n    ctx.fillStyle = \"#0f2b3f\";\n    ctx.fillText(index + 1, x - w / 2 + 8, y - h / 2 + 12);\n    // highlight correct hint when game over\n    if (isCorrectHint) {\n      ctx.strokeStyle = \"rgba(0,150,0,0.8)\";\n      ctx.lineWidth = 3;\n      ctx.strokeRect(x - w / 2 + 4, y - h / 2 + 4, w - 8, h - 8);\n    }\n    ctx.restore();\n  }\n\n  // Positions for UI elements ensuring no overlap\n  function drawUI() {\n    // Score top-left\n    ctx.font = FONT_IMPORTANT;\n    const scoreText = `Score: ${score}/${TARGET_SCORE}`;\n    const scoreBox = drawTextBox(PADDING, PADDING, scoreText, FONT_IMPORTANT, \"#063\", \"rgba(255,255,255,0.9)\");\n\n    // Lives top-right\n    ctx.font = FONT_IMPORTANT;\n    const livesText = `Lives: ${Math.max(0, MAX_WRONG - wrong)}`;\n    const livesMetrics = ctx.measureText(livesText);\n    const livesW = livesMetrics.width + 8 * 2;\n    const livesX = WIDTH - PADDING - livesW;\n    drawTextBox(livesX, PADDING, livesText, FONT_IMPORTANT, \"#6a0222\", \"rgba(255,255,255,0.9)\");\n\n    // Audio toggle indicator next to lives (non-overlapping)\n    ctx.font = \"14px sans-serif\";\n    const audioText = `Sound: ${audioEnabled ? \"On (S)\" : \"Off (S)\"}`;\n    const audioW = ctx.measureText(audioText).width + 8 * 2;\n    const audioX = livesX - 10 - audioW;\n    drawTextBox(audioX, PADDING, audioText, \"14px sans-serif\", \"#07364d\", \"rgba(255,255,255,0.85)\");\n\n    // Question area centered under top bar\n    ctx.font = FONT_IMPORTANT;\n    const qText = `${question.a} ${question.op} ${question.b} = ?`;\n    ctx.font = FONT_IMPORTANT;\n    const qMetrics = ctx.measureText(qText);\n    const qW = qMetrics.width + 16;\n    const qX = (WIDTH - qW) / 2;\n    const qY = PADDING + 8;\n    // place question low enough to avoid UI top overlap: ensure qY + boxH < some value\n    drawTextBox(qX, qY + 40, qText, FONT_IMPORTANT, \"#05244a\", \"rgba(255,255,255,0.95)\");\n\n    // Instructions bottom-center\n    const instrText = \"Choose the correct package (1-4 or click). Press S to toggle sound. Press R to restart.\";\n    ctx.font = FONT_BODY;\n    const instrMetrics = ctx.measureText(instrText);\n    const instrW = Math.min(instrMetrics.width, WIDTH - PADDING * 2);\n    const instrX = (WIDTH - instrW) / 2;\n    const instrY = HEIGHT - PADDING - 40;\n    ctx.fillStyle = \"rgba(255,255,255,0.9)\";\n    ctx.fillRect(instrX - 6, instrY - 6, instrW + 12, 40);\n    ctx.fillStyle = \"#00324d\";\n    ctx.font = FONT_BODY;\n    ctx.textBaseline = \"top\";\n    // Wrap if necessary\n    const maxLineWidth = instrW;\n    const words = instrText.split(\" \");\n    let line = \"\";\n    let lineY = instrY + 4;\n    for (let w of words) {\n      const test = line ? line + \" \" + w : w;\n      if (ctx.measureText(test).width > maxLineWidth) {\n        ctx.fillText(line, instrX, lineY);\n        line = w;\n        lineY += 18;\n      } else {\n        line = test;\n      }\n    }\n    if (line) {\n      ctx.fillText(line, instrX, lineY);\n    }\n  }\n\n  function drawScene() {\n    // clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // sky gradient\n    const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    grad.addColorStop(0, \"#e6f2ff\");\n    grad.addColorStop(1, \"#f7fbff\");\n    ctx.fillStyle = grad;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // distant hills / city (wacky elements)\n    ctx.save();\n    ctx.fillStyle = \"#dceef8\";\n    ctx.beginPath();\n    ctx.ellipse(140, HEIGHT - 50, 220, 40, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.ellipse(560, HEIGHT - 70, 260, 45, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n\n    // draw drone (animated)\n    drawDrone(drone.x, drone.y + Math.sin(drone.bobOffset) * 6, drone.w, drone.h);\n\n    // packages (choices)\n    const baseY = 320;\n    const packageW = 140;\n    const packageH = 60;\n    const margin = 20;\n    const totalW = choices.length * packageW + (choices.length - 1) * margin;\n    const startX = (WIDTH - totalW) / 2 + packageW / 2;\n    // compute positions and draw\n    for (let i = 0; i < choices.length; i++) {\n      const x = startX + i * (packageW + margin);\n      const y = baseY + (i % 2 === 0 ? 8 : -8); // slight vertical wobble\n      const isSelected = i === selectedChoice;\n      const isCorrectHint = gameState !== \"playing\" && choices[i] === question.answer;\n      drawPackage(x, y, packageW, packageH, String(choices[i]), i, isSelected, isCorrectHint);\n    }\n\n    // draw UI elements (score, lives, instructions)\n    drawUI();\n\n    // Draw progress: stars collected as cute icons\n    const starStartX = PADDING;\n    const starY = PADDING + 60;\n    for (let i = 0; i < TARGET_SCORE; i++) {\n      const sX = starStartX + i * 18;\n      ctx.beginPath();\n      ctx.fillStyle = i < score ? \"#ffd200\" : \"#fff6cc\";\n      // simple star-like circle for simplicity\n      ctx.arc(sX, starY, 6, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.strokeStyle = \"#8b6b00\";\n      ctx.stroke();\n    }\n  }\n\n  function update(dt) {\n    // gentle bob\n    drone.bobOffset += dt * 0.01;\n\n    // smooth movement towards target\n    const dx = drone.targetX - drone.x;\n    const dy = drone.targetY - drone.y;\n    drone.vx = dx * 0.08;\n    drone.vy = dy * 0.08;\n    drone.x += drone.vx;\n    drone.y += drone.vy;\n  }\n\n  // Try to pick current selected choice (by index)\n  function pickChoice(index) {\n    if (gameState !== \"playing\") return;\n    if (!question) return;\n    index = clamp(index, 0, choices.length - 1);\n    selectedChoice = index;\n    // move drone to above package\n    const baseY = 320;\n    const packageW = 140;\n    const margin = 20;\n    const totalW = choices.length * packageW + (choices.length - 1) * margin;\n    const startX = (WIDTH - totalW) / 2 + packageW / 2;\n    const targetX = startX + index * (packageW + margin);\n    drone.targetX = targetX;\n    drone.targetY = 220; // hover higher, then descend when confirming\n\n    // on click we submit selection immediately\n  }\n\n  function submitChoice(index) {\n    if (gameState !== \"playing\") return;\n    pickChoice(index);\n    // small delay to let drone move visually (200ms) then evaluate\n    setTimeout(() => {\n      const chosen = choices[index];\n      if (chosen === question.answer) {\n        score += 1;\n        playBeep({ type: \"correct\" });\n        announce(`Correct! ${question.a} ${question.op} ${question.b} equals ${question.answer}. Score ${score} of ${TARGET_SCORE}.`);\n        // drone picks up a star and flies up wacky\n        rewardAnimation(index);\n      } else {\n        wrong += 1;\n        playBeep({ type: \"wrong\" });\n        announce(`Oops. ${question.a} ${question.op} ${question.b} is ${question.answer}. Lives left ${Math.max(0, MAX_WRONG - wrong)}.`);\n        // shake drone\n        wrongAnimation();\n        if (wrong >= MAX_WRONG) {\n          // game over\n          gameState = \"lost\";\n          announce(`Game over. You answered ${score} correctly. Press R to restart.`);\n          setBackgroundSound(false);\n        } else {\n          nextQuestion();\n        }\n      }\n      // check win\n      if (score >= TARGET_SCORE) {\n        gameState = \"won\";\n        announce(`Victory! You collected ${score} stars. Press R to play again.`);\n        setBackgroundSound(false);\n      }\n    }, 260);\n  }\n\n  // Animations for reward and wrong answers\n  function rewardAnimation(index) {\n    // Drone descends, attach star, fly up to celebrate\n    const baseY = 320;\n    const packageW = 140;\n    const margin = 20;\n    const totalW = choices.length * packageW + (choices.length - 1) * margin;\n    const startX = (WIDTH - totalW) / 2 + packageW / 2;\n    const px = startX + index * (packageW + margin);\n    const py = baseY;\n    // sequence: descend to py-10, then ascend with star and small spiral\n    let t = 0;\n    const dur = 900;\n    const startX0 = drone.x;\n    const startY0 = drone.y;\n    const start = performance.now();\n    function anim() {\n      const now = performance.now();\n      t = now - start;\n      const p = Math.min(1, t / dur);\n      if (p < 0.4) {\n        // move to package\n        drone.x = startX0 + (px - startX0) * (p / 0.4);\n        drone.y = startY0 + (py - 20 - startY0) * (p / 0.4);\n      } else {\n        // ascend\n        const pp = (p - 0.4) / 0.6;\n        // spiral up\n        drone.x = px + Math.sin(pp * Math.PI * 4) * 20 * (1 - pp);\n        drone.y = py - 60 * pp - 40 * pp * pp;\n      }\n      if (p < 1) {\n        flyAnim = requestAnimationFrame(anim);\n      } else {\n        cancelAnimationFrame(flyAnim);\n        flyAnim = null;\n        // mark score and continue\n        nextQuestion();\n      }\n    }\n    anim();\n  }\n\n  function wrongAnimation() {\n    // shake drone a bit\n    const startX0 = drone.x;\n    const startY0 = drone.y;\n    let t0 = performance.now();\n    const dur = 420;\n    function anim() {\n      const t = performance.now() - t0;\n      const p = Math.min(1, t / dur);\n      drone.x = startX0 + Math.sin(p * Math.PI * 8) * 10 * (1 - p);\n      drone.y = startY0 + Math.sin(p * Math.PI * 4) * 4 * (1 - p);\n      if (p < 1) {\n        requestAnimationFrame(anim);\n      } else {\n        // reset to hover spot and nextQuestion handled by caller\n        drone.targetX = WIDTH / 2;\n        drone.targetY = 150;\n      }\n    }\n    anim();\n  }\n\n  // Handle mouse clicks mapped to canvas coordinates\n  canvas.addEventListener(\"click\", (ev) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = ev.clientX - rect.left;\n    const my = ev.clientY - rect.top;\n    // If game over or won, check if restart button clicked\n    if (gameState !== \"playing\") {\n      // check restart button area: center rect\n      const btnW = 260;\n      const btnH = 54;\n      const btnX = (WIDTH - btnW) / 2;\n      const btnY = (HEIGHT - btnH) / 2 + 80;\n      if (mx >= btnX && mx <= btnX + btnW && my >= btnY && my <= btnY + btnH) {\n        resetGame();\n        return;\n      }\n    }\n    // Determine if clicked on a package\n    const baseY = 320;\n    const packageW = 140;\n    const packageH = 60;\n    const margin = 20;\n    const totalW = choices.length * packageW + (choices.length - 1) * margin;\n    const startX = (WIDTH - totalW) / 2 + packageW / 2;\n    for (let i = 0; i < choices.length; i++) {\n      const x = startX + i * (packageW + margin);\n      const y = baseY + (i % 2 === 0 ? 8 : -8);\n      if (mx >= x - packageW / 2 && mx <= x + packageW / 2 && my >= y - packageH / 2 && my <= y + packageH / 2) {\n        // ensure audio user gesture resumes audio\n        resumeAudioIfNeeded();\n        submitChoice(i);\n        return;\n      }\n    }\n  });\n\n  // Keyboard controls\n  window.addEventListener(\"keydown\", (ev) => {\n    // Provide a key to resume audio: any game action should resume\n    resumeAudioIfNeeded();\n    if (ev.key >= \"1\" && ev.key <= \"4\") {\n      const idx = parseInt(ev.key, 10) - 1;\n      if (gameState === \"playing\") {\n        submitChoice(idx);\n      } else {\n        // when ended pressing number does nothing\n      }\n      ev.preventDefault();\n      return;\n    }\n    if (ev.key === \"ArrowLeft\") {\n      if (gameState === \"playing\") {\n        selectedChoice = (selectedChoice - 1 + choices.length) % choices.length;\n      }\n      ev.preventDefault();\n      return;\n    }\n    if (ev.key === \"ArrowRight\") {\n      if (gameState === \"playing\") {\n        selectedChoice = (selectedChoice + 1) % choices.length;\n      }\n      ev.preventDefault();\n      return;\n    }\n    if (ev.key === \"Enter\") {\n      if (gameState === \"playing\") {\n        submitChoice(selectedChoice);\n      }\n      ev.preventDefault();\n      return;\n    }\n    if (ev.key === \"s\" || ev.key === \"S\") {\n      // toggle sound\n      setBackgroundSound(!audioEnabled);\n      announce(`Sound ${audioEnabled ? \"on\" : \"off\"}.`);\n      ev.preventDefault();\n      return;\n    }\n    if (ev.key === \"r\" || ev.key === \"R\") {\n      // restart\n      resetGame();\n      ev.preventDefault();\n      return;\n    }\n  });\n\n  // Main loop\n  function tick(now) {\n    const dt = now - lastTick;\n    lastTick = now;\n    if (gameState === \"playing\") {\n      update(dt);\n    }\n    drawScene();\n\n    // If game ended, overlay victory or game over screen\n    if (gameState === \"won\" || gameState === \"lost\") {\n      // dark overlay\n      ctx.fillStyle = \"rgba(6,10,20,0.6)\";\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n      // big text\n      ctx.font = \"36px bold sans-serif\";\n      ctx.fillStyle = \"#fff\";\n      ctx.textBaseline = \"middle\";\n      const title = gameState === \"won\" ? \"You did it! Drone victory!\" : \"Game Over\";\n      const m = ctx.measureText(title);\n      ctx.fillText(title, (WIDTH - m.width) / 2, HEIGHT / 2 - 40);\n      ctx.font = \"20px sans-serif\";\n      const msg = gameState === \"won\" ? `You collected ${score} stars!` : `You collected ${score} stars. Try again!`;\n      const mm = ctx.measureText(msg);\n      ctx.fillText(msg, (WIDTH - mm.width) / 2, HEIGHT / 2 - 5);\n\n      // restart button\n      const btnW = 260;\n      const btnH = 54;\n      const btnX = (WIDTH - btnW) / 2;\n      const btnY = (HEIGHT - btnH) / 2 + 80;\n      ctx.fillStyle = \"#ffdd59\";\n      ctx.fillRect(btnX, btnY, btnW, btnH);\n      ctx.strokeStyle = \"#996000\";\n      ctx.lineWidth = 3;\n      ctx.strokeRect(btnX, btnY, btnW, btnH);\n      ctx.font = \"20px bold sans-serif\";\n      ctx.fillStyle = \"#000\";\n      const btnText = \"Restart (R)\";\n      const bm = ctx.measureText(btnText);\n      ctx.fillText(btnText, btnX + (btnW - bm.width) / 2, btnY + btnH / 2 - 8);\n    }\n\n    requestAnimationFrame(tick);\n  }\n\n  // Start\n  tryCreateAudioContext();\n  resetGame();\n  lastTick = performance.now();\n  requestAnimationFrame(tick);\n\n  // Provide error handling for visibility changes (suspend audio)\n  document.addEventListener(\"visibilitychange\", () => {\n    if (!audioCtx) return;\n    try {\n      if (document.hidden) {\n        audioCtx.suspend && audioCtx.suspend();\n      } else {\n        if (audioEnabled) audioCtx.resume && audioCtx.resume();\n      }\n    } catch (e) {\n      console.warn(\"visibility audio handling error:\", e);\n    }\n  });\n\n  // Expose a small debug on container for screen reader: text alternatives for current question\n  function updateAria() {\n    if (question && gameState === \"playing\") {\n      container.setAttribute(\n        \"aria-label\",\n        `Drone math game. Question: ${question.a} ${question.op} ${question.b}. Choices: ${choices\n          .map((c, i) => `${i + 1}: ${c}`)\n          .join(\", \")}. Score ${score}. Lives left ${Math.max(0, MAX_WRONG - wrong)}.`\n      );\n    } else {\n      container.setAttribute(\"aria-label\", `Drone math game. ${gameState}. Score ${score}. Lives left ${Math.max(0, MAX_WRONG - wrong)}.`);\n    }\n  }\n\n  // Update aria periodically\n  setInterval(updateAria, 1200);\n\n  // Ensure keyboard focus for accessibility\n  container.addEventListener(\"click\", () => {\n    container.focus();\n    resumeAudioIfNeeded();\n  });\n\n  // Safety: if audio unavailable, provide visual cue in the UI\n  if (!window.AudioContext && !window.webkitAudioContext) {\n    announce(\"Audio not supported. Visual cues provided.\");\n  }\n})();\n---\n",
  "improve_response_tokens": 18725,
  "formatted_code": true,
  "formatting_response_tokens": 20811,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}