# Game of the Day - 2025-08-24

## Metadata
- **Generated Date:** 2025-08-24
- **Generated Time:** 2025-08-24T00:29:44.380934
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-24.js
- **File Size:** 24491 bytes
- **Tokens Used:** 8626

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
• Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
• Reinforce the math concept through a real-world narratives tied to theme.
• Include fun, unique memorable characters tied to the theme.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-24.js` - The playable game
- `2025-08-24.meta.json` - Machine-readable metadata
- `2025-08-24.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 17923

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 19741

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function() {
  // Electricity Math Game for ages 7-9
  // Renders into element with ID "game-of-the-day-stage"
  // Canvas size: 720x480
  // Uses Web Audio API oscillators for sounds
  // All graphics are canvas drawn. No external resources.

  // ------ Setup and safety checks ------
  const STAGE_ID = 'game-of-the-day-stage';
  const WIDTH = 720;
  const HEIGHT = 480;

  const stage = document.getElementById(STAGE_ID);
  if (!stage) {
    console.error(`Element with id "${STAGE_ID}" not found.`);
    return;
  }

  // clear stage
  stage.innerHTML = '';
  stage.style.position = 'relative';

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute('role', 'application');
  canvas.setAttribute('aria-label', 'Electric Math Game. Use arrow keys to select a bulb and Space or Enter to connect electricity.');
  stage.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Create an ARIA live region for accessibility updates
  const live = document.createElement('div');
  live.setAttribute('aria-live', 'polite');
  live.style.position = 'absolute';
  live.style.left = '-9999px';
  live.style.width = '1px';
  live.style.height = '1px';
  live.style.overflow = 'hidden';
  stage.appendChild(live);

  // Attempt to create AudioContext; handle errors gracefully
  let audioCtx = null;
  let audioAllowed = true;
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (AudioContext) {
      audioCtx = new AudioContext();
      // Some browsers require a gesture to resume; we'll manage resume on first interaction.
    } else {
      audioAllowed = false;
      console.warn('Web Audio API not supported in this browser.');
    }
  } catch (e) {
    audioAllowed = false;
    console.warn('Failed to create AudioContext:', e);
  }

  // Audio control objects
  const audioState = {
    enabled: audioAllowed,
    resumed: false,
    bgGain: null,
    bgOsc: null
  };

  // Utility: safe resume audio on interaction
  async function tryResumeAudio() {
    if (!audioCtx || audioState.resumed || !audioState.enabled) return;
    try {
      await audioCtx.resume();
      audioState.resumed = true;
      startBackgroundHum();
    } catch (e) {
      console.warn('Audio resume failed:', e);
    }
  }

  // ------- Sound generation using Web Audio API -------
  function safeCreateGain() {
    if (!audioCtx) return null;
    try {
      return audioCtx.createGain();
    } catch (e) {
      console.warn('Failed to create GainNode:', e);
      return null;
    }
  }

  function startBackgroundHum() {
    if (!audioCtx || !audioState.enabled) return;
    stopBackgroundHum();
    try {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      osc.type = 'sine';
      osc.frequency.value = 60; // gentle hum frequency
      filter.type = 'lowpass';
      filter.frequency.value = 600;
      gain.gain.value = 0.02; // very gentle
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start();
      audioState.bgOsc = osc;
      audioState.bgGain = gain;
    } catch (e) {
      console.warn('Failed to start background hum:', e);
    }
  }

  function stopBackgroundHum() {
    if (audioState.bgOsc) {
      try {
        audioState.bgOsc.stop();
      } catch (e) {}
      try {
        audioState.bgOsc.disconnect();
      } catch (e) {}
      audioState.bgOsc = null;
    }
    if (audioState.bgGain) {
      try { audioState.bgGain.disconnect(); } catch (e) {}
      audioState.bgGain = null;
    }
  }

  function playCorrectSound() {
    if (!audioCtx || !audioState.enabled) return;
    tryResumeAudio();
    try {
      const now = audioCtx.currentTime;
      const master = safeCreateGain();
      if (!master) return;
      master.gain.value = 0.0001;
      master.connect(audioCtx.destination);

      // three quick rising tones
      const freqs = [660, 880, 1100];
      freqs.forEach((f, i) => {
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(f - 80, now + i * 0.06);
        osc.frequency.exponentialRampToValueAtTime(f, now + i * 0.06 + 0.08);
        g.gain.setValueAtTime(0.001, now + i * 0.06);
        g.gain.exponentialRampToValueAtTime(0.12, now + i * 0.06 + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, now + i * 0.06 + 0.22);
        filter.type = 'highpass';
        filter.frequency.value = 300;
        osc.connect(filter);
        filter.connect(g);
        g.connect(master);
        osc.start(now + i * 0.06);
        osc.stop(now + i * 0.06 + 0.3);
      });
      // smooth master envelope
      master.gain.setValueAtTime(0.0001, now);
      master.gain.exponentialRampToValueAtTime(1, now + 0.01);
      master.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);
      setTimeout(() => {
        try { master.disconnect(); } catch (e) {}
      }, 700);
    } catch (e) {
      console.warn('Correct sound failed:', e);
    }
  }

  function playIncorrectSound() {
    if (!audioCtx || !audioState.enabled) return;
    tryResumeAudio();
    try {
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      osc.type = 'square';
      osc.frequency.setValueAtTime(160, now);
      filter.type = 'bandpass';
      filter.frequency.value = 300;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.12, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);
      osc.connect(filter);
      filter.connect(g);
      g.connect(audioCtx.destination);
      osc.start(now);
      osc.frequency.exponentialRampToValueAtTime(80, now + 0.4);
      osc.stop(now + 0.5);
      setTimeout(() => {
        try { osc.disconnect(); } catch (e) {}
      }, 600);
    } catch (e) {
      console.warn('Incorrect sound failed:', e);
    }
  }

  // Toggle audio on/off
  function toggleAudio() {
    audioState.enabled = !audioState.enabled;
    if (audioState.enabled) {
      tryResumeAudio();
      startBackgroundHum();
    } else {
      stopBackgroundHum();
    }
  }

  // ------- Game Logic -------
  const GAME = {
    level: 1,
    score: 0,
    lives: 3,
    round: 0,
    playing: true,
    selectedIndex: 0,
    options: [],
    correctIndex: 0,
    a: 0,
    b: 0,
    animParticles: [],
    ui: {}
  };

  // Characters definition (visual only)
  const CHARACTERS = [
    { name: 'Sparky', color: '#FFD34D' },
    { name: 'Bulby', color: '#FCE8A8' },
    { name: 'Dr. Ohm', color: '#B4E4FF' }
  ];

  // Initialize game
  function resetGame() {
    GAME.level = 1;
    GAME.score = 0;
    GAME.lives = 3;
    GAME.round = 0;
    GAME.playing = true;
    GAME.selectedIndex = 0;
    GAME.animParticles = [];
    nextRound();
    live.textContent = 'Game started. Use left and right arrow keys to choose a bulb, Space or Enter to connect.';
  }

  // Generate a round: addition problems with increasing difficulty
  function nextRound() {
    GAME.round++;
    // Difficulty scales with level and round
    const maxAddend = Math.min(10 + Math.floor(GAME.level * 2), 20);
    const a = Math.floor(Math.random() * (Math.min(6 + GAME.level, maxAddend)));
    const b = Math.floor(Math.random() * (Math.min(6 + GAME.level, maxAddend)));
    GAME.a = a;
    GAME.b = b;
    // Create three options including the correct sum
    const sum = a + b;
    const options = new Set();
    options.add(sum);
    while (options.size < 3) {
      // distractors near sum
      let delta = Math.floor(Math.random() * 5) - 2;
      if (Math.random() < 0.2) delta += (Math.random() < 0.5 ? -4 : 4);
      let val = sum + delta;
      if (val < 0) val = Math.abs(val) + 1;
      options.add(val);
    }
    const arr = Array.from(options);
    // shuffle
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    GAME.options = arr;
    GAME.correctIndex = arr.indexOf(sum);
    GAME.selectedIndex = 0;
    // Slightly increase level every few rounds
    if (GAME.round % 5 === 0) GAME.level++;
    announceRound();
  }

  function announceRound() {
    live.textContent = `Round ${GAME.round}. ${GAME.a} plus ${GAME.b} equals ?. Options are ${GAME.options.join(', ')}. Selected ${GAME.options[GAME.selectedIndex]}.`;
  }

  // Visual positions of bulbs
  const bulbs = [
    { x: WIDTH * 0.2, y: HEIGHT * 0.65 },
    { x: WIDTH * 0.5, y: HEIGHT * 0.6 },
    { x: WIDTH * 0.8, y: HEIGHT * 0.65 }
  ];

  // Draw loop
  let lastTime = performance.now();
  function loop(now) {
    const dt = (now - lastTime) / 1000;
    lastTime = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // Update animations
  function update(dt) {
    // update particles
    GAME.animParticles.forEach(p => {
      p.vx += p.ax * dt;
      p.vy += p.ay * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.life -= dt;
      p.size *= (1 - dt * 0.9);
    });
    GAME.animParticles = GAME.animParticles.filter(p => p.life > 0 && p.size > 0.5);
  }

  // Drawing helpers
  function clear() {
    // calming background gradient with wacky shapes
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#E8F7FF');
    g.addColorStop(1, '#F1FFF6');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // faint circuit pattern
    ctx.save();
    ctx.globalAlpha = 0.08;
    ctx.strokeStyle = '#BEEADE';
    ctx.lineWidth = 2;
    for (let i = 0; i < 6; i++) {
      ctx.beginPath();
      const y = 60 + i * 60;
      for (let x = 0; x < WIDTH; x += 40) {
        ctx.lineTo(x, y + Math.sin((x + i * 30) / 60) * 6);
      }
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawCharacters() {
    // Sparky the lightning bolt at left
    // body
    ctx.save();
    ctx.translate(90, 140);
    ctx.rotate(Math.sin(Date.now() / 400) * 0.03);
    ctx.fillStyle = '#FFD34D';
    ctx.beginPath();
    ctx.moveTo(-10, -30);
    ctx.lineTo(10, -30);
    ctx.lineTo(0, -5);
    ctx.lineTo(18, -5);
    ctx.lineTo(-8, 30);
    ctx.lineTo(2, 0);
    ctx.lineTo(-20, 0);
    ctx.closePath();
    ctx.fill();
    // eyes
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.arc(-4, -10, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(6, -8, 3, 0, Math.PI * 2);
    ctx.fill();
    // smile
    ctx.beginPath();
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1.5;
    ctx.arc(1, 2, 7, 0.2, 3.0);
    ctx.stroke();
    ctx.restore();

    // Dr. Ohm - robot on right
    ctx.save();
    ctx.translate(WIDTH - 130, 120);
    ctx.fillStyle = '#B4E4FF';
    ctx.fillRect(-28, -36, 56, 60);
    // eyes
    ctx.fillStyle = '#333';
    ctx.fillRect(-18, -20, 10, 6);
    ctx.fillRect(8, -20, 10, 6);
    // mouth
    ctx.fillStyle = '#333';
    ctx.fillRect(-8, 0, 16, 6);
    // little antenna
    ctx.beginPath();
    ctx.moveTo(18, -36);
    ctx.lineTo(26, -52);
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(26, -52, 4, 0, Math.PI * 2);
    ctx.fillStyle = '#FFCC66';
    ctx.fill();
    ctx.restore();
  }

  function drawHub() {
    // power hub in middle top
    const hubX = WIDTH * 0.5;
    const hubY = HEIGHT * 0.25;
    // outer ring
    ctx.save();
    const grd = ctx.createRadialGradient(hubX, hubY, 10, hubX, hubY, 80);
    grd.addColorStop(0, '#FFF9C4');
    grd.addColorStop(1, '#FFE082');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(hubX, hubY, 60, 0, Math.PI * 2);
    ctx.fill();
    // inner spark
    ctx.fillStyle = '#FFD54D';
    ctx.beginPath();
    ctx.arc(hubX, hubY, 36, 0, Math.PI * 2);
    ctx.fill();
    // label
    ctx.fillStyle = '#333';
    ctx.font = 'bold 18px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Power Hub', hubX, hubY - 70);
    // equation text
    ctx.font = '26px sans-serif';
    ctx.fillText(`${GAME.a} + ${GAME.b} = ?`, hubX, hubY + 6);
    ctx.restore();
  }

  function drawBulbs() {
    bulbs.forEach((b, idx) => {
      const isSelected = (idx === GAME.selectedIndex);
      const isCorrect = (idx === GAME.correctIndex);
      // cable from hub to bulb
      const hubX = WIDTH * 0.5;
      const hubY = HEIGHT * 0.25;
      ctx.save();
      ctx.lineWidth = 6;
      ctx.lineCap = 'round';
      // cable color glows if selected
      if (isSelected) {
        ctx.strokeStyle = '#FFD34D';
        ctx.shadowColor = '#FFD34D';
        ctx.shadowBlur = 12;
      } else {
        ctx.strokeStyle = '#9E9E9E';
        ctx.shadowBlur = 0;
      }
      ctx.beginPath();
      ctx.moveTo(hubX, hubY + 30);
      // curve
      ctx.quadraticCurveTo((hubX + b.x) / 2, hubY + 80 + (idx - 1) * 10, b.x - 12, b.y - 40);
      ctx.stroke();
      ctx.restore();

      // bulb glass
      ctx.save();
      ctx.translate(b.x, b.y);
      // glow if lit (when correct and selected recently)
      let lit = false;
      // lit if correct and we have a small flashing effect or if correct and selected and recent particle present
      if (isCorrect && (GAME.lastCorrectTime && (Date.now() - GAME.lastCorrectTime) < 1200)) lit = true;
      if (isSelected && GAME.recentIncorrect && (Date.now() - GAME.recentIncorrect) < 800) lit = true;
      // bulb body
      const bulbGrad = ctx.createRadialGradient(-6, -12, 4, 6, 8, 60);
      bulbGrad.addColorStop(0, lit ? '#FFF8B0' : '#FFFFFF');
      bulbGrad.addColorStop(1, '#E6EEE9');
      ctx.fillStyle = bulbGrad;
      ctx.beginPath();
      ctx.ellipse(0, -6, 34, 46, 0, 0, Math.PI * 2);
      ctx.fill();
      // filament (cute face)
      ctx.strokeStyle = '#B8860B';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-12, -4);
      ctx.quadraticCurveTo(0, -12, 12, -4);
      ctx.stroke();
      // screw base
      ctx.fillStyle = '#9E9E9E';
      ctx.fillRect(-16, 30, 32, 8);
      ctx.fillStyle = '#777';
      ctx.fillRect(-14, 24, 28, 6);
      // face
      ctx.fillStyle = '#333';
      ctx.beginPath();
      ctx.arc(-8, -10, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(8, -10, 3, 0, Math.PI * 2);
      ctx.fill();
      // smile or surprised
      ctx.beginPath();
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1.6;
      if (isSelected) {
        ctx.arc(0, -2, 8, 0.1, 3.04);
      } else {
        ctx.moveTo(-6, -2);
        ctx.lineTo(6, -2);
      }
      ctx.stroke();

      // answer label
      ctx.fillStyle = '#222';
      ctx.font = 'bold 20px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(GAME.options[idx], 0, 52);
      // selection ring
      if (isSelected) {
        ctx.strokeStyle = '#FFEE88';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.ellipse(0, -6, 46, 58, 0, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.restore();
    });
  }

  function drawUI() {
    // Top left: score and lives
    ctx.save();
    ctx.fillStyle = '#333';
    ctx.font = '18px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`Score: ${GAME.score}`, 16, 28);
    // Lives as little battery icons
    for (let i = 0; i < 3; i++) {
      const x = 120 + i * 28;
      const y = 12;
      ctx.save();
      ctx.translate(x, y);
      // battery outline
      ctx.strokeStyle = '#555';
      ctx.lineWidth = 2;
      ctx.strokeRect(0, 0, 22, 14);
      ctx.fillStyle = (i < GAME.lives) ? '#66BB6A' : '#EEE';
      ctx.fillRect(2, 2, 18, 10);
      if (i < GAME.lives) {
        // little lightning
        ctx.fillStyle = '#FFF';
        ctx.beginPath();
        ctx.moveTo(10, 3);
        ctx.lineTo(6, 10);
        ctx.lineTo(11, 10);
        ctx.lineTo(8, 13);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();
    }
    // audio indicator top-right
    ctx.textAlign = 'right';
    ctx.fillStyle = '#333';
    ctx.font = '16px sans-serif';
    ctx.fillText(`Level: ${GAME.level}`, WIDTH - 110, 28);

    // speaker icon
    ctx.save();
    const sx = WIDTH - 40, sy = 16;
    ctx.translate(sx, sy);
    ctx.fillStyle = audioState.enabled ? '#FFCC66' : '#DDD';
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(-12, -6);
    ctx.lineTo(-2, -6);
    ctx.lineTo(6, -12);
    ctx.lineTo(6, 12);
    ctx.lineTo(-2, 6);
    ctx.lineTo(-12, 6);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    if (audioState.enabled) {
      ctx.beginPath();
      ctx.arc(12, 0, 8, -0.6, 0.6);
      ctx.strokeStyle = '#FFCC66';
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(16, 0, 12, -0.7, 0.7);
      ctx.stroke();
    }
    ctx.restore();

    // Instructions bottom area
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    ctx.fillRect(12, HEIGHT - 78, WIDTH - 24, 66);
    ctx.fillStyle = '#333';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Choose the bulb that shows the correct answer. Use ← and → to select. Press Space or Enter to connect. Click bulbs to select. Press M to toggle sound.', 20, HEIGHT - 46);
    ctx.restore();
  }

  function drawParticles() {
    GAME.animParticles.forEach(p => {
      ctx.save();
      ctx.globalAlpha = Math.max(0, Math.min(1, p.life / p.maxLife));
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, Math.max(1, p.size), 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    });
  }

  function draw() {
    clear();
    drawCharacters();
    drawHub();
    drawBulbs();
    drawUI();
    drawParticles();

    // show friendly footer
    ctx.save();
    ctx.fillStyle = '#666';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('Theme: Electricity - Learn addition by lighting bulbs!', WIDTH - 10, HEIGHT - 8);
    ctx.restore();

    // If game over overlay
    if (!GAME.playing) {
      ctx.save();
      ctx.fillStyle = 'rgba(20,20,20,0.6)';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = '#FFF';
      ctx.font = 'bold 36px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over', WIDTH / 2, HEIGHT / 2 - 20);
      ctx.font = '22px sans-serif';
      ctx.fillText(`Score: ${GAME.score}`, WIDTH / 2, HEIGHT / 2 + 18);
      ctx.font = '16px sans-serif';
      ctx.fillText('Press R to play again', WIDTH / 2, HEIGHT / 2 + 48);
      ctx.restore();
    }
  }

  // ------ Interaction handlers ------

  // click detection for bulbs
  function handleClick(e) {
    // resume audio on first interaction
    tryResumeAudio();

    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);

    for (let i = 0; i < bulbs.length; i++) {
      const b = bulbs[i];
      // simple hit via distance
      const dx = x - b.x;
      const dy = y - b.y;
      if (Math.sqrt(dx * dx + dy * dy) < 60) {
        // select and confirm
        GAME.selectedIndex = i;
        announceRound();
        // quick confirm on second click: if same selected again or immediate click triggers connect
        handleConfirm();
        return;
      }
    }

    // clicking speaker area toggles audio
    const sx = WIDTH - 40, sy = 16;
    if (x > sx - 20 && x < sx + 30 && y > sy - 20 && y < sy + 20) {
      toggleAudio();
      live.textContent = audioState.enabled ? 'Sound on' : 'Sound off';
    }
  }

  function handleKeyDown(e) {
    // resume audio on first gesture
    tryResumeAudio();

    if (!GAME.playing) {
      if (e.key === 'r' || e.key === 'R') {
        resetGame();
      }
      return;
    }

    if (e.key === 'ArrowLeft') {
      GAME.selectedIndex = (GAME.selectedIndex + bulbs.length - 1) % bulbs.length;
      announceRound();
      e.preventDefault();
    } else if (e.key === 'ArrowRight') {
      GAME.selectedIndex = (GAME.selectedIndex + 1) % bulbs.length;
      announceRound();
      e.preventDefault();
    } else if (e.key === ' ' || e.key === 'Enter') {
      handleConfirm();
      e.preventDefault();
    } else if (e.key === 'm' || e.key === 'M') {
      toggleAudio();
      live.textContent = audioState.enabled ? 'Sound on' : 'Sound off';
      e.preventDefault();
    }
  }

  function handleConfirm() {
    if (!GAME.playing) return;
    const chosen = GAME.selectedIndex;
    const correct = GAME.correctIndex;
    if (chosen === correct) {
      // success
      GAME.score += 10;
      GAME.lastCorrectTime = Date.now();
      playCorrectSound();
      // particles around bulb
      const b = bulbs[chosen];
      for (let i = 0; i < 18; i++) {
        GAME.animParticles.push({
          x: b.x + (Math.random() - 0.5) * 30,
          y: b.y + (Math.random() - 0.5) * 20,
          vx: (Math.random() - 0.5) * 60,
          vy: (Math.random() - 1.5) * 60,
          ax: 0,
          ay: 80,
          life: 1.0,
          maxLife: 1.0,
          size: 4 + Math.random() * 4,
          color: `hsl(${Math.random() * 60 + 40}, 80%, ${60 + Math.random() * 10}%)`
        });
      }
      // next round shortly
      setTimeout(nextRound, 700);
      live.textContent = `Correct! ${GAME.a} + ${GAME.b} = ${GAME.options[chosen]}. Score ${GAME.score}.`;
    } else {
      // incorrect
      GAME.lives -= 1;
      GAME.recentIncorrect = Date.now();
      playIncorrectSound();
      // sparks
      const b = bulbs[chosen];
      for (let i = 0; i < 16; i++) {
        GAME.animParticles.push({
          x: b.x + (Math.random() - 0.5) * 30,
          y: b.y + (Math.random() - 0.5) * 20,
          vx: (Math.random() - 0.5) * 100,
          vy: (Math.random() - 1) * 60,
          ax: 0,
          ay: 200,
          life: 0.8 + Math.random() * 0.6,
          maxLife: 1.0,
          size: 3 + Math.random() * 3,
          color: `hsl(${Math.random() * 40 + 10}, 90%, ${40 + Math.random() * 20}%)`
        });
      }
      live.textContent = `Oops! ${GAME.options[chosen]} is not ${GAME.a} + ${GAME.b}. Lives: ${GAME.lives}.`;
      if (GAME.lives <= 0) {
        GAME.playing = false;
        stopBackgroundHum();
        live.textContent = `Game over. Final score ${GAME.score}. Press R to play again.`;
      } else {
        // give a clue: highlight which one is correct
        setTimeout(() => {
          // small hint: briefly set selected to correct so children notice
          GAME.selectedIndex = GAME.correctIndex;
          setTimeout(() => {
            GAME.selectedIndex = 0;
            announceRound();
          }, 700);
        }, 300);
      }
    }
  }

  // Event listeners
  canvas.addEventListener('click', handleClick);
  canvas.addEventListener('touchstart', function(e) {
    if (e.touches && e.touches.length > 0) {
      const t = e.touches[0];
      handleClick({ clientX: t.clientX, clientY: t.clientY });
    }
    e.preventDefault();
  }, { passive: false });

  window.addEventListener('keydown', handleKeyDown);

  // Resume audio upon any user gesture on the canvas
  function userGestureHandler() {
    if (audioCtx && audioCtx.state === 'suspended') {
      tryResumeAudio();
    }
    canvas.removeEventListener('pointerdown', userGestureHandler);
    canvas.removeEventListener('mousedown', userGestureHandler);
    canvas.removeEventListener('touchstart', userGestureHandler);
  }
  canvas.addEventListener('pointerdown', userGestureHandler);
  canvas.addEventListener('mousedown', userGestureHandler);
  canvas.addEventListener('touchstart', userGestureHandler);

  // Initialize game and start loop
  resetGame();
  if (audioState.enabled) {
    // start gently if allowed; may require resume gesture
    try {
      startBackgroundHum();
    } catch (e) {
      console.warn('Background hum start error:', e);
    }
  }
  requestAnimationFrame(loop);

  // Expose a minimal API for possible external controls (non-essential)
  window.__ElectricMathGame = {
    reset: resetGame,
    toggleAudio: toggleAudio,
    getState: () => ({ score: GAME.score, lives: GAME.lives, level: GAME.level, round: GAME.round })
  };

  // Error handling demonstration: watch for context errors
  window.addEventListener('unhandledrejection', function(e) {
    console.warn('Unhandled promise rejection:', e.reason);
  });
})();
---

