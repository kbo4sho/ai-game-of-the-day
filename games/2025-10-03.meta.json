{
  "generated_date": "2025-10-03",
  "generated_timestamp": "2025-10-03T00:25:39.577124",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8472,
  "game_filename": "2025-10-03.js",
  "game_size_bytes": 24453,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Machine Math \u2014 Canvas Game for ages 7-9\n// Renders inside element with id \"game-of-the-day-stage\"\n// Game area exactly 720x480.\n// Uses Canvas and Web Audio API only. No external resources.\n// Accessible: keyboard controls, aria-live updates, visual/audio cues.\n\n// Immediately-invoked function to avoid polluting global scope\n(function () {\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const ROUNDS = 6;\n  const MAX_TRIES_BEFORE_HINT = 3;\n\n  // Find container\n  const container = document.getElementById(\"game-of-the-day-stage\");\n  if (!container) {\n    console.error(\"Container element with ID 'game-of-the-day-stage' not found.\");\n    return;\n  }\n\n  // Clear container\n  container.innerHTML = \"\";\n  container.style.position = \"relative\";\n  container.style.width = WIDTH + \"px\";\n  container.style.height = HEIGHT + \"px\";\n  container.style.userSelect = \"none\";\n  container.style.outline = \"none\";\n\n  // Create accessible live region for screen readers (off-screen but available)\n  const liveRegion = document.createElement(\"div\");\n  liveRegion.setAttribute(\"aria-live\", \"polite\");\n  liveRegion.setAttribute(\"role\", \"status\");\n  liveRegion.style.position = \"absolute\";\n  liveRegion.style.left = \"-9999px\";\n  container.appendChild(liveRegion);\n\n  // Create canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.tabIndex = 0; // make focusable\n  canvas.style.display = \"block\";\n  container.appendChild(canvas);\n  const ctx = canvas.getContext(\"2d\", { alpha: false });\n\n  // Focus canvas for keyboard events\n  canvas.focus();\n\n  // Audio setup with error handling\n  let audioEnabled = true;\n  let audioContext = null;\n  try {\n    const AC = window.AudioContext || window.webkitAudioContext;\n    if (!AC) throw new Error(\"Web Audio API not supported\");\n    audioContext = new AC();\n    // Start suspended for autoplay policy; resume on user gesture\n    if (audioContext.state === \"suspended\") {\n      audioEnabled = false; // will become true after gesture\n    }\n  } catch (e) {\n    console.warn(\"Audio unavailable:\", e.message);\n    audioEnabled = false;\n    audioContext = null;\n  }\n\n  // Audio nodes (created once audio started)\n  let masterGain = null;\n  let bgGain = null;\n  let bgOsc = null;\n  let lfoOsc = null;\n\n  function initAudioNodes() {\n    if (!audioContext) return;\n    try {\n      masterGain = audioContext.createGain();\n      masterGain.gain.value = 0.9;\n      masterGain.connect(audioContext.destination);\n\n      // Background hum: low-volume oscillator + slow LFO to modulate frequency\n      bgGain = audioContext.createGain();\n      bgGain.gain.value = 0.04;\n      bgGain.connect(masterGain);\n\n      bgOsc = audioContext.createOscillator();\n      bgOsc.type = \"sine\";\n      bgOsc.frequency.value = 110; // low hum\n      bgOsc.connect(bgGain);\n\n      lfoOsc = audioContext.createOscillator();\n      const lfoGain = audioContext.createGain();\n      lfoGain.gain.value = 10; // modulation depth\n      lfoOsc.frequency.value = 0.08; // very slow LFO\n      lfoOsc.connect(lfoGain);\n      lfoGain.connect(bgOsc.frequency);\n\n      bgOsc.start();\n      lfoOsc.start();\n    } catch (err) {\n      console.warn(\"Error initAudioNodes:\", err);\n    }\n  }\n\n  // Helper for playing a tone\n  function playTone({ freq = 440, duration = 0.18, type = \"sine\", volume = 0.12, attack = 0.01 } = {}) {\n    if (!audioContext) return;\n    try {\n      const now = audioContext.currentTime;\n      const osc = audioContext.createOscillator();\n      const gain = audioContext.createGain();\n      const filter = audioContext.createBiquadFilter();\n\n      osc.type = type;\n      osc.frequency.value = freq;\n\n      filter.type = \"lowpass\";\n      filter.frequency.value = Math.max(800, freq * 2);\n\n      gain.gain.value = 0;\n      gain.gain.setValueAtTime(0, now);\n      gain.gain.linearRampToValueAtTime(volume, now + attack);\n      gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);\n\n      osc.connect(filter);\n      filter.connect(gain);\n      gain.connect(masterGain || audioContext.destination);\n\n      osc.start(now);\n      osc.stop(now + duration + 0.05);\n    } catch (err) {\n      console.warn(\"playTone error:\", err);\n    }\n  }\n\n  // Feedback sounds\n  function playCorrectSound() {\n    if (!audioContext) return;\n    // small ascending arpeggio\n    const base = 440;\n    const intervals = [0, 3, 7]; // semitone intervals\n    intervals.forEach((i, idx) => {\n      setTimeout(() => playTone({ freq: base * Math.pow(2, i / 12), duration: 0.16, type: \"triangle\", volume: 0.12 }), idx * 120);\n    });\n  }\n\n  function playIncorrectSound() {\n    if (!audioContext) return;\n    // short buzzer\n    playTone({ freq: 220, duration: 0.28, type: \"sawtooth\", volume: 0.14 });\n    setTimeout(() => playTone({ freq: 160, duration: 0.18, type: \"sawtooth\", volume: 0.08 }), 180);\n  }\n\n  function playClick() {\n    if (!audioContext) return;\n    playTone({ freq: 900, duration: 0.06, type: \"square\", volume: 0.06 });\n  }\n\n  // Utility random\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  // Game state\n  const state = {\n    round: 0,\n    score: 0,\n    roundsCompleted: 0,\n    current: null, // current puzzle\n    selectedIndex: 0,\n    triesThisRound: 0,\n    started: false,\n    audioOn: audioEnabled && audioContext && audioContext.state === \"running\",\n  };\n\n  // Generate puzzle: pick target between 6 and 20; present 4 candidate single numbers; exactly one is correct (when added to base makes target)\n  // Puzzle uses a \"machine\" with a missing gear that must be a number to make sums correct.\n  function makePuzzle() {\n    // We'll provide a small equation: base + ? = target, base between 1 and 12, target between base+2 and base+9 (to keep small)\n    const base = randInt(1, 12);\n    const add = randInt(2, 9);\n    const target = base + add;\n    const correct = add;\n    // generate three wrong options that are plausible (close numbers)\n    const options = new Set([correct]);\n    while (options.size < 4) {\n      let candidate = correct + randInt(-4, 4);\n      if (candidate < 1) candidate = Math.abs(candidate) + 1;\n      if (candidate === correct) continue;\n      options.add(candidate);\n    }\n    // shuffle\n    const arr = Array.from(options);\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    const idx = arr.indexOf(correct);\n    return { base, target, options: arr, correctIndex: idx };\n  }\n\n  function startNewRound() {\n    state.current = makePuzzle();\n    state.selectedIndex = 0;\n    state.triesThisRound = 0;\n    state.round++;\n    state.started = true;\n    updateLive(`Round ${state.round} of ${ROUNDS}. Choose the gear to make ${state.current.base} + ? = ${state.current.target}. Use arrows and Enter, or click.`);\n  }\n\n  // Draw helper: calming wacky background with floating blobs\n  let startTime = performance.now();\n  function drawBackground(t) {\n    const time = (t - startTime) / 1000;\n    // soft pastel gradient\n    const g = ctx.createLinearGradient(0, 0, WIDTH, HEIGHT);\n    g.addColorStop(0, \"#e9f6f2\");\n    g.addColorStop(0.5, \"#f3eefc\");\n    g.addColorStop(1, \"#fff5e9\");\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // floating blobs\n    const blobs = [\n      { x: 0.15, y: 0.2, r: 80, c: \"rgba(200,230,255,0.12)\", tx: 0.5 },\n      { x: 0.7, y: 0.18, r: 100, c: \"rgba(255,220,240,0.10)\", tx: -0.7 },\n      { x: 0.45, y: 0.7, r: 120, c: \"rgba(220,255,230,0.10)\", tx: 1.0 },\n    ];\n    blobs.forEach((b, i) => {\n      const bx = WIDTH * (b.x + 0.02 * Math.sin(time * (0.3 + i * 0.1) + i));\n      const by = HEIGHT * (b.y + 0.02 * Math.cos(time * (0.2 + i * 0.12) - i));\n      ctx.beginPath();\n      ctx.fillStyle = b.c;\n      ctx.ellipse(bx, by, b.r, b.r * 0.7, Math.sin(time + i), 0, Math.PI * 2);\n      ctx.fill();\n    });\n  }\n\n  // Draw a gear with teeth, number in center\n  function drawGear(x, y, radius, teeth, color, number, highlight = false, wobble = 0) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(wobble * 0.05);\n    // body\n    ctx.beginPath();\n    // gear teeth: draw as alternate radius\n    const innerR = radius * 0.75;\n    const outerR = radius;\n    for (let i = 0; i < teeth; i++) {\n      const angle = (i / teeth) * Math.PI * 2;\n      const angleNext = ((i + 1) / teeth) * Math.PI * 2;\n      const mid = angle + (angleNext - angle) / 2;\n      // first half of tooth outer arc\n      if (i === 0) ctx.moveTo(Math.cos(angle) * outerR, Math.sin(angle) * outerR);\n      ctx.lineTo(Math.cos(angle) * outerR, Math.sin(angle) * outerR);\n      ctx.lineTo(Math.cos(mid) * outerR, Math.sin(mid) * outerR);\n      ctx.lineTo(Math.cos(angleNext) * innerR, Math.sin(angleNext) * innerR);\n    }\n    ctx.closePath();\n    ctx.fillStyle = color;\n    ctx.shadowColor = \"rgba(0,0,0,0.12)\";\n    ctx.shadowBlur = 6;\n    ctx.fill();\n\n    // center circle\n    ctx.beginPath();\n    ctx.arc(0, 0, innerR * 0.6, 0, Math.PI * 2);\n    ctx.fillStyle = \"#fffefc\";\n    ctx.shadowBlur = 0;\n    ctx.fill();\n\n    // number\n    ctx.fillStyle = \"#2b2b2b\";\n    ctx.font = `bold ${Math.max(16, radius * 0.5)}px sans-serif`;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(String(number), 0, 0);\n\n    // highlight ring\n    if (highlight) {\n      ctx.beginPath();\n      ctx.arc(0, 0, outerR + 6, 0, Math.PI * 2);\n      ctx.strokeStyle = \"rgba(80,160,255,0.55)\";\n      ctx.lineWidth = 6;\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  // Draw machine visualization on left: base gear and missing gear slot\n  function drawMachine(puzzle, t) {\n    const time = (t - startTime) / 1000;\n    const machineX = 180;\n    const machineY = HEIGHT / 2;\n    // Machine body\n    ctx.save();\n    ctx.fillStyle = \"rgba(30, 40, 60, 0.06)\";\n    ctx.fillRect(machineX - 160, machineY - 140, 320, 280);\n    ctx.restore();\n\n    // Big base gear (left)\n    const baseX = machineX - 50;\n    const baseY = machineY;\n    drawGear(baseX, baseY, 64, 12, \"#b2d8f7\", puzzle.base, false, Math.sin(time) * 0.02);\n\n    // Missing gear slot (right), we show a ring to indicate missing gear\n    const slotX = machineX + 70;\n    const slotY = machineY;\n    ctx.beginPath();\n    ctx.arc(slotX, slotY, 64, 0, Math.PI * 2);\n    ctx.lineWidth = 6;\n    ctx.strokeStyle = \"rgba(120,120,120,0.18)\";\n    ctx.setLineDash([8, 10]);\n    ctx.stroke();\n    ctx.setLineDash([]);\n\n    // small bolt and arrows to give machine feel\n    ctx.fillStyle = \"#f6e2b3\";\n    ctx.beginPath();\n    ctx.ellipse(machineX + 70, machineY + 100, 36, 12, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Conveyor or pipe connecting gears\n    ctx.strokeStyle = \"rgba(90,120,150,0.12)\";\n    ctx.lineWidth = 18;\n    ctx.lineCap = \"round\";\n    ctx.beginPath();\n    ctx.moveTo(baseX + 60, baseY + 20);\n    ctx.quadraticCurveTo(machineX + 20, machineY + 40, slotX - 50, slotY + 40);\n    ctx.stroke();\n\n    // Instruction text inside machine\n    ctx.fillStyle = \"#2a2a2a\";\n    ctx.font = \"20px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(`Make ${puzzle.base} + ? = ${puzzle.target}`, machineX, machineY - 110);\n  }\n\n  // Draw candidate gears row with selection highlight\n  function drawCandidates(options, selectedIndex, t, triesThisRound) {\n    const startX = 80;\n    const startY = HEIGHT - 120;\n    const gap = 150;\n    options.forEach((n, i) => {\n      const x = startX + i * gap;\n      const y = startY;\n      const wobble = Math.sin((t - startTime) / 300 + i) * 0.02;\n      const colorPalette = [\"#ffd7b5\", \"#cbe7c4\", \"#e8d7ff\", \"#cfe7ff\"];\n      const color = colorPalette[i % colorPalette.length];\n      const highlight = i === selectedIndex;\n      drawGear(x, y, 48, 10, color, n, highlight, wobble);\n      // draw label beneath\n      ctx.fillStyle = \"#2b2b2b\";\n      ctx.font = \"14px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(\"gear\", x, y + 70);\n      // subtle hint if many tries\n      if (triesThisRound >= MAX_TRIES_BEFORE_HINT && i === state.current.correctIndex) {\n        ctx.beginPath();\n        ctx.arc(x, y - 40, 10 + Math.abs(Math.sin((t - startTime) / 450)) * 4, 0, Math.PI * 2);\n        ctx.fillStyle = \"rgba(80,170,120,0.12)\";\n        ctx.fill();\n      }\n    });\n  }\n\n  // Draw UI: score, round, audio indicator, instructions\n  function drawUI(t) {\n    // top bar\n    ctx.fillStyle = \"rgba(255,255,255,0.5)\";\n    ctx.fillRect(0, 0, WIDTH, 48);\n    ctx.fillStyle = \"#2b2b2b\";\n    ctx.font = \"16px sans-serif\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(`Round ${Math.min(state.round, ROUNDS)} / ${ROUNDS}`, 12, 30);\n    ctx.textAlign = \"center\";\n    ctx.fillText(`Score: ${state.score}`, WIDTH / 2, 30);\n\n    // audio visual cue\n    ctx.textAlign = \"right\";\n    const audioLabel = state.audioOn ? \"\ud83d\udd0a audio on\" : \"\ud83d\udd08 audio off\";\n    ctx.fillText(audioLabel, WIDTH - 12, 30);\n\n    // instructions small\n    ctx.fillStyle = \"#333\";\n    ctx.font = \"13px sans-serif\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(\"Use \u2190 \u2192 to choose gear, Enter to place it. Click a gear to choose.\", 12, 46);\n  }\n\n  // Render full scene\n  function render(t) {\n    // t is high-res timestamp\n    drawBackground(t);\n    if (!state.started) {\n      // draw welcome / start overlay\n      ctx.fillStyle = \"rgba(255,255,255,0.82)\";\n      ctx.fillRect(60, 60, WIDTH - 120, HEIGHT - 120);\n      ctx.fillStyle = \"#2b2b2b\";\n      ctx.font = \"28px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(\"Machine Math!\", WIDTH / 2, 140);\n      ctx.font = \"16px sans-serif\";\n      ctx.fillText(\"Welcome engineer! Help fix the friendly machine by choosing the correct number gears.\", WIDTH / 2, 180);\n      ctx.fillText(\"Solve simple addition: base + ? = target. Beat all rounds to win!\", WIDTH / 2, 210);\n\n      // little start button drawn\n      ctx.beginPath();\n      ctx.fillStyle = \"#bfe6ff\";\n      ctx.roundRect = ctx.roundRect || function (x, y, w, h, r) {\n        const minr = Math.min(w, h) * 0.2;\n        r = Math.min(r, minr);\n        this.beginPath();\n        this.moveTo(x + r, y);\n        this.arcTo(x + w, y, x + w, y + h, r);\n        this.arcTo(x + w, y + h, x, y + h, r);\n        this.arcTo(x, y + h, x, y, r);\n        this.arcTo(x, y, x + w, y, r);\n        this.closePath();\n      };\n      ctx.roundRect( WIDTH/2 - 80, HEIGHT/2 - 18, 160, 36, 12);\n      ctx.fill();\n      ctx.fillStyle = \"#0b3b5a\";\n      ctx.font = \"18px sans-serif\";\n      ctx.fillText(\"Press Enter or Click to Start\", WIDTH/2, HEIGHT/2 + 6);\n\n      // accessibility instructions\n      ctx.font = \"12px sans-serif\";\n      ctx.fillStyle = \"#334\";\n      ctx.fillText(\"Toggle audio with the 'A' key. Press H for help.\", WIDTH/2, HEIGHT/2 + 48);\n    } else if (state.round > ROUNDS) {\n      // victory screen\n      ctx.fillStyle = \"rgba(255,255,255,0.85)\";\n      ctx.fillRect(40, 60, WIDTH - 80, HEIGHT - 120);\n      ctx.fillStyle = \"#2b2b2b\";\n      ctx.font = \"30px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(\"All fixed! The machine hums happily!\", WIDTH / 2, 150);\n      ctx.font = \"18px sans-serif\";\n      ctx.fillText(`You scored ${state.score} / ${ROUNDS}`, WIDTH / 2, 200);\n\n      // confetti-ish gears floating\n      for (let i = 0; i < 10; i++) {\n        const x = 80 + ((t / 50 + i * 47) % (WIDTH - 160));\n        const y = 260 + Math.sin((t / 200) + i) * 40;\n        drawGear(x, y, 18 + (i % 3) * 3, 8 + (i % 4), [\"#ffd7b5\", \"#cbe7c4\", \"#e8d7ff\"][i % 3], i + 1, false, Math.sin((t / 200) + i) * 0.06);\n      }\n\n      ctx.font = \"14px sans-serif\";\n      ctx.fillText(\"Press R to play again.\", WIDTH / 2, 360);\n    } else {\n      // active round\n      drawMachine(state.current, t);\n      drawCandidates(state.current.options, state.selectedIndex, t, state.triesThisRound);\n      drawUI(t);\n      // if last action incorrect show gentle message\n      if (state.lastMessage) {\n        ctx.fillStyle = \"rgba(255,255,255,0.9)\";\n        ctx.fillRect(220, 32, 280, 34);\n        ctx.fillStyle = \"#1e1e1e\";\n        ctx.font = \"14px sans-serif\";\n        ctx.textAlign = \"center\";\n        ctx.fillText(state.lastMessage, 360, 54);\n      }\n    }\n\n    // request next frame\n    requestAnimationFrame(render);\n  }\n\n  // helper: update aria-live text\n  function updateLive(text) {\n    liveRegion.textContent = text;\n  }\n\n  // Handle selection attempts\n  function attemptSelection(index) {\n    state.selectedIndex = index;\n    playClick();\n    const puzzle = state.current;\n    if (!puzzle) return;\n    if (index === puzzle.correctIndex) {\n      state.score += Math.max(1, 3 - state.triesThisRound); // more points for fewer tries\n      state.roundsCompleted++;\n      state.lastMessage = \"Nice! That gear fits!\";\n      updateLive(`Correct! ${puzzle.base} + ${puzzle.options[index]} = ${puzzle.target}.`);\n      if (audioContext && state.audioOn) playCorrectSound();\n      // short delay then next round or win\n      setTimeout(() => {\n        if (state.round >= ROUNDS) {\n          // finish game\n          state.round++;\n          updateLive(\"You've fixed all parts of the machine. Hooray!\");\n          if (audioContext && state.audioOn) {\n            // celebratory melody\n            const notes = [523.25, 659.25, 784, 1046.5];\n            notes.forEach((f, i) => setTimeout(() => playTone({ freq: f, duration: 0.14, type: \"sine\", volume: 0.14 }), i * 140));\n          }\n        } else {\n          startNewRound();\n        }\n      }, 700);\n    } else {\n      state.triesThisRound++;\n      state.lastMessage = \"Oops \u2014 try another gear.\";\n      updateLive(`Not quite. ${puzzle.base} plus ${puzzle.options[index]} equals ${puzzle.base + puzzle.options[index]}. Try again.`);\n      if (audioContext && state.audioOn) playIncorrectSound();\n      // after a few wrong tries, show hint visually and in aria\n      if (state.triesThisRound >= MAX_TRIES_BEFORE_HINT) {\n        updateLive(`Hint: the correct gear is highlighted.`);\n      }\n    }\n  }\n\n  // Prepare initial puzzle\n  function resetGame() {\n    state.round = 0;\n    state.score = 0;\n    state.roundsCompleted = 0;\n    state.current = null;\n    state.selectedIndex = 0;\n    state.triesThisRound = 0;\n    state.started = false;\n    state.lastMessage = null;\n    state.audioOn = audioEnabled && audioContext && audioContext.state === \"running\";\n  }\n\n  // Mouse handling\n  canvas.addEventListener(\"click\", (e) => {\n    // resume audio on first interaction if needed\n    ensureAudioStarted();\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n\n    if (!state.started) {\n      // start game if start button area clicked\n      if (mx > WIDTH/2 - 80 && mx < WIDTH/2 + 80 && my > HEIGHT/2 - 18 && my < HEIGHT/2 + 18) {\n        startNewRound();\n      }\n      return;\n    }\n\n    if (state.round > ROUNDS) {\n      // check for R click\n      // if click near center, reset\n      const centerX = WIDTH/2;\n      const centerY = HEIGHT/2;\n      const dist = Math.hypot(mx - centerX, my - centerY);\n      resetGame();\n      return;\n    }\n\n    // Check candidate areas (we drew at startX with gap)\n    const startX = 80;\n    const gap = 150;\n    const startY = HEIGHT - 120;\n    for (let i = 0; i < state.current.options.length; i++) {\n      const x = startX + i * gap;\n      const y = startY;\n      const dx = mx - x;\n      const dy = my - y;\n      if (dx * dx + dy * dy <= (48 + 8) * (48 + 8)) {\n        attemptSelection(i);\n        return;\n      }\n    }\n  });\n\n  // Keyboard controls\n  canvas.addEventListener(\"keydown\", (e) => {\n    const key = e.key;\n    if (!state.started) {\n      // Enter or Space starts\n      if (key === \"Enter\" || key === \" \" || key === \"Spacebar\") {\n        // ensure audio init\n        ensureAudioStarted();\n        startNewRound();\n        e.preventDefault();\n      }\n      // Toggle audio with 'a'\n      if (key.toLowerCase() === \"a\") {\n        toggleAudio();\n      }\n      if (key.toLowerCase() === \"h\") {\n        showHelp();\n      }\n      return;\n    }\n\n    // If game finished\n    if (state.round > ROUNDS) {\n      if (key.toLowerCase() === \"r\") {\n        ensureAudioStarted();\n        resetGame();\n        startNewRound();\n      }\n      return;\n    }\n\n    // In active round\n    if (key === \"ArrowLeft\") {\n      state.selectedIndex = (state.selectedIndex - 1 + state.current.options.length) % state.current.options.length;\n      playClick();\n      updateLive(`Selected gear ${state.current.options[state.selectedIndex]}`);\n      e.preventDefault();\n    } else if (key === \"ArrowRight\") {\n      state.selectedIndex = (state.selectedIndex + 1) % state.current.options.length;\n      playClick();\n      updateLive(`Selected gear ${state.current.options[state.selectedIndex]}`);\n      e.preventDefault();\n    } else if (key === \"Enter\") {\n      attemptSelection(state.selectedIndex);\n      e.preventDefault();\n    } else if (key.toLowerCase() === \"a\") {\n      toggleAudio();\n    } else if (key.toLowerCase() === \"h\") {\n      showHelp();\n    }\n  });\n\n  // Toggle audio on/off\n  function toggleAudio() {\n    if (!audioContext) {\n      updateLive(\"Audio not available on this device.\");\n      return;\n    }\n    if (!state.audioOn) {\n      ensureAudioStarted(true);\n    } else {\n      // turn off gently\n      try {\n        if (bgGain) bgGain.gain.setTargetAtTime(0, audioContext.currentTime, 0.03);\n        if (masterGain) masterGain.gain.setTargetAtTime(0.0001, audioContext.currentTime, 0.03);\n      } catch (e) {\n        console.warn(\"Error toggling audio:\", e);\n      }\n      state.audioOn = false;\n      updateLive(\"Audio muted\");\n    }\n  }\n\n  // Ensure audio context started and nodes initialized (call on first user gesture)\n  function ensureAudioStarted(forceOn = false) {\n    if (!audioContext) return;\n    if (audioContext.state === \"suspended\") {\n      audioContext.resume().then(() => {\n        audioEnabled = true;\n        state.audioOn = true;\n        initAudioNodes();\n        updateLive(\"Audio enabled\");\n      }).catch((err) => {\n        console.warn(\"Audio resume error:\", err);\n        updateLive(\"Audio could not be started.\");\n      });\n    } else {\n      if (!masterGain) {\n        initAudioNodes();\n      }\n      if (forceOn) {\n        // ramp up master gain\n        try {\n          masterGain.gain.setValueAtTime(0.0001, audioContext.currentTime);\n          masterGain.gain.linearRampToValueAtTime(0.9, audioContext.currentTime + 0.15);\n          if (bgGain) bgGain.gain.setValueAtTime(0.04, audioContext.currentTime + 0.15);\n        } catch (err) {\n          console.warn(\"Error ramping audio:\", err);\n        }\n        audioEnabled = true;\n        state.audioOn = true;\n      }\n    }\n  }\n\n  // Help overlay (simple live announcement and visual cue)\n  function showHelp() {\n    updateLive(\"Help: Choose the gear that completes the equation. Use left and right arrows to move and Enter to choose. Press A to toggle audio.\");\n    // temporary on-screen hint\n    state.lastMessage = \"Hint: Choose the gear so base + gear = target.\";\n    setTimeout(() => {\n      state.lastMessage = null;\n    }, 3000);\n  }\n\n  // Initialization\n  resetGame();\n  // Start render loop\n  requestAnimationFrame(render);\n\n  // Add initial live message for users\n  updateLive(\"Ready. Focus is on the game canvas. Press Enter or click to start. Press A to toggle audio. H for help.\");\n\n  // Small polyfill for roundRect if not available\n  if (!CanvasRenderingContext2D.prototype.roundRect) {\n    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {\n      const minr = Math.min(w, h) * 0.2;\n      if (Array.isArray(r)) {\n        r = r.map(rr => Math.min(rr, minr));\n      } else {\n        r = Math.min(r, minr);\n      }\n      this.beginPath();\n      this.moveTo(x + r, y);\n      this.arcTo(x + w, y, x + w, y + h, r);\n      this.arcTo(x + w, y + h, x, y + h, r);\n      this.arcTo(x, y + h, x, y, r);\n      this.arcTo(x, y, x + w, y, r);\n      this.closePath();\n    };\n  }\n\n  // Safety: catch global errors related to audio or canvas and report\n  window.addEventListener(\"error\", (ev) => {\n    console.error(\"Game error:\", ev.error || ev.message);\n    updateLive(\"An unexpected error occurred. Please try reloading the page.\");\n  });\n\n  // Ensure focus on canvas when container clicked\n  container.addEventListener(\"click\", () => {\n    canvas.focus();\n  });\n\n  // Provide friendly keyboard reminder\n  setTimeout(() => {\n    updateLive(\"Tip: Use keyboard or click. Press H for help, A to toggle audio.\");\n  }, 2000);\n})();\n---\n",
  "improve_response_tokens": 17994,
  "formatted_code": true,
  "formatting_response_tokens": 19906,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}