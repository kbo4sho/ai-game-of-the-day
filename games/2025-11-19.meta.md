# Game of the Day - 2025-11-19

## Metadata
- **Generated Date:** 2025-11-19
- **Generated Time:** 2025-11-19T00:29:36.773828
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-11-19.js
- **File Size:** 25545 bytes
- **Tokens Used:** 9346

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 4

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-11-19.js` - The playable game
- `2025-11-19.meta.json` - Machine-readable metadata
- `2025-11-19.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 17641

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 18389

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Educational Math Drone Game for ages 7-9
  // Renders inside element with id "game-of-the-day-stage"
  // All visuals drawn on canvas (720x480). Sounds via Web Audio API.
  // Author: AI assistant (example). Clean, commented, accessible.

  // Config
  const WIDTH = 720;
  const HEIGHT = 480;
  const PADDING = 10; // minimum padding between UI elements
  const GOAL_CORRECT = 10; // win condition
  const MAX_LIVES = 3; // lose condition
  const FONT_BODY = '16px "Segoe UI", Roboto, Arial, sans-serif';
  const FONT_LARGE = '22px "Segoe UI", Roboto, Arial, sans-serif';
  const FONT_TITLE = '28px "Segoe UI", Roboto, Arial, sans-serif';

  // Get container
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Game container with id "game-of-the-day-stage" not found.');
    return;
  }
  // Clear container
  container.innerHTML = '';
  container.style.position = 'relative';
  container.setAttribute('aria-label', 'Drone math game');
  container.setAttribute('role', 'application');

  // Accessible live region for screen readers (offscreen but inside container)
  const liveRegion = document.createElement('div');
  liveRegion.setAttribute('aria-live', 'polite');
  liveRegion.style.position = 'absolute';
  liveRegion.style.left = '-9999px';
  liveRegion.style.top = 'auto';
  liveRegion.style.width = '1px';
  liveRegion.style.height = '1px';
  container.appendChild(liveRegion);

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.display = 'block';
  canvas.style.background = 'transparent';
  canvas.tabIndex = 0; // make focusable for keyboard controls
  container.appendChild(canvas);

  const ctx = canvas.getContext('2d');
  if (!ctx) {
    console.error('Canvas 2D context not available.');
    return;
  }

  // Game state
  let score = 0;
  let lives = MAX_LIVES;
  let currentQuestion = null; // {text, answer, options}
  let selectedOptionIndex = 0;
  let gameState = 'intro'; // intro, playing, victory, gameover, waiting (for first interaction)
  let audioAllowed = false;
  let audioError = null;

  // Audio variables
  let audioCtx = null;
  let masterGain = null;
  let ambientOsc = null;
  let ambientGain = null;
  let soundEnabled = true; // default on, user can toggle
  let lastUserGesture = false;

  // UI layout calculators (non-overlapping)
  const topBarHeight = 60; // reserve top area
  const bottomBarHeight = 70; // reserve bottom area
  const centerArea = {
    x: PADDING,
    y: topBarHeight + PADDING,
    width: WIDTH - 2 * PADDING,
    height: HEIGHT - topBarHeight - bottomBarHeight - 2 * PADDING,
  };

  // Option button rectangles for click detection
  let optionButtons = []; // each: {x,y,w,h,index}

  // Animated elements
  const clouds = [
    {x: 50, y: 40, scale: 1.0, speed: 0.15},
    {x: 300, y: 20, scale: 1.2, speed: 0.1},
    {x: 600, y: 60, scale: 0.9, speed: 0.12},
  ];
  const drones = [
    {x: 120, y: 200, phase: 0, color: '#8ecae6'},
    {x: 580, y: 240, phase: 1.5, color: '#ffd6a5'},
  ];
  const starParticles = []; // for collecting animations

  // Timing
  let lastTime = performance.now();

  // Helper: try to initialize audio context on user gesture
  function initAudio() {
    if (audioCtx) return;
    try {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      if (!AudioContext) {
        audioError = 'Web Audio API not supported';
        console.warn(audioError);
        audioAllowed = false;
        return;
      }
      audioCtx = new AudioContext();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.9;
      masterGain.connect(audioCtx.destination);

      // Ambient gentle hum
      ambientOsc = audioCtx.createOscillator();
      ambientOsc.type = 'sine';
      ambientOsc.frequency.value = 120; // low hum
      const ambientFilter = audioCtx.createBiquadFilter();
      ambientFilter.type = 'lowpass';
      ambientFilter.frequency.value = 800;
      ambientGain = audioCtx.createGain();
      ambientGain.gain.value = 0.02; // very gentle
      ambientOsc.connect(ambientFilter);
      ambientFilter.connect(ambientGain);
      ambientGain.connect(masterGain);
      ambientOsc.start();

      audioAllowed = true;
      audioError = null;
    } catch (e) {
      audioAllowed = false;
      audioError = 'Audio context error: ' + (e && e.message ? e.message : String(e));
      console.warn(audioError);
    }
  }

  // Play a short beep for correct/incorrect
  function playFeedback(type = 'correct') {
    if (!audioAllowed || !audioCtx || !soundEnabled) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const f = audioCtx.createBiquadFilter();
      o.connect(f);
      f.connect(g);
      g.connect(masterGain);

      if (type === 'correct') {
        o.type = 'triangle';
        o.frequency.value = 880;
        f.type = 'lowpass';
        f.frequency.value = 1000;
        g.gain.value = 0;
        const now = audioCtx.currentTime;
        g.gain.setValueAtTime(0, now);
        g.gain.linearRampToValueAtTime(0.08, now + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);
        o.start(now);
        o.stop(now + 0.45);
      } else {
        // incorrect
        o.type = 'sawtooth';
        o.frequency.value = 220;
        f.type = 'highpass';
        f.frequency.value = 400;
        const now = audioCtx.currentTime;
        g.gain.setValueAtTime(0, now);
        g.gain.linearRampToValueAtTime(0.07, now + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);
        o.start(now);
        o.stop(now + 0.5);
      }
    } catch (e) {
      console.warn('Sound play error', e);
    }
  }

  // Announce to screen reader live region
  function announce(text) {
    liveRegion.textContent = '';
    setTimeout(() => {
      liveRegion.textContent = text;
    }, 50);
  }

  // Generate a simple math question appropriate for 7-9 year olds
  function generateQuestion() {
    // Mix addition, subtraction, simple multiplication
    const types = ['add', 'sub', 'mul'];
    const t = types[Math.floor(Math.random() * types.length)];
    let a, b, answer;
    if (t === 'add') {
      a = rand(1, 20);
      b = rand(1, 20);
      answer = a + b;
      return formatQuestion(`${a} + ${b} = ?`, answer);
    } else if (t === 'sub') {
      a = rand(5, 25);
      b = rand(1, a); // ensure non-negative
      answer = a - b;
      return formatQuestion(`${a} - ${b} = ?`, answer);
    } else {
      // multiplication but small
      a = rand(2, 7);
      b = rand(2, 7);
      answer = a * b;
      return formatQuestion(`${a} × ${b} = ?`, answer);
    }
  }

  function formatQuestion(text, answer) {
    // Create 4 options with one correct, rest distractors
    const options = [];
    options.push(answer);
    while (options.length < 4) {
      let delta = rand(-6, 6);
      if (delta === 0) delta = 1;
      let val = answer + delta;
      if (val < 0) val = Math.abs(val) + 1;
      if (!options.includes(val)) options.push(val);
    }
    // Shuffle
    for (let i = options.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [options[i], options[j]] = [options[j], options[i]];
    }
    return {text, answer, options};
  }

  function rand(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // Start or restart the game
  function startGame() {
    score = 0;
    lives = MAX_LIVES;
    selectedOptionIndex = 0;
    gameState = 'playing';
    nextQuestion();
    announce('Game started. Press number keys 1 to 4 to answer. Collect ' + GOAL_CORRECT + ' correct answers to win.');
  }

  function restartGame() {
    // For user gesture to initialize audio
    if (!lastUserGesture) {
      // focus canvas to receive keyboard
      canvas.focus();
    }
    startGame();
  }

  // Move to next question
  function nextQuestion() {
    currentQuestion = generateQuestion();
    selectedOptionIndex = 0;
    // Update live region with question and options
    announce('New question: ' + currentQuestion.text + ' Options: ' + currentQuestion.options.join(', '));
  }

  // Handle selection
  function chooseOption(index) {
    if (gameState !== 'playing') return;
    if (!currentQuestion) return;
    const chosen = currentQuestion.options[index];
    if (chosen === currentQuestion.answer) {
      // correct
      score++;
      spawnStars(6, WIDTH / 2, centerArea.y + 60);
      playFeedback('correct');
      announce('Correct! Score ' + score + '.');
      if (score >= GOAL_CORRECT) {
        gameState = 'victory';
        announce('Victory! You collected ' + GOAL_CORRECT + ' correct answers. Press R to restart or click restart button.');
        return;
      }
      // next question after short delay to allow animation
      setTimeout(nextQuestion, 650);
    } else {
      lives--;
      playFeedback('incorrect');
      spawnStars(10, WIDTH - 80, 40, false);
      announce('Oops, that was wrong. Lives left: ' + lives + '.');
      if (lives <= 0) {
        gameState = 'gameover';
        announce('Game over. You ran out of lives. Press R to restart or click restart button.');
        return;
      }
      // still next question
      setTimeout(nextQuestion, 650);
    }
  }

  // Spawn star particles for animation (correct/incorrect)
  function spawnStars(count, sx, sy, golden = true) {
    for (let i = 0; i < count; i++) {
      starParticles.push({
        x: sx + rand(-30, 30),
        y: sy + rand(-20, 20),
        vx: (Math.random() - 0.5) * 2,
        vy: -Math.random() * 2 - 1.5,
        life: 1 + Math.random() * 0.8,
        golden: golden,
        size: 6 + Math.random() * 6,
      });
    }
  }

  // Draw helpers
  function drawRoundedRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  // Main render loop
  function render(now) {
    const dt = Math.min(0.05, (now - lastTime) / 1000);
    lastTime = now;

    // Update animations
    clouds.forEach(c => {
      c.x += c.speed;
      if (c.x - 200 > WIDTH) c.x = -200;
    });
    drones.forEach(d => {
      d.phase += dt * 2;
      d.y += Math.sin(d.phase) * 0.6;
    });
    // update particles
    for (let i = starParticles.length - 1; i >= 0; i--) {
      const p = starParticles[i];
      p.vy += 0.05;
      p.x += p.vx;
      p.y += p.vy;
      p.life -= dt * 0.8;
      if (p.life <= 0) starParticles.splice(i, 1);
    }

    // Clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Background sky gradient
    const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    grad.addColorStop(0, '#e6f7ff');
    grad.addColorStop(1, '#f8fff7');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Draw clouds - calming/wacky shapes using arcs
    clouds.forEach((c, i) => {
      ctx.save();
      ctx.globalAlpha = 0.9 - i * 0.15;
      ctx.fillStyle = '#ffffff';
      const cx = c.x;
      const cy = c.y;
      const s = c.scale;
      drawCloud(cx, cy, 90 * s, 40 * s);
      ctx.restore();
    });

    // Draw soft hills / ground
    ctx.fillStyle = '#d7f8d7';
    ctx.beginPath();
    ctx.moveTo(0, HEIGHT);
    ctx.quadraticCurveTo(WIDTH * 0.25, HEIGHT - 80, WIDTH * 0.5, HEIGHT - 40);
    ctx.quadraticCurveTo(WIDTH * 0.75, HEIGHT - 10, WIDTH, HEIGHT - 70);
    ctx.lineTo(WIDTH, HEIGHT);
    ctx.closePath();
    ctx.fill();

    // Draw wacky drones (calming colors)
    drawDrone(100, 160 + Math.sin(now / 600) * 6, 1.0, '#89cff0', 'DR-1');
    drawDrone(540, 190 + Math.sin(now / 700) * 6, 1.1, '#ffd1dc', 'DR-2');

    // Draw top bar UI: score (top-left), lives (top-right), audio icon (top-center right)
    // Score area
    ctx.font = FONT_LARGE;
    ctx.textBaseline = 'top';
    const scoreText = 'Score: ' + score + ' / ' + GOAL_CORRECT;
    const scoreMetrics = ctx.measureText(scoreText);
    const scoreW = Math.ceil(scoreMetrics.width) + 16; // background padding
    const scoreH = 36;
    const scoreX = PADDING;
    const scoreY = PADDING;
    // background
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    drawRoundedRect(scoreX, scoreY, scoreW, scoreH, 8);
    // text
    ctx.fillStyle = '#1b3b6f';
    ctx.fillText(scoreText, scoreX + 8, scoreY + 6);

    // Lives area - top-right
    ctx.font = FONT_LARGE;
    const livesText = 'Lives: ';
    const livesMetrics = ctx.measureText(livesText);
    // we'll draw small drone-heart for each life
    const livesX = WIDTH - PADDING - 120;
    const livesY = PADDING;
    const livesW = 120;
    const livesH = 36;
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    drawRoundedRect(livesX, livesY, livesW, livesH, 8);
    ctx.fillStyle = '#2c3e50';
    ctx.fillText(livesText, livesX + 8, livesY + 6);
    // draw life icons right after text
    const iconStartX = livesX + 8 + livesMetrics.width + 8;
    for (let i = 0; i < MAX_LIVES; i++) {
      const lx = iconStartX + i * 26;
      drawLifeIcon(lx, livesY + 6, i < lives ? '#ffb4a2' : '#e0e0e0');
    }

    // Audio icon (visual cue for audio availability) top-center-right
    ctx.font = FONT_BODY;
    const audioLabel = soundEnabled ? 'Sound: on (M)' : 'Sound: off (M)';
    const audioMetrics = ctx.measureText(audioLabel);
    const audioW = Math.ceil(audioMetrics.width) + 20;
    const audioH = 28;
    const audioX = WIDTH - PADDING - audioW - 10;
    const audioY = livesY + livesH + 8;
    ctx.fillStyle = 'rgba(255,255,255,0.75)';
    drawRoundedRect(audioX, audioY, audioW, audioH, 8);
    ctx.fillStyle = '#1b3b6f';
    ctx.fillText(audioLabel, audioX + 10, audioY + 4);

    // Center area: question box and options
    ctx.font = FONT_TITLE;
    ctx.textBaseline = 'top';
    const qBoxX = centerArea.x + 12;
    const qBoxY = centerArea.y + 6;
    const qBoxW = centerArea.width - 24;
    const qBoxH = 120;
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    drawRoundedRect(qBoxX, qBoxY, qBoxW, qBoxH, 12);

    if (gameState === 'intro' || gameState === 'waiting') {
      // Intro screen: instructions
      ctx.fillStyle = '#0b3d91';
      ctx.font = FONT_TITLE;
      const title = 'Drone Math Mission';
      const titleMetrics = ctx.measureText(title);
      ctx.fillText(title, qBoxX + (qBoxW - titleMetrics.width) / 2, qBoxY + 12);

      ctx.font = FONT_BODY;
      const lines = [
        'Help the friendly drones collect correct numbers!',
        'Answer 10 questions correctly to win. You have 3 lives.',
        'Use number keys 1-4 or click options. Press M to toggle sound.',
        'Click the canvas or press any key to begin.',
      ];
      ctx.fillStyle = '#123a6a';
      let ly = qBoxY + 54;
      lines.forEach(line => {
        ctx.fillText(line, qBoxX + 16, ly);
        ly += 22;
      });
    } else {
      // Gameplay: draw question
      ctx.fillStyle = '#0b3d91';
      ctx.font = FONT_TITLE;
      const questionText = currentQuestion ? currentQuestion.text : '';
      // measure and center
      const mq = ctx.measureText(questionText);
      ctx.fillText(questionText, qBoxX + (qBoxW - mq.width) / 2, qBoxY + 14);

      // Draw options as buttons in two rows
      ctx.font = FONT_BODY;
      optionButtons = [];
      const optW = (qBoxW - 36) / 2;
      const optH = 44;
      const optStartX = qBoxX + 12;
      const optStartY = qBoxY + 64;
      for (let i = 0; i < 4; i++) {
        const col = i % 2;
        const row = Math.floor(i / 2);
        const x = optStartX + col * (optW + 12);
        const y = optStartY + row * (optH + 12);
        // background
        if (i === selectedOptionIndex) {
          ctx.fillStyle = 'rgba(143, 188, 143, 0.95)'; // highlighted
        } else {
          ctx.fillStyle = 'rgba(255,255,255,0.9)';
        }
        drawRoundedRect(x, y, optW, optH, 10);
        // text
        ctx.fillStyle = '#0b3d91';
        const optText = (i + 1) + '. ' + (currentQuestion ? currentQuestion.options[i] : '');
        const m = ctx.measureText(optText);
        // ensure text fits
        let tx = x + 12;
        ctx.fillText(optText, tx, y + 12);
        optionButtons.push({x, y, w: optW, h: optH, index: i});
      }
    }

    // Bottom instructions area (bottom-center)
    ctx.font = FONT_BODY;
    ctx.textBaseline = 'top';
    const instText = 'Controls: 1-4 to choose, ←/→ to change selection, Enter to confirm, M to mute, R to restart';
    const instMetrics = ctx.measureText(instText);
    const instW = Math.ceil(instMetrics.width) + 20;
    const instH = 28;
    const instX = (WIDTH - instW) / 2;
    const instY = HEIGHT - bottomBarHeight + 10;
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    drawRoundedRect(instX, instY, instW, instH, 8);
    ctx.fillStyle = '#173b6a';
    ctx.fillText(instText, instX + 10, instY + 4);

    // Draw star particles on top
    starParticles.forEach(p => {
      ctx.save();
      ctx.globalAlpha = Math.max(0, p.life);
      ctx.fillStyle = p.golden ? '#ffd166' : '#a0e7e5';
      drawStar(p.x, p.y, p.size / 2, p.size, 5);
      ctx.restore();
    });

    // Draw overlays for victory or gameover
    if (gameState === 'victory' || gameState === 'gameover') {
      ctx.save();
      ctx.fillStyle = 'rgba(10, 10, 30, 0.6)';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.font = FONT_TITLE;
      ctx.fillStyle = '#fff';
      const message = gameState === 'victory' ? 'Victory! Drones Celebrating!' : 'Game Over';
      const mm = ctx.measureText(message);
      ctx.fillText(message, (WIDTH - mm.width) / 2, HEIGHT / 2 - 60);
      ctx.font = FONT_LARGE;
      const sub = gameState === 'victory' ? 'You answered ' + score + ' correctly!' : 'You answered ' + score + ' correctly.';
      const sm = ctx.measureText(sub);
      ctx.fillText(sub, (WIDTH - sm.width) / 2, HEIGHT / 2 - 20);

      // restart button
      ctx.font = FONT_LARGE;
      const btnLabel = 'Restart (R)';
      const bm = ctx.measureText(btnLabel);
      const bw = bm.width + 24;
      const bh = 44;
      const bx = (WIDTH - bw) / 2;
      const by = HEIGHT / 2 + 30;
      ctx.fillStyle = '#ffffff';
      drawRoundedRect(bx, by, bw, bh, 12);
      ctx.fillStyle = '#0b3d91';
      ctx.fillText(btnLabel, bx + 12, by + 8);
      // store restart button rect for clicks
      restartButtonRect = {x: bx, y: by, w: bw, h: bh};
      ctx.restore();
    } else {
      restartButtonRect = null;
    }

    // Draw small help/hint at corner regarding audio availability
    ctx.font = '14px sans-serif';
    ctx.fillStyle = '#123a6a';
    const hint = audioError ? 'Audio not available' : (audioAllowed ? 'Audio ready' : 'Click or press any key to enable audio');
    const mh = ctx.measureText(hint);
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    drawRoundedRect(10, HEIGHT - 36, mh.width + 16, 26, 8);
    ctx.fillStyle = '#123a6a';
    ctx.fillText(hint, 18, HEIGHT - 34);

    // Loop
    requestAnimationFrame(render);
  }

  // Draw cloud helper
  function drawCloud(cx, cy, w, h) {
    ctx.beginPath();
    ctx.ellipse(cx, cy, w * 0.6, h * 0.6, 0, 0, Math.PI * 2);
    ctx.ellipse(cx - w * 0.4, cy + 10, w * 0.45, h * 0.45, -0.3, 0, Math.PI * 2);
    ctx.ellipse(cx + w * 0.4, cy + 8, w * 0.48, h * 0.48, 0.3, 0, Math.PI * 2);
    ctx.fill();
  }

  // Draw a wacky drone (simple shapes)
  function drawDrone(x, y, scale, color, label) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);

    // body
    ctx.fillStyle = color;
    drawRoundedRect(-36, -18, 72, 40, 10);

    // dome
    ctx.beginPath();
    ctx.fillStyle = '#ffffff';
    ctx.arc(0, -6, 14, Math.PI, 2 * Math.PI);
    ctx.fill();

    // propellers - wacky gentle arcs
    ctx.fillStyle = '#bdbdbd';
    for (let i = -1; i <= 1; i += 2) {
      ctx.beginPath();
      ctx.ellipse(-42 * i, -26, 8, 4, Math.PI / 6 * i, 0, Math.PI * 2);
      ctx.fill();
    }

    // eyes on dome
    ctx.fillStyle = '#2c3e50';
    ctx.beginPath();
    ctx.arc(-5, -8, 2.6, 0, Math.PI * 2);
    ctx.arc(6, -8, 2.6, 0, Math.PI * 2);
    ctx.fill();

    // little label
    ctx.font = '11px sans-serif';
    ctx.fillStyle = '#0b3d91';
    ctx.fillText(label || '', -12, 10);

    ctx.restore();
  }

  // Draw life icon (heart-like)
  function drawLifeIcon(x, y, fill) {
    ctx.save();
    ctx.fillStyle = fill;
    ctx.beginPath();
    ctx.moveTo(x + 6, y + 3);
    ctx.bezierCurveTo(x + 6, y - 2, x - 4, y - 2, x - 4, y + 4);
    ctx.bezierCurveTo(x - 4, y + 9, x + 6, y + 12, x + 6, y + 14);
    ctx.bezierCurveTo(x + 6, y + 12, x + 16, y + 9, x + 16, y + 4);
    ctx.bezierCurveTo(x + 16, y - 2, x + 6, y - 2, x + 6, y + 3);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  // Draw star helper
  function drawStar(cx, cy, innerR, outerR, points) {
    ctx.beginPath();
    const step = Math.PI / points;
    for (let i = 0; i < 2 * points; i++) {
      const r = i % 2 === 0 ? outerR : innerR;
      const a = i * step - Math.PI / 2;
      ctx.lineTo(cx + Math.cos(a) * r, cy + Math.sin(a) * r);
    }
    ctx.closePath();
    ctx.fill();
  }

  // Input handling
  let restartButtonRect = null;

  canvas.addEventListener('click', function (e) {
    lastUserGesture = true;
    ensureAudioInited();
    canvas.focus();
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (gameState === 'intro' || gameState === 'waiting') {
      startGame();
      return;
    }

    if (gameState === 'victory' || gameState === 'gameover') {
      if (restartButtonRect && pointInRect(x, y, restartButtonRect)) {
        restartGame();
      }
      return;
    }

    // check if clicked on option button
    for (const b of optionButtons) {
      if (pointInRect(x, y, b)) {
        selectedOptionIndex = b.index;
        chooseOption(b.index);
        return;
      }
    }

    // else if clicked audio area (approx by top-right audio rectangle)
    // We'll allow toggling if click near top-right area
    if (x > WIDTH - 200 && y < 110) {
      soundEnabled = !soundEnabled;
      announce('Sound ' + (soundEnabled ? 'on' : 'off'));
      return;
    }
  });

  // Keyboard controls
  canvas.addEventListener('keydown', function (e) {
    lastUserGesture = true;
    ensureAudioInited();
    if (e.key >= '1' && e.key <= '4') {
      if (gameState === 'playing') {
        const idx = parseInt(e.key, 10) - 1;
        selectedOptionIndex = idx;
        chooseOption(idx);
      }
      e.preventDefault();
      return;
    }
    if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
      if (gameState === 'playing') {
        selectedOptionIndex = (selectedOptionIndex + 3) % 4;
      }
      e.preventDefault();
      return;
    }
    if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
      if (gameState === 'playing') {
        selectedOptionIndex = (selectedOptionIndex + 1) % 4;
      }
      e.preventDefault();
      return;
    }
    if (e.key === 'Enter') {
      if (gameState === 'playing') {
        chooseOption(selectedOptionIndex);
      } else if (gameState === 'victory' || gameState === 'gameover') {
        restartGame();
      } else if (gameState === 'intro' || gameState === 'waiting') {
        startGame();
      }
      e.preventDefault();
      return;
    }
    if (e.key === 'm' || e.key === 'M') {
      soundEnabled = !soundEnabled;
      announce('Sound ' + (soundEnabled ? 'on' : 'off'));
      e.preventDefault();
      return;
    }
    if (e.key === 'r' || e.key === 'R') {
      restartGame();
      e.preventDefault();
      return;
    }
    // any other key starts audio
    if (gameState === 'intro' && !lastUserGesture) {
      lastUserGesture = true;
      ensureAudioInited();
      startGame();
    }
  });

  function pointInRect(px, py, r) {
    return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;
  }

  // Ensure audio started after user gesture
  function ensureAudioInited() {
    try {
      if (!audioCtx) initAudio();
      if (audioCtx && audioCtx.state === 'suspended') {
        audioCtx.resume().catch(e => {
          audioAllowed = false;
          audioError = 'Audio resume error: ' + e.message;
          console.warn(audioError);
        });
      }
    } catch (e) {
      audioAllowed = false;
      audioError = 'Audio init error: ' + (e && e.message ? e.message : e);
      console.warn(audioError);
    }
  }

  // Start rendering
  requestAnimationFrame(render);

  // Start in intro/waiting state
  gameState = 'intro';
  announce('Welcome to Drone Math Mission. Click or press any key to begin.');

  // Accessibility: focus to canvas to allow keyboard interactions
  canvas.addEventListener('focus', () => {
    // no-op but helpful
  });

  // Expose minimal controls via container for assistive tech (non-intrusive)
  container.addEventListener('keydown', function (e) {
    // forward to canvas handlers
    canvas.dispatchEvent(new KeyboardEvent('keydown', e));
  });

  // Error handling demonstration (audio)
  window.addEventListener('unhandledrejection', function (ev) {
    console.warn('Unhandled promise rejection in game', ev.reason);
  });

  // Utility: Start the audio context if the user clicks anywhere in the container
  container.addEventListener('pointerdown', function () {
    lastUserGesture = true;
    ensureAudioInited();
  }, {passive: true});

})();
---

