# Game of the Day - 2025-10-21

## Metadata
- **Generated Date:** 2025-10-21
- **Generated Time:** 2025-10-21T00:28:37.198158
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-10-21.js
- **File Size:** 30792 bytes
- **Tokens Used:** 10663

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-10-21.js` - The playable game
- `2025-10-21.meta.json` - Machine-readable metadata
- `2025-10-21.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 22481

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 24674

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Drone Math Adventure - JavaScript game
// Renders into existing HTML element with ID "game-of-the-day-stage"
// Game area is exactly 720x480, uses Canvas + Web Audio API, accessible controls, restart, win/lose screens.

// Immediately-invoked function to avoid global namespace pollution
(function () {
  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const TARGET_GOAL = 10; // win when player answers this many correctly
  const MAX_WRONG = 3; // lose after this many wrong answers
  const DRONE_SPEED = 220; // pixels per second
  const CRATE_COUNT = 4;
  const CRATE_MIN = 1;
  const CRATE_MAX = 15;
  const UI_PADDING = 10;
  const SCORE_FONT = "18px sans-serif"; // important info
  const BODY_FONT = "16px sans-serif"; // body text minimum 14
  const TITLE_FONT = "24px sans-serif";

  // Get container element
  const container = document.getElementById("game-of-the-day-stage");
  if (!container) {
    console.error("Container element with ID 'game-of-the-day-stage' not found.");
    return;
  }

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.tabIndex = 0; // make focusable for keyboard
  canvas.setAttribute("role", "application");
  canvas.setAttribute("aria-label", "Drone Math Adventure. Use arrow keys or WASD to move. Press space or click crates to collect answers.");
  canvas.style.outline = "none";
  container.innerHTML = ""; // clear container
  container.appendChild(canvas);
  const ctx = canvas.getContext("2d");

  // Audio setup with error handling
  let audioCtx = null;
  let audioAllowed = false;
  let audioUnavailable = false;
  const createAudioContext = () => {
    if (audioCtx || audioUnavailable) return;
    try {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) throw new Error("Web Audio API not supported");
      audioCtx = new Ctx();
      // To satisfy mobile/browser autoplay policies, resume on user gesture if suspended
      if (audioCtx.state === "suspended") {
        audioCtx.resume().then(() => {
          audioAllowed = true;
        }).catch((e) => {
          console.warn("Audio context resume failed:", e);
          audioAllowed = false;
        });
      } else {
        audioAllowed = true;
      }
    } catch (e) {
      console.error("Audio context creation failed:", e);
      audioUnavailable = true;
      audioCtx = null;
      audioAllowed = false;
    }
  };

  // Call createAudioContext on first user gesture to minimize autoplay issues
  const requireAudioGesture = () => {
    if (!audioCtx) createAudioContext();
  };

  // Sound helpers using oscillators
  function playTone(frequency = 440, duration = 0.2, type = "sine", volume = 0.06) {
    if (!audioCtx || !audioAllowed) return;
    try {
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = frequency;
      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime(volume, now + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + duration + 0.02);
    } catch (e) {
      console.warn("playTone failed:", e);
    }
  }

  function playPositiveSound() {
    if (!audioCtx || !audioAllowed) return;
    // Arpeggio: ascending short tones
    playTone(440, 0.12, "sine", 0.06);
    setTimeout(() => playTone(554.37, 0.12, "sine", 0.06), 120);
    setTimeout(() => playTone(659.25, 0.18, "sine", 0.07), 260);
  }

  function playNegativeSound() {
    if (!audioCtx || !audioAllowed) return;
    // Vibrating buzz
    try {
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const biquad = audioCtx.createBiquadFilter();
      osc.type = "square";
      osc.frequency.value = 150;
      biquad.type = "lowpass";
      biquad.frequency.value = 600;
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(0.08, now + 0.005);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);
      osc.connect(biquad).connect(gain).connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.45);
    } catch (e) {
      console.warn("playNegativeSound failed:", e);
    }
  }

  // Gentle background hum (optional, togglable)
  let humOsc = null;
  let humGain = null;
  function startHum() {
    if (!audioCtx || !audioAllowed || humOsc) return;
    try {
      humOsc = audioCtx.createOscillator();
      humGain = audioCtx.createGain();
      humOsc.type = "sine";
      humOsc.frequency.value = 120;
      humGain.gain.value = 0.008;
      const lfo = audioCtx.createOscillator();
      const lfoGain = audioCtx.createGain();
      lfo.type = "sine";
      lfo.frequency.value = 0.12;
      lfoGain.gain.value = 20;
      lfo.connect(lfoGain);
      lfoGain.connect(humOsc.detune);
      humOsc.connect(humGain).connect(audioCtx.destination);
      lfo.start();
      humOsc.start();
    } catch (e) {
      console.warn("startHum failed:", e);
      humOsc = null;
      humGain = null;
    }
  }
  function stopHum() {
    try {
      if (humOsc) {
        humOsc.stop();
        humOsc.disconnect();
        humOsc = null;
      }
      if (humGain) {
        humGain.disconnect();
        humGain = null;
      }
    } catch (e) {
      console.warn("stopHum failed:", e);
    }
  }

  // Game state
  let lastTime = performance.now();
  let keys = {};
  let mouse = { x: 0, y: 0, clicked: false };
  let gameState = "intro"; // "playing", "won", "lost"
  let score = 0;
  let wrongs = 0;
  let drone = {
    x: WIDTH / 2,
    y: HEIGHT / 2,
    r: 22,
    angle: 0,
    color: "#6fb1ff"
  };
  let crates = [];
  let currentTarget = null; // target sum number
  let hintText = "Move the drone to pick the crate with the correct answer!";
  let uiSoundEnabled = true;
  let audioStatusMsg = "Sound: unknown";
  let // control info used for bottom instructions
    controlsText =
      "Controls: Arrow keys / WASD to move. Space or click a crate to collect. Press S to toggle sound. Enter to restart when game ends.";

  // Utility functions
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function clamp(v, a, b) {
    return Math.max(a, Math.min(b, v));
  }

  function distance(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    return Math.sqrt(dx * dx + dy * dy);
  }

  // Generate crates ensuring not too close to UI top area and not overlapping drone start
  function spawnCrates() {
    crates = [];
    const marginTop = 80; // to avoid overlapping top UI
    for (let i = 0; i < CRATE_COUNT; i++) {
      let tries = 0;
      while (tries < 200) {
        const w = 56;
        const h = 46;
        const x = randInt(UI_PADDING + 20, WIDTH - w - UI_PADDING - 20);
        const y = randInt(marginTop + 10, HEIGHT - h - 80); // avoid bottom instructions area
        const num = randInt(CRATE_MIN, CRATE_MAX);
        const rect = { x, y, w, h, num, id: Math.random().toString(36).slice(2, 9) };
        // Ensure not overlapping other crates
        let ok = true;
        for (const c of crates) {
          if (Math.abs(c.x - rect.x) < 70 && Math.abs(c.y - rect.y) < 60) {
            ok = false;
            break;
          }
        }
        // Not too close to drone
        if (ok && Math.abs(rect.x - drone.x) < 80 && Math.abs(rect.y - drone.y) < 80) ok = false;
        if (ok) {
          crates.push(rect);
          break;
        }
        tries++;
      }
    }
  }

  // Generate a math question as target sum (simple addition/subtraction)
  function generateQuestion() {
    // Create target between 3 and 16 (age-appropriate)
    const a = randInt(1, 9);
    const b = randInt(1, 9);
    // 50% chance addition or subtraction (but subtraction result must be >=1)
    if (Math.random() < 0.7) {
      currentTarget = { text: `${a} + ${b}`, value: a + b };
    } else {
      const a2 = Math.max(a, b);
      const b2 = Math.min(a, b);
      currentTarget = { text: `${a2} - ${b2}`, value: a2 - b2 };
    }
    // Ensure crates include the correct answer
    // Place correct answer in a random crate and fill other crates with random numbers
    const answerIndex = randInt(0, crates.length - 1);
    const used = new Set([crates[answerIndex].num]);
    crates[answerIndex].num = currentTarget.value;
    used.add(currentTarget.value);
    // Fill others with non-equal numbers
    for (let i = 0; i < crates.length; i++) {
      if (i === answerIndex) continue;
      let tries = 0;
      while (tries < 200) {
        const n = randInt(CRATE_MIN, CRATE_MAX);
        if (!used.has(n)) {
          crates[i].num = n;
          used.add(n);
          break;
        }
        tries++;
      }
    }
  }

  // Reset game
  function resetGame() {
    score = 0;
    wrongs = 0;
    drone.x = WIDTH / 2;
    drone.y = HEIGHT - 100;
    drone.angle = 0;
    spawnCrates();
    generateQuestion();
    gameState = "playing";
    hintText = "Collect the crate with the answer to the math problem shown.";
    // Initialize audio context on first start if possible
    createAudioContext();
    if (audioCtx && audioAllowed) {
      startHum();
      audioStatusMsg = "Sound: on";
    } else if (audioUnavailable) {
      audioStatusMsg = "Sound: unavailable";
    } else {
      audioStatusMsg = "Sound: off (press S to enable)";
    }
  }

  // Handle picking a crate (by clicking or space key)
  function pickCrate(crate) {
    if (!crate) return;
    if (gameState !== "playing") return;
    if (crate.num === currentTarget.value) {
      score++;
      playPositiveSound();
      // small celebration animation (bump drone color)
      drone.color = "#8ef4a3";
      setTimeout(() => (drone.color = "#6fb1ff"), 220);
      if (score >= TARGET_GOAL) {
        gameState = "won";
        stopHum();
      } else {
        // new question: respawn crates and generate next
        spawnCrates();
        generateQuestion();
      }
    } else {
      wrongs++;
      playNegativeSound();
      drone.color = "#ffb1b1";
      setTimeout(() => (drone.color = "#6fb1ff"), 300);
      if (wrongs >= MAX_WRONG) {
        gameState = "lost";
        stopHum();
      }
    }
  }

  // Find nearest crate to drone within pick radius
  function findNearestCrate(radius = 50) {
    let nearest = null;
    let minD = Infinity;
    for (const c of crates) {
      const center = { x: c.x + c.w / 2, y: c.y + c.h / 2 };
      const d = distance(drone, center);
      if (d < minD) {
        minD = d;
        nearest = c;
      }
    }
    if (minD <= radius) return nearest;
    return null;
  }

  // Input event handlers
  canvas.addEventListener("keydown", (e) => {
    // start audio context on first interaction
    requireAudioGesture();
    keys[e.key.toLowerCase()] = true;
    // Prevent arrow keys from scrolling
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(e.key)) {
      e.preventDefault();
    }
    // Space: pick nearest crate
    if (e.key === " " || e.key === "Spacebar") {
      if (gameState === "playing") {
        const c = findNearestCrate(60);
        if (c) pickCrate(c);
      } else if (gameState === "won" || gameState === "lost") {
        resetGame();
      }
    }
    // Enter to restart on end screens
    if (e.key === "Enter" && (gameState === "won" || gameState === "lost")) {
      resetGame();
    }
    // S to toggle sound
    if (e.key.toLowerCase() === "s") {
      // toggle audio context: create if none, start/stop hum
      if (!audioCtx) {
        createAudioContext();
      }
      if (audioCtx && audioAllowed) {
        if (humOsc) {
          stopHum();
          audioStatusMsg = "Sound: off";
        } else {
          startHum();
          audioStatusMsg = "Sound: on";
        }
      } else if (!audioUnavailable) {
        // attempt to resume
        if (audioCtx && audioCtx.state === "suspended") {
          audioCtx.resume().then(() => {
            audioAllowed = true;
            startHum();
            audioStatusMsg = "Sound: on";
          }).catch((err) => {
            console.warn("Audio resume failed:", err);
            audioStatusMsg = "Sound: unavailable";
          });
        } else {
          audioStatusMsg = "Sound: unavailable";
        }
      }
    }
  });
  canvas.addEventListener("keyup", (e) => {
    keys[e.key.toLowerCase()] = false;
  });

  // Mouse / touch events
  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
    mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
  });
  canvas.addEventListener("mousedown", (e) => {
    requireAudioGesture();
    mouse.clicked = true;
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    const my = (e.clientY - rect.top) * (canvas.height / rect.height);
    // If in end-screen restart button area, allow restart
    if ((gameState === "won" || gameState === "lost")) {
      // Drawn restart button coordinates will be known during render; approximate clickable area centered
      // We'll check if click is within center button area
      const bx = WIDTH / 2 - 90;
      const by = HEIGHT / 2 + 36;
      const bw = 180;
      const bh = 44;
      if (mx >= bx && mx <= bx + bw && my >= by && my <= by + bh) {
        resetGame();
        return;
      }
    }
    // Check if clicked on any crate
    for (const c of crates) {
      if (mx >= c.x && mx <= c.x + c.w && my >= c.y && my <= c.y + c.h) {
        pickCrate(c);
        break;
      }
    }
  });
  canvas.addEventListener("mouseup", () => {
    mouse.clicked = false;
  });
  canvas.addEventListener("touchstart", (e) => {
    requireAudioGesture();
    const t = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    mouse.x = (t.clientX - rect.left) * (canvas.width / rect.width);
    mouse.y = (t.clientY - rect.top) * (canvas.height / rect.height);
    mouse.clicked = true;
    e.preventDefault();
    // click behavior mirrors mousedown
    for (const c of crates) {
      if (mouse.x >= c.x && mouse.x <= c.x + c.w && mouse.y >= c.y && mouse.y <= c.y + c.h) {
        pickCrate(c);
        break;
      }
    }
  }, { passive: false });
  canvas.addEventListener("touchmove", (e) => {
    const t = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    mouse.x = (t.clientX - rect.left) * (canvas.width / rect.width);
    mouse.y = (t.clientY - rect.top) * (canvas.height / rect.height);
  });
  canvas.addEventListener("touchend", () => {
    mouse.clicked = false;
  });

  // Drawing helpers
  function drawRoundedRect(x, y, w, h, r = 8, fillStyle = "#fff", strokeStyle = "#000", lineWidth = 1) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fillStyle) {
      ctx.fillStyle = fillStyle;
      ctx.fill();
    }
    if (strokeStyle) {
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = strokeStyle;
      ctx.stroke();
    }
  }

  // Text wrapping function
  function drawWrappedText(text, x, y, maxWidth, lineHeight, align = "center", font = BODY_FONT, bg = null) {
    ctx.font = font;
    const words = text.split(" ");
    let line = "";
    let lines = [];
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + " ";
      const metrics = ctx.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        lines.push(line.trim());
        line = words[n] + " ";
      } else {
        line = testLine;
      }
    }
    lines.push(line.trim());
    // Draw background if specified
    if (bg) {
      const textHeight = lines.length * lineHeight;
      const tw = maxWidth + 10;
      const th = textHeight + 10;
      const bx = x - tw / 2;
      const by = y - th / 2;
      drawRoundedRect(bx, by, tw, th, 10, bg.fill, bg.stroke, bg.lineWidth);
    }
    ctx.fillStyle = "#073b4c";
    ctx.textAlign = align;
    ctx.textBaseline = "top";
    for (let i = 0; i < lines.length; i++) {
      ctx.fillText(lines[i], x, y + i * lineHeight);
    }
  }

  // Prevent overlapping of UI text: compute positions using measureText
  function computeUILayout() {
    ctx.font = SCORE_FONT;
    const scoreText = `Score: ${score}`;
    const scoreW = ctx.measureText(scoreText).width;
    const scoreX = UI_PADDING;
    const scoreY = UI_PADDING;

    ctx.font = SCORE_FONT;
    const targetText = currentTarget ? `Problem: ${currentTarget.text}` : "Problem:";
    const targetW = ctx.measureText(targetText).width;
    const targetXCenter = WIDTH / 2;
    const targetLeft = targetXCenter - targetW / 2;
    const targetY = UI_PADDING;

    ctx.font = SCORE_FONT;
    const livesText = `Lives: ${Math.max(0, MAX_WRONG - wrongs)}`;
    const livesW = ctx.measureText(livesText).width;
    const livesX = WIDTH - UI_PADDING - livesW;
    const livesY = UI_PADDING;

    // Ensure at least 10px spacing between left, center, right items
    // If center overlaps either, move center down by 30 px
    let centerY = targetY;
    const scoreRight = scoreX + scoreW;
    const livesLeft = livesX;
    if (targetLeft - scoreRight < 10 || livesLeft - (targetLeft + targetW) < 10) {
      centerY = targetY + 36;
    }
    return {
      score: { text: scoreText, x: scoreX, y: scoreY, w: scoreW },
      target: { text: targetText, x: targetXCenter, y: centerY, w: targetW },
      lives: { text: livesText, x: livesX, y: livesY, w: livesW }
    };
  }

  // Drawing scene elements: calming background with wacky elements
  function drawBackground() {
    // Sky gradient
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, "#eaf6ff");
    g.addColorStop(0.6, "#f6fbff");
    g.addColorStop(1, "#eef6f5");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Soft rolling hills (calming shapes)
    ctx.fillStyle = "#cfeedd";
    ctx.beginPath();
    ctx.moveTo(0, HEIGHT * 0.65);
    ctx.quadraticCurveTo(WIDTH * 0.25, HEIGHT * 0.55, WIDTH * 0.5, HEIGHT * 0.66);
    ctx.quadraticCurveTo(WIDTH * 0.75, HEIGHT * 0.77, WIDTH, HEIGHT * 0.65);
    ctx.lineTo(WIDTH, HEIGHT);
    ctx.lineTo(0, HEIGHT);
    ctx.closePath();
    ctx.fill();

    // Wacky mountains
    ctx.fillStyle = "#e6f6ff";
    ctx.beginPath();
    ctx.moveTo(40, HEIGHT * 0.7);
    ctx.lineTo(140, HEIGHT * 0.44);
    ctx.lineTo(240, HEIGHT * 0.7);
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(340, HEIGHT * 0.72);
    ctx.lineTo(460, HEIGHT * 0.42);
    ctx.lineTo(560, HEIGHT * 0.72);
    ctx.closePath();
    ctx.fill();

    // Floating clouds (wacky)
    drawCloud(80, 80, 64, 28, "#ffffff");
    drawCloud(220, 60, 54, 24, "#ffffff");
    drawCloud(520, 90, 74, 30, "#ffffff");
    drawCloud(620, 50, 48, 20, "#ffffff");

    // Friendly landmark - a silly radio tower for drones
    drawTower(620, HEIGHT * 0.59, 36, 110);
  }

  function drawCloud(cx, cy, w, h, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.ellipse(cx - w * 0.2, cy, w * 0.32, h * 0.6, 0, 0, Math.PI * 2);
    ctx.ellipse(cx + w * 0.2, cy, w * 0.28, h * 0.55, 0, 0, Math.PI * 2);
    ctx.ellipse(cx, cy - h * 0.1, w * 0.3, h * 0.5, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawTower(x, y, w, h) {
    // tower base
    ctx.fillStyle = "#ffd27f";
    drawRoundedRect(x - w / 2, y - h, w, h, 6, "#ffd27f", "#d08a2f", 2);
    // antenna
    ctx.fillStyle = "#ffefc2";
    ctx.fillRect(x - 2, y - h - 18, 4, 18);
    // small signal rings
    ctx.strokeStyle = "#ffd27f";
    ctx.lineWidth = 1.6;
    ctx.beginPath();
    ctx.arc(x, y - h - 26, 12, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(x, y - h - 26, 20, 0, Math.PI * 2);
    ctx.stroke();
  }

  // Draw drone
  function drawDrone(dt) {
    // angle by velocity/keys
    ctx.save();
    ctx.translate(drone.x, drone.y);
    ctx.rotate(drone.angle);
    // propellers
    ctx.fillStyle = "#f0f9ff";
    ctx.beginPath();
    ctx.ellipse(-26, -8, 16, 6, Math.sin(performance.now() / 180) * 0.6, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(26, -8, 16, 6, Math.cos(performance.now() / 180) * 0.6, 0, Math.PI * 2);
    ctx.fill();
    // body
    drawRoundedRect(-20, -18, 40, 36, 10, drone.color, "#0b4b6a", 2);
    // cockpit
    ctx.fillStyle = "#072f44";
    ctx.beginPath();
    ctx.ellipse(6, 0, 10, 9, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // Friendly shadow
    ctx.fillStyle = "rgba(6,40,50,0.06)";
    ctx.beginPath();
    ctx.ellipse(drone.x, drone.y + 30, 44, 12, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // Draw crates
  function drawCrates() {
    for (const c of crates) {
      // crate box
      drawRoundedRect(c.x, c.y, c.w, c.h, 8, "#fff1cc", "#b98d4f", 2);
      // sticker with number
      ctx.fillStyle = "#ffd27f";
      drawRoundedRect(c.x + 6, c.y + 8, c.w - 12, c.h - 16, 6, "#ffeead", "#b98d4f", 1.2);
      // draw number
      ctx.font = TITLE_FONT;
      ctx.fillStyle = "#073b4c";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(c.num), c.x + c.w / 2, c.y + c.h / 2);
    }
  }

  // Draw UI: score, lives, target, instructions
  function drawUI() {
    const layout = computeUILayout();

    // Score background
    ctx.font = SCORE_FONT;
    const scorePad = 8;
    const scoreH = 30;
    drawRoundedRect(layout.score.x - scorePad, layout.score.y - 6, layout.score.w + scorePad * 2, scoreH, 8, "#ffffffcc", "#073b4c", 1);
    ctx.fillStyle = "#073b4c";
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    ctx.font = SCORE_FONT;
    ctx.fillText(layout.score.text, layout.score.x + 6, layout.score.y + scoreH / 2 - 6);

    // Target background (center)
    const targetW = Math.max(layout.target.w + 24, 180);
    const targetH = 36;
    drawRoundedRect(widthSafe(layout.target.x - targetW / 2), layout.target.y - 6, targetW, targetH, 10, "#e8f7ff", "#0b5775", 1.5);
    ctx.fillStyle = "#0b5775";
    ctx.font = TITLE_FONT;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    const targetText = currentTarget ? `Solve: ${currentTarget.text}` : "Solve:";
    ctx.fillText(targetText, layout.target.x, layout.target.y + targetH / 2 - 6);

    // Lives background
    const livesPad = 8;
    const livesH = 30;
    drawRoundedRect(layout.lives.x - livesPad, layout.lives.y - 6, layout.lives.w + livesPad * 2, livesH, 8, "#fff1f1", "#6b0505", 1);
    ctx.fillStyle = "#6b0505";
    ctx.font = SCORE_FONT;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    ctx.fillText(layout.lives.text, layout.lives.x + 6, layout.lives.y + livesH / 2 - 6);

    // Draw heart icons for lives count (visual)
    const remaining = Math.max(0, MAX_WRONG - wrongs);
    const heartXStart = WIDTH - UI_PADDING - 6 - layout.lives.w - 8 - (remaining * 18);
    for (let i = 0; i < remaining; i++) {
      drawHeart(heartXStart + i * 18, layout.lives.y + 12, 7, "#ff6b6b");
    }

    // Bottom-center instructions with background and wrapped text
    const instrY = HEIGHT - 68;
    drawWrappedText(controlsText, WIDTH / 2, instrY, WIDTH - 40, 20, "center", BODY_FONT, { fill: "#ffffffcc", stroke: "#073b4c", lineWidth: 1 });

    // Audio status small badge (top-left below score)
    ctx.font = "14px sans-serif";
    const audText = audioUnavailable ? "Audio unavailable" : audioStatusMsg;
    const aw = ctx.measureText(audText).width + 12;
    drawRoundedRect(UI_PADDING, layout.score.y + 36, aw, 24, 8, "#ffffffcc", "#073b4c", 1);
    ctx.fillStyle = "#073b4c";
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    ctx.fillText(audText, UI_PADDING + 6, layout.score.y + 48 - 6);

    // Hint text left-bottom
    ctx.font = BODY_FONT;
    ctx.textAlign = "left";
    ctx.fillStyle = "#073b4c";
    const hintBoxW = 300;
    drawRoundedRect(UI_PADDING, HEIGHT - 130, hintBoxW, 44, 8, "#e6faff", "#0b5775", 1);
    ctx.fillStyle = "#0b5775";
    ctx.fillText(hintText, UI_PADDING + 10, HEIGHT - 108);

    // Visual cue for audio enabled/disabled (speaker icon)
    drawSpeaker(UI_PADDING + aw + 12, layout.score.y + 44, audioUnavailable ? "#bdbdbd" : (humOsc ? "#0b5775" : "#6b6b6b"));

    // Avoid overlapping: ensure bottom instructions do not overlap crates; crates were spawned avoiding bottom area.
  }

  function widthSafe(v) {
    // ensure rectangle inside canvas
    return Math.max(8, Math.min(v, WIDTH - 8));
  }

  function drawHeart(x, y, size, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.bezierCurveTo(x, y - size / 2, x - size, y - size / 2, x - size, y + size / 3);
    ctx.bezierCurveTo(x - size, y + size, x, y + size * 1.4, x, y + size * 1.8);
    ctx.bezierCurveTo(x, y + size * 1.4, x + size, y + size, x + size, y + size / 3);
    ctx.bezierCurveTo(x + size, y - size / 2, x, y - size / 2, x, y);
    ctx.fill();
  }

  function drawSpeaker(x, y, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x, y - 6);
    ctx.lineTo(x + 8, y - 10);
    ctx.lineTo(x + 8, y + 10);
    ctx.lineTo(x, y + 6);
    ctx.closePath();
    ctx.fill();
    if (!audioUnavailable && humOsc) {
      // draw sound waves
      ctx.strokeStyle = "#0b5775";
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.arc(x + 12, y - 2, 8, -0.6, 0.6);
      ctx.stroke();
    }
  }

  // End screens
  function drawEndScreen() {
    // dark overlay
    ctx.fillStyle = "rgba(2,15,22,0.5)";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Panel
    const panelW = 520;
    const panelH = 220;
    const px = (WIDTH - panelW) / 2;
    const py = (HEIGHT - panelH) / 2;
    drawRoundedRect(px, py, panelW, panelH, 12, "#ffffff", "#073b4c", 2);

    ctx.fillStyle = "#073b4c";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.font = TITLE_FONT;

    if (gameState === "won") {
      ctx.fillText("Victory! Drone Mission Accomplished", WIDTH / 2, py + 18);
      ctx.font = SCORE_FONT;
      ctx.fillText(`You answered ${score} correct problems!`, WIDTH / 2, py + 64);
    } else {
      ctx.fillText("Game Over", WIDTH / 2, py + 18);
      ctx.font = SCORE_FONT;
      ctx.fillText(`You answered ${score} correctly. Try again!`, WIDTH / 2, py + 64);
    }

    // Restart button
    const bx = WIDTH / 2 - 90;
    const by = py + panelH - 80;
    const bw = 180;
    const bh = 44;
    drawRoundedRect(bx, by, bw, bh, 10, "#eaf6ff", "#0b5775", 2);
    ctx.fillStyle = "#0b5775";
    ctx.font = BODY_FONT;
    ctx.fillText("Restart Mission", WIDTH / 2, by + 12);

    // Instruction small
    ctx.font = "14px sans-serif";
    ctx.fillStyle = "#0b5775";
    ctx.fillText("Click the button or press Enter to try again", WIDTH / 2, by + bh + 12);
  }

  // Game loop
  function update(dt) {
    if (gameState !== "playing") return;
    // Movement input
    let vx = 0,
      vy = 0;
    if (keys["arrowleft"] || keys["a"]) vx -= 1;
    if (keys["arrowright"] || keys["d"]) vx += 1;
    if (keys["arrowup"] || keys["w"]) vy -= 1;
    if (keys["arrowdown"] || keys["s"]) vy += 1;
    // Normalize
    if (vx !== 0 || vy !== 0) {
      const len = Math.sqrt(vx * vx + vy * vy);
      vx /= len;
      vy /= len;
      drone.x += vx * DRONE_SPEED * dt;
      drone.y += vy * DRONE_SPEED * dt;
      drone.angle = Math.atan2(vy, vx) + Math.PI / 2;
    } else {
      // subtle wobble when idle
      drone.angle = Math.sin(performance.now() / 600) * 0.06;
    }
    // Keep within bounds
    drone.x = clamp(drone.x, 30, WIDTH - 30);
    drone.y = clamp(drone.y, 40, HEIGHT - 40);

    // If mouse clicked near crate, pick it (for continuous dragging clicks we only handle down events)
    // handled in mousedown event

    // Ensure crates don't overlap UI (they were spawned with margins), but ensure not on top of drone while playing
    for (const c of crates) {
      if (Math.abs(c.x + c.w / 2 - drone.x) < 18 && Math.abs(c.y + c.h / 2 - drone.y) < 18) {
        // nudge crate
        c.x += randInt(-30, 30);
        c.y += randInt(-30, 30);
        c.x = clamp(c.x, UI_PADDING + 10, WIDTH - c.w - UI_PADDING - 10);
        c.y = clamp(c.y, 80, HEIGHT - c.h - 90);
      }
    }
  }

  function render(dt) {
    // Clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Background and elements
    drawBackground();

    // Draw crates and drone (order matters)
    drawCrates();
    drawDrone(dt);

    // UI
    drawUI();

    // If mouse is hovering near a crate, give a visual highlight and potential pick hint
    for (const c of crates) {
      if (mouse.x >= c.x && mouse.x <= c.x + c.w && mouse.y >= c.y && mouse.y <= c.y + c.h) {
        // highlight
        ctx.strokeStyle = "#0b5775";
        ctx.lineWidth = 3;
        ctx.strokeRect(c.x - 4, c.y - 4, c.w + 8, c.h + 8);
      }
    }

    // End screens
    if (gameState === "won" || gameState === "lost") {
      drawEndScreen();
    }
  }

  // Main loop using requestAnimationFrame
  function loop(now) {
    const dt = Math.min(0.05, (now - lastTime) / 1000);
    lastTime = now;
    update(dt);
    render(dt);
    requestAnimationFrame(loop);
  }

  // Initialize
  function init() {
    // Basic focus for keyboard events
    canvas.focus();

    // Initial spawn and question
    spawnCrates();
    generateQuestion();

    // Set initial audio context status
    if (typeof window.AudioContext === "undefined" && typeof window.webkitAudioContext === "undefined") {
      audioUnavailable = true;
      audioStatusMsg = "Sound: unavailable";
    } else {
      audioStatusMsg = "Sound: off (press S to enable)";
    }

    // Start game loop
    lastTime = performance.now();
    requestAnimationFrame(loop);
  }

  // Accessibility: provide a visible restart function via keyboard for screen readers
  // We will expose restart via canvas 'aria-describedby' update (note: best-effort)
  canvas.setAttribute("title", "Drone Math Adventure. Press Enter to restart when game ends.");

  // Start the game
  try {
    init();
  } catch (e) {
    console.error("Game initialization failed:", e);
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    ctx.fillStyle = "#fff";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    ctx.fillStyle = "#000";
    ctx.font = "16px sans-serif";
    ctx.fillText("An error occurred initializing the game. Please try reloading the page.", 20, 40);
  }
})();
---

