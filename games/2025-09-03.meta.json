{
  "generated_date": "2025-09-03",
  "generated_timestamp": "2025-09-03T00:25:53.164465",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9458,
  "game_filename": "2025-09-03.js",
  "game_size_bytes": 27320,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function() {\n  // Machine Math - Playable educational game for ages 7-9\n  // Renders inside element with ID 'game-of-the-day-stage'\n  // Uses Canvas for graphics and Web Audio API for sound (generated).\n  // Controls: Left/Right arrows or A/D to move selector. Enter/Space to pick/place.\n  // Click/tap parts to pick/place. 'H' for hint. 'M' to toggle sound (also click speaker icon).\n  // Accessible text readouts are provided via offscreen ARIA elements.\n\n  // ---- Config ----\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const STAGE_ID = 'game-of-the-day-stage';\n  const MAX_LEVELS = 6;\n  const GENTLE_BG_VOLUME = 0.03;\n  const CORRECT_VOLUME = 0.18;\n  const INCORRECT_VOLUME = 0.18;\n\n  // ---- Utility ----\n  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));\n  const rand = (a, b) => a + Math.random() * (b - a);\n  const pick = arr => arr[Math.floor(Math.random() * arr.length)];\n\n  // ---- Stage and Accessibility ----\n  const stage = document.getElementById(STAGE_ID);\n  if (!stage) {\n    console.error(`Element with id \"${STAGE_ID}\" not found. Game cannot start.`);\n    return;\n  }\n  stage.style.position = 'relative';\n  stage.style.width = WIDTH + 'px';\n  stage.style.height = HEIGHT + 'px';\n  stage.setAttribute('tabindex', '0'); // make focusable\n\n  // Create ARIA friendly offscreen instructions for screen readers\n  const srInstructions = document.createElement('div');\n  srInstructions.setAttribute('aria-live', 'polite');\n  srInstructions.style.position = 'absolute';\n  srInstructions.style.left = '-9999px';\n  srInstructions.style.top = 'auto';\n  srInstructions.style.width = '1px';\n  srInstructions.style.height = '1px';\n  srInstructions.style.overflow = 'hidden';\n  srInstructions.textContent = 'Machine Math game loaded. Use arrow keys to move, Enter to pick or place parts. Press H for a hint. Press M to toggle sound.';\n  stage.appendChild(srInstructions);\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.display = 'block';\n  canvas.style.outline = 'none';\n  canvas.setAttribute('role', 'img');\n  canvas.setAttribute('aria-label', 'Machine Math game canvas');\n  stage.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Create a small visible speaker button for audio toggle (drawn on canvas too, but a DOM button for accessibility)\n  const speakerBtn = document.createElement('button');\n  speakerBtn.style.position = 'absolute';\n  speakerBtn.style.right = '10px';\n  speakerBtn.style.top = '10px';\n  speakerBtn.style.padding = '6px 8px';\n  speakerBtn.style.borderRadius = '6px';\n  speakerBtn.style.border = '1px solid rgba(0,0,0,0.15)';\n  speakerBtn.style.background = 'rgba(255,255,255,0.9)';\n  speakerBtn.style.cursor = 'pointer';\n  speakerBtn.setAttribute('aria-pressed', 'true');\n  speakerBtn.textContent = 'Sound: On';\n  stage.appendChild(speakerBtn);\n\n  // Hidden live region for gameplay announcements\n  const srAnnounce = document.createElement('div');\n  srAnnounce.setAttribute('aria-live', 'polite');\n  srAnnounce.style.position = 'absolute';\n  srAnnounce.style.left = '-9999px';\n  stage.appendChild(srAnnounce);\n\n  // ---- Audio Setup ----\n  let audioEnabled = true;\n  let audioContext = null;\n  let bgGain = null;\n  let bgOsc = null;\n  let audioReady = false;\n  let audioAllowedByUser = false;\n\n  function initAudioOnUserGesture() {\n    if (audioReady || !audioEnabled) return;\n    try {\n      // create or resume AudioContext\n      const AC = window.AudioContext || window.webkitAudioContext;\n      if (!AC) {\n        console.warn('Web Audio API not supported in this browser.');\n        audioEnabled = false;\n        speakerBtn.textContent = 'Sound: Off';\n        speakerBtn.setAttribute('aria-pressed', 'false');\n        return;\n      }\n      audioContext = new AC();\n\n      // Background gentle hum\n      bgGain = audioContext.createGain();\n      bgGain.gain.value = GENTLE_BG_VOLUME;\n      bgGain.connect(audioContext.destination);\n\n      bgOsc = audioContext.createOscillator();\n      bgOsc.type = 'sine';\n      bgOsc.frequency.value = 110; // low hum\n      // Add gentle slow vibrato via oscillator detune\n      const lfo = audioContext.createOscillator();\n      lfo.type = 'sine';\n      lfo.frequency.value = 0.18; // slow\n      const lfoGain = audioContext.createGain();\n      lfoGain.gain.value = 20; // cents\n      lfo.connect(lfoGain);\n      lfoGain.connect(bgOsc.detune);\n      bgOsc.connect(bgGain);\n\n      bgOsc.start();\n      lfo.start();\n\n      audioReady = true;\n      audioAllowedByUser = true;\n      srAnnounce.textContent = 'Audio enabled.';\n    } catch (e) {\n      console.warn('Audio initialization failed:', e);\n      audioEnabled = false;\n      speakerBtn.textContent = 'Sound: Off';\n      speakerBtn.setAttribute('aria-pressed', 'false');\n      srAnnounce.textContent = 'Audio unavailable.';\n    }\n  }\n\n  function stopBackground() {\n    if (bgOsc) {\n      try {\n        bgOsc.stop();\n      } catch (e) {}\n      bgOsc.disconnect();\n      bgOsc = null;\n    }\n    if (bgGain) {\n      try { bgGain.disconnect(); } catch (e) {}\n      bgGain = null;\n    }\n  }\n\n  function toggleAudio() {\n    audioEnabled = !audioEnabled;\n    if (audioEnabled) {\n      speakerBtn.textContent = 'Sound: On';\n      speakerBtn.setAttribute('aria-pressed', 'true');\n      // Wait for a user gesture to start audio\n      srAnnounce.textContent = 'Sound will start on next interaction.';\n    } else {\n      speakerBtn.textContent = 'Sound: Off';\n      speakerBtn.setAttribute('aria-pressed', 'false');\n      stopBackground();\n      audioReady = false;\n      audioAllowedByUser = false;\n    }\n  }\n\n  speakerBtn.addEventListener('click', () => {\n    toggleAudio();\n    canvas.focus();\n  });\n\n  // Play a short tone - returns Promise that resolves when done\n  function playTone({freq = 440, dur = 0.18, type = 'sine', volume = 0.15, when = 0, detune = 0}) {\n    if (!audioEnabled) return Promise.resolve();\n    if (!audioContext) return Promise.resolve();\n    return new Promise((resolve) => {\n      try {\n        const now = audioContext.currentTime + when;\n        const osc = audioContext.createOscillator();\n        osc.type = type;\n        osc.frequency.value = freq;\n        osc.detune.value = detune;\n\n        const gain = audioContext.createGain();\n        gain.gain.value = 0.0001;\n\n        osc.connect(gain);\n        gain.connect(audioContext.destination);\n\n        gain.gain.setValueAtTime(0.0001, now);\n        gain.gain.exponentialRampToValueAtTime(volume, now + 0.02);\n        gain.gain.exponentialRampToValueAtTime(0.0001, now + dur);\n\n        osc.start(now);\n        osc.stop(now + dur + 0.02);\n\n        osc.onended = () => {\n          try { gain.disconnect(); } catch (e) {}\n          try { osc.disconnect(); } catch (e) {}\n          resolve();\n        };\n      } catch (e) {\n        console.warn('playTone error', e);\n        resolve();\n      }\n    });\n  }\n\n  function playCorrectMelody() {\n    if (!audioEnabled) return;\n    if (!audioContext) return;\n    // ascending triad\n    const freqs = [440, 550, 660];\n    freqs.forEach((f, i) => playTone({freq: f, dur: 0.15, when: i * 0.12, type: 'sine', volume: CORRECT_VOLUME}));\n  }\n\n  function playIncorrectBuzz() {\n    if (!audioEnabled) return;\n    if (!audioContext) return;\n    // short buzzer\n    const now = audioContext.currentTime;\n    try {\n      const osc = audioContext.createOscillator();\n      osc.type = 'square';\n      osc.frequency.value = 180;\n      const gain = audioContext.createGain();\n      gain.gain.value = 0.0001;\n      osc.connect(gain);\n      gain.connect(audioContext.destination);\n      gain.gain.setValueAtTime(0.0001, now);\n      gain.gain.exponentialRampToValueAtTime(INCORRECT_VOLUME, now + 0.01);\n      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);\n      osc.start(now);\n      osc.stop(now + 0.26);\n      osc.onended = () => {\n        try { gain.disconnect(); } catch (e) {}\n        try { osc.disconnect(); } catch (e) {}\n      };\n    } catch (e) {\n      console.warn('playIncorrectBuzz error', e);\n    }\n  }\n\n  // ---- Game State ----\n  let running = true;\n  let lastTime = 0;\n  let parts = []; // conveyor parts\n  let selector = { x: WIDTH / 2, y: HEIGHT - 90, width: 52, height: 28, holding: null };\n  let placedParts = []; // parts placed into machine (values)\n  let level = 1;\n  let target = 5;\n  let attemptsLeft = 3;\n  let levelCompleted = false;\n  let confetti = [];\n  let showHint = false;\n\n  // Generate level targets (increasing difficulty)\n  function computeTargets() {\n    const arr = [];\n    for (let i = 0; i < MAX_LEVELS; i++) {\n      arr.push(5 + i + Math.floor(i / 2) * 2); // 5,6,7,9,10,12 etc.\n    }\n    return arr;\n  }\n  const targetsList = computeTargets();\n\n  // ---- Parts/Conveyor ----\n  function createPart(x, value) {\n    return {\n      x,\n      y: 110 + Math.sin(x * 0.02) * 6,\n      r: 22,\n      value,\n      picked: false,\n      wobble: Math.random() * Math.PI * 2\n    };\n  }\n\n  function populateConveyor(levelNum) {\n    parts = [];\n    const count = 9;\n    const startX = -60;\n    for (let i = 0; i < count; i++) {\n      const x = startX + i * 90;\n      // values between 1..(level+4)\n      const maxVal = clamp(6 + levelNum + 2, 6, 12);\n      const value = Math.floor(rand(1, Math.min(9, maxVal) + 1));\n      parts.push(createPart(x, value));\n    }\n  }\n\n  // ---- Game Flow ----\n  function startLevel(lvl) {\n    level = lvl;\n    target = targetsList[clamp(level - 1, 0, targetsList.length - 1)];\n    attemptsLeft = 3;\n    placedParts = [];\n    levelCompleted = false;\n    confetti = [];\n    populateConveyor(level);\n    srAnnounce.textContent = `Level ${level}. Make ${target} using parts from the conveyor. Use arrow keys to move and press Enter to pick or place.`;\n  }\n\n  // ---- Interaction ----\n  const keys = {};\n  function handleKeyDown(e) {\n    // Guarantee audio on user gesture\n    if (!audioAllowedByUser && audioEnabled) {\n      initAudioOnUserGesture();\n    }\n    keys[e.key] = true;\n    if (e.key === 'm' || e.key === 'M') {\n      toggleAudio();\n      e.preventDefault();\n    }\n    if (e.key === 'h' || e.key === 'H') {\n      requestHint();\n      e.preventDefault();\n    }\n    // Allow picking with Enter or Space\n    if (e.key === 'Enter' || e.key === ' ') {\n      if (!selector.holding) {\n        // attempt pick at selector x\n        pickPartAtSelector();\n      } else {\n        // place into machine\n        placeIntoMachine();\n      }\n      e.preventDefault();\n    }\n    if ((e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A')) {\n      e.preventDefault();\n    }\n    if ((e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D')) {\n      e.preventDefault();\n    }\n  }\n  function handleKeyUp(e) {\n    keys[e.key] = false;\n  }\n\n  window.addEventListener('keydown', handleKeyDown);\n  window.addEventListener('keyup', handleKeyUp);\n\n  // Mouse/touch interactions\n  canvas.addEventListener('click', (ev) => {\n    // start audio if needed\n    if (!audioAllowedByUser && audioEnabled) {\n      initAudioOnUserGesture();\n    }\n    const rect = canvas.getBoundingClientRect();\n    const mx = ev.clientX - rect.left;\n    const my = ev.clientY - rect.top;\n    canvas.focus();\n\n    // If clicked on speaker button area? Speaker button is DOM so ignore.\n\n    // If clicked on part, toggle pick/place\n    const part = parts.find(p => {\n      const dx = mx - p.x;\n      const dy = my - p.y;\n      return Math.hypot(dx, dy) <= p.r + 6;\n    });\n    if (part) {\n      // move selector to that part and pick\n      selector.x = clamp(part.x, 40, WIDTH - 40);\n      pickPartAtSelector();\n      return;\n    }\n\n    // If clicked near machine place zone, attempt to place\n    if (mx > WIDTH - 240 && my > 60 && my < HEIGHT - 120) {\n      if (selector.holding) placeIntoMachine();\n      return;\n    }\n\n    // Click elsewhere: move selector\n    selector.x = clamp(mx, 40, WIDTH - 40);\n  });\n\n  // Pick part near selector\n  function pickPartAtSelector() {\n    if (selector.holding) return;\n    // find nearest part within picking range\n    let nearest = null;\n    let nearestDist = 9999;\n    for (const p of parts) {\n      if (p.picked) continue;\n      const d = Math.abs(p.x - selector.x) + Math.abs(p.y - selector.y);\n      if (d < nearestDist && d < 80) {\n        nearest = p;\n        nearestDist = d;\n      }\n    }\n    if (nearest) {\n      nearest.picked = true;\n      selector.holding = nearest;\n      // Visual cue and small sound\n      playTone({freq: 660, dur: 0.08, type: 'sine', volume: 0.08});\n      srAnnounce.textContent = `Picked a part: ${nearest.value}. Current held: ${nearest.value}.`;\n    } else {\n      // gentle denied sound\n      playTone({freq: 240, dur: 0.08, type: 'sine', volume: 0.06});\n      srAnnounce.textContent = 'No part nearby to pick. Move closer to the conveyor.';\n    }\n  }\n\n  function placeIntoMachine() {\n    if (!selector.holding) return;\n    // place into machine area (right side)\n    const value = selector.holding.value;\n    placedParts.push(value);\n    selector.holding = null;\n    srAnnounce.textContent = `Placed ${value}. Current total: ${placedParts.reduce((a,b)=>a+b,0)} of ${target}.`;\n    // check result\n    const sum = placedParts.reduce((a,b)=>a+b,0);\n    if (sum === target) {\n      // success\n      levelCompleted = true;\n      playCorrectMelody();\n      createConfettiBurst();\n      srAnnounce.textContent = `Correct! Level ${level} complete.`;\n      setTimeout(() => {\n        if (level < MAX_LEVELS) startLevel(level + 1);\n        else finishGame();\n      }, 1200);\n    } else if (sum > target) {\n      // overshoot\n      attemptsLeft -= 1;\n      playIncorrectBuzz();\n      flashError();\n      srAnnounce.textContent = `Oops! That's too many. You have ${attemptsLeft} attempts left. Current total: ${sum} of ${target}.`;\n      if (attemptsLeft <= 0) {\n        // reset the level gently\n        setTimeout(() => {\n          srAnnounce.textContent = `Let's try that level again.`;\n          startLevel(level);\n        }, 900);\n      } else {\n        // allow removing last part (we'll remove it automatically to keep it beatable)\n        // remove last placed part and return it to the conveyor near selector\n        const removed = placedParts.pop();\n        // create a returned part near selector.x\n        const newPart = createPart(selector.x, removed);\n        newPart.picked = false;\n        parts.push(newPart);\n      }\n    } else {\n      // continue, small ding\n      playTone({freq: 520, dur: 0.08, type: 'triangle', volume: 0.06});\n    }\n  }\n\n  // Hint system: suggest a part that helps reach target\n  function requestHint() {\n    showHint = true;\n    // Find a part on conveyor that could be helpful (value <= remaining)\n    const remaining = target - placedParts.reduce((a,b)=>a+b,0);\n    const candidates = parts.filter(p => !p.picked && p.value <= remaining);\n    if (candidates.length === 0) {\n      srAnnounce.textContent = 'No helpful parts available. Try picking a small number or reset the level.';\n      playTone({freq: 220, dur: 0.12, type: 'sine', volume: 0.06});\n      return;\n    }\n    const chosen = pick(candidates);\n    // move selector to chosen so player can easily pick\n    selector.x = clamp(chosen.x, 40, WIDTH - 40);\n    srAnnounce.textContent = `Hint: Try the part with value ${chosen.value} near the conveyor.`;\n    playTone({freq: 660, dur: 0.12, type: 'sine', volume: 0.08});\n  }\n\n  // Finish the game\n  function finishGame() {\n    srAnnounce.textContent = 'Fantastic! You finished all the machine levels. Well done!';\n    // Celebrate visually and with sound\n    for (let i = 0; i < 40; i++) createConfettiBurst();\n    playCorrectMelody();\n    // allow restart\n    setTimeout(() => {\n      startLevel(1);\n    }, 4000);\n  }\n\n  // ---- Visual helpers ----\n  function drawBackground() {\n    // Soft vertical gradient sky\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, '#EAF2FF');\n    g.addColorStop(1, '#F7F9FF');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Random gentle clouds\n    ctx.fillStyle = 'rgba(255,255,255,0.85)';\n    for (let i = 0; i < 6; i++) {\n      const cx = (i * 130 + 60 + (Date.now() * 0.02 * (i%3 - 1))) % WIDTH;\n      const cy = 40 + (i % 3) * 20;\n      drawCloud(cx, cy, 38 + (i % 3) * 8);\n    }\n  }\n  function drawCloud(cx, cy, size) {\n    ctx.beginPath();\n    ctx.arc(cx, cy, size, 0, Math.PI * 2);\n    ctx.arc(cx + size * 0.8, cy + 8, size * 0.8, 0, Math.PI * 2);\n    ctx.arc(cx - size * 0.9, cy + 6, size * 0.7, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  function drawConveyor() {\n    // conveyor belt base\n    ctx.fillStyle = '#DDE7F9';\n    ctx.fillRect(0, 80, WIDTH - 220, 140);\n    // belt pattern\n    ctx.fillStyle = '#C7D8F0';\n    for (let i = 0; i < 20; i++) {\n      ctx.fillRect((i * 80 + (Date.now() * 0.02 % 80)), 150, 40, 14);\n    }\n    // left machine arm\n    drawWackyMachineArm(60, 120, 1.0);\n    // Right machine (receiving)\n    drawReceivingMachine(WIDTH - 200, 40);\n  }\n\n  function drawWackyMachineArm(x, y, scale) {\n    // base\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.scale(scale, scale);\n    ctx.fillStyle = '#D2EAF1';\n    roundRect(ctx, -12, 12, 60, 20, 6);\n    ctx.fill();\n    // arm\n    ctx.fillStyle = '#9FC8D6';\n    roundRect(ctx, 0, -6, 12, 46, 6);\n    ctx.fill();\n    // claw\n    ctx.beginPath();\n    ctx.fillStyle = '#6BB0C4';\n    ctx.arc(36, 18, 12, 0, Math.PI * 2);\n    ctx.fill();\n    // eye decal\n    ctx.fillStyle = '#FFFFFF';\n    ctx.beginPath();\n    ctx.arc(8, 24, 6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = '#334';\n    ctx.fillRect(5, 26, 4, 3);\n    ctx.restore();\n  }\n\n  function drawReceivingMachine(x, y) {\n    // main box\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.fillStyle = '#F7EAD9';\n    roundRect(ctx, 0, 0, 200, 240, 12);\n    ctx.fill();\n    // machine face\n    ctx.fillStyle = '#F2D7BA';\n    roundRect(ctx, 14, 24, 172, 80, 10);\n    ctx.fill();\n    // eyes\n    ctx.fillStyle = '#fff';\n    ctx.beginPath();\n    ctx.arc(52, 66, 12, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(148, 66, 12, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = '#334';\n    ctx.beginPath();\n    ctx.arc(52, 68, 6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(148, 68, 6, 0, Math.PI * 2);\n    ctx.fill();\n    // slot where parts go\n    ctx.fillStyle = '#ECD5B8';\n    roundRect(ctx, 18, 120, 164, 34, 8);\n    ctx.fill();\n    // target display as a digital label\n    ctx.fillStyle = '#0E4C6C';\n    ctx.font = '26px \"Arial\", sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText(`Target: ${target}`, 100, 32);\n    // display placed parts as little gears\n    for (let i = 0; i < placedParts.length; i++) {\n      const vx = 36 + i * 40;\n      drawGear(24 + vx, 138, 14, '#F8C77E', '#D98B4B', placedParts[i]);\n    }\n    ctx.restore();\n  }\n\n  function drawParts() {\n    // draw each part on conveyor\n    for (const p of parts) {\n      // move\n      p.x += 0.6 + Math.sin(Date.now() * 0.001 + p.wobble) * 0.1;\n      p.wobble += 0.01;\n      if (p.x > WIDTH - 240) {\n        p.x = -40;\n      }\n      p.y = 120 + Math.sin(p.x * 0.02 + p.wobble) * 8;\n      // if picked by selector, follow it\n      if (selector.holding === p) {\n        p.x = selector.x;\n        p.y = selector.y - 26;\n      }\n      ctx.save();\n      // shadow\n      ctx.fillStyle = 'rgba(40,40,40,0.08)';\n      ctx.beginPath();\n      ctx.ellipse(p.x, p.y + 24, 24, 8, 0, 0, Math.PI * 2);\n      ctx.fill();\n\n      drawGear(p.x, p.y, p.r, '#E8F1FF', '#6AA5D8', p.value, p.picked);\n      ctx.restore();\n    }\n  }\n\n  function drawGear(cx, cy, radius, fillColor, strokeColor, label, dimmed=false) {\n    ctx.save();\n    ctx.strokeStyle = strokeColor;\n    ctx.fillStyle = fillColor;\n    ctx.lineWidth = 2;\n    // simple gear-like disc with teeth\n    const teeth = 8;\n    ctx.beginPath();\n    for (let i = 0; i < teeth; i++) {\n      const a = (i / teeth) * Math.PI * 2;\n      const r1 = radius - 2;\n      const r2 = radius + 6;\n      const x1 = cx + Math.cos(a) * r1;\n      const y1 = cy + Math.sin(a) * r1;\n      const x2 = cx + Math.cos(a + 0.06) * r2;\n      const y2 = cy + Math.sin(a + 0.06) * r2;\n      ctx.lineTo(x1, y1);\n      ctx.lineTo(x2, y2);\n    }\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n\n    // center circle\n    ctx.beginPath();\n    ctx.fillStyle = dimmed ? 'rgba(255,255,255,0.4)' : '#fff';\n    ctx.arc(cx, cy, radius - 8, 0, Math.PI * 2);\n    ctx.fill();\n\n    // label\n    ctx.fillStyle = '#334';\n    ctx.font = 'bold 14px \"Arial\", sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(String(label), cx, cy);\n    ctx.restore();\n  }\n\n  function drawSelector() {\n    // selector bar\n    ctx.save();\n    ctx.translate(selector.x, selector.y);\n    // base plate\n    ctx.fillStyle = '#FFF9EA';\n    roundRect(ctx, -selector.width/2, -selector.height/2, selector.width, selector.height, 6);\n    ctx.fill();\n    // handle\n    ctx.fillStyle = '#A7C8D9';\n    roundRect(ctx, -10, -selector.height/2 - 12, 20, 12, 6);\n    ctx.fill();\n    // holding part preview\n    if (selector.holding) {\n      drawGear(0, -34, 16, '#FFF0D6', '#E7A85D', selector.holding.value);\n    }\n    // small label\n    ctx.fillStyle = '#334';\n    ctx.font = '12px \"Arial\", sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('Grabber', 0, 16);\n    ctx.restore();\n\n    // visual guide: if audio is off, show speaker-off icon\n    ctx.save();\n    ctx.translate(WIDTH - 80, 20);\n    ctx.fillStyle = audioEnabled ? '#3B8EA5' : '#888';\n    ctx.beginPath();\n    ctx.arc(0, 0, 12, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = '#fff';\n    ctx.font = '10px \"Arial\", sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(audioEnabled ? '\u266b' : '\u2715', 0, 0);\n    ctx.restore();\n  }\n\n  function drawHUD() {\n    // top left level/attempts\n    ctx.fillStyle = '#334';\n    ctx.font = '18px \"Arial\", sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText(`Level ${level}/${MAX_LEVELS}`, 12, 30);\n    ctx.font = '14px \"Arial\", sans-serif';\n    ctx.fillText(`Attempts: ${attemptsLeft}`, 12, 52);\n\n    // instructions\n    ctx.fillStyle = '#334';\n    ctx.font = '12px \"Arial\", sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('Move with \u2190 \u2192 or A/D. Pick/place with Enter or Space. Press H for a hint. M toggles sound.', WIDTH / 2, HEIGHT - 10);\n\n    // target badge left of machine for clarity\n    ctx.save();\n    ctx.fillStyle = '#FDE4B2';\n    roundRect(ctx, WIDTH - 265, 12, 120, 34, 8);\n    ctx.fill();\n    ctx.fillStyle = '#0D3E57';\n    ctx.font = '20px \"Arial\", sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText(`${target}`, WIDTH - 205, 36);\n    ctx.restore();\n  }\n\n  // Confetti for celebration\n  function createConfettiBurst() {\n    for (let i = 0; i < 12; i++) {\n      confetti.push({\n        x: WIDTH - 100 + rand(-40, 40),\n        y: 80 + rand(0, 40),\n        vx: rand(-2.3, 2.3),\n        vy: rand(-6.5, -2.0),\n        size: rand(4, 8),\n        color: pick(['#FFB86B', '#FF7FA7', '#8BD36C', '#7FC8FF', '#FFD86B']),\n        life: rand(1.6, 2.6)\n      });\n    }\n    playTone({freq: 880, dur: 0.12, volume: 0.14});\n  }\n\n  function updateConfetti(dt) {\n    for (const c of confetti) {\n      c.vy += 9.8 * dt;\n      c.x += c.vx;\n      c.y += c.vy;\n      c.life -= dt;\n    }\n    // remove expired\n    confetti = confetti.filter(c => c.life > 0);\n  }\n\n  function drawConfetti() {\n    for (const c of confetti) {\n      ctx.fillStyle = c.color;\n      ctx.fillRect(c.x, c.y, c.size, c.size * 1.6);\n    }\n  }\n\n  // Flashing border on error\n  let flashTimer = 0;\n  function flashError() {\n    flashTimer = 0.5; // seconds\n  }\n\n  // ---- Helpers for drawing rounded rects ----\n  function roundRect(ctx, x, y, w, h, r) {\n    const radius = r || 6;\n    ctx.beginPath();\n    ctx.moveTo(x + radius, y);\n    ctx.arcTo(x + w, y, x + w, y + h, radius);\n    ctx.arcTo(x + w, y + h, x, y + h, radius);\n    ctx.arcTo(x, y + h, x, y, radius);\n    ctx.arcTo(x, y, x + w, y, radius);\n    ctx.closePath();\n  }\n\n  // ---- Main Loop ----\n  function update(dt) {\n    // Input handling\n    if (keys['ArrowLeft'] || keys['a'] || keys['A']) {\n      selector.x -= 220 * dt;\n    } else if (keys['ArrowRight'] || keys['d'] || keys['D']) {\n      selector.x += 220 * dt;\n    }\n    selector.x = clamp(selector.x, 40, WIDTH - 40);\n\n    // update parts positions done in drawParts()\n\n    updateConfetti(dt);\n\n    if (flashTimer > 0) flashTimer -= dt;\n  }\n\n  function draw() {\n    // Clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    // Background & environment\n    drawBackground();\n    drawConveyor();\n    drawParts();\n    drawSelector();\n    drawHUD();\n    drawConfetti();\n\n    // overlay flash for error\n    if (flashTimer > 0) {\n      const alpha = Math.sin(flashTimer * 20) * 0.15 + 0.12;\n      ctx.fillStyle = `rgba(255,90,80,${alpha})`;\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    }\n\n    // Show hint highlight momentarily\n    if (showHint) {\n      ctx.save();\n      ctx.strokeStyle = '#FF7FA7';\n      ctx.lineWidth = 3;\n      ctx.setLineDash([6, 4]);\n      ctx.strokeRect(selector.x - 50, selector.y - 70, 100, 80);\n      ctx.restore();\n      // hide after a moment\n      setTimeout(() => showHint = false, 1000);\n    }\n  }\n\n  function loop(t) {\n    if (!running) return;\n    if (!lastTime) lastTime = t;\n    const dt = Math.min(0.05, (t - lastTime) / 1000);\n    lastTime = t;\n    update(dt);\n    draw();\n    requestAnimationFrame(loop);\n  }\n\n  // ---- Initialize ----\n  function init() {\n    // Basic error handling: ensure canvas context exists\n    if (!ctx) {\n      console.error('Canvas rendering context not available.');\n      stage.appendChild(document.createTextNode('Unable to start the game: canvas not supported.'));\n      return;\n    }\n\n    // Focus canvas for keyboard control\n    canvas.setAttribute('tabindex', '0');\n    canvas.focus();\n\n    // Begin at level 1\n    startLevel(1);\n\n    // Start game loop\n    requestAnimationFrame(loop);\n  }\n\n  // Start audio on first mousedown or key press to satisfy browser policies\n  function firstUserGestureHandler() {\n    if (!audioAllowedByUser && audioEnabled) {\n      initAudioOnUserGesture();\n    }\n    // remove listeners (we only need to capture first)\n    window.removeEventListener('mousedown', firstUserGestureHandler);\n    window.removeEventListener('touchstart', firstUserGestureHandler);\n    window.removeEventListener('keydown', firstUserGestureHandler);\n  }\n  window.addEventListener('mousedown', firstUserGestureHandler);\n  window.addEventListener('touchstart', firstUserGestureHandler);\n  window.addEventListener('keydown', firstUserGestureHandler);\n\n  // Keyboard accessibility: ensure stage gains focus on click\n  stage.addEventListener('click', () => canvas.focus());\n\n  // Prevent accidental text selection during play\n  stage.addEventListener('selectstart', (e) => e.preventDefault());\n\n  // Start everything\n  try {\n    init();\n  } catch (err) {\n    console.error('Game initialization error:', err);\n    srAnnounce.textContent = 'An error occurred while starting the game. Please try reloading the page.';\n  }\n\n  // Expose a simple API for testing/debugging via window (non-essential)\n  window._machineMathGame = {\n    startLevel,\n    toggleAudio,\n    get state() {\n      return { level, target, attemptsLeft, placedParts, partsCount: parts.length };\n    }\n  };\n})();\n---\n",
  "improve_response_tokens": 18897,
  "formatted_code": true,
  "formatting_response_tokens": 20026,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}