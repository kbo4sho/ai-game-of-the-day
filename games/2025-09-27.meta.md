# Game of the Day - 2025-09-27

## Metadata
- **Generated Date:** 2025-09-27
- **Generated Time:** 2025-09-27T00:25:25.202543
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-27.js
- **File Size:** 25364 bytes
- **Tokens Used:** 8359

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-27.js` - The playable game
- `2025-09-27.meta.json` - Machine-readable metadata
- `2025-09-27.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 18454

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 19685

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Machine Math - Educational Game for ages 7-9
// Renders into the element with ID "game-of-the-day-stage"
// All visuals drawn on canvas. Sound via Web Audio API. Accessible instructions added to DOM.
// Written with clean modern JavaScript and comments.

(() => {
  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const MAX_LEVELS = 5;
  const CONTAINER_ID = "game-of-the-day-stage";

  // Utility helpers
  const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  // Find container
  const container = document.getElementById(CONTAINER_ID);
  if (!container) {
    console.error("Game container not found: #" + CONTAINER_ID);
    return;
  }

  // Clear container and set up accessible instructions node
  container.innerHTML = "";
  container.style.position = "relative";
  container.setAttribute("aria-label", "Machine Math game. A child-friendly math puzzle with machines and number tiles.");
  const textInstructions = document.createElement("div");
  textInstructions.style.position = "absolute";
  textInstructions.style.left = "8px";
  textInstructions.style.top = "8px";
  textInstructions.style.maxWidth = "440px";
  textInstructions.style.background = "rgba(255,255,255,0.0)";
  textInstructions.style.color = "#000";
  textInstructions.style.fontFamily = "sans-serif";
  textInstructions.style.fontSize = "12px";
  textInstructions.style.lineHeight = "1.2";
  textInstructions.setAttribute("role", "region");
  textInstructions.setAttribute("aria-live", "polite");
  textInstructions.innerText =
    "Machine Math: Help power the silly machines! Use mouse or keyboard. Arrow keys to move, Enter or Space to pick a tile, Backspace to remove, P to press the power button. Match the tiles to the target sum shown on the machine. Complete all machines to win!";
  container.appendChild(textInstructions);

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.border = "2px solid #223";
  canvas.style.display = "block";
  canvas.style.margin = "0 auto";
  canvas.style.background = "#F6FBFF";
  canvas.setAttribute("role", "img");
  canvas.setAttribute("aria-label", "Game canvas for Machine Math");
  container.appendChild(canvas);
  const ctx = canvas.getContext("2d");

  // Audio setup with error handling
  let audioCtx = null;
  let bgGain = null;
  let bgOsc = null;
  let masterGain = null;
  let clickGain = null;
  let playingBackground = false;

  function initAudio() {
    try {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      if (!AudioContext) throw new Error("Web Audio API not supported in this browser.");
      audioCtx = new AudioContext();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.9;
      masterGain.connect(audioCtx.destination);

      // Background gentle hum - two detuned oscillators through lowpass
      bgGain = audioCtx.createGain();
      bgGain.gain.value = 0.04;
      const filter = audioCtx.createBiquadFilter();
      filter.type = "lowpass";
      filter.frequency.value = 600;
      filter.Q.value = 0.7;

      bgOsc = audioCtx.createOscillator();
      bgOsc.type = "sine";
      bgOsc.frequency.value = 110; // low hum
      const bgOsc2 = audioCtx.createOscillator();
      bgOsc2.type = "sine";
      bgOsc2.frequency.value = 115;

      bgOsc.connect(bgGain);
      bgOsc2.connect(bgGain);
      bgGain.connect(filter);
      filter.connect(masterGain);

      // gentle tremolo via gain automation
      const lfo = audioCtx.createOscillator();
      const lfoGain = audioCtx.createGain();
      lfo.frequency.value = 0.12;
      lfoGain.gain.value = 0.03;
      lfo.connect(lfoGain);
      lfoGain.connect(bgGain.gain);

      // click gain for short sounds
      clickGain = audioCtx.createGain();
      clickGain.gain.value = 0.9;
      clickGain.connect(masterGain);

      // start oscillators on user gesture (we'll start when resumeAudio called)
      bgOsc.start();
      bgOsc2.start();
      lfo.start();
      playingBackground = true;
    } catch (err) {
      console.error("Audio init error:", err);
      audioCtx = null;
    }
  }

  // Call initAudio but be prepared to resume on user gesture
  initAudio();

  function resumeAudio() {
    if (!audioCtx) initAudio();
    if (!audioCtx) return;
    if (audioCtx.state === "suspended") {
      audioCtx.resume().catch((e) => console.warn("Audio resume failed:", e));
    }
  }

  function playTone({ frequency = 440, type = "sine", duration = 0.15, volume = 0.12, attack = 0.01, release = 0.06, filterFreq = 4000 }) {
    if (!audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const filt = audioCtx.createBiquadFilter();

      osc.type = type;
      osc.frequency.value = frequency;
      filt.type = "lowpass";
      filt.frequency.value = filterFreq;

      g.gain.setValueAtTime(0.0001, now);
      g.gain.linearRampToValueAtTime(volume, now + attack);
      g.gain.linearRampToValueAtTime(0.0001, now + duration - release);

      osc.connect(filt);
      filt.connect(g);
      g.connect(clickGain);

      osc.start(now);
      osc.stop(now + duration + 0.02);
    } catch (err) {
      console.warn("playTone error:", err);
    }
  }

  function playCorrect() {
    resumeAudio();
    // pleasant rising triad gliss
    playTone({ frequency: 660, type: "sine", duration: 0.14, volume: 0.12, filterFreq: 900 });
    setTimeout(() => playTone({ frequency: 880, type: "sawtooth", duration: 0.12, volume: 0.12, filterFreq: 1200 }), 80);
    setTimeout(() => playTone({ frequency: 990, type: "triangle", duration: 0.16, volume: 0.12, filterFreq: 1500 }), 160);
  }

  function playIncorrect() {
    resumeAudio();
    // low buzz with quick decay
    playTone({ frequency: 130, type: "square", duration: 0.26, volume: 0.12, filterFreq: 900 });
  }

  function playClick() {
    resumeAudio();
    playTone({ frequency: 420, type: "sine", duration: 0.08, volume: 0.12, filterFreq: 1200 });
  }

  // Game state
  let level = 1;
  let target = 0;
  let tiles = []; // array of numbers
  let selectedIndices = new Set();
  let attempts = 0;
  let score = 0;
  let message = "Welcome! Press Space or click a tile to select. Press P to power the machine.";
  let mouse = { x: 0, y: 0, down: false };
  let focusedTile = 0; // for keyboard navigation
  let powerButton = { x: WIDTH - 140, y: HEIGHT - 110, w: 110, h: 70 };

  // Generate level: target sum and tiles
  function generateLevel(l) {
    // Difficulty scales: start with small sums, increase targets and number of tiles
    const tileCount = clamp(4 + Math.floor(l / 2), 4, 9);
    // target between 6 and 20 + l*3
    target = randInt(6 + l * 1, 10 + l * 3);
    // Create tiles that include at least one valid combination
    tiles = [];
    // ensure at least 2-3 tiles sum to target
    const comboSize = clamp(2 + (l % 3), 2, 4);
    let combo = [];
    // build combo numbers
    let remaining = target;
    for (let i = 0; i < comboSize - 1; i++) {
      const maxPart = Math.max(1, Math.floor(remaining / (comboSize - i)));
      const part = randInt(1, maxPart);
      combo.push(part);
      remaining -= part;
    }
    combo.push(remaining);
    // Fill tiles with combo and other randoms
    combo.forEach((n) => tiles.push(n));
    while (tiles.length < tileCount) {
      tiles.push(randInt(1, Math.max(6, target - 1)));
    }
    // Shuffle tiles
    for (let i = tiles.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
    }
    selectedIndices.clear();
    attempts = 0;
    focusedTile = 0;
    message = `Level ${l}: Make the machine target ${target}.`;
  }

  // Start game
  function startGame() {
    level = 1;
    score = 0;
    generateLevel(level);
    running = true;
  }

  // Game interactions
  function toggleSelectIndex(idx) {
    if (idx < 0 || idx >= tiles.length) return;
    if (selectedIndices.has(idx)) {
      selectedIndices.delete(idx);
      playClick();
    } else {
      selectedIndices.add(idx);
      playClick();
    }
    attempts++;
  }

  function submitPower() {
    // sum selected
    const sum = Array.from(selectedIndices).reduce((acc, i) => acc + tiles[i], 0);
    if (sum === target) {
      // success animation and advance
      score += 10 + Math.max(0, 5 - attempts);
      playCorrect();
      message = "Perfect! Machine powered up! Moving to next machine...";
      // small celebration animation trigger
      triggerFireworks();
      setTimeout(() => {
        level++;
        if (level > MAX_LEVELS) {
          message = `You powered all machines! Score: ${score}. Press R to play again.`;
          running = false;
        } else {
          generateLevel(level);
        }
      }, 1100);
    } else {
      // incorrect
      playIncorrect();
      message = `Hmm! Selected sum is ${sum}. Try again!`;
      // subtle shake or visual cue
      shakeStart = performance.now();
      // do not remove selections automatically to encourage retry
    }
  }

  // Visual state for wacky calming machines
  function drawBackground() {
    // Soft gradient sky
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, "#EAF6FF");
    g.addColorStop(1, "#F6FBFF");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // soft floating bubbles
    for (let i = 0; i < 6; i++) {
      const bx = (i * 137) % WIDTH + 50;
      const by = ((i * 73) % HEIGHT) + 30;
      const r = 20 + (i % 3) * 6;
      ctx.beginPath();
      ctx.fillStyle = "rgba(200,230,255,0.22)";
      ctx.arc(bx + Math.sin((time / 1000) + i) * 12, by + Math.cos((time / 1400) + i) * 7, r, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawMachine() {
    // Machine body - whimsical shapes
    const mx = WIDTH / 2;
    const my = 120;
    // base
    ctx.fillStyle = "#F0E9FF";
    ctx.strokeStyle = "#664466";
    ctx.lineWidth = 3;
    roundRect(ctx, mx - 220, my - 30, 440, 160, 18, true, true);
    // screen
    ctx.fillStyle = "#111a2b";
    roundRect(ctx, mx - 180, my - 10, 260, 90, 12, true, true);
    // target display
    ctx.fillStyle = "#D1F0FF";
    roundRect(ctx, mx + 40, my - 0, 100, 54, 8, true, true);
    ctx.fillStyle = "#004b66";
    ctx.font = "28px Comic Sans MS, Arial";
    ctx.textAlign = "center";
    ctx.fillText(`TARGET`, mx + 90, my + 8);
    ctx.font = "36px Comic Sans MS, Arial";
    ctx.fillStyle = "#003a4d";
    ctx.fillText(`${target}`, mx + 90, my + 40);

    // pipes and knobs
    for (let i = 0; i < 3; i++) {
      const px = mx - 180 + i * 140;
      ctx.fillStyle = "#c9e6ff";
      roundRect(ctx, px, my + 60, 80, 24, 8, true, true);
      // knob
      ctx.beginPath();
      ctx.fillStyle = "#FFEAAD";
      ctx.arc(px + 12, my + 72, 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
    }

    // power socket with wacky eyes
    ctx.fillStyle = "#FFD8EE";
    ctx.beginPath();
    ctx.ellipse(mx + 180, my + 40, 42, 34, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "#AA5577";
    ctx.stroke();

    // eyes
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.arc(mx + 170, my + 30, 8, 0, Math.PI * 2);
    ctx.arc(mx + 190, my + 32, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#111";
    ctx.beginPath();
    ctx.arc(mx + 170, my + 30, 3, 0, Math.PI * 2);
    ctx.arc(mx + 190, my + 32, 3, 0, Math.PI * 2);
    ctx.fill();

    // power button (draw as separate interactive area)
    ctx.fillStyle = "#2b5235";
    roundRect(ctx, powerButton.x, powerButton.y, powerButton.w, powerButton.h, 10, true, true);
    // if keyboard focus is on power (when no tile focused?) show highlight - we'll show when focusedTile equals -1
    if (focusedTile === -1) {
      ctx.strokeStyle = "#FFE07A";
      ctx.lineWidth = 4;
      roundRect(ctx, powerButton.x - 4, powerButton.y - 4, powerButton.w + 8, powerButton.h + 8, 14, false, true);
    }
    ctx.fillStyle = "#BFF0AD";
    ctx.font = "22px Comic Sans MS, Arial";
    ctx.textAlign = "center";
    ctx.fillText("POWER", powerButton.x + powerButton.w / 2, powerButton.y + 42);
  }

  // draw tiles (number tiles)
  function drawTiles() {
    const areaX = 36;
    const areaY = 260;
    const tileW = 84;
    const tileH = 64;
    const gap = 12;
    for (let i = 0; i < tiles.length; i++) {
      const col = i % 5;
      const row = Math.floor(i / 5);
      const x = areaX + col * (tileW + gap);
      const y = areaY + row * (tileH + gap);
      const isSelected = selectedIndices.has(i);
      const isFocused = (focusedTile === i);
      // tile background with wacky patterns
      ctx.save();
      // subtle rotation for fun
      const wobble = Math.sin((i * 1234 + time / 120) / 20) * 0.02;
      ctx.translate(x + tileW / 2, y + tileH / 2);
      ctx.rotate(wobble);
      ctx.translate(-(x + tileW / 2), -(y + tileH / 2));
      // fill
      ctx.fillStyle = isSelected ? "#FFF7D6" : "#FFFFFF";
      roundRect(ctx, x, y, tileW, tileH, 12, true, true);
      // pattern
      ctx.fillStyle = isSelected ? "rgba(120,180,255,0.06)" : "rgba(100,120,160,0.04)";
      ctx.fillRect(x + 6, y + 6, tileW - 12, tileH - 12);
      // border
      ctx.strokeStyle = isFocused ? "#FFB26B" : "#6b6b6b";
      ctx.lineWidth = isFocused ? 3 : 2;
      roundRect(ctx, x, y, tileW, tileH, 12, false, true);
      // number
      ctx.fillStyle = "#223";
      ctx.font = "28px Comic Sans MS, Arial";
      ctx.textAlign = "center";
      ctx.fillText(`${tiles[i]}`, x + tileW / 2, y + tileH / 2 + 10);
      ctx.restore();
    }
  }

  // draw HUD
  function drawHUD() {
    // Title
    ctx.fillStyle = "#223";
    ctx.font = "24px Comic Sans MS, Arial";
    ctx.textAlign = "left";
    ctx.fillText("Machine Math", 18, 32);

    // Score and level
    ctx.font = "16px Arial";
    ctx.fillStyle = "#224";
    ctx.fillText(`Level: ${level} / ${MAX_LEVELS}`, WIDTH - 180, 28);
    ctx.fillText(`Score: ${score}`, WIDTH - 180, 48);

    // message box
    ctx.fillStyle = "rgba(255,255,255,0.8)";
    roundRect(ctx, 12, HEIGHT - 76, 460, 64, 10, true, true);
    ctx.fillStyle = "#253";
    ctx.font = "14px Arial";
    ctx.textAlign = "left";
    wrapText(ctx, message, 24, HEIGHT - 52, 440, 18);
  }

  // Show current selected sum
  function drawSelectedSummary() {
    const sum = Array.from(selectedIndices).reduce((acc, i) => acc + tiles[i], 0);
    ctx.fillStyle = "#002b2b";
    ctx.font = "20px Comic Sans MS, Arial";
    ctx.textAlign = "left";
    ctx.fillText(`Selected sum: ${sum}`, 20, HEIGHT - 100);

    // also provide auditory icon indicator (speaker) that toggles audio
    // Draw small speaker icon that indicates audio is available or not
    ctx.save();
    const sx = WIDTH - 34;
    const sy = 20;
    ctx.fillStyle = audioCtx ? "#3a7" : "#ccc";
    ctx.beginPath();
    ctx.moveTo(sx - 12, sy - 6);
    ctx.lineTo(sx - 4, sy - 6);
    ctx.lineTo(sx + 4, sy - 12);
    ctx.lineTo(sx + 4, sy + 12);
    ctx.lineTo(sx - 4, sy + 6);
    ctx.lineTo(sx - 12, sy + 6);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = "#224";
    ctx.stroke();
    if (!audioCtx) {
      // draw mute cross
      ctx.strokeStyle = "#900";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(sx - 10, sy - 10);
      ctx.lineTo(sx + 10, sy + 10);
      ctx.moveTo(sx + 10, sy - 10);
      ctx.lineTo(sx - 10, sy + 10);
      ctx.stroke();
    }
    ctx.restore();
  }

  // Helpers for canvas shapes and text wrapping
  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    if (typeof r === "undefined") r = 5;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  function wrapText(context, text, x, y, maxWidth, lineHeight) {
    const words = text.split(" ");
    let line = "";
    let testLine;
    for (let n = 0; n < words.length; n++) {
      testLine = line + words[n] + " ";
      const metrics = context.measureText(testLine);
      if (metrics.width > maxWidth && n > 0) {
        context.fillText(line, x, y);
        line = words[n] + " ";
        y += lineHeight;
      } else {
        line = testLine;
      }
    }
    context.fillText(line, x, y);
  }

  // Mouse and keyboard handling
  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
    mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
  });

  canvas.addEventListener("mousedown", (e) => {
    mouse.down = true;
    resumeAudio();
    // check tile clicked or power pressed
    const clicked = hitTest(mouse.x, mouse.y);
    if (clicked.type === "tile") {
      toggleSelectIndex(clicked.index);
      focusedTile = clicked.index;
    } else if (clicked.type === "power") {
      focusedTile = -1;
      submitPower();
    } else {
      playClick();
    }
  });

  canvas.addEventListener("mouseup", () => {
    mouse.down = false;
  });

  // keyboard interactions
  window.addEventListener("keydown", (e) => {
    // Allow keyboard only when game running or after game ends
    if (e.key === "r" || e.key === "R") {
      e.preventDefault();
      startGame();
      return;
    }
    if (e.key === "p" || e.key === "P") {
      e.preventDefault();
      submitPower();
      return;
    }
    if (e.key === " " || e.key === "Enter") {
      e.preventDefault();
      // select focused tile or if focus is power, submit
      if (focusedTile === -1) {
        submitPower();
      } else {
        toggleSelectIndex(focusedTile);
      }
      return;
    }
    if (e.key === "Backspace") {
      e.preventDefault();
      // remove last selected
      const arr = Array.from(selectedIndices);
      if (arr.length) {
        const last = arr[arr.length - 1];
        selectedIndices.delete(last);
        playClick();
      } else {
        message = "No tiles selected.";
      }
      return;
    }
    // arrow navigation
    if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].includes(e.key)) {
      e.preventDefault();
      moveFocus(e.key);
      return;
    }
    // number keys quick select
    if (/^[0-9]$/.test(e.key)) {
      // choose a tile with this number that is not selected yet
      const num = parseInt(e.key, 10);
      let found = -1;
      for (let i = 0; i < tiles.length; i++) {
        if (tiles[i] === num && !selectedIndices.has(i)) {
          found = i;
          break;
        }
      }
      if (found >= 0) {
        focusedTile = found;
        toggleSelectIndex(found);
      } else {
        message = `No unselected tile with number ${num}.`;
        playIncorrect();
      }
    }
  });

  function moveFocus(key) {
    if (focusedTile === -1) {
      // from power, go to last tile
      focusedTile = tiles.length - 1;
      return;
    }
    if (tiles.length === 0) return;
    const cols = 5;
    const col = focusedTile % cols;
    const row = Math.floor(focusedTile / cols);
    let newIndex = focusedTile;
    if (key === "ArrowLeft") {
      if (col > 0) newIndex = focusedTile - 1;
    } else if (key === "ArrowRight") {
      if (col < cols - 1 && focusedTile + 1 < tiles.length) newIndex = focusedTile + 1;
      else newIndex = -1; // move to power
    } else if (key === "ArrowUp") {
      if (row > 0) newIndex = focusedTile - cols;
    } else if (key === "ArrowDown") {
      if (row < Math.ceil(tiles.length / cols) - 1 && focusedTile + cols < tiles.length) newIndex = focusedTile + cols;
      else newIndex = -1; // to power
    }
    if (newIndex === -1) focusedTile = -1;
    else focusedTile = clamp(newIndex, 0, tiles.length - 1);
    playClick();
  }

  // Hit testing for mouse events
  function hitTest(mxPos, myPos) {
    // tiles
    const areaX = 36;
    const areaY = 260;
    const tileW = 84;
    const tileH = 64;
    const gap = 12;
    for (let i = 0; i < tiles.length; i++) {
      const col = i % 5;
      const row = Math.floor(i / 5);
      const x = areaX + col * (tileW + gap);
      const y = areaY + row * (tileH + gap);
      if (mxPos >= x && mxPos <= x + tileW && myPos >= y && myPos <= y + tileH) {
        return { type: "tile", index: i };
      }
    }
    // power button
    if (mxPos >= powerButton.x && mxPos <= powerButton.x + powerButton.w && myPos >= powerButton.y && myPos <= powerButton.y + powerButton.h) {
      return { type: "power" };
    }
    return { type: "none" };
  }

  // Small fireworks for celebration
  let sparks = [];
  let fireworksActive = false;
  function triggerFireworks() {
    fireworksActive = true;
    sparks = [];
    const centerX = WIDTH / 2;
    const centerY = 140;
    for (let s = 0; s < 36; s++) {
      const angle = (Math.PI * 2 * s) / 36;
      const speed = 0.6 + Math.random() * 2.2;
      sparks.push({
        x: centerX,
        y: centerY,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed - 0.6,
        life: 0.6 + Math.random() * 0.6,
        age: 0,
        color: `hsl(${Math.floor(Math.random() * 360)}, 70%, 60%)`,
      });
    }
    setTimeout(() => {
      fireworksActive = false;
    }, 900);
  }

  function updateSparks(dt) {
    for (let s of sparks) {
      s.age += dt;
      s.x += s.vx * dt * 140;
      s.y += s.vy * dt * 140;
      s.vy += 0.6 * dt * 80; // gravity
    }
    sparks = sparks.filter((p) => p.age < p.life);
  }

  function drawSparks() {
    for (let s of sparks) {
      const alpha = 1 - s.age / s.life;
      ctx.fillStyle = s.color;
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.arc(s.x, s.y, 4 + 3 * (1 - alpha), 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  // Small shake effect
  let shakeStart = 0;

  // Main loop
  let lastTime = performance.now();
  let time = 0;
  let running = true;

  function gameLoop(now) {
    const dt = Math.min(0.06, (now - lastTime) / 1000);
    lastTime = now;
    time += now - (lastTime - (now - lastTime)); // small consistent time
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Apply shake when wrong submit
    let dx = 0;
    let dy = 0;
    if (shakeStart > 0) {
      const t = (performance.now() - shakeStart) / 300;
      if (t < 1) {
        dx = Math.sin(t * 24) * 4 * (1 - t);
        dy = Math.cos(t * 18) * 3 * (1 - t);
      } else {
        shakeStart = 0;
      }
    }
    ctx.save();
    ctx.translate(dx, dy);

    drawBackground();
    drawMachine();
    drawTiles();
    drawHUD();
    drawSelectedSummary();

    if (fireworksActive) {
      updateSparks(dt);
      drawSparks();
    }

    // If game ended, show overlay
    if (!running && level > MAX_LEVELS) {
      ctx.fillStyle = "rgba(10, 10, 20, 0.6)";
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = "#FFF";
      ctx.font = "32px Comic Sans MS, Arial";
      ctx.textAlign = "center";
      ctx.fillText("All Machines Powered!", WIDTH / 2, HEIGHT / 2 - 20);
      ctx.font = "20px Arial";
      ctx.fillText(`Your Score: ${score}`, WIDTH / 2, HEIGHT / 2 + 20);
      ctx.font = "16px Arial";
      ctx.fillText("Press R to play again.", WIDTH / 2, HEIGHT / 2 + 56);
    }

    ctx.restore();

    requestAnimationFrame(gameLoop);
  }

  // Start
  generateLevel(level);
  requestAnimationFrame(gameLoop);

  // Start audio on first user gesture; also show accessible control
  function setupFirstGesture() {
    const clickHandler = () => {
      resumeAudio();
      canvas.removeEventListener("click", clickHandler);
    };
    canvas.addEventListener("click", clickHandler);
  }
  setupFirstGesture();

  // Initialize a few UI hints and ensure accessible text updates on state change
  const srStatus = document.createElement("div");
  srStatus.style.position = "absolute";
  srStatus.style.left = "8px";
  srStatus.style.top = "380px";
  srStatus.style.width = "1px";
  srStatus.style.height = "1px";
  srStatus.style.overflow = "hidden";
  srStatus.style.clip = "rect(1px, 1px, 1px, 1px)";
  srStatus.setAttribute("aria-live", "polite");
  container.appendChild(srStatus);

  // Periodically update srStatus to reflect game state for screen readers
  setInterval(() => {
    const sum = Array.from(selectedIndices).reduce((acc, i) => acc + tiles[i], 0);
    srStatus.innerText = `Level ${level}. Target ${target}. Selected sum ${sum}. ${message}`;
  }, 900);

  // Expose some debug functions in case of console usage (non-essential)
  window.machineMath = {
    restart: startGame,
    playTestSound: () => {
      playClick();
    },
  };

  // Good practice: handle page visibility to suspend audio if tab is hidden
  document.addEventListener("visibilitychange", () => {
    if (!audioCtx) return;
    if (document.hidden) {
      if (audioCtx.state === "running") audioCtx.suspend().catch(() => {});
    } else {
      if (audioCtx.state === "suspended") audioCtx.resume().catch(() => {});
    }
  });

  // On load, provide short greeting
  message = "Ready! Use tiles to match the target and press Power. You can use keyboard or mouse.";

})();
---

