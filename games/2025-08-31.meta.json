{
  "generated_date": "2025-08-31",
  "generated_timestamp": "2025-08-31T00:29:14.411075",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8959,
  "game_filename": "2025-08-31.js",
  "game_size_bytes": 27290,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Wacky Machine Math - JavaScript Game\n  // Ages 7-9. All visuals drawn on canvas. Sounds via Web Audio API.\n  // Renders into element with ID 'game-of-the-day-stage'\n\n  // ====== Configuration ======\n  const GAME_WIDTH = 720;\n  const GAME_HEIGHT = 480;\n  const LEVEL_COUNT = 5;\n  const MAX_PARTS = 6;\n  const BG_COLOR = '#e9f3ef'; // calming mint\n  const MACHINE_COLOR = '#d6e6f2';\n  const PART_COLOR = '#ffd89b';\n  const PART_COLOR_ALT = '#ffd1e0';\n  const TEXT_COLOR = '#21333b';\n  const HIGHLIGHT = '#6bb3ff';\n  const FONT = '16px \"Segoe UI\", Roboto, sans-serif';\n  const TITLE_FONT = 'bold 20px \"Segoe UI\", Roboto, sans-serif';\n\n  // ====== Setup canvas and accessibility ======\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Game container with ID \"game-of-the-day-stage\" not found.');\n    return;\n  }\n\n  // Clear container\n  container.innerHTML = '';\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = GAME_WIDTH;\n  canvas.height = GAME_HEIGHT;\n  canvas.style.width = GAME_WIDTH + 'px';\n  canvas.style.height = GAME_HEIGHT + 'px';\n  canvas.tabIndex = 0; // make focusable for keyboard controls\n  canvas.setAttribute('role', 'application');\n  canvas.setAttribute(\n    'aria-label',\n    'Wacky Machine Math. Add number parts to match the machine target. Use mouse or keyboard to play.'\n  );\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext('2d', { alpha: false });\n\n  // ====== Audio Manager ======\n  class AudioManager {\n    constructor() {\n      this.enabled = true;\n      this.ctx = null;\n      this.bgGain = null;\n      this.bgOsc = null;\n      this.isBgPlaying = false;\n\n      try {\n        const AudioContext = window.AudioContext || window.webkitAudioContext;\n        this.ctx = new AudioContext();\n      } catch (e) {\n        console.warn('Web Audio API not available:', e);\n        this.enabled = false;\n        this.ctx = null;\n      }\n\n      // Resume handling for autoplay policies\n      if (this.ctx) {\n        // Try to resume on first user interaction if suspended\n        const resumeIfNeeded = () => {\n          if (this.ctx && this.ctx.state === 'suspended') {\n            this.ctx.resume().catch((err) => {\n              console.warn('Audio context resume failed:', err);\n            });\n          }\n          window.removeEventListener('pointerdown', resumeIfNeeded);\n          window.removeEventListener('keydown', resumeIfNeeded);\n        };\n        window.addEventListener('pointerdown', resumeIfNeeded);\n        window.addEventListener('keydown', resumeIfNeeded);\n      }\n    }\n\n    safeCreateGain() {\n      if (!this.ctx) return null;\n      try {\n        return this.ctx.createGain();\n      } catch (e) {\n        console.warn('Gain creation failed:', e);\n        return null;\n      }\n    }\n\n    playClick() {\n      if (!this.enabled || !this.ctx) return;\n      try {\n        const now = this.ctx.currentTime;\n        const osc = this.ctx.createOscillator();\n        const gain = this.safeCreateGain();\n        if (!gain) return;\n        osc.type = 'sine';\n        osc.frequency.value = 880;\n        gain.gain.setValueAtTime(0.0001, now);\n        gain.gain.exponentialRampToValueAtTime(0.05, now + 0.01);\n        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.2);\n        osc.connect(gain).connect(this.ctx.destination);\n        osc.start(now);\n        osc.stop(now + 0.25);\n      } catch (e) {\n        console.warn('playClick error:', e);\n      }\n    }\n\n    playCorrect() {\n      if (!this.enabled || !this.ctx) return;\n      try {\n        // pleasant rising triad sequence\n        const now = this.ctx.currentTime;\n        const freqs = [660, 880, 990];\n        freqs.forEach((f, i) => {\n          const osc = this.ctx.createOscillator();\n          const gain = this.safeCreateGain();\n          if (!gain) return;\n          osc.type = 'sine';\n          osc.frequency.value = f;\n          gain.gain.setValueAtTime(0.0001, now + i * 0.12);\n          gain.gain.exponentialRampToValueAtTime(0.06, now + i * 0.14);\n          gain.gain.exponentialRampToValueAtTime(0.0001, now + i * 0.5);\n          osc.connect(gain).connect(this.ctx.destination);\n          osc.start(now + i * 0.12);\n          osc.stop(now + i * 0.6);\n        });\n      } catch (e) {\n        console.warn('playCorrect error:', e);\n      }\n    }\n\n    playIncorrect() {\n      if (!this.enabled || !this.ctx) return;\n      try {\n        const now = this.ctx.currentTime;\n        const osc = this.ctx.createOscillator();\n        const gain = this.safeCreateGain();\n        if (!gain) return;\n        osc.type = 'sawtooth';\n        osc.frequency.value = 160;\n        const filter = this.ctx.createBiquadFilter();\n        filter.type = 'lowpass';\n        filter.frequency.value = 600;\n        gain.gain.setValueAtTime(0.0001, now);\n        gain.gain.exponentialRampToValueAtTime(0.08, now + 0.01);\n        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.36);\n        osc.connect(filter);\n        filter.connect(gain).connect(this.ctx.destination);\n        osc.start(now);\n        osc.frequency.exponentialRampToValueAtTime(80, now + 0.35);\n        osc.stop(now + 0.4);\n      } catch (e) {\n        console.warn('playIncorrect error:', e);\n      }\n    }\n\n    startBackground() {\n      if (!this.enabled || !this.ctx || this.isBgPlaying) return;\n      try {\n        const now = this.ctx.currentTime;\n        this.bgOsc = this.ctx.createOscillator();\n        this.bgOsc.type = 'sine';\n        this.bgOsc.frequency.value = 55;\n        this.bgGain = this.safeCreateGain();\n        if (!this.bgGain) return;\n        this.bgGain.gain.setValueAtTime(0.01, now);\n        // subtle LFO for gentle wobble\n        const lfo = this.ctx.createOscillator();\n        lfo.type = 'sine';\n        lfo.frequency.value = 0.25;\n        const lfoGain = this.safeCreateGain();\n        lfoGain.gain.value = 10;\n        lfo.connect(lfoGain).connect(this.bgOsc.frequency);\n        this.bgOsc.connect(this.bgGain).connect(this.ctx.destination);\n        lfo.start();\n        this.bgOsc.start();\n        this.isBgPlaying = true;\n      } catch (e) {\n        console.warn('startBackground error:', e);\n      }\n    }\n\n    stopBackground() {\n      if (!this.ctx || !this.isBgPlaying) return;\n      try {\n        this.bgOsc.stop();\n      } catch (e) {\n        // ignore\n      }\n      this.bgOsc = null;\n      this.bgGain = null;\n      this.isBgPlaying = false;\n    }\n\n    toggleEnabled() {\n      this.enabled = !this.enabled;\n      if (this.enabled) {\n        if (this.ctx && this.ctx.state === 'suspended') {\n          this.ctx.resume().catch((err) => console.warn('resume failed', err));\n        }\n        this.startBackground();\n      } else {\n        this.stopBackground();\n      }\n    }\n  }\n\n  const audio = new AudioManager();\n  if (audio.enabled) {\n    audio.startBackground();\n  }\n\n  // ====== Utilities ======\n  const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\n  function subsetSumExists(parts, target) {\n    // small dynamic programming check\n    const possible = new Set([0]);\n    for (const p of parts) {\n      const next = new Set(possible);\n      for (const s of possible) {\n        next.add(s + p);\n      }\n      for (const v of next) possible.add(v);\n      if (possible.has(target)) return true;\n    }\n    return possible.has(target);\n  }\n\n  function pickPartsForTarget(target, count) {\n    // Ensure there's a subset summing to target. We'll create a solution and then add distractors.\n    // Approach: create some numbers that sum to target by random partition, then add extras.\n    const minPart = 1;\n    const maxPart = Math.max(3, Math.floor(target * 0.9));\n    const solution = [];\n    let remaining = target;\n    let picks = rand(1, Math.min(3, count));\n    for (let i = 0; i < picks; i++) {\n      if (i === picks - 1) {\n        solution.push(remaining);\n      } else {\n        const maxPossible = Math.max(minPart, Math.floor(remaining - (picks - i - 1) * minPart));\n        const v = Math.max(minPart, rand(1, maxPossible));\n        solution.push(v);\n        remaining -= v;\n      }\n    }\n\n    // Now fill distractors\n    const parts = solution.slice();\n    while (parts.length < count) {\n      let d = rand(1, Math.max(1, target + 3));\n      // avoid exact duplicates of solution numbers excessively\n      parts.push(d);\n    }\n    // Shuffle\n    for (let i = parts.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [parts[i], parts[j]] = [parts[j], parts[i]];\n    }\n\n    // Validate subset sum exists\n    if (!subsetSumExists(parts, target)) {\n      // As fallback, make first two parts sum to target\n      parts[0] = Math.max(1, target - 1);\n      parts[1] = target - parts[0];\n    }\n\n    return parts.slice(0, count);\n  }\n\n  // ====== Game State ======\n  let levelIndex = 0;\n  let levels = [];\n  let parts = []; // objects for current level\n  let machineParts = []; // parts placed in machine\n  let selectedPartIndex = -1;\n  let isAnimating = false;\n  let animationTicks = 0;\n  let feedbackText = '';\n  let showMuted = !audio.enabled;\n  let usedAttempts = 0;\n\n  // Floating decorative orbs for calming effect\n  const orbs = Array.from({ length: 8 }, (_, i) => ({\n    x: rand(40, GAME_WIDTH - 40),\n    y: rand(40, GAME_HEIGHT - 40),\n    r: rand(8, 24),\n    hue: rand(150, 200),\n    phase: Math.random() * Math.PI * 2,\n    speed: (Math.random() * 0.5 + 0.2) / 60,\n  }));\n\n  function initLevels() {\n    levels = [];\n    for (let i = 0; i < LEVEL_COUNT; i++) {\n      const difficulty = i + 1;\n      // target increases with difficulty, stays kid-friendly\n      const target = rand(5 + difficulty * 2, 8 + difficulty * 4);\n      const count = Math.min(MAX_PARTS, 3 + difficulty);\n      const partsList = pickPartsForTarget(target, count);\n      levels.push({\n        target,\n        partsList,\n      });\n    }\n  }\n\n  function startLevel(idx) {\n    levelIndex = idx;\n    const level = levels[levelIndex];\n    parts = [];\n    machineParts = [];\n    selectedPartIndex = -1;\n    usedAttempts = 0;\n    feedbackText = 'Place parts so their sum equals the machine target.';\n    const trayX = 40;\n    const trayY = 300;\n    const spacing = 100;\n    for (let i = 0; i < level.partsList.length; i++) {\n      const p = {\n        id: `p${i}`,\n        value: level.partsList[i],\n        x: trayX + i * spacing,\n        y: trayY,\n        tx: trayX + i * spacing,\n        ty: trayY,\n        w: 72,\n        h: 48,\n        inMachine: false,\n        visible: true,\n        color: i % 2 === 0 ? PART_COLOR : PART_COLOR_ALT,\n      };\n      parts.push(p);\n    }\n    isAnimating = false;\n    animationTicks = 0;\n  }\n\n  // Initialize game\n  initLevels();\n  startLevel(0);\n\n  // ====== Drawing ======\n  function draw() {\n    // Clear\n    ctx.fillStyle = BG_COLOR;\n    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);\n\n    // calming orbs background\n    for (const orb of orbs) {\n      const g = ctx.createRadialGradient(orb.x, orb.y, 0, orb.x, orb.y, orb.r * 3);\n      g.addColorStop(0, `rgba(${orb.hue},200,220,0.18)`);\n      g.addColorStop(1, 'rgba(255,255,255,0)');\n      ctx.fillStyle = g;\n      ctx.beginPath();\n      ctx.ellipse(orb.x, orb.y, orb.r * 3, orb.r * 1.8, orb.phase, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // Title and instructions\n    ctx.fillStyle = TEXT_COLOR;\n    ctx.font = TITLE_FONT;\n    ctx.fillText('Wacky Machine Math', 20, 28);\n    ctx.font = FONT;\n    ctx.fillStyle = TEXT_COLOR;\n    ctx.fillText('Theme: Machines \u2014 add parts to match the output number!', 20, 48);\n\n    // Machine area\n    const machineX = 420;\n    const machineY = 70;\n    const machineW = 260;\n    const machineH = 280;\n    // machine base\n    ctx.fillStyle = MACHINE_COLOR;\n    roundRect(ctx, machineX, machineY, machineW, machineH, 12);\n    ctx.fill();\n\n    // machine window\n    ctx.fillStyle = '#ffffff';\n    ctx.fillRect(machineX + 20, machineY + 20, machineW - 40, 120);\n    // target display\n    ctx.fillStyle = '#1b2b31';\n    ctx.font = 'bold 34px \"Segoe UI\", Roboto, sans-serif';\n    const targetText = `TARGET: ${levels[levelIndex].target}`;\n    ctx.fillText(targetText, machineX + 28, machineY + 64);\n\n    // running dial / gauge\n    ctx.strokeStyle = '#b9d8f5';\n    ctx.lineWidth = 6;\n    ctx.beginPath();\n    ctx.arc(machineX + machineW / 2, machineY + 200, 44, Math.PI, Math.PI * 1.9);\n    ctx.stroke();\n\n    // show current sum\n    ctx.font = 'bold 24px \"Segoe UI\", Roboto, sans-serif';\n    const currentSum = machineParts.reduce((s, p) => s + p.value, 0);\n    ctx.fillStyle = TEXT_COLOR;\n    ctx.fillText(`Sum: ${currentSum}`, machineX + 28, machineY + 220);\n\n    // Visual gears and wacky elements on machine\n    drawGears(machineX + 40, machineY + 160, 28, animationTicks * 0.06, '#cbe6ff');\n    drawGear(machineX + 210, machineY + 160, 16, -animationTicks * 0.08, '#ffd2b3');\n\n    // Tray area for parts\n    ctx.fillStyle = '#f6fbf9';\n    roundRect(ctx, 20, 250, 360, 200, 12);\n    ctx.fill();\n    ctx.font = 'bold 18px \"Segoe UI\", Roboto, sans-serif';\n    ctx.fillStyle = '#344b50';\n    ctx.fillText('Parts Tray (click or use keys 1-' + parts.length + ')', 28, 276);\n\n    // Draw parts\n    for (let i = 0; i < parts.length; i++) {\n      const p = parts[i];\n      // animate movement towards target positions if needed\n      p.x += (p.tx - p.x) * 0.2;\n      p.y += (p.ty - p.y) * 0.2;\n      drawPart(p, i === selectedPartIndex);\n    }\n\n    // Draw machine area contents (placed parts)\n    const placedBaseX = machineX + 40;\n    const placedBaseY = machineY + 120;\n    for (let i = 0; i < machineParts.length; i++) {\n      const mp = machineParts[i];\n      // position them in a stack\n      const px = placedBaseX + (i % 3) * 72;\n      const py = placedBaseY + Math.floor(i / 3) * 56;\n      ctx.save();\n      ctx.translate(px, py);\n      drawPart({ ...mp, x: px, y: py, tx: px, ty: py }, false);\n      ctx.restore();\n    }\n\n    // Control hints\n    ctx.fillStyle = TEXT_COLOR;\n    ctx.font = FONT;\n    ctx.fillText('Controls:', 28, 380);\n    ctx.fillText('Click part -> Click machine to add. Or press 1-' + parts.length + ' then Enter to add.', 28, 400);\n    ctx.fillText('Backspace removes last part. R runs the machine. Arrow keys to select.', 28, 420);\n\n    // Buttons (drawn)\n    drawButton(GAME_WIDTH - 200, GAME_HEIGHT - 100, 160, 44, 'Run Machine (R)', '#6bb3ff');\n    drawButton(GAME_WIDTH - 200, GAME_HEIGHT - 42, 160, 36, showMuted ? 'Audio Off' : 'Audio On', showMuted ? '#c2c2c2' : '#ffd28a');\n\n    // Level progress\n    ctx.fillStyle = TEXT_COLOR;\n    ctx.font = FONT;\n    ctx.fillText(`Level ${levelIndex + 1} of ${LEVEL_COUNT}`, GAME_WIDTH - 220, 36);\n\n    // Feedback\n    ctx.fillStyle = '#23414a';\n    ctx.font = 'bold 18px \"Segoe UI\", Roboto, sans-serif';\n    ctx.fillText(feedbackText, 20, GAME_HEIGHT - 12);\n\n    // Audio visual cue\n    ctx.beginPath();\n    ctx.fillStyle = showMuted ? '#999' : '#2d7a2d';\n    ctx.arc(GAME_WIDTH - 42, 40, 10, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  function drawPart(p, highlighted) {\n    // shadow\n    ctx.save();\n    ctx.translate(p.x, p.y);\n    ctx.beginPath();\n    roundRect(ctx, -p.w / 2, -p.h / 2, p.w, p.h, 8);\n    ctx.fillStyle = p.color;\n    ctx.fill();\n    // outline\n    ctx.lineWidth = highlighted ? 3 : 1.5;\n    ctx.strokeStyle = highlighted ? HIGHLIGHT : '#b28b6a';\n    ctx.stroke();\n    // number\n    ctx.fillStyle = '#21333b';\n    ctx.font = 'bold 20px \"Segoe UI\", Roboto, sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(p.value.toString(), 0, 0);\n    // little bolt or screw for wacky machine look\n    ctx.fillStyle = '#7a5f4e';\n    ctx.beginPath();\n    ctx.arc(-p.w / 4, -p.h / 4, 3, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function drawGears(x, y, r, angle, color) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(angle);\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    // simple toothed gear using many arcs\n    const teeth = 10;\n    for (let i = 0; i < teeth; i++) {\n      const a = (i / teeth) * Math.PI * 2;\n      const sx = Math.cos(a) * (r + 6);\n      const sy = Math.sin(a) * (r + 6);\n      ctx.moveTo(Math.cos(a) * r, Math.sin(a) * r);\n      ctx.lineTo(sx, sy);\n    }\n    ctx.fill();\n    // inner circle\n    ctx.beginPath();\n    ctx.fillStyle = '#ffffff';\n    ctx.arc(0, 0, r * 0.55, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function drawGear(x, y, r, angle, color) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(angle);\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.arc(0, 0, r + 6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = '#ffffff';\n    ctx.beginPath();\n    ctx.arc(0, 0, r * 0.5, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function drawButton(x, y, w, h, text, color) {\n    ctx.fillStyle = color;\n    roundRect(ctx, x, y, w, h, 8);\n    ctx.fill();\n    ctx.fillStyle = '#0b2430';\n    ctx.font = 'bold 14px \"Segoe UI\", Roboto, sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(text, x + w / 2, y + h / 2);\n    ctx.textAlign = 'start';\n  }\n\n  function roundRect(ctx, x, y, w, h, r) {\n    if (w < 2 * r) r = w / 2;\n    if (h < 2 * r) r = h / 2;\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n  }\n\n  // ====== Interaction ======\n  function pickPartAt(x, y) {\n    for (let i = parts.length - 1; i >= 0; i--) {\n      const p = parts[i];\n      if (!p.visible) continue;\n      const left = p.x - p.w / 2;\n      const right = p.x + p.w / 2;\n      const top = p.y - p.h / 2;\n      const bottom = p.y + p.h / 2;\n      if (x >= left && x <= right && y >= top && y <= bottom) return i;\n    }\n    return -1;\n  }\n\n  canvas.addEventListener('pointerdown', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = (e.clientX - rect.left) * (canvas.width / rect.width);\n    const y = (e.clientY - rect.top) * (canvas.height / rect.height);\n    // check tray parts\n    const idx = pickPartAt(x, y);\n    if (idx >= 0) {\n      // select part\n      selectedPartIndex = idx;\n      audio.playClick();\n      return;\n    }\n    // check run button\n    if (x >= GAME_WIDTH - 200 && x <= GAME_WIDTH - 40 && y >= GAME_HEIGHT - 100 && y <= GAME_HEIGHT - 56) {\n      // Run Machine clicked\n      runMachine();\n      return;\n    }\n    // audio toggle\n    if (x >= GAME_WIDTH - 200 && x <= GAME_WIDTH - 40 && y >= GAME_HEIGHT - 42 && y <= GAME_HEIGHT - 6) {\n      showMuted = !showMuted;\n      audio.toggleEnabled();\n      feedbackText = showMuted ? 'Audio muted' : 'Audio enabled';\n      return;\n    }\n    // click machine area to add selected part\n    const machineX = 420;\n    const machineY = 70;\n    const machineW = 260;\n    const machineH = 280;\n    if (x >= machineX && x <= machineX + machineW && y >= machineY && y <= machineY + machineH) {\n      if (selectedPartIndex >= 0) {\n        addSelectedPartToMachine();\n      } else {\n        // clicked machine; check if clicked on placed part to remove\n        const mpIndex = pickMachinePartAt(x, y);\n        if (mpIndex >= 0) {\n          removeMachinePart(mpIndex);\n        }\n      }\n      return;\n    }\n  });\n\n  function pickMachinePartAt(x, y) {\n    const machineX = 420;\n    const machineY = 70;\n    const placedBaseX = machineX + 40;\n    const placedBaseY = machineY + 120;\n    for (let i = 0; i < machineParts.length; i++) {\n      const px = placedBaseX + (i % 3) * 72;\n      const py = placedBaseY + Math.floor(i / 3) * 56;\n      const left = px - 36;\n      const right = px + 36;\n      const top = py - 24;\n      const bottom = py + 24;\n      if (x >= left && x <= right && y >= top && y <= bottom) return i;\n    }\n    return -1;\n  }\n\n  // Keyboard controls\n  canvas.addEventListener('keydown', (e) => {\n    if (e.key >= '1' && e.key <= String(Math.max(1, parts.length))) {\n      const idx = Math.min(parts.length - 1, parseInt(e.key, 10) - 1);\n      selectedPartIndex = idx;\n      audio.playClick();\n      e.preventDefault();\n      return;\n    }\n\n    switch (e.key) {\n      case 'ArrowRight':\n        if (parts.length === 0) break;\n        selectedPartIndex = (selectedPartIndex + 1 + parts.length) % parts.length;\n        audio.playClick();\n        e.preventDefault();\n        break;\n      case 'ArrowLeft':\n        if (parts.length === 0) break;\n        selectedPartIndex = (selectedPartIndex - 1 + parts.length) % parts.length;\n        audio.playClick();\n        e.preventDefault();\n        break;\n      case 'Enter':\n      case ' ':\n        if (selectedPartIndex >= 0) {\n          addSelectedPartToMachine();\n        }\n        e.preventDefault();\n        break;\n      case 'Backspace':\n        removeLastMachinePart();\n        e.preventDefault();\n        break;\n      case 'r':\n      case 'R':\n        runMachine();\n        e.preventDefault();\n        break;\n      case 'm':\n      case 'M':\n        showMuted = !showMuted;\n        audio.toggleEnabled();\n        e.preventDefault();\n        break;\n      default:\n        break;\n    }\n  });\n\n  function addSelectedPartToMachine() {\n    if (selectedPartIndex < 0 || selectedPartIndex >= parts.length) {\n      feedbackText = 'Select a part first (click or press 1-' + parts.length + ').';\n      return;\n    }\n    const part = parts[selectedPartIndex];\n    if (!part.visible) {\n      feedbackText = 'That part is already used.';\n      return;\n    }\n    // animate moving into machine\n    const machineX = 420;\n    const placedBaseX = machineX + 40;\n    const placedBaseY = machineX ? machineX + 120 : 0; // not used, compute later\n    // compute target slot\n    const slotX = 420 + 40 + (machineParts.length % 3) * 72;\n    const slotY = 70 + 120 + Math.floor(machineParts.length / 3) * 56;\n    part.tx = slotX;\n    part.ty = slotY;\n    part.visible = false; // hide in tray, will be added to machineParts when close enough\n    // store a copy for machineParts (visual)\n    machineParts.push({ id: part.id, value: part.value, color: part.color });\n    selectedPartIndex = -1;\n    feedbackText = 'Placed part inside the machine.';\n    audio.playClick();\n  }\n\n  function removeMachinePart(index) {\n    if (index < 0 || index >= machineParts.length) return;\n    const mp = machineParts.splice(index, 1)[0];\n    // return a part to tray (find first invisible part slot)\n    const returnSlot = parts.find((p) => p.id === mp.id);\n    if (returnSlot) {\n      returnSlot.visible = true;\n      // animate back to tray\n      returnSlot.tx = returnSlot.tx; // stay in its tray slot\n    } else {\n      // if not found, create new part back in tray\n      const trayX = 40 + (parts.length % 4) * 100;\n      const trayY = 300 + Math.floor(parts.length / 4) * 60;\n      parts.push({\n        id: mp.id,\n        value: mp.value,\n        x: trayX,\n        y: trayY,\n        tx: trayX,\n        ty: trayY,\n        w: 72,\n        h: 48,\n        inMachine: false,\n        visible: true,\n        color: mp.color,\n      });\n    }\n    feedbackText = 'Removed a part from the machine.';\n    audio.playClick();\n  }\n\n  function removeLastMachinePart() {\n    if (machineParts.length === 0) {\n      feedbackText = 'No parts in the machine to remove.';\n      return;\n    }\n    const last = machineParts.pop();\n    // return to tray\n    const slotIdx = parts.findIndex((p) => p.id === last.id);\n    if (slotIdx >= 0) {\n      parts[slotIdx].visible = true;\n      parts[slotIdx].tx = parts[slotIdx].tx; // keep position\n    } else {\n      parts.push({\n        id: last.id,\n        value: last.value,\n        x: 40,\n        y: 300,\n        tx: 40,\n        ty: 300,\n        w: 72,\n        h: 48,\n        visible: true,\n        color: last.color,\n      });\n    }\n    feedbackText = 'Removed the last part.';\n    audio.playClick();\n  }\n\n  // ====== Game logic - Run machine and level progression ======\n  function runMachine() {\n    if (isAnimating) return;\n    usedAttempts++;\n    const target = levels[levelIndex].target;\n    const sum = machineParts.reduce((s, p) => s + p.value, 0);\n    if (sum === target) {\n      // success\n      isAnimating = true;\n      animationTicks = 0;\n      feedbackText = 'Perfect! Machine is happy!';\n      if (audio.enabled) audio.playCorrect();\n      // celebration animation and next level after short delay\n      setTimeout(() => {\n        levelIndex++;\n        if (levelIndex >= levels.length) {\n          // game complete\n          feedbackText = 'You fixed all the machines! Great job!';\n          // create confetti effect by altering orbs\n          for (const orb of orbs) {\n            orb.hue = rand(20, 330);\n          }\n        } else {\n          feedbackText = 'Level up! New machine appears...';\n          startLevel(levelIndex);\n        }\n      }, 1200);\n    } else {\n      // incorrect - allow retries\n      feedbackText = `Not quite. Machine shows ${sum}. Try again.`;\n      if (audio.enabled) audio.playIncorrect();\n      // small wobble animation\n      isAnimating = true;\n      animationTicks = 0;\n      setTimeout(() => {\n        isAnimating = false;\n      }, 700);\n    }\n  }\n\n  // ====== Animation loop ======\n  let last = performance.now();\n  function loop(now) {\n    const dt = now - last;\n    last = now;\n\n    // update anims\n    animationTicks += dt / 16;\n    // animate orbs gentle movement\n    for (const orb of orbs) {\n      orb.phase += orb.speed * dt;\n      orb.x += Math.cos(orb.phase) * 0.02 * dt;\n      orb.y += Math.sin(orb.phase) * 0.01 * dt;\n    }\n\n    // detect when a part has reached its tx/ty to finalize placement (for parts that were set invisible)\n    for (const p of parts) {\n      if (!p.visible) {\n        // find if this part corresponds to a machineParts entry (by id) and if so, set visible false until settled\n        p.x += (p.tx - p.x) * 0.18;\n        p.y += (p.ty - p.y) * 0.18;\n      }\n    }\n    // finalize \"invisible\" tray parts placed into machine when close enough\n    for (let i = parts.length - 1; i >= 0; i--) {\n      const p = parts[i];\n      if (!p.visible) {\n        if (Math.hypot(p.x - p.tx, p.y - p.ty) < 6) {\n          // remove this tray part (since machineParts holds a copy)\n          parts.splice(i, 1);\n        }\n      }\n    }\n\n    // stop background audio gracefully if disabled\n    if (!audio.enabled && audio.isBgPlaying) {\n      audio.stopBackground();\n    }\n    if (audio.enabled && audio.ctx && !audio.isBgPlaying) {\n      audio.startBackground();\n    }\n\n    draw();\n    requestAnimationFrame(loop);\n  }\n\n  requestAnimationFrame(loop);\n\n  // ====== Helpful HUD and restart controls (keyboard accessible) ======\n  window.addEventListener('keydown', (e) => {\n    if (e.key === 'Escape') {\n      // reset game\n      initLevels();\n      startLevel(0);\n      feedbackText = 'Game reset. Start again!';\n      audio.playClick();\n    }\n  });\n\n  // focus the canvas for keyboard on load\n  setTimeout(() => {\n    try {\n      canvas.focus();\n    } catch (e) {\n      // ignore\n    }\n  }, 100);\n\n  // Expose small help in console for testers\n  console.log('Wacky Machine Math loaded. Use mouse or keyboard. Press Escape to reset.');\n\n  // ====== Error handling hints (audible and visual) ======\n  if (!audio.enabled) {\n    feedbackText = 'Audio unavailable. You can still play with visual cues.';\n  }\n})();\n---\n",
  "improve_response_tokens": 18124,
  "formatted_code": true,
  "formatting_response_tokens": 19422,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}