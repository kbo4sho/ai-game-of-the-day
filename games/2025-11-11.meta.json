{
  "generated_date": "2025-11-11",
  "generated_timestamp": "2025-11-11T00:29:05.568050",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 10687,
  "game_filename": "2025-11-11.js",
  "game_size_bytes": 31540,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Drone Math Delivery - JavaScript-only game\n  // Renders into element with id \"game-of-the-day-stage\"\n  // Designed for children 7-9. Goal: answer 10 questions correctly. 3 wrong answers = game over.\n  // Uses Canvas and Web Audio API (no external assets).\n  // Accessible controls: keyboard and mouse; visual cues and clear UI layout.\n  \"use strict\";\n\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const TARGET_CORRECT = 10;\n  const MAX_LIVES = 3;\n  const FONT_FAMILY = \"Arial, sans-serif\";\n\n  // Attempt to find the stage element\n  const stage = document.getElementById(\"game-of-the-day-stage\");\n  if (!stage) {\n    console.error(\"Missing container element with id 'game-of-the-day-stage'.\");\n    return;\n  }\n\n  // Clean stage contents and create canvas\n  stage.innerHTML = \"\";\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.width = WIDTH + \"px\";\n  canvas.style.height = HEIGHT + \"px\";\n  canvas.setAttribute(\"tabindex\", \"0\"); // make focusable for keyboard events\n  stage.appendChild(canvas);\n  const ctx = canvas.getContext(\"2d\");\n\n  // Global state\n  let gameState = {\n    running: true,\n    correctCount: 0,\n    wrongCount: 0,\n    lives: MAX_LIVES,\n    currentProblem: null,\n    inputText: \"\",\n    message: \"\",\n    timeSinceLastCorrect: 0,\n    droneX: 100,\n    droneY: HEIGHT / 2,\n    droneTargetX: 100,\n    droneWobble: 0,\n    animations: [],\n    soundEnabled: true,\n    audioReady: false,\n    audioError: null,\n    bgHumGain: null,\n    lastTick: null,\n    endState: null, // null | \"win\" | \"lose\"\n  };\n\n  // Layout constants to avoid overlapping text\n  const PADDING = 12;\n  const TOP_UI_HEIGHT = 64; // reserved top area for score/lives\n  const BOTTOM_UI_HEIGHT = 84; // instructions area bottom\n  const CENTER_AREA = {\n    x: PADDING,\n    y: TOP_UI_HEIGHT + PADDING,\n    w: WIDTH - PADDING * 2,\n    h: HEIGHT - TOP_UI_HEIGHT - BOTTOM_UI_HEIGHT - PADDING * 2,\n  };\n\n  // Button regions for click detection\n  const regions = {\n    okButton: null,\n    restartButton: null,\n    soundToggle: null,\n    keypadButtons: [], // each has x,y,w,h,value\n  };\n\n  // Utility: measure text width with given font size and weight\n  function measureText(text, size = 16, weight = \"normal\") {\n    ctx.save();\n    ctx.font = `${weight} ${size}px ${FONT_FAMILY}`;\n    const m = ctx.measureText(text);\n    ctx.restore();\n    return m.width;\n  }\n\n  // Audio setup with error handling\n  let audioCtx = null;\n  try {\n    const AudioContext = window.AudioContext || window.webkitAudioContext;\n    if (AudioContext) {\n      audioCtx = new AudioContext();\n    } else {\n      throw new Error(\"Web Audio API not supported\");\n    }\n  } catch (err) {\n    audioCtx = null;\n    gameState.audioError = err.message || String(err);\n    console.warn(\"AudioContext creation failed:\", err);\n  }\n\n  function ensureAudio() {\n    if (!audioCtx) return false;\n    // Some browsers require resume on user gesture\n    if (audioCtx.state === \"suspended\") {\n      audioCtx.resume().catch((e) => {\n        console.warn(\"Audio resume failed\", e);\n      });\n    }\n    return true;\n  }\n\n  // Start gentle background hum if audio ready\n  function startBackgroundHum() {\n    if (!audioCtx) return;\n    try {\n      if (gameState.bgHumGain) return; // already running\n      const osc = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n      osc.type = \"sine\";\n      osc.frequency.value = 120; // low hum\n      gain.gain.value = gameState.soundEnabled ? 0.0018 : 0.0; // subtle\n      osc.connect(gain);\n      const filter = audioCtx.createBiquadFilter();\n      filter.type = \"lowpass\";\n      filter.frequency.value = 800;\n      gain.connect(filter);\n      filter.connect(audioCtx.destination);\n      osc.start();\n      // store a reference; we can't stop oscillator unless we keep it; so we'll keep it running and adjust gain\n      gameState.bgHumGain = gain;\n      gameState.bgHumOsc = osc;\n      gameState.audioReady = true;\n    } catch (e) {\n      console.warn(\"Background hum setup failed\", e);\n      gameState.audioError = e.message || String(e);\n    }\n  }\n\n  // Toggle sound on/off\n  function setSoundEnabled(enabled) {\n    gameState.soundEnabled = enabled;\n    if (gameState.bgHumGain) {\n      gameState.bgHumGain.gain.setTargetAtTime(enabled ? 0.0018 : 0.0, audioCtx.currentTime, 0.02);\n    }\n  }\n\n  // Play short chime for correct\n  function playCorrect() {\n    if (!audioCtx || !gameState.soundEnabled) return;\n    try {\n      const o1 = audioCtx.createOscillator();\n      const o2 = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      const filter = audioCtx.createBiquadFilter();\n      o1.type = \"sine\";\n      o2.type = \"triangle\";\n      o1.frequency.value = 880;\n      o2.frequency.value = 660;\n      g.gain.value = 0;\n      filter.type = \"lowpass\";\n      filter.frequency.value = 1400;\n      o1.connect(g);\n      o2.connect(g);\n      g.connect(filter);\n      filter.connect(audioCtx.destination);\n      const now = audioCtx.currentTime;\n      g.gain.setValueAtTime(0, now);\n      g.gain.linearRampToValueAtTime(0.08, now + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.001, now + 0.5);\n      o1.start(now);\n      o2.start(now);\n      o1.stop(now + 0.55);\n      o2.stop(now + 0.45);\n    } catch (e) {\n      console.warn(\"playCorrect error\", e);\n    }\n  }\n\n  // Play buzz for wrong answer\n  function playWrong() {\n    if (!audioCtx || !gameState.soundEnabled) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = \"sawtooth\";\n      o.frequency.value = 220;\n      o.connect(g);\n      g.connect(audioCtx.destination);\n      const now = audioCtx.currentTime;\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(0.06, now + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);\n      o.start(now);\n      o.stop(now + 0.42);\n    } catch (e) {\n      console.warn(\"playWrong error\", e);\n    }\n  }\n\n  // Play click/hover\n  function playClick() {\n    if (!audioCtx || !gameState.soundEnabled) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = \"square\";\n      o.frequency.value = 1200;\n      o.connect(g);\n      g.connect(audioCtx.destination);\n      const now = audioCtx.currentTime;\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(0.04, now + 0.005);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.08);\n      o.start(now);\n      o.stop(now + 0.09);\n    } catch (e) {\n      console.warn(\"playClick error\", e);\n    }\n  }\n\n  // Helper: create a new math problem suitable for ages 7-9\n  function makeProblem(correctCount) {\n    // Increase difficulty slowly as player gets more correct\n    const level = Math.min(4, Math.floor(correctCount / 3) + 1);\n    // Level 1: + within 10, Level 2: +/-, Level 3: +,- within 20, Level4: simple times (2-5)\n    let a, b, op, answer;\n    if (level === 1) {\n      op = \"+\";\n      a = randInt(0, 10);\n      b = randInt(0, 10);\n      answer = a + b;\n    } else if (level === 2) {\n      op = Math.random() < 0.6 ? \"+\" : \"-\";\n      a = randInt(0, 12);\n      b = randInt(0, a); // ensure non-negative result if subtraction\n      answer = op === \"+\" ? a + b : a - b;\n    } else if (level === 3) {\n      op = Math.random() < 0.5 ? \"+\" : \"-\";\n      a = randInt(0, 20);\n      b = op === \"-\" ? randInt(0, a) : randInt(0, 20);\n      answer = op === \"+\" ? a + b : a - b;\n    } else {\n      // simple multiplication or mixed\n      if (Math.random() < 0.5) {\n        op = \"\u00d7\";\n        a = randInt(2, 6);\n        b = randInt(2, 6);\n        answer = a * b;\n      } else {\n        op = \"+\";\n        a = randInt(0, 30);\n        b = randInt(0, 30);\n        answer = a + b;\n      }\n    }\n    return { a, b, op, answer };\n  }\n\n  // Utility random int inclusive\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  // Reset and start new game\n  function resetGame() {\n    gameState.running = true;\n    gameState.correctCount = 0;\n    gameState.wrongCount = 0;\n    gameState.lives = MAX_LIVES;\n    gameState.inputText = \"\";\n    gameState.animations = [];\n    gameState.message = \"Welcome! Type your answer and press Enter or click OK.\";\n    gameState.currentProblem = makeProblem(0);\n    gameState.droneX = 100;\n    gameState.droneY = CENTER_AREA.y + CENTER_AREA.h / 2;\n    gameState.droneTargetX = gameState.droneX;\n    gameState.droneWobble = 0;\n    gameState.endState = null;\n    if (ensureAudio()) startBackgroundHum();\n    gameLoopResetTime();\n  }\n\n  // Game Over handling\n  function finishGame(state) {\n    // state: \"win\" or \"lose\"\n    gameState.running = false;\n    gameState.endState = state;\n    if (state === \"win\") {\n      gameState.message = `Hooray! You delivered ${TARGET_CORRECT} packages! Press R to restart.`;\n      playCorrect();\n    } else {\n      gameState.message = `Oh no! You lost all lives. Press R to try again.`;\n      playWrong();\n    }\n  }\n\n  // Submit answer logic\n  function submitAnswer() {\n    if (!gameState.running) return;\n    const raw = gameState.inputText.trim();\n    if (raw.length === 0) {\n      gameState.message = \"Please enter a number answer.\";\n      return;\n    }\n    // Parse integer\n    const parsed = parseInt(raw, 10);\n    if (isNaN(parsed)) {\n      gameState.message = \"Invalid number. Use digits and press Enter or OK.\";\n      return;\n    }\n    const correct = parsed === gameState.currentProblem.answer;\n    if (correct) {\n      gameState.correctCount += 1;\n      gameState.message = \"Correct! The drone happily flies to deliver the package.\";\n      gameState.inputText = \"\";\n      // animate drone to right then back\n      animateDroneDeliver();\n      playCorrect();\n      gameState.timeSinceLastCorrect = 0;\n      if (gameState.correctCount >= TARGET_CORRECT) {\n        finishGame(\"win\");\n      } else {\n        // prepare next problem after short delay via animation callback\n      }\n    } else {\n      gameState.wrongCount += 1;\n      gameState.lives -= 1;\n      gameState.message = \"Oops! Wrong answer. Try the next one.\";\n      gameState.inputText = \"\";\n      gameState.droneWobble = 1.0;\n      playWrong();\n      if (gameState.lives <= 0) {\n        finishGame(\"lose\");\n      } else {\n        gameState.currentProblem = makeProblem(gameState.correctCount);\n      }\n    }\n  }\n\n  // Drone delivery animation: drone goes to a 'package' (right side), a star appears, then returns.\n  function animateDroneDeliver() {\n    const startX = gameState.droneX;\n    const targetX = CENTER_AREA.x + CENTER_AREA.w - 120;\n    const duration = 900; // ms to go right\n    const returnDuration = 600;\n    const startTime = performance.now();\n    // push animation into animations array\n    const anim = {\n      type: \"deliver\",\n      startTime,\n      duration,\n      returnDuration,\n      startX,\n      targetX,\n      phase: \"going\",\n      done: false,\n    };\n    gameState.animations.push(anim);\n  }\n\n  // Main loop and rendering\n  function gameLoopResetTime() {\n    gameState.lastTick = performance.now();\n  }\n\n  function update(dt) {\n    // dt in ms\n    if (gameState.running) {\n      gameState.timeSinceLastCorrect += dt;\n      // Update animations\n      const now = performance.now();\n      for (let i = gameState.animations.length - 1; i >= 0; i--) {\n        const a = gameState.animations[i];\n        if (a.type === \"deliver\") {\n          const elapsed = now - a.startTime;\n          if (a.phase === \"going\") {\n            const t = Math.min(1, elapsed / a.duration);\n            // ease out\n            const ease = 1 - Math.pow(1 - t, 3);\n            gameState.droneX = a.startX + (a.targetX - a.startX) * ease;\n            gameState.droneWobble = (1 - t) * 0.6;\n            if (t >= 1) {\n              // create sparkle\n              spawnSparkles(a.targetX + 40, gameState.droneY - 30, 12);\n              // prepare return\n              a.phase = \"returning\";\n              a.returnStart = now + 120;\n            }\n          } else if (a.phase === \"returning\") {\n            const t2 = Math.min(1, (now - a.returnStart) / a.returnDuration);\n            const ease2 = t2 < 0 ? 0 : 1 - Math.pow(1 - t2, 3);\n            gameState.droneX = a.targetX - (a.targetX - a.startX) * ease2;\n            gameState.droneWobble = Math.max(0, 0.6 * (1 - t2));\n            if (t2 >= 1) {\n              // finished\n              a.done = true;\n              gameState.animations.splice(i, 1);\n              // new problem\n              gameState.currentProblem = makeProblem(gameState.correctCount);\n            }\n          }\n        }\n      }\n\n      // Update sparkles or other small animations\n      for (let i = gameState.animations.length - 1; i >= 0; i--) {\n        if (gameState.animations[i].done) {\n          gameState.animations.splice(i, 1);\n        }\n      }\n    } else {\n      // not running, but keep subtle idle animations\n      gameState.droneWobble *= 0.95;\n    }\n\n    // Update drone vertical bobbing\n    const bob = Math.sin((performance.now() / 600) + gameState.droneX / 80) * 6;\n    gameState.droneY = CENTER_AREA.y + CENTER_AREA.h / 2 + bob;\n  }\n\n  // Sparkle animation spawn\n  function spawnSparkles(x, y, count) {\n    for (let i = 0; i < count; i++) {\n      const a = {\n        type: \"spark\",\n        x,\n        y,\n        vx: (Math.random() - 0.5) * 1.8,\n        vy: -Math.random() * 1.6 - 0.6,\n        life: 800 + Math.random() * 600,\n        born: performance.now(),\n      };\n      gameState.animations.push(a);\n    }\n  }\n\n  // Draw helper: rounded rect\n  function roundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.lineTo(x + w - r, y);\n    ctx.quadraticCurveTo(x + w, y, x + w, y + r);\n    ctx.lineTo(x + w, y + h - r);\n    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);\n    ctx.lineTo(x + r, y + h);\n    ctx.quadraticCurveTo(x, y + h, x, y + h - r);\n    ctx.lineTo(x, y + r);\n    ctx.quadraticCurveTo(x, y, x + r, y);\n    ctx.closePath();\n  }\n\n  // Draw main frame\n  function render() {\n    // Clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // Calming pastel sky background with wacky clouds\n    drawBackground();\n\n    // Draw top UI: score left, lives right, sound toggle near top-center\n    drawTopUI();\n\n    // Draw center play area border\n    drawPlayArea();\n\n    // Draw drone and package\n    drawSceneObjects();\n\n    // Draw problem and input UI in center area (non-overlapping)\n    drawProblemArea();\n\n    // Draw instructions bottom center\n    drawBottomInstructions();\n\n    // If not running (end screens)\n    if (!gameState.running && gameState.endState) {\n      drawEndScreen();\n    }\n  }\n\n  function drawBackground() {\n    // gradient sky\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, \"#E8F8FF\");\n    g.addColorStop(1, \"#F6FCFF\");\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // gentle layered hills at bottom\n    ctx.fillStyle = \"#E8F6EF\";\n    roundRect(ctx, 0, HEIGHT - 80, WIDTH, 80, 0);\n    ctx.fill();\n\n    // wacky clouds\n    drawCloud(120, 60, 60, 28, \"#FFFFFF\", \"#EAF6FF\");\n    drawCloud(420, 40, 80, 34, \"#FFFFFF\", \"#F8F9FF\");\n    drawCloud(600, 90, 50, 24, \"#FFFFFF\", \"#F1F7FF\");\n    drawCloud(260, 110, 70, 30, \"#FFFFFF\", \"#F7FFFF\");\n\n    // soft grid of tiny tiny stars to make it whimsical\n    ctx.globalAlpha = 0.15;\n    for (let i = 0; i < 10; i++) {\n      const x = 40 + i * 64 + ((i % 2) * 12);\n      const y = 60 + ((i * 27) % 80);\n      drawTinyWackyStar(x, y, 6 + (i % 3));\n    }\n    ctx.globalAlpha = 1.0;\n  }\n\n  function drawCloud(cx, cy, w, h, color, shade) {\n    const grad = ctx.createLinearGradient(cx - w, cy - h, cx + w, cy + h);\n    grad.addColorStop(0, color);\n    grad.addColorStop(1, shade);\n    ctx.fillStyle = grad;\n    ctx.beginPath();\n    ctx.ellipse(cx, cy, w * 0.8, h, 0, 0, Math.PI * 2);\n    ctx.ellipse(cx - w * 0.45, cy + 6, w * 0.5, h * 0.8, 0, 0, Math.PI * 2);\n    ctx.ellipse(cx + w * 0.45, cy + 4, w * 0.45, h * 0.75, 0, 0, Math.PI * 2);\n    ctx.closePath();\n    ctx.fill();\n    // outline\n    ctx.strokeStyle = \"rgba(0,0,0,0.04)\";\n    ctx.lineWidth = 1;\n    ctx.stroke();\n  }\n\n  function drawTinyWackyStar(x, y, r) {\n    ctx.fillStyle = \"#FFF8E1\";\n    ctx.beginPath();\n    for (let i = 0; i < 5; i++) {\n      const a = (i * Math.PI * 2) / 5;\n      const rx = Math.cos(a) * r;\n      const ry = Math.sin(a) * r;\n      ctx.lineTo(x + rx, y + ry);\n    }\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function drawTopUI() {\n    // score at top-left\n    const scoreText = `Delivered: ${gameState.correctCount}/${TARGET_CORRECT}`;\n    ctx.font = `bold 18px ${FONT_FAMILY}`;\n    const sw = ctx.measureText(scoreText).width;\n    const boxW = sw + 20;\n    const boxH = 34;\n    const x = PADDING;\n    const y = PADDING;\n    ctx.fillStyle = \"rgba(255,255,255,0.75)\";\n    roundRect(ctx, x, y, boxW, boxH, 8);\n    ctx.fill();\n    ctx.fillStyle = \"#0B3954\";\n    ctx.fillText(scoreText, x + 10, y + 22);\n\n    // lives top-right\n    const livesText = `Lives: ${gameState.lives}`;\n    ctx.font = `bold 18px ${FONT_FAMILY}`;\n    const lw = ctx.measureText(livesText).width;\n    const lx = WIDTH - PADDING - (lw + 20);\n    const ly = PADDING;\n    ctx.fillStyle = \"rgba(255,255,255,0.75)\";\n    roundRect(ctx, lx, ly, lw + 20, 34, 8);\n    ctx.fill();\n    ctx.fillStyle = \"#B22222\";\n    ctx.fillText(livesText, lx + 10, ly + 22);\n\n    // sound toggle center top\n    const soundText = gameState.soundEnabled ? \"\ud83d\udd0a Sound (S)\" : \"\ud83d\udd08 Sound (S)\";\n    ctx.font = `16px ${FONT_FAMILY}`;\n    const swt = ctx.measureText(soundText).width;\n    const sx = (WIDTH - swt) / 2 - 8;\n    const sy = PADDING;\n    ctx.fillStyle = \"rgba(255,255,255,0.75)\";\n    roundRect(ctx, sx - 8, sy, swt + 16, 34, 8);\n    ctx.fill();\n    ctx.fillStyle = \"#073B4C\";\n    ctx.fillText(soundText, sx, sy + 22);\n    // register region for clicks\n    regions.soundToggle = { x: sx - 8, y: sy, w: swt + 16, h: 34 };\n  }\n\n  function drawPlayArea() {\n    // border for play area\n    ctx.save();\n    ctx.strokeStyle = \"rgba(11,57,80,0.08)\";\n    ctx.lineWidth = 2;\n    roundRect(ctx, CENTER_AREA.x, CENTER_AREA.y, CENTER_AREA.w, CENTER_AREA.h, 12);\n    ctx.stroke();\n    ctx.restore();\n\n    // Draw a visual \"delivery zone\" on the right side\n    const dzx = CENTER_AREA.x + CENTER_AREA.w - 140;\n    const dzy = CENTER_AREA.y + 40;\n    ctx.fillStyle = \"rgba(255,255,255,0.6)\";\n    roundRect(ctx, dzx, dzy, 120, CENTER_AREA.h - 80, 8);\n    ctx.fill();\n    // a little landing pad icon\n    ctx.fillStyle = \"#F9E79F\";\n    roundRect(ctx, dzx + 12, CENTER_AREA.y + CENTER_AREA.h - 120, 96, 36, 6);\n    ctx.fill();\n    ctx.fillStyle = \"#8E44AD\";\n    ctx.font = `bold 16px ${FONT_FAMILY}`;\n    ctx.fillText(\"Delivery Zone\", dzx + 18, CENTER_AREA.y + CENTER_AREA.h - 94);\n\n    // Draw some playful landmarks (trees/houses) left side to avoid overlap with UI\n    ctx.fillStyle = \"#C8E6C9\";\n    roundRect(ctx, CENTER_AREA.x + 12, CENTER_AREA.y + CENTER_AREA.h - 90, 70, 60, 8);\n    ctx.fill();\n    ctx.fillStyle = \"#6A994E\";\n    roundRect(ctx, CENTER_AREA.x + 20, CENTER_AREA.y + CENTER_AREA.h - 120, 30, 30, 6);\n    ctx.fill();\n  }\n\n  function drawSceneObjects() {\n    // Draw package near delivery zone\n    const pkgX = CENTER_AREA.x + CENTER_AREA.w - 110;\n    const pkgY = CENTER_AREA.y + CENTER_AREA.h / 2 - 40;\n    drawPackage(pkgX, pkgY, 60, 40);\n\n    // Draw drone at gameState.droneX, droneY\n    drawDrone(gameState.droneX, gameState.droneY, gameState.droneWobble);\n\n    // Draw sparkles\n    for (const a of gameState.animations) {\n      if (a.type === \"spark\") {\n        const age = performance.now() - a.born;\n        if (age > a.life) continue;\n        const t = age / a.life;\n        ctx.globalAlpha = 1 - t;\n        ctx.fillStyle = \"#FFF59D\";\n        ctx.beginPath();\n        ctx.arc(a.x + a.vx * t * 120, a.y + a.vy * t * 120, 2 + (1 - t) * 3, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.globalAlpha = 1;\n      }\n    }\n  }\n\n  function drawPackage(x, y, w, h) {\n    ctx.save();\n    ctx.fillStyle = \"#FFDAB9\";\n    roundRect(ctx, x, y, w, h, 6);\n    ctx.fill();\n    ctx.strokeStyle = \"#CC9966\";\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    // ribbon\n    ctx.fillStyle = \"#FF6F61\";\n    ctx.fillRect(x + w / 2 - 4, y + 4, 8, h - 8);\n    ctx.fillRect(x + 6, y + h / 2 - 4, w - 12, 8);\n    ctx.restore();\n  }\n\n  function drawDrone(x, y, wobble) {\n    ctx.save();\n    ctx.translate(x, y);\n\n    // bob / tilt based on wobble\n    const tilt = wobble * 0.8;\n    ctx.rotate(Math.sin(y / 50) * 0.02 - tilt);\n\n    // body\n    ctx.fillStyle = \"#89CFF0\";\n    roundRect(ctx, -36, -18, 72, 36, 10);\n    ctx.fill();\n\n    // canopy\n    ctx.beginPath();\n    ctx.ellipse(0, -10, 28, 12, 0, Math.PI, 0);\n    ctx.fillStyle = \"#D9F1FF\";\n    ctx.fill();\n\n    // face: wacky eyes\n    ctx.fillStyle = \"#073B4C\";\n    ctx.beginPath();\n    ctx.arc(-12, -2, 3, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(12, -2, 4, 0, Math.PI * 2);\n    ctx.fill();\n\n    // propellers (wacky squiggly)\n    drawProp(-34, -18, wobble, 12);\n    drawProp(34, -18, wobble, 12);\n    drawProp(-34, 18, wobble, 12);\n    drawProp(34, 18, wobble, 12);\n\n    // legs\n    ctx.strokeStyle = \"#073B4C\";\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(-14, 18);\n    ctx.lineTo(-20, 28);\n    ctx.moveTo(14, 18);\n    ctx.lineTo(20, 28);\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  function drawProp(cx, cy, wobble, r) {\n    ctx.save();\n    ctx.translate(cx, cy);\n    const spin = performance.now() / 80 + Math.random() * 0.2;\n    ctx.rotate(spin);\n    ctx.globalAlpha = 0.9;\n    ctx.fillStyle = \"#F6F8FF\";\n    ctx.beginPath();\n    ctx.ellipse(0, 0, r * (1 + wobble * 0.6), r / 3, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.globalAlpha = 1.0;\n    ctx.restore();\n  }\n\n  function drawProblemArea() {\n    // Problem text centered in the play area (not overlapping top or bottom)\n    const probText = `${gameState.currentProblem.a} ${gameState.currentProblem.op} ${gameState.currentProblem.b} = ?`;\n    ctx.font = `bold 32px ${FONT_FAMILY}`;\n    const pw = measureText(probText, 32, \"bold\");\n    const px = CENTER_AREA.x + (CENTER_AREA.w - pw) / 2;\n    const py = CENTER_AREA.y + 60;\n    // background box\n    ctx.fillStyle = \"rgba(255,255,255,0.85)\";\n    const pad = 16;\n    roundRect(ctx, px - pad, py - 36, pw + pad * 2, 56, 10);\n    ctx.fill();\n    // text\n    ctx.fillStyle = \"#052A3A\";\n    ctx.fillText(probText, px, py);\n\n    // Input box\n    const inputW = 160;\n    const inputH = 44;\n    const ix = CENTER_AREA.x + (CENTER_AREA.w - inputW) / 2;\n    const iy = py + 36;\n    ctx.fillStyle = \"rgba(255,255,255,0.9)\";\n    roundRect(ctx, ix, iy, inputW, inputH, 8);\n    ctx.fill();\n    ctx.strokeStyle = \"#A3D5FF\";\n    ctx.stroke();\n\n    // Text inside input\n    ctx.font = `20px ${FONT_FAMILY}`;\n    ctx.fillStyle = \"#073B4C\";\n    const inputDisplay = gameState.inputText.length ? gameState.inputText : \"Type answer...\";\n    ctx.fillText(inputDisplay, ix + 12, iy + 28);\n\n    // OK button to the right\n    const okW = 80;\n    const okH = inputH;\n    const okx = ix + inputW + 12;\n    const oky = iy;\n    ctx.fillStyle = \"#6EE7B7\";\n    roundRect(ctx, okx, oky, okW, okH, 8);\n    ctx.fill();\n    ctx.fillStyle = \"#05386B\";\n    ctx.font = `bold 18px ${FONT_FAMILY}`;\n    ctx.fillText(\"OK\", okx + okW / 2 - 12, oky + 28);\n    regions.okButton = { x: okx, y: oky, w: okW, h: okH };\n\n    // Message under input\n    ctx.font = `16px ${FONT_FAMILY}`;\n    ctx.fillStyle = \"#073B4C\";\n    const msg = gameState.message;\n    const mw = measureText(msg, 16);\n    const mx = CENTER_AREA.x + (CENTER_AREA.w - mw) / 2;\n    const my = iy + inputH + 22;\n    ctx.fillText(msg, mx, my);\n\n    // Draw keypad as optional clickable area below to assist children\n    drawKeypad(ix, iy + inputH + 36);\n  }\n\n  function drawKeypad(x, y) {\n    // grid 3x4 for digits 1-9, 0, backspace\n    const btnW = 56;\n    const btnH = 44;\n    const gap = 10;\n    ctx.font = `18px ${FONT_FAMILY}`;\n    regions.keypadButtons = [];\n    const numbers = [\n      [\"1\", \"2\", \"3\"],\n      [\"4\", \"5\", \"6\"],\n      [\"7\", \"8\", \"9\"],\n      [\"\u2190\", \"0\", \"\u21b5\"],\n    ];\n    for (let r = 0; r < numbers.length; r++) {\n      for (let c = 0; c < numbers[r].length; c++) {\n        const bx = x + c * (btnW + gap);\n        const by = y + r * (btnH + gap);\n        ctx.fillStyle = \"rgba(255,255,255,0.92)\";\n        roundRect(ctx, bx, by, btnW, btnH, 8);\n        ctx.fill();\n        ctx.strokeStyle = \"#E6EEF3\";\n        ctx.stroke();\n        ctx.fillStyle = \"#075985\";\n        ctx.fillText(numbers[r][c], bx + btnW / 2 - measureText(numbers[r][c], 18) / 2, by + 28);\n        regions.keypadButtons.push({ x: bx, y: by, w: btnW, h: btnH, value: numbers[r][c] });\n      }\n    }\n    // ensure enough spacing between keypad and bottom instructions\n  }\n\n  function drawBottomInstructions() {\n    const instrLines = [\n      \"Controls: Type digits, Backspace to delete, Enter/OK to submit.\",\n      \"Keyboard shortcuts: S = toggle sound, R = restart after game ends.\",\n      \"Goal: Deliver 10 packages. Fail after 3 wrong answers.\",\n    ];\n    ctx.font = `16px ${FONT_FAMILY}`;\n    // compute total height and center\n    const lineHeight = 20;\n    const totalH = instrLines.length * lineHeight;\n    let startY = HEIGHT - BOTTOM_UI_HEIGHT + (BOTTOM_UI_HEIGHT - totalH) / 2;\n    for (let i = 0; i < instrLines.length; i++) {\n      const txt = instrLines[i];\n      const tw = measureText(txt, 16);\n      const tx = (WIDTH - tw) / 2;\n      // draw background rectangle for readability\n      ctx.fillStyle = \"rgba(255,255,255,0.78)\";\n      roundRect(ctx, tx - 10, startY - 14, tw + 20, lineHeight + 6, 8);\n      ctx.fill();\n      ctx.fillStyle = \"#052A3A\";\n      ctx.fillText(txt, tx, startY + lineHeight - 4);\n      startY += lineHeight;\n    }\n  }\n\n  function drawEndScreen() {\n    // draw translucent overlay\n    ctx.fillStyle = \"rgba(5,42,58,0.5)\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // big central card\n    const cardW = 520;\n    const cardH = 260;\n    const cx = (WIDTH - cardW) / 2;\n    const cy = (HEIGHT - cardH) / 2;\n    ctx.fillStyle = \"rgba(255,255,255,0.98)\";\n    roundRect(ctx, cx, cy, cardW, cardH, 12);\n    ctx.fill();\n\n    // title\n    ctx.font = `bold 28px ${FONT_FAMILY}`;\n    ctx.fillStyle = \"#052A3A\";\n    const title = gameState.endState === \"win\" ? \"Victory!\" : \"Game Over\";\n    const tw = measureText(title, 28, \"bold\");\n    ctx.fillText(title, cx + (cardW - tw) / 2, cy + 54);\n\n    // message\n    ctx.font = `18px ${FONT_FAMILY}`;\n    ctx.fillStyle = \"#073B4C\";\n    const msg = gameState.message;\n    const mw = measureText(msg, 18);\n    ctx.fillText(msg, cx + (cardW - mw) / 2, cy + 92);\n\n    // score summary\n    const summary = `Delivered: ${gameState.correctCount}. Mistakes: ${gameState.wrongCount}.`;\n    ctx.fillText(summary, cx + (cardW - measureText(summary, 18)) / 2, cy + 126);\n\n    // restart button\n    const btnW = 160;\n    const btnH = 44;\n    const bx = cx + (cardW - btnW) / 2;\n    const by = cy + cardH - 84;\n    ctx.fillStyle = \"#6EE7B7\";\n    roundRect(ctx, bx, by, btnW, btnH, 10);\n    ctx.fill();\n    ctx.fillStyle = \"#05386B\";\n    ctx.font = `bold 18px ${FONT_FAMILY}`;\n    const label = \"Restart (R)\";\n    ctx.fillText(label, bx + (btnW - measureText(label, 18, \"bold\")) / 2, by + 28);\n\n    regions.restartButton = { x: bx, y: by, w: btnW, h: btnH };\n  }\n\n  // Input handling\n  canvas.addEventListener(\"keydown\", (e) => {\n    // Make sure canvas has focus.\n    // Allow number keys, backspace, enter, s, r\n    if (!e.key) return;\n    if (e.key >= \"0\" && e.key <= \"9\") {\n      if (!gameState.running && gameState.endState) return; // ignore input in end screen\n      if (gameState.inputText.length < 6) {\n        gameState.inputText += e.key;\n        playClick();\n      }\n      e.preventDefault();\n    } else if (e.key === \"Backspace\") {\n      gameState.inputText = gameState.inputText.slice(0, -1);\n      playClick();\n      e.preventDefault();\n    } else if (e.key === \"Enter\") {\n      submitAnswer();\n      e.preventDefault();\n    } else if (e.key.toLowerCase() === \"s\") {\n      // toggle sound\n      setSoundEnabled(!gameState.soundEnabled);\n      playClick();\n      e.preventDefault();\n    } else if (e.key.toLowerCase() === \"r\") {\n      if (!gameState.running && gameState.endState) {\n        resetGame();\n        playClick();\n      } else {\n        // also allow restart anytime\n        resetGame();\n        playClick();\n      }\n    } else if (e.key === \"-\" || e.key === \"+\") {\n      // allow negative sign if needed\n      if (gameState.inputText.length === 0) {\n        gameState.inputText = e.key;\n        playClick();\n      }\n    }\n  });\n\n  // Mouse / pointer input\n  canvas.addEventListener(\"click\", function (ev) {\n    const rect = canvas.getBoundingClientRect();\n    const mx = (ev.clientX - rect.left) * (canvas.width / rect.width);\n    const my = (ev.clientY - rect.top) * (canvas.height / rect.height);\n    // sound toggle region\n    if (regions.soundToggle && pointInRect(mx, my, regions.soundToggle)) {\n      setSoundEnabled(!gameState.soundEnabled);\n      playClick();\n      return;\n    }\n    // ok button\n    if (regions.okButton && pointInRect(mx, my, regions.okButton)) {\n      submitAnswer();\n      playClick();\n      return;\n    }\n    // keypad buttons\n    for (const b of regions.keypadButtons) {\n      if (pointInRect(mx, my, b)) {\n        if (b.value === \"\u2190\") {\n          gameState.inputText = gameState.inputText.slice(0, -1);\n        } else if (b.value === \"\u21b5\") {\n          submitAnswer();\n        } else {\n          if (gameState.inputText.length < 6) gameState.inputText += b.value;\n        }\n        playClick();\n        return;\n      }\n    }\n    // restart button\n    if (regions.restartButton && pointInRect(mx, my, regions.restartButton)) {\n      resetGame();\n      playClick();\n      return;\n    }\n\n    // Click on canvas elsewhere focuses canvas for keyboard control and optionally toggles audio resume\n    canvas.focus();\n    // try to resume audio if suspended\n    if (ensureAudio()) startBackgroundHum();\n  });\n\n  function pointInRect(px, py, r) {\n    return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;\n  }\n\n  // Input accessibility: display audio error message if audio blocked\n  function drawAudioErrorInfo() {\n    if (!audioCtx && gameState.audioError) {\n      ctx.font = `14px ${FONT_FAMILY}`;\n      const msg = \"Audio not available: \" + gameState.audioError;\n      const w = measureText(msg, 14);\n      const x = WIDTH - w - 12;\n      const y = HEIGHT - 20;\n      ctx.fillStyle = \"rgba(255,255,255,0.8)\";\n      roundRect(ctx, x - 8, y - 16, w + 16, 20, 6);\n      ctx.fill();\n      ctx.fillStyle = \"#4A4A4A\";\n      ctx.fillText(msg, x, y);\n    }\n  }\n\n  // Main animation frame\n  function frame(now) {\n    if (!gameState.lastTick) gameState.lastTick = now;\n    const dt = now - gameState.lastTick;\n    gameState.lastTick = now;\n    try {\n      update(dt);\n      render();\n      drawAudioErrorInfo();\n    } catch (e) {\n      console.error(\"Render/update error\", e);\n      // stop the loop on unexpected errors\n      return;\n    }\n    requestAnimationFrame(frame);\n  }\n\n  // Initialize\n  canvas.style.outline = \"none\";\n  canvas.focus();\n  resetGame();\n  if (ensureAudio()) startBackgroundHum();\n  requestAnimationFrame(frame);\n\n  // Utility: expose some handy console control (for debugging only)\n  window._droneMathGame = {\n    state: gameState,\n    reset: resetGame,\n  };\n\n  // Proper error handling for resource loading: none external used; audio errors handled.\n\n})();\n---\n",
  "improve_response_tokens": 22190,
  "formatted_code": true,
  "formatting_response_tokens": 24220,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}