{
  "generated_date": "2025-09-13",
  "generated_timestamp": "2025-09-13T00:25:07.818115",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 10311,
  "game_filename": "2025-09-13.js",
  "game_size_bytes": 29341,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function() {\n  // Machine Math - a calming math game for ages 7-9\n  // Renders inside element with id 'game-of-the-day-stage'\n  // All visuals drawn on canvas. Sounds created with Web Audio API.\n  // Accessible controls via keyboard and mouse. Proper error handling included.\n\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const MAX_LEVEL = 5;\n  const CONTAINER_ID = 'game-of-the-day-stage';\n\n  // Grab container\n  const container = document.getElementById(CONTAINER_ID);\n  if (!container) {\n    console.error('Game container not found:', CONTAINER_ID);\n    return;\n  }\n\n  // Make container accessible\n  container.setAttribute('role', 'application');\n  container.setAttribute('aria-label', 'Machine Math game. Choose gears (cogs) to add up to the target number. Use mouse or keyboard. Press space or click to start audio.');\n  container.style.position = container.style.position || 'relative';\n  container.style.outline = 'none';\n  container.tabIndex = 0; // enable keyboard focus\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.width = WIDTH + 'px';\n  canvas.style.height = HEIGHT + 'px';\n  canvas.setAttribute('role', 'img');\n  canvas.setAttribute('aria-label', 'Game area: a colorful machine and moving gears.');\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Create an offscreen live region for screen readers\n  const live = document.createElement('div');\n  live.setAttribute('aria-live', 'polite');\n  live.style.position = 'absolute';\n  live.style.left = '-9999px';\n  live.style.width = '1px';\n  live.style.height = '1px';\n  live.style.overflow = 'hidden';\n  container.appendChild(live);\n\n  // DPR scaling for crisp canvas\n  const DPR = window.devicePixelRatio || 1;\n  canvas.width = Math.round(WIDTH * DPR);\n  canvas.height = Math.round(HEIGHT * DPR);\n  ctx.scale(DPR, DPR);\n\n  // Audio setup with error handling\n  let audioCtx = null;\n  let audioEnabled = false;\n  let ambientNodes = null;\n  try {\n    const AudioContextClass = window.AudioContext || window.webkitAudioContext;\n    if (AudioContextClass) {\n      audioCtx = new AudioContextClass();\n      // Do not mark audioEnabled true until user gesture resume\n      audioEnabled = false;\n    } else {\n      console.warn('Web Audio API not available.');\n      audioCtx = null;\n      audioEnabled = false;\n    }\n  } catch (e) {\n    console.error('AudioContext creation failed:', e);\n    audioCtx = null;\n    audioEnabled = false;\n  }\n\n  // Utility: safe connect\n  function safeConnect(nodeA, nodeB) {\n    try {\n      if (nodeA && nodeB && typeof nodeA.connect === 'function') nodeA.connect(nodeB);\n    } catch (e) {\n      console.error('Audio connect error', e);\n    }\n  }\n\n  // Play a short click (interaction)\n  function playClick() {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = 'square';\n      o.frequency.value = 700;\n      g.gain.value = 0.0001;\n      safeConnect(o, g);\n      safeConnect(g, audioCtx.destination);\n      const now = audioCtx.currentTime;\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(0.06, now + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);\n      o.start(now);\n      o.stop(now + 0.2);\n    } catch (e) {\n      console.error('playClick error', e);\n    }\n  }\n\n  // Play correct chime (melody)\n  function playCorrect() {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const freqs = [880, 1100, 1320];\n      let offset = 0;\n      freqs.forEach((f) => {\n        const o = audioCtx.createOscillator();\n        const g = audioCtx.createGain();\n        o.type = 'sine';\n        o.frequency.value = f;\n        g.gain.value = 0.0001;\n        safeConnect(o, g);\n        safeConnect(g, audioCtx.destination);\n        g.gain.setValueAtTime(0.0001, now + offset);\n        g.gain.exponentialRampToValueAtTime(0.04, now + offset + 0.03);\n        g.gain.exponentialRampToValueAtTime(0.0001, now + offset + 0.2);\n        o.start(now + offset);\n        o.stop(now + offset + 0.24);\n        offset += 0.12;\n      });\n    } catch (e) {\n      console.error('playCorrect error', e);\n    }\n  }\n\n  // Play wrong buzzer\n  function playWrong() {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const o = audioCtx.createOscillator();\n      const f = audioCtx.createBiquadFilter();\n      const g = audioCtx.createGain();\n      o.type = 'square';\n      o.frequency.value = 250;\n      f.type = 'lowpass';\n      f.frequency.value = 600;\n      g.gain.value = 0.0001;\n      safeConnect(o, f);\n      safeConnect(f, g);\n      safeConnect(g, audioCtx.destination);\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(0.06, now + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);\n      o.start(now);\n      o.frequency.exponentialRampToValueAtTime(60, now + 0.35);\n      o.stop(now + 0.36);\n    } catch (e) {\n      console.error('playWrong error', e);\n    }\n  }\n\n  // Start ambient background sound (gentle)\n  function startAmbient() {\n    if (!audioCtx || !audioEnabled) return;\n    stopAmbient();\n    try {\n      const master = audioCtx.createGain();\n      master.gain.value = 0.02; // gentle\n      safeConnect(master, audioCtx.destination);\n\n      // Two slow oscillators with slight detune\n      const o1 = audioCtx.createOscillator();\n      o1.type = 'sine';\n      o1.frequency.value = 110;\n      const o2 = audioCtx.createOscillator();\n      o2.type = 'sine';\n      o2.frequency.value = 147;\n\n      const g1 = audioCtx.createGain();\n      const g2 = audioCtx.createGain();\n      g1.gain.value = 0.5;\n      g2.gain.value = 0.45;\n\n      const filt = audioCtx.createBiquadFilter();\n      filt.type = 'lowpass';\n      filt.frequency.value = 600;\n\n      safeConnect(o1, g1);\n      safeConnect(o2, g2);\n      safeConnect(g1, filt);\n      safeConnect(g2, filt);\n      safeConnect(filt, master);\n\n      o1.start();\n      o2.start();\n\n      // Slow LFO on master gain\n      const lfo = audioCtx.createOscillator();\n      lfo.type = 'sine';\n      lfo.frequency.value = 0.08;\n      const lfoGain = audioCtx.createGain();\n      lfoGain.gain.value = 0.01;\n      safeConnect(lfo, lfoGain);\n      safeConnect(lfoGain, master.gain);\n      lfo.start();\n\n      ambientNodes = { o1, o2, g1, g2, filt, lfo, lfoGain, master };\n    } catch (e) {\n      console.error('startAmbient error', e);\n    }\n  }\n\n  function stopAmbient() {\n    if (!ambientNodes) return;\n    try {\n      ['o1', 'o2', 'lfo'].forEach(k => {\n        if (ambientNodes[k] && ambientNodes[k].stop) {\n          try { ambientNodes[k].stop(); } catch (e) {}\n        }\n      });\n    } catch (e) {\n      console.error('stopAmbient error', e);\n    } finally {\n      ambientNodes = null;\n    }\n  }\n\n  // Fade audio context on user gesture\n  function enableAudioOnGesture() {\n    if (!audioCtx) return;\n    if (audioCtx.state === 'suspended') {\n      audioCtx.resume().then(() => {\n        audioEnabled = true;\n        startAmbient();\n        liveUpdate('Audio enabled. Gentle background sounds started.');\n      }).catch((e) => {\n        console.warn('Audio resume failed:', e);\n        audioEnabled = false;\n        liveUpdate('Audio could not be started. You can still play without sound.');\n      });\n    } else {\n      audioEnabled = true;\n      startAmbient();\n      liveUpdate('Audio started.');\n    }\n  }\n\n  // Live region update helper\n  function liveUpdate(msg) {\n    live.textContent = msg;\n  }\n\n  // Game state\n  let level = 1;\n  let score = 0;\n  let state = 'start'; // start, playing, levelComplete, won\n  let waitingForStart = true; // require initial user gesture for audio\n  let cogs = []; // moving cogs on conveyor\n  let placedCogs = []; // cogs placed in machine\n  let selectedCog = null; // reference to cog object when grabbed\n  let hoverCog = null;\n  let conveyorY = 120;\n  let machineX = 460;\n  let machineY = 140;\n  let target = 0;\n\n  // Cog class/object factory\n  function createCog(value, x, y, radius = 30) {\n    return {\n      id: Math.random().toString(36).slice(2, 9),\n      value,\n      x,\n      y,\n      radius,\n      baseX: x,\n      baseY: y,\n      speed: 0.4 + Math.random() * 0.8,\n      dir: Math.random() > 0.5 ? 1 : -1,\n      rotation: Math.random() * Math.PI * 2,\n      grabbed: false,\n      placed: false,\n      wobble: Math.random() * 0.5,\n    };\n  }\n\n  // Level generation ensuring at least one subset equals target\n  function generateLevel(lv) {\n    cogs = [];\n    placedCogs = [];\n    selectedCog = null;\n    hoverCog = null;\n\n    // Choose subset count (2 or 3)\n    const subsetCount = Math.random() > 0.5 ? 2 : 3;\n    const subset = [];\n    // Build a subset with values between 1 and 9\n    let running = 0;\n    for (let i = 0; i < subsetCount; i++) {\n      const maxVal = Math.max(1, 6 - subsetCount + lv); // bias to slightly larger numbers as levels increase\n      let val = 1 + Math.floor(Math.random() * Math.min(9, maxVal + 3));\n      // ensure not too many smalls\n      if (i === subsetCount - 1 && running + val < 4) val = 4;\n      subset.push(val);\n      running += val;\n    }\n    target = running; // target is sum of subset, ensures solvable\n\n    // Place these subset cogs plus extras\n    const totalCogs = 5; // number of items on conveyor\n    const extrasCount = totalCogs - subset.length;\n    const extras = [];\n    for (let i = 0; i < extrasCount; i++) {\n      // random extras that don't accidentally make alternate subset trivial but may mislead\n      let val = 1 + Math.floor(Math.random() * 9);\n      // avoid adding same combination that makes additional trivial solutions by chance: it's okay if duplicates exist\n      extras.push(val);\n    }\n\n    const allValues = shuffleArray([...subset, ...extras]);\n\n    // Place them along conveyor area horizontally\n    const startX = 80;\n    const spacing = 110;\n    for (let i = 0; i < allValues.length; i++) {\n      const x = startX + i * spacing;\n      const y = conveyorY;\n      cogs.push(createCog(allValues[i], x, y));\n    }\n\n    state = 'playing';\n    waitingForStart = false;\n    liveUpdate(`Level ${lv}. Target ${target}. Pick cogs that add to ${target}.`);\n  }\n\n  // Utility shuffle\n  function shuffleArray(arr) {\n    const a = arr.slice();\n    for (let i = a.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [a[i], a[j]] = [a[j], a[i]];\n    }\n    return a;\n  }\n\n  // Collision detection for cog-point\n  function pointInCog(px, py, cog) {\n    const dx = px - cog.x;\n    const dy = py - cog.y;\n    return dx * dx + dy * dy <= cog.radius * cog.radius;\n  }\n\n  // Main draw loop\n  function draw() {\n    // Clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // Soft background\n    drawBackground();\n\n    // Draw machine area\n    drawMachine();\n\n    // Draw conveyor and cogs\n    drawConveyor();\n\n    // HUD: level, target, instructions, audio icon\n    drawHUD();\n\n    // Overlay messages depending on state\n    if (state === 'start') {\n      drawStartOverlay();\n    } else if (state === 'levelComplete') {\n      drawLevelCompleteOverlay();\n    } else if (state === 'won') {\n      drawWonOverlay();\n    }\n\n    // Accessibility focus highlight\n    if (selectedCog && selectedCog.grabbed) {\n      // a subtle halo is drawn on selected cog already\n    }\n  }\n\n  function drawBackground() {\n    // calming gradient with wacky floating shapes\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, '#e8f4ff');\n    g.addColorStop(1, '#f7fbf2');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // soft wacky clouds (circles)\n    for (let i = 0; i < 5; i++) {\n      const cx = 40 + (i * 160 + (Date.now() / 300) % 120);\n      const cy = 40 + (i % 2 === 0 ? 10 : -10);\n      ctx.globalAlpha = 0.06 + (i % 2) * 0.02;\n      ctx.fillStyle = '#ffffff';\n      ctx.beginPath();\n      ctx.ellipse(cx % WIDTH, cy + 20 * Math.sin(Date.now() / 3000 + i), 80, 32, 0, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    ctx.globalAlpha = 1;\n  }\n\n  function drawConveyor() {\n    // conveyor belt\n    ctx.fillStyle = '#dcdcdc';\n    roundRect(ctx, 40, conveyorY - 40, 380, 120, 16);\n    ctx.fill();\n\n    // little moving stripes for conveyor motion\n    const stripeW = 40;\n    const offset = (Date.now() / 60) % stripeW;\n    ctx.fillStyle = '#c0c0c0';\n    for (let x = 40 - offset; x < 420; x += stripeW * 2) {\n      ctx.fillRect(x, conveyorY - 28, stripeW, 80);\n    }\n\n    // draw cogs\n    cogs.forEach((cog) => {\n      // animate movement for unreleased cogs along small horizontal swing\n      if (!cog.grabbed && !cog.placed) {\n        const sway = Math.sin((Date.now() / 1000) * cog.speed * cog.dir + cog.wobble) * 6;\n        cog.x = cog.baseX + sway;\n        cog.rotation += 0.01 * cog.dir * cog.speed;\n      } else if (cog.placed) {\n        // placed cogs have a tiny bounce\n        cog.rotation += 0.02;\n      } else if (cog.grabbed) {\n        cog.rotation += 0.08;\n      }\n\n      drawCog(cog, cog === selectedCog ? '#ffedcc' : (cog === hoverCog ? '#edffec' : '#ffffff'));\n    });\n  }\n\n  function drawMachine() {\n    // machine body\n    ctx.save();\n    ctx.translate(machineX, machineY);\n\n    // playful machine base\n    ctx.fillStyle = '#cfe7ff';\n    roundRect(ctx, 0, 0, 240, 260, 18);\n    ctx.fill();\n\n    // control panel\n    ctx.fillStyle = '#ffffff';\n    roundRect(ctx, 20, 20, 200, 90, 10);\n    ctx.fill();\n\n    // display target\n    ctx.fillStyle = '#07263d';\n    ctx.font = '28px Arial';\n    ctx.fillText('Target', 32, 50);\n    ctx.font = '44px Arial';\n    ctx.fillStyle = '#d1495b';\n    ctx.fillText(String(target), 32, 88);\n\n    // slots area\n    ctx.fillStyle = '#f2f6f9';\n    roundRect(ctx, 20, 130, 200, 90, 8);\n    ctx.fill();\n\n    // draw placed cogs in slots (arranged)\n    const slotCount = 5;\n    const slotSpacing = 36;\n    const startX = 30;\n    const startY = 152;\n    placedCogs.forEach((cog, idx) => {\n      const px = startX + (idx % slotCount) * slotSpacing;\n      const py = startY + Math.floor(idx / slotCount) * 32;\n      // draw small cog circle with number\n      drawMiniCog(px, py, 14, cog.value);\n    });\n\n    // machine mouth/slot where you drop cogs\n    ctx.fillStyle = '#03263d';\n    roundRect(ctx, 170, 86, 40, 120, 6);\n    ctx.fill();\n\n    ctx.restore();\n\n    // decorative arms and gears\n    ctx.save();\n    ctx.translate(machineX - 30, machineY + 60);\n    ctx.fillStyle = '#ffd179';\n    ctx.beginPath();\n    ctx.ellipse(0, 0, 30, 12, Math.sin(Date.now() / 800) * 0.1, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n\n    // draw small indicator showing sum so far\n    const sumSoFar = placedCogs.reduce((s, c) => s + c.value, 0);\n    ctx.fillStyle = '#07263d';\n    ctx.font = '20px Arial';\n    ctx.fillText(`Sum: ${sumSoFar}`, machineX + 28, machineY + 240);\n  }\n\n  function drawMiniCog(x, y, r, val) {\n    ctx.save();\n    ctx.translate(x, y);\n    // teeth\n    ctx.fillStyle = '#f9f9f9';\n    for (let t = 0; t < 8; t++) {\n      ctx.beginPath();\n      const a = (t / 8) * Math.PI * 2;\n      const tx = Math.cos(a) * (r + 6);\n      const ty = Math.sin(a) * (r + 6);\n      ctx.rect(tx - 3, ty - 2, 6, 4);\n      ctx.fill();\n    }\n    // body\n    ctx.fillStyle = '#ffd379';\n    ctx.beginPath();\n    ctx.arc(0, 0, r, 0, Math.PI * 2);\n    ctx.fill();\n\n    // center\n    ctx.fillStyle = '#ffffff';\n    ctx.beginPath();\n    ctx.arc(0, 0, r / 2, 0, Math.PI * 2);\n    ctx.fill();\n\n    // number\n    ctx.fillStyle = '#052233';\n    ctx.font = '12px Arial';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(String(val), 0, 0);\n    ctx.restore();\n  }\n\n  function drawCog(cog, fillColor = '#fff') {\n    ctx.save();\n    ctx.translate(cog.x, cog.y);\n    ctx.rotate(cog.rotation);\n    // teeth\n    const teeth = 12;\n    for (let i = 0; i < teeth; i++) {\n      const a = (i / teeth) * Math.PI * 2;\n      const tx = Math.cos(a) * (cog.radius + 8);\n      const ty = Math.sin(a) * (cog.radius + 8);\n      ctx.fillStyle = '#f2f2f2';\n      ctx.beginPath();\n      ctx.ellipse(tx, ty, 6, 10, a, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    // main body\n    ctx.fillStyle = fillColor;\n    ctx.beginPath();\n    ctx.arc(0, 0, cog.radius, 0, Math.PI * 2);\n    ctx.fill();\n    // inner circle\n    ctx.fillStyle = '#ffffff';\n    ctx.beginPath();\n    ctx.arc(0, 0, cog.radius * 0.6, 0, Math.PI * 2);\n    ctx.fill();\n    // number\n    ctx.fillStyle = '#052233';\n    ctx.font = `${cog.radius * 0.7}px Arial`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(String(cog.value), 0, 0);\n    // highlight if selected\n    if (cog.grabbed) {\n      ctx.strokeStyle = '#ff7b7b';\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.arc(0, 0, cog.radius + 6, 0, Math.PI * 2);\n      ctx.stroke();\n    } else if (cog === hoverCog) {\n      ctx.strokeStyle = '#7bffbd';\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.arc(0, 0, cog.radius + 6, 0, Math.PI * 2);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  function drawHUD() {\n    // Level indicator\n    ctx.fillStyle = '#07263d';\n    ctx.font = '18px Arial';\n    ctx.fillText(`Level ${level}`, 16, 24);\n\n    // Score\n    ctx.fillStyle = '#07263d';\n    ctx.font = '18px Arial';\n    ctx.fillText(`Score ${score}`, WIDTH - 120, 24);\n\n    // Instructions compact\n    ctx.fillStyle = '#07263d';\n    ctx.font = '14px Arial';\n    ctx.fillText('Pick cogs and drop into machine to match the target number.', 16, HEIGHT - 30);\n    ctx.fillText('Keyboard: Tab/Left-Right to select, Space/Enter to grab/drop. Number keys to pick cogs.', 16, HEIGHT - 12);\n\n    // Audio icon\n    drawAudioIcon(WIDTH - 40, 36, audioEnabled);\n  }\n\n  function drawAudioIcon(x, y, on) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.fillStyle = on ? '#9fe6a9' : '#ffd1d1';\n    ctx.beginPath();\n    ctx.arc(0, 0, 14, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = '#07263d';\n    ctx.font = '12px Arial';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(on ? '\ud83d\udd0a' : '\ud83d\udd08', 0, 0);\n    ctx.restore();\n  }\n\n  function drawStartOverlay() {\n    ctx.fillStyle = 'rgba(4, 28, 52, 0.5)';\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.fillStyle = '#fff';\n    ctx.font = '26px Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText('Machine Math', WIDTH / 2, 140);\n    ctx.font = '18px Arial';\n    ctx.fillText('Assemble cogs to match the target number.', WIDTH / 2, 180);\n    ctx.fillText('Click or press Space to start. Use mouse or keyboard.', WIDTH / 2, 210);\n\n    // friendly machine drawing\n    ctx.save();\n    ctx.translate(WIDTH / 2 - 80, 250);\n    roundRect(ctx, 0, 0, 160, 140, 14);\n    ctx.fillStyle = '#f7f2e8';\n    ctx.fill();\n    ctx.fillStyle = '#07263d';\n    ctx.font = '20px Arial';\n    ctx.fillText('Click to Start', 80, 80);\n    ctx.restore();\n  }\n\n  function drawLevelCompleteOverlay() {\n    ctx.fillStyle = 'rgba(255,255,255,0.8)';\n    ctx.fillRect(160, 100, 400, 280);\n    ctx.strokeStyle = '#07263d';\n    ctx.strokeRect(160, 100, 400, 280);\n    ctx.fillStyle = '#07263d';\n    ctx.font = '22px Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText(`Nice! Level ${level} complete`, WIDTH / 2, 170);\n    ctx.font = '18px Arial';\n    ctx.fillText('Press Space or Click to continue.', WIDTH / 2, 210);\n  }\n\n  function drawWonOverlay() {\n    ctx.fillStyle = 'rgba(6, 60, 20, 0.85)';\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.fillStyle = '#e6ffe9';\n    ctx.font = '30px Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText('All Machines Fixed!', WIDTH / 2, 220);\n    ctx.font = '18px Arial';\n    ctx.fillText('Great work \u2014 you solved all the machine puzzles!', WIDTH / 2, 260);\n    ctx.fillText('Refresh to play again.', WIDTH / 2, 290);\n  }\n\n  // Utility rounded rect\n  function roundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n  }\n\n  // Interaction handling\n  let mouse = { x: 0, y: 0, down: false };\n\n  canvas.addEventListener('mousemove', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    mouse.x = (e.clientX - rect.left);\n    mouse.y = (e.clientY - rect.top);\n    // hover detection\n    if (!selectedCog) {\n      hoverCog = null;\n      for (let i = 0; i < cogs.length; i++) {\n        const cog = cogs[i];\n        if (!cog.placed && pointInCog(mouse.x, mouse.y, cog)) {\n          hoverCog = cog;\n          break;\n        }\n      }\n    } else if (selectedCog && selectedCog.grabbed) {\n      // move selected to mouse\n      selectedCog.x = mouse.x;\n      selectedCog.y = mouse.y;\n    }\n  });\n\n  canvas.addEventListener('mousedown', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    mouse.x = (e.clientX - rect.left);\n    mouse.y = (e.clientY - rect.top);\n    mouse.down = true;\n\n    // If start overlay present, clicking starts game\n    if (state === 'start' || waitingForStart) {\n      // enable audio on click gesture\n      enableAudioOnGesture();\n      waitingForStart = false;\n      if (state === 'start') {\n        generateLevel(level);\n        playClick();\n        return;\n      }\n    }\n\n    // If in levelComplete or won, clicking continues\n    if (state === 'levelComplete') {\n      playClick();\n      nextLevel();\n      return;\n    } else if (state === 'won') {\n      // Reset game\n      resetGame();\n      playClick();\n      return;\n    }\n\n    // pick a cog if clicked on one\n    for (let i = cogs.length - 1; i >= 0; i--) {\n      const cog = cogs[i];\n      if (!cog.placed && pointInCog(mouse.x, mouse.y, cog)) {\n        selectCog(cog);\n        return;\n      }\n    }\n  });\n\n  canvas.addEventListener('mouseup', (e) => {\n    mouse.down = false;\n    if (selectedCog && selectedCog.grabbed) {\n      // drop cog and check if over machine slot\n      const inMachine = isOverMachineSlot(selectedCog.x, selectedCog.y);\n      if (inMachine) {\n        placeCog(selectedCog);\n      } else {\n        // return to base position (smoothly)\n        playClick();\n        selectedCog.grabbed = false;\n        selectedCog = null;\n      }\n    }\n  });\n\n  // Keyboard controls\n  container.addEventListener('keydown', (e) => {\n    // Allow start on keyboard as well\n    if (waitingForStart && (e.key === ' ' || e.key === 'Enter')) {\n      enableAudioOnGesture();\n      waitingForStart = false;\n      if (state === 'start') {\n        generateLevel(level);\n        playClick();\n      }\n      e.preventDefault();\n      return;\n    }\n    if (state === 'start') return;\n\n    if (state === 'levelComplete' && (e.key === ' ' || e.key === 'Enter')) {\n      nextLevel();\n      e.preventDefault();\n      return;\n    } else if (state === 'won' && (e.key === ' ' || e.key === 'Enter')) {\n      resetGame();\n      e.preventDefault();\n      return;\n    }\n\n    // Navigation among cogs\n    const availableCogs = cogs.filter(c => !c.placed);\n    if (e.key === 'ArrowRight' || e.key === 'Tab') {\n      // cycle to next\n      if (availableCogs.length) {\n        let idx = availableCogs.indexOf(selectedCog);\n        idx = idx === -1 ? 0 : (idx + 1) % availableCogs.length;\n        selectCog(availableCogs[idx]);\n      }\n      e.preventDefault();\n      return;\n    } else if (e.key === 'ArrowLeft') {\n      if (availableCogs.length) {\n        let idx = availableCogs.indexOf(selectedCog);\n        idx = idx === -1 ? availableCogs.length - 1 : (idx - 1 + availableCogs.length) % availableCogs.length;\n        selectCog(availableCogs[idx]);\n      }\n      e.preventDefault();\n      return;\n    } else if (e.key === ' ' || e.key === 'Enter') {\n      // toggle grab/drop\n      if (!selectedCog && availableCogs.length) {\n        selectCog(availableCogs[0]);\n      } else if (selectedCog && !selectedCog.grabbed) {\n        // grab\n        grabSelected();\n      } else if (selectedCog && selectedCog.grabbed) {\n        // attempt drop at machine position (keyboard drops into machine)\n        const dropX = machineX + 190; // into slot\n        const dropY = machineY + 150;\n        selectedCog.x = dropX;\n        selectedCog.y = dropY;\n        placeCog(selectedCog);\n      }\n      playClick();\n      e.preventDefault();\n      return;\n    } else if (/^[1-9]$/.test(e.key)) {\n      // pick cog by number key index (1-based)\n      const idx = parseInt(e.key, 10) - 1;\n      const av = availableCogs;\n      if (idx >= 0 && idx < av.length) {\n        selectCog(av[idx]);\n      }\n      e.preventDefault();\n      return;\n    } else if (e.key === 'm' || e.key === 'M') {\n      // toggle audio\n      if (audioCtx) {\n        if (audioEnabled) {\n          stopAmbient();\n          audioEnabled = false;\n          liveUpdate('Audio muted.');\n        } else {\n          enableAudioOnGesture();\n        }\n      } else {\n        liveUpdate('Audio not available on this device.');\n      }\n    }\n  });\n\n  function selectCog(cog) {\n    // Deselect previous\n    if (selectedCog && selectedCog !== cog) {\n      selectedCog.grabbed = false;\n    }\n    selectedCog = cog;\n    // Bring selected to front by moving to end of array\n    const idx = cogs.indexOf(cog);\n    if (idx >= 0) {\n      cogs.splice(idx, 1);\n      cogs.push(cog);\n    }\n    // small visual highlight\n    liveUpdate(`Selected cog ${cog.value}. Press Space to grab or drag to machine.`);\n  }\n\n  function grabSelected() {\n    if (!selectedCog) return;\n    selectedCog.grabbed = true;\n  }\n\n  function isOverMachineSlot(x, y) {\n    // machine region rectangle roughly\n    return x >= machineX + 20 && x <= machineX + 220 && y >= machineY + 130 && y <= machineY + 220;\n  }\n\n  function placeCog(cog) {\n    cog.grabbed = false;\n    cog.placed = true;\n    // snap to placed array\n    placedCogs.push(cog);\n    selectedCog = null;\n    playClick();\n    // Check the sum\n    const sum = placedCogs.reduce((s, c) => s + c.value, 0);\n    if (sum === target) {\n      // success\n      playCorrect();\n      score += 10 * level;\n      state = 'levelComplete';\n      liveUpdate(`Perfect! You matched ${target}. Level complete.`);\n    } else if (sum > target) {\n      // over target\n      playWrong();\n      liveUpdate(`Oh no! Sum ${sum} is more than ${target}. Remove a cog and try again.`);\n      // We allow correction: remove last placed cog automatically with gentle rejection animation\n      setTimeout(() => {\n        // reject last placed\n        const rejected = placedCogs.pop();\n        if (rejected) {\n          rejected.placed = false;\n          // send it back to base position\n          rejected.x = rejected.baseX;\n          rejected.y = rejected.baseY;\n        }\n      }, 600);\n    } else {\n      // under target - encourage\n      playClick();\n      liveUpdate(`Good. Current sum ${sum}. Keep going to reach ${target}.`);\n    }\n  }\n\n  function nextLevel() {\n    if (level >= MAX_LEVEL) {\n      state = 'won';\n      liveUpdate('You have fixed all the machines. Fantastic!');\n      stopAmbient();\n      return;\n    }\n    level++;\n    generateLevel(level);\n  }\n\n  function resetGame() {\n    level = 1;\n    score = 0;\n    state = 'start';\n    waitingForStart = true;\n    cogs = [];\n    placedCogs = [];\n    selectedCog = null;\n    hoverCog = null;\n    liveUpdate('Game reset. Press Space or click to begin.');\n    // ambient may continue if audio enabled\n    startAmbient();\n  }\n\n  // Animation loop\n  function loop() {\n    update();\n    draw();\n    requestAnimationFrame(loop);\n  }\n\n  function update() {\n    // Hover detection subtle\n    if (!selectedCog) {\n      hoverCog = null;\n      for (let i = 0; i < cogs.length; i++) {\n        const cog = cogs[i];\n        if (!cog.placed && pointInCog(mouse.x, mouse.y, cog)) {\n          hoverCog = cog;\n          break;\n        }\n      }\n    }\n\n    // idle floating for placed cogs\n    placedCogs.forEach((c, i) => {\n      c.y = machineY + 152 + Math.floor(i / 5) * 32;\n      c.x = machineX + 30 + (i % 5) * 36;\n      c.rotation += 0.01;\n    });\n  }\n\n  // Start the loop\n  draw();\n  loop();\n\n  // Expose a helpful message for initial state\n  liveUpdate('Welcome to Machine Math. Press Space or click to start. Press M to toggle audio. Use keyboard or mouse.');\n\n  // Ensure user sees instructions if audio fails\n  if (!audioCtx) {\n    liveUpdate('Audio not available. You can still play the game without sound.');\n  }\n\n  // Cleanup on unload: stop audio nodes\n  window.addEventListener('unload', () => {\n    try {\n      stopAmbient();\n      if (audioCtx && typeof audioCtx.close === 'function') audioCtx.close();\n    } catch (e) { /* ignore */ }\n  });\n\n  // Handle visibility changes for audio\n  document.addEventListener('visibilitychange', () => {\n    if (document.hidden) {\n      // reduce ambient\n      if (ambientNodes && ambientNodes.master) ambientNodes.master.gain.setValueAtTime(0.001, audioCtx.currentTime);\n    } else {\n      if (ambientNodes && ambientNodes.master) ambientNodes.master.gain.setValueAtTime(0.02, audioCtx.currentTime);\n    }\n  });\n\n  // Provide some friendly error handling for resource failures (none to load) but catching unexpected exceptions\n  window.addEventListener('error', (ev) => {\n    console.error('Unexpected error in Machine Math', ev.error || ev.message || ev);\n    liveUpdate('An unexpected error occurred. Try refreshing the page.');\n  });\n\n})();\n---\n",
  "improve_response_tokens": 22006,
  "formatted_code": true,
  "formatting_response_tokens": 25303,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}