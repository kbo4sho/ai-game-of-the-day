{
  "generated_date": "2025-10-31",
  "generated_timestamp": "2025-10-31T00:28:00.037570",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9752,
  "game_filename": "2025-10-31.js",
  "game_size_bytes": 27110,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Drone Math Delivery - Canvas Game\n  // Renders into element with id \"game-of-the-day-stage\"\n  // For kids ages 7-9. Uses Web Audio API for sounds. All graphics drawn on canvas.\n\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const PADDING = 12;\n  const TARGET_SCORE = 10;\n  const MAX_LIVES = 3;\n  const OPTION_COUNT = 4;\n\n  // DOM setup\n  const container = document.getElementById(\"game-of-the-day-stage\");\n  if (!container) {\n    console.error(\"Missing container element with id 'game-of-the-day-stage'.\");\n    return;\n  }\n  container.innerHTML = \"\"; // clear any children\n  container.style.position = \"relative\";\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute(\"role\", \"img\");\n  canvas.setAttribute(\"aria-label\", \"Drone Delivery Math Game\");\n  canvas.style.display = \"block\";\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    console.error(\"Unable to get 2D context.\");\n    return;\n  }\n\n  // Audio setup with error handling\n  let audioContext = null;\n  let masterGain = null;\n  let ambientGain = null;\n  let audioEnabled = false;\n  let audioAllowed = false;\n  try {\n    const AudioCtx = window.AudioContext || window.webkitAudioContext;\n    if (AudioCtx) {\n      audioContext = new AudioCtx();\n      masterGain = audioContext.createGain();\n      ambientGain = audioContext.createGain();\n      masterGain.gain.value = 0.9;\n      ambientGain.gain.value = 0.06; // very gentle ambient hum\n      ambientGain.connect(masterGain);\n      masterGain.connect(audioContext.destination);\n      // start ambient hum\n      startAmbientHum();\n    } else {\n      console.warn(\"Web Audio API not supported in this browser.\");\n    }\n  } catch (e) {\n    console.error(\"Error creating AudioContext:\", e);\n    audioContext = null;\n  }\n\n  function resumeAudioIfNeeded() {\n    if (!audioContext) return;\n    if (audioContext.state === \"suspended\") {\n      audioContext.resume().then(() => {\n        audioAllowed = true;\n        audioEnabled = true;\n      }).catch((err) => {\n        console.warn(\"Audio resume failed:\", err);\n      });\n    } else {\n      audioAllowed = true;\n      audioEnabled = true;\n    }\n  }\n\n  // Ambient hum - a gentle backing oscillator with subtle movement\n  let ambientOsc1 = null;\n  let ambientOsc2 = null;\n  function startAmbientHum() {\n    if (!audioContext) return;\n    try {\n      ambientOsc1 = audioContext.createOscillator();\n      ambientOsc1.type = \"sine\";\n      ambientOsc1.frequency.value = 90; // low drone hum\n      const amp1 = audioContext.createGain();\n      amp1.gain.value = 0.02;\n      ambientOsc1.connect(amp1);\n      amp1.connect(ambientGain);\n\n      ambientOsc2 = audioContext.createOscillator();\n      ambientOsc2.type = \"sine\";\n      ambientOsc2.frequency.value = 120;\n      const amp2 = audioContext.createGain();\n      amp2.gain.value = 0.02;\n      ambientOsc2.connect(amp2);\n      amp2.connect(ambientGain);\n\n      ambientOsc1.start();\n      ambientOsc2.start();\n      audioAllowed = audioContext.state !== \"suspended\";\n      audioEnabled = audioAllowed;\n    } catch (e) {\n      console.error(\"Error starting ambient sound:\", e);\n    }\n  }\n\n  // Play a short tone; returns a promise that resolves when done\n  function playTone({ frequency = 440, type = \"sine\", duration = 0.2, volume = 0.12, detune = 0 } = {}) {\n    if (!audioContext || !audioEnabled) return Promise.resolve();\n    try {\n      const now = audioContext.currentTime;\n      const osc = audioContext.createOscillator();\n      const gain = audioContext.createGain();\n      osc.type = type;\n      osc.frequency.value = frequency;\n      osc.detune.value = detune;\n      gain.gain.setValueAtTime(volume, now);\n      gain.gain.exponentialRampToValueAtTime(0.001, now + duration);\n      osc.connect(gain);\n      gain.connect(masterGain);\n      osc.start(now);\n      osc.stop(now + duration + 0.05);\n      return new Promise((res) => {\n        setTimeout(res, (duration + 0.05) * 1000);\n      });\n    } catch (e) {\n      console.warn(\"playTone failed:\", e);\n      return Promise.resolve();\n    }\n  }\n\n  // Correct and incorrect feedback sequences\n  async function playCorrectSound() {\n    if (!audioContext || !audioEnabled) return;\n    // pleasant ascending chirp\n    const seq = [\n      { f: 660, d: 0.08 },\n      { f: 880, d: 0.10 },\n      { f: 990, d: 0.12 }\n    ];\n    for (const s of seq) {\n      await playTone({ frequency: s.f, type: \"sine\", duration: s.d, volume: 0.08 });\n    }\n  }\n  async function playIncorrectSound() {\n    if (!audioContext || !audioEnabled) return;\n    // low buzzer\n    await playTone({ frequency: 160, type: \"square\", duration: 0.22, volume: 0.14 });\n    await playTone({ frequency: 120, type: \"square\", duration: 0.18, volume: 0.12 });\n  }\n\n  // Utility: rounded rectangle\n  function roundRect(ctx, x, y, w, h, r) {\n    const radius = Math.min(r, w / 2, h / 2);\n    ctx.beginPath();\n    ctx.moveTo(x + radius, y);\n    ctx.arcTo(x + w, y, x + w, y + h, radius);\n    ctx.arcTo(x + w, y + h, x, y + h, radius);\n    ctx.arcTo(x, y + h, x, y, radius);\n    ctx.arcTo(x, y, x + w, y, radius);\n    ctx.closePath();\n  }\n\n  // Game state\n  let state = {\n    score: 0,\n    lives: MAX_LIVES,\n    currentQuestion: null,\n    options: [],\n    correctIndex: 0,\n    selectedOption: -1,\n    wrongCount: 0,\n    started: false,\n    phase: \"playing\", // \"playing\", \"won\", \"lost\"\n    droneX: 40,\n    droneY: 110,\n    lastAnswerTime: 0,\n    hoverIndex: -1,\n    ambientEnabled: true,\n    lastInteraction: Date.now()\n  };\n\n  // Accessibility: instructions text\n  const instructionsLines = [\n    \"Use mouse or keyboard to answer:\",\n    \"Click an option or press 1-4 to choose, Enter to confirm.\",\n    \"Press M to toggle sound. Press R or Enter on end screen to restart.\"\n  ];\n\n  // Generate a new math question appropriate for ages 7-9\n  function makeQuestion() {\n    // Randomly choose addition/subtraction or simple multiplication occasionally\n    const typeRoll = Math.random();\n    let a, b, problemText, answer;\n    if (typeRoll < 0.7) {\n      // addition or subtraction\n      if (Math.random() < 0.5) {\n        // addition up to 20\n        a = Math.floor(Math.random() * 16) + 2; // 2..17\n        b = Math.floor(Math.random() * 9) + 1; // 1..9\n        answer = a + b;\n        problemText = `${a} + ${b} = ?`;\n      } else {\n        // subtraction ensuring non-negative\n        a = Math.floor(Math.random() * 19) + 5; // 5..23\n        b = Math.floor(Math.random() * 5) + 1; // 1..5\n        if (b > a) [a, b] = [b, a];\n        answer = a - b;\n        problemText = `${a} \u2212 ${b} = ?`;\n      }\n    } else {\n      // simple multiplication 2..5 times 2..6\n      a = Math.floor(Math.random() * 4) + 2; // 2..5\n      b = Math.floor(Math.random() * 5) + 2; // 2..6\n      answer = a * b;\n      problemText = `${a} \u00d7 ${b} = ?`;\n    }\n    // Build options: include correct and distractors\n    const options = new Set();\n    options.add(answer);\n    while (options.size < OPTION_COUNT) {\n      // distractors within reasonable range\n      let delta = Math.max(1, Math.floor(Math.random() * 5));\n      let candidate = answer + (Math.random() < 0.5 ? -delta : delta);\n      if (Math.random() < 0.1) candidate = answer + (Math.floor(Math.random() * 10) - 5);\n      if (candidate < 0) continue;\n      options.add(candidate);\n    }\n    const optsArr = Array.from(options);\n    // Shuffle and determine correct index\n    for (let i = optsArr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [optsArr[i], optsArr[j]] = [optsArr[j], optsArr[i]];\n    }\n    const correctIndex = optsArr.indexOf(answer);\n    state.currentQuestion = problemText;\n    state.options = optsArr;\n    state.correctIndex = correctIndex;\n    state.selectedOption = -1;\n    state.hoverIndex = -1;\n    state.lastAnswerTime = 0;\n  }\n\n  // Hit test for option rectangles: compute layout then check\n  function layoutOptions() {\n    // Two-by-two grid centered in lower half\n    const boxW = 280;\n    const boxH = 64;\n    const gapX = 20;\n    const gapY = 18;\n    const totalW = boxW * 2 + gapX;\n    const startX = (WIDTH - totalW) / 2;\n    const startY = 220;\n    const rects = [];\n    for (let i = 0; i < OPTION_COUNT; i++) {\n      const col = i % 2;\n      const row = Math.floor(i / 2);\n      const x = startX + col * (boxW + gapX);\n      const y = startY + row * (boxH + gapY);\n      rects.push({ x, y, w: boxW, h: boxH });\n    }\n    return rects;\n  }\n\n  // Input handling\n  canvas.addEventListener(\"mousedown\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    handlePointer(mx, my, true);\n    resumeAudioIfNeeded();\n    state.lastInteraction = Date.now();\n  });\n  canvas.addEventListener(\"mousemove\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    handlePointer(mx, my, false);\n  });\n  window.addEventListener(\"keydown\", (e) => {\n    // Global keyboard control\n    if (!state.started) {\n      state.started = true;\n    }\n    resumeAudioIfNeeded();\n    state.lastInteraction = Date.now();\n    if (state.phase === \"won\" || state.phase === \"lost\") {\n      if (e.key === \"r\" || e.key === \"R\" || e.key === \"Enter\") {\n        restartGame();\n      }\n      return;\n    }\n    if (e.key === \"m\" || e.key === \"M\") {\n      toggleAudio();\n      return;\n    }\n    // number keys 1 to 4 select\n    if ([\"1\", \"2\", \"3\", \"4\"].includes(e.key)) {\n      const idx = parseInt(e.key, 10) - 1;\n      selectOption(idx);\n      return;\n    }\n    // arrows navigate\n    if (e.key === \"ArrowRight\") {\n      moveSelection(1);\n    } else if (e.key === \"ArrowLeft\") {\n      moveSelection(-1);\n    } else if (e.key === \"ArrowUp\") {\n      moveSelection(-2);\n    } else if (e.key === \"ArrowDown\") {\n      moveSelection(2);\n    } else if (e.key === \"Enter\" || e.key === \" \") {\n      // confirm\n      if (state.selectedOption >= 0) {\n        submitAnswer(state.selectedOption);\n      }\n    }\n  });\n\n  function toggleAudio() {\n    if (!audioContext) return;\n    audioEnabled = !audioEnabled;\n    if (audioEnabled && audioContext.state === \"suspended\") {\n      audioContext.resume().catch(() => {});\n    }\n  }\n\n  function handlePointer(mx, my, isClick) {\n    // If on end screen, check restart button\n    if (state.phase === \"won\" || state.phase === \"lost\") {\n      const btn = endScreenButtonRect();\n      if (mx >= btn.x && mx <= btn.x + btn.w && my >= btn.y && my <= btn.y + btn.h) {\n        if (isClick) restartGame();\n      }\n      return;\n    }\n\n    // Check options\n    const rects = layoutOptions();\n    let found = -1;\n    for (let i = 0; i < rects.length; i++) {\n      const r = rects[i];\n      if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) {\n        found = i;\n        break;\n      }\n    }\n    state.hoverIndex = found;\n    if (isClick && found >= 0) {\n      selectOption(found);\n      submitAnswer(found);\n    }\n  }\n\n  function moveSelection(delta) {\n    let idx = state.selectedOption;\n    if (idx < 0) idx = 0;\n    idx = (idx + delta + OPTION_COUNT) % OPTION_COUNT;\n    state.selectedOption = idx;\n  }\n\n  function selectOption(idx) {\n    if (state.phase !== \"playing\") return;\n    state.selectedOption = idx;\n  }\n\n  // Submission and scoring\n  function submitAnswer(idx) {\n    if (state.phase !== \"playing\") return;\n    const now = Date.now();\n    // prevent very fast repeat submissions\n    if (now - state.lastAnswerTime < 250) return;\n    state.lastAnswerTime = now;\n\n    if (idx === state.correctIndex) {\n      state.score += 1;\n      state.droneX = Math.min(WIDTH - 120, 40 + Math.floor((state.score / TARGET_SCORE) * (WIDTH - 180)));\n      playCorrectSound().catch(() => {});\n      // fun wobble\n      animateSuccess();\n      if (state.score >= TARGET_SCORE) {\n        state.phase = \"won\";\n        playVictorySequence();\n      } else {\n        // new question after short delay\n        setTimeout(makeQuestion, 700);\n      }\n    } else {\n      state.lives -= 1;\n      state.wrongCount += 1;\n      playIncorrectSound().catch(() => {});\n      animateCrash();\n      if (state.lives <= 0) {\n        state.phase = \"lost\";\n      } else {\n        // keep same question or provide new? We'll provide a new question after short delay\n        setTimeout(makeQuestion, 700);\n      }\n    }\n    state.selectedOption = -1;\n  }\n\n  // Victory sound sequence\n  async function playVictorySequence() {\n    if (!audioContext || !audioEnabled) return;\n    // arpeggio\n    const notes = [880, 990, 1320, 1760];\n    for (let i = 0; i < notes.length; i++) {\n      await playTone({ frequency: notes[i], type: \"sine\", duration: 0.16, volume: 0.09 });\n    }\n    // small celebratory burst\n    for (let i = 0; i < 3; i++) {\n      await playTone({ frequency: 660 + i * 80, type: \"triangle\", duration: 0.12, volume: 0.08 });\n    }\n  }\n\n  // Simple animations tracked by timers\n  let anims = {\n    successPulse: { t: 0 },\n    crashShake: { t: 0 }\n  };\n\n  function animateSuccess() {\n    anims.successPulse.t = 1.0; // counts down in update\n  }\n  function animateCrash() {\n    anims.crashShake.t = 1.0;\n  }\n\n  // Restart game\n  function restartGame() {\n    state.score = 0;\n    state.lives = MAX_LIVES;\n    state.wrongCount = 0;\n    state.phase = \"playing\";\n    state.droneX = 40;\n    state.started = true;\n    makeQuestion();\n  }\n\n  // End screen button rect\n  function endScreenButtonRect() {\n    const text = \"Restart (R or Enter)\";\n    ctx.font = \"18px sans-serif\";\n    const textW = ctx.measureText(text).width;\n    const btnW = textW + 28;\n    const btnH = 42;\n    const x = (WIDTH - btnW) / 2;\n    const y = HEIGHT / 2 + 60;\n    return { x, y, w: btnW, h: btnH, text };\n  }\n\n  // Drawing the entire scene\n  function draw() {\n    try {\n      // clear\n      ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n      // background - calming sky gradient with wacky stripes\n      const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n      g.addColorStop(0, \"#BEE3F8\");\n      g.addColorStop(0.5, \"#E6F7FF\");\n      g.addColorStop(1, \"#FAFFFE\");\n      ctx.fillStyle = g;\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n      // playful clouds (wacky)\n      drawCloud(80, 60, 70, 36, \"#FFFFFF\", \"#EAF7FF\");\n      drawCloud(250, 40, 100, 52, \"#F8FFFF\", \"#E0F4FF\");\n      drawCloud(560, 70, 72, 38, \"#FFFFFF\", \"#F0FBFF\");\n\n      // distant hills\n      ctx.fillStyle = \"#D6F7E3\";\n      roundRect(ctx, -40, HEIGHT - 160, WIDTH + 80, 220, 120);\n      ctx.fill();\n\n      // decorative sun\n      ctx.beginPath();\n      ctx.arc(WIDTH - 70, 60, 30, 0, Math.PI * 2);\n      ctx.fillStyle = \"#FFF2B8\";\n      ctx.fill();\n\n      // UI: Score top-left\n      ctx.font = \"18px sans-serif\";\n      const scoreText = `Delivered: ${state.score}/${TARGET_SCORE}`;\n      const scoreTextW = ctx.measureText(scoreText).width;\n      const scoreBgW = scoreTextW + 20;\n      const scoreX = PADDING;\n      const scoreY = PADDING;\n      ctx.fillStyle = \"rgba(255,255,255,0.85)\";\n      roundRect(ctx, scoreX, scoreY, scoreBgW, 34, 8);\n      ctx.fill();\n      ctx.fillStyle = \"#2d6a9f\";\n      ctx.font = \"18px sans-serif\";\n      ctx.fillText(scoreText, scoreX + 10, scoreY + 22);\n\n      // UI: Lives top-right\n      ctx.font = \"18px sans-serif\";\n      const livesText = `Lives: ${state.lives}`;\n      const livesTextW = ctx.measureText(livesText).width;\n      const livesBgW = livesTextW + 20;\n      const livesX = WIDTH - livesBgW - PADDING;\n      const livesY = PADDING;\n      ctx.fillStyle = \"rgba(255,255,255,0.85)\";\n      roundRect(ctx, livesX, livesY, livesBgW, 34, 8);\n      ctx.fill();\n      ctx.fillStyle = \"#a94444\";\n      ctx.fillText(livesText, livesX + 10, livesY + 22);\n      // little heart icons\n      for (let i = 0; i < MAX_LIVES; i++) {\n        const hx = livesX + livesBgW - 12 - i * 18;\n        const hy = livesY + 8;\n        drawHeart(hx - 10, hy + 6, 8, i < state.lives ? \"#e74c3c\" : \"#f0dede\");\n      }\n\n      // UI: Audio indicator top-center\n      ctx.font = \"14px sans-serif\";\n      const audioText = audioEnabled ? \"Sound: On (M to mute)\" : \"Sound: Off (M to unmute)\";\n      const audioW = ctx.measureText(audioText).width + 16;\n      const audioX = (WIDTH - audioW) / 2;\n      const audioY = PADDING + 40;\n      ctx.fillStyle = \"rgba(255,255,255,0.7)\";\n      roundRect(ctx, audioX, audioY, audioW, 28, 8);\n      ctx.fill();\n      ctx.fillStyle = \"#2c3e50\";\n      ctx.font = \"14px sans-serif\";\n      ctx.fillText(audioText, audioX + 8, audioY + 18);\n\n      // Progress lane and drone path\n      drawProgressPath();\n\n      // Drone - position depends on score and animation pulses\n      const pulse = anims.successPulse.t * 0.4;\n      const shake = anims.crashShake.t * 5;\n      const droneX = state.droneX + (Math.random() - 0.5) * shake;\n      const droneY = state.droneY - pulse * 10;\n      drawDrone(droneX, droneY);\n\n      // Draw package target ahead\n      drawTarget(WIDTH - 100, state.droneY + 10);\n\n      // Question display in upper center-left\n      ctx.font = \"28px sans-serif\";\n      ctx.fillStyle = \"rgba(255,255,255,0.88)\";\n      const qW = Math.max(180, ctx.measureText(state.currentQuestion || \"\").width + 40);\n      const qX = PADDING + 8;\n      const qY = 90;\n      roundRect(ctx, qX, qY, qW, 56, 10);\n      ctx.fill();\n      ctx.fillStyle = \"#16324a\";\n      ctx.font = \"24px sans-serif\";\n      ctx.fillText(state.currentQuestion || \"Press any key or click to start\", qX + 12, qY + 36);\n\n      // Options area\n      drawOptions();\n\n      // Bottom-center instructions\n      ctx.font = \"16px sans-serif\";\n      const instrY = HEIGHT - 72;\n      // Draw multi-line instructions with spacing and background\n      let instrMaxW = 0;\n      for (const line of instructionsLines) {\n        instrMaxW = Math.max(instrMaxW, ctx.measureText(line).width);\n      }\n      const instrBgW = instrMaxW + 24;\n      const instrX = (WIDTH - instrBgW) / 2;\n      const instrH = instructionsLines.length * 20 + 18;\n      roundRect(ctx, instrX, instrY - 6, instrBgW, instrH, 10);\n      ctx.fillStyle = \"rgba(255,255,255,0.9)\";\n      ctx.fill();\n      ctx.fillStyle = \"#2d4760\";\n      ctx.font = \"16px sans-serif\";\n      for (let i = 0; i < instructionsLines.length; i++) {\n        ctx.fillText(instructionsLines[i], instrX + 12, instrY + 20 * i + 18);\n      }\n\n      // If paused or awaiting audio permission show small overlay\n      if (!state.started) {\n        ctx.fillStyle = \"rgba(10,10,30,0.25)\";\n        roundRect(ctx, WIDTH / 2 - 180, HEIGHT / 2 - 54, 360, 108, 12);\n        ctx.fill();\n        ctx.fillStyle = \"#ffffff\";\n        ctx.font = \"20px sans-serif\";\n        const welcome = \"Welcome! Click or press any key to begin and enable sound.\";\n        const welcomeW = ctx.measureText(welcome).width;\n        ctx.fillText(welcome, WIDTH / 2 - welcomeW / 2, HEIGHT / 2 + 8);\n      }\n\n      // End screens\n      if (state.phase === \"won\") {\n        drawEndScreen(true);\n      } else if (state.phase === \"lost\") {\n        drawEndScreen(false);\n      }\n\n    } catch (e) {\n      console.error(\"Draw error:\", e);\n    }\n  }\n\n  function drawCloud(cx, cy, w, h, color1, color2) {\n    const gradient = ctx.createLinearGradient(cx - w / 2, cy - h / 2, cx + w / 2, cy + h / 2);\n    gradient.addColorStop(0, color1);\n    gradient.addColorStop(1, color2);\n    ctx.fillStyle = gradient;\n    roundRect(ctx, cx - w / 2, cy - h / 2, w, h, h / 2);\n    ctx.fill();\n    // playful puff circles\n    ctx.fillStyle = color1;\n    ctx.beginPath();\n    ctx.arc(cx - w / 4, cy - h / 4, h / 2.6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(cx + w / 6, cy - h / 5, h / 3.2, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  function drawHeart(x, y, size, color) {\n    ctx.save();\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    const topCurveHeight = size * 0.3;\n    ctx.moveTo(x, y + topCurveHeight);\n    // left\n    ctx.bezierCurveTo(x, y, x - size / 2, y, x - size / 2, y + topCurveHeight);\n    // bottom left\n    ctx.bezierCurveTo(x - size / 2, y + (size + topCurveHeight) / 2, x, y + (size + topCurveHeight) / 1.2, x, y + size);\n    // bottom right\n    ctx.bezierCurveTo(x, y + (size + topCurveHeight) / 1.2, x + size / 2, y + (size + topCurveHeight) / 2, x + size / 2, y + topCurveHeight);\n    // right\n    ctx.bezierCurveTo(x + size / 2, y, x, y, x, y + topCurveHeight);\n    ctx.closePath();\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function drawTarget(x, y) {\n    // a quirky landing pad\n    ctx.fillStyle = \"#fff1b6\";\n    roundRect(ctx, x - 28, y + 20, 120, 46, 12);\n    ctx.fill();\n    ctx.fillStyle = \"#ffb54d\";\n    ctx.font = \"18px sans-serif\";\n    const txt = \"Delivery Hub\";\n    ctx.fillText(txt, x - 6, y + 48);\n    // target circle\n    ctx.beginPath();\n    ctx.arc(x + 10, y, 32, 0, Math.PI * 2);\n    ctx.fillStyle = \"#fff\";\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(x + 10, y, 22, 0, Math.PI * 2);\n    ctx.fillStyle = \"#ffd166\";\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(x + 10, y, 8, 0, Math.PI * 2);\n    ctx.fillStyle = \"#ff6b6b\";\n    ctx.fill();\n  }\n\n  function drawProgressPath() {\n    // draw a subtle strip from left to right indicating route\n    const pathY = state.droneY + 42;\n    ctx.lineWidth = 8;\n    ctx.strokeStyle = \"rgba(255,255,255,0.5)\";\n    ctx.beginPath();\n    ctx.moveTo(20, pathY);\n    const seg = WIDTH - 140;\n    for (let i = 0; i < 6; i++) {\n      ctx.lineTo(20 + seg * ((i + 1) / 6), pathY + (i % 2 === 0 ? 4 : -4));\n    }\n    ctx.stroke();\n    // little sign posts\n    for (let i = 0; i < 4; i++) {\n      const x = 80 + i * 130;\n      ctx.fillStyle = \"#d7eaf2\";\n      roundRect(ctx, x, pathY - 18, 36, 16, 6);\n      ctx.fill();\n    }\n  }\n\n  function drawDrone(cx, cy) {\n    ctx.save();\n    ctx.translate(cx, cy);\n    // body\n    ctx.fillStyle = \"#8ad4ff\";\n    roundRect(ctx, -38, -10, 76, 34, 8);\n    ctx.fill();\n    // cockpit\n    ctx.fillStyle = \"#eaf8ff\";\n    roundRect(ctx, -10, -6, 30, 22, 6);\n    ctx.fill();\n    // rotors\n    drawRotor(-26, -12, 18, 0.9);\n    drawRotor(26, -12, 18, -0.9);\n    drawRotor(-26, 22, 18, -0.6);\n    drawRotor(26, 22, 18, 0.6);\n    // legs\n    ctx.strokeStyle = \"#3b5b6e\";\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.moveTo(-25, 24);\n    ctx.lineTo(-15, 36);\n    ctx.moveTo(25, 24);\n    ctx.lineTo(15, 36);\n    ctx.stroke();\n    // package\n    ctx.fillStyle = \"#ffd29f\";\n    roundRect(ctx, -12, 24, 28, 18, 4);\n    ctx.fill();\n    ctx.strokeStyle = \"#d79b5f\";\n    ctx.lineWidth = 2;\n    ctx.strokeRect(-12, 24, 28, 18);\n    ctx.restore();\n  }\n\n  function drawRotor(x, y, r, spin) {\n    ctx.save();\n    ctx.translate(x, y);\n    // blades\n    ctx.fillStyle = \"rgba(30,30,30,0.6)\";\n    for (let i = 0; i < 3; i++) {\n      ctx.beginPath();\n      ctx.ellipse(0, 0, r, r / 6, i * Math.PI * 0.66, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    // center\n    ctx.beginPath();\n    ctx.arc(0, 0, 6, 0, Math.PI * 2);\n    ctx.fillStyle = \"#2b3b44\";\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function drawOptions() {\n    const rects = layoutOptions();\n    ctx.font = \"20px sans-serif\";\n    for (let i = 0; i < rects.length; i++) {\n      const r = rects[i];\n      // background\n      const isSelected = state.selectedOption === i;\n      const isHover = state.hoverIndex === i;\n      if (isSelected) {\n        ctx.fillStyle = \"rgba(146,196,255,0.95)\";\n      } else if (isHover) {\n        ctx.fillStyle = \"rgba(255,255,255,0.92)\";\n      } else {\n        ctx.fillStyle = \"rgba(255,255,255,0.88)\";\n      }\n      roundRect(ctx, r.x, r.y, r.w, r.h, 10);\n      ctx.fill();\n\n      // text\n      ctx.fillStyle = \"#16324a\";\n      const optText = `${i + 1}. ${state.options[i]}`;\n      ctx.font = \"20px sans-serif\";\n      const textW = ctx.measureText(optText).width;\n      // ensure padding and non-overlap\n      ctx.fillText(optText, r.x + 16, r.y + 38);\n\n      // if last answered recently, show correct/incorrect highlight\n      if (Date.now() - state.lastAnswerTime < 800) {\n        if (i === state.correctIndex) {\n          ctx.strokeStyle = \"rgba(46,204,113,0.9)\";\n          ctx.lineWidth = 3;\n          roundRect(ctx, r.x + 2, r.y + 2, r.w - 4, r.h - 4, 8);\n          ctx.stroke();\n        }\n        if (state.hoverIndex === i && state.wrongCount > 0) {\n          // no-op; handled by lives feedback\n        }\n      }\n    }\n  }\n\n  function drawEndScreen(isWin) {\n    ctx.save();\n    // dim background\n    ctx.fillStyle = \"rgba(6, 20, 30, 0.45)\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // card\n    const cardW = 460;\n    const cardH = 220;\n    const cardX = (WIDTH - cardW) / 2;\n    const cardY = (HEIGHT - cardH) / 2 - 20;\n    ctx.fillStyle = \"#ffffff\";\n    roundRect(ctx, cardX, cardY, cardW, cardH, 12);\n    ctx.fill();\n\n    // Title text\n    ctx.fillStyle = isWin ? \"#1b6b2e\" : \"#8a2432\";\n    ctx.font = \"28px sans-serif\";\n    const title = isWin ? \"All Packages Delivered!\" : \"Uh-oh! The drone ran out of lives!\";\n    const titleW = ctx.measureText(title).width;\n    ctx.fillText(title, cardX + (cardW - titleW) / 2, cardY + 48);\n\n    // Message\n    ctx.font = \"18px sans-serif\";\n    ctx.fillStyle = \"#2b4756\";\n    const msg = isWin ? \"Great job! You helped the drone deliver all packages.\" : `Delivered ${state.score} package(s). Try again to beat the route!`;\n    const msgW = ctx.measureText(msg).width;\n    ctx.fillText(msg, cardX + (cardW - msgW) / 2, cardY + 88);\n\n    // Restart button\n    const btn = endScreenButtonRect();\n    const bx = btn.x;\n    const by = btn.y;\n    const bw = btn.w;\n    const bh = btn.h;\n    ctx.fillStyle = \"#4aa3ff\";\n    roundRect(ctx, bx, by, bw, bh, 8);\n    ctx.fill();\n    ctx.fillStyle = \"#fff\";\n    ctx.font = \"18px sans-serif\";\n    const txt = btn.text;\n    const txtW = ctx.measureText(txt).width;\n    ctx.fillText(txt, bx + (bw - txtW) / 2, by + 26);\n\n    // Small hint\n    ctx.fillStyle = \"#2b4756\";\n    ctx.font = \"14px sans-serif\";\n    const hint = \"Press R or Enter to restart. Or click the button.\";\n    const hintW = ctx.measureText(hint).width;\n    ctx.fillText(hint, cardX + (cardW - hintW) / 2, cardY + cardH - 22);\n\n    ctx.restore();\n  }\n\n  // Animations update\n  function update(dt) {\n    // decay animations\n    if (anims.successPulse.t > 0) anims.successPulse.t = Math.max(0, anims.successPulse.t - dt * 2.4);\n    if (anims.crashShake.t > 0) anims.crashShake.t = Math.max(0, anims.crashShake.t - dt * 2.6);\n\n    // subtle auto-hover reset\n    if (Date.now() - state.lastInteraction > 4000) {\n      state.hoverIndex = -1;\n    }\n  }\n\n  // Simple game loop\n  let last = performance.now();\n  function loop(now) {\n    const dt = Math.min(0.05, (now - last) / 1000);\n    last = now;\n    try {\n      update(dt);\n      draw();\n    } catch (e) {\n      console.error(\"Main loop error:\", e);\n    }\n    requestAnimationFrame(loop);\n  }\n\n  // Start-up\n  function init() {\n    // initial question\n    makeQuestion();\n    state.started = true;\n    // ensure initial audio resume will happen on first click/keypress\n    canvas.addEventListener(\"click\", resumeAudioIfNeeded, { once: true });\n    window.addEventListener(\"keydown\", resumeAudioIfNeeded, { once: true });\n    loop(performance.now());\n  }\n\n  init();\n})();\n---\n",
  "improve_response_tokens": 20364,
  "formatted_code": true,
  "formatting_response_tokens": 22584,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}