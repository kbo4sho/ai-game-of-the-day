# Game of the Day - 2025-10-02

## Metadata
- **Generated Date:** 2025-10-02
- **Generated Time:** 2025-10-02T00:26:06.237975
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-10-02.js
- **File Size:** 24730 bytes
- **Tokens Used:** 8360

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-10-02.js` - The playable game
- `2025-10-02.meta.json` - Machine-readable metadata
- `2025-10-02.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 18293

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 20950

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Math Machine Game for ages 7-9
  // Renders inside element with ID 'game-of-the-day-stage'
  // All visuals drawn on canvas. Audio via Web Audio API oscillators.
  // Accessible: keyboard controls, aria-live updates, visual cues, instructions.

  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const LEVEL_COUNT = 6; // number of puzzles to beat the game
  const CHOICES = 3;

  // Utility: clamp
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  // Find container
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Game container with ID "game-of-the-day-stage" not found.');
    return;
  }

  // Clear container
  container.innerHTML = '';
  container.style.position = 'relative';
  container.setAttribute('aria-hidden', 'false');

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.width = WIDTH + 'px';
  canvas.style.height = HEIGHT + 'px';
  canvas.setAttribute('role', 'img');
  canvas.setAttribute('aria-label', 'Math Machine game area');
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Accessibility: a live region for announcements
  const live = document.createElement('div');
  live.setAttribute('aria-live', 'polite');
  live.style.position = 'absolute';
  live.style.left = '-9999px';
  live.style.width = '1px';
  live.style.height = '1px';
  live.style.overflow = 'hidden';
  container.appendChild(live);

  // Visual status for audio (drawn on canvas too)
  let audioEnabled = true;
  let audioAvailable = true;

  // Audio setup with error handling
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let audioCtx = null;
  let ambientNodes = null;
  try {
    if (!AudioCtx) throw new Error('Web Audio API not supported in this browser.');
    audioCtx = new AudioCtx();
    // Resume on user gesture if needed
    if (audioCtx.state === 'suspended') {
      // Some browsers require a user gesture; we'll resume when user interacts.
      audioCtx.resume().catch(() => {
        // We'll handle resume later on interaction
      });
    }
  } catch (e) {
    console.warn('Audio unavailable:', e);
    audioAvailable = false;
    audioEnabled = false;
  }

  // Create ambient sound (gentle machine hum)
  function startAmbient() {
    if (!audioAvailable || !audioEnabled || !audioCtx) return;
    stopAmbient();
    try {
      const master = audioCtx.createGain();
      master.gain.value = 0.06;
      master.connect(audioCtx.destination);

      // Low slow oscillator for hum
      const osc = audioCtx.createOscillator();
      osc.type = 'sine';
      osc.frequency.value = 110; // low hum

      // Tremolo via LFO
      const lfo = audioCtx.createOscillator();
      lfo.type = 'triangle';
      lfo.frequency.value = 0.15;

      const lfoGain = audioCtx.createGain();
      lfoGain.gain.value = 0.4;

      lfo.connect(lfoGain);
      lfoGain.connect(master.gain);

      osc.connect(master);

      osc.start();
      lfo.start();

      ambientNodes = { osc, lfo, master };
    } catch (err) {
      console.warn('Ambient sound error:', err);
    }
  }

  function stopAmbient() {
    if (!ambientNodes) return;
    try {
      ambientNodes.osc.stop();
      ambientNodes.lfo.stop();
      ambientNodes.osc.disconnect();
      ambientNodes.lfo.disconnect();
      ambientNodes.master.disconnect();
    } catch (e) {
      // ignore
    }
    ambientNodes = null;
  }

  // Play a short chime for correct answers
  function playCorrect() {
    if (!audioAvailable || !audioEnabled || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const master = audioCtx.createGain();
      master.gain.value = 0.0001;
      master.connect(audioCtx.destination);

      // Two-tone arpeggio
      const freqs = [880, 1320]; // A5 and E6ish
      freqs.forEach((f, i) => {
        const o = audioCtx.createOscillator();
        o.type = 'sine';
        o.frequency.value = f;
        const g = audioCtx.createGain();
        g.gain.value = 0.0;
        o.connect(g);
        g.connect(master);
        o.start(now + i * 0.08);
        g.gain.linearRampToValueAtTime(0.12, now + i * 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, now + i * 0.4);
        o.stop(now + i * 0.5);
      });

      // swell
      master.gain.linearRampToValueAtTime(0.12, now + 0.01);
      master.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);
      setTimeout(() => master.disconnect(), 800);
    } catch (e) {
      console.warn('playCorrect error', e);
    }
  }

  // Play a short buzzer for incorrect answers
  function playIncorrect() {
    if (!audioAvailable || !audioEnabled || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      o.type = 'square';
      o.frequency.value = 220;
      const g = audioCtx.createGain();
      g.gain.value = 0.0001;
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 1200;
      o.connect(filter);
      filter.connect(g);
      g.connect(audioCtx.destination);
      o.start(now);
      g.gain.exponentialRampToValueAtTime(0.15, now + 0.02);
      o.frequency.setValueAtTime(220, now);
      o.frequency.exponentialRampToValueAtTime(80, now + 0.35);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);
      o.stop(now + 0.45);
    } catch (e) {
      console.warn('playIncorrect error', e);
    }
  }

  // Click sound for interactions
  function playClick() {
    if (!audioAvailable || !audioEnabled || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      o.type = 'triangle';
      o.frequency.value = 660;
      const g = audioCtx.createGain();
      g.gain.value = 0.0001;
      o.connect(g);
      g.connect(audioCtx.destination);
      o.start(now);
      g.gain.exponentialRampToValueAtTime(0.09, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);
      o.stop(now + 0.2);
    } catch (e) {
      console.warn('playClick error', e);
    }
  }

  // Ensure audio resumes on first interaction if suspended
  function tryResumeAudio() {
    if (!audioCtx) return;
    if (audioCtx.state === 'suspended') {
      audioCtx.resume().then(() => {
        if (audioEnabled) startAmbient();
      }).catch(() => {
        // ignore
      });
    }
  }

  // Game utilities for generating problems
  function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function generateProblem(levelIndex) {
    // Gradually increase difficulty: sum up to 10 then up to 20
    const maxSum = levelIndex < 2 ? 10 : levelIndex < 4 ? 15 : 20;
    const isAddition = Math.random() > 0.3; // mostly addition
    if (isAddition) {
      const a = randomInt(0, Math.min(12, maxSum));
      const b = randomInt(0, Math.min(maxSum - a, 12));
      return { type: 'add', a, b, answer: a + b };
    } else {
      const a = randomInt(0, Math.min(maxSum, 18));
      const b = randomInt(0, a); // ensure non-negative result
      return { type: 'sub', a, b, answer: a - b };
    }
  }

  function makeChoices(correct, levelIndex) {
    const choices = new Set([correct]);
    while (choices.size < CHOICES) {
      const spread = Math.max(3, Math.floor(5 + levelIndex * 1.2));
      const candidate = correct + randomInt(-spread, spread);
      if (candidate >= 0 && candidate <= 30) choices.add(candidate);
    }
    const arr = Array.from(choices);
    // shuffle
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  // Game state
  const game = {
    levelIndex: 0,
    problems: [],
    currentProblem: null,
    choices: [],
    selectedChoiceIndex: 0,
    score: 0,
    completed: false,
    lastFeedback: '', // message for aria
    audioMutedManually: false,
    paused: false
  };

  // Prepare levels
  for (let i = 0; i < LEVEL_COUNT; i++) {
    const p = generateProblem(i);
    game.problems.push(p);
  }

  function startLevel(index) {
    game.levelIndex = clamp(index, 0, LEVEL_COUNT - 1);
    game.currentProblem = game.problems[game.levelIndex];
    game.choices = makeChoices(game.currentProblem.answer, game.levelIndex);
    game.selectedChoiceIndex = 0;
    game.lastFeedback = `Level ${game.levelIndex + 1} of ${LEVEL_COUNT}: Solve the machine puzzle.`;
    announce(game.lastFeedback);
  }

  // Announce text to aria-live region
  function announce(text) {
    live.textContent = text;
  }

  // Geometry for UI elements
  const machineArea = { x: 40, y: 80, w: 420, h: 300 };
  const choicesArea = { x: 480, y: 120, w: 200, h: 260 };

  function drawRoundedRect(ctx, x, y, w, h, r) {
    const radius = r || 8;
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.arcTo(x + w, y, x + w, y + h, radius);
    ctx.arcTo(x + w, y + h, x, y + h, radius);
    ctx.arcTo(x, y + h, x, y, radius);
    ctx.arcTo(x, y, x + w, y, radius);
    ctx.closePath();
  }

  // Draw gear-like wacky elements
  function drawGear(ctx, cx, cy, radius, teeth, color, angle) {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(angle || 0);
    ctx.beginPath();
    for (let i = 0; i < teeth * 2; i++) {
      const r = i % 2 === 0 ? radius : radius * 0.7;
      const a = (i / (teeth * 2)) * Math.PI * 2;
      const x = Math.cos(a) * r;
      const y = Math.sin(a) * r;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
    // center hole
    ctx.beginPath();
    ctx.arc(0, 0, radius * 0.35, 0, Math.PI * 2);
    ctx.fillStyle = '#ffee';
    ctx.fill();
    ctx.restore();
  }

  // Simple confetti celebration
  let confettiParticles = [];
  function spawnConfetti() {
    confettiParticles = [];
    for (let i = 0; i < 80; i++) {
      confettiParticles.push({
        x: randomInt(100, WIDTH - 100),
        y: randomInt(-80, 0),
        vx: (Math.random() - 0.5) * 2,
        vy: Math.random() * 2 + 1,
        size: randomInt(6, 12),
        color: `hsl(${Math.floor(Math.random() * 360)}, 70%, 60%)`,
        rot: Math.random() * Math.PI * 2
      });
    }
  }

  // Draw everything
  let lastTime = 0;
  let gearAngle = 0;
  let celebrationTime = 0;

  function draw(time) {
    const dt = Math.min(0.04, (time - lastTime) / 1000 || 0);
    lastTime = time;
    // background
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    // soft gradient sky
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#f6f9ff');
    g.addColorStop(1, '#eaf2f8');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // title and instructions
    ctx.fillStyle = '#334';
    ctx.font = 'bold 20px "Segoe UI", Roboto, Arial';
    ctx.fillText('Math Machines: Fix the Wacky Robot!', 18, 28);
    ctx.font = '13px "Segoe UI", Roboto, Arial';
    ctx.fillStyle = '#345';
    ctx.fillText('Solve the math to fit parts into the machine. Use 1-3 keys or arrows + Enter. M to mute.', 18, 48);

    // machine background panel
    ctx.save();
    drawRoundedRect(ctx, machineArea.x, machineArea.y, machineArea.w, machineArea.h, 16);
    ctx.fillStyle = '#f0f7fa';
    ctx.fill();
    ctx.strokeStyle = '#cfe6ee';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();

    // draw gears on the left machine
    gearAngle += dt * 0.8;
    drawGear(ctx, machineArea.x + 80, machineArea.y + 80, 44, 12, '#c8dbe1', gearAngle);
    drawGear(ctx, machineArea.x + 160, machineArea.y + 220, 32, 10, '#dceff4', -gearAngle * 1.4);
    drawGear(ctx, machineArea.x + 260, machineArea.y + 120, 22, 8, '#d0e6ec', gearAngle * 0.6);

    // draw the "robot" machine: wacky shapes that fill in when correct
    const robotX = machineArea.x + 230;
    const robotY = machineArea.y + 180;
    // base body
    ctx.save();
    ctx.translate(robotX, robotY);
    // body color changes slightly with progress
    const progress = game.score / LEVEL_COUNT;
    const bodyR = 200 - progress * 40;
    const bodyG = 230 - progress * 60;
    const bodyB = 250 - progress * 80;
    ctx.fillStyle = `rgb(${bodyR}, ${bodyG}, ${bodyB})`;
    drawRoundedRect(ctx, -90, -70, 140, 120, 18);
    ctx.fill();
    ctx.strokeStyle = '#bcd6e0';
    ctx.lineWidth = 2;
    ctx.stroke();

    // face area
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.ellipse(-20, -30, 54, 36, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // eyes: add if progress >= levels
    ctx.fillStyle = '#334';
    ctx.beginPath();
    ctx.arc(-36, -34, 6 + progress * 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(-4, -34, 6 + progress * 4, 0, Math.PI * 2);
    ctx.fill();

    // mouth: changes when correct
    ctx.strokeStyle = '#334';
    ctx.lineWidth = 2;
    ctx.beginPath();
    const mouthY = -12 + (1 - progress) * 6;
    ctx.arc(-20, mouthY, 16, 0, Math.PI, false);
    ctx.stroke();

    // arms: draw little pistons
    ctx.fillStyle = '#dbeef7';
    ctx.fillRect(50, -10, 12, 10);
    ctx.fillRect(-102, -10, 12, 10);

    ctx.restore();

    // Draw current problem text on machine
    ctx.fillStyle = '#133';
    ctx.font = '18px "Segoe UI", Roboto, Arial';
    if (game.currentProblem) {
      const p = game.currentProblem;
      const eq = p.type === 'add' ? `${p.a} + ${p.b} = ?` : `${p.a} - ${p.b} = ?`;
      ctx.fillText('Machine Puzzle: ' + eq, machineArea.x + 16, machineArea.y + 40);
    } else {
      ctx.fillText('Loading puzzle...', machineArea.x + 16, machineArea.y + 40);
    }

    // Draw choices panel
    ctx.save();
    drawRoundedRect(ctx, choicesArea.x, choicesArea.y, choicesArea.w, choicesArea.h, 12);
    ctx.fillStyle = '#fff';
    ctx.fill();
    ctx.strokeStyle = '#cfe6ee';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillStyle = '#234';
    ctx.font = '16px "Segoe UI", Roboto, Arial';
    ctx.fillText('Parts (choices):', choicesArea.x + 12, choicesArea.y + 28);

    // draw each choice button
    const buttonH = 54;
    const gap = 16;
    for (let i = 0; i < CHOICES; i++) {
      const bx = choicesArea.x + 12;
      const by = choicesArea.y + 48 + i * (buttonH + gap);
      const bw = choicesArea.w - 24;
      // button background
      const isSelected = game.selectedChoiceIndex === i;
      drawRoundedRect(ctx, bx, by, bw, buttonH, 10);
      ctx.fillStyle = isSelected ? '#d9f3ff' : '#f8fdff';
      ctx.fill();
      ctx.strokeStyle = isSelected ? '#77c6dc' : '#dceff4';
      ctx.lineWidth = isSelected ? 3 : 2;
      ctx.stroke();

      // number text
      ctx.fillStyle = '#123';
      ctx.font = '22px "Segoe UI", Roboto, Arial';
      const text = game.choices[i] !== undefined ? String(game.choices[i]) : '-';
      ctx.fillText(text, bx + 18, by + 34);

      // label 1/2/3 for keyboard
      ctx.fillStyle = '#6aa';
      ctx.font = '12px "Segoe UI", Roboto, Arial';
      ctx.fillText(`(${i + 1})`, bx + bw - 34, by + 20);

      // visual hint for correct last answer when incorrect chosen recently
      // (we store feedback)
      if (game.lastFeedback && game.lastFeedback.includes('Correct') && game.choices[i] === game.currentProblem.answer) {
        // gentle glow
        ctx.save();
        ctx.globalAlpha = 0.12;
        ctx.fillStyle = '#8ee6b7';
        drawRoundedRect(ctx, bx - 2, by - 2, bw + 4, buttonH + 4, 12);
        ctx.fill();
        ctx.restore();
      }
    }
    ctx.restore();

    // Draw score/progress and audio indicator
    // progress bar
    const barX = 18;
    const barY = HEIGHT - 50;
    const barW = WIDTH - 36;
    ctx.fillStyle = '#eef7fb';
    drawRoundedRect(ctx, barX, barY, barW, 36, 8);
    ctx.fill();
    ctx.strokeStyle = '#cfe6ee';
    ctx.stroke();

    // filled progress
    const filledW = (game.score / LEVEL_COUNT) * (barW - 8);
    ctx.fillStyle = '#bfe8ff';
    drawRoundedRect(ctx, barX + 4, barY + 4, filledW, 28, 6);
    ctx.fill();

    ctx.fillStyle = '#224';
    ctx.font = '14px "Segoe UI", Roboto, Arial';
    ctx.fillText(`Progress: ${game.score} / ${LEVEL_COUNT}`, barX + 12, barY + 24);

    // audio icon
    ctx.save();
    const audioX = WIDTH - 58;
    const audioY = 18;
    ctx.fillStyle = audioEnabled ? '#4a9' : '#bbb';
    ctx.beginPath();
    ctx.moveTo(audioX, audioY + 6);
    ctx.lineTo(audioX + 10, audioY + 6);
    ctx.lineTo(audioX + 18, audioY);
    ctx.lineTo(audioX + 18, audioY + 24);
    ctx.lineTo(audioX + 10, audioY + 18);
    ctx.lineTo(audioX, audioY + 18);
    ctx.closePath();
    ctx.fill();
    if (!audioEnabled) {
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(audioX + 2, audioY + 2);
      ctx.lineTo(audioX + 22, audioY + 22);
      ctx.stroke();
    } else {
      // small wave lines
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(audioX + 22, audioY + 6);
      ctx.quadraticCurveTo(audioX + 28, audioY + 12, audioX + 22, audioY + 18);
      ctx.stroke();
    }
    ctx.restore();

    // Feedback text
    ctx.fillStyle = '#145';
    ctx.font = '14px "Segoe UI", Roboto, Arial';
    if (game.lastFeedback) {
      ctx.fillText(game.lastFeedback, 18, HEIGHT - 76);
    }

    // Victory celebration
    if (game.completed) {
      celebrationTime += dt;
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.restore();

      // animate confetti
      confettiParticles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.rot += 0.1;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        ctx.fillStyle = p.color;
        ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size * 0.6);
        ctx.restore();
      });

      // show message
      ctx.fillStyle = '#134';
      ctx.font = '28px "Segoe UI", Roboto, Arial';
      ctx.fillText('Machine Fixed! Great Job!', WIDTH / 2 - 180, HEIGHT / 2 - 10);
      ctx.font = '16px "Segoe UI", Roboto, Arial';
      ctx.fillText('Play again? Press R or click the glowing robot.', WIDTH / 2 - 170, HEIGHT / 2 + 20);
    }

    // animate confetti gravity and remove
    confettiParticles = confettiParticles.filter(p => p.y < HEIGHT + 40);

    requestAnimationFrame(draw);
  }

  // Interaction handling
  canvas.addEventListener('click', (e) => {
    tryResumeAudio();
    playClick();
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // if completed: click on robot area restarts
    if (game.completed) {
      const robotX = machineArea.x + 230;
      const robotY = machineArea.y + 180;
      const dx = x - robotX;
      const dy = y - robotY;
      if (dx > -120 && dx < 120 && dy > -120 && dy < 120) {
        restartGame();
        return;
      }
    }

    // check choices
    for (let i = 0; i < CHOICES; i++) {
      const bx = choicesArea.x + 12;
      const by = choicesArea.y + 48 + i * (54 + 16);
      const bw = choicesArea.w - 24;
      const bh = 54;
      if (x >= bx && x <= bx + bw && y >= by && y <= by + bh) {
        game.selectedChoiceIndex = i;
        handleSubmitChoice();
        return;
      }
    }

    // check audio icon click area
    const audioX = WIDTH - 58;
    const audioY = 18;
    if (x >= audioX - 4 && x <= audioX + 28 && y >= audioY - 4 && y <= audioY + 28) {
      toggleAudio();
      return;
    }
  });

  // Keyboard controls
  window.addEventListener('keydown', (e) => {
    // prevent page scroll for arrow keys when focused inside game
    const allowedKeys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Enter', ' ', 'm', 'M', 'r', 'R'];
    if (allowedKeys.includes(e.key)) e.preventDefault();

    tryResumeAudio();

    // Number keys 1-3 directly select
    if (/^[1-3]$/.test(e.key)) {
      const idx = parseInt(e.key, 10) - 1;
      if (idx >= 0 && idx < CHOICES && !game.completed) {
        game.selectedChoiceIndex = idx;
        playClick();
        handleSubmitChoice();
      }
      return;
    }

    switch (e.key) {
      case 'ArrowUp':
      case 'ArrowLeft':
        if (!game.completed) {
          game.selectedChoiceIndex = (game.selectedChoiceIndex + CHOICES - 1) % CHOICES;
          playClick();
        }
        break;
      case 'ArrowDown':
      case 'ArrowRight':
        if (!game.completed) {
          game.selectedChoiceIndex = (game.selectedChoiceIndex + 1) % CHOICES;
          playClick();
        }
        break;
      case 'Enter':
      case ' ':
        if (game.completed) {
          restartGame();
        } else {
          handleSubmitChoice();
        }
        break;
      case 'm':
      case 'M':
        toggleAudio();
        break;
      case 'r':
      case 'R':
        restartGame();
        break;
      default:
        break;
    }
  });

  function toggleAudio() {
    game.audioMutedManually = !game.audioMutedManually;
    audioEnabled = !game.audioMutedManually && audioAvailable;
    if (audioEnabled) {
      startAmbient();
      announce('Audio on');
    } else {
      stopAmbient();
      announce('Audio muted');
    }
    playClick();
  }

  // Handle submit choice (selecting the currently highlighted option)
  function handleSubmitChoice() {
    if (!game.currentProblem || game.completed) return;
    const idx = game.selectedChoiceIndex;
    const chosen = game.choices[idx];
    if (chosen === undefined) return;
    if (chosen === game.currentProblem.answer) {
      // correct
      playCorrect();
      game.score += 1;
      game.lastFeedback = `Correct! ${game.currentProblem.answer} fits perfectly.`;
      announce(game.lastFeedback);
      // animate or mark progression: advance to next level after small delay
      setTimeout(() => {
        if (game.score >= LEVEL_COUNT) {
          // won
          completeGame();
        } else {
          startLevel(game.levelIndex + 1);
        }
      }, 700);
    } else {
      // incorrect
      playIncorrect();
      game.lastFeedback = `Not quite. ${chosen} doesn't fit. Try again.`;
      announce(game.lastFeedback);
      // small shake or hint: nothing else
    }
  }

  function completeGame() {
    game.completed = true;
    game.lastFeedback = 'Correct! Machine fixed.';
    announce('Machine fixed! You win!');
    spawnConfetti();
    playCorrect();
    // stop ambient to highlight celebration then restart ambient after delay
    stopAmbient();
    setTimeout(() => {
      if (!game.audioMutedManually) startAmbient();
    }, 2000);
  }

  function restartGame() {
    // reset game
    game.levelIndex = 0;
    game.score = 0;
    game.completed = false;
    game.lastFeedback = 'New game started. Fix all machines!';
    // regenerate problems to keep it fresh
    game.problems = [];
    for (let i = 0; i < LEVEL_COUNT; i++) game.problems.push(generateProblem(i));
    startLevel(0);
    announce('Game restarted. Use keys 1-3 or arrow keys and Enter to select a part.');
    playClick();
    // start ambient if audio available
    tryResumeAudio();
    if (audioEnabled) startAmbient();
  }

  // Initialize
  function init() {
    // If audio available and not muted, start ambient
    if (audioAvailable && audioEnabled) startAmbient();

    // Start first level
    startLevel(0);

    // initial draw loop
    requestAnimationFrame(draw);

    // initial announcement
    announce('Welcome to Math Machines. Press 1, 2, or 3 to choose a part. Press M to toggle audio.');
  }

  // Error handling for unexpected exceptions
  window.addEventListener('error', function (ev) {
    console.error('Unexpected error', ev.error || ev.message);
    announce('An unexpected error occurred in the game. Please reload the page.');
  });

  // Provide a small help button drawn as overlay (keyboard accessible via 'H' or 'h')
  window.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'h') {
      announce('Help: Solve the math shown using the numbered parts on the right. Use 1-3 or arrows + Enter. Press M to mute.');
    }
  });

  // Start game on user gesture as well to ensure audio resume
  function ensureUserGestureListener() {
    function resumeOnInteraction() {
      tryResumeAudio();
      if (audioEnabled) startAmbient();
      window.removeEventListener('pointerdown', resumeOnInteraction);
      window.removeEventListener('keydown', resumeOnInteraction);
    }
    window.addEventListener('pointerdown', resumeOnInteraction);
    window.addEventListener('keydown', resumeOnInteraction);
  }
  ensureUserGestureListener();

  // Kick off
  init();

})();
---

