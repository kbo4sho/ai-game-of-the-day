# Game of the Day - 2025-10-20

## Metadata
- **Generated Date:** 2025-10-20
- **Generated Time:** 2025-10-20T00:30:14.378648
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-10-20.js
- **File Size:** 30241 bytes
- **Tokens Used:** 10258

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-10-20.js` - The playable game
- `2025-10-20.meta.json` - Machine-readable metadata
- `2025-10-20.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 20890

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 22460

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Drone Math Catcher
  // Created for ages 7-9. Renders inside element with ID 'game-of-the-day-stage'.
  // Game rules:
  // - Answer 10 questions correctly to WIN.
  // - 3 wrong answers = GAME OVER.
  // - Move the drone with arrow keys or WASD or mouse.
  // - Catch the correct answer bubble.
  // - Press M to mute/unmute audio. Press Enter to restart on end screens.
  // - Click the restart button on end screens to play again.

  // -------------------------
  // Basic setup and constants
  // -------------------------
  const STAGE_ID = "game-of-the-day-stage";
  const WIDTH = 720;
  const HEIGHT = 480;
  const TARGET_CORRECT = 10;
  const MAX_WRONG = 3;
  const PADDING = 10; // UI padding minimum
  const MIN_BODY_FONT = 14;
  const IMPORTANT_FONT = 20; // >=18
  const BG_COLOR = "#E8F6FF";

  // Get container
  const container = document.getElementById(STAGE_ID);
  if (!container) {
    console.error(`Container element with id "${STAGE_ID}" not found.`);
    return;
  }
  container.style.position = "relative";

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.display = "block";
  canvas.style.background = BG_COLOR;
  container.appendChild(canvas);
  const ctx = canvas.getContext("2d");

  // Accessibility: describe the canvas to screen readers
  canvas.setAttribute(
    "role",
    "application"
  );
  canvas.setAttribute(
    "aria-label",
    "Drone math catcher game. Move the drone to catch the bubble with the correct answer. Use arrow keys or WASD. Press M to mute sound."
  );

  // -------------------------
  // Audio setup
  // -------------------------
  let audioCtx = null;
  let masterGain = null;
  let backgroundOsc = null;
  let audioEnabled = true; // toggle with M
  let audioInitAttempted = false;

  function initAudio() {
    if (audioCtx || audioInitAttempted) return;
    audioInitAttempted = true;
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) throw new Error("Web Audio API not supported");
      audioCtx = new AC();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.25;
      masterGain.connect(audioCtx.destination);

      // Gentle background hum using low-frequency oscillator and slight filter
      backgroundOsc = audioCtx.createOscillator();
      backgroundOsc.type = "sine";
      backgroundOsc.frequency.value = 110;
      const bgGain = audioCtx.createGain();
      bgGain.gain.value = 0.02;
      const bgFilter = audioCtx.createBiquadFilter();
      bgFilter.type = "lowpass";
      bgFilter.frequency.value = 300;
      backgroundOsc.connect(bgFilter);
      bgFilter.connect(bgGain);
      bgGain.connect(masterGain);
      backgroundOsc.start();

      if (!audioEnabled) masterGain.gain.value = 0;
    } catch (e) {
      console.warn("Audio initialization failed:", e);
      audioCtx = null;
      audioInitAttempted = true;
      audioEnabled = false;
    }
  }

  // Ensure audio context is resumed after user gesture
  function resumeAudioIfRequired() {
    if (!audioCtx) return;
    if (typeof audioCtx.resume === "function") {
      audioCtx.resume().catch((e) => {
        console.warn("Audio resume failed:", e);
      });
    }
  }

  // Play a short tone sequence for correct answer
  function playCorrectSound() {
    if (!audioCtx || !audioEnabled) return;
    try {
      const now = audioCtx.currentTime;
      const g = audioCtx.createGain();
      g.gain.value = 0;
      g.connect(masterGain);

      const o1 = audioCtx.createOscillator();
      o1.type = "sine";
      o1.frequency.value = 660;
      o1.connect(g);

      const o2 = audioCtx.createOscillator();
      o2.type = "triangle";
      o2.frequency.value = 880;
      o2.connect(g);

      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(0.15, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);

      o1.start(now);
      o2.start(now + 0.03);
      o1.stop(now + 0.35);
      o2.stop(now + 0.35);
    } catch (e) {
      console.warn("playCorrectSound error:", e);
    }
  }

  // Play buzz for incorrect
  function playIncorrectSound() {
    if (!audioCtx || !audioEnabled) return;
    try {
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "square";
      o.frequency.value = 120;
      o.connect(g);
      g.connect(masterGain);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.08, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.3);
      o.start(now);
      o.stop(now + 0.32);
    } catch (e) {
      console.warn("playIncorrectSound error:", e);
    }
  }

  // Visual audio indicator: will draw in UI (muted or not)
  function toggleAudio() {
    audioEnabled = !audioEnabled;
    if (!audioEnabled) {
      if (masterGain) masterGain.gain.value = 0;
    } else {
      if (!audioCtx) initAudio();
      if (masterGain) masterGain.gain.value = 0.25;
      resumeAudioIfRequired();
    }
  }

  // -------------------------
  // Game state
  // -------------------------
  const state = {
    mode: "loading", // 'playing', 'win', 'gameover'
    drone: {
      x: WIDTH / 2,
      y: HEIGHT - 120,
      vx: 0,
      vy: 0,
      speed: 180, // px/s
      radius: 26,
    },
    keys: {
      left: false,
      right: false,
      up: false,
      down: false,
    },
    mouse: {
      x: null,
      y: null,
      active: false,
    },
    question: null,
    bubbles: [], // {x,y,vy,value,isCorrect,id}
    correctCount: 0,
    wrongCount: 0,
    lastSpawn: 0,
    spawnInterval: 1200, // ms
    lastTime: performance.now(),
    feedbackFlash: { color: null, t: 0 }, // for visual feedback
    rngCounter: 0,
  };

  // -------------------------
  // Utility helpers
  // -------------------------
  function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function nowMs() {
    return performance.now();
  }

  function measureTextRect(text, font) {
    ctx.font = font;
    const metrics = ctx.measureText(text);
    const w = Math.ceil(metrics.width);
    // approximate height
    const h = Math.ceil(parseInt(font, 10) || 16);
    return { w, h };
  }

  // -------------------------
  // Math question generator
  // -------------------------
  function generateQuestion() {
    // Randomly choose operation: +, -, × with weights favoring addition/subtraction
    const ops = ["+", "+", "+", "-", "-", "×"];
    const op = ops[randomInt(0, ops.length - 1)];
    let a, b, answer;
    if (op === "+") {
      a = randomInt(1, 20);
      b = randomInt(1, 20);
      answer = a + b;
    } else if (op === "-") {
      a = randomInt(1, 20);
      b = randomInt(1, Math.min(19, a)); // ensure non-negative
      answer = a - b;
    } else {
      a = randomInt(2, 6);
      b = randomInt(2, 6);
      answer = a * b;
    }
    const qText = `${a} ${op} ${b} = ?`;
    // Generate choices including correct answer
    const choices = new Set();
    choices.add(answer);
    while (choices.size < 4) {
      // generate plausible distractors
      const delta = randomInt(1, Math.max(3, Math.floor(Math.abs(answer / 5) + 3)));
      const sign = Math.random() < 0.5 ? -1 : 1;
      let cand = answer + sign * delta;
      if (cand < 0) cand = Math.abs(cand) + 1;
      choices.add(cand);
    }
    const arr = Array.from(choices);
    // shuffle
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return { qText, answer, choices: arr };
  }

  // -------------------------
  // Bubbles spawn management
  // -------------------------
  function spawnBubblesForQuestion(question) {
    const bubbles = [];
    const marginLeft = 60;
    const marginRight = WIDTH - 60;
    const total = question.choices.length;
    const spacing = (marginRight - marginLeft) / (total - 1 || 1);
    for (let i = 0; i < total; i++) {
      const x = marginLeft + spacing * i + randomInt(-20, 20);
      const y = randomInt(120, 220) + randomInt(-40, 40);
      const vy = randomInt(10, 35) / 50; // slow vertical drift
      const val = question.choices[i];
      const isCorrect = val === question.answer;
      bubbles.push({
        id: `${Date.now()}-${i}-${state.rngCounter++}`,
        x,
        y,
        vy,
        value: val,
        isCorrect,
        r: 30 + Math.floor(Math.random() * 6),
      });
    }
    state.bubbles = bubbles;
  }

  // -------------------------
  // Game control functions
  // -------------------------
  function startNewGame() {
    // initialize game variables
    state.mode = "playing";
    state.drone.x = WIDTH / 2;
    state.drone.y = HEIGHT - 120;
    state.drone.vx = 0;
    state.drone.vy = 0;
    state.correctCount = 0;
    state.wrongCount = 0;
    state.feedbackFlash.t = 0;
    state.lastSpawn = nowMs();
    state.spawnInterval = 1200;
    state.bubbles = [];
    state.question = generateQuestion();
    spawnBubblesForQuestion(state.question);
    state.lastTime = performance.now();
    // ensure audio is prepared on first user interaction
    initAudio();
    resumeAudioIfRequired();
    loop();
  }

  function endGame(win) {
    state.mode = win ? "win" : "gameover";
    // stop audio gently (leave background on but lower)
    if (audioCtx && masterGain) {
      // make a short visual/audio cue
      if (!audioEnabled) {
        // nothing
      } else {
        // brief celebratory or sad tone
        if (win) playCorrectSound();
        else playIncorrectSound();
      }
    }
  }

  // -------------------------
  // Input handlers
  // -------------------------
  window.addEventListener("keydown", (e) => {
    // initialize audio on first gesture
    initAudio();
    resumeAudioIfRequired();

    if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") {
      state.keys.left = true;
    } else if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") {
      state.keys.right = true;
    } else if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") {
      state.keys.up = true;
    } else if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") {
      state.keys.down = true;
    } else if (e.key === "m" || e.key === "M") {
      toggleAudio();
    } else if (e.key === "Enter") {
      if (state.mode === "win" || state.mode === "gameover") {
        startNewGame();
      }
    }
  });
  window.addEventListener("keyup", (e) => {
    if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") {
      state.keys.left = false;
    } else if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") {
      state.keys.right = false;
    } else if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") {
      state.keys.up = false;
    } else if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") {
      state.keys.down = false;
    }
  });

  // Mouse move to allow pointer control optional
  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    state.mouse.x = mx;
    state.mouse.y = my;
  });
  canvas.addEventListener("mousedown", (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    // handle click on restart button for end screens
    if (state.mode === "win" || state.mode === "gameover") {
      const btn = restartButtonRect();
      if (mx >= btn.x && mx <= btn.x + btn.w && my >= btn.y && my <= btn.y + btn.h) {
        startNewGame();
        return;
      }
    }
    // also allow clicking bubbles to catch them
    if (state.mode === "playing") {
      // check bubble collisions
      for (const b of state.bubbles.slice()) {
        const dx = b.x - mx;
        const dy = b.y - my;
        if (Math.sqrt(dx * dx + dy * dy) <= b.r + 5) {
          handleBubbleCatch(b);
          break;
        }
      }
    }
  });

  // Restart button rectangle helper
  function restartButtonRect() {
    const font = `${IMPORTANT_FONT}px sans-serif`;
    const text = "Restart";
    ctx.font = font;
    const metrics = ctx.measureText(text);
    const tw = Math.ceil(metrics.width);
    const th = IMPORTANT_FONT;
    const bw = tw + PADDING * 2;
    const bh = th + PADDING * 2;
    const x = WIDTH / 2 - bw / 2;
    const y = HEIGHT / 2 + 40;
    return { x, y, w: bw, h: bh, text, font };
  }

  // -------------------------
  // Game mechanics
  // -------------------------
  function handleBubbleCatch(bubble) {
    // remove bubble
    state.bubbles = state.bubbles.filter((b) => b.id !== bubble.id);
    if (bubble.isCorrect) {
      state.correctCount++;
      state.feedbackFlash.color = "rgba(80,200,120,0.35)";
      state.feedbackFlash.t = nowMs();
      playCorrectSound();
      // if reached target, win
      if (state.correctCount >= TARGET_CORRECT) {
        endGame(true);
        return;
      }
      // next question
      state.question = generateQuestion();
      // spawn choices in a fun arrangement
      spawnBubblesForQuestion(state.question);
    } else {
      state.wrongCount++;
      state.feedbackFlash.color = "rgba(255,80,80,0.35)";
      state.feedbackFlash.t = nowMs();
      playIncorrectSound();
      if (state.wrongCount >= MAX_WRONG) {
        endGame(false);
        return;
      }
      // remove incorrect bubble but keep question unchanged; spawn a new incorrect distractor to replace it after small delay
      setTimeout(() => {
        // only spawn new distractor if still playing
        if (state.mode !== "playing") return;
        const val = bubble.value + (Math.random() < 0.5 ? -2 : 2);
        const newBubble = {
          id: `${Date.now()}-spawn${state.rngCounter++}`,
          x: Math.min(Math.max(60, bubble.x + randomInt(-40, 40)), WIDTH - 60),
          y: Math.min(Math.max(120, bubble.y + randomInt(-20, 20)), HEIGHT - 180),
          vy: randomInt(10, 30) / 50,
          value: val,
          isCorrect: val === state.question.answer,
          r: 28 + Math.floor(Math.random() * 8),
        };
        state.bubbles.push(newBubble);
      }, 700);
    }
  }

  // -------------------------
  // Drawing helpers
  // -------------------------
  function clearCanvas() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    // base calming background with wacky cloud shapes
    ctx.fillStyle = BG_COLOR;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // soft diagonal gradient
    const g = ctx.createLinearGradient(0, 0, WIDTH, HEIGHT);
    g.addColorStop(0, "rgba(232,246,255,0.6)");
    g.addColorStop(1, "rgba(245,255,238,0.7)");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // gentle floating circles as decorative non-distracting elements
    for (let i = 0; i < 20; i++) {
      const x = (i * 97) % WIDTH;
      const y = (i * 53 + (nowMs() / 50)) % HEIGHT;
      ctx.fillStyle = `rgba(200,230,255,0.06)`;
      ctx.beginPath();
      ctx.arc(x, y, 35, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawUI() {
    // Score top-left
    const scoreText = `Correct: ${state.correctCount}/${TARGET_CORRECT}`;
    const scoreFont = `${IMPORTANT_FONT}px sans-serif`;
    ctx.font = scoreFont;
    const scoreMetrics = ctx.measureText(scoreText);
    const scoreW = Math.ceil(scoreMetrics.width);
    const scoreH = IMPORTANT_FONT;
    const scoreX = PADDING;
    const scoreY = PADDING;
    // background rect
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.strokeStyle = "rgba(100,120,140,0.2)";
    ctx.lineWidth = 1;
    const sw = scoreW + PADDING * 2;
    const sh = scoreH + PADDING * 2;
    ctx.fillRect(scoreX, scoreY, sw, sh);
    ctx.strokeRect(scoreX, scoreY, sw, sh);
    // text
    ctx.fillStyle = "#123";
    ctx.font = scoreFont;
    ctx.textBaseline = "top";
    ctx.fillText(scoreText, scoreX + PADDING, scoreY + PADDING);

    // Lives top-right
    const livesText = `Wrong allowed: ${MAX_WRONG - state.wrongCount}`;
    ctx.font = `${IMPORTANT_FONT}px sans-serif`;
    const livesMetrics = ctx.measureText(livesText);
    const lw = Math.ceil(livesMetrics.width);
    const lh = IMPORTANT_FONT;
    const livesX = WIDTH - PADDING - (lw + PADDING * 2);
    const livesY = PADDING;
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.fillRect(livesX, livesY, lw + PADDING * 2, lh + PADDING * 2);
    ctx.strokeStyle = "rgba(100,120,140,0.2)";
    ctx.strokeRect(livesX, livesY, lw + PADDING * 2, lh + PADDING * 2);
    ctx.fillStyle = "#123";
    ctx.fillText(livesText, livesX + PADDING, livesY + PADDING);

    // Audio indicator near lives (small)
    const audioText = audioEnabled ? "🔊" : "🔇";
    const audioFont = `${MIN_BODY_FONT}px sans-serif`;
    ctx.font = audioFont;
    const audMetrics = ctx.measureText(audioText);
    const aw = Math.ceil(audMetrics.width);
    const ah = MIN_BODY_FONT;
    const apad = 6;
    const ax = livesX - apad - aw - 6;
    const ay = livesY + (lh + PADDING * 2 - ah) / 2;
    // background for icon
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.fillRect(ax - apad, ay - 4, aw + apad * 2, ah + 8);
    ctx.fillStyle = "#123";
    ctx.fillText(audioText, ax, ay);

    // Question top-center
    const qFont = `${IMPORTANT_FONT + 4}px sans-serif`;
    ctx.font = qFont;
    const qText = state.question ? state.question.qText : "Loading...";
    const qMetrics = ctx.measureText(qText);
    const qw = Math.ceil(qMetrics.width);
    const qh = IMPORTANT_FONT + 4;
    const qx = WIDTH / 2 - qw / 2;
    const qy = 60 - qh / 2;
    // background rectangle centered
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.fillRect(qx - PADDING, qy - PADDING, qw + PADDING * 2, qh + PADDING * 2);
    ctx.strokeStyle = "rgba(80,120,150,0.12)";
    ctx.strokeRect(qx - PADDING, qy - PADDING, qw + PADDING * 2, qh + PADDING * 2);
    ctx.fillStyle = "#0B3";
    ctx.font = qFont;
    ctx.fillText(qText, qx, qy);

    // Instructions bottom-center (multi-line)
    const instructions = [
      "Move: Arrow keys or WASD. Click or touch a bubble to catch it.",
      "Press M to mute/unmute sound. Press Enter to restart after game ends.",
    ];
    ctx.font = `${MIN_BODY_FONT}px sans-serif`;
    const lineHeight = MIN_BODY_FONT + 6;
    // compute width as max of lines
    let maxW = 0;
    for (const line of instructions) {
      const m = ctx.measureText(line);
      maxW = Math.max(maxW, Math.ceil(m.width));
    }
    const instrW = maxW + PADDING * 2;
    const instrH = instructions.length * lineHeight + PADDING * 2;
    const instrX = WIDTH / 2 - instrW / 2;
    const instrY = HEIGHT - instrH - 12;
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.fillRect(instrX, instrY, instrW, instrH);
    ctx.strokeStyle = "rgba(100,120,140,0.08)";
    ctx.strokeRect(instrX, instrY, instrW, instrH);
    ctx.fillStyle = "#044";
    for (let i = 0; i < instructions.length; i++) {
      ctx.fillText(instructions[i], instrX + PADDING, instrY + PADDING + i * lineHeight);
    }
  }

  function drawDrone(drone, t = 0) {
    const { x, y, radius } = drone;
    // Drone body
    ctx.save();
    ctx.translate(x, y);

    // subtle shadow
    ctx.beginPath();
    ctx.ellipse(0, radius + 12, radius * 0.9, radius * 0.35, 0, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(20,20,30,0.08)";
    ctx.fill();

    // body rectangle (wacky)
    ctx.fillStyle = "#ffd66b";
    ctx.strokeStyle = "#ab8a3f";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect = function (x, y, w, h, r) {
      // utility
      this.moveTo(x + r, y);
      this.arcTo(x + w, y, x + w, y + h, r);
      this.arcTo(x + w, y + h, x, y + h, r);
      this.arcTo(x, y + h, x, y, r);
      this.arcTo(x, y, x + w, y, r);
    };
    ctx.beginPath();
    ctx.roundRect(-radius * 1.1, -radius * 0.6, radius * 2.2, radius * 1.2, 8);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // little face
    ctx.fillStyle = "#5b3";
    ctx.beginPath();
    ctx.arc(-8, 0, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(12, 0, 6, 0, Math.PI * 2);
    ctx.fill();

    // propellers (wacky, slightly animated)
    const spin = (t / 200) % (Math.PI * 2);
    function drawProp(cx, cy) {
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(spin);
      ctx.fillStyle = "rgba(80,100,130,0.9)";
      ctx.beginPath();
      ctx.ellipse(0, -8, 28, 7, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(0, 8, 28, 7, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
    drawProp(-radius * 1.6, -radius * 0.8);
    drawProp(radius * 1.6, -radius * 0.8);
    drawProp(-radius * 1.6, radius * 0.7);
    drawProp(radius * 1.6, radius * 0.7);

    ctx.restore();
  }

  function drawBubbles(bubbles) {
    for (const b of bubbles) {
      // bubble shadow
      ctx.beginPath();
      ctx.ellipse(b.x + 6, b.y + 8, b.r * 0.9, b.r * 0.6, 0, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(20,20,20,0.06)";
      ctx.fill();

      // bubble body with gradient
      const g = ctx.createLinearGradient(b.x - b.r, b.y - b.r, b.x + b.r, b.y + b.r);
      g.addColorStop(0, "rgba(255,255,255,0.95)");
      g.addColorStop(1, b.isCorrect ? "rgba(130,220,160,1)" : "rgba(180,200,255,1)");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.fill();

      // shiny highlight
      ctx.fillStyle = "rgba(255,255,255,0.55)";
      ctx.beginPath();
      ctx.ellipse(b.x - b.r * 0.35, b.y - b.r * 0.45, b.r * 0.4, b.r * 0.25, 0, 0, Math.PI * 2);
      ctx.fill();

      // number
      ctx.fillStyle = "#072";
      ctx.font = `bold ${Math.max(18, Math.floor(b.r / 1.5))}px sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(b.value), b.x, b.y);
    }
    ctx.textAlign = "start";
  }

  // -------------------------
  // Main loop
  // -------------------------
  function loop() {
    if (state.mode !== "playing") {
      // still draw a single frame to show end state maybe
      draw();
      return;
    }
    const t0 = nowMs();
    const dt = Math.min(100, t0 - state.lastTime);
    update(dt / 1000);
    draw();
    state.lastTime = t0;
    requestAnimationFrame(loop);
  }

  function update(dt) {
    const d = state.drone;
    // input movement
    let moveX = 0;
    let moveY = 0;
    if (state.keys.left) moveX -= 1;
    if (state.keys.right) moveX += 1;
    if (state.keys.up) moveY -= 1;
    if (state.keys.down) moveY += 1;
    // if mouse is active, move toward mouse gently
    if (state.mouse.x !== null && state.mouse.y !== null && !state.keys.left && !state.keys.right && !state.keys.up && !state.keys.down) {
      // allow mouse to drag drone
      const dx = state.mouse.x - d.x;
      const dy = state.mouse.y - d.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist > 8) {
        moveX = dx / dist;
        moveY = dy / dist;
      }
    }

    // normalize
    if (moveX !== 0 || moveY !== 0) {
      const len = Math.sqrt(moveX * moveX + moveY * moveY);
      moveX /= len;
      moveY /= len;
      d.x += moveX * d.speed * dt;
      d.y += moveY * d.speed * dt;
    } else {
      // slight drift to give wacky feel
      d.x += Math.sin(nowMs() / 600) * 0.2;
      d.y += Math.cos(nowMs() / 700) * 0.15;
    }

    // clamp
    d.x = Math.max(30, Math.min(WIDTH - 30, d.x));
    d.y = Math.max(80, Math.min(HEIGHT - 140, d.y));

    // update bubbles: gentle floating
    for (const b of state.bubbles) {
      b.y += b.vy;
      b.x += Math.sin((nowMs() + b.x) / 1200) * 0.4;
      // wrap around top/bottom if floats too far
      if (b.y > HEIGHT - 120) b.y = 120 + Math.random() * 40;
      if (b.y < 100) b.y = 100 + Math.random() * 60;
    }

    // collision detection
    for (const b of state.bubbles.slice()) {
      const dx = b.x - d.x;
      const dy = b.y - d.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist <= b.r + d.radius * 0.6) {
        handleBubbleCatch(b);
      }
    }

    // feedback flash fade
    if (state.feedbackFlash.t > 0) {
      if (nowMs() - state.feedbackFlash.t > 400) {
        state.feedbackFlash.t = 0;
      }
    }
  }

  function draw() {
    clearCanvas();

    // optional feedback overlay
    if (state.feedbackFlash.t > 0) {
      ctx.fillStyle = state.feedbackFlash.color;
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
    }

    // Draw bubbles behind drone for depth effect
    drawBubbles(state.bubbles);

    // draw drone with animation timestamp
    drawDrone(state.drone, nowMs());

    // draw UI overlays on top
    drawUI();

    // draw game state end screens
    if (state.mode === "win") {
      drawEndScreen(true);
    } else if (state.mode === "gameover") {
      drawEndScreen(false);
    }
  }

  function drawEndScreen(win) {
    // dim panel
    ctx.fillStyle = "rgba(10,10,20,0.35)";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // central panel
    const title = win ? "You Win! Drone delivered the packages!" : "Game Over. Drone needs a recharge.";
    const subtitle = win ? `You answered ${state.correctCount} questions correctly!` : `You made ${state.wrongCount} wrong answers.`;
    const titleFont = `${IMPORTANT_FONT + 6}px sans-serif`;
    const subFont = `${MIN_BODY_FONT + 2}px sans-serif`;

    // measure
    ctx.font = titleFont;
    const tmetrics = ctx.measureText(title);
    const tw = Math.ceil(tmetrics.width);
    ctx.font = subFont;
    const smetrics = ctx.measureText(subtitle);
    const sw = Math.ceil(smetrics.width);
    const panelW = Math.max(tw, sw) + PADDING * 4;
    const panelH = 120;
    const px = WIDTH / 2 - panelW / 2;
    const py = HEIGHT / 2 - panelH / 2 - 40;
    ctx.fillStyle = "rgba(255,255,255,0.98)";
    ctx.fillRect(px, py, panelW, panelH);
    ctx.strokeStyle = "rgba(80,120,140,0.12)";
    ctx.strokeRect(px, py, panelW, panelH);

    // title
    ctx.fillStyle = win ? "#0A6" : "#B33";
    ctx.font = titleFont;
    ctx.fillText(title, px + PADDING * 2, py + PADDING * 2);

    // subtitle
    ctx.fillStyle = "#123";
    ctx.font = subFont;
    ctx.fillText(subtitle, px + PADDING * 2, py + PADDING * 2 + (IMPORTANT_FONT + 10));

    // restart button
    const btn = restartButtonRect();
    ctx.fillStyle = "#64b5f6";
    ctx.strokeStyle = "#2b6a9a";
    ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
    ctx.strokeRect(btn.x, btn.y, btn.w, btn.h);
    ctx.fillStyle = "#012";
    ctx.font = btn.font;
    ctx.fillText(btn.text, btn.x + PADDING, btn.y + PADDING);

    // instruction to press Enter
    ctx.font = `${MIN_BODY_FONT}px sans-serif`;
    ctx.fillStyle = "#fff";
    const msg = "Press Enter or click Restart to play again";
    const mm = ctx.measureText(msg);
    ctx.fillText(msg, WIDTH / 2 - mm.width / 2, btn.y + btn.h + 28);
  }

  // -------------------------
  // Start / Loading
  // -------------------------
  // Draw initial instructions and wait for user to click to start (and to allow audio init)
  function drawLoadingScreen() {
    clearCanvas();
    ctx.fillStyle = "#fff";
    const title = "Drone Math Catcher";
    const fontTitle = "28px sans-serif";
    ctx.font = fontTitle;
    const tmetrics = ctx.measureText(title);
    ctx.fillStyle = "#123";
    ctx.fillText(title, WIDTH / 2 - tmetrics.width / 2, HEIGHT / 2 - 80);

    // small image-like drone drawn
    drawDrone({ x: WIDTH / 2, y: HEIGHT / 2 - 10, radius: 30 }, nowMs());

    // instructions
    const lines = [
      "Catch the bubble with the correct answer to the question.",
      `Get ${TARGET_CORRECT} correct answers to win. ${MAX_WRONG} wrongs and it's game over.`,
      "Click to begin. Press M to mute/unmute sound anytime.",
    ];
    ctx.font = `${MIN_BODY_FONT}px sans-serif`;
    ctx.fillStyle = "#044";
    for (let i = 0; i < lines.length; i++) {
      const m = ctx.measureText(lines[i]);
      ctx.fillText(lines[i], WIDTH / 2 - m.width / 2, HEIGHT / 2 + 60 + i * 22);
    }

    // button
    const btnText = "Start Game";
    const btnFont = `${IMPORTANT_FONT}px sans-serif`;
    ctx.font = btnFont;
    const bm = ctx.measureText(btnText);
    const bw = Math.ceil(bm.width) + PADDING * 2;
    const bh = IMPORTANT_FONT + PADDING * 2;
    const bx = WIDTH / 2 - bw / 2;
    const by = HEIGHT / 2 + 120;
    ctx.fillStyle = "#fdd835";
    ctx.fillRect(bx, by, bw, bh);
    ctx.strokeStyle = "#b58a06";
    ctx.strokeRect(bx, by, bw, bh);
    ctx.fillStyle = "#012";
    ctx.fillText(btnText, bx + PADDING, by + PADDING);
    // click handler for start
    canvas.addEventListener(
      "click",
      function onStartClick(e) {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        if (mx >= bx && mx <= bx + bw && my >= by && my <= by + bh) {
          canvas.removeEventListener("click", onStartClick);
          startNewGame();
        } else {
          // allow clicking anywhere to start too
          canvas.removeEventListener("click", onStartClick);
          startNewGame();
        }
      },
      { once: true }
    );
  }

  // Custom rounding helper for canvas path (polyfill)
  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
      if (w < 2 * r) r = w / 2;
      if (h < 2 * r) r = h / 2;
      this.beginPath();
      this.moveTo(x + r, y);
      this.arcTo(x + w, y, x + w, y + h, r);
      this.arcTo(x + w, y + h, x, y + h, r);
      this.arcTo(x, y + h, x, y, r);
      this.arcTo(x, y, x + w, y, r);
      this.closePath();
      return this;
    };
  }

  // Kick off loading screen
  state.mode = "loading";
  drawLoadingScreen();

  // Expose for accessibility - simple keyboard instruction in case canvas not accessible
  // (We won't add external DOM elements as per requirement; this is just a fallback log.)
  console.info("Drone Math Catcher ready. Focus the page and press Start.");

  // Accessibility: allow resizing of fonts if user changes system settings - canvas won't adapt but we keep sizes readable.

})();
---

