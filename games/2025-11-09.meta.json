{
  "generated_date": "2025-11-09",
  "generated_timestamp": "2025-11-09T00:30:31.508328",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 10038,
  "game_filename": "2025-11-09.js",
  "game_size_bytes": 28101,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Drone Math Quest - JavaScript game\n// Renders inside element with id \"game-of-the-day-stage\"\n// Creates a 720x480 canvas and runs the game\n\n(function () {\n  // Ensure stage element exists\n  const stage = document.getElementById(\"game-of-the-day-stage\");\n  if (!stage) {\n    console.error(\"Missing container element with id 'game-of-the-day-stage'.\");\n    return;\n  }\n\n  // Clear stage and create canvas\n  stage.innerHTML = \"\";\n  stage.style.position = stage.style.position || \"relative\";\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 720;\n  canvas.height = 480;\n  canvas.style.width = \"720px\";\n  canvas.style.height = \"480px\";\n  canvas.setAttribute(\"role\", \"img\");\n  canvas.setAttribute(\"aria-label\", \"Drone Math Quest game canvas\");\n  stage.appendChild(canvas);\n\n  // Create an offscreen accessible status region for screen readers\n  const a11yStatus = document.createElement(\"div\");\n  a11yStatus.setAttribute(\"role\", \"status\");\n  a11yStatus.setAttribute(\"aria-live\", \"polite\");\n  // visually hide but keep in DOM\n  Object.assign(a11yStatus.style, {\n    position: \"absolute\",\n    left: \"-9999px\",\n    width: \"1px\",\n    height: \"1px\",\n    overflow: \"hidden\",\n  });\n  stage.appendChild(a11yStatus);\n\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    console.error(\"2D context not available.\");\n    return;\n  }\n\n  // Audio setup with error handling\n  let audioCtx = null;\n  let audioEnabled = false;\n  let bgGain = null;\n  let bgOsc = null;\n  try {\n    const AudioContext = window.AudioContext || window.webkitAudioContext;\n    if (AudioContext) {\n      audioCtx = new AudioContext();\n      // start suspended to respect autoplay policies; resume on user gesture\n      if (audioCtx.state === \"running\") {\n        audioEnabled = true;\n      } else {\n        audioEnabled = false;\n      }\n    } else {\n      console.warn(\"Web Audio API not supported in this browser.\");\n      audioCtx = null;\n    }\n  } catch (err) {\n    console.warn(\"Error creating AudioContext:\", err);\n    audioCtx = null;\n  }\n\n  // Helper to safely resume audio context on user interaction\n  async function ensureAudioRunning() {\n    if (!audioCtx) return false;\n    try {\n      if (audioCtx.state !== \"running\") {\n        await audioCtx.resume();\n      }\n      audioEnabled = true;\n      // start gentle background hum if not present\n      startBackgroundHum();\n      return true;\n    } catch (err) {\n      console.warn(\"Audio context resume failed:\", err);\n      audioEnabled = false;\n      return false;\n    }\n  }\n\n  // Create gentle background hum using oscillator + slow LFO on gain\n  function startBackgroundHum() {\n    if (!audioCtx) return;\n    try {\n      stopBackgroundHum();\n      bgOsc = audioCtx.createOscillator();\n      bgOsc.type = \"sine\";\n      bgOsc.frequency.value = 120; // base frequency (hum-ish)\n\n      bgGain = audioCtx.createGain();\n      bgGain.gain.value = 0.01; // very gentle\n\n      // Create LFO to modulate gain slowly\n      const lfo = audioCtx.createOscillator();\n      lfo.frequency.value = 0.2; // slow pulse\n      const lfoGain = audioCtx.createGain();\n      lfoGain.gain.value = 0.008;\n\n      lfo.connect(lfoGain).connect(bgGain.gain);\n\n      bgOsc.connect(bgGain).connect(audioCtx.destination);\n\n      bgOsc.start();\n      lfo.start();\n\n      // Keep references so we can stop them later\n      bgOsc._lfo = lfo;\n      bgOsc._lfoGain = lfoGain;\n    } catch (err) {\n      console.warn(\"Error starting background hum:\", err);\n    }\n  }\n\n  function stopBackgroundHum() {\n    if (!bgOsc) return;\n    try {\n      if (bgOsc._lfo) {\n        try {\n          bgOsc._lfo.stop();\n          bgOsc._lfo.disconnect();\n        } catch (e) {}\n      }\n      try {\n        bgOsc.stop();\n      } catch (e) {}\n      bgOsc.disconnect();\n    } catch (err) {\n      // ignore\n    }\n    bgOsc = null;\n    bgGain = null;\n  }\n\n  // Play short beep for correct/incorrect using oscillators, plus filter for timbre\n  function playBeep({ pitch = 800, duration = 0.12, type = \"sine\", volume = 0.08 }) {\n    if (!audioCtx || !audioEnabled) return;\n    try {\n      const osc = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n      const filter = audioCtx.createBiquadFilter();\n      filter.type = \"lowpass\";\n      filter.frequency.value = 3000;\n\n      osc.type = type;\n      osc.frequency.value = pitch;\n\n      gain.gain.value = volume;\n\n      osc.connect(filter);\n      filter.connect(gain);\n      gain.connect(audioCtx.destination);\n\n      const now = audioCtx.currentTime;\n      gain.gain.setValueAtTime(volume, now);\n      gain.gain.exponentialRampToValueAtTime(0.001, now + duration);\n\n      osc.start(now);\n      osc.stop(now + duration + 0.02);\n    } catch (err) {\n      console.warn(\"playBeep error:\", err);\n    }\n  }\n\n  function playCorrectSound() {\n    // Triad quick arpeggio\n    playBeep({ pitch: 900, duration: 0.12, type: \"triangle\", volume: 0.08 });\n    setTimeout(() => playBeep({ pitch: 1200, duration: 0.09, type: \"sine\", volume: 0.07 }), 120);\n    setTimeout(() => playBeep({ pitch: 1500, duration: 0.08, type: \"sine\", volume: 0.06 }), 220);\n  }\n\n  function playWrongSound() {\n    playBeep({ pitch: 220, duration: 0.2, type: \"square\", volume: 0.09 });\n  }\n\n  // Game constants and state\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const UI_PADDING = 10;\n  const SCORE_GOAL = 10;\n  const ALLOWED_WRONG = 3;\n  const FONT_BODY = \"16px sans-serif\"; // >=14\n  const FONT_IMPORTANT = \"20px sans-serif\"; // >=18\n\n  let score = 0;\n  let wrongCount = 0;\n  let currentQuestion = null;\n  let choices = [];\n  let selectedIndex = 0;\n  let gameState = \"intro\"; // intro, playing, victory, gameover\n  let drone = {\n    x: WIDTH / 2,\n    y: 150,\n    w: 120,\n    h: 50,\n    bobPhase: 0,\n    targetX: WIDTH / 2,\n    wobble: 0,\n  };\n  let stars = []; // animated collected stars\n  let lastTime = performance.now();\n\n  // UI elements detection (buttons)\n  const restartButton = {\n    x: WIDTH / 2 - 90,\n    y: HEIGHT / 2 + 60,\n    w: 180,\n    h: 44,\n  };\n  const soundButton = {\n    x: WIDTH - 10 - 36,\n    y: 10,\n    w: 36,\n    h: 36,\n  };\n\n  // Generate a new arithmetic question appropriate for ages 7-9\n  function generateQuestion() {\n    // Mix of addition and subtraction, numbers 0..20 appropriate\n    const ops = [\"+\"];\n    // Include subtraction sometimes to vary\n    if (Math.random() < 0.4) ops.push(\"-\");\n    const op = ops[Math.floor(Math.random() * ops.length)];\n    let a, b, answer;\n    if (op === \"+\") {\n      a = Math.floor(Math.random() * 12) + 1; // 1..12\n      b = Math.floor(Math.random() * 9) + 0; // 0..8\n      answer = a + b;\n    } else {\n      a = Math.floor(Math.random() * 12) + 5; // ensure positive result\n      b = Math.floor(Math.random() * 5); // 0..4\n      answer = a - b;\n    }\n\n    // Build 4 choices including answer and three distractors\n    const optionSet = new Set();\n    optionSet.add(answer);\n    while (optionSet.size < 4) {\n      const delta = Math.floor(Math.random() * 7) - 3; // -3..3\n      let candidate = answer + delta;\n      if (candidate < 0) candidate = Math.abs(candidate + 2);\n      // Avoid duplicate\n      if (optionSet.has(candidate)) {\n        candidate = answer + (Math.floor(Math.random() * 7) + 2);\n      }\n      optionSet.add(candidate);\n    }\n    const optionList = Array.from(optionSet);\n    // Shuffle options\n    for (let i = optionList.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [optionList[i], optionList[j]] = [optionList[j], optionList[i]];\n    }\n\n    currentQuestion = {\n      a,\n      b,\n      op,\n      answer,\n      text: `${a} ${op} ${b} = ?`,\n    };\n    choices = optionList;\n    selectedIndex = 0;\n    a11yStatus.textContent = `New question: ${currentQuestion.text}. Options: ${choices.join(\", \")}. Press 1 to 4 to choose.`;\n  }\n\n  // UI helpers: draw rounded rect\n  function drawRoundedRect(x, y, w, h, r, fillStyle) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fillStyle = fillStyle;\n    ctx.fill();\n  }\n\n  // Draw drone using canvas shapes\n  function drawDrone(dt) {\n    // bobbing motion\n    drone.bobPhase += dt * 0.005;\n    const bob = Math.sin(drone.bobPhase * 2) * 6;\n    drone.wobble = Math.sin(drone.bobPhase * 4) * 6;\n\n    // slide toward targetX a bit\n    drone.x += (drone.targetX - drone.x) * 0.02;\n\n    const cx = drone.x;\n    const cy = drone.y + bob;\n\n    // body\n    ctx.save();\n    ctx.translate(cx, cy);\n    // shadow\n    ctx.beginPath();\n    ctx.ellipse(0, drone.h / 2 + 22, 56, 10, 0, 0, Math.PI * 2);\n    ctx.fillStyle = \"rgba(0,0,0,0.12)\";\n    ctx.fill();\n\n    // main body\n    ctx.fillStyle = \"#88C0D0\"; // calm teal\n    ctx.beginPath();\n    ctx.ellipse(0, 0, drone.w / 2, drone.h / 2, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // canopy\n    ctx.fillStyle = \"#5E81AC\";\n    ctx.beginPath();\n    ctx.ellipse(-12, -6, 44, 26, -0.2, 0, Math.PI * 2);\n    ctx.fill();\n\n    // propellers - four small circles with little blades\n    const props = [\n      [-drone.w / 2 + 12, -drone.h / 2 - 8],\n      [drone.w / 2 - 12, -drone.h / 2 - 8],\n      [-drone.w / 2 + 12, drone.h / 2 + 4],\n      [drone.w / 2 - 12, drone.h / 2 + 4],\n    ];\n    for (let i = 0; i < props.length; i++) {\n      const [px, py] = props[i];\n      ctx.save();\n      ctx.translate(px, py);\n      ctx.rotate((drone.bobPhase * (i % 2 ? -1 : 1)) * 6);\n      // blades\n      ctx.fillStyle = \"rgba(0,0,0,0.12)\";\n      for (let b = 0; b < 3; b++) {\n        ctx.rotate((Math.PI * 2) / 3);\n        ctx.fillRect(0, -2, 28, 4);\n      }\n      // center\n      ctx.beginPath();\n      ctx.arc(0, 0, 6, 0, Math.PI * 2);\n      ctx.fillStyle = \"#2E3440\";\n      ctx.fill();\n      ctx.restore();\n    }\n\n    // package under the drone (math crate)\n    ctx.fillStyle = \"#D08770\";\n    ctx.fillRect(-22, 22, 44, 28);\n    // math symbol on box\n    ctx.fillStyle = \"#2E3440\";\n    ctx.font = \"bold 18px sans-serif\";\n    const symbol = \"?\";\n    const w = ctx.measureText(symbol).width;\n    ctx.fillText(symbol, -w / 2, 22 + 18);\n\n    // speech bubble with question\n    const bubbleText = currentQuestion ? currentQuestion.text : \"Click to start\";\n    ctx.font = FONT_IMPORTANT;\n    const metrics = ctx.measureText(bubbleText);\n    const bw = metrics.width + 20;\n    const bh = 36;\n    const bx = -bw / 2;\n    const by = -drone.h / 2 - bh - 12;\n    // bubble background\n    drawRoundedRect(cx + bx, cy + by, bw, bh, 8, \"rgba(255,255,255,0.95)\");\n    // outline\n    ctx.strokeStyle = \"rgba(0,0,0,0.06)\";\n    ctx.lineWidth = 1;\n    ctx.strokeRect(cx + bx, cy + by, bw, bh);\n    // text\n    ctx.fillStyle = \"#2E3440\";\n    ctx.fillText(bubbleText, cx + bx + 10, cy + by + 24);\n\n    ctx.restore();\n  }\n\n  // Draw choices as round power-cells at bottom\n  function drawChoices() {\n    const bottomY = HEIGHT - 100;\n    const cellRadius = 36;\n    const spacing = 18;\n    const totalWidth = choices.length * (cellRadius * 2) + (choices.length - 1) * spacing;\n    let startX = (WIDTH - totalWidth) / 2 + cellRadius;\n\n    ctx.font = \"16px sans-serif\";\n    for (let i = 0; i < choices.length; i++) {\n      const x = startX + i * (2 * cellRadius + spacing);\n      const y = bottomY;\n      // background circle\n      ctx.beginPath();\n      ctx.arc(x, y, cellRadius + 6, 0, Math.PI * 2);\n      ctx.fillStyle = selectedIndex === i ? \"rgba(232, 145, 85, 0.12)\" : \"rgba(255,255,255,0.0)\";\n      ctx.fill();\n\n      // ring\n      ctx.beginPath();\n      ctx.arc(x, y, cellRadius, 0, Math.PI * 2);\n      ctx.fillStyle = \"#ECEFF4\";\n      ctx.fill();\n      ctx.lineWidth = 2;\n      ctx.strokeStyle = \"#D8DEE9\";\n      ctx.stroke();\n\n      // number label (1..4) small\n      ctx.fillStyle = \"#4C566A\";\n      ctx.font = \"12px sans-serif\";\n      const idxLabel = `${i + 1}`;\n      ctx.fillText(idxLabel, x - cellRadius + 6, y - cellRadius + 14);\n\n      // actual choice value\n      ctx.fillStyle = \"#2E3440\";\n      ctx.font = \"18px sans-serif\";\n      const text = String(choices[i]);\n      const tw = ctx.measureText(text).width;\n      ctx.fillText(text, x - tw / 2, y + 6);\n    }\n  }\n\n  // Draw top UI (score, goal) ensuring no overlap with padding and using measureText\n  function drawTopUI() {\n    // Score top-left\n    ctx.font = FONT_IMPORTANT;\n    const scoreText = `Score: ${score}/${SCORE_GOAL}`;\n    const scoreMetrics = ctx.measureText(scoreText);\n    const scoreW = scoreMetrics.width + 20;\n    const scoreH = 36;\n    const scoreX = UI_PADDING;\n    const scoreY = UI_PADDING;\n    drawRoundedRect(scoreX, scoreY, scoreW, scoreH, 8, \"rgba(255,255,255,0.92)\");\n    ctx.fillStyle = \"#2E3440\";\n    ctx.fillText(scoreText, scoreX + 10, scoreY + 24);\n\n    // Lives top-right\n    ctx.font = FONT_IMPORTANT;\n    const livesText = `X ${ALLOWED_WRONG - wrongCount} lives`;\n    const livesMetrics = ctx.measureText(livesText);\n    const livesW = livesMetrics.width + 20;\n    const livesH = 36;\n    const livesX = WIDTH - UI_PADDING - livesW - soundButton.w - 12; // leave space for sound button\n    const livesY = UI_PADDING;\n    drawRoundedRect(livesX, livesY, livesW, livesH, 8, \"rgba(255,255,255,0.92)\");\n    ctx.fillStyle = \"#2E3440\";\n    ctx.fillText(livesText, livesX + 10, livesY + 24);\n\n    // Goal text center-top\n    ctx.font = \"18px sans-serif\";\n    const goalText = `Collect ${SCORE_GOAL} stars to win`;\n    const goalMetrics = ctx.measureText(goalText);\n    const goalW = goalMetrics.width + 20;\n    const goalH = 32;\n    const goalX = (WIDTH - goalW) / 2;\n    const goalY = UI_PADDING + 2;\n    drawRoundedRect(goalX, goalY, goalW, goalH, 8, \"rgba(255,255,255,0.92)\");\n    ctx.fillStyle = \"#2E3440\";\n    ctx.fillText(goalText, goalX + 10, goalY + 22);\n\n    // Sound button top-right\n    ctx.save();\n    const sb = soundButton;\n    // draw background circle\n    drawRoundedRect(sb.x, sb.y, sb.w, sb.h, 8, \"rgba(255,255,255,0.92)\");\n    // speaker icon\n    ctx.fillStyle = audioEnabled ? \"#88C0D0\" : \"#D08770\";\n    ctx.translate(sb.x + sb.w / 2, sb.y + sb.h / 2);\n    // speaker box\n    ctx.beginPath();\n    ctx.moveTo(-8, -6);\n    ctx.lineTo(-2, -6);\n    ctx.lineTo(6, -12);\n    ctx.lineTo(6, 12);\n    ctx.lineTo(-2, 6);\n    ctx.lineTo(-8, 6);\n    ctx.closePath();\n    ctx.fill();\n    // waves if enabled\n    if (audioEnabled) {\n      ctx.beginPath();\n      ctx.arc(10, -2, 5, -0.8, 0.8);\n      ctx.strokeStyle = \"#88C0D0\";\n      ctx.lineWidth = 2;\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.arc(12, -2, 9, -0.8, 0.8);\n      ctx.stroke();\n    } else {\n      // draw small X\n      ctx.strokeStyle = \"#D08770\";\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(8, -8);\n      ctx.lineTo(14, -2);\n      ctx.moveTo(8, -2);\n      ctx.lineTo(14, -8);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  // Draw instructions bottom center with background and spacing\n  function drawInstructions() {\n    ctx.font = FONT_BODY;\n    const lines = [\n      \"How to play: Solve the math shown on the drone. Choose the correct power-cell.\",\n      \"Keyboard: 1-4 select, Left/Right to change, Enter to confirm, R to restart, M to toggle audio.\",\n      \"Goal: Get 10 correct answers. Lose after 3 wrong answers.\",\n      audioCtx ? \"Click anywhere to enable audio if sound is off.\" : \"Audio unavailable in this browser.\",\n    ];\n    const padding = 10;\n    // compute width of the longest line\n    let maxW = 0;\n    ctx.font = FONT_BODY;\n    for (const line of lines) {\n      const w = ctx.measureText(line).width;\n      if (w > maxW) maxW = w;\n    }\n    const boxW = maxW + padding * 2;\n    const boxH = lines.length * 20 + padding * 2;\n    const boxX = (WIDTH - boxW) / 2;\n    const boxY = HEIGHT - boxH - 10;\n    drawRoundedRect(boxX, boxY, boxW, boxH, 8, \"rgba(255,255,255,0.92)\");\n    ctx.fillStyle = \"#4C566A\";\n    ctx.font = FONT_BODY;\n    for (let i = 0; i < lines.length; i++) {\n      ctx.fillText(lines[i], boxX + padding, boxY + padding + 16 + i * 20);\n    }\n  }\n\n  // Draw animated stars that fly to score area upon correct answer\n  function updateAndDrawStars(dt) {\n    for (let i = stars.length - 1; i >= 0; i--) {\n      const s = stars[i];\n      // simple physics toward target\n      s.vx += (s.tx - s.x) * 0.004 * dt;\n      s.vy += (s.ty - s.y) * 0.004 * dt + 0.001 * dt;\n      s.x += s.vx * dt * 0.001;\n      s.y += s.vy * dt * 0.001;\n      s.angle += 0.06 * dt * 0.001;\n\n      // draw star shape\n      ctx.save();\n      ctx.translate(s.x, s.y);\n      ctx.rotate(s.angle);\n      ctx.fillStyle = s.color;\n      ctx.beginPath();\n      const rOut = 10;\n      const rIn = 4;\n      for (let k = 0; k < 10; k++) {\n        const r = k % 2 === 0 ? rOut : rIn;\n        const a = (k * Math.PI) / 5;\n        ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);\n      }\n      ctx.closePath();\n      ctx.fill();\n      ctx.restore();\n\n      // remove if near target\n      if (Math.hypot(s.x - s.tx, s.y - s.ty) < 8) {\n        stars.splice(i, 1);\n      }\n    }\n  }\n\n  // Handle correct answer event\n  function handleCorrect(xy) {\n    score++;\n    a11yStatus.textContent = `Correct! Score ${score} of ${SCORE_GOAL}.`;\n    // spawn a star at xy that moves to score UI\n    const scorePosX = UI_PADDING + 40;\n    const scorePosY = UI_PADDING + 18;\n    const s = {\n      x: xy ? xy.x : drone.x,\n      y: xy ? xy.y : drone.y + 40,\n      tx: scorePosX,\n      ty: scorePosY,\n      vx: (Math.random() - 0.5) * 0.5,\n      vy: -Math.random() * 0.5 - 0.2,\n      angle: Math.random() * Math.PI,\n      color: \"#EBCB8B\",\n    };\n    stars.push(s);\n    try {\n      playCorrectSound();\n    } catch (err) {\n      console.warn(\"Error playing correct sound:\", err);\n    }\n\n    // Small drone bounce animation\n    drone.targetX = Math.random() * (WIDTH - 200) + 100;\n\n    // Check victory\n    if (score >= SCORE_GOAL) {\n      gameState = \"victory\";\n      stopBackgroundHum();\n      a11yStatus.textContent = `Victory! You collected ${score} stars. Press R to restart.`;\n    } else {\n      // new question after a brief delay\n      setTimeout(() => {\n        generateQuestion();\n      }, 700);\n    }\n  }\n\n  // Handle wrong answer event\n  function handleWrong() {\n    wrongCount++;\n    a11yStatus.textContent = `Oops! Wrong answer. ${ALLOWED_WRONG - wrongCount} lives remaining.`;\n    try {\n      playWrongSound();\n    } catch (err) {\n      console.warn(\"Error playing wrong sound:\", err);\n    }\n    // shake drone\n    drone.wobble += 12;\n\n    if (wrongCount >= ALLOWED_WRONG) {\n      gameState = \"gameover\";\n      stopBackgroundHum();\n      a11yStatus.textContent = `Game over. You made ${wrongCount} wrong answers. Press R to restart.`;\n    } else {\n      // new question soon\n      setTimeout(() => {\n        generateQuestion();\n      }, 700);\n    }\n  }\n\n  // Validate and process a chosen index\n  function chooseIndex(i, clickPos) {\n    if (gameState !== \"playing\") return;\n    if (i < 0 || i >= choices.length) return;\n    if (!currentQuestion) return;\n    const chosen = choices[i];\n    if (chosen === currentQuestion.answer) {\n      handleCorrect(clickPos || { x: drone.x, y: drone.y });\n    } else {\n      handleWrong();\n    }\n  }\n\n  // Draw overlay screens: intro, victory, game over\n  function drawOverlay() {\n    ctx.save();\n    ctx.fillStyle = \"rgba(20, 20, 24, 0.62)\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    ctx.fillStyle = \"#ECEFF4\";\n    ctx.font = \"28px sans-serif\";\n    ctx.textAlign = \"center\";\n    if (gameState === \"intro\") {\n      ctx.fillText(\"Drone Math Quest\", WIDTH / 2, HEIGHT / 2 - 80);\n      ctx.font = \"18px sans-serif\";\n      ctx.fillText(\"Help the friendly drone collect power stars by solving math!\", WIDTH / 2, HEIGHT / 2 - 40);\n      ctx.fillText(\"Click or press any key to begin (and enable sound if desired).\", WIDTH / 2, HEIGHT / 2 - 10);\n      // draw start button visual\n      drawRoundedRect(restartButton.x, restartButton.y, restartButton.w, restartButton.h, 8, \"#88C0D0\");\n      ctx.fillStyle = \"#2E3440\";\n      ctx.font = \"18px sans-serif\";\n      ctx.fillText(\"Start Game\", WIDTH / 2, restartButton.y + 28);\n    } else if (gameState === \"victory\") {\n      ctx.fillText(\"Victory!\", WIDTH / 2, HEIGHT / 2 - 80);\n      ctx.font = \"18px sans-serif\";\n      ctx.fillText(`You collected ${score} stars! Great job flying with the drone.`, WIDTH / 2, HEIGHT / 2 - 40);\n      // stats\n      ctx.fillText(`Wrong answers: ${wrongCount}`, WIDTH / 2, HEIGHT / 2 - 10);\n      // restart button\n      drawRoundedRect(restartButton.x, restartButton.y, restartButton.w, restartButton.h, 8, \"#A3BE8C\");\n      ctx.fillStyle = \"#2E3440\";\n      ctx.fillText(\"Play Again (R)\", WIDTH / 2, restartButton.y + 28);\n    } else if (gameState === \"gameover\") {\n      ctx.fillText(\"Game Over\", WIDTH / 2, HEIGHT / 2 - 80);\n      ctx.font = \"18px sans-serif\";\n      ctx.fillText(`You made ${wrongCount} wrong answers. Try again to beat ${SCORE_GOAL} stars.`, WIDTH / 2, HEIGHT / 2 - 40);\n      drawRoundedRect(restartButton.x, restartButton.y, restartButton.w, restartButton.h, 8, \"#D08770\");\n      ctx.fillStyle = \"#2E3440\";\n      ctx.fillText(\"Restart (R)\", WIDTH / 2, restartButton.y + 28);\n    }\n    ctx.restore();\n    ctx.textAlign = \"left\";\n  }\n\n  // Main render loop\n  function render(now) {\n    const dt = now - lastTime;\n    lastTime = now;\n    // clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // background - calming sky gradient\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, \"#E5F6FA\");\n    g.addColorStop(1, \"#F7FBFF\");\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // playful clouds (wacky elements)\n    drawClouds(now);\n\n    // Draw drone and question\n    drawDrone(dt);\n\n    // Draw choices and UI\n    drawChoices();\n\n    // Update and draw stars\n    updateAndDrawStars(dt);\n\n    // Draw top UI\n    drawTopUI();\n\n    // Draw instructions bottom\n    drawInstructions();\n\n    // Draw subtle ground lines or landing pads\n    drawLandingPad();\n\n    // If in overlay states, draw overlay\n    if (gameState !== \"playing\") {\n      drawOverlay();\n    }\n\n    // Draw any remaining UI, like a small help text or audio indicator\n    // Use requestAnimationFrame\n    requestAnimationFrame(render);\n  }\n\n  // Clouds: wacky but calming\n  let cloudPhases = [0, 3000, 6000];\n  function drawClouds(now) {\n    ctx.save();\n    ctx.globalAlpha = 0.9;\n    for (let i = 0; i < cloudPhases.length; i++) {\n      const cp = cloudPhases[i];\n      const x = ((now + cp) * 0.02) % (WIDTH + 200) - 100;\n      const y = 40 + i * 30;\n      drawCloud(x, y, 80 + i * 10);\n    }\n    ctx.restore();\n  }\n\n  function drawCloud(cx, cy, size) {\n    ctx.fillStyle = \"#FFFFFF\";\n    ctx.beginPath();\n    ctx.ellipse(cx, cy, size * 0.6, size * 0.36, 0, 0, Math.PI * 2);\n    ctx.ellipse(cx + size * 0.5, cy + 4, size * 0.4, size * 0.28, 0, 0, Math.PI * 2);\n    ctx.ellipse(cx - size * 0.5, cy + 4, size * 0.4, size * 0.28, 0, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  // Landing pad under drone for visual interest\n  function drawLandingPad() {\n    const padX = WIDTH / 2 - 120;\n    const padY = HEIGHT - 170;\n    ctx.fillStyle = \"#ECEFF4\";\n    drawRoundedRect(padX, padY, 240, 12, 6, \"#E5E9F0\");\n    ctx.fillStyle = \"#D8DEE9\";\n    ctx.fillRect(padX + 20, padY - 6, 200, 6);\n  }\n\n  // Pointer utilities\n  function getCanvasPos(evt) {\n    const rect = canvas.getBoundingClientRect();\n    const x = (evt.clientX - rect.left) * (canvas.width / rect.width);\n    const y = (evt.clientY - rect.top) * (canvas.height / rect.height);\n    return { x, y };\n  }\n\n  // Input handling\n  canvas.addEventListener(\"click\", async (evt) => {\n    const pos = getCanvasPos(evt);\n\n    // If audio not enabled, user gesture enables audio\n    if (audioCtx && !audioEnabled) {\n      const ok = await ensureAudioRunning();\n      if (ok) {\n        a11yStatus.textContent = \"Audio enabled.\";\n      } else {\n        a11yStatus.textContent = \"Audio could not be enabled.\";\n      }\n    }\n\n    // If overlay intro and click inside start button, begin\n    if (gameState === \"intro\") {\n      if (pointInRect(pos, restartButton)) {\n        startGame();\n      } else {\n        startGame();\n      }\n      return;\n    }\n\n    // If overlay (victory/gameover), check restart\n    if (gameState === \"victory\" || gameState === \"gameover\") {\n      if (pointInRect(pos, restartButton)) {\n        restartGame();\n      }\n      return;\n    }\n\n    // Sound button click\n    if (pointInRect(pos, soundButton)) {\n      if (!audioEnabled) {\n        // attempt to enable\n        const ok = await ensureAudioRunning();\n        if (!ok) {\n          a11yStatus.textContent = \"Audio not available.\";\n        }\n      } else {\n        // toggle off\n        audioEnabled = false;\n        stopBackgroundHum();\n        a11yStatus.textContent = \"Audio muted.\";\n      }\n      return;\n    }\n\n    // Check choices click\n    const bottomY = HEIGHT - 100;\n    const cellRadius = 36;\n    const spacing = 18;\n    const totalWidth = choices.length * (cellRadius * 2) + (choices.length - 1) * spacing;\n    let startX = (WIDTH - totalWidth) / 2 + cellRadius;\n    for (let i = 0; i < choices.length; i++) {\n      const x = startX + i * (2 * cellRadius + spacing);\n      const y = bottomY;\n      if (Math.hypot(pos.x - x, pos.y - y) <= cellRadius + 6) {\n        selectedIndex = i;\n        chooseIndex(i, pos);\n        return;\n      }\n    }\n  });\n\n  function pointInRect(p, r) {\n    return p.x >= r.x && p.x <= r.x + r.w && p.y >= r.y && p.y <= r.y + r.h;\n  }\n\n  // Keyboard controls\n  window.addEventListener(\"keydown\", async (evt) => {\n    if (evt.repeat) return;\n    const key = evt.key.toLowerCase();\n    if (gameState === \"intro\") {\n      // start on any key\n      if (key) startGame();\n      return;\n    }\n    // Toggle audio\n    if (key === \"m\") {\n      if (!audioEnabled) {\n        const ok = await ensureAudioRunning();\n        if (!ok) a11yStatus.textContent = \"Audio not available.\";\n      } else {\n        audioEnabled = false;\n        stopBackgroundHum();\n        a11yStatus.textContent = \"Audio muted.\";\n      }\n      return;\n    }\n    if (key === \"r\") {\n      restartGame();\n      return;\n    }\n    if (gameState !== \"playing\") return;\n\n    if ([\"1\", \"2\", \"3\", \"4\"].includes(key)) {\n      const idx = parseInt(key, 10) - 1;\n      selectedIndex = idx;\n      chooseIndex(idx);\n      return;\n    }\n    if (key === \"arrowleft\") {\n      selectedIndex = (selectedIndex - 1 + choices.length) % choices.length;\n      a11yStatus.textContent = `Selected option ${selectedIndex + 1}.`;\n      return;\n    }\n    if (key === \"arrowright\") {\n      selectedIndex = (selectedIndex + 1) % choices.length;\n      a11yStatus.textContent = `Selected option ${selectedIndex + 1}.`;\n      return;\n    }\n    if (key === \"enter\") {\n      chooseIndex(selectedIndex);\n      return;\n    }\n  });\n\n  // Restart game\n  function restartGame() {\n    score = 0;\n    wrongCount = 0;\n    stars = [];\n    currentQuestion = null;\n    choices = [];\n    selectedIndex = 0;\n    gameState = \"intro\";\n    a11yStatus.textContent = \"Game reset. Press any key or click to start.\";\n  }\n\n  // Start actual playing state\n  function startGame() {\n    if (gameState === \"playing\") return;\n    score = 0;\n    wrongCount = 0;\n    stars = [];\n    drone.targetX = WIDTH / 2;\n    generateQuestion();\n    gameState = \"playing\";\n    lastTime = performance.now();\n    // attempt to ensure audio if possible\n    if (audioCtx && !audioEnabled) {\n      ensureAudioRunning().then((ok) => {\n        if (!ok) {\n          // audio not enabled, but continue playing\n          a11yStatus.textContent = \"Audio not enabled. Press M to enable audio.\";\n        }\n      });\n    } else if (audioEnabled) {\n      startBackgroundHum();\n    }\n    a11yStatus.textContent = \"Game started. Solve the first question.\";\n  }\n\n  // Kick off rendering\n  lastTime = performance.now();\n  requestAnimationFrame(render);\n\n  // Initialize intro state message\n  a11yStatus.textContent = \"Welcome to Drone Math Quest. Press any key or click to start.\";\n\n  // Expose some functions to console for debugging (non-essential)\n  window._droneMathQuest = {\n    restart: restartGame,\n    start: startGame,\n    getState: () => ({ score, wrongCount, gameState }),\n  };\n})();\n---\n",
  "improve_response_tokens": 21611,
  "formatted_code": true,
  "formatting_response_tokens": 24143,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}