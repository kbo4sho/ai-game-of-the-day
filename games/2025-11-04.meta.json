{
  "generated_date": "2025-11-04",
  "generated_timestamp": "2025-11-04T00:27:55.424060",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9771,
  "game_filename": "2025-11-04.js",
  "game_size_bytes": 26231,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function() {\n  // Educational Drone Math Game\n  // Renders into #game-of-the-day-stage using a canvas sized 720x480\n  // Math target: answer 10 questions correctly to win. 3 wrong answers = game over.\n  // Controls: Arrow keys to move drone, Space to pick up nearest package,\n  // Number keys 1-4 to choose an on-screen package, Mouse click to select,\n  // S to toggle sound (requires enabling audio), R to restart.\n  // Accessible: canvas has role and aria-live updates for current question.\n  // All visuals are canvas-drawn. Sounds generated with Web Audio API oscillators.\n\n  // Strict mode\n  'use strict';\n\n  // Config\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const PADDING = 10;\n  const GOAL_SCORE = 10;\n  const MAX_LIVES = 3;\n  const PACKAGE_COUNT = 4;\n  const MIN_BODY_FONT = 16; // px\n  const IMPORTANT_FONT = 20; // px\n  const UI_BG_COLOR = 'rgba(255,255,255,0.85)';\n  const UI_TEXT_COLOR = '#083d77';\n  const DRONE_COLOR = '#2a9d8f';\n  const DRONE_SIZE = 36;\n  const PACKAGE_RADIUS = 26;\n  const CLOUD_COUNT = 6;\n\n  // DOM setup\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('No element with id \"game-of-the-day-stage\" found.');\n    return;\n  }\n  container.innerHTML = ''; // clear\n  container.style.position = 'relative';\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute('role', 'img');\n  canvas.setAttribute('aria-label', 'Drone Math Game. Use arrow keys to fly and space to pick packages. Press S to enable sound.');\n  canvas.tabIndex = 0; // make focusable for keyboard controls\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Accessibility live region for question results\n  const live = document.createElement('div');\n  live.setAttribute('aria-live', 'polite');\n  live.style.position = 'absolute';\n  live.style.left = '-9999px';\n  container.appendChild(live);\n\n  // Audio setup with robust error handling\n  let audioCtx = null;\n  let globalGain = null;\n  let ambientNodes = [];\n  let audioEnabled = false;\n  function tryCreateAudio() {\n    if (audioCtx) return;\n    try {\n      const AC = window.AudioContext || window.webkitAudioContext;\n      audioCtx = new AC();\n      globalGain = audioCtx.createGain();\n      globalGain.gain.value = 0.0; // start muted until enabled\n      globalGain.connect(audioCtx.destination);\n      audioEnabled = false;\n      startAmbient(); // create ambient nodes but keep muted\n    } catch (e) {\n      console.warn('AudioContext creation failed:', e);\n      audioCtx = null;\n      globalGain = null;\n      audioEnabled = false;\n    }\n  }\n\n  // Ambient gentle hum (soft drone hum)\n  function startAmbient() {\n    if (!audioCtx || !globalGain) return;\n    try {\n      // Create a couple of very low-volume oscillators for texture\n      stopAmbient();\n      for (let i = 0; i < 2; i++) {\n        const osc = audioCtx.createOscillator();\n        osc.type = i === 0 ? 'sine' : 'triangle';\n        osc.frequency.value = i === 0 ? 80 : 120;\n        const gain = audioCtx.createGain();\n        gain.gain.value = 0.0015; // extremely gentle by default\n        // LFO for slight movement\n        const lfo = audioCtx.createOscillator();\n        lfo.frequency.value = 0.05 + i * 0.04;\n        const lfoGain = audioCtx.createGain();\n        lfoGain.gain.value = i === 0 ? 20 : 30;\n        lfo.connect(lfoGain);\n        lfoGain.connect(osc.frequency);\n        osc.connect(gain);\n        gain.connect(globalGain);\n        osc.start();\n        lfo.start();\n        ambientNodes.push({osc, gain, lfo, lfoGain});\n      }\n    } catch (e) {\n      console.warn('Failed to start ambient audio:', e);\n    }\n  }\n\n  function stopAmbient() {\n    try {\n      ambientNodes.forEach(n => {\n        try {\n          n.osc.stop();\n        } catch(e){}\n        try {\n          n.lfo.stop();\n        } catch(e){}\n      });\n    } catch (e) {\n      // ignore\n    }\n    ambientNodes = [];\n  }\n\n  function setAudioEnabled(enabled) {\n    try {\n      if (!audioCtx) tryCreateAudio();\n      if (!audioCtx) return;\n      audioEnabled = !!enabled;\n      audioCtx.resume().catch(()=>{}); // in case suspended\n      globalGain.gain.setTargetAtTime(enabled ? 0.06 : 0.0, audioCtx.currentTime, 0.02);\n    } catch (e) {\n      console.warn('Error toggling audio:', e);\n      audioEnabled = false;\n    }\n  }\n\n  // Sound effects: correct / wrong uses short oscillators and filters\n  function playCorrect() {\n    if (!audioCtx || !globalGain || !audioEnabled) return;\n    try {\n      const o1 = audioCtx.createOscillator();\n      o1.type = 'sine';\n      const g1 = audioCtx.createGain();\n      g1.gain.value = 0.0;\n      o1.frequency.value = 880;\n      // simple envelope\n      o1.connect(g1);\n      g1.connect(globalGain);\n      const now = audioCtx.currentTime;\n      g1.gain.setValueAtTime(0.0001, now);\n      g1.gain.exponentialRampToValueAtTime(0.09, now + 0.02);\n      g1.gain.exponentialRampToValueAtTime(0.0001, now + 0.28);\n      o1.frequency.setValueAtTime(880, now);\n      o1.frequency.exponentialRampToValueAtTime(1320, now + 0.18);\n      o1.start(now);\n      o1.stop(now + 0.3);\n    } catch (e) {\n      console.warn('playCorrect failed', e);\n    }\n  }\n\n  function playWrong() {\n    if (!audioCtx || !globalGain || !audioEnabled) return;\n    try {\n      const o = audioCtx.createOscillator();\n      o.type = 'sawtooth';\n      const g = audioCtx.createGain();\n      g.gain.value = 0.0;\n      const bi = audioCtx.createBiquadFilter();\n      bi.type = 'lowpass';\n      bi.frequency.value = 1200;\n      o.connect(bi);\n      bi.connect(g);\n      g.connect(globalGain);\n      const now = audioCtx.currentTime;\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(0.08, now + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);\n      o.frequency.setValueAtTime(220, now);\n      o.frequency.exponentialRampToValueAtTime(110, now + 0.22);\n      o.start(now);\n      o.stop(now + 0.3);\n    } catch (e) {\n      console.warn('playWrong failed', e);\n    }\n  }\n\n  // Simple utility helpers\n  function randRange(a, b) {\n    return Math.floor(Math.random() * (b - a + 1)) + a;\n  }\n  function clamp(v, a, b) {\n    return Math.max(a, Math.min(b, v));\n  }\n  function distance(a, b) {\n    const dx = a.x - b.x;\n    const dy = a.y - b.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  // Game state\n  let score = 0;\n  let lives = MAX_LIVES;\n  let packages = [];\n  let drone = {x: WIDTH / 2, y: HEIGHT / 2, vx: 0, vy: 0, size: DRONE_SIZE};\n  let keys = {};\n  let question = null;\n  let gameState = 'playing'; // playing, victory, gameover, attract (initial)\n  let lastTime = performance.now();\n  let flashTimer = 0;\n  let audioAvailable = true;\n  let clouds = [];\n\n  // Initialize clouds for background\n  function initClouds() {\n    clouds = [];\n    for (let i = 0; i < CLOUD_COUNT; i++) {\n      clouds.push({\n        x: Math.random() * WIDTH,\n        y: Math.random() * (HEIGHT * 0.45),\n        size: 40 + Math.random() * 90,\n        vx: 0.2 + Math.random() * 0.6,\n        wobble: Math.random() * 1000\n      });\n    }\n  }\n\n  // Math question generation (age 7-9)\n  function generateQuestion() {\n    // Use addition and subtraction mainly, occasional multiplication\n    const ops = ['+','-','*'];\n    let op = Math.random() < 0.7 ? (Math.random() < 0.6 ? '+' : '-') : '*';\n    // ensure multiplication less frequent\n    if (op === '*') {\n      const a = randRange(2,8);\n      const b = randRange(2,8);\n      const ans = a * b;\n      return {a,b,op,answer:ans};\n    } else if (op === '+') {\n      const a = randRange(1, 20);\n      const b = randRange(1, 20);\n      return {a,b,op,answer: a + b};\n    } else {\n      // subtraction ensure positive results\n      let a = randRange(1, 20);\n      let b = randRange(1, a);\n      return {a,b,op:'-',answer: a - b};\n    }\n  }\n\n  // Generate options including correct answer\n  function generateOptions(correct) {\n    const opts = new Set();\n    opts.add(correct);\n    while (opts.size < PACKAGE_COUNT) {\n      // create plausible wrong answers\n      const delta = randRange(1, 6);\n      const sign = Math.random() < 0.5 ? -1 : 1;\n      let val = correct + sign * delta;\n      // ensure non-negative and not equal\n      if (val < 0) val = Math.abs(val) + 1;\n      opts.add(val);\n    }\n    // Shuffle\n    const arr = Array.from(opts);\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    return arr;\n  }\n\n  // Spawn packages in non-overlapping positions and away from UI\n  function spawnPackages() {\n    packages = [];\n    const opts = generateOptions(question.answer);\n    const attemptsLimit = 200;\n    for (let i = 0; i < opts.length; i++) {\n      let placed = false;\n      let attempts = 0;\n      while (!placed && attempts < attemptsLimit) {\n        attempts++;\n        const marginTop = 80; // avoid top UI\n        const x = PACKAGE_RADIUS + Math.random() * (WIDTH - PACKAGE_RADIUS * 2);\n        const y = marginTop + PACKAGE_RADIUS + Math.random() * (HEIGHT - marginTop - PACKAGE_RADIUS - 80);\n        const candidate = {x,y,r:PACKAGE_RADIUS,number:opts[i],vx: (Math.random()*0.8-0.4), vy: 0, wobble: Math.random()*2000, id: i};\n        // Check not overlapping with other packages\n        let ok = true;\n        for (const p of packages) {\n          if (distance(candidate, p) < candidate.r + p.r + 8) { ok = false; break; }\n        }\n        // Avoid center top UI area (for question) - allow safe zone\n        if (y < marginTop + 10) ok = false;\n        if (ok) {\n          packages.push(candidate);\n          placed = true;\n        }\n      }\n      if (!placed) {\n        // fallback: place in grid\n        packages.push({x: 80 + i * 140, y: 160, r: PACKAGE_RADIUS, number: opts[i], vx:0, vy:0, wobble: i*100, id:i});\n      }\n    }\n  }\n\n  // Reset game\n  function resetGame() {\n    score = 0;\n    lives = MAX_LIVES;\n    drone.x = WIDTH / 2;\n    drone.y = HEIGHT - 100;\n    keys = {};\n    question = generateQuestion();\n    spawnPackages();\n    gameState = 'playing';\n    flashTimer = 0;\n    lastTime = performance.now();\n    live.textContent = `New question: ${question.a} ${question.op} ${question.b} = ?`;\n  }\n\n  // Initialize\n  tryCreateAudio();\n  initClouds();\n  question = generateQuestion();\n  spawnPackages();\n\n  // Input handling\n  canvas.addEventListener('keydown', (e) => {\n    const key = e.key;\n    keys[key] = true;\n    // Allow enabling audio with 'S'\n    if (key === 's' || key === 'S') {\n      tryCreateAudio();\n      setAudioEnabled(!audioEnabled);\n    }\n    if ((key === 'r' || key === 'R') && (gameState === 'victory' || gameState === 'gameover')) {\n      resetGame();\n      audioCtx && audioCtx.resume().catch(()=>{});\n    }\n    // Number keys choose package\n    if (['1','2','3','4'].includes(key) && gameState === 'playing') {\n      const idx = parseInt(key,10) - 1;\n      if (packages[idx]) {\n        handleSelection(packages[idx]);\n      }\n    }\n    if (key === ' ' && gameState === 'playing') {\n      // pick nearest package\n      let nearest = null; let minD = Infinity;\n      for (const p of packages) {\n        const d = distance(p, drone);\n        if (d < minD) { minD = d; nearest = p; }\n      }\n      if (nearest && minD <= 80) {\n        handleSelection(nearest);\n      }\n    }\n  });\n\n  canvas.addEventListener('keyup', (e) => {\n    delete keys[e.key];\n  });\n\n  // Mouse controls\n  canvas.addEventListener('click', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);\n    const my = (e.clientY - rect.top) * (canvas.height / rect.height);\n    if (gameState === 'playing') {\n      // Check package clicked\n      for (let i = 0; i < packages.length; i++) {\n        const p = packages[i];\n        if (Math.hypot(p.x - mx, p.y - my) <= p.r + 4) {\n          handleSelection(p);\n          return;\n        }\n      }\n      // Check audio toggle button area (drawn bottom-left)\n      const audRect = getAudioButtonRect();\n      if (mx >= audRect.x && mx <= audRect.x + audRect.w && my >= audRect.y && my <= audRect.y + audRect.h) {\n        tryCreateAudio();\n        setAudioEnabled(!audioEnabled);\n        return;\n      }\n    } else {\n      // On end screens, check for restart button\n      const btn = getRestartButtonRect();\n      if (mx >= btn.x && mx <= btn.x + btn.w && my >= btn.y && my <= btn.y + btn.h) {\n        resetGame();\n        return;\n      }\n    }\n  });\n\n  // Touch support (tap)\n  canvas.addEventListener('touchstart', (e) => {\n    const touch = e.touches[0];\n    if (!touch) return;\n    const rect = canvas.getBoundingClientRect();\n    const tx = (touch.clientX - rect.left) * (canvas.width / rect.width);\n    const ty = (touch.clientY - rect.top) * (canvas.height / rect.height);\n    // emulate click\n    const clickEvent = new MouseEvent('click', {\n      clientX: touch.clientX,\n      clientY: touch.clientY\n    });\n    canvas.dispatchEvent(clickEvent);\n    e.preventDefault();\n  }, {passive:false});\n\n  // UI geometry helpers\n  function drawUITextBox(text, x, y, font='16px sans-serif', padding=PADDING, align='left', bg=UI_BG_COLOR, fg=UI_TEXT_COLOR) {\n    ctx.save();\n    ctx.font = font;\n    ctx.textBaseline = 'top';\n    const metrics = ctx.measureText(text);\n    const w = metrics.width;\n    const h = parseInt(font,10) + 6;\n    let drawX = x;\n    if (align === 'center') drawX = x - w / 2 - padding;\n    if (align === 'right') drawX = x - w - padding * 2;\n    const rectX = drawX - padding;\n    const rectY = y - padding;\n    const rectW = w + padding * 2;\n    const rectH = h + padding * 2;\n    // background\n    ctx.fillStyle = bg;\n    roundRect(ctx, rectX, rectY, rectW, rectH, 8);\n    ctx.fill();\n    // text\n    ctx.fillStyle = fg;\n    ctx.fillText(text, rectX + padding, rectY + padding + 2);\n    ctx.restore();\n    return {x:rectX, y:rectY, w:rectW, h:rectH};\n  }\n\n  function roundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n  }\n\n  // Draw drone (simple whimsical shape)\n  function drawDrone(x, y, size, t) {\n    ctx.save();\n    ctx.translate(x, y);\n    // body\n    ctx.fillStyle = DRONE_COLOR;\n    ctx.beginPath();\n    ctx.ellipse(0, 0, size * 0.9, size * 0.6, Math.sin(t/200)*0.08, 0, Math.PI*2);\n    ctx.fill();\n\n    // cockpit\n    ctx.fillStyle = '#e9f5db';\n    ctx.beginPath();\n    ctx.ellipse(-size*0.15, -size*0.05, size*0.35, size*0.25, 0, 0, Math.PI*2);\n    ctx.fill();\n\n    // propellers (wacky arms)\n    for (let i = -1; i <= 1; i+=2) {\n      ctx.save();\n      ctx.translate(i * size * 0.8, -size*0.15);\n      ctx.rotate(Math.sin(t/120 + i)*0.8);\n      ctx.fillStyle = '#c7f9cc';\n      ctx.fillRect(-size*0.3, -4, size*0.6, 8);\n      ctx.restore();\n    }\n\n    // cargo hook\n    ctx.fillStyle = '#6c757d';\n    ctx.fillRect(-6, size*0.42, 12, 12);\n    ctx.restore();\n  }\n\n  // Draw cloud\n  function drawCloud(c, t) {\n    ctx.save();\n    ctx.globalAlpha = 0.9;\n    ctx.fillStyle = '#ffffff';\n    ctx.beginPath();\n    const wob = Math.sin((t + c.wobble) / 600) * 6;\n    ctx.ellipse(c.x, c.y + wob, c.size * 0.6, c.size * 0.36, 0, 0, Math.PI*2);\n    ctx.ellipse(c.x - c.size*0.28, c.y + 6 + wob, c.size*0.5, c.size*0.28, 0, 0, Math.PI*2);\n    ctx.ellipse(c.x + c.size*0.28, c.y + 8 + wob, c.size*0.5, c.size*0.28, 0, 0, Math.PI*2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  // Handle selecting a package (by click or keyboard)\n  function handleSelection(pkg) {\n    if (gameState !== 'playing') return;\n    if (!pkg) return;\n    if (pkg.number === question.answer) {\n      score++;\n      flashTimer = 16;\n      playCorrect();\n      live.textContent = `Correct! ${question.a} ${question.op} ${question.b} = ${question.answer}. Score ${score}/${GOAL_SCORE}.`;\n      // generate new question\n      if (score >= GOAL_SCORE) {\n        gameState = 'victory';\n        live.textContent = `Victory! You delivered ${GOAL_SCORE} correct packages. Press R to restart.`;\n        return;\n      } else {\n        question = generateQuestion();\n        spawnPackages();\n      }\n    } else {\n      lives--;\n      playWrong();\n      flashTimer = 26;\n      live.textContent = `Oops! ${pkg.number} is not ${question.a} ${question.op} ${question.b}. Lives left: ${lives}.`;\n      if (lives <= 0) {\n        gameState = 'gameover';\n        live.textContent = `Game over. You had ${score} correct answers. Press R to restart.`;\n      }\n    }\n  }\n\n  // Get audio button rect for click detection (bottom-left)\n  function getAudioButtonRect() {\n    const font = `${MIN_BODY_FONT}px sans-serif`;\n    ctx.font = font;\n    const text = audioEnabled ? 'Sound: On (S)' : 'Sound: Off (S)';\n    const metrics = ctx.measureText(text);\n    const w = metrics.width + PADDING * 2;\n    const h = MIN_BODY_FONT + PADDING * 2 + 6;\n    const x = PADDING;\n    const y = HEIGHT - h - PADDING;\n    return {x,y,w,h, text};\n  }\n\n  // Get restart button rect center\n  function getRestartButtonRect() {\n    const font = `${IMPORTANT_FONT}px sans-serif`;\n    ctx.font = font;\n    const text = 'Restart (R)';\n    const metrics = ctx.measureText(text);\n    const w = metrics.width + PADDING * 2;\n    const h = IMPORTANT_FONT + PADDING * 2 + 6;\n    const x = (WIDTH - w) / 2;\n    const y = HEIGHT / 2 + 70;\n    return {x,y,w,h, text};\n  }\n\n  // Main loop\n  function loop(now) {\n    const dt = Math.min(60, now - lastTime);\n    lastTime = now;\n    update(dt);\n    draw(now);\n    requestAnimationFrame(loop);\n  }\n\n  // Update logic\n  function update(dt) {\n    // Clouds drift\n    for (const c of clouds) {\n      c.x += c.vx * (dt / 16);\n      if (c.x - c.size > WIDTH) c.x = -c.size;\n    }\n\n    if (gameState !== 'playing') return;\n\n    // Drone movement\n    const speed = 0.22 * dt;\n    if (keys['ArrowLeft'] || keys['Left']) drone.x -= speed;\n    if (keys['ArrowRight'] || keys['Right']) drone.x += speed;\n    if (keys['ArrowUp'] || keys['Up']) drone.y -= speed;\n    if (keys['ArrowDown'] || keys['Down']) drone.y += speed;\n    // Keep within bounds\n    drone.x = clamp(drone.x, DRONE_SIZE * 0.6, WIDTH - DRONE_SIZE * 0.6);\n    drone.y = clamp(drone.y, DRONE_SIZE * 0.5, HEIGHT - DRONE_SIZE * 0.5 - 60);\n\n    // Packages drift slightly and bob\n    for (const p of packages) {\n      p.wobble = (p.wobble + dt) % 100000;\n      p.x += Math.sin(p.wobble / 800) * 0.25;\n      p.y += Math.sin(p.wobble / 700) * 0.15;\n      // keep in bounds\n      p.x = clamp(p.x, p.r + 8, WIDTH - p.r - 8);\n      p.y = clamp(p.y, 90 + p.r, HEIGHT - p.r - 80);\n    }\n\n    if (flashTimer > 0) flashTimer--;\n  }\n\n  // Draw everything\n  function draw(t) {\n    // Clear\n    ctx.clearRect(0,0,WIDTH,HEIGHT);\n\n    // Background sky gradient\n    const grad = ctx.createLinearGradient(0,0,0,HEIGHT);\n    grad.addColorStop(0, '#cceefc');\n    grad.addColorStop(1, '#f3f8ff');\n    ctx.fillStyle = grad;\n    ctx.fillRect(0,0,WIDTH,HEIGHT);\n\n    // Clouds\n    for (const c of clouds) drawCloud(c, t);\n\n    // Calm wacky ground / landscape\n    ctx.save();\n    ctx.fillStyle = '#e8f6ee';\n    ctx.beginPath();\n    ctx.moveTo(0, HEIGHT * 0.78);\n    for (let x = 0; x <= WIDTH; x += 20) {\n      const y = HEIGHT*0.78 + Math.sin((x + t/8) / 60) * 8;\n      ctx.lineTo(x, y);\n    }\n    ctx.lineTo(WIDTH, HEIGHT);\n    ctx.lineTo(0, HEIGHT);\n    ctx.closePath();\n    ctx.fill();\n    ctx.restore();\n\n    // Draw packages\n    for (let i = 0; i < packages.length; i++) {\n      const p = packages[i];\n      const bob = Math.sin((t + p.wobble) / 220) * 6;\n      // shadow\n      ctx.save();\n      ctx.globalAlpha = 0.2;\n      ctx.fillStyle = '#000';\n      ctx.beginPath();\n      ctx.ellipse(p.x + 6, p.y + p.r + 8, p.r * 0.9, p.r * 0.25, 0, 0, Math.PI*2);\n      ctx.fill();\n      ctx.restore();\n\n      // package body\n      ctx.save();\n      ctx.translate(p.x, p.y + bob);\n      ctx.fillStyle = '#ffd166';\n      ctx.strokeStyle = '#8b5e34';\n      ctx.lineWidth = 2;\n      roundRect(ctx, -p.r, -p.r, p.r*2, p.r*2, 8);\n      ctx.fill();\n      ctx.stroke();\n\n      // number label\n      ctx.fillStyle = '#083d77';\n      ctx.font = `${IMPORTANT_FONT}px sans-serif`;\n      ctx.textBaseline = 'middle';\n      ctx.textAlign = 'center';\n      ctx.fillText(String(p.number), 0, 0);\n      ctx.restore();\n\n      // small index\n      ctx.save();\n      ctx.fillStyle = 'rgba(8,61,119,0.08)';\n      ctx.font = `${MIN_BODY_FONT}px sans-serif`;\n      ctx.fillText(`${i+1}`, p.x + p.r - 8, p.y - p.r + 6);\n      ctx.restore();\n    }\n\n    // Draw drone with gentle bob\n    drawDrone(drone.x, drone.y + Math.sin(t/200)*4, drone.size, t);\n\n    // UI: Score top-left\n    ctx.save();\n    const scoreText = `Score: ${score}/${GOAL_SCORE}`;\n    ctx.font = `${IMPORTANT_FONT}px sans-serif`;\n    const scoreRect = drawUITextBox(scoreText, PADDING, PADDING, `${IMPORTANT_FONT}px sans-serif`, PADDING, 'left');\n    ctx.restore();\n\n    // Lives top-right\n    ctx.save();\n    const livesText = `Lives: ${lives}`;\n    ctx.font = `${IMPORTANT_FONT}px sans-serif`;\n    const livesMetrics = ctx.measureText(livesText);\n    const livesRect = drawUITextBox(livesText, WIDTH - PADDING - livesMetrics.width - PADDING, PADDING, `${IMPORTANT_FONT}px sans-serif`, PADDING, 'left', UI_BG_COLOR, UI_TEXT_COLOR);\n    ctx.restore();\n\n    // Question top-center (ensure non-overlap)\n    ctx.save();\n    const qText = `Solve: ${question.a} ${question.op} ${question.b} = ?`;\n    ctx.font = `${IMPORTANT_FONT+2}px sans-serif`;\n    const qMetrics = ctx.measureText(qText);\n    let qx = WIDTH / 2; // center position\n    let qy = PADDING;\n    // Compute rectangles for left and right boxes\n    const leftBoxRight = scoreRect.x + scoreRect.w;\n    const rightBoxLeft = livesRect.x;\n    const qLeft = qx - qMetrics.width / 2 - PADDING;\n    const qRight = qx + qMetrics.width / 2 + PADDING;\n    // If overlap with left or right, move question down below top UI by padding\n    if (qLeft < leftBoxRight + 10 || qRight > rightBoxLeft - 10) {\n      qy = scoreRect.y + scoreRect.h + 12;\n    }\n    drawUITextBox(qText, qx, qy, `${IMPORTANT_FONT+2}px sans-serif`, PADDING, 'center', UI_BG_COLOR, UI_TEXT_COLOR);\n    ctx.restore();\n\n    // Instructions bottom-center (multi-line)\n    ctx.save();\n    ctx.font = `${MIN_BODY_FONT}px sans-serif`;\n    const instrLines = [\n      'Controls: Arrows to fly \u2022 Space to pick nearest \u2022 1-4 keys to pick packages \u2022 Click to pick \u2022 S to toggle sound',\n      'Goal: Answer 10 correctly. Wrong answers: lose 1 life. Lose all lives = Game Over. Press R to restart.'\n    ];\n    // Draw a multi-line centered box\n    const lineHeights = instrLines.map(l => MIN_BODY_FONT + 6);\n    const maxWidth = Math.max(...instrLines.map(l => ctx.measureText(l).width));\n    const boxW = maxWidth + PADDING * 2;\n    const boxH = lineHeights.reduce((a,b)=>a+b,0) + PADDING*2;\n    const boxX = (WIDTH - boxW) / 2;\n    const boxY = HEIGHT - boxH - PADDING;\n    ctx.fillStyle = UI_BG_COLOR;\n    roundRect(ctx, boxX, boxY, boxW, boxH, 10);\n    ctx.fill();\n    ctx.fillStyle = UI_TEXT_COLOR;\n    ctx.textBaseline = 'top';\n    let ly = boxY + PADDING;\n    for (const line of instrLines) {\n      ctx.fillText(line, boxX + PADDING, ly);\n      ly += MIN_BODY_FONT + 6;\n    }\n    ctx.restore();\n\n    // Audio button bottom-left\n    const aud = getAudioButtonRect();\n    ctx.save();\n    ctx.fillStyle = UI_BG_COLOR;\n    roundRect(ctx, aud.x, aud.y, aud.w, aud.h, 8);\n    ctx.fill();\n    ctx.fillStyle = UI_TEXT_COLOR;\n    ctx.font = `${MIN_BODY_FONT}px sans-serif`;\n    ctx.fillText(aud.text, aud.x + PADDING, aud.y + PADDING + 2);\n    // Visual cue for audio on/off: simple icon\n    ctx.beginPath();\n    ctx.fillStyle = audioEnabled ? '#2a9d8f' : '#b6b6b6';\n    ctx.moveTo(aud.x + aud.w - 26, aud.y + 12);\n    ctx.lineTo(aud.x + aud.w - 14, aud.y + 12);\n    ctx.lineTo(aud.x + aud.w - 6, aud.y + aud.h - 12);\n    ctx.lineTo(aud.x + aud.w - 30, aud.y + aud.h - 12);\n    ctx.closePath();\n    ctx.fill();\n    ctx.restore();\n\n    // Visual feedback when flashTimer active (correct/wrong)\n    if (flashTimer > 0) {\n      ctx.save();\n      const alpha = Math.min(0.7, flashTimer / 30);\n      // color depends on last action: if lives decreased recently (we can't easily check), alternate color by even/odd\n      const color = (flashTimer % 2 === 0) ? 'rgba(42,157,143,'+alpha+')' : 'rgba(239,68,68,'+alpha+')';\n      ctx.fillStyle = color;\n      ctx.fillRect(0,0,WIDTH,HEIGHT);\n      ctx.restore();\n    }\n\n    // If victory or gameover, draw overlay screens\n    if (gameState === 'victory' || gameState === 'gameover') {\n      ctx.save();\n      ctx.fillStyle = 'rgba(3,61,119,0.75)';\n      ctx.fillRect(0,0,WIDTH,HEIGHT);\n      // Message box\n      const title = gameState === 'victory' ? 'YOU WON!' : 'GAME OVER';\n      const message = gameState === 'victory' ? `You delivered ${GOAL_SCORE} correct packages!` : `You answered ${score} correctly.`;\n      ctx.fillStyle = '#ffffff';\n      ctx.font = `${IMPORTANT_FONT + 12}px sans-serif`;\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(title, WIDTH/2, HEIGHT/2 - 40);\n      ctx.font = `${IMPORTANT_FONT}px sans-serif`;\n      ctx.fillText(message, WIDTH/2, HEIGHT/2 + 0);\n      // Restart button\n      const btn = getRestartButtonRect();\n      ctx.fillStyle = '#ffd166';\n      roundRect(ctx, btn.x, btn.y, btn.w, btn.h, 8);\n      ctx.fill();\n      ctx.fillStyle = '#083d77';\n      ctx.font = `${IMPORTANT_FONT}px sans-serif`;\n      ctx.fillText(btn.text, WIDTH/2, btn.y + btn.h/2);\n      ctx.restore();\n    }\n  }\n\n  // Start animation\n  requestAnimationFrame(loop);\n\n  // Ensure canvas gets focus to receive keyboard events\n  canvas.addEventListener('focus', () => {\n    // nothing special\n  });\n  setTimeout(() => {\n    try { canvas.focus(); } catch(e){/* ignore */ }\n  }, 200);\n\n  // Expose restart for console (optional)\n  window.__droneMathGame = {\n    reset: resetGame,\n    toggleSound: () => setAudioEnabled(!audioEnabled)\n  };\n\n  // Initial message to live region\n  live.textContent = `Welcome! Answer ${GOAL_SCORE} questions correctly to win. Use the controls shown. Press S to enable sound.`;\n\n})();\n---\n",
  "improve_response_tokens": 18414,
  "formatted_code": true,
  "formatting_response_tokens": 20211,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}