{
  "generated_date": "2025-09-25",
  "generated_timestamp": "2025-09-25T00:26:32.402579",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9250,
  "game_filename": "2025-09-25.js",
  "game_size_bytes": 27486,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function() {\n  // Machine Math \u2014 Canvas Game for Ages 7-9\n  // Renders inside element with id \"game-of-the-day-stage\"\n  // All visuals drawn with canvas. Sounds made with Web Audio API oscillators.\n  // Keyboard: \u2190 \u2192 move, Space pick/drop, Enter submit, M mute, R reset level\n  // Accessible live text updates added for screen readers.\n\n  // Constants\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const STAGE_ID = \"game-of-the-day-stage\";\n  const MAX_LEVEL = 6;\n  const NUM_BUBBLES = 5;\n  const SLOT_COUNT = 3;\n\n  // Colors and styling\n  const COLORS = {\n    bg: \"#f2f7fb\",\n    machine: \"#D6EAF8\",\n    accent: \"#8EC5FF\",\n    gear: \"#B2D3E8\",\n    text: \"#21495A\",\n    bubble: \"#F7D6A5\",\n    bubbleText: \"#3E3E3E\",\n    robot: \"#C6EBC5\",\n    slotEmpty: \"#EDEDED\",\n    slotFilled: \"#F8E1E7\",\n    good: \"#4BB543\",\n    bad: \"#E04E4E\",\n    speakerOn: \"#21495A\",\n    speakerOff: \"#A0A0A0\"\n  };\n\n  // Helper utilities\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  function clamp(v, a, b) {\n    return Math.max(a, Math.min(b, v));\n  }\n\n  function safeAudioContext() {\n    try {\n      const Ctx = window.AudioContext || window.webkitAudioContext;\n      if (!Ctx) return null;\n      return new Ctx();\n    } catch (e) {\n      return null;\n    }\n  }\n\n  // Get stage element\n  const stage = document.getElementById(STAGE_ID);\n  if (!stage) {\n    console.error(\"Game stage element not found:\", STAGE_ID);\n    return;\n  }\n\n  // Create an offscreen live region for screen readers inside the stage element\n  const liveRegion = document.createElement(\"div\");\n  liveRegion.setAttribute(\"aria-live\", \"polite\");\n  liveRegion.setAttribute(\"role\", \"status\");\n  // Visually hide but keep accessible\n  liveRegion.style.position = \"absolute\";\n  liveRegion.style.left = \"-9999px\";\n  liveRegion.style.top = \"auto\";\n  stage.appendChild(liveRegion);\n\n  // Create canvas exactly 720x480\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute(\"role\", \"img\");\n  canvas.setAttribute(\"aria-label\", \"Machine Math game. Move robot with left and right arrow keys, pick up numbers with space, submit with Enter. Press M to mute sound.\");\n  stage.appendChild(canvas);\n  const ctx = canvas.getContext(\"2d\");\n\n  // Game state\n  let state = {\n    level: 1,\n    target: 0,\n    bubbles: [], // {x,y,val,visible}\n    slots: new Array(SLOT_COUNT).fill(null), // each holds a number or null\n    robot: { x: WIDTH / 2, y: HEIGHT - 70, speed: 6, holding: null },\n    score: 0,\n    message: \"Welcome! Press Space to pick up a number.\",\n    messageTimer: 0,\n    audioEnabled: false,\n    audioAvailable: true,\n    muted: false,\n    bgHum: null, // background oscillator\n    soundContext: null,\n    awaitingUserGesture: true,\n    levelSolved: false\n  };\n\n  // Audio utilities and sounds\n  function initAudio() {\n    if (state.soundContext) return;\n    try {\n      const ctxAudio = safeAudioContext();\n      if (!ctxAudio) {\n        state.audioAvailable = false;\n        console.warn(\"Web Audio API not available.\");\n        liveAnnounce(\"Audio is not available in your browser.\");\n        return;\n      }\n      state.soundContext = ctxAudio;\n      // Create a gentle background hum (low volume)\n      try {\n        const humOsc = ctxAudio.createOscillator();\n        humOsc.type = \"sine\";\n        humOsc.frequency.value = 60; // low hum\n        const humGain = ctxAudio.createGain();\n        humGain.gain.value = 0.0025; // very gentle background\n        humOsc.connect(humGain).connect(ctxAudio.destination);\n        humOsc.start();\n        state.bgHum = { osc: humOsc, gain: humGain };\n        state.audioAvailable = true;\n      } catch (err) {\n        console.warn(\"Background hum error:\", err);\n      }\n    } catch (err) {\n      state.audioAvailable = false;\n      console.warn(\"Failed to initialize audio:\", err);\n      liveAnnounce(\"Audio initialization failed.\");\n    }\n  }\n\n  function resumeAudioOnUserGesture() {\n    if (!state.soundContext) return;\n    const ctx = state.soundContext;\n    if (ctx.state === \"suspended\") {\n      ctx.resume().then(() => {\n        state.awaitingUserGesture = false;\n        state.audioEnabled = !state.muted;\n      }).catch(err => {\n        console.warn(\"Audio resume failed:\", err);\n      });\n    }\n  }\n\n  function stopAllSounds() {\n    if (!state.soundContext) return;\n    try {\n      if (state.bgHum && state.bgHum.osc) {\n        try { state.bgHum.osc.stop(); } catch (e) {}\n        state.bgHum.osc.disconnect();\n        state.bgHum.gain.disconnect();\n      }\n    } catch (e) {\n      console.warn(\"Error stopping sounds:\", e);\n    }\n    state.bgHum = null;\n    // Close context if possible\n    if (state.soundContext.close) {\n      state.soundContext.close().catch(() => {});\n    }\n    state.soundContext = null;\n  }\n\n  function playToneSequence(tones = [], options = {}) {\n    if (!state.audioAvailable || state.muted) return;\n    if (!state.soundContext) return;\n    try {\n      const ctx = state.soundContext;\n      const now = ctx.currentTime;\n      const masterGain = ctx.createGain();\n      masterGain.gain.value = options.volume ?? 0.08;\n      masterGain.connect(ctx.destination);\n      let t = now;\n      tones.forEach((tone, i) => {\n        const osc = ctx.createOscillator();\n        const gain = ctx.createGain();\n        osc.type = tone.type || \"sine\";\n        osc.frequency.value = tone.freq;\n        gain.gain.setValueAtTime(0.0001, t);\n        gain.gain.exponentialRampToValueAtTime(1, t + 0.02);\n        gain.gain.exponentialRampToValueAtTime(0.001, t + (tone.dur ?? 0.15));\n        osc.connect(gain).connect(masterGain);\n        osc.start(t);\n        osc.stop(t + (tone.dur ?? 0.15) + 0.02);\n        t += (tone.dur ?? 0.15) + (tone.pause ?? 0.02);\n      });\n      // cleanup after longest tone\n      setTimeout(() => {\n        try { masterGain.disconnect(); } catch (e) {}\n      }, 1000);\n    } catch (err) {\n      console.warn(\"playToneSequence error:\", err);\n    }\n  }\n\n  function playCorrect() {\n    // pleasant ascending arpeggio\n    playToneSequence([\n      { freq: 440, dur: 0.12, type: \"sine\" },\n      { freq: 550, dur: 0.12, type: \"sine\" },\n      { freq: 660, dur: 0.16, type: \"sine\" }\n    ], { volume: 0.06 });\n  }\n\n  function playIncorrect() {\n    // low buzz\n    playToneSequence([\n      { freq: 120, dur: 0.25, type: \"sawtooth\" }\n    ], { volume: 0.12 });\n  }\n\n  function playPick() {\n    playToneSequence([{ freq: 660, dur: 0.08 }], { volume: 0.04 });\n  }\n\n  function playDrop() {\n    playToneSequence([{ freq: 330, dur: 0.08 }], { volume: 0.04 });\n  }\n\n  // Accessibility live announcements\n  function liveAnnounce(text) {\n    if (!liveRegion) return;\n    liveRegion.textContent = \"\";\n    // Short timeout to ensure SR reads new text\n    setTimeout(() => liveRegion.textContent = text, 50);\n  }\n\n  // Level generation ensuring solvability\n  function generateLevel(level) {\n    // Construct a set of numbers with a guaranteed solution\n    const bubbles = [];\n    const subsetSize = Math.min(1 + (level % 3), SLOT_COUNT); // 1 to 3\n    const baseNumbers = [];\n    for (let i = 0; i < subsetSize; i++) {\n      baseNumbers.push(randInt(1 + level, 4 + level + 4)); // slightly increasing\n    }\n    const target = baseNumbers.reduce((a, b) => a + b, 0);\n\n    // Fill additional numbers\n    while (baseNumbers.length < NUM_BUBBLES) {\n      // Avoid creating duplicates of the exact target parts too often\n      const candidate = randInt(1, Math.max(6, 6 + level));\n      baseNumbers.push(candidate);\n    }\n\n    // Shuffle and position them\n    for (let i = 0; i < NUM_BUBBLES; i++) {\n      const val = baseNumbers[i];\n      const x = 120 + (i % 3) * 90 + randInt(-6, 6);\n      const y = 110 + Math.floor(i / 3) * 80 + randInt(-6, 6);\n      bubbles.push({ x, y, val, visible: true, id: i });\n    }\n\n    return { target, bubbles };\n  }\n\n  // Initialize or reset the level\n  function startLevel(levelNumber) {\n    const lvl = clamp(levelNumber, 1, MAX_LEVEL);\n    state.level = lvl;\n    state.slots = new Array(SLOT_COUNT).fill(null);\n    state.robot.holding = null;\n    state.levelSolved = false;\n    const lvlData = generateLevel(lvl);\n    state.target = lvlData.target;\n    state.bubbles = lvlData.bubbles;\n    state.message = `Level ${lvl} \u2014 Make the machine equal ${state.target}.`;\n    state.messageTimer = 300; // frames\n    liveAnnounce(`Level ${lvl}. Target number ${state.target}. Use arrows to move robot and space to pick up numbers.`);\n  }\n\n  // Check if subset of slots sums to target\n  function checkSolution() {\n    const sum = state.slots.reduce((acc, s) => acc + (s === null ? 0 : s), 0);\n    if (sum === state.target) {\n      // Win\n      state.score += 10 * state.level;\n      state.levelSolved = true;\n      state.message = \"Correct! Machine is happy.\";\n      state.messageTimer = 240;\n      playCorrect();\n      liveAnnounce(`Correct! You solved level ${state.level}.`);\n      // Proceed to next level after short delay\n      setTimeout(() => {\n        if (state.level < MAX_LEVEL) {\n          startLevel(state.level + 1);\n        } else {\n          state.message = \"You finished all levels! Great job!\";\n          liveAnnounce(\"Congratulations! You finished all levels!\");\n        }\n      }, 1500);\n    } else {\n      // Incorrect\n      state.message = `Not quite. Current sum ${sum}, target ${state.target}. Try again.`;\n      state.messageTimer = 240;\n      playIncorrect();\n      liveAnnounce(`Try again. Current sum ${sum}, target ${state.target}.`);\n      // Reset slots and return numbers back\n      state.slots.forEach((s, idx) => {\n        if (s !== null) {\n          // find a hidden spot to put it back\n          const bubble = state.bubbles.find(b => b.val === s && !b.visible);\n          if (bubble) {\n            bubble.visible = true;\n          } else {\n            // create a new bubble to avoid loss\n            state.bubbles.push({ x: 120 + (idx * 60) % 240, y: 240, val: s, visible: true, id: Date.now() + idx });\n          }\n        }\n      });\n      state.slots = new Array(SLOT_COUNT).fill(null);\n      state.robot.holding = null;\n    }\n  }\n\n  // Robot picks up the nearest visible bubble within range\n  function robotPickOrDrop() {\n    const r = state.robot;\n    if (r.holding === null) {\n      // Try pick a bubble near robot\n      let nearest = null;\n      let nearestDist = 9999;\n      for (const b of state.bubbles) {\n        if (!b.visible) continue;\n        const dx = b.x - r.x;\n        const dy = b.y - r.y;\n        const d = Math.hypot(dx, dy);\n        if (d < nearestDist && d < 60) {\n          nearestDist = d;\n          nearest = b;\n        }\n      }\n      if (nearest) {\n        r.holding = { val: nearest.val, id: nearest.id };\n        nearest.visible = false;\n        state.message = `Picked up ${r.holding.val}.`;\n        state.messageTimer = 140;\n        playPick();\n        liveAnnounce(`Picked up ${r.holding.val}.`);\n      } else {\n        state.message = \"No number close enough to pick. Move closer.\";\n        state.messageTimer = 120;\n      }\n    } else {\n      // Try drop into an empty slot if robot is near machine\n      const machineX = WIDTH - 220;\n      const machineY = HEIGHT / 2;\n      const dx = r.x - machineX;\n      const dy = r.y - machineY;\n      const d = Math.hypot(dx, dy);\n      if (d < 120) {\n        // find empty slot\n        let placed = false;\n        for (let i = 0; i < SLOT_COUNT; i++) {\n          if (state.slots[i] === null) {\n            state.slots[i] = r.holding.val;\n            r.holding = null;\n            state.message = \"Dropped into machine.\";\n            state.messageTimer = 120;\n            playDrop();\n            liveAnnounce(\"Dropped number into machine.\");\n            placed = true;\n            break;\n          }\n        }\n        if (!placed) {\n          state.message = \"All machine slots are full. Press Enter to check or remove a number.\";\n          state.messageTimer = 160;\n        }\n      } else {\n        // drop back to nearest bubble area (failsafe)\n        const droppedBack = { x: r.x + randInt(-20, 20), y: r.y + randInt(-20, 20), val: r.holding.val, visible: true, id: Date.now() };\n        state.bubbles.push(droppedBack);\n        r.holding = null;\n        playDrop();\n        state.message = \"Dropped the number back.\";\n        state.messageTimer = 120;\n      }\n    }\n  }\n\n  // Remove a filled slot (player can move robot near machine and press Space to pick a number out)\n  function robotPickupFromSlot() {\n    const r = state.robot;\n    const machineX = WIDTH - 220;\n    const machineY = HEIGHT / 2;\n    const dx = r.x - machineX;\n    const dy = r.y - machineY;\n    const d = Math.hypot(dx, dy);\n    if (d < 120 && r.holding === null) {\n      // pick from last non-empty slot\n      for (let i = SLOT_COUNT - 1; i >= 0; i--) {\n        if (state.slots[i] !== null) {\n          r.holding = { val: state.slots[i], fromSlot: i };\n          state.slots[i] = null;\n          playPick();\n          state.message = `Picked up ${r.holding.val} from slot ${i + 1}.`;\n          state.messageTimer = 140;\n          liveAnnounce(`Picked up ${r.holding.val} from slot ${i + 1}.`);\n          return true;\n        }\n      }\n      state.message = \"No numbers in machine to pick up.\";\n      state.messageTimer = 120;\n      return false;\n    }\n    return false;\n  }\n\n  // Keyboard and mouse controls\n  const keys = {};\n  window.addEventListener(\"keydown\", (e) => {\n    if (e.key === \"ArrowLeft\" || e.key === \"ArrowRight\" || e.key === \" \" || e.key === \"Enter\" || e.key === \"m\" || e.key === \"M\" || e.key === \"r\" || e.key === \"R\") {\n      e.preventDefault();\n    }\n    keys[e.key] = true;\n\n    // initialize audio on first user gesture\n    if (state.awaitingUserGesture) {\n      initAudio();\n      resumeAudioOnUserGesture();\n      state.awaitingUserGesture = false;\n    }\n\n    // Shortcuts\n    if (e.key === \"m\" || e.key === \"M\") {\n      state.muted = !state.muted;\n      if (state.muted) {\n        liveAnnounce(\"Audio muted.\");\n      } else {\n        liveAnnounce(\"Audio unmuted.\");\n      }\n    }\n    if (e.key === \"r\" || e.key === \"R\") {\n      startLevel(state.level);\n      liveAnnounce(`Level ${state.level} restarted.`);\n    }\n  });\n\n  window.addEventListener(\"keyup\", (e) => {\n    keys[e.key] = false;\n  });\n\n  // Allow clicking/tapping to pick/drop\n  canvas.addEventListener(\"click\", (ev) => {\n    // initialize audio on user gesture\n    if (state.awaitingUserGesture) {\n      initAudio();\n      resumeAudioOnUserGesture();\n      state.awaitingUserGesture = false;\n      liveAnnounce(\"Audio enabled.\");\n    }\n    const rect = canvas.getBoundingClientRect();\n    const cx = ev.clientX - rect.left;\n    const cy = ev.clientY - rect.top;\n    // If clicked near speaker icon toggle mute\n    if (cx < 46 && cy < 46) {\n      state.muted = !state.muted;\n      liveAnnounce(state.muted ? \"Audio muted.\" : \"Audio unmuted.\");\n      return;\n    }\n    // If near robot, pick/drop\n    const r = state.robot;\n    const dx = cx - r.x;\n    const dy = cy - r.y;\n    if (Math.hypot(dx, dy) < 80) {\n      // if near machine area and holding something then drop, else pick\n      if (state.robot.holding !== null) {\n        robotPickOrDrop();\n      } else {\n        // try pick from slot first if clicking near machine\n        const machineX = WIDTH - 220;\n        const machineY = HEIGHT / 2;\n        const d2 = Math.hypot(cx - machineX, cy - machineY);\n        if (d2 < 120) {\n          robotPickupFromSlot();\n        } else {\n          robotPickOrDrop();\n        }\n      }\n      return;\n    }\n    // Else click nearest bubble to pick directly\n    let picked = false;\n    for (const b of state.bubbles) {\n      if (b.visible) {\n        const dbx = cx - b.x;\n        const dby = cy - b.y;\n        if (Math.hypot(dbx, dby) < 28) {\n          // move robot near to that bubble and pick\n          state.robot.x = clamp(b.x, 40, WIDTH - 40);\n          state.robot.y = clamp(b.y + 40, HEIGHT - 120, HEIGHT - 40);\n          if (!state.robot.holding) {\n            state.robot.holding = { val: b.val, id: b.id };\n            b.visible = false;\n            state.message = `Picked up ${b.val}.`;\n            state.messageTimer = 120;\n            playPick();\n            liveAnnounce(`Picked up ${b.val}.`);\n          }\n          picked = true;\n          break;\n        }\n      }\n    }\n    if (!picked) {\n      // if clicked on machine area, try to pick from slot\n      const machineX = WIDTH - 220;\n      const machineY = HEIGHT / 2;\n      if (Math.hypot(cx - machineX, cy - machineY) < 140) {\n        robotPickupFromSlot();\n      }\n    }\n  });\n\n  // Main update loop\n  function update() {\n    // Movement\n    if (keys[\"ArrowLeft\"]) {\n      state.robot.x -= state.robot.speed;\n      if (state.robot.x < 40) state.robot.x = 40;\n    }\n    if (keys[\"ArrowRight\"]) {\n      state.robot.x += state.robot.speed;\n      if (state.robot.x > WIDTH - 40) state.robot.x = WIDTH - 40;\n    }\n\n    // Pick/drop with space\n    if (keys[\" \"]) {\n      if (!state._spaceHeld) {\n        // single action on press\n        // if near machine and holding nothing, pick from slot\n        const machineX = WIDTH - 220;\n        const machineY = HEIGHT / 2;\n        const d = Math.hypot(state.robot.x - machineX, state.robot.y - machineY);\n        if (d < 120 && state.robot.holding === null) {\n          robotPickupFromSlot();\n        } else {\n          robotPickOrDrop();\n        }\n        state._spaceHeld = true;\n      }\n    } else {\n      state._spaceHeld = false;\n    }\n\n    // Submit with Enter\n    if (keys[\"Enter\"]) {\n      if (!state._enterHeld) {\n        checkSolution();\n        state._enterHeld = true;\n      }\n    } else {\n      state._enterHeld = false;\n    }\n\n    // Update bubble floatiness\n    for (const b of state.bubbles) {\n      if (!b.visible) continue;\n      // small up/down drifting\n      b.y += Math.sin((Date.now() + b.id * 47) / 500) * 0.2;\n      b.x += Math.cos((Date.now() + b.id * 31) / 700) * 0.08;\n    }\n\n    // message timer decay\n    if (state.messageTimer > 0) {\n      state.messageTimer--;\n      if (state.messageTimer === 0) {\n        state.message = \"\";\n      }\n    }\n  }\n\n  // Drawing functions\n  function drawBackground() {\n    // sky background\n    ctx.fillStyle = COLORS.bg;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // faint diagonal stripes for a calming pattern\n    ctx.save();\n    ctx.globalAlpha = 0.08;\n    ctx.fillStyle = COLORS.accent;\n    for (let i = -HEIGHT; i < WIDTH; i += 40) {\n      ctx.beginPath();\n      ctx.moveTo(i, 0);\n      ctx.lineTo(i + 20, 0);\n      ctx.lineTo(i + HEIGHT + 20, HEIGHT);\n      ctx.lineTo(i + HEIGHT, HEIGHT);\n      ctx.closePath();\n      ctx.fill();\n    }\n    ctx.restore();\n\n    // Ground platform\n    ctx.fillStyle = \"#e9f4f8\";\n    ctx.fillRect(0, HEIGHT - 80, WIDTH, 80);\n\n    // Wacky pipes on left\n    ctx.save();\n    ctx.translate(40, 40);\n    for (let i = 0; i < 3; i++) {\n      ctx.fillStyle = i % 2 === 0 ? COLORS.gear : COLORS.machine;\n      ctx.fillRect(i * 40, 60 + i * 14, 100, 18);\n      ctx.beginPath();\n      ctx.arc(i * 40 + 8, 60 + i * 14 + 9, 12, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    ctx.restore();\n\n    // Large soothing gear shapes\n    drawGear(180, 70, 40, 8, COLORS.gear, 0.08);\n    drawGear(260, 50, 28, 6, COLORS.gear, -0.05);\n    drawGear(110, 130, 22, 6, COLORS.gear, 0.06);\n  }\n\n  function drawGear(cx, cy, radius, teeth, color, rotateOffset) {\n    ctx.save();\n    ctx.translate(cx, cy);\n    ctx.rotate((Date.now() / 500) * rotateOffset);\n    ctx.fillStyle = color;\n    for (let i = 0; i < teeth; i++) {\n      ctx.beginPath();\n      const a1 = (i / teeth) * Math.PI * 2;\n      const a2 = a1 + (Math.PI * 2 / teeth) * 0.6;\n      ctx.moveTo(Math.cos(a1) * radius, Math.sin(a1) * radius);\n      ctx.lineTo(Math.cos(a1) * (radius + 8), Math.sin(a1) * (radius + 8));\n      ctx.lineTo(Math.cos(a2) * radius, Math.sin(a2) * radius);\n      ctx.closePath();\n      ctx.fill();\n    }\n    ctx.beginPath();\n    ctx.fillStyle = \"#fff\";\n    ctx.arc(0, 0, radius - 6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function drawBubbles() {\n    for (const b of state.bubbles) {\n      if (!b.visible) continue;\n      ctx.save();\n      ctx.beginPath();\n      ctx.fillStyle = COLORS.bubble;\n      ctx.strokeStyle = \"#d1bfa9\";\n      ctx.lineWidth = 2;\n      ctx.arc(b.x, b.y, 28, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n\n      // subtle highlight\n      ctx.beginPath();\n      ctx.fillStyle = \"rgba(255,255,255,0.6)\";\n      ctx.ellipse(b.x - 10, b.y - 12, 10, 6, -0.5, 0, Math.PI * 2);\n      ctx.fill();\n\n      // number\n      ctx.fillStyle = COLORS.bubbleText;\n      ctx.font = \"bold 18px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillText(String(b.val), b.x, b.y);\n      ctx.restore();\n    }\n  }\n\n  function drawMachine() {\n    const mx = WIDTH - 320;\n    const my = HEIGHT / 2 - 40;\n    // Machine body\n    ctx.save();\n    ctx.fillStyle = COLORS.machine;\n    roundRect(ctx, mx, my, 300, 260, 18, true, false);\n    // control panel\n    ctx.fillStyle = \"#cfeaf6\";\n    roundRect(ctx, mx + 20, my + 18, 260, 60, 10, true, false);\n\n    // display target\n    ctx.fillStyle = COLORS.accent;\n    roundRect(ctx, mx + 40, my + 28, 200, 36, 8, true, false);\n    ctx.fillStyle = COLORS.text;\n    ctx.font = \"bold 22px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"TARGET: \" + state.target, mx + 140, my + 52);\n\n    // draw slots\n    const slotStartX = mx + 42;\n    const slotY = my + 110;\n    for (let i = 0; i < SLOT_COUNT; i++) {\n      const sx = slotStartX + i * 90;\n      ctx.fillStyle = state.slots[i] === null ? COLORS.slotEmpty : COLORS.slotFilled;\n      roundRect(ctx, sx, slotY, 70, 70, 10, true, true);\n      if (state.slots[i] !== null) {\n        // fill number inside\n        ctx.fillStyle = COLORS.bubbleText;\n        ctx.font = \"bold 26px sans-serif\";\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillText(String(state.slots[i]), sx + 35, slotY + 35);\n      } else {\n        // draw small indicator\n        ctx.fillStyle = \"#c6d3db\";\n        ctx.font = \"12px sans-serif\";\n        ctx.textAlign = \"center\";\n        ctx.fillText(\"slot \" + (i + 1), sx + 35, slotY + 60);\n      }\n    }\n\n    // Machine smiley (if solved)\n    ctx.fillStyle = state.levelSolved ? COLORS.good : \"#7fb2c9\";\n    ctx.beginPath();\n    ctx.ellipse(mx + 180, my + 200, 36, 24, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = \"#fff\";\n    ctx.font = \"12px sans-serif\";\n    ctx.fillText(state.levelSolved ? \"Machine happy\" : \"Machine\", mx + 180, my + 200);\n    ctx.restore();\n  }\n\n  function roundRect(ctx, x, y, w, h, r, fill, stroke) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  function drawRobot() {\n    const r = state.robot;\n    ctx.save();\n    ctx.translate(r.x, r.y);\n\n    // shadow\n    ctx.beginPath();\n    ctx.fillStyle = \"rgba(30,30,30,0.08)\";\n    ctx.ellipse(0, 46, 46, 14, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // body\n    ctx.fillStyle = COLORS.robot;\n    roundRect(ctx, -28, -28, 56, 56, 8, true, true);\n    // head\n    ctx.fillStyle = \"#fff\";\n    roundRect(ctx, -20, -50, 40, 30, 6, true, true);\n    // eye\n    ctx.fillStyle = \"#21495A\";\n    ctx.beginPath();\n    ctx.arc(0, -35, 5, 0, Math.PI * 2);\n    ctx.fill();\n\n    // arms\n    ctx.strokeStyle = \"#bde5c9\";\n    ctx.lineWidth = 5;\n    ctx.beginPath();\n    ctx.moveTo(-20, -10);\n    ctx.lineTo(-42, 8);\n    ctx.moveTo(20, -10);\n    ctx.lineTo(48, 20);\n    ctx.stroke();\n\n    // wheel\n    ctx.fillStyle = \"#cbdfe1\";\n    ctx.beginPath();\n    ctx.arc(0, 38, 22, 0, Math.PI * 2);\n    ctx.fill();\n\n    // holding number bubble (if any)\n    if (r.holding) {\n      ctx.save();\n      ctx.translate(36, -8);\n      ctx.beginPath();\n      ctx.fillStyle = COLORS.bubble;\n      ctx.arc(0, 0, 20, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.fillStyle = COLORS.bubbleText;\n      ctx.font = \"bold 16px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillText(String(r.holding.val), 0, 0);\n      ctx.restore();\n    }\n\n    ctx.restore();\n  }\n\n  function drawHUD() {\n    // Top-left speaker icon\n    ctx.save();\n    ctx.translate(12, 12);\n    ctx.beginPath();\n    ctx.fillStyle = state.muted ? COLORS.speakerOff : COLORS.speakerOn;\n    ctx.fillRect(0, 10, 8, 12);\n    ctx.beginPath();\n    ctx.moveTo(10, 10);\n    ctx.lineTo(20, 6);\n    ctx.lineTo(20, 26);\n    ctx.lineTo(10, 22);\n    ctx.closePath();\n    ctx.fill();\n\n    if (!state.muted) {\n      ctx.beginPath();\n      ctx.strokeStyle = COLORS.speakerOn;\n      ctx.lineWidth = 2;\n      ctx.arc(26, 16, 8, -0.9, 0.9);\n      ctx.stroke();\n    } else {\n      // cross\n      ctx.strokeStyle = COLORS.speakerOff;\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(6, 6);\n      ctx.lineTo(34, 26);\n      ctx.moveTo(34, 6);\n      ctx.lineTo(6, 26);\n      ctx.stroke();\n    }\n    ctx.restore();\n\n    // Level and score\n    ctx.fillStyle = COLORS.text;\n    ctx.font = \"16px sans-serif\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(`Level ${state.level}`, 12, 60);\n    ctx.fillText(`Score ${state.score}`, 12, 82);\n\n    // Instructions\n    ctx.font = \"12px sans-serif\";\n    ctx.fillStyle = \"#29586a\";\n    ctx.fillText(\"\u2190 \u2192 to move  \u2022  Space to pick/drop  \u2022  Enter to check  \u2022  M to mute  \u2022  R restart\", 120, 28);\n\n    // Message box\n    if (state.message) {\n      ctx.save();\n      ctx.globalAlpha = 0.95;\n      roundRect(ctx, WIDTH / 2 - 200, 18, 400, 36, 8, true, false);\n      ctx.fillStyle = COLORS.text;\n      ctx.font = \"14px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(state.message, WIDTH / 2, 42);\n      ctx.restore();\n    }\n  }\n\n  function draw() {\n    // Clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    // Draw everything\n    drawBackground();\n    drawBubbles();\n    drawMachine();\n    drawRobot();\n    drawHUD();\n  }\n\n  // Main loop\n  function loop() {\n    try {\n      update();\n      draw();\n      requestAnimationFrame(loop);\n    } catch (err) {\n      console.error(\"Game loop error:\", err);\n    }\n  }\n\n  // Initial start\n  startLevel(1);\n  initAudio(); // attempt silent init; will be resumed on gesture\n  loop();\n\n  // Expose a safe reset method on the canvas element for debug or accessibility\n  canvas.resetGame = function() {\n    stopAllSounds();\n    state = {\n      level: 1,\n      target: 0,\n      bubbles: [],\n      slots: new Array(SLOT_COUNT).fill(null),\n      robot: { x: WIDTH / 2, y: HEIGHT - 70, speed: 6, holding: null },\n      score: 0,\n      message: \"Resetting game.\",\n      messageTimer: 120,\n      audioEnabled: false,\n      audioAvailable: true,\n      muted: false,\n      bgHum: null,\n      soundContext: null,\n      awaitingUserGesture: true,\n      levelSolved: false\n    };\n    startLevel(1);\n    initAudio();\n  };\n\n  // Provide error handling for audio context creation attempts after user gesture\n  window.addEventListener(\"click\", () => {\n    if (!state.soundContext && !state.audioAvailable) {\n      try {\n        initAudio();\n        resumeAudioOnUserGesture();\n      } catch (err) {\n        console.warn(\"Audio gesture init error:\", err);\n      }\n    }\n  });\n\n  // Graceful unload: stop audio\n  window.addEventListener(\"beforeunload\", () => {\n    try {\n      stopAllSounds();\n    } catch (e) {}\n  });\n\n})();\n---\n",
  "improve_response_tokens": 19016,
  "formatted_code": true,
  "formatting_response_tokens": 20955,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}