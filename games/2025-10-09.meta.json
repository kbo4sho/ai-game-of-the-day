{
  "generated_date": "2025-10-09",
  "generated_timestamp": "2025-10-09T00:26:44.538332",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 10016,
  "game_filename": "2025-10-09.js",
  "game_size_bytes": 29698,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function() {\n  // Educational Math Game: \"Machine Menders\"\n  // Ages: 7-9. Theme: machines. Canvas-based visuals + Web Audio API.\n  // Renders inside an element with ID \"game-of-the-day-stage\".\n  // All visuals drawn on canvas. All sounds generated programmatically.\n  // Author: expert educational game designer (AI-generated).\n  'use strict';\n\n  // Utility functions\n  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));\n  const rand = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;\n  const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];\n  const easeOut = t => 1 - Math.pow(1 - t, 3);\n\n  // Find stage element\n  const stage = document.getElementById('game-of-the-day-stage');\n  if (!stage) {\n    console.error('Game container with ID \"game-of-the-day-stage\" not found.');\n    return;\n  }\n\n  // Clear stage\n  while (stage.firstChild) stage.removeChild(stage.firstChild);\n\n  // Create accessible text area (for screen readers and instructions).\n  const sr = document.createElement('div');\n  sr.setAttribute('role', 'region');\n  sr.setAttribute('aria-live', 'polite');\n  sr.style.position = 'absolute';\n  sr.style.left = '-9999px';\n  sr.style.width = '1px';\n  sr.style.height = '1px';\n  sr.style.overflow = 'hidden';\n  sr.id = 'machine-menders-sr';\n  stage.appendChild(sr);\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = 720;\n  canvas.height = 480;\n  canvas.style.width = '720px';\n  canvas.style.height = '480px';\n  canvas.setAttribute('role', 'img');\n  canvas.setAttribute('aria-label', 'Machine Menders math game canvas');\n  stage.appendChild(canvas);\n\n  const ctx = canvas.getContext('2d');\n\n  // Audio setup with error handling\n  let audioContext = null;\n  try {\n    const AC = window.AudioContext || window.webkitAudioContext;\n    if (AC) {\n      audioContext = new AC();\n    } else {\n      audioContext = null;\n      console.warn('Web Audio API is not supported in this browser.');\n    }\n  } catch (e) {\n    audioContext = null;\n    console.warn('Error creating AudioContext:', e);\n  }\n\n  // Manage audio state and sound functions\n  let audioEnabled = false;\n  let bgGain = null;\n  let bgOsc = null;\n  let lfo = null;\n\n  function createBackgroundSound() {\n    if (!audioContext) return;\n    try {\n      bgGain = audioContext.createGain();\n      bgGain.gain.value = 0.02; // very gentle\n      bgGain.connect(audioContext.destination);\n\n      bgOsc = audioContext.createOscillator();\n      bgOsc.type = 'sine';\n      bgOsc.frequency.value = 220;\n      bgOsc.connect(bgGain);\n\n      // Gentle movement: LFO to modulate frequency\n      lfo = audioContext.createOscillator();\n      const lfoGain = audioContext.createGain();\n      lfo.type = 'sine';\n      lfo.frequency.value = 0.25; // very slow\n      lfoGain.gain.value = 30;\n      lfo.connect(lfoGain);\n      lfoGain.connect(bgOsc.frequency);\n\n      bgOsc.start();\n      lfo.start();\n      audioEnabled = true;\n      updateSR('Sound enabled.');\n    } catch (e) {\n      console.warn('Error creating background sound:', e);\n      audioEnabled = false;\n      updateSR('Sound could not be enabled.');\n    }\n  }\n\n  function stopBackgroundSound() {\n    if (!audioContext) return;\n    try {\n      if (bgOsc) {\n        bgOsc.stop();\n        bgOsc.disconnect();\n        bgOsc = null;\n      }\n      if (lfo) {\n        lfo.stop();\n        lfo.disconnect();\n        lfo = null;\n      }\n      if (bgGain) {\n        bgGain.disconnect();\n        bgGain = null;\n      }\n      audioEnabled = false;\n      updateSR('Sound disabled.');\n    } catch (e) {\n      console.warn('Error stopping background sound:', e);\n    }\n  }\n\n  // Play a tone for feedback; uses oscillator + filter + gain envelope\n  function playTone(freq = 440, type = 'sine', duration = 0.4, volume = 0.12) {\n    if (!audioContext || !audioEnabled) return;\n    try {\n      const now = audioContext.currentTime;\n      const o = audioContext.createOscillator();\n      const g = audioContext.createGain();\n      const f = audioContext.createBiquadFilter();\n      o.type = type;\n      o.frequency.value = freq;\n      f.type = 'lowpass';\n      f.frequency.value = Math.max(800, freq * 2);\n      g.gain.value = 0.0001;\n\n      o.connect(f);\n      f.connect(g);\n      g.connect(audioContext.destination);\n\n      // Envelope\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(volume, now + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);\n\n      o.start(now);\n      o.stop(now + duration + 0.05);\n    } catch (e) {\n      console.warn('playTone error:', e);\n    }\n  }\n\n  // Feedback sounds\n  function playCorrect() {\n    // pleasant arpeggio\n    playTone(660, 'sine', 0.14, 0.12);\n    setTimeout(() => playTone(880, 'sine', 0.18, 0.12), 140);\n    setTimeout(() => playTone(990, 'sine', 0.22, 0.12), 320);\n  }\n  function playIncorrect() {\n    // soft buzz\n    if (!audioContext || !audioEnabled) return;\n    try {\n      const now = audioContext.currentTime;\n      const o = audioContext.createOscillator();\n      const g = audioContext.createGain();\n      const f = audioContext.createBiquadFilter();\n      o.type = 'sawtooth';\n      o.frequency.value = 120;\n      f.type = 'lowpass';\n      f.frequency.value = 500;\n      o.connect(f);\n      f.connect(g);\n      g.connect(audioContext.destination);\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(0.08, now + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);\n      o.start(now);\n      o.stop(now + 0.36);\n    } catch (e) {\n      console.warn('playIncorrect error:', e);\n    }\n  }\n\n  // Game constants\n  const WIDTH = canvas.width;\n  const HEIGHT = canvas.height;\n  const MACHINE_X = WIDTH / 2;\n  const MACHINE_Y = HEIGHT / 2 + 10;\n  const MAX_LEVELS = 8;\n  const START_LIVES = 3;\n\n  // Game state class\n  class Game {\n    constructor() {\n      this.level = 0;\n      this.lives = START_LIVES;\n      this.score = 0;\n      this.state = 'menu'; // menu, playing, win, lose, anim\n      this.parts = []; // interactive options\n      this.target = null; // expression object\n      this.selectorIndex = 0; // keyboard selection\n      this.anim = { t: 0 };\n      this.lastTime = performance.now();\n      this.shake = 0;\n      this.paused = false;\n      this.soundAllowed = !!audioEnabled;\n      this.initInput();\n      this.generateLevel();\n      this._bindVisibility();\n      this.updateSRInstructions();\n      this.requester = null;\n      this.loop = this.loop.bind(this);\n      this.loop();\n    }\n\n    updateSRInstructions() {\n      const controls = [\n        'Keyboard: arrow keys to move selection, Enter or Space to pick, number keys 1\u20134 to choose a part.',\n        'Click or tap a part to select it.',\n        'Press S to toggle sound.',\n        'Press R to restart the game when over.'\n      ];\n      updateSR(\n        `Welcome to Machine Menders. Fix machines by choosing the correct part to complete the math. ` +\n        `You have ${START_LIVES} hearts. ` +\n        `Controls: ${controls.join(' ')}`\n      );\n    }\n\n    _bindVisibility() {\n      document.addEventListener('visibilitychange', () => {\n        if (document.hidden) {\n          // stop background sound gently\n          if (audioContext && audioEnabled) {\n            audioContext.suspend().catch(() => {});\n          }\n        } else {\n          if (audioContext && audioEnabled) {\n            audioContext.resume().catch(() => {});\n          }\n        }\n      });\n    }\n\n    initInput() {\n      // Mouse and touch handlers\n      canvas.addEventListener('click', (e) => {\n        const rect = canvas.getBoundingClientRect();\n        const x = (e.clientX - rect.left) * (canvas.width / rect.width);\n        const y = (e.clientY - rect.top) * (canvas.height / rect.height);\n        if (this.state === 'menu') {\n          // Start on click\n          this.startGame();\n          return;\n        }\n        if (this.state === 'win' || this.state === 'lose') {\n          // Restart on click\n          this.restart();\n          return;\n        }\n        // detect which part clicked\n        for (let i = 0; i < this.parts.length; i++) {\n          const p = this.parts[i];\n          const dx = x - p.x;\n          const dy = y - p.y;\n          if (Math.hypot(dx, dy) < p.radius + 8) {\n            this.pickPart(i);\n            return;\n          }\n        }\n      });\n\n      // Keyboard controls\n      window.addEventListener('keydown', (e) => {\n        if (e.defaultPrevented) return;\n        if (this.state === 'menu' && (e.key === ' ' || e.key === 'Enter')) {\n          e.preventDefault();\n          this.startGame();\n          return;\n        }\n        if (e.key.toLowerCase() === 's') {\n          e.preventDefault();\n          this.toggleSound();\n          return;\n        }\n        if ((this.state === 'win' || this.state === 'lose') && e.key.toLowerCase() === 'r') {\n          e.preventDefault();\n          this.restart();\n          return;\n        }\n        if (this.state !== 'playing') return;\n        if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {\n          e.preventDefault();\n          this.selectorIndex = (this.selectorIndex - 1 + this.parts.length) % this.parts.length;\n          this.updateSRSelection();\n        } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {\n          e.preventDefault();\n          this.selectorIndex = (this.selectorIndex + 1) % this.parts.length;\n          this.updateSRSelection();\n        } else if (e.key === 'Enter' || e.key === ' ') {\n          e.preventDefault();\n          this.pickPart(this.selectorIndex);\n        } else {\n          // number keys 1-4\n          const n = parseInt(e.key, 10);\n          if (!Number.isNaN(n) && n >= 1 && n <= 9) {\n            if (n <= this.parts.length) {\n              e.preventDefault();\n              this.pickPart(n - 1);\n            }\n          }\n        }\n      });\n    }\n\n    toggleSound() {\n      if (!audioContext) {\n        updateSR('Sound unavailable on this device.');\n        return;\n      }\n      // If audio hasn't been allowed by user gesture, resume/create on first toggle\n      if (!audioEnabled) {\n        // Some browsers require resume on user gesture\n        audioContext.resume().then(() => {\n          createBackgroundSound();\n        }).catch((err) => {\n          console.warn('Audio resume failed:', err);\n          updateSR('Unable to enable sound due to browser restrictions.');\n        });\n      } else {\n        stopBackgroundSound();\n      }\n      this.soundAllowed = audioEnabled;\n    }\n\n    generateLevel() {\n      // Prepare level math: either addition or subtraction\n      const levelNum = this.level + 1;\n      const type = levelNum <= 3 ? 'add' : (levelNum <= 6 ? pick(['add', 'sub']) : pick(['add', 'sub']));\n      const maxTarget = 10 + levelNum * 2;\n      let a, b, target, missingOnLeft = Math.random() < 0.5;\n      if (type === 'add') {\n        a = rand(1, Math.max(4, Math.min(12, maxTarget - 1)));\n        b = rand(1, Math.max(3, Math.min(12, maxTarget - a)));\n        target = a + b;\n      } else {\n        // b = a - target (we want positive numbers)\n        a = rand(5, Math.max(6, Math.min(18, maxTarget)));\n        target = rand(1, Math.max(3, Math.min(10, a - 1)));\n        b = a - target;\n      }\n      // We'll show expression like \"a + ? = target\" or \"? + b = target\"\n      const missingValue = missingOnLeft ? a : b;\n      const expression = {\n        type,\n        a,\n        b,\n        target,\n        missingOnLeft,\n        missingValue\n      };\n      this.target = expression;\n\n      // Create parts (options)\n      const correct = missingValue;\n      const choices = new Set([correct]);\n      while (choices.size < 4) {\n        const delta = pick([-4, -3, -2, -1, 1, 2, 3, 4]);\n        choices.add(clamp(correct + delta, 0, Math.max(1, correct + 6)));\n      }\n      const arr = Array.from(choices);\n      // shuffle\n      for (let i = arr.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [arr[i], arr[j]] = [arr[j], arr[i]];\n      }\n\n      // Place parts in positions around machine\n      const ringRadius = 160;\n      this.parts = arr.map((val, idx) => {\n        const angle = (Math.PI * 2 * idx) / arr.length - Math.PI / 2 + (Math.random() - 0.5) * 0.2;\n        const px = MACHINE_X + Math.cos(angle) * ringRadius + rand(-10, 10);\n        const py = MACHINE_Y + Math.sin(angle) * ringRadius + rand(-10, 10);\n        return {\n          value: val,\n          x: px,\n          y: py,\n          baseX: px,\n          baseY: py,\n          radius: 36,\n          wobble: Math.random() * Math.PI * 2\n        };\n      });\n\n      this.selectorIndex = 0;\n      this.shake = 0;\n      this.anim = { t: 0 };\n      this.state = 'playing';\n      updateSR(`Level ${this.level + 1}. Fix the machine: ${this.getExpressionText()}. Choose the correct part.`);\n    }\n\n    getExpressionText() {\n      const e = this.target;\n      if (!e) return '';\n      if (e.type === 'add') {\n        if (e.missingOnLeft) return `? + ${e.b} = ${e.target}`;\n        return `${e.a} + ? = ${e.target}`;\n      } else {\n        if (e.missingOnLeft) return `? - ${e.b} = ${e.target}`;\n        return `${e.a} - ? = ${e.target}`;\n      }\n    }\n\n    pickPart(index) {\n      if (this.state !== 'playing') return;\n      if (index < 0 || index >= this.parts.length) return;\n      const part = this.parts[index];\n      this.selectorIndex = index;\n      // animate part moving to machine\n      part.picked = true;\n      part.pickedStart = { x: part.x, y: part.y };\n      part.pickedTime = 0;\n      // Evaluate answer\n      const chosen = part.value;\n      const correct = this.target.missingValue;\n      if (chosen === correct) {\n        this.onCorrect();\n      } else {\n        this.onIncorrect();\n      }\n    }\n\n    onCorrect() {\n      this.score += 10 + this.level * 2;\n      playCorrect();\n      updateSR('Correct! The part fits. The machine hums happily.');\n      // Animate success and advance level after short delay\n      this.state = 'anim';\n      this.anim = { type: 'success', t: 0, duration: 1200 };\n      setTimeout(() => {\n        this.level++;\n        if (this.level >= MAX_LEVELS) {\n          this.win();\n        } else {\n          this.generateLevel();\n        }\n      }, 1200);\n    }\n\n    onIncorrect() {\n      this.lives -= 1;\n      playIncorrect();\n      this.shake = 12;\n      updateSR(`Oops! That part doesn't fit. ${this.lives} ${this.lives === 1 ? 'heart' : 'hearts'} remaining.`);\n      if (this.lives <= 0) {\n        setTimeout(() => this.lose(), 650);\n      }\n    }\n\n    startGame() {\n      this.level = 0;\n      this.lives = START_LIVES;\n      this.score = 0;\n      // Enable audio on user gesture if supported\n      if (audioContext && !audioEnabled) {\n        audioContext.resume().then(() => {\n          createBackgroundSound();\n        }).catch((err) => {\n          console.warn('Audio resume failed:', err);\n        });\n      }\n      this.generateLevel();\n    }\n\n    restart() {\n      this.state = 'menu';\n      this.level = 0;\n      this.lives = START_LIVES;\n      this.score = 0;\n      this.parts = [];\n      this.target = null;\n      updateSR('Game reset. Click or press Enter to start.');\n    }\n\n    win() {\n      this.state = 'win';\n      updateSR('You fixed all the machines! You win! Press R or click to play again.');\n      // Victory sound sequence\n      if (audioContext && audioEnabled) {\n        setTimeout(() => playTone(880, 'sine', 0.18, 0.12), 0);\n        setTimeout(() => playTone(660, 'sine', 0.18, 0.12), 180);\n        setTimeout(() => playTone(990, 'sine', 0.28, 0.12), 380);\n      }\n    }\n\n    lose() {\n      this.state = 'lose';\n      updateSR('The machine could not be repaired. Game over. Press R to try again.');\n    }\n\n    updateSR(text) {\n      updateSR(text);\n    }\n\n    update(dt) {\n      // dt in ms\n      if (this.shake > 0) {\n        this.shake = Math.max(0, this.shake - dt * 0.02);\n      }\n      // update parts wobble and any picked animations\n      this.parts.forEach((p, i) => {\n        p.wobble += dt * 0.004 + i * 0.0001;\n        p.x = p.baseX + Math.sin(p.wobble) * 6;\n        p.y = p.baseY + Math.cos(p.wobble) * 4;\n        if (p.picked) {\n          p.pickedTime += dt;\n          const duration = 400;\n          const t = clamp(p.pickedTime / duration, 0, 1);\n          // move toward machine center\n          p.x = p.pickedStart.x + (MACHINE_X - p.pickedStart.x) * easeOut(t);\n          p.y = p.pickedStart.y + (MACHINE_Y + 10 - p.pickedStart.y) * easeOut(t);\n          p.radius = 36 * (1 - 0.4 * easeOut(t));\n        } else {\n          p.radius = 36;\n        }\n      });\n\n      // animate success or idle anthropomorphic machine\n      if (this.state === 'anim' && this.anim) {\n        this.anim.t += dt;\n        if (this.anim.t >= this.anim.duration) {\n          this.anim = { t: 0 };\n          // animation ends handled in onCorrect where new level is created\n          this.state = 'playing';\n        }\n      }\n    }\n\n    drawBackground() {\n      // calming gradient sky\n      const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n      g.addColorStop(0, '#E8F6FF');\n      g.addColorStop(0.6, '#F6FBFF');\n      g.addColorStop(1, '#F8FFF7');\n      ctx.fillStyle = g;\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n      // soft floating clouds (wacky shapes)\n      for (let i = 0; i < 5; i++) {\n        const cx = (i * 160 + (Date.now() * 0.02 * (i % 2 ? 1 : -1))) % (WIDTH + 200) - 100;\n        const cy = 70 + (i % 2) * 40;\n        ctx.fillStyle = 'rgba(255,255,255,0.85)';\n        ctx.beginPath();\n        ctx.ellipse(cx, cy, 58, 24, 0, 0, Math.PI * 2);\n        ctx.ellipse(cx + 36, cy + 6, 34, 18, 0, 0, Math.PI * 2);\n        ctx.ellipse(cx - 36, cy + 8, 40, 20, 0, 0, Math.PI * 2);\n        ctx.fill();\n      }\n\n      // soft ground\n      ctx.fillStyle = '#E6F2EA';\n      ctx.fillRect(0, HEIGHT - 80, WIDTH, 80);\n    }\n\n    drawMachine() {\n      // machine body\n      ctx.save();\n      // apply shake\n      const sh = (Math.random() - 0.5) * this.shake;\n      ctx.translate(sh, sh);\n      // machine base\n      ctx.fillStyle = '#DCEFFE';\n      roundRect(ctx, MACHINE_X - 160, MACHINE_Y - 90, 320, 180, 18, true, false);\n      // big gear on left\n      drawGear(ctx, MACHINE_X - 120, MACHINE_Y - 10, 40, 12, '#C6E6FF', '#6FB6FF', Date.now() * 0.002);\n      // big gear on right\n      drawGear(ctx, MACHINE_X + 120, MACHINE_Y - 10, 34, 10, '#FFEFD6', '#FFC88C', -Date.now() * 0.0025);\n\n      // central robot face / slot\n      ctx.save();\n      ctx.fillStyle = '#FFFFFF';\n      roundRect(ctx, MACHINE_X - 70, MACHINE_Y - 70, 140, 120, 14, true, false);\n      ctx.fillStyle = '#E6F0FF';\n      roundRect(ctx, MACHINE_X - 70, MACHINE_Y - 10, 140, 34, 10, true, false);\n      // mouth (slot) where part goes\n      ctx.fillStyle = '#333';\n      ctx.fillRect(MACHINE_X - 34, MACHINE_Y + 18, 68, 10);\n      // eyes\n      ctx.fillStyle = '#333';\n      ctx.beginPath();\n      ctx.arc(MACHINE_X - 26, MACHINE_Y - 32, 9, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.beginPath();\n      ctx.arc(MACHINE_X + 26, MACHINE_Y - 32, 9, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n\n      // display expression text on machine screen\n      ctx.fillStyle = '#0B3B2E';\n      ctx.font = '20px \"Segoe UI\", Roboto, Arial';\n      ctx.textAlign = 'center';\n      ctx.fillText(this.getExpressionText(), MACHINE_X, MACHINE_Y - 46);\n\n      // hearts and level\n      ctx.font = '16px \"Segoe UI\", Roboto, Arial';\n      ctx.textAlign = 'left';\n      let heartX = 18;\n      for (let i = 0; i < this.lives; i++) {\n        drawHeart(ctx, heartX + i * 22, 18, 10, '#FF6B81');\n      }\n      ctx.fillStyle = '#114B4A';\n      ctx.fillText(`Level ${this.level + 1} / ${MAX_LEVELS}`, WIDTH - 150, 24);\n      ctx.fillText(`Score: ${this.score}`, WIDTH - 150, 44);\n\n      ctx.restore();\n    }\n\n    drawParts() {\n      // draw each part as wacky mechanical piece with number\n      for (let i = 0; i < this.parts.length; i++) {\n        const p = this.parts[i];\n        // highlight if selected via keyboard\n        const selected = (i === this.selectorIndex && this.state === 'playing');\n        // shadow\n        ctx.save();\n        ctx.globalAlpha = 0.98;\n        ctx.beginPath();\n        ctx.fillStyle = 'rgba(0,0,0,0.07)';\n        ctx.ellipse(p.x + 6, p.y + 14, p.radius * 0.9, p.radius * 0.5, 0, 0, Math.PI * 2);\n        ctx.fill();\n        // body\n        ctx.fillStyle = '#FFF9F1';\n        roundRect(ctx, p.x - p.radius, p.y - p.radius, p.radius * 2, p.radius * 2, 18, true, false);\n        // gear teeth around\n        drawMiniGear(ctx, p.x, p.y, p.radius + 8, 8, '#F4F1E6', '#D6C9B3', Date.now() * 0.003 * ((i % 2) ? 1 : -1));\n        // number plate\n        ctx.fillStyle = '#0B3142';\n        ctx.beginPath();\n        ctx.arc(p.x, p.y - 6, p.radius - 10, 0, Math.PI * 2);\n        ctx.fill();\n        // number\n        ctx.fillStyle = '#FFFFFF';\n        ctx.font = '20px \"Segoe UI\", Roboto, Arial';\n        ctx.textAlign = 'center';\n        ctx.fillText(p.value, p.x, p.y - 0);\n        // small label (keyboard number for accessibility)\n        ctx.fillStyle = selected ? '#2B8A78' : '#7C8790';\n        ctx.font = '12px \"Segoe UI\", Roboto, Arial';\n        ctx.fillText(`${i + 1}`, p.x + p.radius - 12, p.y + p.radius - 6);\n\n        // selection ring\n        if (selected) {\n          ctx.lineWidth = 3;\n          ctx.strokeStyle = '#6AE3C1';\n          ctx.beginPath();\n          ctx.arc(p.x, p.y, p.radius + 6, 0, Math.PI * 2);\n          ctx.stroke();\n        }\n\n        // if part is picked and correct show glow\n        if (p.picked) {\n          ctx.globalCompositeOperation = 'lighter';\n          ctx.strokeStyle = 'rgba(170,255,210,0.15)';\n          ctx.lineWidth = 18 * (1 - clamp(p.pickedTime / 400, 0, 1));\n          ctx.beginPath();\n          ctx.arc(p.x, p.y, p.radius + 12, 0, Math.PI * 2);\n          ctx.stroke();\n          ctx.globalCompositeOperation = 'source-over';\n        }\n        ctx.restore();\n      }\n    }\n\n    drawFooter() {\n      // speaker icon and instructions hint\n      ctx.save();\n      ctx.globalAlpha = 0.9;\n      ctx.fillStyle = audioEnabled ? '#2B8A78' : '#7C8790';\n      // small speaker circle\n      const sx = 44;\n      const sy = HEIGHT - 32;\n      ctx.beginPath();\n      ctx.rect(sx - 10, sy - 8, 20, 16);\n      ctx.fill();\n      // triangle\n      ctx.beginPath();\n      ctx.moveTo(sx + 10, sy - 12);\n      ctx.lineTo(sx + 28, sy - 18);\n      ctx.lineTo(sx + 28, sy + 18);\n      ctx.lineTo(sx + 10, sy + 12);\n      ctx.closePath();\n      ctx.fill();\n      ctx.fillStyle = '#114B4A';\n      ctx.font = '13px \"Segoe UI\", Roboto, Arial';\n      ctx.textAlign = 'left';\n      ctx.fillText('Press S to toggle sound', sx + 44, sy - 2);\n      ctx.restore();\n    }\n\n    drawOverlay() {\n      // menu, win, lose overlays\n      if (this.state === 'menu') {\n        ctx.save();\n        ctx.fillStyle = 'rgba(6,18,22,0.28)';\n        ctx.fillRect(0, 0, WIDTH, HEIGHT);\n        ctx.fillStyle = '#FFFFFF';\n        ctx.font = '28px \"Segoe UI\", Roboto, Arial';\n        ctx.textAlign = 'center';\n        ctx.fillText('Machine Menders', WIDTH / 2, HEIGHT / 2 - 36);\n        ctx.font = '18px \"Segoe UI\", Roboto, Arial';\n        ctx.fillText('Fix the machines by choosing the correct part to complete each math problem.', WIDTH / 2, HEIGHT / 2 - 6);\n        ctx.fillText('Click, tap, or press Enter to start. Helpful controls: arrows, numbers 1\u20134, S for sound.', WIDTH / 2, HEIGHT / 2 + 16);\n        ctx.fillStyle = '#F1F9F4';\n        roundRect(ctx, WIDTH / 2 - 80, HEIGHT / 2 + 40, 160, 44, 12, true, false);\n        ctx.fillStyle = '#0B3B2E';\n        ctx.font = '20px \"Segoe UI\", Roboto, Arial';\n        ctx.fillText('Start Game', WIDTH / 2, HEIGHT / 2 + 70 - 8);\n        ctx.restore();\n      }\n      if (this.state === 'win') {\n        ctx.save();\n        ctx.fillStyle = 'rgba(8, 30, 15, 0.72)';\n        ctx.fillRect(0, 0, WIDTH, HEIGHT);\n        ctx.fillStyle = '#FFF8EC';\n        ctx.font = '30px \"Segoe UI\", Roboto, Arial';\n        ctx.textAlign = 'center';\n        ctx.fillText('You Fixed All the Machines!', WIDTH / 2, HEIGHT / 2 - 12);\n        ctx.font = '18px \"Segoe UI\", Roboto, Arial';\n        ctx.fillText(`Final score: ${this.score}`, WIDTH / 2, HEIGHT / 2 + 18);\n        ctx.fillText('Press R or click to play again.', WIDTH / 2, HEIGHT / 2 + 44);\n        ctx.restore();\n      }\n      if (this.state === 'lose') {\n        ctx.save();\n        ctx.fillStyle = 'rgba(48, 12, 12, 0.72)';\n        ctx.fillRect(0, 0, WIDTH, HEIGHT);\n        ctx.fillStyle = '#FFF4F6';\n        ctx.font = '28px \"Segoe UI\", Roboto, Arial';\n        ctx.textAlign = 'center';\n        ctx.fillText('Machine Failure', WIDTH / 2, HEIGHT / 2 - 6);\n        ctx.font = '16px \"Segoe UI\", Roboto, Arial';\n        ctx.fillText(`You repaired ${this.level} machines. Final score: ${this.score}`, WIDTH / 2, HEIGHT / 2 + 22);\n        ctx.fillText('Press R or click to try again.', WIDTH / 2, HEIGHT / 2 + 46);\n        ctx.restore();\n      }\n    }\n\n    draw(dt) {\n      ctx.clearRect(0, 0, WIDTH, HEIGHT);\n      this.drawBackground();\n\n      // animate little active bits\n      this.drawMachine();\n      this.drawParts();\n      this.drawFooter();\n      this.drawOverlay();\n\n      // subtle instruction text bottom-left\n      ctx.fillStyle = '#123B3A';\n      ctx.font = '13px \"Segoe UI\", Roboto, Arial';\n      ctx.textAlign = 'left';\n      ctx.fillText('Pick the part that completes the expression shown on the machine.', 14, HEIGHT - 8);\n\n      // small accessibility cue for sound status\n      ctx.save();\n      ctx.fillStyle = audioEnabled ? 'rgba(100,220,180,0.12)' : 'rgba(200,200,200,0.06)';\n      roundRect(ctx, WIDTH - 180, HEIGHT - 40, 164, 30, 12, true, false);\n      ctx.fillStyle = audioEnabled ? '#2B8A78' : '#7C8790';\n      ctx.font = '12px \"Segoe UI\", Roboto';\n      ctx.textAlign = 'right';\n      ctx.fillText(audioEnabled ? 'Sound: On' : 'Sound: Off', WIDTH - 20, HEIGHT - 20);\n      ctx.restore();\n    }\n\n    loop() {\n      const now = performance.now();\n      const dt = now - (this.lastTime || now);\n      this.lastTime = now;\n      if (!this.paused) {\n        this.update(dt);\n        this.draw(dt);\n      }\n      this.requester = requestAnimationFrame(this.loop);\n    }\n  }\n\n  // Helper drawing functions\n  function roundRect(ctx, x, y, w, h, r, fill, stroke) {\n    if (w < 2 * r) r = w / 2;\n    if (h < 2 * r) r = h / 2;\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  function drawGear(ctx, cx, cy, radius, teeth, color1, color2, spin) {\n    ctx.save();\n    ctx.translate(cx, cy);\n    ctx.rotate(spin || 0);\n    // base circle\n    ctx.beginPath();\n    ctx.fillStyle = color1;\n    ctx.arc(0, 0, radius, 0, Math.PI * 2);\n    ctx.fill();\n\n    // teeth\n    ctx.fillStyle = color2;\n    for (let i = 0; i < teeth; i++) {\n      const a = (i / teeth) * Math.PI * 2;\n      const tx = Math.cos(a) * (radius + 4);\n      const ty = Math.sin(a) * (radius + 4);\n      ctx.save();\n      ctx.translate(tx, ty);\n      ctx.rotate(a);\n      ctx.beginPath();\n      ctx.rect(-4, -6, 8, 12);\n      ctx.fill();\n      ctx.restore();\n    }\n    // center\n    ctx.fillStyle = '#FFFFFF';\n    ctx.beginPath();\n    ctx.arc(0, 0, radius * 0.4, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  function drawMiniGear(ctx, cx, cy, radius, teeth, color1, color2, spin) {\n    ctx.save();\n    ctx.translate(cx, cy);\n    ctx.rotate(spin || 0);\n    ctx.beginPath();\n    ctx.fillStyle = color1;\n    ctx.arc(0, 0, radius - 6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = color2;\n    for (let i = 0; i < teeth; i++) {\n      const a = (i / teeth) * Math.PI * 2;\n      const tx = Math.cos(a) * radius;\n      const ty = Math.sin(a) * radius;\n      ctx.beginPath();\n      ctx.arc(tx, ty, 4, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    ctx.restore();\n  }\n\n  function drawHeart(ctx, x, y, size, color) {\n    ctx.save();\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(x, y);\n    ctx.bezierCurveTo(x, y - size / 2, x - size, y - size / 2, x - size, y + size / 4);\n    ctx.bezierCurveTo(x - size, y + size, x, y + size * 1.2, x, y + size * 1.6);\n    ctx.bezierCurveTo(x, y + size * 1.2, x + size, y + size, x + size, y + size / 4);\n    ctx.bezierCurveTo(x + size, y - size / 2, x, y - size / 2, x, y);\n    ctx.closePath();\n    ctx.fill();\n    ctx.restore();\n  }\n\n  // Screen reader update helper\n  function updateSR(message) {\n    if (!sr) return;\n    sr.textContent = message;\n    console.log('[SR]', message);\n  }\n\n  // Start the game instance\n  const game = new Game();\n\n  // Friendly error handling for audio context creation after load\n  if (!audioContext) {\n    updateSR('Note: Audio is not available in this browser. The game is still playable with visual feedback.');\n  } else {\n    // Some browsers require a user gesture to resume audio. Notify the player.\n    updateSR('Press S to toggle sound. Click or press Enter to start the game.');\n  }\n\n  // Ensure audio context is resumed on first user gesture to allow immediate sound on some browsers\n  const ensureAudioOnGesture = () => {\n    if (!audioContext) return;\n    const resumeOnce = () => {\n      audioContext.resume().then(() => {\n        // do nothing; will be enabled when user toggles sound\n      }).catch(() => {});\n      window.removeEventListener('pointerdown', resumeOnce);\n      window.removeEventListener('keydown', resumeOnce);\n    };\n    window.addEventListener('pointerdown', resumeOnce, { once: true });\n    window.addEventListener('keydown', resumeOnce, { once: true });\n  };\n  ensureAudioOnGesture();\n\n})();\n---\n",
  "improve_response_tokens": 21068,
  "formatted_code": true,
  "formatting_response_tokens": 23417,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}