{
  "generated_date": "2025-11-12",
  "generated_timestamp": "2025-11-12T00:28:08.173533",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 10465,
  "game_filename": "2025-11-12.js",
  "game_size_bytes": 30262,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function() {\n  // Drone Math Game (for ages 7-9)\n  // Renders inside element with ID 'game-of-the-day-stage'.\n  // All visuals drawn on canvas (720x480). Sounds generated with Web Audio API.\n  // Win: score reaches GOAL. Lose: lives <= 0.\n  // Keyboard controls (arrows/WASD), number keys 1-3 to choose answers, M to mute, Enter to restart.\n\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const GOAL = 10; // number of correct answers to win\n  const MAX_WRONG = 3; // lives\n  const TOP_PADDING = 12; // spacing for UI\n  const UI_TEXT_MIN = 14; // minimum body text size\n  const UI_IMPORTANT = 20; // important info size\n  const FONT_FAMILY = 'Arial, sans-serif';\n\n  // Find container\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error(\"Game container with ID 'game-of-the-day-stage' not found.\");\n    return;\n  }\n\n  // Clear and create canvas\n  container.innerHTML = '';\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute('role', 'img');\n  canvas.setAttribute('aria-label', 'Drone math game: move the drone to the bubble with the correct answer. Arrow keys or WASD move. Press M to mute. Press Enter to restart.');\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Audio setup with error handling\n  let audioContext = null;\n  let audioAllowed = true;\n  try {\n    // Some browsers require user gesture; creation may throw in older contexts\n    audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    // create a low-volume ambient background oscillator\n    const ambientGain = audioContext.createGain();\n    ambientGain.gain.value = 0.03;\n    ambientGain.connect(audioContext.destination);\n\n    const ambientOsc = audioContext.createOscillator();\n    ambientOsc.type = 'sine';\n    ambientOsc.frequency.value = 110; // low hum\n    const ambientFilter = audioContext.createBiquadFilter();\n    ambientFilter.type = 'lowpass';\n    ambientFilter.frequency.value = 300;\n    ambientOsc.connect(ambientFilter);\n    ambientFilter.connect(ambientGain);\n    ambientOsc.start();\n  } catch (err) {\n    console.warn('Audio context could not be created or is blocked. Game will run without sound.', err);\n    audioContext = null;\n    audioAllowed = false;\n  }\n\n  // Helper to play a short tone for correct/incorrect/button. Uses AudioContext safely.\n  function playTone({ type = 'click', duration = 0.25, freq = 440, volume = 0.15 } = {}) {\n    if (!audioContext) return;\n    try {\n      const now = audioContext.currentTime;\n      const osc = audioContext.createOscillator();\n      const gain = audioContext.createGain();\n      const filter = audioContext.createBiquadFilter();\n\n      // Configure by type\n      if (type === 'correct') {\n        osc.type = 'sine';\n        freq = freq || 880;\n        filter.type = 'highpass';\n        filter.frequency.value = 300;\n        gain.gain.value = volume;\n      } else if (type === 'wrong') {\n        osc.type = 'square';\n        freq = freq || 220;\n        filter.type = 'lowpass';\n        filter.frequency.value = 800;\n        gain.gain.value = volume * 0.9;\n      } else if (type === 'click') {\n        osc.type = 'triangle';\n        freq = freq || 600;\n        filter.type = 'bandpass';\n        filter.frequency.value = 600;\n        gain.gain.value = volume * 0.6;\n      } else {\n        osc.type = 'sine';\n        filter.type = 'lowpass';\n        filter.frequency.value = 1200;\n        gain.gain.value = volume;\n      }\n\n      osc.frequency.setValueAtTime(freq, now);\n      gain.gain.setValueAtTime(0.0001, now);\n      gain.gain.exponentialRampToValueAtTime(gain.gain.value, now + 0.01);\n      gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);\n\n      osc.connect(filter);\n      filter.connect(gain);\n      gain.connect(audioContext.destination);\n\n      osc.start(now);\n      osc.stop(now + duration + 0.05);\n    } catch (err) {\n      console.warn('Error playing sound:', err);\n    }\n  }\n\n  // Game state\n  let state = {\n    score: 0,\n    wrong: 0,\n    goal: GOAL,\n    lives: MAX_WRONG,\n    running: true, // false when paused on end screens\n    currentQuestion: null,\n    choices: [], // objects {value, x, y, r}\n    drone: {\n      x: WIDTH / 2,\n      y: HEIGHT / 2 + 30,\n      vx: 0,\n      vy: 0,\n      speed: 2.4,\n      radius: 18,\n      rotorPhase: 0\n    },\n    keys: {},\n    hoverIndex: -1,\n    muted: !audioAllowed, // if audio disabled at start, set muted true\n    showMessage: '', // temporary instructional messages\n    lastActionTime: 0,\n    floating: [], // for decorative floating shapes\n    gameOverReason: null // 'win' or 'lose'\n  };\n\n  // Utility: clamp\n  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));\n\n  // Generate math question appropriate for ages 7-9\n  function generateQuestion() {\n    // Randomly pick op: +, -, sometimes * (small)\n    const ops = ['+', '-', '*'];\n    let op = Math.random() < 0.75 ? (Math.random() < 0.5 ? '+' : '-') : '*';\n    if (Math.random() < 0.05) op = '*'; // keep multiplication rare\n\n    let a, b;\n    if (op === '+') {\n      a = Math.floor(Math.random() * 20) + 1; // 1..20\n      b = Math.floor(Math.random() * 20) + 1;\n    } else if (op === '-') {\n      a = Math.floor(Math.random() * 20) + 5; // ensure positive\n      b = Math.floor(Math.random() * (a - 1)) + 1;\n    } else {\n      a = Math.floor(Math.random() * 6) + 1; // 1..6\n      b = Math.floor(Math.random() * 6) + 1;\n    }\n    const correct = op === '+' ? a + b : op === '-' ? a - b : a * b;\n    // generate two distractors not equal to correct\n    const choices = new Set([correct]);\n    while (choices.size < 3) {\n      const variance = Math.max(1, Math.floor(Math.random() * 6));\n      const sign = Math.random() < 0.5 ? -1 : 1;\n      let candidate = correct + sign * variance;\n      if (candidate < 0) candidate = Math.abs(candidate) + 1;\n      choices.add(candidate);\n    }\n    const arr = Array.from(choices);\n    // shuffle\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n\n    return {\n      a, b, op, correct, choices: arr\n    };\n  }\n\n  // Initialize floating decorative shapes (wacky and calming)\n  function initFloating() {\n    state.floating = [];\n    for (let i = 0; i < 8; i++) {\n      state.floating.push({\n        x: Math.random() * WIDTH,\n        y: Math.random() * HEIGHT,\n        radius: 20 + Math.random() * 40,\n        dx: (Math.random() - 0.5) * 0.2,\n        dy: (Math.random() - 0.5) * 0.2,\n        hue: 180 + Math.random() * 80,\n        alpha: 0.06 + Math.random() * 0.06\n      });\n    }\n  }\n\n  // Place choices as bubbles avoiding overlapping UI\n  function layoutChoices(choices) {\n    // Place bubbles in a lower region to avoid overlapping top UI (top 90px)\n    const regionTop = 130;\n    const regionBottom = HEIGHT - 70;\n    const regionLeft = 40;\n    const regionRight = WIDTH - 40;\n    const positions = [];\n\n    // We will try random non-overlapping placement for each bubble\n    for (const val of choices) {\n      let attempts = 0;\n      let placed = false;\n      while (!placed && attempts < 200) {\n        attempts++;\n        const r = 36 + Math.random() * 12;\n        const x = regionLeft + r + Math.random() * (regionRight - regionLeft - 2 * r);\n        const y = regionTop + r + Math.random() * (regionBottom - regionTop - 2 * r);\n        // Ensure not overlapping with other bubbles and not overlapping the drone start position\n        let ok = true;\n        for (const p of positions) {\n          const dx = p.x - x;\n          const dy = p.y - y;\n          if (Math.hypot(dx, dy) < p.r + r + 12) { ok = false; break; }\n        }\n        // avoid top question area center\n        if (ok) {\n          if (y < regionTop + 40) ok = false;\n        }\n        // avoid drone initial region\n        const dx2 = state.drone.x - x;\n        const dy2 = state.drone.y - y;\n        if (Math.hypot(dx2, dy2) < r + 60) ok = false;\n        if (ok) {\n          positions.push({ value: val, x, y, r });\n          placed = true;\n        }\n      }\n      // Fallback simple placement if not found\n      if (!placed) {\n        const r = 40;\n        const x = regionLeft + r + Math.random() * (regionRight - regionLeft - 2 * r);\n        const y = regionTop + r + choices.indexOf(val) * (r * 2.1);\n        positions.push({ value: val, x, y, r });\n      }\n    }\n    return positions;\n  }\n\n  // Start a new round with a new question\n  function startRound() {\n    state.currentQuestion = generateQuestion();\n    state.choices = layoutChoices(state.currentQuestion.choices);\n    state.lastActionTime = performance.now();\n    state.showMessage = 'Steer the drone to the correct bubble!';\n  }\n\n  // Restart entire game\n  function restartGame() {\n    state.score = 0;\n    state.wrong = 0;\n    state.lives = MAX_WRONG;\n    state.running = true;\n    state.gameOverReason = null;\n    state.drone.x = WIDTH / 2;\n    state.drone.y = HEIGHT / 2 + 30;\n    state.drone.vx = 0;\n    state.drone.vy = 0;\n    state.showMessage = 'Ready? Use arrows or WASD to move.';\n    startRound();\n  }\n\n  // Start initial\n  initFloating();\n  startRound();\n\n  // Input handling\n  window.addEventListener('keydown', (e) => {\n    state.keys[e.key.toLowerCase()] = true;\n\n    // Mute toggle\n    if (e.key.toLowerCase() === 'm') {\n      state.muted = !state.muted;\n      if (!audioContext && !state.muted) {\n        // Try to resume audio context on user gesture\n        try {\n          audioContext = new (window.AudioContext || window.webkitAudioContext)();\n        } catch (err) {\n          audioContext = null;\n          console.warn('Could not create audio context on unmute', err);\n        }\n      }\n      if (!state.muted) playTone({ type: 'click' });\n    }\n\n    // number keys to select an answer (1-3)\n    if (['1', '2', '3'].includes(e.key) && state.running) {\n      const idx = parseInt(e.key, 10) - 1;\n      if (state.choices[idx]) {\n        handleChoiceSelection(state.choices[idx]);\n      }\n    }\n\n    // Enter to restart if not running\n    if (!state.running && e.key === 'Enter') {\n      restartGame();\n      if (!state.muted) playTone({ type: 'click' });\n    }\n\n    // allow spacebar to make small boost upward\n    if (e.key === ' ' && state.running) {\n      state.drone.vy -= 0.6;\n      if (!state.muted) playTone({ type: 'click', freq: 800, duration: 0.08, volume: 0.06 });\n    }\n  });\n\n  window.addEventListener('keyup', (e) => {\n    state.keys[e.key.toLowerCase()] = false;\n  });\n\n  // Mouse and touch handling for clicking bubbles and restart button\n  canvas.addEventListener('pointerdown', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = (e.clientX - rect.left) * (canvas.width / rect.width);\n    const y = (e.clientY - rect.top) * (canvas.height / rect.height);\n    // If game running, check bubbles\n    if (state.running) {\n      for (const choice of state.choices) {\n        const dx = x - choice.x;\n        const dy = y - choice.y;\n        if (Math.hypot(dx, dy) <= choice.r + 6) {\n          handleChoiceSelection(choice);\n          return;\n        }\n      }\n    } else {\n      // If game over, check restart \"button\" area center\n      // We'll draw restart centered at bottom; detect clicks within rectangle\n      const btn = getRestartButtonRect();\n      if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {\n        restartGame();\n        if (!state.muted) playTone({ type: 'click' });\n      }\n    }\n  });\n\n  // Provide alternative: clicking on canvas moves drone toward pointer for accessibility (optional)\n  canvas.addEventListener('dblclick', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = (e.clientX - rect.left) * (canvas.width / rect.width);\n    const y = (e.clientY - rect.top) * (canvas.height / rect.height);\n    state.drone.x = clamp(x, 20, WIDTH - 20);\n    state.drone.y = clamp(y, 20, HEIGHT - 20);\n  });\n\n  // Handle when user chooses a bubble (by collision or click/keyboard)\n  function handleChoiceSelection(choice) {\n    if (!state.running) return;\n    const isCorrect = choice.value === state.currentQuestion.correct;\n    if (isCorrect) {\n      state.score += 1;\n      state.showMessage = 'Great! Correct!';\n      if (!state.muted) playTone({ type: 'correct', freq: 940, duration: 0.28, volume: 0.2 });\n    } else {\n      state.wrong += 1;\n      state.lives = Math.max(0, MAX_WRONG - state.wrong);\n      state.showMessage = 'Oops \u2014 try again!';\n      if (!state.muted) playTone({ type: 'wrong', freq: 180, duration: 0.35, volume: 0.18 });\n    }\n\n    // small visual \"pop\" on the chosen bubble by temporarily moving drone near it\n    state.drone.x = choice.x - (choice.x - state.drone.x) * 0.2;\n    state.drone.y = choice.y - (choice.y - state.drone.y) * 0.2;\n    state.drone.vx *= 0.4;\n    state.drone.vy *= 0.4;\n\n    // Next round after short delay\n    setTimeout(() => {\n      if (state.score >= state.goal) {\n        // Win\n        endGame('win');\n        return;\n      }\n      if (state.lives <= 0) {\n        endGame('lose');\n        return;\n      }\n      startRound();\n    }, 700);\n  }\n\n  // End game: show victory or game over screen\n  function endGame(reason) {\n    state.running = false;\n    state.gameOverReason = reason; // 'win' or 'lose'\n    state.showMessage = reason === 'win' ? \"You did it! Drone team wins!\" : \"Oh no \u2014 drone ran out of safety!\";\n    if (!state.muted) playTone({ type: reason === 'win' ? 'correct' : 'wrong', duration: 0.6, volume: 0.22 });\n  }\n\n  // Utility to measure text and draw a background rectangle for readability\n  function drawTextWithBg(text, x, y, options = {}) {\n    const {\n      fontSize = UI_TEXT_MIN,\n      fontWeight = 'normal',\n      align = 'left',\n      baseline = 'top',\n      padding = 8,\n      bgColor = 'rgba(255,255,255,0.75)',\n      textColor = '#0b2d3a',\n      radius = 8\n    } = options;\n    ctx.font = `${fontWeight} ${fontSize}px ${FONT_FAMILY}`;\n    ctx.textAlign = align;\n    ctx.textBaseline = baseline;\n\n    const metrics = ctx.measureText(text);\n    const textWidth = metrics.width;\n    // Compute background rect coordinates depending on align\n    let bx = x;\n    if (align === 'center') bx = x - textWidth / 2 - padding;\n    else if (align === 'right') bx = x - textWidth - padding * 2;\n\n    const bw = textWidth + padding * 2;\n    const bh = fontSize + padding;\n    const by = y - (baseline === 'top' ? 0 : fontSize / 2);\n\n    // simple rounded rect\n    roundRect(ctx, bx, by, bw, bh, radius, bgColor);\n    ctx.fillStyle = textColor;\n    if (align === 'center') ctx.fillText(text, x, y);\n    else if (align === 'left') ctx.fillText(text, x + padding, y);\n    else if (align === 'right') ctx.fillText(text, x - padding, y);\n    return { x: bx, y: by, w: bw, h: bh };\n  }\n\n  // Draw rounded rectangle filled with color\n  function roundRect(ctx, x, y, w, h, r = 8, fillColor = '#fff') {\n    ctx.save();\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fillStyle = fillColor;\n    ctx.fill();\n    ctx.restore();\n  }\n\n  // Draw background and floating decorations\n  function drawBackground(delta) {\n    // soothing gradient sky\n    const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    grad.addColorStop(0, '#e6f7ff');\n    grad.addColorStop(1, '#f3fbf8');\n    ctx.fillStyle = grad;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // floating blobs\n    for (const f of state.floating) {\n      f.x += f.dx;\n      f.y += f.dy;\n      if (f.x < -60) f.x = WIDTH + 60;\n      if (f.x > WIDTH + 60) f.x = -60;\n      if (f.y < -60) f.y = HEIGHT + 60;\n      if (f.y > HEIGHT + 60) f.y = -60;\n\n      ctx.beginPath();\n      ctx.fillStyle = `hsla(${f.hue},60%,65%,${f.alpha})`;\n      ctx.ellipse(f.x, f.y, f.radius * 1.6, f.radius, 0, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // soft wavy ground near bottom\n    ctx.beginPath();\n    ctx.fillStyle = 'rgba(200, 255, 230, 0.6)';\n    ctx.ellipse(WIDTH * 0.3, HEIGHT + 40, 340, 80, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.fillStyle = 'rgba(220, 240, 255, 0.5)';\n    ctx.ellipse(WIDTH * 0.75, HEIGHT + 20, 260, 60, 0, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  // Draw drone\n  function drawDrone(timeDelta) {\n    const d = state.drone;\n    // Update rotor phase for animation\n    d.rotorPhase += 0.12 + Math.hypot(d.vx, d.vy) * 0.02;\n    // Drone body\n    ctx.save();\n    ctx.translate(d.x, d.y);\n    // shadow\n    ctx.beginPath();\n    ctx.fillStyle = 'rgba(0,0,0,0.12)';\n    ctx.ellipse(0, d.radius + 18, d.radius * 1.6, 10, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // body\n    roundRect(ctx, -d.radius, -d.radius * 0.6, d.radius * 2, d.radius * 1.2, 8, '#bfe9ff');\n    ctx.beginPath();\n    ctx.fillStyle = '#2a6f8a';\n    ctx.ellipse(0, -4, d.radius * 0.7, d.radius * 0.48, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // cockpit glass\n    ctx.beginPath();\n    ctx.fillStyle = 'rgba(255,255,255,0.85)';\n    ctx.ellipse(d.radius * 0.1, -6, d.radius * 0.35, d.radius * 0.2, -0.2, 0, Math.PI * 2);\n    ctx.fill();\n\n    // rotors (wacky soft)\n    const rotorW = d.radius * 1.8;\n    const rotorH = 6;\n    const rp = Math.sin(d.rotorPhase) * 6;\n    for (let i = -1; i <= 1; i += 2) {\n      ctx.save();\n      ctx.translate(i * (d.radius + 8), -8);\n      ctx.rotate(rp * 0.02);\n      ctx.beginPath();\n      ctx.fillStyle = 'rgba(120,160,190,0.9)';\n      ctx.ellipse(0, 0, rotorW * 0.4, rotorH, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n    }\n\n    // little face\n    ctx.beginPath();\n    ctx.fillStyle = '#083b4a';\n    ctx.arc(-6, -2, 2, 0, Math.PI * 2);\n    ctx.arc(8, -2, 2, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  // Draw answer bubbles\n  function drawChoices() {\n    state.hoverIndex = -1;\n    for (let i = 0; i < state.choices.length; i++) {\n      const ch = state.choices[i];\n      // simple hover detection using mouse position from keys? We'll use pointer coords when pointerdown, but also mark close to drone\n      const dx = state.drone.x - ch.x;\n      const dy = state.drone.y - ch.y;\n      const dist = Math.hypot(dx, dy);\n      const isNear = dist < ch.r + state.drone.radius + 1;\n      // scale slightly if near\n      const scale = isNear ? 1.05 : 1.0;\n      const r = ch.r * scale;\n\n      // bubble background\n      ctx.beginPath();\n      const hue = 160 + (i * 40);\n      ctx.fillStyle = `rgba(${200 - i * 20}, ${230 - i * 10}, ${255 - i * 30}, 0.95)`;\n      ctx.ellipse(ch.x, ch.y, r, r * 0.9, 0, 0, Math.PI * 2);\n      ctx.fill();\n\n      // ring\n      ctx.beginPath();\n      ctx.lineWidth = 3;\n      ctx.strokeStyle = isNear ? '#ffde7a' : 'rgba(0,0,0,0.06)';\n      ctx.ellipse(ch.x, ch.y, r + 4, r * 0.9 + 4, 0, 0, Math.PI * 2);\n      ctx.stroke();\n\n      // number text\n      ctx.font = `bold 22px ${FONT_FAMILY}`;\n      ctx.fillStyle = '#073b46';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      const text = String(ch.value);\n      // measure text width and ensure it fits inside bubble - decrease font if necessary\n      let fontSize = 22;\n      let metrics = ctx.measureText(text);\n      while ((metrics.width > r * 1.6) && fontSize > 14) {\n        fontSize -= 1;\n        ctx.font = `bold ${fontSize}px ${FONT_FAMILY}`;\n        metrics = ctx.measureText(text);\n      }\n      ctx.fillText(text, ch.x, ch.y);\n\n      // If drone is near, mark hover index (for keyboard visual)\n      if (isNear) state.hoverIndex = i;\n    }\n  }\n\n  // Draw top UI: score left, level/goal center, lives right, audio icon top-right corner\n  function drawTopUI() {\n    // Score top-left\n    const scoreText = `Score: ${state.score}/${state.goal}`;\n    drawTextWithBg(scoreText, 12, TOP_PADDING, {\n      fontSize: UI_IMPORTANT,\n      fontWeight: 'bold',\n      align: 'left',\n      baseline: 'top',\n      padding: 10,\n      bgColor: 'rgba(255,255,255,0.9)',\n      textColor: '#064048',\n      radius: 10\n    });\n\n    // Lives top-right\n    const livesText = `Lives: ${state.lives}`;\n    ctx.save();\n    // measure to align right near edge with padding 12\n    ctx.font = `bold ${UI_IMPORTANT}px ${FONT_FAMILY}`;\n    const metrics = ctx.measureText(livesText);\n    const textW = metrics.width;\n    const x = WIDTH - 12 - textW;\n    drawTextWithBg(livesText, WIDTH - 12, TOP_PADDING, {\n      fontSize: UI_IMPORTANT,\n      fontWeight: 'bold',\n      align: 'right',\n      baseline: 'top',\n      padding: 10,\n      bgColor: 'rgba(255,255,255,0.9)',\n      textColor: '#670d0d',\n      radius: 10\n    });\n    ctx.restore();\n\n    // Goal center top\n    const goalText = `Get ${state.goal} correct answers to win`;\n    ctx.save();\n    ctx.font = `${UI_TEXT_MIN + 6}px ${FONT_FAMILY}`;\n    const centerY = TOP_PADDING + 6;\n    drawTextWithBg(goalText, WIDTH / 2, TOP_PADDING, {\n      fontSize: UI_TEXT_MIN + 6,\n      fontWeight: '600',\n      align: 'center',\n      baseline: 'top',\n      padding: 10,\n      bgColor: 'rgba(255,255,255,0.88)',\n      textColor: '#1b3b43',\n      radius: 10\n    });\n    ctx.restore();\n\n    // Audio mute icon right of lives\n    const iconSize = 18;\n    const iconX = WIDTH - 12 - iconSize - 12;\n    const iconY = TOP_PADDING + 34;\n    ctx.beginPath();\n    ctx.fillStyle = state.muted ? '#bfbfbf' : '#2c6f7b';\n    roundRect(ctx, iconX - 6, iconY - 6, iconSize + 12, iconSize + 12, 6, state.muted ? 'rgba(255,255,255,0.9)' : 'rgba(255,255,255,0.9)');\n    // tiny speaker box\n    ctx.fillStyle = state.muted ? '#bfbfbf' : '#2c6f7b';\n    ctx.fillRect(iconX, iconY, iconSize - 6, iconSize);\n    // cone\n    ctx.beginPath();\n    ctx.moveTo(iconX + iconSize - 6, iconY + 2);\n    ctx.lineTo(iconX + iconSize + 4, iconY + 9);\n    ctx.lineTo(iconX + iconSize - 6, iconY + iconSize - 2);\n    ctx.closePath();\n    ctx.fill();\n\n    // muted cross\n    if (state.muted) {\n      ctx.strokeStyle = '#ff6b6b';\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(iconX + 4, iconY + 4);\n      ctx.lineTo(iconX + iconSize + 6, iconY + iconSize - 2);\n      ctx.moveTo(iconX + iconSize + 6, iconY + 4);\n      ctx.lineTo(iconX + 4, iconY + iconSize - 2);\n      ctx.stroke();\n    }\n\n    // Text instruction at bottom-center (non-overlapping)\n    const instr = \"Move: Arrows or WASD  \u2022  Select: fly into bubble or press 1-3  \u2022  M: mute/unmute\";\n    drawTextWithBg(instr, WIDTH / 2, HEIGHT - 38, {\n      fontSize: UI_TEXT_MIN,\n      fontWeight: 'normal',\n      align: 'center',\n      baseline: 'top',\n      padding: 10,\n      bgColor: 'rgba(255,255,255,0.92)',\n      textColor: '#0b3b44',\n      radius: 10\n    });\n  }\n\n  // Draw current question text below top UI (centered)\n  function drawQuestionArea() {\n    if (!state.currentQuestion) return;\n    const q = state.currentQuestion;\n    const text = `${q.a} ${q.op} ${q.b} = ?`;\n    // Ensure it doesn't overlap with score or lives by placing at y ~ 78\n    const y = 78;\n    drawTextWithBg(text, WIDTH / 2, y, {\n      fontSize: 26,\n      fontWeight: 'bold',\n      align: 'center',\n      baseline: 'top',\n      padding: 12,\n      bgColor: 'rgba(255,255,255,0.95)',\n      textColor: '#023047',\n      radius: 12\n    });\n  }\n\n  // Draw floating temporary messages\n  function drawMessage() {\n    if (!state.showMessage) return;\n    const elapsed = performance.now() - state.lastActionTime;\n    // fade out after 1800ms\n    const alpha = elapsed < 1800 ? 1 : Math.max(0, 1 - (elapsed - 1800) / 800);\n    if (alpha <= 0) {\n      state.showMessage = '';\n      return;\n    }\n    ctx.save();\n    ctx.globalAlpha = alpha;\n    drawTextWithBg(state.showMessage, WIDTH / 2, 110, {\n      fontSize: 16,\n      fontWeight: '600',\n      align: 'center',\n      baseline: 'top',\n      padding: 8,\n      bgColor: 'rgba(255,255,255,0.9)',\n      textColor: '#0b3b44',\n      radius: 10\n    });\n    ctx.restore();\n  }\n\n  // Restart button rectangle for end screens\n  function getRestartButtonRect() {\n    const w = 240;\n    const h = 44;\n    const x = WIDTH / 2 - w / 2;\n    const y = HEIGHT / 2 + 60;\n    return { x, y, w, h };\n  }\n\n  // Draw end-game overlay (win/lose) with restart instruction\n  function drawEndScreen() {\n    const overlayAlpha = 0.86;\n    // semi-opaque overlay\n    ctx.fillStyle = `rgba(8,12,20,${overlayAlpha})`;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // message\n    if (state.gameOverReason === 'win') {\n      drawTextWithBg('VICTORY!', WIDTH / 2, HEIGHT / 2 - 40, {\n        fontSize: 36,\n        fontWeight: 'bold',\n        align: 'center',\n        baseline: 'top',\n        padding: 14,\n        bgColor: '#eafff2',\n        textColor: '#0a7a3d',\n        radius: 14\n      });\n      const details = `You guided the drone crew and answered ${state.score} questions!`;\n      drawTextWithBg(details, WIDTH / 2, HEIGHT / 2 + 6, {\n        fontSize: 18,\n        fontWeight: '600',\n        align: 'center',\n        baseline: 'top',\n        padding: 12,\n        bgColor: 'rgba(255,255,255,0.95)',\n        textColor: '#073b4a',\n        radius: 10\n      });\n    } else {\n      drawTextWithBg('GAME OVER', WIDTH / 2, HEIGHT / 2 - 40, {\n        fontSize: 34,\n        fontWeight: 'bold',\n        align: 'center',\n        baseline: 'top',\n        padding: 14,\n        bgColor: '#ffefef',\n        textColor: '#7a0b0b',\n        radius: 14\n      });\n      const details = `You answered ${state.score} correctly. Try again to reach ${state.goal}!`;\n      drawTextWithBg(details, WIDTH / 2, HEIGHT / 2 + 6, {\n        fontSize: 18,\n        fontWeight: '600',\n        align: 'center',\n        baseline: 'top',\n        padding: 12,\n        bgColor: 'rgba(255,255,255,0.95)',\n        textColor: '#073b4a',\n        radius: 10\n      });\n    }\n\n    // restart button\n    const btn = getRestartButtonRect();\n    // draw rounded rect\n    roundRect(ctx, btn.x, btn.y, btn.w, btn.h, 10, '#fffcf0');\n    ctx.fillStyle = '#094b5f';\n    ctx.font = `bold 18px ${FONT_FAMILY}`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText('Restart (Enter or Click)', btn.x + btn.w / 2, btn.y + btn.h / 2);\n  }\n\n  // Main update and draw loop\n  let lastTime = performance.now();\n  function loop(now) {\n    const dt = Math.min(60, now - lastTime);\n    lastTime = now;\n\n    // Update floating decor a bit\n    for (const f of state.floating) {\n      f.x += f.dx * dt * 0.06;\n      f.y += f.dy * dt * 0.06;\n    }\n\n    // Input: movement\n    if (state.running) {\n      const speed = state.drone.speed;\n      const k = state.keys;\n      let ax = 0, ay = 0;\n      if (k['arrowleft'] || k['a']) ax -= 1;\n      if (k['arrowright'] || k['d']) ax += 1;\n      if (k['arrowup'] || k['w']) ay -= 1;\n      if (k['arrowdown'] || k['s']) ay += 1;\n\n      // Normalize diagonal\n      if (ax !== 0 && ay !== 0) {\n        ax *= 0.7071;\n        ay *= 0.7071;\n      }\n      state.drone.vx += ax * 0.18 * speed;\n      state.drone.vy += ay * 0.18 * speed;\n      // friction\n      state.drone.vx *= 0.96;\n      state.drone.vy *= 0.96;\n      // cap speed\n      const spd = Math.hypot(state.drone.vx, state.drone.vy);\n      const max = state.drone.speed;\n      if (spd > max) {\n        state.drone.vx = (state.drone.vx / spd) * max;\n        state.drone.vy = (state.drone.vy / spd) * max;\n      }\n      state.drone.x += state.drone.vx;\n      state.drone.y += state.drone.vy;\n\n      // confine to play area margins to keep UI readable\n      const margin = 22;\n      state.drone.x = clamp(state.drone.x, margin, WIDTH - margin);\n      state.drone.y = clamp(state.drone.y, 100, HEIGHT - 90);\n\n      // check collisions with bubbles\n      for (const choice of state.choices) {\n        const dx = state.drone.x - choice.x;\n        const dy = state.drone.y - choice.y;\n        if (Math.hypot(dx, dy) <= state.drone.radius + choice.r - 4) {\n          // collided with this bubble\n          handleChoiceSelection(choice);\n          break;\n        }\n      }\n    }\n\n    // Clear and draw\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    drawBackground(dt);\n    drawTopUI();\n    drawQuestionArea();\n    drawChoices();\n    drawDrone(dt);\n    drawMessage();\n\n    // If not running (end screen), draw overlay\n    if (!state.running) {\n      drawEndScreen();\n    }\n\n    requestAnimationFrame(loop);\n  }\n\n  requestAnimationFrame(loop);\n\n  // Accessibility: provide some text alternative live-updates for screen readers by updating container aria-label\n  function updateAria() {\n    const status = state.running ? `Score ${state.score} out of ${state.goal}. Lives ${state.lives}.` : (state.gameOverReason === 'win' ? 'Victory!' : 'Game over.');\n    const question = state.currentQuestion ? `Question: ${state.currentQuestion.a} ${state.currentQuestion.op} ${state.currentQuestion.b}.` : '';\n    container.setAttribute('aria-label', `Drone math game. ${status} ${question} Move with arrow keys or WASD. Press M to mute. Press Enter to restart.`);\n  }\n\n  // Periodically update aria label\n  setInterval(updateAria, 1000);\n\n  // Initialize on user gesture to resume audio if needed\n  function resumeAudioOnGesture() {\n    if (audioContext && audioContext.state === 'suspended') {\n      audioContext.resume().catch((err) => {\n        console.warn('Audio context resume failed:', err);\n      });\n    }\n    window.removeEventListener('pointerdown', resumeAudioOnGesture);\n    window.removeEventListener('keydown', resumeAudioOnGesture);\n  }\n  window.addEventListener('pointerdown', resumeAudioOnGesture);\n  window.addEventListener('keydown', resumeAudioOnGesture);\n\n  // Error handling for unexpected exceptions during runtime\n  window.addEventListener('error', (evt) => {\n    console.error('Unexpected error in game:', evt.error);\n    // Display a friendly message inside canvas\n    ctx.save();\n    roundRect(ctx, 60, HEIGHT / 2 - 60, WIDTH - 120, 120, 12, '#fff7ed');\n    ctx.fillStyle = '#3b1e00';\n    ctx.font = `bold 18px ${FONT_FAMILY}`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText('An unexpected error occurred. Please reload to try again.', WIDTH / 2, HEIGHT / 2);\n    ctx.restore();\n  });\n\n  // Prevent tab navigation away from game area interfering with key controls\n  canvas.setAttribute('tabindex', '0');\n  canvas.addEventListener('blur', () => {\n    // stop movement if focus lost\n    state.keys = {};\n  });\n\n})();\n---\n",
  "improve_response_tokens": 20101,
  "formatted_code": true,
  "formatting_response_tokens": 21135,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}