{
  "generated_date": "2025-08-20",
  "generated_timestamp": "2025-08-20T00:26:36.819553",
  "model": "gpt-5-mini",
  "theme": "electricity",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9263,
  "game_filename": "2025-08-20.js",
  "game_size_bytes": 26031,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a <canvas> inside it.\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Electricity Math Game for ages 7-9\n  // Renders inside element with ID \"game-of-the-day-stage\"\n  // Canvas must be exactly 720x480\n  // Uses Web Audio API for sounds (oscillators), canvas-only graphics\n  // Accessible: keyboard controls, aria labels, offscreen live region for screen readers\n\n  // ==== Setup DOM and Canvas ====\n  const STAGE_ID = 'game-of-the-day-stage';\n  const STAGE = document.getElementById(STAGE_ID);\n  if (!STAGE) {\n    console.error('Game stage element not found:', STAGE_ID);\n    return;\n  }\n  // Clear stage\n  STAGE.innerHTML = '';\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = 720;\n  canvas.height = 480;\n  canvas.style.width = '720px';\n  canvas.style.height = '480px';\n  canvas.setAttribute('role', 'img');\n  canvas.setAttribute('aria-label', 'Spark Factory math game. Use keyboard or mouse to select number nodes to equal a target number. Press S to toggle sound.');\n  canvas.tabIndex = 0; // make focusable for keyboard events\n  STAGE.appendChild(canvas);\n\n  // Hidden live region for screen readers\n  const live = document.createElement('div');\n  live.setAttribute('aria-live', 'polite');\n  live.style.position = 'absolute';\n  live.style.left = '-10000px';\n  live.style.width = '1px';\n  live.style.height = '1px';\n  live.style.overflow = 'hidden';\n  STAGE.appendChild(live);\n\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    console.error('2D context not available.');\n    return;\n  }\n\n  // ==== Audio Setup with error handling ====\n  let audioEnabled = true;\n  let audioCtx = null;\n  let ambientOsc = null;\n  try {\n    const AudioContext = window.AudioContext || window.webkitAudioContext;\n    audioCtx = new AudioContext();\n  } catch (e) {\n    console.warn('Web Audio API not available or blocked:', e);\n    audioEnabled = false;\n  }\n\n  // Resume audio context on user gesture if suspended\n  function ensureAudioRunning() {\n    if (!audioEnabled || !audioCtx) return Promise.resolve();\n    if (audioCtx.state === 'suspended') {\n      return audioCtx.resume().catch((e) => {\n        console.warn('Could not resume audio context:', e);\n      });\n    }\n    return Promise.resolve();\n  }\n\n  // Create simple tone with envelope\n  function playTone({ freq = 440, duration = 0.15, type = 'sine', gain = 0.12, attack = 0.01 }) {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = type;\n      o.frequency.setValueAtTime(freq, now);\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.linearRampToValueAtTime(gain, now + attack);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);\n      o.connect(g).connect(audioCtx.destination);\n      o.start(now);\n      o.stop(now + duration + 0.02);\n    } catch (err) {\n      console.warn('Error playing tone:', err);\n      // disable audio to prevent repeated errors\n      audioEnabled = false;\n    }\n  }\n\n  // Ambient hum (gentle) for electricity theme\n  function startAmbient() {\n    if (!audioEnabled || !audioCtx || ambientOsc) return;\n    try {\n      ambientOsc = audioCtx.createOscillator();\n      const ambientGain = audioCtx.createGain();\n      ambientOsc.type = 'sine';\n      ambientOsc.frequency.value = 120; // low hum\n      ambientGain.gain.value = 0.02;\n      // subtle movement with LFO\n      const lfo = audioCtx.createOscillator();\n      lfo.frequency.value = 0.08;\n      const lfoGain = audioCtx.createGain();\n      lfoGain.gain.value = 10;\n      lfo.connect(lfoGain);\n      lfoGain.connect(ambientOsc.frequency);\n      ambientOsc.connect(ambientGain).connect(audioCtx.destination);\n      ambientOsc.start();\n      lfo.start();\n      // store for stopping (we keep references)\n      ambientOsc._lfo = lfo;\n      ambientOsc._gain = ambientGain;\n    } catch (err) {\n      console.warn('Error starting ambient:', err);\n    }\n  }\n  function stopAmbient() {\n    if (!ambientOsc) return;\n    try {\n      if (ambientOsc._lfo) ambientOsc._lfo.stop();\n      ambientOsc.stop();\n      ambientOsc = null;\n    } catch (err) {\n      console.warn('Error stopping ambient:', err);\n    }\n  }\n\n  // Sound effects\n  function playSelectSound() {\n    ensureAudioRunning().then(() => {\n      playTone({ freq: 880, duration: 0.08, type: 'square', gain: 0.09 });\n    });\n  }\n  function playDeselectSound() {\n    ensureAudioRunning().then(() => {\n      playTone({ freq: 400, duration: 0.08, type: 'triangle', gain: 0.06 });\n    });\n  }\n  function playCorrectSound() {\n    ensureAudioRunning().then(() => {\n      // small melody\n      playTone({ freq: 660, duration: 0.12, type: 'sine', gain: 0.14 });\n      setTimeout(() => playTone({ freq: 880, duration: 0.18, type: 'sine', gain: 0.14 }), 120);\n      setTimeout(() => playTone({ freq: 1320, duration: 0.22, type: 'sine', gain: 0.14 }), 320);\n    });\n  }\n  function playIncorrectSound() {\n    ensureAudioRunning().then(() => {\n      playTone({ freq: 220, duration: 0.28, type: 'sawtooth', gain: 0.12 });\n      setTimeout(() => playTone({ freq: 160, duration: 0.18, type: 'sawtooth', gain: 0.08 }), 160);\n    });\n  }\n\n  // Toggle audio on/off\n  function toggleAudio() {\n    audioEnabled = !audioEnabled;\n    if (audioEnabled) {\n      ensureAudioRunning().then(() => startAmbient());\n    } else {\n      stopAmbient();\n    }\n    announce(`Sound ${audioEnabled ? 'on' : 'off'}`);\n  }\n\n  // ==== Game Logic ====\n  const state = {\n    nodes: [], // {x,y,r,value,selected,id}\n    target: 10,\n    selections: [], // indexes of nodes chosen in current attempt\n    maxSelect: 3,\n    score: 0,\n    round: 1,\n    attemptsLeft: 3,\n    highlightIndex: 0,\n    message: 'Select numbers to equal the target',\n    showHelp: false,\n    mutedByUser: false,\n  };\n\n  function announce(text) {\n    if (!live) return;\n    live.textContent = text;\n  }\n\n  // Utility: random integer inclusive\n  function ri(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  // Create a solvable round: ensure combination of up to maxSelect numbers sums to target\n  function generateRound(roundNum = 1) {\n    // Determine target: increase range slightly with rounds\n    const minT = 6 + Math.min(roundNum - 1, 6); // small growth\n    const maxT = 12 + Math.min(roundNum - 1, 8);\n    const target = ri(minT, maxT);\n    // choose number of terms (2 or 3 usually)\n    const terms = Math.random() < 0.4 ? 2 : 3;\n    // generate solution parts between 1 and 9\n    const parts = [];\n    let remaining = target;\n    // ensure we can create valid parts: choose random solution composition\n    for (let i = 0; i < terms - 1; i++) {\n      const maxPart = Math.min(9, remaining - (terms - i - 1) * 1);\n      const partMin = 1;\n      const part = ri(partMin, Math.max(partMin, maxPart));\n      parts.push(part);\n      remaining -= part;\n    }\n    // last part\n    if (remaining < 1) {\n      // fallback: pick simple two-term split\n      const a = ri(1, Math.min(9, target - 1));\n      const b = target - a;\n      parts.length = 0;\n      parts.push(a, b);\n    } else if (remaining > 9) {\n      // split remaining\n      const a = ri(1, 9);\n      const b = remaining - a;\n      if (b <= 9 && b >= 1) {\n        parts.push(a, b);\n      } else {\n        parts.push(ri(1, 9));\n        parts.push(ri(1, 9));\n      }\n    } else {\n      parts.push(remaining);\n    }\n    // Shuffle parts\n    for (let i = parts.length - 1; i > 0; i--) {\n      const j = ri(0, i);\n      [parts[i], parts[j]] = [parts[j], parts[i]];\n    }\n\n    // Create nodes: place 6 nodes, include all parts, fill rest with random numbers\n    const nodes = [];\n    const positions = [\n      { x: 140, y: 160 },\n      { x: 360, y: 100 },\n      { x: 580, y: 160 },\n      { x: 180, y: 320 },\n      { x: 360, y: 260 },\n      { x: 540, y: 320 },\n    ];\n    // Fill with parts first\n    const used = [];\n    for (let i = 0; i < positions.length; i++) {\n      let value;\n      if (i < parts.length) {\n        value = parts[i];\n      } else {\n        // avoid creating extra numbers equal to parts too often\n        let candidate;\n        do {\n          candidate = ri(1, 9);\n        } while (Math.random() < 0.3 && parts.includes(candidate));\n        value = candidate;\n      }\n      nodes.push({\n        id: i,\n        x: positions[i].x,\n        y: positions[i].y,\n        r: 40,\n        value,\n        selected: false,\n        disabled: false,\n      });\n    }\n\n    state.nodes = nodes;\n    state.target = target;\n    state.selections = [];\n    state.highlightIndex = 0;\n    state.round = roundNum;\n    state.attemptsLeft = 3;\n    state.message = 'Select numbers to equal the target';\n  }\n\n  // Check current selection\n  function currentSum() {\n    return state.selections.reduce((s, idx) => s + state.nodes[idx].value, 0);\n  }\n  function checkSelection() {\n    const sum = currentSum();\n    if (sum === state.target) {\n      state.score += 1;\n      state.message = 'Perfect! Gadget powered up!';\n      announce(`Correct! Round ${state.round} complete. Score ${state.score}.`);\n      playCorrectSound();\n      // flash and then next round\n      setTimeout(() => {\n        generateRound(state.round + 1);\n      }, 900);\n    } else if (sum > state.target || state.selections.length >= state.maxSelect) {\n      // incorrect attempt\n      state.attemptsLeft -= 1;\n      if (state.attemptsLeft <= 0) {\n        state.message = `Out of attempts. The correct sum was ${state.target}. Try again!`;\n        announce(`Round ${state.round} failed. Score ${state.score}.`);\n        playIncorrectSound();\n        setTimeout(() => {\n          generateRound(Math.max(1, state.round)); // repeat same round\n        }, 1200);\n      } else {\n        state.message = `Not quite. ${state.attemptsLeft} ${state.attemptsLeft === 1 ? 'attempt' : 'attempts'} left. Try another combo.`;\n        announce(state.message);\n        playIncorrectSound();\n        // deselect all selections for retry\n        for (const idx of state.selections) state.nodes[idx].selected = false;\n        state.selections = [];\n      }\n    } else {\n      // still less than target and selections remaining\n      state.message = 'Good partial total. Keep going!';\n      playSelectSound();\n    }\n  }\n\n  // Select/deselect node by index\n  function selectNode(idx) {\n    if (!state.nodes[idx]) return;\n    const node = state.nodes[idx];\n    if (node.disabled) return;\n    if (node.selected) {\n      node.selected = false;\n      // remove from selections\n      const pos = state.selections.indexOf(idx);\n      if (pos >= 0) state.selections.splice(pos, 1);\n      playDeselectSound();\n      state.message = 'Number removed.';\n      announce('Number removed.');\n      return;\n    }\n    if (state.selections.length >= state.maxSelect) {\n      state.message = `You can only pick up to ${state.maxSelect} numbers.`;\n      announce(state.message);\n      return;\n    }\n    node.selected = true;\n    state.selections.push(idx);\n    // Immediately check after selection\n    checkSelection();\n  }\n\n  // Keyboard navigation: move highlight (left right up down)\n  function moveHighlight(dx, dy) {\n    // find nearest by simple index navigation: left/right/up/down map to positions index ordering above\n    const positions = state.nodes.map((n) => ({ x: n.x, y: n.y }));\n    let current = state.highlightIndex || 0;\n    const currPos = positions[current];\n    let bestIdx = current;\n    let bestScore = Infinity;\n    for (let i = 0; i < positions.length; i++) {\n      if (i === current) continue;\n      const p = positions[i];\n      const vx = p.x - currPos.x;\n      const vy = p.y - currPos.y;\n      // require directional dot > 0 (approx)\n      if (dx !== 0 && Math.sign(vx) !== dx) continue;\n      if (dy !== 0 && Math.sign(vy) !== dy) continue;\n      const dist = Math.abs(vx) + Math.abs(vy);\n      if (dist < bestScore) {\n        bestScore = dist;\n        bestIdx = i;\n      }\n    }\n    if (bestIdx !== current) {\n      state.highlightIndex = bestIdx;\n      playSelectSound();\n    }\n  }\n\n  // Mouse handling: detect hover & click\n  function nodeIndexAt(x, y) {\n    for (let i = 0; i < state.nodes.length; i++) {\n      const n = state.nodes[i];\n      const dx = x - n.x;\n      const dy = y - n.y;\n      if (dx * dx + dy * dy <= n.r * n.r) return i;\n    }\n    return -1;\n  }\n\n  // ==== Drawing ====\n  function drawBackground() {\n    // soft gradient background (canvas-only)\n    const g = ctx.createLinearGradient(0, 0, 0, canvas.height);\n    g.addColorStop(0, '#eaf6ff');\n    g.addColorStop(1, '#f0fff6');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // subtle grid of circuits: wavy dashed lines\n    ctx.save();\n    ctx.globalAlpha = 0.12;\n    ctx.strokeStyle = '#76c7ff';\n    ctx.lineWidth = 2;\n    for (let i = 0; i < 6; i++) {\n      ctx.beginPath();\n      const y = 40 + i * 80;\n      for (let x = 0; x <= canvas.width; x += 20) {\n        const ny = y + Math.sin((x / canvas.width) * Math.PI * 4 + i) * 6;\n        if (x === 0) ctx.moveTo(x, ny);\n        else ctx.lineTo(x, ny);\n      }\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  function drawCharacters() {\n    // \"Captain Capacitor\" left - tall cylinder with friendly face\n    ctx.save();\n    // body\n    ctx.fillStyle = '#ffd87d';\n    ctx.beginPath();\n    ctx.ellipse(90, 360, 56, 80, 0, 0, Math.PI * 2);\n    ctx.fill();\n    // metallic top\n    ctx.fillStyle = '#e6e6e6';\n    ctx.beginPath();\n    ctx.ellipse(90, 300, 56, 22, 0, 0, Math.PI * 2);\n    ctx.fill();\n    // eyes\n    ctx.fillStyle = '#333';\n    ctx.beginPath();\n    ctx.arc(70, 350, 6, 0, Math.PI * 2);\n    ctx.arc(110, 350, 6, 0, Math.PI * 2);\n    ctx.fill();\n    // smile\n    ctx.strokeStyle = '#333';\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.arc(90, 365, 18, 0, Math.PI);\n    ctx.stroke();\n    // label\n    ctx.fillStyle = '#333';\n    ctx.font = '12px sans-serif';\n    ctx.fillText('Captain Capacitor', 40, 430);\n    ctx.restore();\n\n    // \"Gigi the Gizmo\" right - whimsical gadget\n    ctx.save();\n    ctx.translate(620, 90);\n    ctx.fillStyle = '#dfefff';\n    ctx.beginPath();\n    ctx.moveTo(-60, 0);\n    ctx.quadraticCurveTo(0, -90, 60, 0);\n    ctx.quadraticCurveTo(0, 60, -60, 0);\n    ctx.fill();\n    // eye\n    ctx.fillStyle = '#28527a';\n    ctx.beginPath();\n    ctx.arc(0, -10, 18, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = '#fff';\n    ctx.beginPath();\n    ctx.arc(-6, -16, 6, 0, Math.PI * 2);\n    ctx.fill();\n    // antenna spark\n    ctx.fillStyle = '#ffd36b';\n    ctx.beginPath();\n    ctx.moveTo(0, -90);\n    ctx.lineTo(8, -72);\n    ctx.lineTo(-8, -72);\n    ctx.fill();\n    ctx.fillStyle = '#333';\n    ctx.font = '12px sans-serif';\n    ctx.fillText('Gigi the Gizmo', -40, 50);\n    ctx.restore();\n  }\n\n  function drawNodes() {\n    for (let i = 0; i < state.nodes.length; i++) {\n      const n = state.nodes[i];\n      // glow if selected, highlight if hovered\n      const isHighlighted = i === state.highlightIndex;\n      // wire connection visual: draw a small curved wire to central gadget\n      ctx.save();\n      // wire base color depends on selection\n      ctx.strokeStyle = n.selected ? '#ffd36b' : '#b3e0ff';\n      ctx.lineWidth = n.selected ? 4 : 2;\n      ctx.beginPath();\n      const cx = 360;\n      const cy = 60 + 260; // gadget center near middle bottom-ish\n      ctx.moveTo(n.x, n.y);\n      // control point for curve\n      ctx.quadraticCurveTo((n.x + cx) / 2, n.y - 40, cx, cy - 20 + (i % 2 === 0 ? -10 : 10));\n      ctx.stroke();\n      ctx.restore();\n\n      // node circle\n      ctx.save();\n      // shadow glow\n      ctx.beginPath();\n      ctx.fillStyle = isHighlighted ? 'rgba(255,220,120,0.22)' : 'rgba(180,220,255,0.12)';\n      ctx.arc(n.x, n.y, n.r + (n.selected ? 8 : 4), 0, Math.PI * 2);\n      ctx.fill();\n\n      // circle body\n      ctx.beginPath();\n      ctx.fillStyle = n.selected ? '#ffefc2' : '#ffffff';\n      ctx.strokeStyle = '#2b6a7a';\n      ctx.lineWidth = 3;\n      ctx.arc(n.x, n.y, n.r, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n\n      // number text\n      ctx.fillStyle = '#2b6a7a';\n      ctx.font = '28px \"Segoe UI\", Roboto, sans-serif';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(String(n.value), n.x, n.y - 4);\n\n      // little label for keyboard hint (1-6)\n      ctx.fillStyle = '#2b6a7a';\n      ctx.font = '12px sans-serif';\n      ctx.fillText(`Key ${i + 1}`, n.x, n.y + 30);\n\n      // small bolt icon inside when selected\n      if (n.selected) {\n        ctx.beginPath();\n        ctx.fillStyle = '#f9a825';\n        ctx.moveTo(n.x - 6, n.y - 18);\n        ctx.lineTo(n.x + 2, n.y - 8);\n        ctx.lineTo(n.x - 2, n.y - 8);\n        ctx.lineTo(n.x + 6, n.y + 8);\n        ctx.lineTo(n.x - 2, n.y + 0);\n        ctx.lineTo(n.x + 2, n.y + 0);\n        ctx.closePath();\n        ctx.fill();\n      }\n\n      ctx.restore();\n    }\n  }\n\n  function drawGadget() {\n    // Central gadget that needs to be powered to target number\n    const cx = 360;\n    const cy = 140 + 120;\n    ctx.save();\n    // base rectangle\n    ctx.fillStyle = '#e8f8ff';\n    ctx.strokeStyle = '#2b6a7a';\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.roundRect\n      ? ctx.roundRect(cx - 140, cy - 90, 280, 120, 14)\n      : (function () {\n          const x = cx - 140;\n          const y = cy - 90;\n          const w = 280;\n          const h = 120;\n          const r = 14;\n          ctx.moveTo(x + r, y);\n          ctx.arcTo(x + w, y, x + w, y + h, r);\n          ctx.arcTo(x + w, y + h, x, y + h, r);\n          ctx.arcTo(x, y + h, x, y, r);\n          ctx.arcTo(x, y, x + w, y, r);\n          ctx.closePath();\n        })();\n    ctx.fill();\n    ctx.stroke();\n\n    // display target number nicely\n    ctx.fillStyle = '#0b486b';\n    ctx.font = '28px \"Segoe UI\", Roboto, sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText('Gadget Power Need', cx, cy - 40);\n    ctx.font = '44px \"Segoe UI\", Roboto, sans-serif';\n    ctx.fillStyle = '#2b6a7a';\n    ctx.fillText(String(state.target), cx, cy + 6);\n\n    // small meter showing progress\n    const sum = currentSum();\n    const pct = Math.min(1, sum / state.target);\n    ctx.fillStyle = '#cfefff';\n    ctx.fillRect(cx - 100, cy + 24, 200, 16);\n    ctx.fillStyle = '#7ad0ff';\n    ctx.fillRect(cx - 100, cy + 24, 200 * pct, 16);\n    ctx.strokeStyle = '#2b6a7a';\n    ctx.strokeRect(cx - 100, cy + 24, 200, 16);\n\n    // little spark animation if exact\n    if (sum === state.target) {\n      for (let i = 0; i < 6; i++) {\n        const angle = (i / 6) * Math.PI * 2;\n        const rx = cx + Math.cos(angle) * 120;\n        const ry = cy + Math.sin(angle) * 6;\n        ctx.beginPath();\n        ctx.fillStyle = `rgba(255,200,90,${0.6 - i * 0.08})`;\n        ctx.arc(rx, ry, 6 - i * 0.6, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n\n    ctx.restore();\n  }\n\n  function drawUI() {\n    // Top-left: score and round\n    ctx.save();\n    ctx.fillStyle = '#14444f';\n    ctx.font = '16px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText(`Score: ${state.score}`, 16, 24);\n    ctx.fillText(`Round: ${state.round}`, 16, 44);\n    ctx.fillText(`Attempts: ${state.attemptsLeft}`, 16, 64);\n    // instructions\n    ctx.font = '13px sans-serif';\n    ctx.fillStyle = '#0b486b';\n    ctx.fillText('Keys: 1-6 select nodes, arrows to move, Enter to select, Backspace undo, S to toggle sound, R to reset', 150, 24);\n    // message box bottom\n    ctx.fillStyle = 'rgba(255,255,255,0.85)';\n    ctx.fillRect(20, 420, 680, 44);\n    ctx.strokeStyle = '#2b6a7a';\n    ctx.strokeRect(20, 420, 680, 44);\n    ctx.fillStyle = '#114b5f';\n    ctx.font = '16px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText(state.message, 36, 447);\n    ctx.restore();\n\n    // audio visual indicator\n    ctx.save();\n    ctx.translate(678, 8);\n    // speaker icon\n    ctx.fillStyle = audioEnabled ? '#ffd36b' : '#d8d8d8';\n    ctx.beginPath();\n    ctx.moveTo(0, 6);\n    ctx.lineTo(10, 6);\n    ctx.lineTo(18, 0);\n    ctx.lineTo(18, 24);\n    ctx.lineTo(10, 18);\n    ctx.lineTo(0, 18);\n    ctx.closePath();\n    ctx.fill();\n    if (audioEnabled) {\n      ctx.beginPath();\n      ctx.strokeStyle = '#ffedbc';\n      ctx.lineWidth = 2;\n      ctx.arc(22, 12, 8, -0.6, 0.6);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.arc(22, 12, 12, -0.6, 0.6);\n      ctx.stroke();\n    } else {\n      ctx.strokeStyle = '#a0a0a0';\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(-2, -2);\n      ctx.lineTo(30, 26);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  // Draw loop\n  function render() {\n    // clear\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    drawBackground();\n    drawCharacters();\n    drawNodes();\n    drawGadget();\n    drawUI();\n    // highlight the currently highlighted node with a ring\n    const hi = state.highlightIndex;\n    if (typeof hi === 'number' && state.nodes[hi]) {\n      const n = state.nodes[hi];\n      ctx.save();\n      ctx.beginPath();\n      ctx.strokeStyle = 'rgba(255,150,30,0.9)';\n      ctx.lineWidth = 3;\n      ctx.setLineDash([6, 4]);\n      ctx.arc(n.x, n.y, n.r + 14, 0, Math.PI * 2);\n      ctx.stroke();\n      ctx.restore();\n    }\n    requestAnimationFrame(render);\n  }\n\n  // ==== Input Handling ====\n  // Focus canvas for keyboard\n  canvas.addEventListener('click', (e) => {\n    canvas.focus();\n    // resume audio if necessary\n    if (audioEnabled && audioCtx && audioCtx.state === 'suspended') {\n      ensureAudioRunning().then(() => startAmbient());\n    }\n  });\n\n  // Mouse interactions\n  canvas.addEventListener('mousemove', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = ((e.clientX - rect.left) / rect.width) * canvas.width;\n    const y = ((e.clientY - rect.top) / rect.height) * canvas.height;\n    const idx = nodeIndexAt(x, y);\n    if (idx !== -1) {\n      state.highlightIndex = idx;\n    }\n  });\n\n  canvas.addEventListener('click', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = ((e.clientX - rect.left) / rect.width) * canvas.width;\n    const y = ((e.clientY - rect.top) / rect.height) * canvas.height;\n    const idx = nodeIndexAt(x, y);\n    if (idx !== -1) {\n      selectNode(idx);\n      announce(`Selected ${state.nodes[idx].value}. Current sum ${currentSum()} of ${state.target}.`);\n    } else {\n      // clicking gadget area resets selection maybe\n      // if clicked on gadget area, show hint\n      if (x > 220 && x < 500 && y > 180 && y < 320) {\n        state.message = 'Click a number or press keys 1-6 to select nodes.';\n        announce(state.message);\n      }\n    }\n  });\n\n  // Keyboard controls\n  canvas.addEventListener('keydown', (e) => {\n    // Prevent page from scrolling when using arrows\n    const arrows = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];\n    if (arrows.includes(e.key)) e.preventDefault();\n\n    if (e.key >= '1' && e.key <= '6') {\n      const idx = parseInt(e.key, 10) - 1;\n      selectNode(idx);\n      announce(`Selected ${state.nodes[idx].value}. Current sum ${currentSum()} of ${state.target}.`);\n      return;\n    }\n    if (e.key === 'Enter' || e.key === ' ') {\n      // select highlighted\n      selectNode(state.highlightIndex);\n      announce(`Selected ${state.nodes[state.highlightIndex].value}. Current sum ${currentSum()} of ${state.target}.`);\n      return;\n    }\n    if (e.key === 'Backspace' || e.key === 'Delete') {\n      // undo last selection\n      const last = state.selections.pop();\n      if (typeof last !== 'undefined') {\n        state.nodes[last].selected = false;\n        state.message = 'Removed last selection.';\n        announce(state.message);\n        playDeselectSound();\n      } else {\n        state.message = 'No selections to undo.';\n        announce(state.message);\n      }\n      return;\n    }\n    if (e.key === 'ArrowLeft') {\n      moveHighlight(-1, 0);\n      return;\n    }\n    if (e.key === 'ArrowRight') {\n      moveHighlight(1, 0);\n      return;\n    }\n    if (e.key === 'ArrowUp') {\n      moveHighlight(0, -1);\n      return;\n    }\n    if (e.key === 'ArrowDown') {\n      moveHighlight(0, 1);\n      return;\n    }\n    if (e.key.toLowerCase() === 's') {\n      toggleAudio();\n      return;\n    }\n    if (e.key.toLowerCase() === 'r') {\n      generateRound(1);\n      state.score = 0;\n      announce('Game reset.');\n      return;\n    }\n    if (e.key.toLowerCase() === 'h') {\n      state.showHelp = !state.showHelp;\n      state.message = state.showHelp ? 'Help shown.' : 'Help hidden.';\n      announce(state.message);\n      return;\n    }\n  });\n\n  // Keyboard focus styles for accessibility\n  canvas.addEventListener('focus', () => {\n    canvas.style.outline = '2px dashed rgba(40,80,100,0.6)';\n  });\n  canvas.addEventListener('blur', () => {\n    canvas.style.outline = 'none';\n  });\n\n  // ==== Initialization ====\n  // Compatibility: add roundRect if not present (for older browsers)\n  if (!CanvasRenderingContext2D.prototype.roundRect) {\n    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {\n      if (w < 2 * r) r = w / 2;\n      if (h < 2 * r) r = h / 2;\n      this.beginPath();\n      this.moveTo(x + r, y);\n      this.arcTo(x + w, y, x + w, y + h, r);\n      this.arcTo(x + w, y + h, x, y + h, r);\n      this.arcTo(x, y + h, x, y, r);\n      this.arcTo(x, y, x + w, y, r);\n      this.closePath();\n      return this;\n    };\n  }\n\n  // Start ambient if audio allowed (but may be suspended until user gesture)\n  if (audioEnabled && audioCtx) {\n    // start ambient; if suspended it may throw, so guard\n    ensureAudioRunning().then(() => {\n      try {\n        startAmbient();\n      } catch (e) {\n        // may be suspended; ignore\n      }\n    });\n  }\n\n  // Generate first round and begin loop\n  generateRound(1);\n  render();\n\n  // Small guidance announcements for screen readers at start\n  announce('Welcome to Spark Factory. Match numbers to the gadget target. Use keys 1 to 6 or click nodes. Press S to toggle sound.');\n\n  // Expose minimal API for debugging (no global namespace pollution)\n  // but attach to element for potential external control\n  STAGE.game = {\n    reset: () => {\n      generateRound(1);\n    },\n    toggleAudio,\n  };\n})();\n---\n",
  "improve_response_tokens": 18201,
  "formatted_code": true,
  "formatting_response_tokens": 20143,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}