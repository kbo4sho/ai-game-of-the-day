# Game of the Day - 2025-10-09

## Metadata
- **Generated Date:** 2025-10-09
- **Generated Time:** 2025-10-09T00:26:44.538332
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-10-09.js
- **File Size:** 29698 bytes
- **Tokens Used:** 10016

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-10-09.js` - The playable game
- `2025-10-09.meta.json` - Machine-readable metadata
- `2025-10-09.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 21068

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 23417

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function() {
  // Educational Math Game: "Machine Menders"
  // Ages: 7-9. Theme: machines. Canvas-based visuals + Web Audio API.
  // Renders inside an element with ID "game-of-the-day-stage".
  // All visuals drawn on canvas. All sounds generated programmatically.
  // Author: expert educational game designer (AI-generated).
  'use strict';

  // Utility functions
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;
  const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
  const easeOut = t => 1 - Math.pow(1 - t, 3);

  // Find stage element
  const stage = document.getElementById('game-of-the-day-stage');
  if (!stage) {
    console.error('Game container with ID "game-of-the-day-stage" not found.');
    return;
  }

  // Clear stage
  while (stage.firstChild) stage.removeChild(stage.firstChild);

  // Create accessible text area (for screen readers and instructions).
  const sr = document.createElement('div');
  sr.setAttribute('role', 'region');
  sr.setAttribute('aria-live', 'polite');
  sr.style.position = 'absolute';
  sr.style.left = '-9999px';
  sr.style.width = '1px';
  sr.style.height = '1px';
  sr.style.overflow = 'hidden';
  sr.id = 'machine-menders-sr';
  stage.appendChild(sr);

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = 720;
  canvas.height = 480;
  canvas.style.width = '720px';
  canvas.style.height = '480px';
  canvas.setAttribute('role', 'img');
  canvas.setAttribute('aria-label', 'Machine Menders math game canvas');
  stage.appendChild(canvas);

  const ctx = canvas.getContext('2d');

  // Audio setup with error handling
  let audioContext = null;
  try {
    const AC = window.AudioContext || window.webkitAudioContext;
    if (AC) {
      audioContext = new AC();
    } else {
      audioContext = null;
      console.warn('Web Audio API is not supported in this browser.');
    }
  } catch (e) {
    audioContext = null;
    console.warn('Error creating AudioContext:', e);
  }

  // Manage audio state and sound functions
  let audioEnabled = false;
  let bgGain = null;
  let bgOsc = null;
  let lfo = null;

  function createBackgroundSound() {
    if (!audioContext) return;
    try {
      bgGain = audioContext.createGain();
      bgGain.gain.value = 0.02; // very gentle
      bgGain.connect(audioContext.destination);

      bgOsc = audioContext.createOscillator();
      bgOsc.type = 'sine';
      bgOsc.frequency.value = 220;
      bgOsc.connect(bgGain);

      // Gentle movement: LFO to modulate frequency
      lfo = audioContext.createOscillator();
      const lfoGain = audioContext.createGain();
      lfo.type = 'sine';
      lfo.frequency.value = 0.25; // very slow
      lfoGain.gain.value = 30;
      lfo.connect(lfoGain);
      lfoGain.connect(bgOsc.frequency);

      bgOsc.start();
      lfo.start();
      audioEnabled = true;
      updateSR('Sound enabled.');
    } catch (e) {
      console.warn('Error creating background sound:', e);
      audioEnabled = false;
      updateSR('Sound could not be enabled.');
    }
  }

  function stopBackgroundSound() {
    if (!audioContext) return;
    try {
      if (bgOsc) {
        bgOsc.stop();
        bgOsc.disconnect();
        bgOsc = null;
      }
      if (lfo) {
        lfo.stop();
        lfo.disconnect();
        lfo = null;
      }
      if (bgGain) {
        bgGain.disconnect();
        bgGain = null;
      }
      audioEnabled = false;
      updateSR('Sound disabled.');
    } catch (e) {
      console.warn('Error stopping background sound:', e);
    }
  }

  // Play a tone for feedback; uses oscillator + filter + gain envelope
  function playTone(freq = 440, type = 'sine', duration = 0.4, volume = 0.12) {
    if (!audioContext || !audioEnabled) return;
    try {
      const now = audioContext.currentTime;
      const o = audioContext.createOscillator();
      const g = audioContext.createGain();
      const f = audioContext.createBiquadFilter();
      o.type = type;
      o.frequency.value = freq;
      f.type = 'lowpass';
      f.frequency.value = Math.max(800, freq * 2);
      g.gain.value = 0.0001;

      o.connect(f);
      f.connect(g);
      g.connect(audioContext.destination);

      // Envelope
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(volume, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);

      o.start(now);
      o.stop(now + duration + 0.05);
    } catch (e) {
      console.warn('playTone error:', e);
    }
  }

  // Feedback sounds
  function playCorrect() {
    // pleasant arpeggio
    playTone(660, 'sine', 0.14, 0.12);
    setTimeout(() => playTone(880, 'sine', 0.18, 0.12), 140);
    setTimeout(() => playTone(990, 'sine', 0.22, 0.12), 320);
  }
  function playIncorrect() {
    // soft buzz
    if (!audioContext || !audioEnabled) return;
    try {
      const now = audioContext.currentTime;
      const o = audioContext.createOscillator();
      const g = audioContext.createGain();
      const f = audioContext.createBiquadFilter();
      o.type = 'sawtooth';
      o.frequency.value = 120;
      f.type = 'lowpass';
      f.frequency.value = 500;
      o.connect(f);
      f.connect(g);
      g.connect(audioContext.destination);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.08, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);
      o.start(now);
      o.stop(now + 0.36);
    } catch (e) {
      console.warn('playIncorrect error:', e);
    }
  }

  // Game constants
  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;
  const MACHINE_X = WIDTH / 2;
  const MACHINE_Y = HEIGHT / 2 + 10;
  const MAX_LEVELS = 8;
  const START_LIVES = 3;

  // Game state class
  class Game {
    constructor() {
      this.level = 0;
      this.lives = START_LIVES;
      this.score = 0;
      this.state = 'menu'; // menu, playing, win, lose, anim
      this.parts = []; // interactive options
      this.target = null; // expression object
      this.selectorIndex = 0; // keyboard selection
      this.anim = { t: 0 };
      this.lastTime = performance.now();
      this.shake = 0;
      this.paused = false;
      this.soundAllowed = !!audioEnabled;
      this.initInput();
      this.generateLevel();
      this._bindVisibility();
      this.updateSRInstructions();
      this.requester = null;
      this.loop = this.loop.bind(this);
      this.loop();
    }

    updateSRInstructions() {
      const controls = [
        'Keyboard: arrow keys to move selection, Enter or Space to pick, number keys 1–4 to choose a part.',
        'Click or tap a part to select it.',
        'Press S to toggle sound.',
        'Press R to restart the game when over.'
      ];
      updateSR(
        `Welcome to Machine Menders. Fix machines by choosing the correct part to complete the math. ` +
        `You have ${START_LIVES} hearts. ` +
        `Controls: ${controls.join(' ')}`
      );
    }

    _bindVisibility() {
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          // stop background sound gently
          if (audioContext && audioEnabled) {
            audioContext.suspend().catch(() => {});
          }
        } else {
          if (audioContext && audioEnabled) {
            audioContext.resume().catch(() => {});
          }
        }
      });
    }

    initInput() {
      // Mouse and touch handlers
      canvas.addEventListener('click', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (canvas.width / rect.width);
        const y = (e.clientY - rect.top) * (canvas.height / rect.height);
        if (this.state === 'menu') {
          // Start on click
          this.startGame();
          return;
        }
        if (this.state === 'win' || this.state === 'lose') {
          // Restart on click
          this.restart();
          return;
        }
        // detect which part clicked
        for (let i = 0; i < this.parts.length; i++) {
          const p = this.parts[i];
          const dx = x - p.x;
          const dy = y - p.y;
          if (Math.hypot(dx, dy) < p.radius + 8) {
            this.pickPart(i);
            return;
          }
        }
      });

      // Keyboard controls
      window.addEventListener('keydown', (e) => {
        if (e.defaultPrevented) return;
        if (this.state === 'menu' && (e.key === ' ' || e.key === 'Enter')) {
          e.preventDefault();
          this.startGame();
          return;
        }
        if (e.key.toLowerCase() === 's') {
          e.preventDefault();
          this.toggleSound();
          return;
        }
        if ((this.state === 'win' || this.state === 'lose') && e.key.toLowerCase() === 'r') {
          e.preventDefault();
          this.restart();
          return;
        }
        if (this.state !== 'playing') return;
        if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
          e.preventDefault();
          this.selectorIndex = (this.selectorIndex - 1 + this.parts.length) % this.parts.length;
          this.updateSRSelection();
        } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
          e.preventDefault();
          this.selectorIndex = (this.selectorIndex + 1) % this.parts.length;
          this.updateSRSelection();
        } else if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          this.pickPart(this.selectorIndex);
        } else {
          // number keys 1-4
          const n = parseInt(e.key, 10);
          if (!Number.isNaN(n) && n >= 1 && n <= 9) {
            if (n <= this.parts.length) {
              e.preventDefault();
              this.pickPart(n - 1);
            }
          }
        }
      });
    }

    toggleSound() {
      if (!audioContext) {
        updateSR('Sound unavailable on this device.');
        return;
      }
      // If audio hasn't been allowed by user gesture, resume/create on first toggle
      if (!audioEnabled) {
        // Some browsers require resume on user gesture
        audioContext.resume().then(() => {
          createBackgroundSound();
        }).catch((err) => {
          console.warn('Audio resume failed:', err);
          updateSR('Unable to enable sound due to browser restrictions.');
        });
      } else {
        stopBackgroundSound();
      }
      this.soundAllowed = audioEnabled;
    }

    generateLevel() {
      // Prepare level math: either addition or subtraction
      const levelNum = this.level + 1;
      const type = levelNum <= 3 ? 'add' : (levelNum <= 6 ? pick(['add', 'sub']) : pick(['add', 'sub']));
      const maxTarget = 10 + levelNum * 2;
      let a, b, target, missingOnLeft = Math.random() < 0.5;
      if (type === 'add') {
        a = rand(1, Math.max(4, Math.min(12, maxTarget - 1)));
        b = rand(1, Math.max(3, Math.min(12, maxTarget - a)));
        target = a + b;
      } else {
        // b = a - target (we want positive numbers)
        a = rand(5, Math.max(6, Math.min(18, maxTarget)));
        target = rand(1, Math.max(3, Math.min(10, a - 1)));
        b = a - target;
      }
      // We'll show expression like "a + ? = target" or "? + b = target"
      const missingValue = missingOnLeft ? a : b;
      const expression = {
        type,
        a,
        b,
        target,
        missingOnLeft,
        missingValue
      };
      this.target = expression;

      // Create parts (options)
      const correct = missingValue;
      const choices = new Set([correct]);
      while (choices.size < 4) {
        const delta = pick([-4, -3, -2, -1, 1, 2, 3, 4]);
        choices.add(clamp(correct + delta, 0, Math.max(1, correct + 6)));
      }
      const arr = Array.from(choices);
      // shuffle
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }

      // Place parts in positions around machine
      const ringRadius = 160;
      this.parts = arr.map((val, idx) => {
        const angle = (Math.PI * 2 * idx) / arr.length - Math.PI / 2 + (Math.random() - 0.5) * 0.2;
        const px = MACHINE_X + Math.cos(angle) * ringRadius + rand(-10, 10);
        const py = MACHINE_Y + Math.sin(angle) * ringRadius + rand(-10, 10);
        return {
          value: val,
          x: px,
          y: py,
          baseX: px,
          baseY: py,
          radius: 36,
          wobble: Math.random() * Math.PI * 2
        };
      });

      this.selectorIndex = 0;
      this.shake = 0;
      this.anim = { t: 0 };
      this.state = 'playing';
      updateSR(`Level ${this.level + 1}. Fix the machine: ${this.getExpressionText()}. Choose the correct part.`);
    }

    getExpressionText() {
      const e = this.target;
      if (!e) return '';
      if (e.type === 'add') {
        if (e.missingOnLeft) return `? + ${e.b} = ${e.target}`;
        return `${e.a} + ? = ${e.target}`;
      } else {
        if (e.missingOnLeft) return `? - ${e.b} = ${e.target}`;
        return `${e.a} - ? = ${e.target}`;
      }
    }

    pickPart(index) {
      if (this.state !== 'playing') return;
      if (index < 0 || index >= this.parts.length) return;
      const part = this.parts[index];
      this.selectorIndex = index;
      // animate part moving to machine
      part.picked = true;
      part.pickedStart = { x: part.x, y: part.y };
      part.pickedTime = 0;
      // Evaluate answer
      const chosen = part.value;
      const correct = this.target.missingValue;
      if (chosen === correct) {
        this.onCorrect();
      } else {
        this.onIncorrect();
      }
    }

    onCorrect() {
      this.score += 10 + this.level * 2;
      playCorrect();
      updateSR('Correct! The part fits. The machine hums happily.');
      // Animate success and advance level after short delay
      this.state = 'anim';
      this.anim = { type: 'success', t: 0, duration: 1200 };
      setTimeout(() => {
        this.level++;
        if (this.level >= MAX_LEVELS) {
          this.win();
        } else {
          this.generateLevel();
        }
      }, 1200);
    }

    onIncorrect() {
      this.lives -= 1;
      playIncorrect();
      this.shake = 12;
      updateSR(`Oops! That part doesn't fit. ${this.lives} ${this.lives === 1 ? 'heart' : 'hearts'} remaining.`);
      if (this.lives <= 0) {
        setTimeout(() => this.lose(), 650);
      }
    }

    startGame() {
      this.level = 0;
      this.lives = START_LIVES;
      this.score = 0;
      // Enable audio on user gesture if supported
      if (audioContext && !audioEnabled) {
        audioContext.resume().then(() => {
          createBackgroundSound();
        }).catch((err) => {
          console.warn('Audio resume failed:', err);
        });
      }
      this.generateLevel();
    }

    restart() {
      this.state = 'menu';
      this.level = 0;
      this.lives = START_LIVES;
      this.score = 0;
      this.parts = [];
      this.target = null;
      updateSR('Game reset. Click or press Enter to start.');
    }

    win() {
      this.state = 'win';
      updateSR('You fixed all the machines! You win! Press R or click to play again.');
      // Victory sound sequence
      if (audioContext && audioEnabled) {
        setTimeout(() => playTone(880, 'sine', 0.18, 0.12), 0);
        setTimeout(() => playTone(660, 'sine', 0.18, 0.12), 180);
        setTimeout(() => playTone(990, 'sine', 0.28, 0.12), 380);
      }
    }

    lose() {
      this.state = 'lose';
      updateSR('The machine could not be repaired. Game over. Press R to try again.');
    }

    updateSR(text) {
      updateSR(text);
    }

    update(dt) {
      // dt in ms
      if (this.shake > 0) {
        this.shake = Math.max(0, this.shake - dt * 0.02);
      }
      // update parts wobble and any picked animations
      this.parts.forEach((p, i) => {
        p.wobble += dt * 0.004 + i * 0.0001;
        p.x = p.baseX + Math.sin(p.wobble) * 6;
        p.y = p.baseY + Math.cos(p.wobble) * 4;
        if (p.picked) {
          p.pickedTime += dt;
          const duration = 400;
          const t = clamp(p.pickedTime / duration, 0, 1);
          // move toward machine center
          p.x = p.pickedStart.x + (MACHINE_X - p.pickedStart.x) * easeOut(t);
          p.y = p.pickedStart.y + (MACHINE_Y + 10 - p.pickedStart.y) * easeOut(t);
          p.radius = 36 * (1 - 0.4 * easeOut(t));
        } else {
          p.radius = 36;
        }
      });

      // animate success or idle anthropomorphic machine
      if (this.state === 'anim' && this.anim) {
        this.anim.t += dt;
        if (this.anim.t >= this.anim.duration) {
          this.anim = { t: 0 };
          // animation ends handled in onCorrect where new level is created
          this.state = 'playing';
        }
      }
    }

    drawBackground() {
      // calming gradient sky
      const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
      g.addColorStop(0, '#E8F6FF');
      g.addColorStop(0.6, '#F6FBFF');
      g.addColorStop(1, '#F8FFF7');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      // soft floating clouds (wacky shapes)
      for (let i = 0; i < 5; i++) {
        const cx = (i * 160 + (Date.now() * 0.02 * (i % 2 ? 1 : -1))) % (WIDTH + 200) - 100;
        const cy = 70 + (i % 2) * 40;
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        ctx.beginPath();
        ctx.ellipse(cx, cy, 58, 24, 0, 0, Math.PI * 2);
        ctx.ellipse(cx + 36, cy + 6, 34, 18, 0, 0, Math.PI * 2);
        ctx.ellipse(cx - 36, cy + 8, 40, 20, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      // soft ground
      ctx.fillStyle = '#E6F2EA';
      ctx.fillRect(0, HEIGHT - 80, WIDTH, 80);
    }

    drawMachine() {
      // machine body
      ctx.save();
      // apply shake
      const sh = (Math.random() - 0.5) * this.shake;
      ctx.translate(sh, sh);
      // machine base
      ctx.fillStyle = '#DCEFFE';
      roundRect(ctx, MACHINE_X - 160, MACHINE_Y - 90, 320, 180, 18, true, false);
      // big gear on left
      drawGear(ctx, MACHINE_X - 120, MACHINE_Y - 10, 40, 12, '#C6E6FF', '#6FB6FF', Date.now() * 0.002);
      // big gear on right
      drawGear(ctx, MACHINE_X + 120, MACHINE_Y - 10, 34, 10, '#FFEFD6', '#FFC88C', -Date.now() * 0.0025);

      // central robot face / slot
      ctx.save();
      ctx.fillStyle = '#FFFFFF';
      roundRect(ctx, MACHINE_X - 70, MACHINE_Y - 70, 140, 120, 14, true, false);
      ctx.fillStyle = '#E6F0FF';
      roundRect(ctx, MACHINE_X - 70, MACHINE_Y - 10, 140, 34, 10, true, false);
      // mouth (slot) where part goes
      ctx.fillStyle = '#333';
      ctx.fillRect(MACHINE_X - 34, MACHINE_Y + 18, 68, 10);
      // eyes
      ctx.fillStyle = '#333';
      ctx.beginPath();
      ctx.arc(MACHINE_X - 26, MACHINE_Y - 32, 9, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(MACHINE_X + 26, MACHINE_Y - 32, 9, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // display expression text on machine screen
      ctx.fillStyle = '#0B3B2E';
      ctx.font = '20px "Segoe UI", Roboto, Arial';
      ctx.textAlign = 'center';
      ctx.fillText(this.getExpressionText(), MACHINE_X, MACHINE_Y - 46);

      // hearts and level
      ctx.font = '16px "Segoe UI", Roboto, Arial';
      ctx.textAlign = 'left';
      let heartX = 18;
      for (let i = 0; i < this.lives; i++) {
        drawHeart(ctx, heartX + i * 22, 18, 10, '#FF6B81');
      }
      ctx.fillStyle = '#114B4A';
      ctx.fillText(`Level ${this.level + 1} / ${MAX_LEVELS}`, WIDTH - 150, 24);
      ctx.fillText(`Score: ${this.score}`, WIDTH - 150, 44);

      ctx.restore();
    }

    drawParts() {
      // draw each part as wacky mechanical piece with number
      for (let i = 0; i < this.parts.length; i++) {
        const p = this.parts[i];
        // highlight if selected via keyboard
        const selected = (i === this.selectorIndex && this.state === 'playing');
        // shadow
        ctx.save();
        ctx.globalAlpha = 0.98;
        ctx.beginPath();
        ctx.fillStyle = 'rgba(0,0,0,0.07)';
        ctx.ellipse(p.x + 6, p.y + 14, p.radius * 0.9, p.radius * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        // body
        ctx.fillStyle = '#FFF9F1';
        roundRect(ctx, p.x - p.radius, p.y - p.radius, p.radius * 2, p.radius * 2, 18, true, false);
        // gear teeth around
        drawMiniGear(ctx, p.x, p.y, p.radius + 8, 8, '#F4F1E6', '#D6C9B3', Date.now() * 0.003 * ((i % 2) ? 1 : -1));
        // number plate
        ctx.fillStyle = '#0B3142';
        ctx.beginPath();
        ctx.arc(p.x, p.y - 6, p.radius - 10, 0, Math.PI * 2);
        ctx.fill();
        // number
        ctx.fillStyle = '#FFFFFF';
        ctx.font = '20px "Segoe UI", Roboto, Arial';
        ctx.textAlign = 'center';
        ctx.fillText(p.value, p.x, p.y - 0);
        // small label (keyboard number for accessibility)
        ctx.fillStyle = selected ? '#2B8A78' : '#7C8790';
        ctx.font = '12px "Segoe UI", Roboto, Arial';
        ctx.fillText(`${i + 1}`, p.x + p.radius - 12, p.y + p.radius - 6);

        // selection ring
        if (selected) {
          ctx.lineWidth = 3;
          ctx.strokeStyle = '#6AE3C1';
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius + 6, 0, Math.PI * 2);
          ctx.stroke();
        }

        // if part is picked and correct show glow
        if (p.picked) {
          ctx.globalCompositeOperation = 'lighter';
          ctx.strokeStyle = 'rgba(170,255,210,0.15)';
          ctx.lineWidth = 18 * (1 - clamp(p.pickedTime / 400, 0, 1));
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius + 12, 0, Math.PI * 2);
          ctx.stroke();
          ctx.globalCompositeOperation = 'source-over';
        }
        ctx.restore();
      }
    }

    drawFooter() {
      // speaker icon and instructions hint
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = audioEnabled ? '#2B8A78' : '#7C8790';
      // small speaker circle
      const sx = 44;
      const sy = HEIGHT - 32;
      ctx.beginPath();
      ctx.rect(sx - 10, sy - 8, 20, 16);
      ctx.fill();
      // triangle
      ctx.beginPath();
      ctx.moveTo(sx + 10, sy - 12);
      ctx.lineTo(sx + 28, sy - 18);
      ctx.lineTo(sx + 28, sy + 18);
      ctx.lineTo(sx + 10, sy + 12);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = '#114B4A';
      ctx.font = '13px "Segoe UI", Roboto, Arial';
      ctx.textAlign = 'left';
      ctx.fillText('Press S to toggle sound', sx + 44, sy - 2);
      ctx.restore();
    }

    drawOverlay() {
      // menu, win, lose overlays
      if (this.state === 'menu') {
        ctx.save();
        ctx.fillStyle = 'rgba(6,18,22,0.28)';
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
        ctx.fillStyle = '#FFFFFF';
        ctx.font = '28px "Segoe UI", Roboto, Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Machine Menders', WIDTH / 2, HEIGHT / 2 - 36);
        ctx.font = '18px "Segoe UI", Roboto, Arial';
        ctx.fillText('Fix the machines by choosing the correct part to complete each math problem.', WIDTH / 2, HEIGHT / 2 - 6);
        ctx.fillText('Click, tap, or press Enter to start. Helpful controls: arrows, numbers 1–4, S for sound.', WIDTH / 2, HEIGHT / 2 + 16);
        ctx.fillStyle = '#F1F9F4';
        roundRect(ctx, WIDTH / 2 - 80, HEIGHT / 2 + 40, 160, 44, 12, true, false);
        ctx.fillStyle = '#0B3B2E';
        ctx.font = '20px "Segoe UI", Roboto, Arial';
        ctx.fillText('Start Game', WIDTH / 2, HEIGHT / 2 + 70 - 8);
        ctx.restore();
      }
      if (this.state === 'win') {
        ctx.save();
        ctx.fillStyle = 'rgba(8, 30, 15, 0.72)';
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
        ctx.fillStyle = '#FFF8EC';
        ctx.font = '30px "Segoe UI", Roboto, Arial';
        ctx.textAlign = 'center';
        ctx.fillText('You Fixed All the Machines!', WIDTH / 2, HEIGHT / 2 - 12);
        ctx.font = '18px "Segoe UI", Roboto, Arial';
        ctx.fillText(`Final score: ${this.score}`, WIDTH / 2, HEIGHT / 2 + 18);
        ctx.fillText('Press R or click to play again.', WIDTH / 2, HEIGHT / 2 + 44);
        ctx.restore();
      }
      if (this.state === 'lose') {
        ctx.save();
        ctx.fillStyle = 'rgba(48, 12, 12, 0.72)';
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
        ctx.fillStyle = '#FFF4F6';
        ctx.font = '28px "Segoe UI", Roboto, Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Machine Failure', WIDTH / 2, HEIGHT / 2 - 6);
        ctx.font = '16px "Segoe UI", Roboto, Arial';
        ctx.fillText(`You repaired ${this.level} machines. Final score: ${this.score}`, WIDTH / 2, HEIGHT / 2 + 22);
        ctx.fillText('Press R or click to try again.', WIDTH / 2, HEIGHT / 2 + 46);
        ctx.restore();
      }
    }

    draw(dt) {
      ctx.clearRect(0, 0, WIDTH, HEIGHT);
      this.drawBackground();

      // animate little active bits
      this.drawMachine();
      this.drawParts();
      this.drawFooter();
      this.drawOverlay();

      // subtle instruction text bottom-left
      ctx.fillStyle = '#123B3A';
      ctx.font = '13px "Segoe UI", Roboto, Arial';
      ctx.textAlign = 'left';
      ctx.fillText('Pick the part that completes the expression shown on the machine.', 14, HEIGHT - 8);

      // small accessibility cue for sound status
      ctx.save();
      ctx.fillStyle = audioEnabled ? 'rgba(100,220,180,0.12)' : 'rgba(200,200,200,0.06)';
      roundRect(ctx, WIDTH - 180, HEIGHT - 40, 164, 30, 12, true, false);
      ctx.fillStyle = audioEnabled ? '#2B8A78' : '#7C8790';
      ctx.font = '12px "Segoe UI", Roboto';
      ctx.textAlign = 'right';
      ctx.fillText(audioEnabled ? 'Sound: On' : 'Sound: Off', WIDTH - 20, HEIGHT - 20);
      ctx.restore();
    }

    loop() {
      const now = performance.now();
      const dt = now - (this.lastTime || now);
      this.lastTime = now;
      if (!this.paused) {
        this.update(dt);
        this.draw(dt);
      }
      this.requester = requestAnimationFrame(this.loop);
    }
  }

  // Helper drawing functions
  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    if (w < 2 * r) r = w / 2;
    if (h < 2 * r) r = h / 2;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  function drawGear(ctx, cx, cy, radius, teeth, color1, color2, spin) {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(spin || 0);
    // base circle
    ctx.beginPath();
    ctx.fillStyle = color1;
    ctx.arc(0, 0, radius, 0, Math.PI * 2);
    ctx.fill();

    // teeth
    ctx.fillStyle = color2;
    for (let i = 0; i < teeth; i++) {
      const a = (i / teeth) * Math.PI * 2;
      const tx = Math.cos(a) * (radius + 4);
      const ty = Math.sin(a) * (radius + 4);
      ctx.save();
      ctx.translate(tx, ty);
      ctx.rotate(a);
      ctx.beginPath();
      ctx.rect(-4, -6, 8, 12);
      ctx.fill();
      ctx.restore();
    }
    // center
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath();
    ctx.arc(0, 0, radius * 0.4, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  function drawMiniGear(ctx, cx, cy, radius, teeth, color1, color2, spin) {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(spin || 0);
    ctx.beginPath();
    ctx.fillStyle = color1;
    ctx.arc(0, 0, radius - 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = color2;
    for (let i = 0; i < teeth; i++) {
      const a = (i / teeth) * Math.PI * 2;
      const tx = Math.cos(a) * radius;
      const ty = Math.sin(a) * radius;
      ctx.beginPath();
      ctx.arc(tx, ty, 4, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawHeart(ctx, x, y, size, color) {
    ctx.save();
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.bezierCurveTo(x, y - size / 2, x - size, y - size / 2, x - size, y + size / 4);
    ctx.bezierCurveTo(x - size, y + size, x, y + size * 1.2, x, y + size * 1.6);
    ctx.bezierCurveTo(x, y + size * 1.2, x + size, y + size, x + size, y + size / 4);
    ctx.bezierCurveTo(x + size, y - size / 2, x, y - size / 2, x, y);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  // Screen reader update helper
  function updateSR(message) {
    if (!sr) return;
    sr.textContent = message;
    console.log('[SR]', message);
  }

  // Start the game instance
  const game = new Game();

  // Friendly error handling for audio context creation after load
  if (!audioContext) {
    updateSR('Note: Audio is not available in this browser. The game is still playable with visual feedback.');
  } else {
    // Some browsers require a user gesture to resume audio. Notify the player.
    updateSR('Press S to toggle sound. Click or press Enter to start the game.');
  }

  // Ensure audio context is resumed on first user gesture to allow immediate sound on some browsers
  const ensureAudioOnGesture = () => {
    if (!audioContext) return;
    const resumeOnce = () => {
      audioContext.resume().then(() => {
        // do nothing; will be enabled when user toggles sound
      }).catch(() => {});
      window.removeEventListener('pointerdown', resumeOnce);
      window.removeEventListener('keydown', resumeOnce);
    };
    window.addEventListener('pointerdown', resumeOnce, { once: true });
    window.addEventListener('keydown', resumeOnce, { once: true });
  };
  ensureAudioOnGesture();

})();
---

