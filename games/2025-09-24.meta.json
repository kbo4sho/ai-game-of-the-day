{
  "generated_date": "2025-09-24",
  "generated_timestamp": "2025-09-24T00:26:51.772115",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9370,
  "game_filename": "2025-09-24.js",
  "game_size_bytes": 28385,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Machine Math \u2014 a calming, wacky educational game for ages 7-9\n  // Renders into the element with ID \"game-of-the-day-stage\"\n  // All visuals drawn to a 720x480 canvas. Sounds generated with Web Audio API.\n  // Accessible text updates via an offscreen live region. Keyboard controls supported.\n\n  // -------------------------\n  // Basic setup and utilities\n  // -------------------------\n  const STAGE_ID = 'game-of-the-day-stage';\n  const WIDTH = 720;\n  const HEIGHT = 480;\n\n  const stage = document.getElementById(STAGE_ID);\n  if (!stage) {\n    console.error('Game stage element with ID \"' + STAGE_ID + '\" not found.');\n    return;\n  }\n\n  // Clear any existing children, then create needed UI nodes\n  stage.innerHTML = '';\n  stage.style.position = 'relative';\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute('role', 'application');\n  canvas.setAttribute('aria-label', 'Machine Math game. Use left and right arrows to pick a gear, press Enter to place it. Press M to toggle sound, R to restart.');\n  canvas.tabIndex = 0; // make focusable for keyboard events\n  canvas.style.outline = 'none';\n  stage.appendChild(canvas);\n\n  // Offscreen live region for screen readers\n  const a11y = document.createElement('div');\n  a11y.setAttribute('role', 'status');\n  a11y.setAttribute('aria-live', 'polite');\n  a11y.style.position = 'absolute';\n  a11y.style.left = '-10000px';\n  a11y.style.width = '1px';\n  a11y.style.height = '1px';\n  a11y.style.overflow = 'hidden';\n  stage.appendChild(a11y);\n\n  // Visible, small control buttons (canvas-only visuals exist, but include small DOM buttons for accessibility)\n  const controls = document.createElement('div');\n  controls.style.position = 'absolute';\n  controls.style.right = '8px';\n  controls.style.top = '8px';\n  controls.style.fontSize = '12px';\n  controls.style.fontFamily = 'sans-serif';\n  controls.style.color = '#333';\n  stage.appendChild(controls);\n\n  const soundIndicator = document.createElement('button');\n  soundIndicator.textContent = 'Sound: On';\n  soundIndicator.setAttribute('aria-pressed', 'true');\n  soundIndicator.style.padding = '6px 8px';\n  soundIndicator.style.marginBottom = '4px';\n  soundIndicator.style.cursor = 'pointer';\n  controls.appendChild(soundIndicator);\n\n  const restartButton = document.createElement('button');\n  restartButton.textContent = 'Restart (R)';\n  restartButton.style.display = 'block';\n  restartButton.style.padding = '6px 8px';\n  restartButton.style.cursor = 'pointer';\n  controls.appendChild(restartButton);\n\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    console.error('Failed to get 2D context on canvas.');\n    a11y.textContent = 'Error: Canvas not available.';\n    return;\n  }\n\n  // Helper random\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  // -------------------------\n  // Audio setup with error handling\n  // -------------------------\n  let audioEnabled = true;\n  let audioContext = null;\n  let bgGain = null;\n  let bgSource = null;\n  let masterGain = null;\n\n  function tryCreateAudioContext() {\n    if (audioContext) return;\n    try {\n      const AC = window.AudioContext || window.webkitAudioContext;\n      if (!AC) throw new Error('Web Audio API not supported.');\n      audioContext = new AC();\n      masterGain = audioContext.createGain();\n      masterGain.gain.value = 0.9;\n      masterGain.connect(audioContext.destination);\n\n      // background gentle hum: oscillator + filter + LFO\n      bgGain = audioContext.createGain();\n      bgGain.gain.value = 0.03; // very quiet\n      const osc = audioContext.createOscillator();\n      osc.type = 'sine';\n      osc.frequency.value = 110; // low pitch\n      const filter = audioContext.createBiquadFilter();\n      filter.type = 'lowpass';\n      filter.frequency.value = 600;\n      // LFO for filter movement\n      const lfo = audioContext.createOscillator();\n      lfo.frequency.value = 0.08;\n      const lfoGain = audioContext.createGain();\n      lfoGain.gain.value = 220;\n      lfo.connect(lfoGain);\n      lfoGain.connect(filter.frequency);\n      osc.connect(filter);\n      filter.connect(bgGain);\n      bgGain.connect(masterGain);\n      osc.start();\n      lfo.start();\n      bgSource = { osc, lfo, lfoGain, filter, gain: bgGain };\n    } catch (e) {\n      console.warn('Audio initialization failed:', e);\n      audioEnabled = false;\n      audioContext = null;\n      a11y.textContent = 'Audio unavailable. The game will continue without sound.';\n      soundIndicator.textContent = 'Sound: Off';\n      soundIndicator.setAttribute('aria-pressed', 'false');\n    }\n  }\n\n  // Start background if audio allowed; ensure it only starts on user gesture where required.\n  function startBackground() {\n    if (!audioEnabled) return;\n    try {\n      tryCreateAudioContext();\n      if (!audioContext || !bgSource) return;\n      // Ensure context resumed (some browsers require user gesture)\n      if (audioContext.state === 'suspended') {\n        audioContext.resume().catch(() => {\n          // ignore resume errors until user interacts\n        });\n      }\n      // bgGain already connected and oscillators started in tryCreateAudioContext()\n    } catch (e) {\n      console.warn('Background sound failed', e);\n    }\n  }\n\n  // Sound effects\n  function playTone({ type = 'sine', freq = 440, duration = 0.2, attack = 0.01, release = 0.12, gain = 0.15, detune = 0 } = {}) {\n    if (!audioEnabled) return;\n    try {\n      tryCreateAudioContext();\n      if (!audioContext) return;\n      const now = audioContext.currentTime;\n      const o = audioContext.createOscillator();\n      const g = audioContext.createGain();\n      o.type = type;\n      o.frequency.value = freq;\n      o.detune.value = detune;\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.linearRampToValueAtTime(gain, now + attack);\n      g.gain.linearRampToValueAtTime(0.0001, now + duration - release);\n      g.gain.linearRampToValueAtTime(0, now + duration + 0.001);\n      o.connect(g);\n      g.connect(masterGain);\n      o.start(now);\n      o.stop(now + duration + 0.02);\n    } catch (e) {\n      console.warn('playTone error', e);\n    }\n  }\n\n  function playCorrect() {\n    // pleasant ascending arpeggio\n    playTone({ type: 'triangle', freq: 660, duration: 0.18, attack: 0.005, release: 0.06, gain: 0.08 });\n    setTimeout(() => playTone({ type: 'triangle', freq: 880, duration: 0.18, attack: 0.005, release: 0.06, gain: 0.06 }), 120);\n  }\n\n  function playIncorrect() {\n    // low buzz\n    if (!audioEnabled || !audioContext) return;\n    try {\n      const now = audioContext.currentTime;\n      const o = audioContext.createOscillator();\n      const f = audioContext.createBiquadFilter();\n      const g = audioContext.createGain();\n      o.type = 'square';\n      o.frequency.value = 110;\n      f.type = 'lowpass';\n      f.frequency.value = 400;\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.linearRampToValueAtTime(0.15, now + 0.02);\n      g.gain.linearRampToValueAtTime(0.0001, now + 0.3);\n      o.connect(f);\n      f.connect(g);\n      g.connect(masterGain);\n      o.start(now);\n      o.stop(now + 0.32);\n    } catch (e) {\n      console.warn('playIncorrect error', e);\n    }\n  }\n\n  function playClick() {\n    playTone({ type: 'square', freq: 1200, duration: 0.06, attack: 0.001, release: 0.02, gain: 0.06 });\n  }\n\n  // Toggle audio, resume context if needed\n  function toggleAudio() {\n    audioEnabled = !audioEnabled;\n    soundIndicator.textContent = 'Sound: ' + (audioEnabled ? 'On' : 'Off');\n    soundIndicator.setAttribute('aria-pressed', audioEnabled ? 'true' : 'false');\n    if (audioEnabled) {\n      tryCreateAudioContext();\n      if (audioContext && audioContext.state === 'suspended') {\n        audioContext.resume().catch(() => {});\n      }\n    } else {\n      // reduce background\n      if (bgGain) bgGain.gain.value = 0;\n    }\n    a11y.textContent = audioEnabled ? 'Sound enabled.' : 'Sound disabled.';\n  }\n\n  soundIndicator.addEventListener('click', () => {\n    toggleAudio();\n    playClick();\n    canvas.focus();\n  });\n\n  restartButton.addEventListener('click', () => {\n    playClick();\n    resetGame();\n    canvas.focus();\n  });\n\n  // -------------------------\n  // Game logic\n  // -------------------------\n  let animationFrameId = null;\n  let lastTime = 0;\n\n  const MAX_LIVES = 3;\n\n  const state = {\n    levelIndex: 0,\n    lives: MAX_LIVES,\n    score: 0,\n    gears: [], // moving gear objects\n    selectedIndex: 0,\n    phase: 'intro', // intro, play, correct, incorrect, win, gameover\n    machineBase: 0,\n    machineTarget: 0,\n    awaiting: false,\n    timeSincePhaseStart: 0,\n    showAudioCue: false // visual cue whether audio is active\n  };\n\n  // Predefined levels that escalate difficulty gently\n  const LEVEL_COUNT = 8;\n  const levels = [];\n\n  // Generate levels: choose base and target such that 1<=diff<=9, different strategies.\n  (function generateLevels() {\n    for (let i = 0; i < LEVEL_COUNT; i++) {\n      let base = randInt(1, Math.min(9, 2 + i)); // base increases slowly\n      let diff = randInt(1, Math.min(9, 3 + Math.floor(i / 2)));\n      let target = base + diff;\n      // occasionally require subtractive thinking (smaller gear to subtract)\n      const needsSubtract = Math.random() < 0.15 && base > 1;\n      if (needsSubtract) {\n        // target < base, so gear is negative conceptually \u2014 for simplicity present as \"remove\" action\n        const reduce = randInt(1, Math.min(base - 1, 4));\n        target = base - reduce;\n      }\n      levels.push({ base, target });\n    }\n  })();\n\n  function prepareLevel(index) {\n    const level = levels[index];\n    state.machineBase = level.base;\n    state.machineTarget = level.target;\n    state.phase = 'play';\n    state.awaiting = false;\n    state.timeSincePhaseStart = 0;\n    state.selectedIndex = 0;\n    // create 3 moving gears: one correct (difference or subtract), two distractors\n    const diff = state.machineTarget - state.machineBase; // correct gear value (can be negative)\n    const correct = diff;\n    const options = new Set();\n    options.add(correct);\n    while (options.size < 3) {\n      let pick;\n      if (Math.random() < 0.6) {\n        // distractor near the correct\n        pick = correct + randInt(-3, 3);\n      } else {\n        pick = randInt(-4, 9);\n      }\n      if (pick === correct) continue;\n      // avoid zero for clarity unless correct is zero\n      if (pick === 0 && correct !== 0) continue;\n      options.add(pick);\n    }\n    const arr = Array.from(options);\n    // shuffle\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n\n    // place gears to the right moving left\n    state.gears = arr.map((value, i) => {\n      return {\n        id: i,\n        value,\n        x: WIDTH + i * 160 + randInt(0, 60),\n        y: 320 + (i % 2) * -18 + randInt(-6, 6),\n        radius: 36 + randInt(-4, 8),\n        speed: 40 + randInt(-10, 30) + i * 8\n      };\n    });\n\n    announce(`Level ${index + 1}. Machine shows ${state.machineBase} aiming for ${state.machineTarget}. Choose the gear that makes ${state.machineBase} become ${state.machineTarget}.`);\n  }\n\n  function resetGame() {\n    state.levelIndex = 0;\n    state.lives = MAX_LIVES;\n    state.score = 0;\n    state.phase = 'intro';\n    state.timeSincePhaseStart = 0;\n    prepareLevel(0);\n    startBackground();\n    draw(); // immediate redraw\n    a11y.textContent = 'Game restarted. Press Enter to begin.';\n  }\n\n  // Start initially\n  prepareLevel(0);\n  startBackground();\n\n  // -------------------------\n  // Interaction: keyboard & mouse\n  // -------------------------\n  canvas.addEventListener('keydown', (e) => {\n    const key = e.key;\n    if (state.phase === 'intro') {\n      if (key === 'Enter' || key === ' ') {\n        state.phase = 'play';\n        a11y.textContent = 'Game started. Use left and right to move, Enter to choose a gear.';\n        e.preventDefault();\n        playClick();\n        return;\n      }\n    }\n\n    if (key === 'ArrowLeft') {\n      state.selectedIndex = Math.max(0, state.selectedIndex - 1);\n      playClick();\n      e.preventDefault();\n    } else if (key === 'ArrowRight') {\n      state.selectedIndex = Math.min(state.gears.length - 1, state.selectedIndex + 1);\n      playClick();\n      e.preventDefault();\n    } else if (key === 'Enter' || key === ' ') {\n      // place gear\n      attemptPlaceGear(state.selectedIndex);\n      e.preventDefault();\n    } else if (key.toLowerCase() === 'm') {\n      toggleAudio();\n      playClick();\n    } else if (key.toLowerCase() === 'r') {\n      resetGame();\n      playClick();\n    }\n  });\n\n  // Mouse clicks for selection and gear placement\n  canvas.addEventListener('mousedown', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    // If clicking on a gear, select it or if it's near the place zone, place it\n    for (let i = 0; i < state.gears.length; i++) {\n      const g = state.gears[i];\n      const dx = mx - g.x;\n      const dy = my - g.y;\n      if (dx * dx + dy * dy <= g.radius * g.radius) {\n        state.selectedIndex = i;\n        playClick();\n        // If clicked twice quickly, place\n        const now = performance.now();\n        if (state.lastClickGear === i && now - state.lastClickTime < 400) {\n          attemptPlaceGear(i);\n        }\n        state.lastClickGear = i;\n        state.lastClickTime = now;\n        break;\n      }\n    }\n    canvas.focus();\n  });\n\n  // Attempt to place a gear by index\n  function attemptPlaceGear(index) {\n    if (state.phase !== 'play') return;\n    const gear = state.gears[index];\n    if (!gear) return;\n    // place animation start\n    state.phase = 'placing';\n    state.awaiting = true;\n    state.timeSincePhaseStart = 0;\n    state.placing = {\n      gearIndex: index,\n      startX: gear.x,\n      startY: gear.y,\n      progress: 0 // 0..1\n    };\n    playClick();\n    a11y.textContent = `You picked gear ${gear.value}. Placing...`;\n  }\n\n  // Evaluate placed gear when placement animation completes\n  function evaluatePlacement(gearValue) {\n    const required = state.machineTarget - state.machineBase;\n    if (gearValue === required) {\n      // correct\n      state.score += 10;\n      state.phase = 'correct';\n      state.timeSincePhaseStart = 0;\n      a11y.textContent = `Great! That was correct. Machine now reaches ${state.machineTarget}.`;\n      playCorrect();\n      // proceed to next level after short delay\n      setTimeout(() => {\n        state.levelIndex++;\n        if (state.levelIndex >= LEVEL_COUNT) {\n          state.phase = 'win';\n          a11y.textContent = `Congratulations! You fixed all machines. Score ${state.score}. Press R to play again.`;\n        } else {\n          prepareLevel(state.levelIndex);\n        }\n      }, 900);\n    } else {\n      // incorrect\n      state.lives--;\n      state.phase = 'incorrect';\n      state.timeSincePhaseStart = 0;\n      a11y.textContent = `Oops. That gear did not work. ${state.lives} ${state.lives === 1 ? 'life' : 'lives'} remaining.`;\n      playIncorrect();\n      setTimeout(() => {\n        if (state.lives <= 0) {\n          state.phase = 'gameover';\n          a11y.textContent = `Game over. Score ${state.score}. Press R to try again.`;\n        } else {\n          // return to same level with new gear positions (regenerate distractors)\n          prepareLevel(state.levelIndex);\n        }\n      }, 900);\n    }\n  }\n\n  // -------------------------\n  // Drawing functions\n  // -------------------------\n  function clear() {\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n  }\n\n  function drawBackground(t) {\n    // calming pastel gradient sky\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, '#eaf6ff');\n    g.addColorStop(1, '#f6f9ff');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // floating bubbles/wacky shapes for whimsy\n    ctx.globalAlpha = 0.12;\n    for (let i = 0; i < 7; i++) {\n      const bx = (i * 137 + (t * 0.02 * (i + 1))) % (WIDTH + 100) - 50;\n      const by = 40 + ((i * 77) % 180) + 10 * Math.sin((t / 800) + i);\n      ctx.beginPath();\n      ctx.fillStyle = ['#ffe8f0', '#e8fff4', '#fff0e8', '#e8f0ff'][i % 4];\n      ctx.arc(bx, by, 28 + (i % 3) * 6, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    ctx.globalAlpha = 1;\n  }\n\n  function drawConveyor() {\n    // conveyor base\n    ctx.fillStyle = '#d3e2ea';\n    roundRect(ctx, 50, 260, 620, 110, 20);\n    ctx.fill();\n\n    // belt stripes\n    ctx.save();\n    ctx.beginPath();\n    ctx.rect(60, 270, 600, 90);\n    ctx.clip();\n    for (let i = 0; i < 30; i++) {\n      ctx.fillStyle = i % 2 === 0 ? '#cbdfe8' : '#bcd0da';\n      ctx.fillRect(60 + (i * 40 + (performance.now() / 30)) % 40 - 40, 270, 30, 90);\n    }\n    ctx.restore();\n\n    // bolts\n    for (let i = 0; i < 8; i++) {\n      drawBolt(70 + i * 86, 282);\n      drawBolt(70 + i * 86, 342);\n    }\n  }\n\n  function drawBolt(x, y) {\n    ctx.fillStyle = '#f2f8fb';\n    ctx.beginPath();\n    ctx.arc(x, y, 6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = '#bcd0da';\n    ctx.stroke();\n  }\n\n  function drawMachine() {\n    // machine body\n    const mx = 180;\n    const my = 110;\n    ctx.save();\n    // main panel\n    ctx.fillStyle = '#cfe6ff';\n    roundRect(ctx, 120, 60, 420, 180, 18);\n    ctx.fill();\n    // window\n    ctx.fillStyle = '#ffffff';\n    roundRect(ctx, 420, 82, 110, 50, 8);\n    ctx.fill();\n    // screen showing base and target\n    ctx.fillStyle = '#1b3b4b';\n    ctx.font = '20px Arial';\n    ctx.textAlign = 'left';\n    ctx.fillText(`Base: ${state.machineBase}`, 140, 110);\n    ctx.fillText(`Target: ${state.machineTarget}`, 140, 140);\n\n    // wacky robot face\n    ctx.fillStyle = '#fff';\n    ctx.beginPath();\n    ctx.arc(470, 165, 36, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = '#333';\n    ctx.beginPath();\n    ctx.arc(458, 158, 6, 0, Math.PI * 2);\n    ctx.arc(482, 158, 6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = '#333';\n    ctx.beginPath();\n    ctx.moveTo(458, 175);\n    ctx.quadraticCurveTo(470, 182, 482, 175);\n    ctx.stroke();\n\n    ctx.restore();\n\n    // slot where gear is placed\n    ctx.save();\n    ctx.fillStyle = '#f1f7fb';\n    roundRect(ctx, 330, 250, 160, 76, 12);\n    ctx.fill();\n    ctx.strokeStyle = '#bcd0da';\n    ctx.strokeRect(330, 250, 160, 76);\n    ctx.fillStyle = '#7aa5c8';\n    ctx.font = '18px Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText('Place Gear Here', 410, 290);\n    ctx.restore();\n  }\n\n  function drawGears(t) {\n    // animate gears moving, draw selected highlight\n    for (let i = 0; i < state.gears.length; i++) {\n      const g = state.gears[i];\n      // update positions during play\n      if (state.phase === 'play') {\n        g.x -= (g.speed * (1 / 60)); // simple time step\n        if (g.x < -80) {\n          // wrap around\n          g.x = WIDTH + randInt(40, 160);\n          g.y = 300 + randInt(-20, 20);\n        }\n      }\n      // if placing this gear, the animation handled elsewhere\n      if (state.phase === 'placing' && state.placing && state.placing.gearIndex === i) {\n        // position will be set by placing progress during draw\n      }\n\n      // gear body\n      ctx.save();\n      const isSelected = i === state.selectedIndex;\n      ctx.translate(g.x, g.y);\n\n      // rotation for whimsy\n      const rot = (t / 800) * (i % 2 === 0 ? 1 : -1);\n      ctx.rotate(rot);\n\n      // teeth\n      const teeth = 8 + (g.radius % 5);\n      for (let j = 0; j < teeth; j++) {\n        ctx.beginPath();\n        ctx.fillStyle = '#e8f5ff';\n        const angle = (j / teeth) * Math.PI * 2;\n        const tx = Math.cos(angle) * (g.radius + 6);\n        const ty = Math.sin(angle) * (g.radius + 6);\n        ctx.arc(tx, ty, 6, 0, Math.PI * 2);\n        ctx.fill();\n      }\n\n      // main circle\n      ctx.beginPath();\n      ctx.fillStyle = isSelected ? '#ffd8a8' : '#fff';\n      ctx.arc(0, 0, g.radius, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.strokeStyle = '#b4cfe0';\n      ctx.lineWidth = 3;\n      ctx.stroke();\n\n      // value text\n      ctx.fillStyle = '#123';\n      ctx.font = '20px Arial';\n      ctx.textAlign = 'center';\n      ctx.fillText(String(g.value), 0, 6);\n\n      // small face\n      ctx.fillStyle = '#123';\n      ctx.beginPath();\n      ctx.arc(-g.radius / 3, -g.radius / 5, 3, 0, Math.PI * 2);\n      ctx.arc(g.radius / 3, -g.radius / 5, 3, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n    }\n  }\n\n  function drawHUD() {\n    // Lives hearts\n    ctx.fillStyle = '#333';\n    ctx.font = '16px Arial';\n    ctx.textAlign = 'left';\n    ctx.fillText('Lives: ', 16, 26);\n    for (let i = 0; i < MAX_LIVES; i++) {\n      ctx.beginPath();\n      const x = 80 + i * 22;\n      const y = 14;\n      heart(ctx, x, y, 12, i < state.lives ? '#ff7b86' : '#f1c7cc');\n    }\n\n    // Score\n    ctx.fillStyle = '#123';\n    ctx.font = '16px Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText('Score: ' + state.score, WIDTH / 2, 26);\n\n    // Level indicator\n    ctx.textAlign = 'right';\n    ctx.fillText(`Level ${state.levelIndex + 1}/${LEVEL_COUNT}`, WIDTH - 12, 26);\n\n    // Sound visual cue\n    ctx.fillStyle = audioEnabled ? '#1b9e7a' : '#c8c8c8';\n    ctx.beginPath();\n    ctx.arc(WIDTH - 30, HEIGHT - 30, 10, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = '#fff';\n    ctx.font = '10px Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText(audioEnabled ? '\ud83d\udd0a' : '\ud83d\udd08', WIDTH - 30, HEIGHT - 26);\n\n    // Instructions short\n    ctx.fillStyle = '#123';\n    ctx.font = '12px Arial';\n    ctx.textAlign = 'left';\n    ctx.fillText('Arrows: move  Enter: place  M: sound  R: restart', 12, HEIGHT - 12);\n  }\n\n  function drawOverlay() {\n    ctx.save();\n    if (state.phase === 'intro') {\n      ctx.fillStyle = 'rgba(20,30,40,0.2)';\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n      ctx.fillStyle = '#123';\n      ctx.font = '28px Arial';\n      ctx.textAlign = 'center';\n      ctx.fillText('Machine Math', WIDTH / 2, HEIGHT / 2 - 40);\n      ctx.font = '16px Arial';\n      ctx.fillText('Get the machine to the target by placing the right gear.', WIDTH / 2, HEIGHT / 2);\n      ctx.fillText('Press Enter to start.', WIDTH / 2, HEIGHT / 2 + 28);\n    } else if (state.phase === 'correct') {\n      // celebratory overlay\n      ctx.fillStyle = 'rgba(60,170,100,0.06)';\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    } else if (state.phase === 'incorrect') {\n      // red flash\n      const alpha = 0.2;\n      ctx.fillStyle = `rgba(200,50,50,${alpha})`;\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    } else if (state.phase === 'gameover') {\n      ctx.fillStyle = 'rgba(0,0,0,0.35)';\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n      ctx.fillStyle = '#fff';\n      ctx.font = '28px Arial';\n      ctx.textAlign = 'center';\n      ctx.fillText('Game Over', WIDTH / 2, HEIGHT / 2 - 20);\n      ctx.font = '16px Arial';\n      ctx.fillText(`Score: ${state.score}`, WIDTH / 2, HEIGHT / 2 + 6);\n      ctx.fillText('Press R to restart', WIDTH / 2, HEIGHT / 2 + 34);\n    } else if (state.phase === 'win') {\n      ctx.fillStyle = 'rgba(255,255,255,0.35)';\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n      ctx.fillStyle = '#123';\n      ctx.font = '26px Arial';\n      ctx.textAlign = 'center';\n      ctx.fillText('You fixed all the machines!', WIDTH / 2, HEIGHT / 2 - 10);\n      ctx.font = '16px Arial';\n      ctx.fillText(`Final Score: ${state.score}`, WIDTH / 2, HEIGHT / 2 + 20);\n      ctx.fillText('Press R to play again', WIDTH / 2, HEIGHT / 2 + 46);\n    }\n    ctx.restore();\n  }\n\n  function drawPlacing(t, dt) {\n    // If placing, animate the chosen gear moving into the machine slot\n    if (!state.placing) return;\n    const g = state.gears[state.placing.gearIndex];\n    const p = state.placing;\n    p.progress += dt / 500; // half-second travel\n    if (p.progress >= 1) p.progress = 1;\n    // ease\n    const e = easeOutCubic(p.progress);\n    const targetX = 410;\n    const targetY = 290;\n    const x = p.startX + (targetX - p.startX) * e;\n    const y = p.startY + (targetY - p.startY) * e;\n    // draw the moving gear above others\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate((t / 800) * 1.3);\n    // transient scale\n    const s = 1 + 0.12 * (1 - Math.abs(0.5 - p.progress) * 2);\n    ctx.scale(s, s);\n    // gear visuals\n    const gr = g.radius;\n    for (let j = 0; j < 9; j++) {\n      ctx.beginPath();\n      ctx.fillStyle = '#e8f5ff';\n      const angle = (j / 9) * Math.PI * 2;\n      const tx = Math.cos(angle) * (gr + 6);\n      const ty = Math.sin(angle) * (gr + 6);\n      ctx.arc(tx, ty, 6, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    ctx.beginPath();\n    ctx.fillStyle = '#fff';\n    ctx.arc(0, 0, gr, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = '#b4cfe0';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n    ctx.fillStyle = '#123';\n    ctx.font = '20px Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText(String(g.value), 0, 6);\n    ctx.restore();\n\n    if (p.progress >= 1 && state.awaiting) {\n      // finalize placement after slight pause\n      state.awaiting = false;\n      setTimeout(() => {\n        evaluatePlacement(g.value);\n      }, 150);\n    }\n  }\n\n  // -------------------------\n  // Main loop\n  // -------------------------\n  function loop(timestamp) {\n    const dt = lastTime ? timestamp - lastTime : 16;\n    lastTime = timestamp;\n    state.timeSincePhaseStart += dt;\n\n    // update placing progress if any\n    if (state.phase === 'placing' && state.placing) {\n      // nothing else; drawPlacing handles progress increment\n    }\n\n    // draw frame\n    draw(timestamp, dt);\n\n    animationFrameId = requestAnimationFrame(loop);\n  }\n\n  function draw(t = performance.now(), dt = 16) {\n    clear();\n    drawBackground(t);\n    drawConveyor();\n    drawMachine();\n    // update gear positions\n    if (state.phase === 'placing') {\n      // while placing, still move other gears a little\n      for (const g of state.gears) {\n        if (state.placing && state.placing.gearIndex === g.id) continue;\n        g.x -= (g.speed * (dt / 1000));\n        if (g.x < -80) g.x = WIDTH + randInt(40, 160);\n      }\n    }\n    drawGears(t);\n    drawPlacing(t, dt);\n    drawHUD();\n    drawOverlay();\n  }\n\n  // Start animation\n  animationFrameId = requestAnimationFrame(loop);\n\n  // -------------------------\n  // Utility drawing helpers\n  // -------------------------\n  function roundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n  }\n\n  function heart(ctx, x, y, size, color) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.scale(size / 24, size / 24);\n    ctx.beginPath();\n    ctx.moveTo(0, 10);\n    ctx.bezierCurveTo(-12, -2, -12, -10, 0, -10);\n    ctx.bezierCurveTo(12, -10, 12, -2, 0, 10);\n    ctx.closePath();\n    ctx.fillStyle = color;\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function easeOutCubic(t) {\n    return 1 - Math.pow(1 - t, 3);\n  }\n\n  // -------------------------\n  // Announcements and accessibility\n  // -------------------------\n  function announce(text) {\n    a11y.textContent = text;\n    // also console for debug\n    console.log('Announce:', text);\n  }\n\n  // -------------------------\n  // Clean up on page unload\n  // -------------------------\n  window.addEventListener('unload', () => {\n    if (animationFrameId) cancelAnimationFrame(animationFrameId);\n    if (audioContext) {\n      try {\n        audioContext.close();\n      } catch (e) {}\n    }\n  });\n\n  // -------------------------\n  // Provide a small warm greeting\n  // -------------------------\n  a11y.textContent = 'Welcome to Machine Math. Press Enter to begin, or use the controls.';\n\n  // Set initial focus to canvas\n  setTimeout(() => { canvas.focus(); }, 200);\n\n  // Ensure audio starts on user gesture if blocked\n  function handleFirstInteraction() {\n    if (audioEnabled) {\n      try {\n        tryCreateAudioContext();\n        if (audioContext && audioContext.state === 'suspended') {\n          audioContext.resume().catch(() => {});\n        }\n      } catch (e) {}\n    }\n    // remove listener after first use\n    window.removeEventListener('pointerdown', handleFirstInteraction);\n    window.removeEventListener('keydown', handleFirstInteraction);\n  }\n  window.addEventListener('pointerdown', handleFirstInteraction);\n  window.addEventListener('keydown', handleFirstInteraction);\n\n})();\n---\n",
  "improve_response_tokens": 18849,
  "formatted_code": true,
  "formatting_response_tokens": 20065,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}