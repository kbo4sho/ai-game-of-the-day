{
  "generated_date": "2025-10-21",
  "generated_timestamp": "2025-10-21T00:28:37.198158",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 10663,
  "game_filename": "2025-10-21.js",
  "game_size_bytes": 30792,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Drone Math Adventure - JavaScript game\n// Renders into existing HTML element with ID \"game-of-the-day-stage\"\n// Game area is exactly 720x480, uses Canvas + Web Audio API, accessible controls, restart, win/lose screens.\n\n// Immediately-invoked function to avoid global namespace pollution\n(function () {\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const TARGET_GOAL = 10; // win when player answers this many correctly\n  const MAX_WRONG = 3; // lose after this many wrong answers\n  const DRONE_SPEED = 220; // pixels per second\n  const CRATE_COUNT = 4;\n  const CRATE_MIN = 1;\n  const CRATE_MAX = 15;\n  const UI_PADDING = 10;\n  const SCORE_FONT = \"18px sans-serif\"; // important info\n  const BODY_FONT = \"16px sans-serif\"; // body text minimum 14\n  const TITLE_FONT = \"24px sans-serif\";\n\n  // Get container element\n  const container = document.getElementById(\"game-of-the-day-stage\");\n  if (!container) {\n    console.error(\"Container element with ID 'game-of-the-day-stage' not found.\");\n    return;\n  }\n\n  // Create canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.tabIndex = 0; // make focusable for keyboard\n  canvas.setAttribute(\"role\", \"application\");\n  canvas.setAttribute(\"aria-label\", \"Drone Math Adventure. Use arrow keys or WASD to move. Press space or click crates to collect answers.\");\n  canvas.style.outline = \"none\";\n  container.innerHTML = \"\"; // clear container\n  container.appendChild(canvas);\n  const ctx = canvas.getContext(\"2d\");\n\n  // Audio setup with error handling\n  let audioCtx = null;\n  let audioAllowed = false;\n  let audioUnavailable = false;\n  const createAudioContext = () => {\n    if (audioCtx || audioUnavailable) return;\n    try {\n      const Ctx = window.AudioContext || window.webkitAudioContext;\n      if (!Ctx) throw new Error(\"Web Audio API not supported\");\n      audioCtx = new Ctx();\n      // To satisfy mobile/browser autoplay policies, resume on user gesture if suspended\n      if (audioCtx.state === \"suspended\") {\n        audioCtx.resume().then(() => {\n          audioAllowed = true;\n        }).catch((e) => {\n          console.warn(\"Audio context resume failed:\", e);\n          audioAllowed = false;\n        });\n      } else {\n        audioAllowed = true;\n      }\n    } catch (e) {\n      console.error(\"Audio context creation failed:\", e);\n      audioUnavailable = true;\n      audioCtx = null;\n      audioAllowed = false;\n    }\n  };\n\n  // Call createAudioContext on first user gesture to minimize autoplay issues\n  const requireAudioGesture = () => {\n    if (!audioCtx) createAudioContext();\n  };\n\n  // Sound helpers using oscillators\n  function playTone(frequency = 440, duration = 0.2, type = \"sine\", volume = 0.06) {\n    if (!audioCtx || !audioAllowed) return;\n    try {\n      const now = audioCtx.currentTime;\n      const osc = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n      osc.type = type;\n      osc.frequency.value = frequency;\n      gain.gain.setValueAtTime(0, now);\n      gain.gain.linearRampToValueAtTime(volume, now + 0.01);\n      gain.gain.exponentialRampToValueAtTime(0.001, now + duration);\n      osc.connect(gain).connect(audioCtx.destination);\n      osc.start(now);\n      osc.stop(now + duration + 0.02);\n    } catch (e) {\n      console.warn(\"playTone failed:\", e);\n    }\n  }\n\n  function playPositiveSound() {\n    if (!audioCtx || !audioAllowed) return;\n    // Arpeggio: ascending short tones\n    playTone(440, 0.12, \"sine\", 0.06);\n    setTimeout(() => playTone(554.37, 0.12, \"sine\", 0.06), 120);\n    setTimeout(() => playTone(659.25, 0.18, \"sine\", 0.07), 260);\n  }\n\n  function playNegativeSound() {\n    if (!audioCtx || !audioAllowed) return;\n    // Vibrating buzz\n    try {\n      const now = audioCtx.currentTime;\n      const osc = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n      const biquad = audioCtx.createBiquadFilter();\n      osc.type = \"square\";\n      osc.frequency.value = 150;\n      biquad.type = \"lowpass\";\n      biquad.frequency.value = 600;\n      gain.gain.setValueAtTime(0.0001, now);\n      gain.gain.exponentialRampToValueAtTime(0.08, now + 0.005);\n      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);\n      osc.connect(biquad).connect(gain).connect(audioCtx.destination);\n      osc.start(now);\n      osc.stop(now + 0.45);\n    } catch (e) {\n      console.warn(\"playNegativeSound failed:\", e);\n    }\n  }\n\n  // Gentle background hum (optional, togglable)\n  let humOsc = null;\n  let humGain = null;\n  function startHum() {\n    if (!audioCtx || !audioAllowed || humOsc) return;\n    try {\n      humOsc = audioCtx.createOscillator();\n      humGain = audioCtx.createGain();\n      humOsc.type = \"sine\";\n      humOsc.frequency.value = 120;\n      humGain.gain.value = 0.008;\n      const lfo = audioCtx.createOscillator();\n      const lfoGain = audioCtx.createGain();\n      lfo.type = \"sine\";\n      lfo.frequency.value = 0.12;\n      lfoGain.gain.value = 20;\n      lfo.connect(lfoGain);\n      lfoGain.connect(humOsc.detune);\n      humOsc.connect(humGain).connect(audioCtx.destination);\n      lfo.start();\n      humOsc.start();\n    } catch (e) {\n      console.warn(\"startHum failed:\", e);\n      humOsc = null;\n      humGain = null;\n    }\n  }\n  function stopHum() {\n    try {\n      if (humOsc) {\n        humOsc.stop();\n        humOsc.disconnect();\n        humOsc = null;\n      }\n      if (humGain) {\n        humGain.disconnect();\n        humGain = null;\n      }\n    } catch (e) {\n      console.warn(\"stopHum failed:\", e);\n    }\n  }\n\n  // Game state\n  let lastTime = performance.now();\n  let keys = {};\n  let mouse = { x: 0, y: 0, clicked: false };\n  let gameState = \"intro\"; // \"playing\", \"won\", \"lost\"\n  let score = 0;\n  let wrongs = 0;\n  let drone = {\n    x: WIDTH / 2,\n    y: HEIGHT / 2,\n    r: 22,\n    angle: 0,\n    color: \"#6fb1ff\"\n  };\n  let crates = [];\n  let currentTarget = null; // target sum number\n  let hintText = \"Move the drone to pick the crate with the correct answer!\";\n  let uiSoundEnabled = true;\n  let audioStatusMsg = \"Sound: unknown\";\n  let // control info used for bottom instructions\n    controlsText =\n      \"Controls: Arrow keys / WASD to move. Space or click a crate to collect. Press S to toggle sound. Enter to restart when game ends.\";\n\n  // Utility functions\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  function clamp(v, a, b) {\n    return Math.max(a, Math.min(b, v));\n  }\n\n  function distance(a, b) {\n    const dx = a.x - b.x;\n    const dy = a.y - b.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  // Generate crates ensuring not too close to UI top area and not overlapping drone start\n  function spawnCrates() {\n    crates = [];\n    const marginTop = 80; // to avoid overlapping top UI\n    for (let i = 0; i < CRATE_COUNT; i++) {\n      let tries = 0;\n      while (tries < 200) {\n        const w = 56;\n        const h = 46;\n        const x = randInt(UI_PADDING + 20, WIDTH - w - UI_PADDING - 20);\n        const y = randInt(marginTop + 10, HEIGHT - h - 80); // avoid bottom instructions area\n        const num = randInt(CRATE_MIN, CRATE_MAX);\n        const rect = { x, y, w, h, num, id: Math.random().toString(36).slice(2, 9) };\n        // Ensure not overlapping other crates\n        let ok = true;\n        for (const c of crates) {\n          if (Math.abs(c.x - rect.x) < 70 && Math.abs(c.y - rect.y) < 60) {\n            ok = false;\n            break;\n          }\n        }\n        // Not too close to drone\n        if (ok && Math.abs(rect.x - drone.x) < 80 && Math.abs(rect.y - drone.y) < 80) ok = false;\n        if (ok) {\n          crates.push(rect);\n          break;\n        }\n        tries++;\n      }\n    }\n  }\n\n  // Generate a math question as target sum (simple addition/subtraction)\n  function generateQuestion() {\n    // Create target between 3 and 16 (age-appropriate)\n    const a = randInt(1, 9);\n    const b = randInt(1, 9);\n    // 50% chance addition or subtraction (but subtraction result must be >=1)\n    if (Math.random() < 0.7) {\n      currentTarget = { text: `${a} + ${b}`, value: a + b };\n    } else {\n      const a2 = Math.max(a, b);\n      const b2 = Math.min(a, b);\n      currentTarget = { text: `${a2} - ${b2}`, value: a2 - b2 };\n    }\n    // Ensure crates include the correct answer\n    // Place correct answer in a random crate and fill other crates with random numbers\n    const answerIndex = randInt(0, crates.length - 1);\n    const used = new Set([crates[answerIndex].num]);\n    crates[answerIndex].num = currentTarget.value;\n    used.add(currentTarget.value);\n    // Fill others with non-equal numbers\n    for (let i = 0; i < crates.length; i++) {\n      if (i === answerIndex) continue;\n      let tries = 0;\n      while (tries < 200) {\n        const n = randInt(CRATE_MIN, CRATE_MAX);\n        if (!used.has(n)) {\n          crates[i].num = n;\n          used.add(n);\n          break;\n        }\n        tries++;\n      }\n    }\n  }\n\n  // Reset game\n  function resetGame() {\n    score = 0;\n    wrongs = 0;\n    drone.x = WIDTH / 2;\n    drone.y = HEIGHT - 100;\n    drone.angle = 0;\n    spawnCrates();\n    generateQuestion();\n    gameState = \"playing\";\n    hintText = \"Collect the crate with the answer to the math problem shown.\";\n    // Initialize audio context on first start if possible\n    createAudioContext();\n    if (audioCtx && audioAllowed) {\n      startHum();\n      audioStatusMsg = \"Sound: on\";\n    } else if (audioUnavailable) {\n      audioStatusMsg = \"Sound: unavailable\";\n    } else {\n      audioStatusMsg = \"Sound: off (press S to enable)\";\n    }\n  }\n\n  // Handle picking a crate (by clicking or space key)\n  function pickCrate(crate) {\n    if (!crate) return;\n    if (gameState !== \"playing\") return;\n    if (crate.num === currentTarget.value) {\n      score++;\n      playPositiveSound();\n      // small celebration animation (bump drone color)\n      drone.color = \"#8ef4a3\";\n      setTimeout(() => (drone.color = \"#6fb1ff\"), 220);\n      if (score >= TARGET_GOAL) {\n        gameState = \"won\";\n        stopHum();\n      } else {\n        // new question: respawn crates and generate next\n        spawnCrates();\n        generateQuestion();\n      }\n    } else {\n      wrongs++;\n      playNegativeSound();\n      drone.color = \"#ffb1b1\";\n      setTimeout(() => (drone.color = \"#6fb1ff\"), 300);\n      if (wrongs >= MAX_WRONG) {\n        gameState = \"lost\";\n        stopHum();\n      }\n    }\n  }\n\n  // Find nearest crate to drone within pick radius\n  function findNearestCrate(radius = 50) {\n    let nearest = null;\n    let minD = Infinity;\n    for (const c of crates) {\n      const center = { x: c.x + c.w / 2, y: c.y + c.h / 2 };\n      const d = distance(drone, center);\n      if (d < minD) {\n        minD = d;\n        nearest = c;\n      }\n    }\n    if (minD <= radius) return nearest;\n    return null;\n  }\n\n  // Input event handlers\n  canvas.addEventListener(\"keydown\", (e) => {\n    // start audio context on first interaction\n    requireAudioGesture();\n    keys[e.key.toLowerCase()] = true;\n    // Prevent arrow keys from scrolling\n    if ([\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\", \" \"].includes(e.key)) {\n      e.preventDefault();\n    }\n    // Space: pick nearest crate\n    if (e.key === \" \" || e.key === \"Spacebar\") {\n      if (gameState === \"playing\") {\n        const c = findNearestCrate(60);\n        if (c) pickCrate(c);\n      } else if (gameState === \"won\" || gameState === \"lost\") {\n        resetGame();\n      }\n    }\n    // Enter to restart on end screens\n    if (e.key === \"Enter\" && (gameState === \"won\" || gameState === \"lost\")) {\n      resetGame();\n    }\n    // S to toggle sound\n    if (e.key.toLowerCase() === \"s\") {\n      // toggle audio context: create if none, start/stop hum\n      if (!audioCtx) {\n        createAudioContext();\n      }\n      if (audioCtx && audioAllowed) {\n        if (humOsc) {\n          stopHum();\n          audioStatusMsg = \"Sound: off\";\n        } else {\n          startHum();\n          audioStatusMsg = \"Sound: on\";\n        }\n      } else if (!audioUnavailable) {\n        // attempt to resume\n        if (audioCtx && audioCtx.state === \"suspended\") {\n          audioCtx.resume().then(() => {\n            audioAllowed = true;\n            startHum();\n            audioStatusMsg = \"Sound: on\";\n          }).catch((err) => {\n            console.warn(\"Audio resume failed:\", err);\n            audioStatusMsg = \"Sound: unavailable\";\n          });\n        } else {\n          audioStatusMsg = \"Sound: unavailable\";\n        }\n      }\n    }\n  });\n  canvas.addEventListener(\"keyup\", (e) => {\n    keys[e.key.toLowerCase()] = false;\n  });\n\n  // Mouse / touch events\n  canvas.addEventListener(\"mousemove\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);\n    mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);\n  });\n  canvas.addEventListener(\"mousedown\", (e) => {\n    requireAudioGesture();\n    mouse.clicked = true;\n    const rect = canvas.getBoundingClientRect();\n    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);\n    const my = (e.clientY - rect.top) * (canvas.height / rect.height);\n    // If in end-screen restart button area, allow restart\n    if ((gameState === \"won\" || gameState === \"lost\")) {\n      // Drawn restart button coordinates will be known during render; approximate clickable area centered\n      // We'll check if click is within center button area\n      const bx = WIDTH / 2 - 90;\n      const by = HEIGHT / 2 + 36;\n      const bw = 180;\n      const bh = 44;\n      if (mx >= bx && mx <= bx + bw && my >= by && my <= by + bh) {\n        resetGame();\n        return;\n      }\n    }\n    // Check if clicked on any crate\n    for (const c of crates) {\n      if (mx >= c.x && mx <= c.x + c.w && my >= c.y && my <= c.y + c.h) {\n        pickCrate(c);\n        break;\n      }\n    }\n  });\n  canvas.addEventListener(\"mouseup\", () => {\n    mouse.clicked = false;\n  });\n  canvas.addEventListener(\"touchstart\", (e) => {\n    requireAudioGesture();\n    const t = e.touches[0];\n    const rect = canvas.getBoundingClientRect();\n    mouse.x = (t.clientX - rect.left) * (canvas.width / rect.width);\n    mouse.y = (t.clientY - rect.top) * (canvas.height / rect.height);\n    mouse.clicked = true;\n    e.preventDefault();\n    // click behavior mirrors mousedown\n    for (const c of crates) {\n      if (mouse.x >= c.x && mouse.x <= c.x + c.w && mouse.y >= c.y && mouse.y <= c.y + c.h) {\n        pickCrate(c);\n        break;\n      }\n    }\n  }, { passive: false });\n  canvas.addEventListener(\"touchmove\", (e) => {\n    const t = e.touches[0];\n    const rect = canvas.getBoundingClientRect();\n    mouse.x = (t.clientX - rect.left) * (canvas.width / rect.width);\n    mouse.y = (t.clientY - rect.top) * (canvas.height / rect.height);\n  });\n  canvas.addEventListener(\"touchend\", () => {\n    mouse.clicked = false;\n  });\n\n  // Drawing helpers\n  function drawRoundedRect(x, y, w, h, r = 8, fillStyle = \"#fff\", strokeStyle = \"#000\", lineWidth = 1) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fillStyle) {\n      ctx.fillStyle = fillStyle;\n      ctx.fill();\n    }\n    if (strokeStyle) {\n      ctx.lineWidth = lineWidth;\n      ctx.strokeStyle = strokeStyle;\n      ctx.stroke();\n    }\n  }\n\n  // Text wrapping function\n  function drawWrappedText(text, x, y, maxWidth, lineHeight, align = \"center\", font = BODY_FONT, bg = null) {\n    ctx.font = font;\n    const words = text.split(\" \");\n    let line = \"\";\n    let lines = [];\n    for (let n = 0; n < words.length; n++) {\n      const testLine = line + words[n] + \" \";\n      const metrics = ctx.measureText(testLine);\n      const testWidth = metrics.width;\n      if (testWidth > maxWidth && n > 0) {\n        lines.push(line.trim());\n        line = words[n] + \" \";\n      } else {\n        line = testLine;\n      }\n    }\n    lines.push(line.trim());\n    // Draw background if specified\n    if (bg) {\n      const textHeight = lines.length * lineHeight;\n      const tw = maxWidth + 10;\n      const th = textHeight + 10;\n      const bx = x - tw / 2;\n      const by = y - th / 2;\n      drawRoundedRect(bx, by, tw, th, 10, bg.fill, bg.stroke, bg.lineWidth);\n    }\n    ctx.fillStyle = \"#073b4c\";\n    ctx.textAlign = align;\n    ctx.textBaseline = \"top\";\n    for (let i = 0; i < lines.length; i++) {\n      ctx.fillText(lines[i], x, y + i * lineHeight);\n    }\n  }\n\n  // Prevent overlapping of UI text: compute positions using measureText\n  function computeUILayout() {\n    ctx.font = SCORE_FONT;\n    const scoreText = `Score: ${score}`;\n    const scoreW = ctx.measureText(scoreText).width;\n    const scoreX = UI_PADDING;\n    const scoreY = UI_PADDING;\n\n    ctx.font = SCORE_FONT;\n    const targetText = currentTarget ? `Problem: ${currentTarget.text}` : \"Problem:\";\n    const targetW = ctx.measureText(targetText).width;\n    const targetXCenter = WIDTH / 2;\n    const targetLeft = targetXCenter - targetW / 2;\n    const targetY = UI_PADDING;\n\n    ctx.font = SCORE_FONT;\n    const livesText = `Lives: ${Math.max(0, MAX_WRONG - wrongs)}`;\n    const livesW = ctx.measureText(livesText).width;\n    const livesX = WIDTH - UI_PADDING - livesW;\n    const livesY = UI_PADDING;\n\n    // Ensure at least 10px spacing between left, center, right items\n    // If center overlaps either, move center down by 30 px\n    let centerY = targetY;\n    const scoreRight = scoreX + scoreW;\n    const livesLeft = livesX;\n    if (targetLeft - scoreRight < 10 || livesLeft - (targetLeft + targetW) < 10) {\n      centerY = targetY + 36;\n    }\n    return {\n      score: { text: scoreText, x: scoreX, y: scoreY, w: scoreW },\n      target: { text: targetText, x: targetXCenter, y: centerY, w: targetW },\n      lives: { text: livesText, x: livesX, y: livesY, w: livesW }\n    };\n  }\n\n  // Drawing scene elements: calming background with wacky elements\n  function drawBackground() {\n    // Sky gradient\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, \"#eaf6ff\");\n    g.addColorStop(0.6, \"#f6fbff\");\n    g.addColorStop(1, \"#eef6f5\");\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Soft rolling hills (calming shapes)\n    ctx.fillStyle = \"#cfeedd\";\n    ctx.beginPath();\n    ctx.moveTo(0, HEIGHT * 0.65);\n    ctx.quadraticCurveTo(WIDTH * 0.25, HEIGHT * 0.55, WIDTH * 0.5, HEIGHT * 0.66);\n    ctx.quadraticCurveTo(WIDTH * 0.75, HEIGHT * 0.77, WIDTH, HEIGHT * 0.65);\n    ctx.lineTo(WIDTH, HEIGHT);\n    ctx.lineTo(0, HEIGHT);\n    ctx.closePath();\n    ctx.fill();\n\n    // Wacky mountains\n    ctx.fillStyle = \"#e6f6ff\";\n    ctx.beginPath();\n    ctx.moveTo(40, HEIGHT * 0.7);\n    ctx.lineTo(140, HEIGHT * 0.44);\n    ctx.lineTo(240, HEIGHT * 0.7);\n    ctx.closePath();\n    ctx.fill();\n\n    ctx.beginPath();\n    ctx.moveTo(340, HEIGHT * 0.72);\n    ctx.lineTo(460, HEIGHT * 0.42);\n    ctx.lineTo(560, HEIGHT * 0.72);\n    ctx.closePath();\n    ctx.fill();\n\n    // Floating clouds (wacky)\n    drawCloud(80, 80, 64, 28, \"#ffffff\");\n    drawCloud(220, 60, 54, 24, \"#ffffff\");\n    drawCloud(520, 90, 74, 30, \"#ffffff\");\n    drawCloud(620, 50, 48, 20, \"#ffffff\");\n\n    // Friendly landmark - a silly radio tower for drones\n    drawTower(620, HEIGHT * 0.59, 36, 110);\n  }\n\n  function drawCloud(cx, cy, w, h, color) {\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.ellipse(cx - w * 0.2, cy, w * 0.32, h * 0.6, 0, 0, Math.PI * 2);\n    ctx.ellipse(cx + w * 0.2, cy, w * 0.28, h * 0.55, 0, 0, Math.PI * 2);\n    ctx.ellipse(cx, cy - h * 0.1, w * 0.3, h * 0.5, 0, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  function drawTower(x, y, w, h) {\n    // tower base\n    ctx.fillStyle = \"#ffd27f\";\n    drawRoundedRect(x - w / 2, y - h, w, h, 6, \"#ffd27f\", \"#d08a2f\", 2);\n    // antenna\n    ctx.fillStyle = \"#ffefc2\";\n    ctx.fillRect(x - 2, y - h - 18, 4, 18);\n    // small signal rings\n    ctx.strokeStyle = \"#ffd27f\";\n    ctx.lineWidth = 1.6;\n    ctx.beginPath();\n    ctx.arc(x, y - h - 26, 12, 0, Math.PI * 2);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.arc(x, y - h - 26, 20, 0, Math.PI * 2);\n    ctx.stroke();\n  }\n\n  // Draw drone\n  function drawDrone(dt) {\n    // angle by velocity/keys\n    ctx.save();\n    ctx.translate(drone.x, drone.y);\n    ctx.rotate(drone.angle);\n    // propellers\n    ctx.fillStyle = \"#f0f9ff\";\n    ctx.beginPath();\n    ctx.ellipse(-26, -8, 16, 6, Math.sin(performance.now() / 180) * 0.6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.ellipse(26, -8, 16, 6, Math.cos(performance.now() / 180) * 0.6, 0, Math.PI * 2);\n    ctx.fill();\n    // body\n    drawRoundedRect(-20, -18, 40, 36, 10, drone.color, \"#0b4b6a\", 2);\n    // cockpit\n    ctx.fillStyle = \"#072f44\";\n    ctx.beginPath();\n    ctx.ellipse(6, 0, 10, 9, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n\n    // Friendly shadow\n    ctx.fillStyle = \"rgba(6,40,50,0.06)\";\n    ctx.beginPath();\n    ctx.ellipse(drone.x, drone.y + 30, 44, 12, 0, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  // Draw crates\n  function drawCrates() {\n    for (const c of crates) {\n      // crate box\n      drawRoundedRect(c.x, c.y, c.w, c.h, 8, \"#fff1cc\", \"#b98d4f\", 2);\n      // sticker with number\n      ctx.fillStyle = \"#ffd27f\";\n      drawRoundedRect(c.x + 6, c.y + 8, c.w - 12, c.h - 16, 6, \"#ffeead\", \"#b98d4f\", 1.2);\n      // draw number\n      ctx.font = TITLE_FONT;\n      ctx.fillStyle = \"#073b4c\";\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillText(String(c.num), c.x + c.w / 2, c.y + c.h / 2);\n    }\n  }\n\n  // Draw UI: score, lives, target, instructions\n  function drawUI() {\n    const layout = computeUILayout();\n\n    // Score background\n    ctx.font = SCORE_FONT;\n    const scorePad = 8;\n    const scoreH = 30;\n    drawRoundedRect(layout.score.x - scorePad, layout.score.y - 6, layout.score.w + scorePad * 2, scoreH, 8, \"#ffffffcc\", \"#073b4c\", 1);\n    ctx.fillStyle = \"#073b4c\";\n    ctx.textAlign = \"left\";\n    ctx.textBaseline = \"middle\";\n    ctx.font = SCORE_FONT;\n    ctx.fillText(layout.score.text, layout.score.x + 6, layout.score.y + scoreH / 2 - 6);\n\n    // Target background (center)\n    const targetW = Math.max(layout.target.w + 24, 180);\n    const targetH = 36;\n    drawRoundedRect(widthSafe(layout.target.x - targetW / 2), layout.target.y - 6, targetW, targetH, 10, \"#e8f7ff\", \"#0b5775\", 1.5);\n    ctx.fillStyle = \"#0b5775\";\n    ctx.font = TITLE_FONT;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    const targetText = currentTarget ? `Solve: ${currentTarget.text}` : \"Solve:\";\n    ctx.fillText(targetText, layout.target.x, layout.target.y + targetH / 2 - 6);\n\n    // Lives background\n    const livesPad = 8;\n    const livesH = 30;\n    drawRoundedRect(layout.lives.x - livesPad, layout.lives.y - 6, layout.lives.w + livesPad * 2, livesH, 8, \"#fff1f1\", \"#6b0505\", 1);\n    ctx.fillStyle = \"#6b0505\";\n    ctx.font = SCORE_FONT;\n    ctx.textAlign = \"left\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(layout.lives.text, layout.lives.x + 6, layout.lives.y + livesH / 2 - 6);\n\n    // Draw heart icons for lives count (visual)\n    const remaining = Math.max(0, MAX_WRONG - wrongs);\n    const heartXStart = WIDTH - UI_PADDING - 6 - layout.lives.w - 8 - (remaining * 18);\n    for (let i = 0; i < remaining; i++) {\n      drawHeart(heartXStart + i * 18, layout.lives.y + 12, 7, \"#ff6b6b\");\n    }\n\n    // Bottom-center instructions with background and wrapped text\n    const instrY = HEIGHT - 68;\n    drawWrappedText(controlsText, WIDTH / 2, instrY, WIDTH - 40, 20, \"center\", BODY_FONT, { fill: \"#ffffffcc\", stroke: \"#073b4c\", lineWidth: 1 });\n\n    // Audio status small badge (top-left below score)\n    ctx.font = \"14px sans-serif\";\n    const audText = audioUnavailable ? \"Audio unavailable\" : audioStatusMsg;\n    const aw = ctx.measureText(audText).width + 12;\n    drawRoundedRect(UI_PADDING, layout.score.y + 36, aw, 24, 8, \"#ffffffcc\", \"#073b4c\", 1);\n    ctx.fillStyle = \"#073b4c\";\n    ctx.textAlign = \"left\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(audText, UI_PADDING + 6, layout.score.y + 48 - 6);\n\n    // Hint text left-bottom\n    ctx.font = BODY_FONT;\n    ctx.textAlign = \"left\";\n    ctx.fillStyle = \"#073b4c\";\n    const hintBoxW = 300;\n    drawRoundedRect(UI_PADDING, HEIGHT - 130, hintBoxW, 44, 8, \"#e6faff\", \"#0b5775\", 1);\n    ctx.fillStyle = \"#0b5775\";\n    ctx.fillText(hintText, UI_PADDING + 10, HEIGHT - 108);\n\n    // Visual cue for audio enabled/disabled (speaker icon)\n    drawSpeaker(UI_PADDING + aw + 12, layout.score.y + 44, audioUnavailable ? \"#bdbdbd\" : (humOsc ? \"#0b5775\" : \"#6b6b6b\"));\n\n    // Avoid overlapping: ensure bottom instructions do not overlap crates; crates were spawned avoiding bottom area.\n  }\n\n  function widthSafe(v) {\n    // ensure rectangle inside canvas\n    return Math.max(8, Math.min(v, WIDTH - 8));\n  }\n\n  function drawHeart(x, y, size, color) {\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(x, y);\n    ctx.bezierCurveTo(x, y - size / 2, x - size, y - size / 2, x - size, y + size / 3);\n    ctx.bezierCurveTo(x - size, y + size, x, y + size * 1.4, x, y + size * 1.8);\n    ctx.bezierCurveTo(x, y + size * 1.4, x + size, y + size, x + size, y + size / 3);\n    ctx.bezierCurveTo(x + size, y - size / 2, x, y - size / 2, x, y);\n    ctx.fill();\n  }\n\n  function drawSpeaker(x, y, color) {\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(x, y - 6);\n    ctx.lineTo(x + 8, y - 10);\n    ctx.lineTo(x + 8, y + 10);\n    ctx.lineTo(x, y + 6);\n    ctx.closePath();\n    ctx.fill();\n    if (!audioUnavailable && humOsc) {\n      // draw sound waves\n      ctx.strokeStyle = \"#0b5775\";\n      ctx.lineWidth = 1.2;\n      ctx.beginPath();\n      ctx.arc(x + 12, y - 2, 8, -0.6, 0.6);\n      ctx.stroke();\n    }\n  }\n\n  // End screens\n  function drawEndScreen() {\n    // dark overlay\n    ctx.fillStyle = \"rgba(2,15,22,0.5)\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Panel\n    const panelW = 520;\n    const panelH = 220;\n    const px = (WIDTH - panelW) / 2;\n    const py = (HEIGHT - panelH) / 2;\n    drawRoundedRect(px, py, panelW, panelH, 12, \"#ffffff\", \"#073b4c\", 2);\n\n    ctx.fillStyle = \"#073b4c\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"top\";\n    ctx.font = TITLE_FONT;\n\n    if (gameState === \"won\") {\n      ctx.fillText(\"Victory! Drone Mission Accomplished\", WIDTH / 2, py + 18);\n      ctx.font = SCORE_FONT;\n      ctx.fillText(`You answered ${score} correct problems!`, WIDTH / 2, py + 64);\n    } else {\n      ctx.fillText(\"Game Over\", WIDTH / 2, py + 18);\n      ctx.font = SCORE_FONT;\n      ctx.fillText(`You answered ${score} correctly. Try again!`, WIDTH / 2, py + 64);\n    }\n\n    // Restart button\n    const bx = WIDTH / 2 - 90;\n    const by = py + panelH - 80;\n    const bw = 180;\n    const bh = 44;\n    drawRoundedRect(bx, by, bw, bh, 10, \"#eaf6ff\", \"#0b5775\", 2);\n    ctx.fillStyle = \"#0b5775\";\n    ctx.font = BODY_FONT;\n    ctx.fillText(\"Restart Mission\", WIDTH / 2, by + 12);\n\n    // Instruction small\n    ctx.font = \"14px sans-serif\";\n    ctx.fillStyle = \"#0b5775\";\n    ctx.fillText(\"Click the button or press Enter to try again\", WIDTH / 2, by + bh + 12);\n  }\n\n  // Game loop\n  function update(dt) {\n    if (gameState !== \"playing\") return;\n    // Movement input\n    let vx = 0,\n      vy = 0;\n    if (keys[\"arrowleft\"] || keys[\"a\"]) vx -= 1;\n    if (keys[\"arrowright\"] || keys[\"d\"]) vx += 1;\n    if (keys[\"arrowup\"] || keys[\"w\"]) vy -= 1;\n    if (keys[\"arrowdown\"] || keys[\"s\"]) vy += 1;\n    // Normalize\n    if (vx !== 0 || vy !== 0) {\n      const len = Math.sqrt(vx * vx + vy * vy);\n      vx /= len;\n      vy /= len;\n      drone.x += vx * DRONE_SPEED * dt;\n      drone.y += vy * DRONE_SPEED * dt;\n      drone.angle = Math.atan2(vy, vx) + Math.PI / 2;\n    } else {\n      // subtle wobble when idle\n      drone.angle = Math.sin(performance.now() / 600) * 0.06;\n    }\n    // Keep within bounds\n    drone.x = clamp(drone.x, 30, WIDTH - 30);\n    drone.y = clamp(drone.y, 40, HEIGHT - 40);\n\n    // If mouse clicked near crate, pick it (for continuous dragging clicks we only handle down events)\n    // handled in mousedown event\n\n    // Ensure crates don't overlap UI (they were spawned with margins), but ensure not on top of drone while playing\n    for (const c of crates) {\n      if (Math.abs(c.x + c.w / 2 - drone.x) < 18 && Math.abs(c.y + c.h / 2 - drone.y) < 18) {\n        // nudge crate\n        c.x += randInt(-30, 30);\n        c.y += randInt(-30, 30);\n        c.x = clamp(c.x, UI_PADDING + 10, WIDTH - c.w - UI_PADDING - 10);\n        c.y = clamp(c.y, 80, HEIGHT - c.h - 90);\n      }\n    }\n  }\n\n  function render(dt) {\n    // Clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // Background and elements\n    drawBackground();\n\n    // Draw crates and drone (order matters)\n    drawCrates();\n    drawDrone(dt);\n\n    // UI\n    drawUI();\n\n    // If mouse is hovering near a crate, give a visual highlight and potential pick hint\n    for (const c of crates) {\n      if (mouse.x >= c.x && mouse.x <= c.x + c.w && mouse.y >= c.y && mouse.y <= c.y + c.h) {\n        // highlight\n        ctx.strokeStyle = \"#0b5775\";\n        ctx.lineWidth = 3;\n        ctx.strokeRect(c.x - 4, c.y - 4, c.w + 8, c.h + 8);\n      }\n    }\n\n    // End screens\n    if (gameState === \"won\" || gameState === \"lost\") {\n      drawEndScreen();\n    }\n  }\n\n  // Main loop using requestAnimationFrame\n  function loop(now) {\n    const dt = Math.min(0.05, (now - lastTime) / 1000);\n    lastTime = now;\n    update(dt);\n    render(dt);\n    requestAnimationFrame(loop);\n  }\n\n  // Initialize\n  function init() {\n    // Basic focus for keyboard events\n    canvas.focus();\n\n    // Initial spawn and question\n    spawnCrates();\n    generateQuestion();\n\n    // Set initial audio context status\n    if (typeof window.AudioContext === \"undefined\" && typeof window.webkitAudioContext === \"undefined\") {\n      audioUnavailable = true;\n      audioStatusMsg = \"Sound: unavailable\";\n    } else {\n      audioStatusMsg = \"Sound: off (press S to enable)\";\n    }\n\n    // Start game loop\n    lastTime = performance.now();\n    requestAnimationFrame(loop);\n  }\n\n  // Accessibility: provide a visible restart function via keyboard for screen readers\n  // We will expose restart via canvas 'aria-describedby' update (note: best-effort)\n  canvas.setAttribute(\"title\", \"Drone Math Adventure. Press Enter to restart when game ends.\");\n\n  // Start the game\n  try {\n    init();\n  } catch (e) {\n    console.error(\"Game initialization failed:\", e);\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    ctx.fillStyle = \"#fff\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.fillStyle = \"#000\";\n    ctx.font = \"16px sans-serif\";\n    ctx.fillText(\"An error occurred initializing the game. Please try reloading the page.\", 20, 40);\n  }\n})();\n---\n",
  "improve_response_tokens": 22481,
  "formatted_code": true,
  "formatting_response_tokens": 24674,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}