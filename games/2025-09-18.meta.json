{
  "generated_date": "2025-09-18",
  "generated_timestamp": "2025-09-18T00:25:27.261710",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9389,
  "game_filename": "2025-09-18.js",
  "game_size_bytes": 25752,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Wacky Machine Math Game\n  // For ages 7-9. Renders into existing element with id \"game-of-the-day-stage\".\n  // All visuals are canvas-drawn. Sounds use Web Audio API oscillators/filters.\n  // Written with accessibility in mind (keyboard controls and aria-live updates).\n\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const CONTAINER_ID = 'game-of-the-day-stage';\n  const LEVEL_COUNT = 8;\n\n  // Utility helpers\n  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));\n  const randInt = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;\n  const safeText = s => String(s == null ? '' : s);\n\n  // Find container\n  const container = document.getElementById(CONTAINER_ID);\n  if (!container) {\n    console.error(`Game container with id \"${CONTAINER_ID}\" not found.`);\n    return;\n  }\n\n  // Clear container and set accessible label\n  container.innerHTML = '';\n  container.style.position = 'relative';\n\n  // Create a hidden accessible live region for screen readers\n  const ariaLive = document.createElement('div');\n  ariaLive.setAttribute('role', 'status');\n  ariaLive.setAttribute('aria-live', 'polite');\n  ariaLive.style.position = 'absolute';\n  ariaLive.style.left = '0';\n  ariaLive.style.top = '0';\n  ariaLive.style.width = '1px';\n  ariaLive.style.height = '1px';\n  ariaLive.style.overflow = 'hidden';\n  ariaLive.style.clip = 'rect(1px, 1px, 1px, 1px)';\n  ariaLive.style.whiteSpace = 'nowrap';\n  container.appendChild(ariaLive);\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.tabIndex = 0; // make it focusable for keyboard events\n  canvas.setAttribute('aria-label', 'Wacky Machines math game. Use arrow keys to play. Press M to toggle sound.');\n  canvas.style.outline = 'none';\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d', { alpha: false });\n\n  // Game state\n  let running = true;\n  let frame = 0;\n  let selectedKnob = 0; // 0,1,2\n  let level = 0;\n  let attempts = 0;\n  let solvedCount = 0;\n  let showHint = false;\n  let audioAllowed = false;\n  let audioOk = false;\n  let audioEnabled = true;\n  let audioContext = null; // will be created on first user gesture\n  let masterGain = null;\n  let bgNodes = null; // background audio nodes\n  let lastAudioError = null;\n  let spinner = 0;\n\n  // Puzzle data: each level has three knobs values and a target sum\n  const puzzles = [];\n\n  // Generate puzzles (simple addition tasks)\n  function generatePuzzles() {\n    puzzles.length = 0;\n    for (let i = 0; i < LEVEL_COUNT; i++) {\n      // Levels start easy and grow slightly\n      const min = 0;\n      const maxBase = 5 + Math.floor(i * 1.5); // 5,6.5,8...\n      const max = clamp(maxBase + randInt(0, 4), 6, 12);\n      const a = randInt(min, max);\n      const b = randInt(min, max);\n      const c = randInt(min, max);\n      const target = a + b + c + randInt(-3, 3);\n      // Ensure target is reasonable and positive\n      puzzles.push({\n        knobs: [a, b, c].map(v => clamp(v, 0, 12)),\n        target: clamp(target, 0, 30),\n      });\n    }\n  }\n\n  generatePuzzles();\n\n  // Copy initial values for current play\n  let current = {\n    knobs: [0, 0, 0],\n    target: 0,\n  };\n\n  function startLevel(index = 0) {\n    level = clamp(index, 0, puzzles.length - 1);\n    attempts = 0;\n    showHint = false;\n    selectedKnob = 0;\n    const p = puzzles[level];\n    current.knobs = p.knobs.slice(); // start with the puzzle's values as default\n    current.target = p.target;\n    updateAria(`Level ${level + 1}. The target is ${current.target}. Use left/right to pick a knob and up/down to change its number, then press Enter to submit.`);\n  }\n\n  startLevel(0);\n\n  // Accessibility update\n  function updateAria(text) {\n    ariaLive.textContent = text;\n  }\n\n  // Input handling\n  canvas.addEventListener('keydown', (e) => {\n    if (e.defaultPrevented) return;\n    const key = e.key;\n    if (key === 'ArrowLeft') {\n      selectedKnob = (selectedKnob + 3 - 1) % 3;\n      e.preventDefault();\n      playClick();\n      updateAria(`Knob ${selectedKnob + 1} selected, value ${current.knobs[selectedKnob]}.`);\n    } else if (key === 'ArrowRight') {\n      selectedKnob = (selectedKnob + 1) % 3;\n      e.preventDefault();\n      playClick();\n      updateAria(`Knob ${selectedKnob + 1} selected, value ${current.knobs[selectedKnob]}.`);\n    } else if (key === 'ArrowUp') {\n      changeKnob(selectedKnob, 1);\n      e.preventDefault();\n    } else if (key === 'ArrowDown') {\n      changeKnob(selectedKnob, -1);\n      e.preventDefault();\n    } else if (key === 'Enter' || key === ' ') {\n      submitAttempt();\n      e.preventDefault();\n    } else if (key.toLowerCase() === 'm') {\n      toggleAudio();\n      e.preventDefault();\n    } else if (key.toLowerCase() === 'r') {\n      startLevel(0);\n      solvedCount = 0;\n      updateAria('Game reset. Starting at level 1.');\n      e.preventDefault();\n    } else if (key.toLowerCase() === 'h') {\n      showHint = !showHint;\n      updateAria(showHint ? 'Hint shown.' : 'Hint hidden.');\n      e.preventDefault();\n    }\n  });\n\n  // Mouse handling\n  canvas.addEventListener('mousedown', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = (e.clientX - rect.left) * (canvas.width / rect.width);\n    const y = (e.clientY - rect.top) * (canvas.height / rect.height);\n    // Click detection for knobs and submit/mute buttons\n    const clicked = handleClick(x, y);\n    if (clicked) {\n      // allow audio to start on first user gesture\n      ensureAudioResume();\n    }\n  });\n\n  // Wheel to adjust knob\n  canvas.addEventListener('wheel', (e) => {\n    e.preventDefault();\n    const dy = Math.sign(e.deltaY);\n    changeKnob(selectedKnob, -dy);\n    ensureAudioResume();\n  }, { passive: false });\n\n  // Touch support: simple tap to select/submit\n  canvas.addEventListener('touchstart', (e) => {\n    if (e.touches.length > 0) {\n      const rect = canvas.getBoundingClientRect();\n      const t = e.touches[0];\n      const x = (t.clientX - rect.left) * (canvas.width / rect.width);\n      const y = (t.clientY - rect.top) * (canvas.height / rect.height);\n      handleClick(x, y);\n      ensureAudioResume();\n    }\n  });\n\n  // Change knob value\n  function changeKnob(idx, delta) {\n    current.knobs[idx] = clamp(current.knobs[idx] + delta, 0, 20);\n    attempts++;\n    playClick();\n    updateAria(`Knob ${idx + 1} is now ${current.knobs[idx]}.`);\n  }\n\n  // Submit attempt\n  function submitAttempt() {\n    attempts++;\n    const sum = current.knobs.reduce((a, b) => a + b, 0);\n    if (sum === current.target) {\n      solvedCount++;\n      playCorrect();\n      updateAria(`Good job! You fixed the machine. Level ${level + 1} complete.`);\n      // Move to next after short delay\n      setTimeout(() => {\n        if (level + 1 < puzzles.length) {\n          startLevel(level + 1);\n        } else {\n          winGame();\n        }\n      }, 900);\n    } else {\n      playIncorrect();\n      updateAria(`Not quite. The total is ${sum}. Try again.`);\n    }\n  }\n\n  function winGame() {\n    updateAria(`All machines fixed! You completed all ${puzzles.length} levels with ${attempts} attempts on the last level. Press R to play again.`);\n    // show confetti-like wacky gears animation and reset option\n    // reset after a beat\n    setTimeout(() => {\n      startLevel(0);\n      solvedCount = 0;\n    }, 3000);\n  }\n\n  // Click handling: determine which part was clicked\n  function handleClick(x, y) {\n    // Knobs area positions\n    const knobPositions = [\n      { x: 180, y: 260 },\n      { x: 360, y: 240 },\n      { x: 540, y: 260 },\n    ];\n    for (let i = 0; i < knobPositions.length; i++) {\n      const k = knobPositions[i];\n      const dx = x - k.x;\n      const dy = y - k.y;\n      if (Math.hypot(dx, dy) < 60) {\n        selectedKnob = i;\n        playClick();\n        updateAria(`Knob ${i + 1} selected, value ${current.knobs[i]}.`);\n        return true;\n      }\n    }\n    // Submit button\n    if (x >= 600 && x <= 690 && y >= 380 && y <= 440) {\n      submitAttempt();\n      return true;\n    }\n    // Mute toggle (top-right tiny speaker)\n    if (x >= 680 && x <= 708 && y >= 8 && y <= 36) {\n      toggleAudio();\n      return true;\n    }\n    // Hint bubble (top-left)\n    if (x >= 8 && x <= 88 && y >= 8 && y <= 48) {\n      showHint = !showHint;\n      updateAria(showHint ? 'Hint shown.' : 'Hint hidden.');\n      return true;\n    }\n    return false;\n  }\n\n  // Audio: Web Audio API setup and functions\n  function initAudio() {\n    if (audioContext) return;\n    try {\n      const AC = window.AudioContext || window.webkitAudioContext;\n      if (!AC) {\n        lastAudioError = new Error('Web Audio API not supported in this browser.');\n        audioOk = false;\n        console.warn(lastAudioError.message);\n        return;\n      }\n      audioContext = new AC();\n      masterGain = audioContext.createGain();\n      masterGain.gain.value = 0.6;\n      masterGain.connect(audioContext.destination);\n\n      // Background gentle tones - two oscillators with slow LFO on filter\n      const oscA = audioContext.createOscillator();\n      const oscB = audioContext.createOscillator();\n      const mixGain = audioContext.createGain();\n      const filter = audioContext.createBiquadFilter();\n      filter.type = 'lowpass';\n      filter.frequency.value = 600;\n      filter.Q.value = 1;\n\n      oscA.type = 'sine';\n      oscB.type = 'triangle';\n      oscA.frequency.value = 220;\n      oscB.frequency.value = 110;\n      mixGain.gain.value = 0.12;\n\n      oscA.connect(mixGain);\n      oscB.connect(mixGain);\n      mixGain.connect(filter);\n      filter.connect(masterGain);\n\n      // LFO to slowly modulate filter frequency\n      const lfo = audioContext.createOscillator();\n      const lfoGain = audioContext.createGain();\n      lfo.type = 'sine';\n      lfo.frequency.value = 0.08; // slow\n      lfoGain.gain.value = 120;\n      lfo.connect(lfoGain);\n      lfoGain.connect(filter.frequency);\n\n      oscA.start();\n      oscB.start();\n      lfo.start();\n\n      bgNodes = { oscA, oscB, lfo, filter, mixGain };\n\n      audioOk = true;\n      lastAudioError = null;\n    } catch (err) {\n      lastAudioError = err;\n      audioOk = false;\n      console.error('Audio initialization failed:', err);\n    }\n  }\n\n  // Ensure audio is resumed on user gesture according to browser policies\n  function ensureAudioResume() {\n    audioAllowed = true;\n    if (!audioContext) {\n      try {\n        initAudio();\n      } catch (e) {\n        // error handled in initAudio\n      }\n    }\n    if (audioContext && audioContext.state === 'suspended') {\n      audioContext.resume().catch((err) => {\n        console.warn('Audio resume failed:', err);\n      });\n    }\n  }\n\n  function toggleAudio() {\n    audioEnabled = !audioEnabled;\n    if (masterGain) {\n      masterGain.gain.setTargetAtTime(audioEnabled ? 0.6 : 0.0, audioContext.currentTime, 0.02);\n    }\n    updateAria(audioEnabled ? 'Sound on.' : 'Sound muted.');\n    playClick();\n  }\n\n  // Play short click sound for UI interactions\n  function playClick() {\n    if (!audioEnabled) return;\n    try {\n      if (!audioContext) initAudio();\n      if (!audioOk) return;\n      const o = audioContext.createOscillator();\n      const g = audioContext.createGain();\n      const f = audioContext.createBiquadFilter();\n      o.type = 'square';\n      o.frequency.value = 880;\n      f.type = 'highpass';\n      f.frequency.value = 400;\n      g.gain.value = 0.0001;\n      o.connect(f);\n      f.connect(g);\n      g.connect(masterGain);\n      const now = audioContext.currentTime;\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(0.08, now + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);\n      o.start(now);\n      o.stop(now + 0.2);\n    } catch (err) {\n      console.warn('playClick error', err);\n    }\n  }\n\n  // Play success melody\n  function playCorrect() {\n    if (!audioEnabled) return;\n    try {\n      if (!audioContext) initAudio();\n      if (!audioOk) return;\n      const notes = [880, 1046, 1318]; // A5, C6, E6\n      const now = audioContext.currentTime;\n      notes.forEach((freq, i) => {\n        const o = audioContext.createOscillator();\n        const g = audioContext.createGain();\n        o.type = i === 1 ? 'triangle' : 'sine';\n        o.frequency.value = freq;\n        g.gain.value = 0.0001;\n        o.connect(g);\n        g.connect(masterGain);\n        const start = now + i * 0.12;\n        const end = start + 0.18;\n        g.gain.setValueAtTime(0.0001, start);\n        g.gain.exponentialRampToValueAtTime(0.12, start + 0.01);\n        g.gain.exponentialRampToValueAtTime(0.0001, end);\n        o.start(start);\n        o.stop(end + 0.02);\n      });\n    } catch (err) {\n      console.warn('playCorrect error', err);\n    }\n  }\n\n  // Play incorrect buzzer\n  function playIncorrect() {\n    if (!audioEnabled) return;\n    try {\n      if (!audioContext) initAudio();\n      if (!audioOk) return;\n      const now = audioContext.currentTime;\n      // descending buzz\n      for (let i = 0; i < 3; i++) {\n        const o = audioContext.createOscillator();\n        const g = audioContext.createGain();\n        o.type = 'sawtooth';\n        o.frequency.value = 660 - i * 110;\n        g.gain.value = 0.0001;\n        o.connect(g);\n        g.connect(masterGain);\n        const start = now + i * 0.06;\n        const end = start + 0.12;\n        g.gain.setValueAtTime(0.0001, start);\n        g.gain.exponentialRampToValueAtTime(0.08, start + 0.01);\n        g.gain.exponentialRampToValueAtTime(0.0001, end);\n        o.start(start);\n        o.stop(end + 0.02);\n      }\n    } catch (err) {\n      console.warn('playIncorrect error', err);\n    }\n  }\n\n  // Fallback if audio cannot be initialized\n  if (!audioContext) {\n    try {\n      initAudio();\n    } catch (e) { /* handled above */ }\n  }\n\n  // Drawing helpers\n  function drawRoundedRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  // Colors and palette (calming, wacky)\n  const palette = {\n    bg: '#F7FBFF',\n    panel: '#E8F1F8',\n    accent: '#7BB7D6',\n    knob: '#F3DFAE',\n    knob2: '#D1E8E2',\n    text: '#22313A',\n    highlight: '#FFB84D',\n    wrong: '#FF6B6B',\n    correct: '#6BE38D',\n    gentle: '#B7DDF0',\n  };\n\n  // Drawing the full scene each frame\n  function draw() {\n    frame++;\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // Background gradient\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, palette.bg);\n    g.addColorStop(1, '#ECF8FF');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Soft floating gears in background (wacky)\n    drawGearsBackground();\n\n    // Large machine body\n    ctx.fillStyle = palette.panel;\n    drawRoundedRect(ctx, 80, 60, 560, 300, 18);\n\n    // Wacky antenna and eyes\n    drawAntenna();\n    drawGooglyEyes();\n\n    // Display panel with target\n    drawDisplay();\n\n    // Knobs\n    drawKnobs();\n\n    // Conveyor belt and output\n    drawConveyor();\n\n    // Buttons: submit and hint and mute\n    drawControls();\n\n    // Instruction text\n    drawInstructions();\n\n    // Tiny debug / audio status\n    drawAudioIndicator();\n\n    // Possibly draw hint bubble\n    if (showHint) drawHint();\n\n    // Drawing done\n  }\n\n  // Background gears animation\n  function drawGearsBackground() {\n    const baseY = 420;\n    for (let i = 0; i < 6; i++) {\n      const x = 40 + i * 120 + (Math.sin((frame + i * 10) * 0.02) * 8);\n      const y = baseY + Math.cos((frame + i * 15) * 0.013) * 6;\n      const r = 28 + (i % 2 ? 6 : 0);\n      drawGear(x, y, r, (frame * 0.5 + i * 8) * (i % 2 ? -0.02 : 0.02));\n    }\n  }\n\n  function drawGear(cx, cy, radius, rotation) {\n    ctx.save();\n    ctx.translate(cx, cy);\n    ctx.rotate(rotation);\n    // Soft gear shadow\n    ctx.beginPath();\n    ctx.fillStyle = 'rgba(140,160,170,0.06)';\n    ctx.arc(6, 6, radius + 6, 0, Math.PI * 2);\n    ctx.fill();\n    // Gear body\n    ctx.fillStyle = palette.gentle;\n    ctx.beginPath();\n    ctx.arc(0, 0, radius, 0, Math.PI * 2);\n    ctx.fill();\n    // Teeth\n    for (let i = 0; i < 10; i++) {\n      const a = (i / 10) * Math.PI * 2;\n      const x = Math.cos(a) * (radius + 8);\n      const y = Math.sin(a) * (radius + 8);\n      ctx.fillStyle = palette.panel;\n      ctx.fillRect(x - 4, y - 6, 8, 12);\n    }\n    // center hole\n    ctx.fillStyle = '#E7FBFF';\n    ctx.beginPath();\n    ctx.arc(0, 0, radius * 0.4, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function drawAntenna() {\n    ctx.save();\n    ctx.strokeStyle = palette.accent;\n    ctx.lineWidth = 6;\n    ctx.lineCap = 'round';\n    ctx.beginPath();\n    ctx.moveTo(600, 90);\n    ctx.lineTo(650, 30 + Math.sin(frame * 0.06) * 6);\n    ctx.stroke();\n    // top bulb\n    ctx.fillStyle = palette.highlight;\n    ctx.beginPath();\n    ctx.arc(650, 30 + Math.sin(frame * 0.06) * 6, 12, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function drawGooglyEyes() {\n    // two eyes on machine\n    const left = { x: 240, y: 120 };\n    const right = { x: 320, y: 118 };\n    drawEye(left.x, left.y, 26, 0.6 + Math.sin(frame * 0.06) * 0.6);\n    drawEye(right.x, right.y, 26, 0.4 + Math.cos(frame * 0.05) * 0.6);\n  }\n\n  function drawEye(x, y, r, offset) {\n    ctx.save();\n    // white\n    ctx.fillStyle = '#FFF';\n    ctx.beginPath();\n    ctx.arc(x, y, r, 0, Math.PI * 2);\n    ctx.fill();\n    // iris\n    ctx.fillStyle = '#2E6A7A';\n    ctx.beginPath();\n    ctx.arc(x + offset * 6, y, r * 0.42, 0, Math.PI * 2);\n    ctx.fill();\n    // highlight\n    ctx.fillStyle = 'rgba(255,255,255,0.7)';\n    ctx.beginPath();\n    ctx.arc(x + offset * 6 - 3, y - 4, r * 0.12, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function drawDisplay() {\n    // machine numeric display for target\n    ctx.save();\n    ctx.fillStyle = '#112';\n    ctx.globalAlpha = 0.06;\n    drawRoundedRect(ctx, 210, 90, 300, 80, 10);\n    ctx.globalAlpha = 1;\n    ctx.fillStyle = '#0B2B36';\n    drawRoundedRect(ctx, 230, 100, 260, 60, 8);\n    ctx.fillStyle = palette.accent;\n    ctx.fillRect(240, 110, 240, 40);\n    // text\n    ctx.fillStyle = '#08323a';\n    ctx.font = 'bold 26px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText(`TARGET: ${current.target}`, 350, 138);\n    ctx.restore();\n  }\n\n  function drawKnobs() {\n    const positions = [\n      { x: 180, y: 260 },\n      { x: 360, y: 240 },\n      { x: 540, y: 260 },\n    ];\n    for (let i = 0; i < 3; i++) {\n      const p = positions[i];\n      drawSingleKnob(p.x, p.y, current.knobs[i], i === selectedKnob);\n    }\n  }\n\n  function drawSingleKnob(x, y, value, selected) {\n    ctx.save();\n    // base plate\n    ctx.fillStyle = selected ? '#FFF6E6' : '#FFF';\n    ctx.beginPath();\n    ctx.ellipse(x, y + 8, 72, 48, 0, 0, Math.PI * 2);\n    ctx.fill();\n    // knob circle\n    ctx.fillStyle = palette.knob;\n    ctx.beginPath();\n    ctx.arc(x, y, 50, 0, Math.PI * 2);\n    ctx.fill();\n    // inner shadow\n    ctx.fillStyle = 'rgba(0,0,0,0.08)';\n    ctx.beginPath();\n    ctx.arc(x, y + 6, 48, 0, Math.PI * 2);\n    ctx.fill();\n    // number\n    ctx.fillStyle = palette.text;\n    ctx.font = 'bold 28px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText(String(value), x, y + 10);\n\n    // little screw\n    ctx.fillStyle = '#C9DDE6';\n    ctx.beginPath();\n    ctx.arc(x, y - 24, 6, 0, Math.PI * 2);\n    ctx.fill();\n\n    // highlight ring if selected\n    if (selected) {\n      ctx.strokeStyle = palette.highlight;\n      ctx.lineWidth = 6;\n      ctx.beginPath();\n      ctx.arc(x, y, 58, 0, Math.PI * 2);\n      ctx.stroke();\n    }\n\n    // small +/- visual indicators\n    ctx.fillStyle = '#8EAEC0';\n    ctx.font = '12px sans-serif';\n    ctx.fillText('+', x + 38, y - 8);\n    ctx.fillText('\u2212', x - 38, y - 8);\n\n    ctx.restore();\n  }\n\n  function drawConveyor() {\n    ctx.save();\n    // belt\n    ctx.fillStyle = '#E2F2FB';\n    ctx.fillRect(120, 330, 480, 34);\n\n    // output window\n    const sum = current.knobs.reduce((a, b) => a + b, 0);\n    ctx.fillStyle = sum === current.target ? palette.correct : '#E8EEF1';\n    drawRoundedRect(ctx, 300, 330, 120, 34, 6);\n\n    ctx.fillStyle = palette.text;\n    ctx.font = '20px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText(`OUTPUT: ${sum}`, 360, 353);\n\n    // moving screws/wacky items on conveyor\n    for (let i = 0; i < 8; i++) {\n      const x = 140 + ((frame * 1.2 + i * 40) % 480);\n      ctx.fillStyle = i % 2 ? palette.knob2 : '#D9EEF6';\n      ctx.beginPath();\n      ctx.arc(x, 347, 8 + (i % 3), 0, Math.PI * 2);\n      ctx.fill();\n    }\n    ctx.restore();\n  }\n\n  function drawControls() {\n    ctx.save();\n    // Submit button\n    ctx.fillStyle = '#FFDD99';\n    ctx.fillRect(600, 380, 90, 56);\n    ctx.fillStyle = palette.text;\n    ctx.font = 'bold 18px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('FIX IT!', 645, 416);\n\n    // Hint bubble (top-left)\n    ctx.fillStyle = showHint ? palette.highlight : palette.panel;\n    drawRoundedRect(ctx, 8, 8, 80, 40, 8);\n    ctx.fillStyle = palette.text;\n    ctx.font = '14px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText('Hint', 20, 34);\n    // small hint icon\n    ctx.beginPath();\n    ctx.fillStyle = '#FFF';\n    ctx.arc(66, 20, 10, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = '#22313A';\n    ctx.fillText('?', 62, 26);\n\n    // Mute icon top-right\n    ctx.fillStyle = palette.panel;\n    drawRoundedRect(ctx, 680, 8, 28, 28, 6);\n    ctx.fillStyle = '#22313A';\n    ctx.font = '12px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText(audioEnabled ? '\ud83d\udd0a' : '\ud83d\udd08', 694, 26);\n    ctx.restore();\n  }\n\n  function drawInstructions() {\n    ctx.save();\n    ctx.fillStyle = '#10323A';\n    ctx.font = '14px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText('Pick a knob (\u2190\u2192), change value (\u2191\u2193), press Enter to submit. Press M to toggle sound. H for hint.', 20, 460);\n    ctx.restore();\n  }\n\n  function drawAudioIndicator() {\n    ctx.save();\n    ctx.globalAlpha = 0.9;\n    ctx.fillStyle = '#FFF';\n    ctx.font = '12px sans-serif';\n    ctx.textAlign = 'left';\n    if (!audioOk) {\n      ctx.fillStyle = palette.wrong;\n      ctx.fillText('Audio unavailable', 520, 32);\n      ctx.fillStyle = 'rgba(0,0,0,0.15)';\n      ctx.fillRect(512, 12, 196, 26);\n    } else {\n      ctx.fillStyle = audioEnabled ? palette.correct : palette.wrong;\n      ctx.fillText(audioEnabled ? 'Sound on' : 'Muted', 540, 32);\n    }\n    ctx.restore();\n  }\n\n  function drawHint() {\n    ctx.save();\n    ctx.globalAlpha = 0.95;\n    ctx.fillStyle = 'rgba(255,255,255,0.92)';\n    ctx.strokeStyle = palette.panel;\n    drawRoundedRect(ctx, 80, 360, 440, 100, 12);\n    ctx.fillStyle = palette.text;\n    ctx.font = 'bold 16px sans-serif';\n    ctx.textAlign = 'left';\n    const sum = current.knobs.reduce((a, b) => a + b, 0);\n    const diff = current.target - sum;\n    let hintText = '';\n    if (Math.abs(diff) <= 2) {\n      hintText = `You're close! Change one knob by ${diff >= 0 ? '+' + diff : diff}.`;\n    } else {\n      hintText = `Try to reach ${current.target} by adjusting the three knobs. Add small numbers or reduce large ones.`;\n    }\n    ctx.fillText(hintText, 96, 398);\n    ctx.restore();\n  }\n\n  // Main animation loop\n  function loop() {\n    if (!running) return;\n    draw();\n    requestAnimationFrame(loop);\n  }\n\n  // Start loop\n  loop();\n\n  // Initialize audio on first user gesture for browsers requiring interaction\n  function initAutoAudioOnGesture() {\n    const resumeHandler = () => {\n      ensureAudioResume();\n      // Try to fade-in background\n      if (audioContext && masterGain) {\n        masterGain.gain.setTargetAtTime(audioEnabled ? 0.6 : 0.0, audioContext.currentTime, 0.02);\n      }\n      window.removeEventListener('mousedown', resumeHandler);\n      window.removeEventListener('keydown', resumeHandler);\n      window.removeEventListener('touchstart', resumeHandler);\n    };\n    window.addEventListener('mousedown', resumeHandler, { once: true });\n    window.addEventListener('keydown', resumeHandler, { once: true });\n    window.addEventListener('touchstart', resumeHandler, { once: true });\n  }\n\n  initAutoAudioOnGesture();\n\n  // Expose some debug in container (non-intrusive) for errors\n  const statusBox = document.createElement('div');\n  statusBox.style.position = 'absolute';\n  statusBox.style.right = '6px';\n  statusBox.style.bottom = '6px';\n  statusBox.style.background = 'rgba(255,255,255,0.6)';\n  statusBox.style.borderRadius = '6px';\n  statusBox.style.padding = '6px 8px';\n  statusBox.style.fontSize = '11px';\n  statusBox.style.color = '#234';\n  statusBox.style.pointerEvents = 'none';\n  statusBox.textContent = 'Wacky Machines';\n  container.appendChild(statusBox);\n\n  // Periodically update status text and handle audio errors\n  setInterval(() => {\n    let s = `Level ${level + 1}/${puzzles.length}`;\n    if (!audioOk && lastAudioError) {\n      s += ' \u2022 Audio error';\n    }\n    statusBox.textContent = s;\n  }, 1100);\n\n  // Ensure focus for keyboard controls\n  canvas.addEventListener('focus', () => {\n    canvas.style.boxShadow = '0 0 0 4px rgba(120,180,200,0.12)';\n  });\n  canvas.addEventListener('blur', () => {\n    canvas.style.boxShadow = 'none';\n  });\n  // Auto-focus the canvas for convenience\n  setTimeout(() => {\n    try { canvas.focus(); } catch (e) { /* ignore */ }\n  }, 300);\n\n  // Clean up on unload\n  window.addEventListener('unload', () => {\n    running = false;\n    try {\n      if (audioContext) {\n        audioContext.close();\n      }\n    } catch (e) { /* ignore */ }\n  });\n\n  // Expose some helpful messages to ariaLive at start\n  updateAria('Welcome to Wacky Machines. Use left and right arrows to select a knob, up and down to change its number, and Enter to submit. Press M to toggle sound.');\n\n})();\n---\n",
  "improve_response_tokens": 19805,
  "formatted_code": true,
  "formatting_response_tokens": 22190,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}