{
  "generated_date": "2025-10-10",
  "generated_timestamp": "2025-10-10T00:26:48.223367",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9547,
  "game_filename": "2025-10-10.js",
  "game_size_bytes": 29965,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function() {\n  // Machine Merge - Math Game for ages 7-9\n  // Renders into element with ID \"game-of-the-day-stage\"\n  // Canvas is exactly 720x480\n  // No external resources. All graphics via canvas. All sounds via Web Audio API oscillators/filters.\n  // Accessible keyboard controls and visual/audio cues.\n\n  // ======== Setup and Utilities ========\n  const STAGE_ID = 'game-of-the-day-stage';\n  const WIDTH = 720;\n  const HEIGHT = 480;\n\n  const container = document.getElementById(STAGE_ID);\n  if (!container) {\n    throw new Error(`Container element with ID \"${STAGE_ID}\" not found.`);\n  }\n\n  // Clear container and create canvas\n  container.innerHTML = '';\n  container.style.position = 'relative';\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.width = WIDTH + 'px';\n  canvas.style.height = HEIGHT + 'px';\n  canvas.tabIndex = 0; // focusable\n  canvas.setAttribute('role', 'application');\n  canvas.setAttribute('aria-label', 'Machine Merge math game. Use arrow keys to move, space to pick/drop parts, M to toggle audio, Escape to restart.');\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext('2d');\n\n  // Utility random\n  const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));\n\n  // ======== Audio Setup ========\n  let audioCtx = null;\n  let audioEnabled = true;\n  let backgroundGain = null;\n  let backgroundOsc = null;\n  let audioInitError = false;\n\n  function initAudio() {\n    if (audioCtx) return;\n    try {\n      const AudioContext = window.AudioContext || window.webkitAudioContext;\n      audioCtx = new AudioContext();\n\n      // Background hum\n      backgroundOsc = audioCtx.createOscillator();\n      const bgFilter = audioCtx.createBiquadFilter();\n      backgroundGain = audioCtx.createGain();\n      bgFilter.type = 'lowpass';\n      bgFilter.frequency.value = 800;\n      backgroundOsc.type = 'sine';\n      backgroundOsc.frequency.value = 110; // low gentle tone\n      backgroundGain.gain.value = 0.02; // very gentle\n      backgroundOsc.connect(bgFilter);\n      bgFilter.connect(backgroundGain);\n      backgroundGain.connect(audioCtx.destination);\n      backgroundOsc.start();\n    } catch (e) {\n      console.warn('Audio initialization failed:', e);\n      audioInitError = true;\n      audioEnabled = false;\n      audioCtx = null;\n    }\n  }\n\n  function resumeAudioOnInteraction() {\n    if (!audioCtx) return;\n    if (audioCtx.state === 'suspended') {\n      audioCtx.resume().catch((e) => {\n        console.warn('Audio resume failed:', e);\n        audioEnabled = false;\n      });\n    }\n  }\n\n  function setAudioEnabled(enabled) {\n    audioEnabled = enabled && !audioInitError;\n    if (backgroundGain) backgroundGain.gain.value = audioEnabled ? 0.02 : 0;\n  }\n\n  // Short sound effects generated by oscillator\n  function playTone({ freq = 440, type = 'sine', duration = 0.15, volume = 0.12, attack = 0.01, decay = 0.08, detune = 0 } = {}) {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      const filter = audioCtx.createBiquadFilter();\n      o.type = type;\n      o.frequency.value = freq;\n      o.detune.value = detune;\n      filter.type = 'lowpass';\n      filter.frequency.value = Math.max(600, freq * 2);\n      g.gain.value = 0;\n      o.connect(filter);\n      filter.connect(g);\n      g.connect(audioCtx.destination);\n\n      const now = audioCtx.currentTime;\n      g.gain.cancelScheduledValues(now);\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.linearRampToValueAtTime(volume, now + attack);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + duration - decay);\n\n      o.start(now);\n      o.stop(now + duration + 0.02);\n    } catch (e) {\n      console.warn('playTone error', e);\n    }\n  }\n\n  function playPickSound() {\n    playTone({ freq: 880, type: 'triangle', duration: 0.12, volume: 0.08, attack: 0.01, decay: 0.06 });\n  }\n  function playDropSound() {\n    playTone({ freq: 660, type: 'sine', duration: 0.15, volume: 0.10, attack: 0.01, decay: 0.06 });\n  }\n  function playCorrectSound() {\n    // cheerful arpeggio\n    playTone({ freq: 880, type: 'sine', duration: 0.14, volume: 0.12 });\n    setTimeout(() => playTone({ freq: 1100, type: 'sine', duration: 0.14, volume: 0.12 }), 160);\n    setTimeout(() => playTone({ freq: 1320, type: 'sine', duration: 0.18, volume: 0.12 }), 320);\n  }\n  function playWrongSound() {\n    // gentle buzz\n    playTone({ freq: 220, type: 'square', duration: 0.22, volume: 0.12 });\n    setTimeout(() => playTone({ freq: 170, type: 'square', duration: 0.18, volume: 0.09 }), 120);\n  }\n\n  // Initialize audio on first user gesture to satisfy browser policies\n  function tryInitAudioOnGesture() {\n    initAudio();\n  }\n\n  // ======== Game Data & Logic ========\n  class Part {\n    constructor(x, y, speed, value, belt) {\n      this.x = x;\n      this.y = y;\n      this.speed = speed;\n      this.value = value;\n      this.radius = 22;\n      this.belt = belt; // 0 or 1\n      this.id = Math.random().toString(36).substr(2, 9);\n      this.picked = false;\n    }\n\n    draw(ctx) {\n      // draw soft capsule/coggy orb\n      ctx.save();\n      ctx.translate(this.x, this.y);\n\n      // subtle shadow\n      ctx.beginPath();\n      ctx.fillStyle = 'rgba(0,0,0,0.08)';\n      ctx.arc(6, 12, this.radius + 3, 0, Math.PI * 2);\n      ctx.fill();\n\n      // main circle\n      const colors = ['#8fd3c7', '#ffd6a5', '#c3b0f8', '#ffb6c1', '#bfe3ff'];\n      const base = colors[(this.value + this.belt) % colors.length];\n      const grd = ctx.createLinearGradient(-this.radius, -this.radius, this.radius, this.radius);\n      grd.addColorStop(0, base);\n      grd.addColorStop(1, '#ffffff');\n\n      ctx.beginPath();\n      ctx.fillStyle = grd;\n      ctx.strokeStyle = '#7d7d7d';\n      ctx.lineWidth = 1.5;\n      ctx.arc(0, 0, this.radius, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n\n      // number\n      ctx.fillStyle = '#2b2b2b';\n      ctx.font = 'bold 18px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(String(this.value), 0, 0);\n      ctx.restore();\n    }\n\n    update(dt) {\n      if (this.picked) return;\n      this.x += this.speed * dt;\n      // wrap horizontally\n      if (this.speed > 0 && this.x - this.radius > WIDTH + 40) {\n        this.x = -40;\n      } else if (this.speed < 0 && this.x + this.radius < -40) {\n        this.x = WIDTH + 40;\n      }\n    }\n  }\n\n  class Arm {\n    constructor() {\n      this.x = WIDTH / 2;\n      this.y = HEIGHT - 120;\n      this.width = 110;\n      this.height = 22;\n      this.holding = []; // up to 2 parts\n      this.cooldown = 0;\n    }\n\n    draw(ctx) {\n      // arm base\n      ctx.save();\n      ctx.translate(this.x, this.y);\n\n      // shadow\n      ctx.beginPath();\n      ctx.fillStyle = 'rgba(0,0,0,0.08)';\n      ctx.fillRect(-this.width/2 + 6, 10, this.width, 10);\n\n      // arm beam\n      ctx.beginPath();\n      ctx.fillStyle = '#dcecf0';\n      roundRect(ctx, -this.width/2, -10, this.width, 20, 10);\n      ctx.fill();\n      ctx.lineWidth = 2;\n      ctx.strokeStyle = '#9aaab0';\n      ctx.stroke();\n\n      // claw/tray\n      ctx.beginPath();\n      ctx.fillStyle = '#e8f2ff';\n      roundRect(ctx, -44, 12, 88, 28, 8);\n      ctx.fill();\n      ctx.strokeStyle = '#8aa0b1';\n      ctx.stroke();\n\n      // draw held parts in tray positions\n      for (let i = 0; i < this.holding.length; i++) {\n        const p = this.holding[i];\n        ctx.save();\n        const offsetX = -22 + i * 44;\n        ctx.translate(offsetX, 26);\n        // draw small circle with number\n        ctx.beginPath();\n        ctx.fillStyle = '#fff7';\n        ctx.arc(0, 0, 18, 0, Math.PI*2);\n        ctx.fill();\n\n        ctx.beginPath();\n        ctx.fillStyle = '#2b2b2b';\n        ctx.font = 'bold 16px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(String(p.value), 0, 0);\n        ctx.restore();\n      }\n\n      ctx.restore();\n    }\n  }\n\n  class Game {\n    constructor(ctx) {\n      this.ctx = ctx;\n      this.lastTime = performance.now();\n      this.parts = [];\n      this.arm = new Arm();\n      this.belts = [\n        { y: 140, direction: 1, speedBase: 30 },\n        { y: 210, direction: -1, speedBase: 36 }\n      ];\n      this.level = 1;\n      this.maxLevels = 5;\n      this.attemptsLeft = 3;\n      this.target = 8;\n      this.message = 'Welcome! Press Space or Click to pick up parts. Collect two parts that add to the Target.';\n      this.messageTimer = 0;\n      this.showHelp = true;\n      this.running = true;\n      this.win = false;\n      this.solvedThisLevel = false;\n      this.animationRequest = null;\n      this.mouse = { x: 0, y: 0, down: false };\n      this.keys = {};\n      this.audioVisualOn = true; // show speaker icon\n      this.initLevel();\n\n      // Input handlers\n      this.bindHandlers();\n      this.loop = this.loop.bind(this);\n      this.animationRequest = requestAnimationFrame(this.loop);\n    }\n\n    bindHandlers() {\n      // keyboard\n      canvas.addEventListener('keydown', (e) => {\n        // resume audio on gesture\n        tryInitAudioOnGesture();\n        resumeAudioOnInteraction();\n        if (e.key === 'm' || e.key === 'M') {\n          setAudioEnabled(!audioEnabled);\n          this.message = audioEnabled ? 'Sound on' : 'Sound off';\n          this.messageTimer = 2000;\n          e.preventDefault();\n          return;\n        }\n        if (e.key === 'Escape') {\n          this.restart();\n          e.preventDefault();\n          return;\n        }\n        if (e.key === ' ') {\n          // pick/drop\n          this.tryPickOrDrop();\n          e.preventDefault();\n        }\n        // movement keys handled on keydown/keyup\n        this.keys[e.key] = true;\n      });\n\n      canvas.addEventListener('keyup', (e) => {\n        this.keys[e.key] = false;\n      });\n\n      // mouse\n      canvas.addEventListener('mousedown', (e) => {\n        tryInitAudioOnGesture();\n        resumeAudioOnInteraction();\n        const rect = canvas.getBoundingClientRect();\n        this.mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);\n        this.mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);\n        this.mouse.down = true;\n        // clicking left side moves arm there\n        this.arm.x = clamp(this.mouse.x, 60, WIDTH - 60);\n        this.tryPickOrDrop();\n      });\n\n      canvas.addEventListener('mousemove', (e) => {\n        const rect = canvas.getBoundingClientRect();\n        this.mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);\n        this.mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);\n      });\n\n      canvas.addEventListener('mouseup', (e) => {\n        this.mouse.down = false;\n      });\n\n      // make sure canvas can be focused for keyboard\n      canvas.addEventListener('click', () => canvas.focus());\n    }\n\n    initLevel() {\n      // prepare parts and target so there's always at least one solvable pair\n      this.parts = [];\n      this.arm.holding = [];\n      this.solvedThisLevel = false;\n      this.win = false;\n      this.attemptsLeft = 3;\n      this.message = `Level ${this.level}. Build a pair that adds to the Target.`;\n      this.messageTimer = 3000;\n      this.showHelp = this.level === 1;\n\n      // choose target depending on level difficulty\n      const minTarget = 5 + (this.level - 1) * 1; // grows slightly\n      const maxTarget = 10 + (this.level - 1) * 2;\n      this.target = randInt(minTarget, maxTarget);\n\n      // create at least 5 moving parts, ensure at least one pair sums to target\n      const pairA = randInt(1, this.target - 1);\n      const pairB = this.target - pairA;\n      const count = 6;\n      for (let i = 0; i < count; i++) {\n        const beltIndex = i % 2;\n        const belt = this.belts[beltIndex];\n        const y = belt.y + (beltIndex === 0 ? -6 : -4);\n        const direction = belt.direction;\n        const speed = (belt.speedBase + randInt(-8, 8)) * direction;\n        let value;\n        if (i === 0) value = pairA;\n        else if (i === 1) value = pairB;\n        else value = randInt(1, Math.max(2, this.target - 1));\n        const x = randInt(20, WIDTH - 20);\n        this.parts.push(new Part(x, y, speed, value, beltIndex));\n      }\n    }\n\n    tryPickOrDrop() {\n      // If holding less than 2, try pick nearest part within reach\n      if (this.arm.cooldown > 0) return;\n      if (this.arm.holding.length < 2) {\n        // find closest part near arm center/tray region\n        const trayX = this.arm.x;\n        const trayY = this.arm.y + 26;\n        let best = null;\n        let bestDist = 9999;\n        for (const p of this.parts) {\n          if (p.picked) continue;\n          const dx = p.x - trayX;\n          const dy = p.y - trayY;\n          const dist = Math.hypot(dx, dy);\n          if (dist < 40 && dist < bestDist) {\n            best = p;\n            bestDist = dist;\n          }\n        }\n        if (best) {\n          // pick it\n          best.picked = true;\n          this.arm.holding.push(best);\n          playPickSound();\n          this.message = 'Picked a part. Place two parts into the gearbox!';\n          this.messageTimer = 2000;\n          this.arm.cooldown = 200; // ms\n          return;\n        }\n        // otherwise try picking from belts by reaching down\n        for (const p of this.parts) {\n          if (p.picked) continue;\n          const dx = p.x - this.arm.x;\n          const dy = p.y - (this.arm.y - 8);\n          const dist = Math.hypot(dx, dy);\n          if (dist < 30) {\n            p.picked = true;\n            this.arm.holding.push(p);\n            playPickSound();\n            this.message = 'Picked a part!';\n            this.messageTimer = 1200;\n            this.arm.cooldown = 200;\n            return;\n          }\n        }\n      } else {\n        // drop into gearbox area if near gearbox\n        const gearboxX = WIDTH - 120;\n        const gearboxY = HEIGHT / 2;\n        const dx = this.arm.x - gearboxX;\n        const dy = this.arm.y - gearboxY;\n        const dist = Math.hypot(dx, dy);\n        if (dist < 120) {\n          // drop all held parts into gearbox check\n          // The gearbox only accepts 2 parts at a time. If more than 2, drop only first two.\n          while (this.arm.holding.length > 2) {\n            const extra = this.arm.holding.pop();\n            extra.picked = false;\n            // re-position extra onto belt\n            extra.x = clamp(this.arm.x + randInt(-30, 30), 40, WIDTH - 40);\n            playDropSound();\n          }\n\n          if (this.arm.holding.length === 2) {\n            // compute sum\n            const sum = this.arm.holding[0].value + this.arm.holding[1].value;\n            if (sum === this.target) {\n              // success\n              playCorrectSound();\n              this.message = `Nice! ${this.arm.holding[0].value} + ${this.arm.holding[1].value} = ${this.target}`;\n              this.messageTimer = 3000;\n              this.solvedThisLevel = true;\n              // remove those parts from the field\n              this.parts = this.parts.filter(p => !this.arm.holding.includes(p));\n              this.arm.holding = [];\n              // progress to next level after a short delay\n              setTimeout(() => this.nextLevel(), 1200);\n            } else {\n              // wrong\n              playWrongSound();\n              this.attemptsLeft--;\n              this.message = `Try again: ${this.arm.holding[0].value} + ${this.arm.holding[1].value} = ${sum}`;\n              this.messageTimer = 2500;\n              // pop held parts back onto belts near machine\n              for (const p of this.arm.holding) {\n                p.picked = false;\n                p.x = clamp(this.arm.x + randInt(-20, 20), 40, WIDTH - 40);\n              }\n              this.arm.holding = [];\n              this.arm.cooldown = 300;\n              if (this.attemptsLeft <= 0) {\n                this.message = 'Out of attempts! Restarting level...';\n                this.messageTimer = 2200;\n                setTimeout(() => this.initLevel(), 1200);\n              }\n            }\n          } else {\n            // not enough parts to test\n            playDropSound();\n            // drop parts back to belts\n            for (const p of this.arm.holding) {\n              p.picked = false;\n              p.x = clamp(this.arm.x + randInt(-20, 20), 40, WIDTH - 40);\n            }\n            this.arm.holding = [];\n            this.message = 'You need two parts to test the gearbox.';\n            this.messageTimer = 1500;\n          }\n          return;\n        } else {\n          // simply drop the held parts back onto belts where arm is\n          for (const p of this.arm.holding) {\n            p.picked = false;\n            p.x = clamp(this.arm.x + randInt(-20, 20), 40, WIDTH - 40);\n          }\n          this.arm.holding = [];\n          playDropSound();\n          this.message = 'Dropped parts back on the belts.';\n          this.messageTimer = 1200;\n          this.arm.cooldown = 180;\n        }\n      }\n    }\n\n    nextLevel() {\n      if (this.level >= this.maxLevels) {\n        this.win = true;\n        this.message = 'You fixed the Mega Machine! Great work!';\n        this.messageTimer = 4000;\n        // celebration sounds\n        playCorrectSound();\n      } else {\n        this.level++;\n        this.initLevel();\n      }\n    }\n\n    restart() {\n      this.level = 1;\n      this.initLevel();\n      this.win = false;\n      this.message = 'Game restarted. Have fun!';\n      this.messageTimer = 2000;\n    }\n\n    update(dt) {\n      if (!this.running) return;\n      // move arm via keyboard\n      const moveSpeed = 220; // px/s\n      if (this.keys['ArrowLeft'] || this.keys['a'] || this.keys['A']) {\n        this.arm.x -= moveSpeed * dt;\n      }\n      if (this.keys['ArrowRight'] || this.keys['d'] || this.keys['D']) {\n        this.arm.x += moveSpeed * dt;\n      }\n      if (this.keys['ArrowUp'] || this.keys['w'] || this.keys['W']) {\n        this.arm.y -= moveSpeed * 0.5 * dt;\n      }\n      if (this.keys['ArrowDown'] || this.keys['s'] || this.keys['S']) {\n        this.arm.y += moveSpeed * 0.5 * dt;\n      }\n      this.arm.x = clamp(this.arm.x, 60, WIDTH - 60);\n      this.arm.y = clamp(this.arm.y, HEIGHT - 200, HEIGHT - 80);\n\n      // quick keyboard pick with Enter\n      if (this.keys['Enter']) {\n        this.tryPickOrDrop();\n        this.keys['Enter'] = false;\n      }\n\n      // update parts\n      for (const p of this.parts) {\n        p.update(dt);\n      }\n\n      // move picked parts to follow arm/its tray positions\n      for (let i = 0; i < this.arm.holding.length; i++) {\n        const p = this.arm.holding[i];\n        // target position on tray\n        const targetX = this.arm.x + (-22 + i * 44);\n        const targetY = this.arm.y + 26;\n        p.x += (targetX - p.x) * Math.min(1, dt * 12);\n        p.y += (targetY - p.y) * Math.min(1, dt * 12);\n      }\n\n      if (this.arm.cooldown > 0) {\n        this.arm.cooldown = Math.max(0, this.arm.cooldown - dt * 1000);\n      }\n\n      if (this.messageTimer > 0) {\n        this.messageTimer -= dt * 1000;\n        if (this.messageTimer <= 0) this.message = '';\n      }\n    }\n\n    drawBackground(ctx) {\n      // soft gradient sky\n      const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n      g.addColorStop(0, '#f7fbff');\n      g.addColorStop(0.5, '#eef9f7');\n      g.addColorStop(1, '#f3f7fb');\n      ctx.fillStyle = g;\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n      // doodle cloud shapes for wacky calm feel\n      ctx.save();\n      ctx.globalAlpha = 0.7;\n      drawCloud(ctx, 80, 60, 60, '#ffffff');\n      drawCloud(ctx, 220, 40, 44, '#ffffff');\n      drawCloud(ctx, 520, 70, 50, '#ffffff');\n      ctx.globalAlpha = 1;\n      ctx.restore();\n\n      // big machine frame on right\n      ctx.save();\n      ctx.translate(WIDTH - 180, HEIGHT / 2 - 20);\n      ctx.fillStyle = '#f0f4f8';\n      roundRect(ctx, -120, -140, 240, 280, 16);\n      ctx.fill();\n      ctx.strokeStyle = '#bfcdd7';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n      // porthole\n      ctx.beginPath();\n      ctx.fillStyle = '#e9fbff';\n      ctx.arc(0, -50, 36, 0, Math.PI*2);\n      ctx.fill();\n      ctx.strokeStyle = '#9cc3cf';\n      ctx.stroke();\n\n      // target display window\n      ctx.beginPath();\n      ctx.fillStyle = '#fff7';\n      roundRect(ctx, -70, 20, 140, 70, 10);\n      ctx.fill();\n      ctx.strokeStyle = '#9aaeb7';\n      ctx.stroke();\n\n      // little label\n      ctx.fillStyle = '#2b2b2b';\n      ctx.font = '14px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText('Gearbox Target', 0, 16);\n      ctx.restore();\n    }\n\n    drawConveyorAndParts(ctx) {\n      // draw belts\n      for (let b = 0; b < this.belts.length; b++) {\n        const belt = this.belts[b];\n        const y = belt.y;\n        // belt backing\n        ctx.beginPath();\n        ctx.fillStyle = '#eef7f6';\n        roundRect(ctx, 20, y - 28, WIDTH - 260, 56, 14);\n        ctx.fill();\n        // pattern lines to indicate motion\n        ctx.save();\n        ctx.clip();\n        ctx.beginPath();\n        ctx.strokeStyle = '#cfe6e3';\n        ctx.lineWidth = 3;\n        const stripeWidth = 22;\n        const offset = ((performance.now() / 30) * belt.direction) % stripeWidth;\n        for (let x = -100 + offset; x < WIDTH; x += stripeWidth) {\n          ctx.moveTo(x, y - 20);\n          ctx.lineTo(x + 14, y + 20);\n        }\n        ctx.stroke();\n        ctx.restore();\n\n        // belt edges screws\n        ctx.fillStyle = '#d0d8db';\n        for (let s = 24; s < WIDTH - 236; s += 60) {\n          ctx.beginPath();\n          ctx.arc(s, y - 20, 3, 0, Math.PI*2);\n          ctx.fill();\n          ctx.beginPath();\n          ctx.arc(s, y + 20, 3, 0, Math.PI*2);\n          ctx.fill();\n        }\n      }\n\n      // draw parts\n      for (const p of this.parts) p.draw(ctx);\n    }\n\n    drawMachineDetail(ctx) {\n      // gearbox window with target number\n      ctx.save();\n      const gx = WIDTH - 120;\n      const gy = HEIGHT / 2;\n      // display target number in window\n      ctx.beginPath();\n      ctx.fillStyle = '#fff';\n      roundRect(ctx, gx - 70, gy + 20, 140, 70, 10);\n      ctx.fill();\n      ctx.strokeStyle = '#9aaeb7';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n\n      // target number big\n      ctx.fillStyle = '#2b2b2b';\n      ctx.font = 'bold 38px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(String(this.target), gx, gy + 56);\n\n      // gears below\n      drawGear(ctx, gx - 40, gy - 30, 22, 8, '#c2e7e1', '#8ab6a9', 0.2);\n      drawGear(ctx, gx + 30, gy - 10, 28, 10, '#fde0c2', '#e6b884', -0.12);\n      ctx.restore();\n    }\n\n    drawArmAndUI(ctx) {\n      // draw arm first (so parts overlay nicely)\n      this.arm.draw(ctx);\n\n      // HUD: level, attempts, instructions\n      ctx.save();\n      ctx.fillStyle = 'rgba(255,255,255,0.75)';\n      roundRect(ctx, 10, 10, 260, 86, 10);\n      ctx.fill();\n      ctx.strokeStyle = '#d0d6da';\n      ctx.stroke();\n\n      ctx.fillStyle = '#2b2b2b';\n      ctx.font = 'bold 16px sans-serif';\n      ctx.textAlign = 'left';\n      ctx.fillText(`Level ${this.level}/${this.maxLevels}`, 22, 34);\n\n      ctx.font = '13px sans-serif';\n      ctx.fillText(`Attempts: ${this.attemptsLeft}`, 22, 56);\n      ctx.fillText('Controls: \u2190 \u2192 move  Space/Click pick/drop  M toggle sound', 22, 76);\n\n      // audio icon visual cue\n      const iconX = 260;\n      const iconY = 32;\n      ctx.beginPath();\n      ctx.fillStyle = audioEnabled ? '#7fc9a9' : '#ddd';\n      roundRect(ctx, iconX, iconY - 12, 34, 24, 6);\n      ctx.fill();\n      ctx.strokeStyle = '#c3d3d0';\n      ctx.stroke();\n\n      ctx.fillStyle = audioEnabled ? '#fff' : '#888';\n      ctx.font = '12px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText(audioEnabled ? 'Sound' : 'Muted', iconX + 17, iconY + 1);\n\n      ctx.restore();\n\n      // Message area\n      if (this.message) {\n        ctx.save();\n        ctx.globalAlpha = 0.95;\n        ctx.fillStyle = '#ffffff';\n        roundRect(ctx, WIDTH/2 - 260, HEIGHT - 96, 520, 60, 12);\n        ctx.fill();\n        ctx.strokeStyle = '#cdd9dc';\n        ctx.stroke();\n\n        ctx.fillStyle = '#2b2b2b';\n        ctx.font = '15px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.fillText(this.message, WIDTH/2, HEIGHT - 60);\n        ctx.restore();\n      }\n\n      // Accessibility hint\n      ctx.save();\n      ctx.font = '12px sans-serif';\n      ctx.fillStyle = '#6a6a6a';\n      ctx.textAlign = 'left';\n      ctx.fillText('For screen readers: use keyboard arrows and space to operate the arm. Press M to toggle sound.', 14, HEIGHT - 10);\n      ctx.restore();\n    }\n\n    drawWinScreen(ctx) {\n      ctx.save();\n      ctx.fillStyle = 'rgba(255,255,255,0.9)';\n      roundRect(ctx, WIDTH/2 - 260, HEIGHT/2 - 120, 520, 240, 18);\n      ctx.fill();\n      ctx.strokeStyle = '#d7e6e6';\n      ctx.stroke();\n\n      ctx.fillStyle = '#2b2b2b';\n      ctx.font = 'bold 26px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText('Mega Machine Fixed!', WIDTH/2, HEIGHT/2 - 20);\n      ctx.font = '18px sans-serif';\n      ctx.fillText('You solved all levels. Great engineering thinking!', WIDTH/2, HEIGHT/2 + 16);\n\n      ctx.font = '14px sans-serif';\n      ctx.fillStyle = '#6a6a6a';\n      ctx.fillText('Press Escape to play again.', WIDTH/2, HEIGHT/2 + 56);\n      ctx.restore();\n    }\n\n    draw(ctx) {\n      // clear\n      ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n      this.drawBackground(ctx);\n      this.drawConveyorAndParts(ctx);\n      this.drawMachineDetail(ctx);\n      this.drawArmAndUI(ctx);\n\n      if (this.win) {\n        this.drawWinScreen(ctx);\n      }\n\n      // draw subtle decorative wacky elements\n      ctx.save();\n      ctx.globalAlpha = 0.9;\n      ctx.fillStyle = '#ffffff';\n      // tiny moving bubbles for calm effect\n      const t = performance.now() / 1000;\n      for (let i = 0; i < 6; i++) {\n        const bx = (i * 110 + ((t * (i + 1) * 5) % 110));\n        const by = 40 + (Math.sin(t * (i + 1)) * 10);\n        ctx.beginPath();\n        ctx.fillStyle = `rgba(255,255,255,${0.6 - i*0.06})`;\n        ctx.arc(bx % WIDTH, by, 8 + i % 3, 0, Math.PI*2);\n        ctx.fill();\n      }\n      ctx.restore();\n    }\n\n    loop(now) {\n      const dt = Math.min(0.05, (now - this.lastTime) / 1000);\n      this.lastTime = now;\n      this.update(dt);\n      try {\n        this.draw(this.ctx);\n      } catch (e) {\n        console.error('Render error', e);\n      }\n      this.animationRequest = requestAnimationFrame(this.loop);\n    }\n\n    stop() {\n      this.running = false;\n      if (this.animationRequest) cancelAnimationFrame(this.animationRequest);\n    }\n  }\n\n  // ======== Drawing Helpers ========\n  function roundRect(ctx, x, y, w, h, r) {\n    const radius = r || 6;\n    ctx.beginPath();\n    ctx.moveTo(x + radius, y);\n    ctx.arcTo(x + w, y, x + w, y + h, radius);\n    ctx.arcTo(x + w, y + h, x, y + h, radius);\n    ctx.arcTo(x, y + h, x, y, radius);\n    ctx.arcTo(x, y, x + w, y, radius);\n    ctx.closePath();\n  }\n\n  function drawCloud(ctx, x, y, size, color = '#fff') {\n    ctx.save();\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.arc(x, y, size * 0.6, 0, Math.PI * 2);\n    ctx.arc(x + size * 0.6, y + 4, size * 0.5, 0, Math.PI * 2);\n    ctx.arc(x - size * 0.5, y + 4, size * 0.4, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function drawGear(ctx, x, y, radius, teeth, colorLight, colorDark, rotation = 0) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(rotation);\n    // teeth\n    for (let i = 0; i < teeth; i++) {\n      const ang = (i / teeth) * Math.PI * 2;\n      const x1 = Math.cos(ang) * radius;\n      const y1 = Math.sin(ang) * radius;\n      const x2 = Math.cos(ang) * (radius + 8);\n      const y2 = Math.sin(ang) * (radius + 8);\n      ctx.beginPath();\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x2, y2);\n      ctx.lineWidth = 6;\n      ctx.strokeStyle = colorDark;\n      ctx.stroke();\n    }\n    // center disc\n    ctx.beginPath();\n    ctx.fillStyle = colorLight;\n    ctx.arc(0, 0, radius - 6, 0, Math.PI*2);\n    ctx.fill();\n    ctx.strokeStyle = colorDark;\n    ctx.lineWidth = 2;\n    ctx.stroke();\n\n    // hub\n    ctx.beginPath();\n    ctx.fillStyle = '#ffffff';\n    ctx.arc(0, 0, radius / 4, 0, Math.PI*2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  // ======== Initialization and Error Handling ========\n  // Try audio init but allow graceful degrade\n  try {\n    initAudio();\n  } catch (e) {\n    console.warn('Audio unavailable:', e);\n    audioInitError = true;\n    audioEnabled = false;\n  }\n  setAudioEnabled(audioEnabled);\n\n  // Create and start the game\n  const game = new Game(ctx);\n\n  // Accessibility: announce start via canvas aria-label update\n  function updateAria() {\n    const desc = `Machine Merge. Level ${game.level}. Target ${game.target}. ${game.attemptsLeft} attempts remaining. Use arrows to move the arm, space to pick or drop parts, M to toggle sound.`;\n    canvas.setAttribute('aria-label', desc);\n  }\n  setInterval(updateAria, 1000);\n\n  // Resume audio on first user interaction\n  ['click', 'keydown', 'touchstart'].forEach(evt => {\n    document.addEventListener(evt, () => {\n      tryInitAudioOnGesture();\n      resumeAudioOnInteraction();\n    }, { once: true });\n  });\n\n  // Basic error handling for audio context events\n  if (audioCtx) {\n    audioCtx.onstatechange = () => {\n      if (audioCtx.state === 'suspended') {\n        // show visual cue\n        game.message = 'Audio suspended; press a key or click to resume audio.';\n        game.messageTimer = 3000;\n      }\n    };\n  }\n\n  // Clean up on page unload\n  window.addEventListener('beforeunload', () => {\n    try {\n      if (backgroundOsc) backgroundOsc.disconnect();\n      if (backgroundGain) backgroundGain.disconnect();\n      if (audioCtx) audioCtx.close();\n    } catch (e) {\n      // ignore\n    }\n  });\n\n  // Expose some simple debug hooks (non-invasive)\n  window.__MachineMergeGame = {\n    restart: () => game.restart(),\n    toggleSound: () => setAudioEnabled(!audioEnabled)\n  };\n})();\n---\n",
  "improve_response_tokens": 20227,
  "formatted_code": true,
  "formatting_response_tokens": 21957,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}