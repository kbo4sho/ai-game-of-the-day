{
  "generated_date": "2025-10-13",
  "generated_timestamp": "2025-10-13T00:29:00.924642",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9069,
  "game_filename": "2025-10-13.js",
  "game_size_bytes": 25802,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Drone Math Collector - JavaScript Game\n  // Renders inside element with ID game-of-the-day-stage\n  // Designed for ages 7-9. Uses Canvas and Web Audio API only.\n  // Clear win: collect TARGET_SCORE correct numbers.\n  // Clear loss: reach MAX_WRONG wrong collections (lives system).\n  // Includes keyboard controls, clickable restart, accessible canvas attributes, audio toggle,\n  // and careful layout using ctx.measureText to avoid overlapping text.\n\n  // CONFIG\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const TARGET_SCORE = 10; // win condition\n  const MAX_WRONG = 3; // lives\n  const STARTING_BALLOONS = 5;\n  const MIN_NUMBER = 1;\n  const MAX_NUMBER = 20;\n  const BODY_FONT = \"16px system-ui, sans-serif\";\n  const TITLE_FONT = \"22px system-ui, sans-serif\";\n  const IMPORTANT_FONT = \"28px system-ui, sans-serif\";\n  const PADDING = 10; // min 10px padding\n  const BOTTOM_INSTRUCTIONS_HEIGHT = 80; // reserved bottom area for instructions\n\n  // Get container and create canvas\n  const container = document.getElementById(\"game-of-the-day-stage\");\n  if (!container) {\n    console.error(\"Container #game-of-the-day-stage not found.\");\n    return;\n  }\n  container.style.position = \"relative\";\n  container.style.width = WIDTH + \"px\";\n  container.style.height = HEIGHT + \"px\";\n  container.style.userSelect = \"none\";\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.tabIndex = 0; // make keyboard focusable\n  canvas.setAttribute(\"role\", \"application\");\n  canvas.setAttribute(\"aria-label\", \"Drone Math Collector game. Use arrow keys to move, space to pick up balloons. Press R to restart.\");\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext(\"2d\");\n\n  // Audio setup with proper error handling\n  let audioEnabled = true;\n  let audioContext = null;\n  try {\n    const AC = window.AudioContext || window.webkitAudioContext;\n    if (!AC) throw new Error(\"Web Audio API not supported\");\n    audioContext = new AC();\n    // unlock audio on interaction for browsers that require it\n    const unlock = () => {\n      if (audioContext.state === \"suspended\") {\n        audioContext.resume().catch(() => {});\n      }\n      window.removeEventListener(\"pointerdown\", unlock);\n      window.removeEventListener(\"keydown\", unlock);\n    };\n    window.addEventListener(\"pointerdown\", unlock, { once: true });\n    window.addEventListener(\"keydown\", unlock, { once: true });\n  } catch (e) {\n    console.warn(\"Audio context creation failed:\", e);\n    audioEnabled = false;\n    audioContext = null;\n  }\n\n  // Sound generators (simple oscillator-based)\n  function playTone({ type = \"sine\", freq = 440, duration = 0.25, volume = 0.06, attack = 0.01, decay = 0.05 }) {\n    if (!audioEnabled || !audioContext) return;\n    try {\n      const now = audioContext.currentTime;\n      const o = audioContext.createOscillator();\n      const g = audioContext.createGain();\n      o.type = type;\n      o.frequency.value = freq;\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.linearRampToValueAtTime(volume, now + attack);\n      g.gain.linearRampToValueAtTime(0.0001, now + duration - decay);\n      o.connect(g);\n      g.connect(audioContext.destination);\n      o.start(now);\n      o.stop(now + duration + 0.02);\n      o.onended = () => {\n        try {\n          o.disconnect();\n          g.disconnect();\n        } catch (e) {}\n      };\n    } catch (e) {\n      console.warn(\"Error playing tone:\", e);\n    }\n  }\n\n  function playCorrectSound() {\n    // gentle chime: arpeggio-like\n    playTone({ type: \"sine\", freq: 880, duration: 0.18, volume: 0.05 });\n    setTimeout(() => playTone({ type: \"sine\", freq: 1100, duration: 0.16, volume: 0.05 }), 120);\n  }\n\n  function playWrongSound() {\n    // buzzy short noise\n    if (!audioEnabled || !audioContext) return;\n    try {\n      const now = audioContext.currentTime;\n      const o = audioContext.createOscillator();\n      const f = audioContext.createBiquadFilter();\n      const g = audioContext.createGain();\n      o.type = \"square\";\n      o.frequency.value = 220;\n      f.type = \"highpass\";\n      f.frequency.value = 1000;\n      g.gain.setValueAtTime(0.12, now);\n      g.gain.exponentialRampToValueAtTime(0.001, now + 0.18);\n      o.connect(f);\n      f.connect(g);\n      g.connect(audioContext.destination);\n      o.start(now);\n      o.stop(now + 0.18);\n      o.onended = () => {\n        try {\n          o.disconnect();\n          f.disconnect();\n          g.disconnect();\n        } catch (e) {}\n      };\n    } catch (e) {\n      console.warn(\"Error playing wrong sound:\", e);\n    }\n  }\n\n  // Game state\n  let score = 0;\n  let wrongs = 0;\n  let balloons = [];\n  let player = null;\n  let targetQuestion = null;\n  let elapsed = 0;\n  let lastTime = 0;\n  let running = false; // whether gameplay is active\n  let gameState = \"start\"; // \"start\", \"playing\", \"won\", \"lost\"\n  let backgroundOffset = 0;\n  let showAudioStatusFlash = 0;\n\n  // Input state\n  const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, Space: false };\n\n  // Utility functions\n  function rand(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  function clamp(v, a, b) {\n    return Math.max(a, Math.min(b, v));\n  }\n\n  // Create player drone\n  function resetPlayer() {\n    player = {\n      x: WIDTH / 2,\n      y: HEIGHT / 2,\n      r: 18,\n      speed: 180, // px per second\n      color: \"#6BB7FF\",\n      wobble: 0\n    };\n  }\n\n  // Create a new math question and set of balloons\n  function spawnQuestion() {\n    // Choose addition or subtraction with simple numbers\n    const type = Math.random() < 0.6 ? \"+\" : \"-\";\n    let a, b, answer;\n    if (type === \"+\") {\n      a = rand(1, 12);\n      b = rand(1, 12);\n      answer = a + b;\n    } else {\n      a = rand(5, 18);\n      b = rand(1, 6);\n      answer = a - b;\n    }\n    targetQuestion = { a, b, type, answer };\n\n    // Spawn balloons with numbers, including the correct one\n    balloons = [];\n    const count = STARTING_BALLOONS;\n    const correctIndex = rand(0, count - 1);\n    for (let i = 0; i < count; i++) {\n      let value;\n      if (i === correctIndex) {\n        value = answer;\n      } else {\n        // ensure wrong values not equal answer\n        let v;\n        do {\n          v = rand(MIN_NUMBER, MAX_NUMBER);\n        } while (v === answer);\n        value = v;\n      }\n      // positions along top area (not overlapping bottom instructions)\n      const spawnX = rand(40, WIDTH - 40);\n      const spawnY = rand(60, HEIGHT - BOTTOM_INSTRUCTIONS_HEIGHT - 60);\n      const vx = (Math.random() - 0.5) * (20 + score * 2); // slightly faster as score increases\n      const vy = (Math.random() - 0.5) * 20;\n      balloons.push({\n        x: spawnX,\n        y: spawnY,\n        r: 20,\n        vx,\n        vy,\n        value,\n        wobble: Math.random() * Math.PI * 2,\n        color: pastelColor(i)\n      });\n    }\n  }\n\n  // Pastel palette generator for wacky calming colors\n  function pastelColor(index) {\n    const hues = [200, 180, 220, 260, 140, 30, 20, 340];\n    const h = hues[index % hues.length] + (index * 10 % 40);\n    return `hsl(${h} 70% 75%)`;\n  }\n\n  // Draw calming background with soft clouds and grid\n  function drawBackground(dt) {\n    backgroundOffset += dt * 20; // scroll\n    // sky\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, \"#E8F7FF\");\n    g.addColorStop(1, \"#F7FDFF\");\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // soft clouds - use arcs\n    ctx.fillStyle = \"rgba(255,255,255,0.6)\";\n    for (let i = 0; i < 6; i++) {\n      const cx = (i * 220 - (backgroundOffset % 220));\n      const cy = 60 + Math.sin((backgroundOffset / 60) + i) * 8;\n      drawCloud(cx + 100, cy, 50 + (i % 3) * 6);\n    }\n\n    // gentle grid lines for calming techy look\n    ctx.strokeStyle = \"rgba(120,170,200,0.06)\";\n    ctx.lineWidth = 1;\n    for (let x = -((backgroundOffset / 4) % 60); x < WIDTH; x += 60) {\n      ctx.beginPath();\n      ctx.moveTo(x, 0);\n      ctx.lineTo(x, HEIGHT);\n      ctx.stroke();\n    }\n    for (let y = 0; y < HEIGHT; y += 60) {\n      ctx.beginPath();\n      ctx.moveTo(0, y);\n      ctx.lineTo(WIDTH, y);\n      ctx.stroke();\n    }\n  }\n\n  function drawCloud(cx, cy, size) {\n    ctx.beginPath();\n    ctx.arc(cx - size / 2, cy, size * 0.6, 0, Math.PI * 2);\n    ctx.arc(cx, cy - size * 0.2, size * 0.8, 0, Math.PI * 2);\n    ctx.arc(cx + size / 2, cy, size * 0.6, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  // Draw UI elements with spacing and non-overlap using measureText\n  function drawUI() {\n    // Top-left: Score\n    ctx.font = IMPORTANT_FONT;\n    ctx.fillStyle = \"#09324B\";\n    const scoreText = `Score: ${score}/${TARGET_SCORE}`;\n    const scoreMetrics = ctx.measureText(scoreText);\n    const scoreW = scoreMetrics.width;\n    const scoreH = 28;\n    const scoreX = PADDING;\n    const scoreY = PADDING;\n    ctx.fillStyle = \"rgba(255,255,255,0.85)\";\n    roundRectFill(scoreX - 6, scoreY - 6, scoreW + 12, scoreH + 12, 8);\n    ctx.fillStyle = \"#07405F\";\n    ctx.fillText(scoreText, scoreX + 0, scoreY + scoreH - 8);\n\n    // Top-center: Audio toggle (visual indicator)\n    ctx.font = BODY_FONT;\n    const audioText = audioEnabled ? \"\ud83d\udd0a Audio: On\" : \"\ud83d\udd08 Audio: Off\";\n    const audioMetrics = ctx.measureText(audioText);\n    const audioW = audioMetrics.width;\n    const audioX = (WIDTH - audioW) / 2;\n    const audioY = PADDING;\n    ctx.fillStyle = \"rgba(255,255,255,0.85)\";\n    roundRectFill(audioX - 6, audioY - 6, audioW + 12, 26 + 12 - 6, 8);\n    ctx.fillStyle = \"#07405F\";\n    ctx.fillText(audioText, audioX, audioY + 20);\n\n    // If audio is disabled, flash small visual cue occasionally\n    if (!audioEnabled && showAudioStatusFlash > 0) {\n      ctx.fillStyle = \"rgba(255,120,120,0.6)\";\n      ctx.fillRect(audioX + audioW + 14, audioY + 2, 8, 8);\n    }\n\n    // Top-right: Lives/wrongs\n    ctx.font = IMPORTANT_FONT;\n    const livesText = `Lives: ${Math.max(0, MAX_WRONG - wrongs)}`;\n    const livesMetrics = ctx.measureText(livesText);\n    const livesW = livesMetrics.width;\n    const livesX = WIDTH - livesW - PADDING;\n    const livesY = PADDING;\n    ctx.fillStyle = \"rgba(255,255,255,0.85)\";\n    roundRectFill(livesX - 6, livesY - 6, livesW + 12, 28 + 12 - 6, 8);\n    ctx.fillStyle = \"#7A102B\";\n    ctx.fillText(livesText, livesX, livesY + 20);\n\n    // Bottom-center: Instructions (multi-line)\n    ctx.font = BODY_FONT;\n    const lines = [];\n    if (gameState === \"playing\") {\n      lines.push(`Question: ${targetQuestion.a} ${targetQuestion.type} ${targetQuestion.b} = ?`);\n      lines.push(\"Fly your drone (arrow keys) and collect the correct numbered balloon. Space picks up too.\");\n    } else if (gameState === \"start\") {\n      lines.push(\"Welcome! Help your friendly drone collect the correct numbers.\");\n      lines.push(\"Collect 10 correct balloons to win. 3 wrong picks and it's game over.\");\n      lines.push(\"Press Space or Enter to begin.\");\n    } else if (gameState === \"won\") {\n      lines.push(\"You Win! The drone fleet celebrates!\");\n      lines.push(\"Press R or click Restart to play again.\");\n    } else if (gameState === \"lost\") {\n      lines.push(\"Game Over. The drone needs practice.\");\n      lines.push(\"Press R or click Restart to try again.\");\n    }\n    // measure max width\n    let maxW = 0;\n    for (const l of lines) {\n      const m = ctx.measureText(l).width;\n      if (m > maxW) maxW = m;\n    }\n    const boxW = maxW + 24;\n    const boxH = lines.length * 20 + 20;\n    const boxX = (WIDTH - boxW) / 2;\n    const boxY = HEIGHT - boxH - PADDING;\n    ctx.fillStyle = \"rgba(255,255,255,0.85)\";\n    roundRectFill(boxX, boxY, boxW, boxH, 10);\n    ctx.fillStyle = \"#0A3A55\";\n    for (let i = 0; i < lines.length; i++) {\n      ctx.fillText(lines[i], boxX + 12, boxY + 20 + i * 20);\n    }\n\n    // If game over or win, draw restart button just above instructions\n    if (gameState === \"won\" || gameState === \"lost\") {\n      const btnText = \"Restart\";\n      ctx.font = \"18px system-ui, sans-serif\";\n      const bW = ctx.measureText(btnText).width + 30;\n      const bH = 36;\n      const bX = (WIDTH - bW) / 2;\n      const bY = boxY - bH - 12;\n      ctx.fillStyle = \"#FFFFFF\";\n      roundRectFill(bX, bY, bW, bH, 8);\n      ctx.fillStyle = \"#07405F\";\n      ctx.fillText(btnText, bX + 15, bY + 24);\n      // store button bounds for click detection\n      canvas.restartButton = { x: bX, y: bY, w: bW, h: bH };\n    } else {\n      canvas.restartButton = null;\n    }\n  }\n\n  function roundRectFill(x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  // Draw player drone\n  function drawPlayer(dt) {\n    if (!player) return;\n    player.wobble += dt * 8;\n    // draw shadow\n    ctx.fillStyle = \"rgba(0,0,0,0.08)\";\n    ctx.beginPath();\n    ctx.ellipse(player.x, player.y + player.r + 10, player.r * 1.1, player.r * 0.5, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // body\n    ctx.fillStyle = player.color;\n    ctx.beginPath();\n    ctx.ellipse(player.x, player.y, player.r * 1.2, player.r, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // highlight\n    ctx.fillStyle = \"rgba(255,255,255,0.3)\";\n    ctx.beginPath();\n    ctx.ellipse(player.x - 6, player.y - 6, player.r * 0.45, player.r * 0.3, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // propellers (wacky)\n    ctx.save();\n    ctx.translate(player.x, player.y - player.r * 0.9);\n    for (let i = -1; i <= 1; i += 2) {\n      ctx.save();\n      ctx.rotate(Math.sin(player.wobble + i) * 0.8);\n      ctx.fillStyle = \"rgba(30,30,40,0.6)\";\n      ctx.fillRect(i * (player.r + 4), -4, 28, 8);\n      ctx.restore();\n    }\n    ctx.restore();\n\n    // simple face\n    ctx.fillStyle = \"#052A3B\";\n    ctx.beginPath();\n    ctx.arc(player.x - 6, player.y - 2, 2, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(player.x + 6, player.y - 2, 2, 0, Math.PI * 2);\n    ctx.fill();\n    // mouth\n    ctx.strokeStyle = \"#052A3B\";\n    ctx.lineWidth = 1.5;\n    ctx.beginPath();\n    ctx.arc(player.x, player.y + 4, 4, 0, Math.PI);\n    ctx.stroke();\n  }\n\n  // Draw balloons (numbers to collect)\n  function drawBalloons(dt) {\n    ctx.font = \"18px system-ui, sans-serif\";\n    balloons.forEach((b) => {\n      // movement\n      b.x += b.vx * dt;\n      b.y += b.vy * dt;\n      b.wobble += dt * 3;\n      // bounce from edges\n      if (b.x < b.r + 6) {\n        b.x = b.r + 6;\n        b.vx *= -1;\n      } else if (b.x > WIDTH - b.r - 6) {\n        b.x = WIDTH - b.r - 6;\n        b.vx *= -1;\n      }\n      if (b.y < b.r + 50) {\n        b.y = b.r + 50;\n        b.vy *= -1;\n      } else if (b.y > HEIGHT - BOTTOM_INSTRUCTIONS_HEIGHT - b.r - 6) {\n        b.y = HEIGHT - BOTTOM_INSTRUCTIONS_HEIGHT - b.r - 6;\n        b.vy *= -1;\n      }\n      // tether line\n      ctx.strokeStyle = \"rgba(60,80,90,0.18)\";\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(b.x, b.y + 18);\n      ctx.lineTo(b.x, b.y + 38);\n      ctx.stroke();\n\n      // balloon body\n      ctx.fillStyle = b.color;\n      ctx.beginPath();\n      ctx.ellipse(b.x, b.y, b.r, b.r * 1.05, Math.sin(b.wobble) * 0.2, 0, Math.PI * 2);\n      ctx.fill();\n\n      // number text background for readability\n      const text = String(b.value);\n      const metrics = ctx.measureText(text);\n      const textW = metrics.width;\n      const textH = 18;\n      ctx.fillStyle = \"rgba(255,255,255,0.65)\";\n      roundRectFill(b.x - textW / 2 - 8, b.y - textH / 2 - 6, textW + 16, textH + 10, 6);\n\n      // number\n      ctx.fillStyle = \"#053241\";\n      ctx.fillText(text, b.x - textW / 2, b.y + 6);\n    });\n  }\n\n  // Update player position based on keys\n  function updatePlayer(dt) {\n    if (!player) return;\n    let dx = 0,\n      dy = 0;\n    if (keys.ArrowLeft) dx -= 1;\n    if (keys.ArrowRight) dx += 1;\n    if (keys.ArrowUp) dy -= 1;\n    if (keys.ArrowDown) dy += 1;\n    // Normalize\n    if (dx !== 0 || dy !== 0) {\n      const len = Math.sqrt(dx * dx + dy * dy);\n      dx /= len;\n      dy /= len;\n      player.x += dx * player.speed * dt;\n      player.y += dy * player.speed * dt;\n      player.x = clamp(player.x, player.r + 8, WIDTH - player.r - 8);\n      player.y = clamp(player.y, player.r + 50, HEIGHT - BOTTOM_INSTRUCTIONS_HEIGHT - player.r - 8);\n    }\n  }\n\n  // Collision detection for collecting balloons\n  function checkCollisions() {\n    if (!player) return;\n    for (let i = balloons.length - 1; i >= 0; i--) {\n      const b = balloons[i];\n      const dx = player.x - b.x;\n      const dy = player.y - b.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      if (dist < player.r + b.r - 6) {\n        // auto-pickup upon touch OR when pressing space near balloon\n        // We'll consider immediate pickup on touch for younger players (accessible)\n        collectBalloon(i);\n      }\n    }\n  }\n\n  function collectBalloon(index) {\n    const b = balloons[index];\n    if (!b) return;\n    const correct = b.value === targetQuestion.answer;\n    // pop animation: remove balloon\n    balloons.splice(index, 1);\n    if (correct) {\n      score += 1;\n      playCorrectSound();\n      // small celebratory particle or wobble (visual only)\n      showAudioStatusFlash = 5;\n      if (score >= TARGET_SCORE) {\n        endGame(true);\n        return;\n      } else {\n        // spawn next question after small delay\n        setTimeout(spawnQuestion, 500);\n      }\n    } else {\n      wrongs += 1;\n      playWrongSound();\n      showAudioStatusFlash = 5;\n      if (wrongs >= MAX_WRONG) {\n        endGame(false);\n        return;\n      } else {\n        setTimeout(spawnQuestion, 500);\n      }\n    }\n  }\n\n  function endGame(won) {\n    running = false;\n    gameState = won ? \"won\" : \"lost\";\n    // stop background audio if any - we only used oscillators\n    // show accessibility hint via canvas title\n    canvas.setAttribute(\"aria-label\", won ? \"You won! Press R to restart.\" : \"Game over. Press R to restart.\");\n  }\n\n  // Start a new game\n  function startGame() {\n    score = 0;\n    wrongs = 0;\n    resetPlayer();\n    spawnQuestion();\n    gameState = \"playing\";\n    running = true;\n    lastTime = performance.now();\n    requestAnimationFrame(loop);\n  }\n\n  // Main loop\n  function loop(now) {\n    if (!lastTime) lastTime = now;\n    const dt = (now - lastTime) / 1000;\n    lastTime = now;\n    elapsed += dt;\n\n    // Update showAudioStatusFlash timer\n    if (showAudioStatusFlash > 0) showAudioStatusFlash -= dt;\n\n    // Update and draw\n    drawBackground(dt);\n    updatePlayer(dt);\n    drawBalloons(dt);\n    drawPlayer(dt);\n\n    // UI AFTER drawing game elements to ensure readability\n    drawUI();\n\n    if (running) {\n      checkCollisions();\n      requestAnimationFrame(loop);\n    }\n  }\n\n  // Input handlers\n  canvas.addEventListener(\"keydown\", (e) => {\n    if (e.key in keys) {\n      keys[e.key] = true;\n      e.preventDefault();\n    } else if (e.key === \" \" || e.key === \"Spacebar\") {\n      // space can also be used to start game or pick up near balloons\n      e.preventDefault();\n      if (gameState === \"start\") {\n        startGame();\n      } else if (gameState === \"playing\") {\n        // pick-up: check for nearest balloon within small radius\n        let nearest = -1;\n        let minDist = Infinity;\n        for (let i = 0; i < balloons.length; i++) {\n          const b = balloons[i];\n          const dx = player.x - b.x;\n          const dy = player.y - b.y;\n          const dist = Math.sqrt(dx * dx + dy * dy);\n          if (dist < minDist) {\n            minDist = dist;\n            nearest = i;\n          }\n        }\n        if (nearest !== -1 && minDist < player.r + balloons[nearest].r + 8) {\n          collectBalloon(nearest);\n        }\n      } else if (gameState === \"won\" || gameState === \"lost\") {\n        restartGame();\n      }\n    } else if (e.key === \"Enter\") {\n      if (gameState === \"start\") startGame();\n    } else if (e.key === \"r\" || e.key === \"R\") {\n      restartGame();\n    } else if (e.key.toLowerCase() === \"m\") {\n      // toggle audio with M\n      toggleAudio();\n    }\n  });\n\n  canvas.addEventListener(\"keyup\", (e) => {\n    if (e.key in keys) {\n      keys[e.key] = false;\n      e.preventDefault();\n    }\n  });\n\n  // Focus canvas to receive keyboard\n  canvas.addEventListener(\"focus\", () => {\n    // nothing needed, but keep accessibility cue visible\n  });\n\n  // Pointer controls for moving (also support clicking restart)\n  let pointerActive = false;\n  canvas.addEventListener(\"pointerdown\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    // Check restart button\n    if (canvas.restartButton) {\n      const b = canvas.restartButton;\n      if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {\n        restartGame();\n        return;\n      }\n    }\n    // Check audio toggle area (top-center)\n    ctx.font = BODY_FONT;\n    const audioText = audioEnabled ? \"\ud83d\udd0a Audio: On\" : \"\ud83d\udd08 Audio: Off\";\n    const audioW = ctx.measureText(audioText).width;\n    const audioX = (WIDTH - audioW) / 2;\n    const audioY = PADDING;\n    if (y >= audioY - 6 && y <= audioY + 28 && x >= audioX - 6 && x <= audioX + audioW + 6) {\n      toggleAudio();\n      return;\n    }\n    // Move player toward pointer while pointer active\n    pointerActive = true;\n    movePlayerTo(x, y);\n  });\n\n  canvas.addEventListener(\"pointermove\", (e) => {\n    if (!pointerActive) return;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    movePlayerTo(x, y);\n  });\n\n  canvas.addEventListener(\"pointerup\", () => {\n    pointerActive = false;\n  });\n\n  canvas.addEventListener(\"click\", (e) => {\n    // If clicking on a balloon near player, treat as pickup\n    if (gameState !== \"playing\") return;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    // find clicked balloon\n    for (let i = 0; i < balloons.length; i++) {\n      const b = balloons[i];\n      const dx = x - b.x;\n      const dy = y - b.y;\n      if (Math.sqrt(dx * dx + dy * dy) <= b.r + 6) {\n        // if player close enough, collect; otherwise move player toward it\n        const pdx = player.x - b.x;\n        const pdy = player.y - b.y;\n        if (Math.sqrt(pdx * pdx + pdy * pdy) < 120) {\n          collectBalloon(i);\n        } else {\n          // move player toward clicked balloon immediately\n          movePlayerTo(b.x, b.y);\n        }\n        break;\n      }\n    }\n  });\n\n  function movePlayerTo(x, y) {\n    if (!player) return;\n    // teleport a bit towards pointer for touch accessibility: smooth small move\n    const dx = x - player.x;\n    const dy = y - player.y;\n    const len = Math.sqrt(dx * dx + dy * dy);\n    if (len < 1) return;\n    const step = Math.min(60, len);\n    player.x += (dx / len) * step;\n    player.y += (dy / len) * step;\n    player.x = clamp(player.x, player.r + 8, WIDTH - player.r - 8);\n    player.y = clamp(player.y, player.r + 50, HEIGHT - BOTTOM_INSTRUCTIONS_HEIGHT - player.r - 8);\n  }\n\n  // Toggle audio on/off\n  function toggleAudio() {\n    if (!audioContext) {\n      audioEnabled = false;\n      showAudioStatusFlash = 5;\n      return;\n    }\n    audioEnabled = !audioEnabled;\n    showAudioStatusFlash = 5;\n    canvas.setAttribute(\"aria-label\", audioEnabled ? \"Audio enabled\" : \"Audio disabled\");\n  }\n\n  // Restart game (reset state)\n  function restartGame() {\n    score = 0;\n    wrongs = 0;\n    resetPlayer();\n    spawnQuestion();\n    gameState = \"playing\";\n    running = true;\n    lastTime = performance.now();\n    requestAnimationFrame(loop);\n  }\n\n  // Initial draw for start screen\n  function initialDraw() {\n    // background\n    drawBackground(0.016);\n    // big friendly drone floating center-left\n    resetPlayer();\n    player.x = WIDTH / 3;\n    player.y = HEIGHT / 2 - 20;\n    drawPlayer(0.016);\n    // a couple of decorative balloons\n    balloons = [\n      { x: WIDTH * 0.62, y: HEIGHT * 0.33, r: 22, vx: 0, vy: 0, value: 7, wobble: 0, color: pastelColor(1) },\n      { x: WIDTH * 0.75, y: HEIGHT * 0.45, r: 22, vx: 0, vy: 0, value: 3, wobble: 0, color: pastelColor(2) }\n    ];\n    drawBalloons(0.016);\n\n    // Title and instructions\n    ctx.font = IMPORTANT_FONT;\n    ctx.fillStyle = \"#073146\";\n    const title = \"Drone Math Collector\";\n    const titleW = ctx.measureText(title).width;\n    ctx.fillText(title, (WIDTH - titleW) / 2, 80);\n\n    // Description box bottom\n    ctx.font = BODY_FONT;\n    const lines = [\n      \"Welcome! Help your friendly drone collect the correct numbers to solve math questions.\",\n      `Collect ${TARGET_SCORE} correct balloons to win. ${MAX_WRONG} wrong picks and it's game over.`,\n      \"Use arrow keys to fly, or tap/click. Press Space to start.\",\n      \"Press M to toggle audio.\"\n    ];\n    let maxW = 0;\n    for (const l of lines) {\n      const m = ctx.measureText(l).width;\n      if (m > maxW) maxW = m;\n    }\n    const w = maxW + 24;\n    const h = lines.length * 20 + 20;\n    const x = (WIDTH - w) / 2;\n    const y = HEIGHT - h - PADDING;\n    ctx.fillStyle = \"rgba(255,255,255,0.9)\";\n    roundRectFill(x, y, w, h, 10);\n    ctx.fillStyle = \"#073146\";\n    for (let i = 0; i < lines.length; i++) {\n      ctx.fillText(lines[i], x + 12, y + 18 + i * 20);\n    }\n\n    // Draw UI elements on top\n    drawUI();\n  }\n\n  // Kick off initial screen\n  initialDraw();\n\n  // Set focus to canvas for keyboard\n  canvas.focus();\n\n  // Accessibility: inform if audio unavailable\n  if (!audioContext) {\n    canvas.setAttribute(\"aria-label\", \"Audio unavailable in this browser. Use M to toggle (disabled).\");\n  }\n\n  // Protect against page unload without stopping audio etc.\n  window.addEventListener(\"blur\", () => {\n    // pause active state\n    // nothing heavy to do; audio oscillators are short-lived\n  });\n})();\n---\n",
  "improve_response_tokens": 18810,
  "formatted_code": true,
  "formatting_response_tokens": 21343,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}