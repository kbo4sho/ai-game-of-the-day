# Game of the Day - 2025-11-04

## Metadata
- **Generated Date:** 2025-11-04
- **Generated Time:** 2025-11-04T00:27:55.424060
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-11-04.js
- **File Size:** 26231 bytes
- **Tokens Used:** 9771

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-11-04.js` - The playable game
- `2025-11-04.meta.json` - Machine-readable metadata
- `2025-11-04.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 18414

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 20211

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function() {
  // Educational Drone Math Game
  // Renders into #game-of-the-day-stage using a canvas sized 720x480
  // Math target: answer 10 questions correctly to win. 3 wrong answers = game over.
  // Controls: Arrow keys to move drone, Space to pick up nearest package,
  // Number keys 1-4 to choose an on-screen package, Mouse click to select,
  // S to toggle sound (requires enabling audio), R to restart.
  // Accessible: canvas has role and aria-live updates for current question.
  // All visuals are canvas-drawn. Sounds generated with Web Audio API oscillators.

  // Strict mode
  'use strict';

  // Config
  const WIDTH = 720;
  const HEIGHT = 480;
  const PADDING = 10;
  const GOAL_SCORE = 10;
  const MAX_LIVES = 3;
  const PACKAGE_COUNT = 4;
  const MIN_BODY_FONT = 16; // px
  const IMPORTANT_FONT = 20; // px
  const UI_BG_COLOR = 'rgba(255,255,255,0.85)';
  const UI_TEXT_COLOR = '#083d77';
  const DRONE_COLOR = '#2a9d8f';
  const DRONE_SIZE = 36;
  const PACKAGE_RADIUS = 26;
  const CLOUD_COUNT = 6;

  // DOM setup
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('No element with id "game-of-the-day-stage" found.');
    return;
  }
  container.innerHTML = ''; // clear
  container.style.position = 'relative';
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute('role', 'img');
  canvas.setAttribute('aria-label', 'Drone Math Game. Use arrow keys to fly and space to pick packages. Press S to enable sound.');
  canvas.tabIndex = 0; // make focusable for keyboard controls
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Accessibility live region for question results
  const live = document.createElement('div');
  live.setAttribute('aria-live', 'polite');
  live.style.position = 'absolute';
  live.style.left = '-9999px';
  container.appendChild(live);

  // Audio setup with robust error handling
  let audioCtx = null;
  let globalGain = null;
  let ambientNodes = [];
  let audioEnabled = false;
  function tryCreateAudio() {
    if (audioCtx) return;
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AC();
      globalGain = audioCtx.createGain();
      globalGain.gain.value = 0.0; // start muted until enabled
      globalGain.connect(audioCtx.destination);
      audioEnabled = false;
      startAmbient(); // create ambient nodes but keep muted
    } catch (e) {
      console.warn('AudioContext creation failed:', e);
      audioCtx = null;
      globalGain = null;
      audioEnabled = false;
    }
  }

  // Ambient gentle hum (soft drone hum)
  function startAmbient() {
    if (!audioCtx || !globalGain) return;
    try {
      // Create a couple of very low-volume oscillators for texture
      stopAmbient();
      for (let i = 0; i < 2; i++) {
        const osc = audioCtx.createOscillator();
        osc.type = i === 0 ? 'sine' : 'triangle';
        osc.frequency.value = i === 0 ? 80 : 120;
        const gain = audioCtx.createGain();
        gain.gain.value = 0.0015; // extremely gentle by default
        // LFO for slight movement
        const lfo = audioCtx.createOscillator();
        lfo.frequency.value = 0.05 + i * 0.04;
        const lfoGain = audioCtx.createGain();
        lfoGain.gain.value = i === 0 ? 20 : 30;
        lfo.connect(lfoGain);
        lfoGain.connect(osc.frequency);
        osc.connect(gain);
        gain.connect(globalGain);
        osc.start();
        lfo.start();
        ambientNodes.push({osc, gain, lfo, lfoGain});
      }
    } catch (e) {
      console.warn('Failed to start ambient audio:', e);
    }
  }

  function stopAmbient() {
    try {
      ambientNodes.forEach(n => {
        try {
          n.osc.stop();
        } catch(e){}
        try {
          n.lfo.stop();
        } catch(e){}
      });
    } catch (e) {
      // ignore
    }
    ambientNodes = [];
  }

  function setAudioEnabled(enabled) {
    try {
      if (!audioCtx) tryCreateAudio();
      if (!audioCtx) return;
      audioEnabled = !!enabled;
      audioCtx.resume().catch(()=>{}); // in case suspended
      globalGain.gain.setTargetAtTime(enabled ? 0.06 : 0.0, audioCtx.currentTime, 0.02);
    } catch (e) {
      console.warn('Error toggling audio:', e);
      audioEnabled = false;
    }
  }

  // Sound effects: correct / wrong uses short oscillators and filters
  function playCorrect() {
    if (!audioCtx || !globalGain || !audioEnabled) return;
    try {
      const o1 = audioCtx.createOscillator();
      o1.type = 'sine';
      const g1 = audioCtx.createGain();
      g1.gain.value = 0.0;
      o1.frequency.value = 880;
      // simple envelope
      o1.connect(g1);
      g1.connect(globalGain);
      const now = audioCtx.currentTime;
      g1.gain.setValueAtTime(0.0001, now);
      g1.gain.exponentialRampToValueAtTime(0.09, now + 0.02);
      g1.gain.exponentialRampToValueAtTime(0.0001, now + 0.28);
      o1.frequency.setValueAtTime(880, now);
      o1.frequency.exponentialRampToValueAtTime(1320, now + 0.18);
      o1.start(now);
      o1.stop(now + 0.3);
    } catch (e) {
      console.warn('playCorrect failed', e);
    }
  }

  function playWrong() {
    if (!audioCtx || !globalGain || !audioEnabled) return;
    try {
      const o = audioCtx.createOscillator();
      o.type = 'sawtooth';
      const g = audioCtx.createGain();
      g.gain.value = 0.0;
      const bi = audioCtx.createBiquadFilter();
      bi.type = 'lowpass';
      bi.frequency.value = 1200;
      o.connect(bi);
      bi.connect(g);
      g.connect(globalGain);
      const now = audioCtx.currentTime;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.08, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);
      o.frequency.setValueAtTime(220, now);
      o.frequency.exponentialRampToValueAtTime(110, now + 0.22);
      o.start(now);
      o.stop(now + 0.3);
    } catch (e) {
      console.warn('playWrong failed', e);
    }
  }

  // Simple utility helpers
  function randRange(a, b) {
    return Math.floor(Math.random() * (b - a + 1)) + a;
  }
  function clamp(v, a, b) {
    return Math.max(a, Math.min(b, v));
  }
  function distance(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    return Math.sqrt(dx * dx + dy * dy);
  }

  // Game state
  let score = 0;
  let lives = MAX_LIVES;
  let packages = [];
  let drone = {x: WIDTH / 2, y: HEIGHT / 2, vx: 0, vy: 0, size: DRONE_SIZE};
  let keys = {};
  let question = null;
  let gameState = 'playing'; // playing, victory, gameover, attract (initial)
  let lastTime = performance.now();
  let flashTimer = 0;
  let audioAvailable = true;
  let clouds = [];

  // Initialize clouds for background
  function initClouds() {
    clouds = [];
    for (let i = 0; i < CLOUD_COUNT; i++) {
      clouds.push({
        x: Math.random() * WIDTH,
        y: Math.random() * (HEIGHT * 0.45),
        size: 40 + Math.random() * 90,
        vx: 0.2 + Math.random() * 0.6,
        wobble: Math.random() * 1000
      });
    }
  }

  // Math question generation (age 7-9)
  function generateQuestion() {
    // Use addition and subtraction mainly, occasional multiplication
    const ops = ['+','-','*'];
    let op = Math.random() < 0.7 ? (Math.random() < 0.6 ? '+' : '-') : '*';
    // ensure multiplication less frequent
    if (op === '*') {
      const a = randRange(2,8);
      const b = randRange(2,8);
      const ans = a * b;
      return {a,b,op,answer:ans};
    } else if (op === '+') {
      const a = randRange(1, 20);
      const b = randRange(1, 20);
      return {a,b,op,answer: a + b};
    } else {
      // subtraction ensure positive results
      let a = randRange(1, 20);
      let b = randRange(1, a);
      return {a,b,op:'-',answer: a - b};
    }
  }

  // Generate options including correct answer
  function generateOptions(correct) {
    const opts = new Set();
    opts.add(correct);
    while (opts.size < PACKAGE_COUNT) {
      // create plausible wrong answers
      const delta = randRange(1, 6);
      const sign = Math.random() < 0.5 ? -1 : 1;
      let val = correct + sign * delta;
      // ensure non-negative and not equal
      if (val < 0) val = Math.abs(val) + 1;
      opts.add(val);
    }
    // Shuffle
    const arr = Array.from(opts);
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  // Spawn packages in non-overlapping positions and away from UI
  function spawnPackages() {
    packages = [];
    const opts = generateOptions(question.answer);
    const attemptsLimit = 200;
    for (let i = 0; i < opts.length; i++) {
      let placed = false;
      let attempts = 0;
      while (!placed && attempts < attemptsLimit) {
        attempts++;
        const marginTop = 80; // avoid top UI
        const x = PACKAGE_RADIUS + Math.random() * (WIDTH - PACKAGE_RADIUS * 2);
        const y = marginTop + PACKAGE_RADIUS + Math.random() * (HEIGHT - marginTop - PACKAGE_RADIUS - 80);
        const candidate = {x,y,r:PACKAGE_RADIUS,number:opts[i],vx: (Math.random()*0.8-0.4), vy: 0, wobble: Math.random()*2000, id: i};
        // Check not overlapping with other packages
        let ok = true;
        for (const p of packages) {
          if (distance(candidate, p) < candidate.r + p.r + 8) { ok = false; break; }
        }
        // Avoid center top UI area (for question) - allow safe zone
        if (y < marginTop + 10) ok = false;
        if (ok) {
          packages.push(candidate);
          placed = true;
        }
      }
      if (!placed) {
        // fallback: place in grid
        packages.push({x: 80 + i * 140, y: 160, r: PACKAGE_RADIUS, number: opts[i], vx:0, vy:0, wobble: i*100, id:i});
      }
    }
  }

  // Reset game
  function resetGame() {
    score = 0;
    lives = MAX_LIVES;
    drone.x = WIDTH / 2;
    drone.y = HEIGHT - 100;
    keys = {};
    question = generateQuestion();
    spawnPackages();
    gameState = 'playing';
    flashTimer = 0;
    lastTime = performance.now();
    live.textContent = `New question: ${question.a} ${question.op} ${question.b} = ?`;
  }

  // Initialize
  tryCreateAudio();
  initClouds();
  question = generateQuestion();
  spawnPackages();

  // Input handling
  canvas.addEventListener('keydown', (e) => {
    const key = e.key;
    keys[key] = true;
    // Allow enabling audio with 'S'
    if (key === 's' || key === 'S') {
      tryCreateAudio();
      setAudioEnabled(!audioEnabled);
    }
    if ((key === 'r' || key === 'R') && (gameState === 'victory' || gameState === 'gameover')) {
      resetGame();
      audioCtx && audioCtx.resume().catch(()=>{});
    }
    // Number keys choose package
    if (['1','2','3','4'].includes(key) && gameState === 'playing') {
      const idx = parseInt(key,10) - 1;
      if (packages[idx]) {
        handleSelection(packages[idx]);
      }
    }
    if (key === ' ' && gameState === 'playing') {
      // pick nearest package
      let nearest = null; let minD = Infinity;
      for (const p of packages) {
        const d = distance(p, drone);
        if (d < minD) { minD = d; nearest = p; }
      }
      if (nearest && minD <= 80) {
        handleSelection(nearest);
      }
    }
  });

  canvas.addEventListener('keyup', (e) => {
    delete keys[e.key];
  });

  // Mouse controls
  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    const my = (e.clientY - rect.top) * (canvas.height / rect.height);
    if (gameState === 'playing') {
      // Check package clicked
      for (let i = 0; i < packages.length; i++) {
        const p = packages[i];
        if (Math.hypot(p.x - mx, p.y - my) <= p.r + 4) {
          handleSelection(p);
          return;
        }
      }
      // Check audio toggle button area (drawn bottom-left)
      const audRect = getAudioButtonRect();
      if (mx >= audRect.x && mx <= audRect.x + audRect.w && my >= audRect.y && my <= audRect.y + audRect.h) {
        tryCreateAudio();
        setAudioEnabled(!audioEnabled);
        return;
      }
    } else {
      // On end screens, check for restart button
      const btn = getRestartButtonRect();
      if (mx >= btn.x && mx <= btn.x + btn.w && my >= btn.y && my <= btn.y + btn.h) {
        resetGame();
        return;
      }
    }
  });

  // Touch support (tap)
  canvas.addEventListener('touchstart', (e) => {
    const touch = e.touches[0];
    if (!touch) return;
    const rect = canvas.getBoundingClientRect();
    const tx = (touch.clientX - rect.left) * (canvas.width / rect.width);
    const ty = (touch.clientY - rect.top) * (canvas.height / rect.height);
    // emulate click
    const clickEvent = new MouseEvent('click', {
      clientX: touch.clientX,
      clientY: touch.clientY
    });
    canvas.dispatchEvent(clickEvent);
    e.preventDefault();
  }, {passive:false});

  // UI geometry helpers
  function drawUITextBox(text, x, y, font='16px sans-serif', padding=PADDING, align='left', bg=UI_BG_COLOR, fg=UI_TEXT_COLOR) {
    ctx.save();
    ctx.font = font;
    ctx.textBaseline = 'top';
    const metrics = ctx.measureText(text);
    const w = metrics.width;
    const h = parseInt(font,10) + 6;
    let drawX = x;
    if (align === 'center') drawX = x - w / 2 - padding;
    if (align === 'right') drawX = x - w - padding * 2;
    const rectX = drawX - padding;
    const rectY = y - padding;
    const rectW = w + padding * 2;
    const rectH = h + padding * 2;
    // background
    ctx.fillStyle = bg;
    roundRect(ctx, rectX, rectY, rectW, rectH, 8);
    ctx.fill();
    // text
    ctx.fillStyle = fg;
    ctx.fillText(text, rectX + padding, rectY + padding + 2);
    ctx.restore();
    return {x:rectX, y:rectY, w:rectW, h:rectH};
  }

  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  // Draw drone (simple whimsical shape)
  function drawDrone(x, y, size, t) {
    ctx.save();
    ctx.translate(x, y);
    // body
    ctx.fillStyle = DRONE_COLOR;
    ctx.beginPath();
    ctx.ellipse(0, 0, size * 0.9, size * 0.6, Math.sin(t/200)*0.08, 0, Math.PI*2);
    ctx.fill();

    // cockpit
    ctx.fillStyle = '#e9f5db';
    ctx.beginPath();
    ctx.ellipse(-size*0.15, -size*0.05, size*0.35, size*0.25, 0, 0, Math.PI*2);
    ctx.fill();

    // propellers (wacky arms)
    for (let i = -1; i <= 1; i+=2) {
      ctx.save();
      ctx.translate(i * size * 0.8, -size*0.15);
      ctx.rotate(Math.sin(t/120 + i)*0.8);
      ctx.fillStyle = '#c7f9cc';
      ctx.fillRect(-size*0.3, -4, size*0.6, 8);
      ctx.restore();
    }

    // cargo hook
    ctx.fillStyle = '#6c757d';
    ctx.fillRect(-6, size*0.42, 12, 12);
    ctx.restore();
  }

  // Draw cloud
  function drawCloud(c, t) {
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    const wob = Math.sin((t + c.wobble) / 600) * 6;
    ctx.ellipse(c.x, c.y + wob, c.size * 0.6, c.size * 0.36, 0, 0, Math.PI*2);
    ctx.ellipse(c.x - c.size*0.28, c.y + 6 + wob, c.size*0.5, c.size*0.28, 0, 0, Math.PI*2);
    ctx.ellipse(c.x + c.size*0.28, c.y + 8 + wob, c.size*0.5, c.size*0.28, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // Handle selecting a package (by click or keyboard)
  function handleSelection(pkg) {
    if (gameState !== 'playing') return;
    if (!pkg) return;
    if (pkg.number === question.answer) {
      score++;
      flashTimer = 16;
      playCorrect();
      live.textContent = `Correct! ${question.a} ${question.op} ${question.b} = ${question.answer}. Score ${score}/${GOAL_SCORE}.`;
      // generate new question
      if (score >= GOAL_SCORE) {
        gameState = 'victory';
        live.textContent = `Victory! You delivered ${GOAL_SCORE} correct packages. Press R to restart.`;
        return;
      } else {
        question = generateQuestion();
        spawnPackages();
      }
    } else {
      lives--;
      playWrong();
      flashTimer = 26;
      live.textContent = `Oops! ${pkg.number} is not ${question.a} ${question.op} ${question.b}. Lives left: ${lives}.`;
      if (lives <= 0) {
        gameState = 'gameover';
        live.textContent = `Game over. You had ${score} correct answers. Press R to restart.`;
      }
    }
  }

  // Get audio button rect for click detection (bottom-left)
  function getAudioButtonRect() {
    const font = `${MIN_BODY_FONT}px sans-serif`;
    ctx.font = font;
    const text = audioEnabled ? 'Sound: On (S)' : 'Sound: Off (S)';
    const metrics = ctx.measureText(text);
    const w = metrics.width + PADDING * 2;
    const h = MIN_BODY_FONT + PADDING * 2 + 6;
    const x = PADDING;
    const y = HEIGHT - h - PADDING;
    return {x,y,w,h, text};
  }

  // Get restart button rect center
  function getRestartButtonRect() {
    const font = `${IMPORTANT_FONT}px sans-serif`;
    ctx.font = font;
    const text = 'Restart (R)';
    const metrics = ctx.measureText(text);
    const w = metrics.width + PADDING * 2;
    const h = IMPORTANT_FONT + PADDING * 2 + 6;
    const x = (WIDTH - w) / 2;
    const y = HEIGHT / 2 + 70;
    return {x,y,w,h, text};
  }

  // Main loop
  function loop(now) {
    const dt = Math.min(60, now - lastTime);
    lastTime = now;
    update(dt);
    draw(now);
    requestAnimationFrame(loop);
  }

  // Update logic
  function update(dt) {
    // Clouds drift
    for (const c of clouds) {
      c.x += c.vx * (dt / 16);
      if (c.x - c.size > WIDTH) c.x = -c.size;
    }

    if (gameState !== 'playing') return;

    // Drone movement
    const speed = 0.22 * dt;
    if (keys['ArrowLeft'] || keys['Left']) drone.x -= speed;
    if (keys['ArrowRight'] || keys['Right']) drone.x += speed;
    if (keys['ArrowUp'] || keys['Up']) drone.y -= speed;
    if (keys['ArrowDown'] || keys['Down']) drone.y += speed;
    // Keep within bounds
    drone.x = clamp(drone.x, DRONE_SIZE * 0.6, WIDTH - DRONE_SIZE * 0.6);
    drone.y = clamp(drone.y, DRONE_SIZE * 0.5, HEIGHT - DRONE_SIZE * 0.5 - 60);

    // Packages drift slightly and bob
    for (const p of packages) {
      p.wobble = (p.wobble + dt) % 100000;
      p.x += Math.sin(p.wobble / 800) * 0.25;
      p.y += Math.sin(p.wobble / 700) * 0.15;
      // keep in bounds
      p.x = clamp(p.x, p.r + 8, WIDTH - p.r - 8);
      p.y = clamp(p.y, 90 + p.r, HEIGHT - p.r - 80);
    }

    if (flashTimer > 0) flashTimer--;
  }

  // Draw everything
  function draw(t) {
    // Clear
    ctx.clearRect(0,0,WIDTH,HEIGHT);

    // Background sky gradient
    const grad = ctx.createLinearGradient(0,0,0,HEIGHT);
    grad.addColorStop(0, '#cceefc');
    grad.addColorStop(1, '#f3f8ff');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,WIDTH,HEIGHT);

    // Clouds
    for (const c of clouds) drawCloud(c, t);

    // Calm wacky ground / landscape
    ctx.save();
    ctx.fillStyle = '#e8f6ee';
    ctx.beginPath();
    ctx.moveTo(0, HEIGHT * 0.78);
    for (let x = 0; x <= WIDTH; x += 20) {
      const y = HEIGHT*0.78 + Math.sin((x + t/8) / 60) * 8;
      ctx.lineTo(x, y);
    }
    ctx.lineTo(WIDTH, HEIGHT);
    ctx.lineTo(0, HEIGHT);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // Draw packages
    for (let i = 0; i < packages.length; i++) {
      const p = packages[i];
      const bob = Math.sin((t + p.wobble) / 220) * 6;
      // shadow
      ctx.save();
      ctx.globalAlpha = 0.2;
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.ellipse(p.x + 6, p.y + p.r + 8, p.r * 0.9, p.r * 0.25, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      // package body
      ctx.save();
      ctx.translate(p.x, p.y + bob);
      ctx.fillStyle = '#ffd166';
      ctx.strokeStyle = '#8b5e34';
      ctx.lineWidth = 2;
      roundRect(ctx, -p.r, -p.r, p.r*2, p.r*2, 8);
      ctx.fill();
      ctx.stroke();

      // number label
      ctx.fillStyle = '#083d77';
      ctx.font = `${IMPORTANT_FONT}px sans-serif`;
      ctx.textBaseline = 'middle';
      ctx.textAlign = 'center';
      ctx.fillText(String(p.number), 0, 0);
      ctx.restore();

      // small index
      ctx.save();
      ctx.fillStyle = 'rgba(8,61,119,0.08)';
      ctx.font = `${MIN_BODY_FONT}px sans-serif`;
      ctx.fillText(`${i+1}`, p.x + p.r - 8, p.y - p.r + 6);
      ctx.restore();
    }

    // Draw drone with gentle bob
    drawDrone(drone.x, drone.y + Math.sin(t/200)*4, drone.size, t);

    // UI: Score top-left
    ctx.save();
    const scoreText = `Score: ${score}/${GOAL_SCORE}`;
    ctx.font = `${IMPORTANT_FONT}px sans-serif`;
    const scoreRect = drawUITextBox(scoreText, PADDING, PADDING, `${IMPORTANT_FONT}px sans-serif`, PADDING, 'left');
    ctx.restore();

    // Lives top-right
    ctx.save();
    const livesText = `Lives: ${lives}`;
    ctx.font = `${IMPORTANT_FONT}px sans-serif`;
    const livesMetrics = ctx.measureText(livesText);
    const livesRect = drawUITextBox(livesText, WIDTH - PADDING - livesMetrics.width - PADDING, PADDING, `${IMPORTANT_FONT}px sans-serif`, PADDING, 'left', UI_BG_COLOR, UI_TEXT_COLOR);
    ctx.restore();

    // Question top-center (ensure non-overlap)
    ctx.save();
    const qText = `Solve: ${question.a} ${question.op} ${question.b} = ?`;
    ctx.font = `${IMPORTANT_FONT+2}px sans-serif`;
    const qMetrics = ctx.measureText(qText);
    let qx = WIDTH / 2; // center position
    let qy = PADDING;
    // Compute rectangles for left and right boxes
    const leftBoxRight = scoreRect.x + scoreRect.w;
    const rightBoxLeft = livesRect.x;
    const qLeft = qx - qMetrics.width / 2 - PADDING;
    const qRight = qx + qMetrics.width / 2 + PADDING;
    // If overlap with left or right, move question down below top UI by padding
    if (qLeft < leftBoxRight + 10 || qRight > rightBoxLeft - 10) {
      qy = scoreRect.y + scoreRect.h + 12;
    }
    drawUITextBox(qText, qx, qy, `${IMPORTANT_FONT+2}px sans-serif`, PADDING, 'center', UI_BG_COLOR, UI_TEXT_COLOR);
    ctx.restore();

    // Instructions bottom-center (multi-line)
    ctx.save();
    ctx.font = `${MIN_BODY_FONT}px sans-serif`;
    const instrLines = [
      'Controls: Arrows to fly • Space to pick nearest • 1-4 keys to pick packages • Click to pick • S to toggle sound',
      'Goal: Answer 10 correctly. Wrong answers: lose 1 life. Lose all lives = Game Over. Press R to restart.'
    ];
    // Draw a multi-line centered box
    const lineHeights = instrLines.map(l => MIN_BODY_FONT + 6);
    const maxWidth = Math.max(...instrLines.map(l => ctx.measureText(l).width));
    const boxW = maxWidth + PADDING * 2;
    const boxH = lineHeights.reduce((a,b)=>a+b,0) + PADDING*2;
    const boxX = (WIDTH - boxW) / 2;
    const boxY = HEIGHT - boxH - PADDING;
    ctx.fillStyle = UI_BG_COLOR;
    roundRect(ctx, boxX, boxY, boxW, boxH, 10);
    ctx.fill();
    ctx.fillStyle = UI_TEXT_COLOR;
    ctx.textBaseline = 'top';
    let ly = boxY + PADDING;
    for (const line of instrLines) {
      ctx.fillText(line, boxX + PADDING, ly);
      ly += MIN_BODY_FONT + 6;
    }
    ctx.restore();

    // Audio button bottom-left
    const aud = getAudioButtonRect();
    ctx.save();
    ctx.fillStyle = UI_BG_COLOR;
    roundRect(ctx, aud.x, aud.y, aud.w, aud.h, 8);
    ctx.fill();
    ctx.fillStyle = UI_TEXT_COLOR;
    ctx.font = `${MIN_BODY_FONT}px sans-serif`;
    ctx.fillText(aud.text, aud.x + PADDING, aud.y + PADDING + 2);
    // Visual cue for audio on/off: simple icon
    ctx.beginPath();
    ctx.fillStyle = audioEnabled ? '#2a9d8f' : '#b6b6b6';
    ctx.moveTo(aud.x + aud.w - 26, aud.y + 12);
    ctx.lineTo(aud.x + aud.w - 14, aud.y + 12);
    ctx.lineTo(aud.x + aud.w - 6, aud.y + aud.h - 12);
    ctx.lineTo(aud.x + aud.w - 30, aud.y + aud.h - 12);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // Visual feedback when flashTimer active (correct/wrong)
    if (flashTimer > 0) {
      ctx.save();
      const alpha = Math.min(0.7, flashTimer / 30);
      // color depends on last action: if lives decreased recently (we can't easily check), alternate color by even/odd
      const color = (flashTimer % 2 === 0) ? 'rgba(42,157,143,'+alpha+')' : 'rgba(239,68,68,'+alpha+')';
      ctx.fillStyle = color;
      ctx.fillRect(0,0,WIDTH,HEIGHT);
      ctx.restore();
    }

    // If victory or gameover, draw overlay screens
    if (gameState === 'victory' || gameState === 'gameover') {
      ctx.save();
      ctx.fillStyle = 'rgba(3,61,119,0.75)';
      ctx.fillRect(0,0,WIDTH,HEIGHT);
      // Message box
      const title = gameState === 'victory' ? 'YOU WON!' : 'GAME OVER';
      const message = gameState === 'victory' ? `You delivered ${GOAL_SCORE} correct packages!` : `You answered ${score} correctly.`;
      ctx.fillStyle = '#ffffff';
      ctx.font = `${IMPORTANT_FONT + 12}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(title, WIDTH/2, HEIGHT/2 - 40);
      ctx.font = `${IMPORTANT_FONT}px sans-serif`;
      ctx.fillText(message, WIDTH/2, HEIGHT/2 + 0);
      // Restart button
      const btn = getRestartButtonRect();
      ctx.fillStyle = '#ffd166';
      roundRect(ctx, btn.x, btn.y, btn.w, btn.h, 8);
      ctx.fill();
      ctx.fillStyle = '#083d77';
      ctx.font = `${IMPORTANT_FONT}px sans-serif`;
      ctx.fillText(btn.text, WIDTH/2, btn.y + btn.h/2);
      ctx.restore();
    }
  }

  // Start animation
  requestAnimationFrame(loop);

  // Ensure canvas gets focus to receive keyboard events
  canvas.addEventListener('focus', () => {
    // nothing special
  });
  setTimeout(() => {
    try { canvas.focus(); } catch(e){/* ignore */ }
  }, 200);

  // Expose restart for console (optional)
  window.__droneMathGame = {
    reset: resetGame,
    toggleSound: () => setAudioEnabled(!audioEnabled)
  };

  // Initial message to live region
  live.textContent = `Welcome! Answer ${GOAL_SCORE} questions correctly to win. Use the controls shown. Press S to enable sound.`;

})();
---

