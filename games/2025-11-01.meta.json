{
  "generated_date": "2025-11-01",
  "generated_timestamp": "2025-11-01T00:29:56.054439",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9424,
  "game_filename": "2025-11-01.js",
  "game_size_bytes": 27566,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function() {\n  \"use strict\";\n\n  // Game constants\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const GOAL_CORRECT = 10; // win condition\n  const MAX_WRONG = 3; // lose condition\n  const DRONE_RADIUS = 28;\n  const ANSWER_RADIUS = 26;\n  const UI_PADDING = 10;\n  const BODY_FONT = \"16px sans-serif\";\n  const LARGE_FONT = \"22px sans-serif\";\n  const TITLE_FONT = \"28px sans-serif\";\n  const TICK = 1000 / 60; // approx 60fps\n\n  // Find container\n  const container = document.getElementById(\"game-of-the-day-stage\");\n  if (!container) {\n    console.error(\"No element with id 'game-of-the-day-stage' found.\");\n    return;\n  }\n\n  // Clear container and set up canvas\n  container.innerHTML = \"\";\n  container.style.position = \"relative\";\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute(\"role\", \"application\");\n  canvas.setAttribute(\"aria-label\", \"Drone Math Collector game\");\n  canvas.style.background = \"#eaf6ff\";\n  container.appendChild(canvas);\n  const ctx = canvas.getContext(\"2d\");\n\n  // Audio setup with proper error handling\n  let audioEnabled = true;\n  let audioContext = null;\n  let backgroundOsc = null;\n  try {\n    const AudioContext = window.AudioContext || window.webkitAudioContext;\n    if (AudioContext) {\n      audioContext = new AudioContext();\n      // Create gentle background hum (low-volume)\n      backgroundOsc = audioContext.createOscillator();\n      const bgGain = audioContext.createGain();\n      backgroundOsc.type = \"sine\";\n      backgroundOsc.frequency.value = 110; // low hum\n      bgGain.gain.value = 0.0008; // very quiet\n      backgroundOsc.connect(bgGain);\n      bgGain.connect(audioContext.destination);\n      backgroundOsc.start(0);\n    } else {\n      audioEnabled = false;\n      console.warn(\"Web Audio API not supported in this browser.\");\n    }\n  } catch (e) {\n    audioEnabled = false;\n    console.warn(\"Unable to initialize AudioContext:\", e);\n  }\n\n  // Sound play functions with safety checks\n  function playCorrectSound() {\n    if (!audioEnabled || !audioContext) return;\n    try {\n      const t = audioContext.currentTime;\n      const gain = audioContext.createGain();\n      gain.gain.setValueAtTime(0.0001, t);\n      gain.gain.exponentialRampToValueAtTime(0.08, t + 0.01);\n      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.6);\n      gain.connect(audioContext.destination);\n      const o1 = audioContext.createOscillator();\n      const o2 = audioContext.createOscillator();\n      o1.type = \"sine\";\n      o2.type = \"triangle\";\n      o1.frequency.value = 880;\n      o2.frequency.value = 1320;\n      o1.connect(gain);\n      o2.connect(gain);\n      o1.start(t);\n      o2.start(t);\n      o1.stop(t + 0.6);\n      o2.stop(t + 0.6);\n    } catch (e) {\n      console.warn(\"Error playing correct sound:\", e);\n    }\n  }\n\n  function playWrongSound() {\n    if (!audioEnabled || !audioContext) return;\n    try {\n      const t = audioContext.currentTime;\n      const g = audioContext.createGain();\n      g.gain.setValueAtTime(0.0001, t);\n      g.gain.exponentialRampToValueAtTime(0.09, t + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.4);\n      g.connect(audioContext.destination);\n      const o = audioContext.createOscillator();\n      o.type = \"square\";\n      o.frequency.setValueAtTime(220, t);\n      o.frequency.exponentialRampToValueAtTime(80, t + 0.4);\n      o.connect(g);\n      o.start(t);\n      o.stop(t + 0.4);\n    } catch (e) {\n      console.warn(\"Error playing wrong sound:\", e);\n    }\n  }\n\n  // Local state\n  let keys = {};\n  let mouse = { x: 0, y: 0 };\n  let gameState = \"menu\"; // menu, playing, win, gameover\n  let score = 0;\n  let wrong = 0;\n  let currentQuestion = null;\n  let answers = [];\n  let tickCount = 0;\n  let drone = { x: WIDTH / 2, y: HEIGHT / 2, vx: 0, vy: 0, angle: 0 };\n  let lastTime = performance.now();\n  let soundPulse = 0;\n\n  // Ensure accessible instructions visible as text (drawn on canvas),\n  // but also set an offscreen aria-live for screen readers:\n  const ariaLive = document.createElement(\"div\");\n  ariaLive.setAttribute(\"aria-live\", \"polite\");\n  ariaLive.style.position = \"absolute\";\n  ariaLive.style.left = \"-9999px\";\n  container.appendChild(ariaLive);\n\n  function announce(text) {\n    ariaLive.textContent = text;\n  }\n\n  // Helper: clamp\n  function clamp(v, a, b) {\n    return Math.max(a, Math.min(b, v));\n  }\n\n  // Create a math question for ages 7-9 (simple addition/subtraction, maybe small multiplication)\n  function generateQuestion(difficulty = 1) {\n    // difficulty increases as score increases\n    const typeRoll = Math.random();\n    let a, b, correct, text;\n    if (typeRoll < 0.6) {\n      // addition/subtraction within small ranges\n      a = Math.floor(Math.random() * (5 + difficulty * 2)) + 1;\n      b = Math.floor(Math.random() * (5 + difficulty * 2)) + 1;\n      if (Math.random() < 0.5) {\n        correct = a + b;\n        text = `${a} + ${b} = ?`;\n      } else {\n        // ensure non-negative\n        if (a < b) [a, b] = [b, a];\n        correct = a - b;\n        text = `${a} - ${b} = ?`;\n      }\n    } else {\n      // simple multiplication small\n      a = Math.floor(Math.random() * (2 + difficulty)) + 1;\n      b = Math.floor(Math.random() * (2 + difficulty)) + 1;\n      correct = a * b;\n      text = `${a} \u00d7 ${b} = ?`;\n    }\n    return { text, correct };\n  }\n\n  // Create answer items: circles that the player collects by touching\n  function spawnAnswers(question) {\n    answers = [];\n    const correct = question.correct;\n    // generate two distractors reasonably close but not equal\n    const distractors = new Set();\n    while (distractors.size < 2) {\n      const offset = (Math.random() < 0.5 ? -1 : 1) * (Math.floor(Math.random() * 4) + 1);\n      let val = correct + offset;\n      if (val < 0) val = Math.abs(val) + 1;\n      if (val !== correct) distractors.add(val);\n    }\n    const options = [correct, ...Array.from(distractors)];\n    // scramble\n    options.sort(() => Math.random() - 0.5);\n\n    // Spawn in three different non-overlapping zones (left, center, right)\n    const zones = [\n      { x: WIDTH * 0.2, y: HEIGHT * 0.35 },\n      { x: WIDTH * 0.5, y: HEIGHT * 0.3 },\n      { x: WIDTH * 0.8, y: HEIGHT * 0.4 }\n    ];\n    for (let i = 0; i < options.length; i++) {\n      const startX = zones[i].x + (Math.random() * 80 - 40);\n      const startY = zones[i].y + (Math.random() * 80 - 40);\n      answers.push({\n        id: i,\n        value: options[i],\n        x: clamp(startX, ANSWER_RADIUS + 40, WIDTH - ANSWER_RADIUS - 40),\n        y: clamp(startY, 100 + ANSWER_RADIUS, HEIGHT - 120 - ANSWER_RADIUS),\n        vx: (Math.random() - 0.5) * (0.6 + score * 0.06),\n        vy: (Math.random() - 0.5) * (0.4 + score * 0.04),\n        wobble: Math.random() * Math.PI * 2\n      });\n    }\n  }\n\n  // Start a fresh game\n  function startGame() {\n    score = 0;\n    wrong = 0;\n    tickCount = 0;\n    drone.x = WIDTH / 2;\n    drone.y = HEIGHT / 2;\n    drone.vx = 0;\n    drone.vy = 0;\n    gameState = \"playing\";\n    currentQuestion = generateQuestion(1);\n    spawnAnswers(currentQuestion);\n    announce(\"Game started. Use arrow keys or WASD to fly the drone and collect the correct answer.\");\n    // Ensure audio is resumed on user gesture if necessary\n    if (audioContext && audioContext.state === \"suspended\") {\n      audioContext.resume().catch((e) => {\n        console.warn(\"Audio resume failed:\", e);\n      });\n    }\n  }\n\n  // Reset to menu\n  function goToMenu() {\n    gameState = \"menu\";\n    announce(\"Menu. Press Enter or click Start to begin.\");\n  }\n\n  goToMenu();\n\n  // Input handlers\n  window.addEventListener(\"keydown\", (e) => {\n    // space or enter to start from menu\n    if (e.key === \"Enter\" || e.key === \" \" || e.key === \"Spacebar\") e.preventDefault();\n    keys[e.key.toLowerCase()] = true;\n\n    if (gameState === \"menu\" && (e.key === \"Enter\" || e.key.toLowerCase() === \" \")) {\n      startGame();\n    } else if ((gameState === \"win\" || gameState === \"gameover\") && (e.key === \"r\" || e.key === \"R\" || e.key === \"Enter\")) {\n      startGame();\n    }\n\n    // toggle sound with m\n    if (e.key.toLowerCase() === \"m\") {\n      audioEnabled = !audioEnabled;\n      if (!audioEnabled && audioContext) {\n        // mute by setting background gain to zero if available\n        try {\n          if (backgroundOsc) {\n            // can't directly set oscillator gain since we used created gain in closure and didn't store - but we can suspend context\n            audioContext.suspend().catch(() => {});\n          }\n        } catch (err) {\n          console.warn(err);\n        }\n      } else if (audioEnabled && audioContext && audioContext.state === \"suspended\") {\n        audioContext.resume().catch(() => {});\n      }\n      announce(`Sound ${audioEnabled ? \"on\" : \"off\"}`);\n    }\n  });\n\n  window.addEventListener(\"keyup\", (e) => {\n    keys[e.key.toLowerCase()] = false;\n  });\n\n  canvas.addEventListener(\"mousemove\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);\n    mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);\n  });\n\n  canvas.addEventListener(\"mousedown\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);\n    const my = (e.clientY - rect.top) * (canvas.height / rect.height);\n\n    // restart or menu click detection: check if click is inside button rectangles when showing end screens\n    if (gameState === \"menu\") {\n      // check start button area\n      const btn = getMenuStartButtonRect();\n      if (pointInRect(mx, my, btn)) {\n        startGame();\n      }\n    } else if (gameState === \"win\" || gameState === \"gameover\") {\n      const btn = getEndButtonRect();\n      if (pointInRect(mx, my, btn)) {\n        startGame();\n      }\n    } else if (gameState === \"playing\") {\n      // clicking the sound icon toggles sound\n      const sd = getSoundIconRect();\n      if (pointInRect(mx, my, sd)) {\n        audioEnabled = !audioEnabled;\n        if (!audioEnabled && audioContext) audioContext.suspend().catch(() => {});\n        else if (audioEnabled && audioContext) audioContext.resume().catch(() => {});\n        announce(`Sound ${audioEnabled ? \"on\" : \"off\"}`);\n      } else {\n        // else clicking will \"nudge\" drone toward click for accessibility\n        const dx = mx - drone.x;\n        const dy = my - drone.y;\n        const dist = Math.hypot(dx, dy) || 1;\n        drone.vx += (dx / dist) * 1.8;\n        drone.vy += (dy / dist) * 1.8;\n      }\n    }\n  });\n\n  function pointInRect(x, y, r) {\n    return x >= r.x && x <= r.x + r.w && y >= r.y && y <= r.y + r.h;\n  }\n\n  // UI layout helper rects\n  function getScoreRect(text) {\n    ctx.font = BODY_FONT;\n    const metrics = ctx.measureText(text);\n    const w = metrics.width + UI_PADDING * 2;\n    const h = 36;\n    return { x: UI_PADDING, y: UI_PADDING, w, h };\n  }\n\n  function getLivesRect(text) {\n    ctx.font = BODY_FONT;\n    const metrics = ctx.measureText(text);\n    const w = metrics.width + UI_PADDING * 2 + 24;\n    const h = 36;\n    return { x: WIDTH - w - UI_PADDING, y: UI_PADDING, w, h };\n  }\n\n  function getQuestionRect(text) {\n    ctx.font = LARGE_FONT;\n    const metrics = ctx.measureText(text);\n    const w = Math.min(metrics.width + UI_PADDING * 4, WIDTH - 200);\n    const h = 48;\n    return { x: (WIDTH - w) / 2, y: 10 + 36 + 8, w, h };\n  }\n\n  function getInstructionsRect(lines) {\n    ctx.font = BODY_FONT;\n    // multiple lines stacked bottom-center\n    const maxWidth = Math.max(...lines.map(l => ctx.measureText(l).width));\n    const w = maxWidth + UI_PADDING * 4;\n    const h = lines.length * 20 + UI_PADDING * 2;\n    return { x: (WIDTH - w) / 2, y: HEIGHT - h - 10, w, h };\n  }\n\n  function getMenuStartButtonRect() {\n    const w = 220;\n    const h = 56;\n    return { x: (WIDTH - w) / 2, y: HEIGHT / 2 - 20, w, h };\n  }\n\n  function getEndButtonRect() {\n    const w = 240;\n    const h = 56;\n    return { x: (WIDTH - w) / 2, y: HEIGHT / 2 + 40, w, h };\n  }\n\n  function getSoundIconRect() {\n    const w = 40;\n    const h = 36;\n    return { x: WIDTH - w - UI_PADDING - 80, y: UI_PADDING, w, h };\n  }\n\n  // Drawing helpers\n  function drawRoundedRect(ctx, x, y, w, h, r = 8) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  // Drawing the wacky drone\n  function drawDrone(ctx, d) {\n    // shadow\n    ctx.save();\n    ctx.translate(d.x, d.y);\n    ctx.rotate(d.angle);\n    ctx.shadowColor = \"rgba(0,0,0,0.12)\";\n    ctx.shadowBlur = 10;\n    // body\n    ctx.fillStyle = \"#fefefe\";\n    drawRoundedRect(ctx, -24, -18, 48, 36, 12);\n    ctx.fillStyle = \"#c6e7ff\";\n    ctx.fillRect(-24, -18, 48, 36);\n    // cockpit\n    ctx.beginPath();\n    ctx.ellipse(10, -2, 12, 10, Math.PI / 8, 0, Math.PI * 2);\n    ctx.fillStyle = \"#d4f3ff\";\n    ctx.fill();\n    // propellers\n    ctx.strokeStyle = \"#6a6a6a\";\n    ctx.lineWidth = 2;\n    for (let i = -1; i <= 1; i += 2) {\n      const px = i * 26;\n      const py = -14;\n      // bar\n      ctx.beginPath();\n      ctx.moveTo(px, py);\n      ctx.lineTo(px, py - 18);\n      ctx.stroke();\n      // rotor (wacky)\n      ctx.beginPath();\n      ctx.fillStyle = \"rgba(255,255,255,0.7)\";\n      ctx.arc(px, py - 24, 12 + Math.sin(tickCount / 8 + px) * 1.5, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    // smile\n    ctx.beginPath();\n    ctx.strokeStyle = \"#3b3b3b\";\n    ctx.lineWidth = 1.6;\n    ctx.arc(-6, 6, 8, 0, Math.PI);\n    ctx.stroke();\n\n    ctx.restore();\n    ctx.shadowBlur = 0;\n  }\n\n  // Drawing answer bubble\n  function drawAnswer(ctx, a, highlight = false) {\n    ctx.save();\n    // wobble animation\n    const wob = Math.sin(a.wobble + tickCount / 30) * 2;\n    a.wobble += 0.01;\n    ctx.translate(a.x, a.y + wob);\n    // outer ring\n    ctx.beginPath();\n    ctx.fillStyle = highlight ? \"#fff6d4\" : \"#ffffff\";\n    ctx.strokeStyle = highlight ? \"#ffd166\" : \"#cfe9ff\";\n    ctx.lineWidth = 3;\n    ctx.arc(0, 0, ANSWER_RADIUS + 4, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n    // inner circle\n    ctx.beginPath();\n    ctx.fillStyle = \"#f2fbff\";\n    ctx.arc(0, 0, ANSWER_RADIUS, 0, Math.PI * 2);\n    ctx.fill();\n    // number text\n    ctx.font = \"20px sans-serif\";\n    ctx.fillStyle = \"#1c3e5a\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(String(a.value), 0, 0);\n    ctx.restore();\n  }\n\n  // Collision detection\n  function checkCollisions() {\n    for (let i = answers.length - 1; i >= 0; i--) {\n      const a = answers[i];\n      const dx = a.x - drone.x;\n      const dy = a.y - drone.y;\n      const dist = Math.hypot(dx, dy);\n      if (dist < DRONE_RADIUS + ANSWER_RADIUS - 6) {\n        // collision happened\n        if (a.value === currentQuestion.correct) {\n          score++;\n          playCorrectSound();\n          announce(`Correct! Your score is ${score}.`);\n          // feedback pulse\n          soundPulse = 10;\n          // next question or win\n          if (score >= GOAL_CORRECT) {\n            gameState = \"win\";\n            announce(\"You win! Press R or click Restart to play again.\");\n            return;\n          } else {\n            // generate next question with mild difficulty\n            currentQuestion = generateQuestion(1 + Math.floor(score / 3));\n            spawnAnswers(currentQuestion);\n            return;\n          }\n        } else {\n          wrong++;\n          playWrongSound();\n          announce(`Oops! That was ${a.value}. You have ${wrong} wrong answers.`);\n          // visual feedback: shake drone and flash\n          drone.vx += (Math.random() - 0.5) * 3;\n          drone.vy += (Math.random() - 0.5) * 3;\n          // remove collided wrong answer but keep others\n          answers.splice(i, 1);\n          if (wrong >= MAX_WRONG) {\n            gameState = \"gameover\";\n            announce(\"Game over. Press R or click Restart to try again.\");\n            return;\n          } else {\n            // optionally spawn a new distractor to maintain three options\n            // spawn one random distractor around edges\n            const val = currentQuestion.correct + (Math.random() < 0.5 ? -1 : 1) * (Math.floor(Math.random() * 4) + 1);\n            answers.push({\n              id: Date.now(),\n              value: val === currentQuestion.correct ? val + 2 : val,\n              x: clamp(Math.random() * (WIDTH - 80) + 40, ANSWER_RADIUS + 40, WIDTH - ANSWER_RADIUS - 40),\n              y: clamp(Math.random() * (HEIGHT - 200) + 120, 100 + ANSWER_RADIUS, HEIGHT - 120 - ANSWER_RADIUS),\n              vx: (Math.random() - 0.5) * (0.6 + score * 0.06),\n              vy: (Math.random() - 0.5) * (0.4 + score * 0.04),\n              wobble: Math.random() * Math.PI * 2\n            });\n          }\n        }\n      }\n    }\n  }\n\n  // Update logic\n  function update(dt) {\n    tickCount++;\n    if (gameState !== \"playing\") {\n      // slow subtle animations only\n      for (const a of answers) {\n        a.wobble += 0.01;\n      }\n      return;\n    }\n\n    // Player movement: keyboard\n    const speed = 2.1 + score * 0.05;\n    const accel = 0.25;\n    if (keys[\"arrowup\"] || keys[\"w\"]) drone.vy -= accel;\n    if (keys[\"arrowdown\"] || keys[\"s\"]) drone.vy += accel;\n    if (keys[\"arrowleft\"] || keys[\"a\"]) drone.vx -= accel;\n    if (keys[\"arrowright\"] || keys[\"d\"]) drone.vx += accel;\n\n    // Gentle drag\n    drone.vx *= 0.92;\n    drone.vy *= 0.92;\n\n    // Limit speed\n    drone.vx = clamp(drone.vx, -speed * 1.6, speed * 1.6);\n    drone.vy = clamp(drone.vy, -speed * 1.6, speed * 1.6);\n\n    drone.x += drone.vx;\n    drone.y += drone.vy;\n\n    // Boundaries\n    drone.x = clamp(drone.x, DRONE_RADIUS + 6, WIDTH - DRONE_RADIUS - 6);\n    drone.y = clamp(drone.y, DRONE_RADIUS + 80, HEIGHT - DRONE_RADIUS - 80);\n\n    // tilt based on vx\n    drone.angle = Math.atan2(drone.vy, drone.vx) * 0.05;\n\n    // Update answers movement\n    for (const a of answers) {\n      a.x += a.vx;\n      a.y += a.vy;\n      // gentle bounce off walls\n      if (a.x < ANSWER_RADIUS + 12 || a.x > WIDTH - ANSWER_RADIUS - 12) a.vx *= -1;\n      if (a.y < 120 + ANSWER_RADIUS || a.y > HEIGHT - 120 - ANSWER_RADIUS) a.vy *= -1;\n      // keep inside\n      a.x = clamp(a.x, ANSWER_RADIUS + 12, WIDTH - ANSWER_RADIUS - 12);\n      a.y = clamp(a.y, 120 + ANSWER_RADIUS, HEIGHT - 120 - ANSWER_RADIUS);\n      // slight drift to keep things lively\n      a.vx += (Math.random() - 0.5) * 0.02;\n      a.vy += (Math.random() - 0.5) * 0.02;\n    }\n\n    // Collision check\n    checkCollisions();\n\n    // background pulse for audio visual indicator\n    soundPulse = Math.max(0, soundPulse - 0.25);\n  }\n\n  // UI drawing ensuring non overlapping using measureText and rectangles\n  function render() {\n    // clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // Calm sky gradient\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, \"#e8faff\");\n    g.addColorStop(1, \"#f7fbff\");\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Soft fluffy clouds (wacky+calming)\n    drawCloud(ctx, 100, 80, 1.0, 0.9);\n    drawCloud(ctx, 540, 60, 0.9, 0.85);\n    drawCloud(ctx, 360, 120, 1.1, 0.95);\n\n    // UI: score top-left\n    ctx.font = BODY_FONT;\n    const scoreText = `Correct: ${score}/${GOAL_CORRECT}`;\n    const scoreRect = getScoreRect(scoreText);\n    ctx.fillStyle = \"rgba(255,255,255,0.9)\";\n    drawRoundedRect(ctx, scoreRect.x, scoreRect.y, scoreRect.w, scoreRect.h, 8);\n    ctx.fillStyle = \"#1c3e5a\";\n    ctx.fillText(scoreText, scoreRect.x + UI_PADDING, scoreRect.y + 24);\n\n    // Sound visual icon and push\n    const soundRect = getSoundIconRect();\n    ctx.fillStyle = \"rgba(255,255,255,0.9)\";\n    drawRoundedRect(ctx, scoreRect.x + scoreRect.w + 8, soundRect.y, soundRect.w, soundRect.h, 8);\n    ctx.fillStyle = \"#1c3e5a\";\n    ctx.font = \"14px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    // speaker icon\n    ctx.beginPath();\n    ctx.moveTo(scoreRect.x + scoreRect.w + 20 - 8, soundRect.y + soundRect.h / 2 - 8);\n    ctx.lineTo(scoreRect.x + scoreRect.w + 20 - 2, soundRect.y + soundRect.h / 2 - 14);\n    ctx.lineTo(scoreRect.x + scoreRect.w + 20 + 10, soundRect.y + soundRect.h / 2 - 8);\n    ctx.closePath();\n    ctx.fillStyle = \"#256085\";\n    ctx.fill();\n    // bars if on\n    if (audioEnabled) {\n      ctx.strokeStyle = \"#256085\";\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(scoreRect.x + scoreRect.w + 24, soundRect.y + soundRect.h / 2 - 2);\n      ctx.quadraticCurveTo(scoreRect.x + scoreRect.w + 32, soundRect.y + soundRect.h / 2 - 8, scoreRect.x + scoreRect.w + 36, soundRect.y + soundRect.h / 2 - 2);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo(scoreRect.x + scoreRect.w + 24, soundRect.y + soundRect.h / 2 + 4);\n      ctx.quadraticCurveTo(scoreRect.x + scoreRect.w + 34, soundRect.y + soundRect.h / 2 + 12, scoreRect.x + scoreRect.w + 40, soundRect.y + soundRect.h / 2 + 4);\n      ctx.stroke();\n    }\n\n    // Lives top-right\n    ctx.font = BODY_FONT;\n    const livesText = `Wrong: ${wrong}/${MAX_WRONG}`;\n    const livesRect = getLivesRect(livesText);\n    ctx.fillStyle = \"rgba(255,255,255,0.9)\";\n    drawRoundedRect(ctx, livesRect.x, livesRect.y, livesRect.w, livesRect.h, 8);\n    ctx.fillStyle = \"#873b3b\";\n    ctx.fillText(livesText, livesRect.x + UI_PADDING, livesRect.y + 24);\n\n    // Question top-center (ensuring not overlapping)\n    if (currentQuestion) {\n      ctx.font = LARGE_FONT;\n      const qText = currentQuestion.text;\n      const qRect = getQuestionRect(qText);\n      ctx.fillStyle = \"rgba(255,255,255,0.95)\";\n      drawRoundedRect(ctx, qRect.x, qRect.y, qRect.w, qRect.h, 10);\n      ctx.fillStyle = \"#06314a\";\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillText(qText, qRect.x + qRect.w / 2, qRect.y + qRect.h / 2);\n    }\n\n    // Instructions bottom-center\n    const lines = [\n      \"Fly the drone to collect the correct answer!\",\n      \"Goal: collect 10 correct answers. You lose after 3 wrong picks.\",\n      \"Controls: Arrow keys or WASD to move. Click or press M to toggle sound. Press R to restart.\"\n    ];\n    ctx.font = BODY_FONT;\n    const instRect = getInstructionsRect(lines);\n    ctx.fillStyle = \"rgba(255,255,255,0.9)\";\n    drawRoundedRect(ctx, instRect.x, instRect.y, instRect.w, instRect.h, 8);\n    ctx.fillStyle = \"#0b3954\";\n    ctx.textAlign = \"left\";\n    ctx.textBaseline = \"top\";\n    let yy = instRect.y + UI_PADDING;\n    for (const line of lines) {\n      ctx.fillText(line, instRect.x + UI_PADDING, yy);\n      yy += 20;\n    }\n\n    // Draw answers\n    for (const a of answers) {\n      // highlight if near drone\n      const d = Math.hypot(a.x - drone.x, a.y - drone.y);\n      drawAnswer(ctx, a, d < 120);\n    }\n\n    // Draw drone last (so it's on top)\n    drawDrone(ctx, drone);\n\n    // If paused/menu/win/gameover overlay\n    if (gameState === \"menu\") {\n      drawMenu();\n    } else if (gameState === \"win\") {\n      drawEndScreen(true);\n    } else if (gameState === \"gameover\") {\n      drawEndScreen(false);\n    }\n\n    // Sound activity visual cue (tiny pulsing circle near sound icon)\n    ctx.beginPath();\n    const pulseR = 4 + Math.sin(tickCount / 6) * 2 * (audioEnabled ? 1 : 0.2);\n    ctx.fillStyle = audioEnabled ? \"rgba(37,96,133,0.95)\" : \"rgba(150,150,150,0.6)\";\n    ctx.arc(scoreRect.x + scoreRect.w + 28, soundRect.y + soundRect.h + 6 + -UI_PADDING, pulseR, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  function drawMenu() {\n    // translucent overlay\n    ctx.fillStyle = \"rgba(7,20,40,0.28)\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    // title box\n    const title = \"Drone Math Collector\";\n    ctx.font = TITLE_FONT;\n    const tMetrics = ctx.measureText(title);\n    const tW = Math.min(tMetrics.width, WIDTH - 80);\n    const tx = (WIDTH - tW) / 2;\n    const ty = HEIGHT * 0.22;\n    ctx.fillStyle = \"rgba(255,255,255,0.95)\";\n    drawRoundedRect(ctx, tx - 12, ty - 22, tW + 24, 60, 10);\n    ctx.fillStyle = \"#06314a\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(title, WIDTH / 2, ty + 6);\n    // start button\n    const btn = getMenuStartButtonRect();\n    ctx.fillStyle = \"#fff8e1\";\n    drawRoundedRect(ctx, btn.x, btn.y, btn.w, btn.h, 12);\n    ctx.fillStyle = \"#2a6f97\";\n    ctx.font = \"20px sans-serif\";\n    ctx.fillText(\"Start the Drone Adventure\", btn.x + btn.w / 2, btn.y + btn.h / 2);\n    // instructions below\n    ctx.font = BODY_FONT;\n    ctx.fillStyle = \"#ffffff\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"Collect correct answers by flying the drone. Avoid wrong picks!\", WIDTH / 2, btn.y + btn.h + 36);\n    ctx.fillText(\"Click the Start button or press Enter to begin.\", WIDTH / 2, btn.y + btn.h + 56);\n  }\n\n  function drawEndScreen(won) {\n    // overlay\n    ctx.fillStyle = \"rgba(5, 15, 30, 0.45)\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.font = TITLE_FONT;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillStyle = \"#fff\";\n    const title = won ? \"Victory! You mastered drone math!\" : \"Game Over - Keep practicing!\";\n    ctx.fillText(title, WIDTH / 2, HEIGHT * 0.28);\n    // details\n    ctx.font = LARGE_FONT;\n    ctx.fillStyle = won ? \"#ffd166\" : \"#ff8a8a\";\n    ctx.fillText(won ? `Score: ${score}/${GOAL_CORRECT}` : `Correct: ${score}  Wrong: ${wrong}`, WIDTH / 2, HEIGHT * 0.38);\n    // restart button\n    const btn = getEndButtonRect();\n    ctx.fillStyle = won ? \"#e6ffe9\" : \"#fff0f0\";\n    drawRoundedRect(ctx, btn.x, btn.y, btn.w, btn.h, 12);\n    ctx.fillStyle = \"#06314a\";\n    ctx.font = \"20px sans-serif\";\n    ctx.fillText(\"Restart (R) and try again\", btn.x + btn.w / 2, btn.y + btn.h / 2);\n    // small hint\n    ctx.font = BODY_FONT;\n    ctx.fillStyle = \"#ffffff\";\n    ctx.fillText(\"Click Restart or press R to play again.\", WIDTH / 2, btn.y + btn.h + 36);\n  }\n\n  // Cloud drawing simple shapes for background\n  function drawCloud(ctx, x, y, scale = 1, alpha = 1) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.scale(scale, scale);\n    ctx.globalAlpha = alpha;\n    ctx.fillStyle = \"#ffffff\";\n    ctx.beginPath();\n    ctx.arc(0, 0, 22, 0, Math.PI * 2);\n    ctx.arc(24, -6, 18, 0, Math.PI * 2);\n    ctx.arc(40, 2, 20, 0, Math.PI * 2);\n    ctx.arc(18, 10, 16, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.globalAlpha = 1;\n    ctx.restore();\n  }\n\n  // Main loop\n  function loop(now) {\n    const dt = now - lastTime;\n    lastTime = now;\n    update(dt);\n    render();\n    requestAnimationFrame(loop);\n  }\n  requestAnimationFrame(loop);\n\n  // Accessibility: draw focus outlines and ensure canvas informs keyboard users\n  // This is drawn as part of render (we provide overlays and text instructions).\n  // Provide a keyboard-only help shortcut: pressing \"h\" will announce controls\n  window.addEventListener(\"keydown\", (e) => {\n    if (e.key.toLowerCase() === \"h\") {\n      announce(\"Controls: Arrow keys or W A S D to move, click the screen to nudge the drone, M toggles sound, R to restart.\");\n    }\n  });\n\n  // Resize and layout: ensure canvas stays the desired size\n  canvas.style.width = WIDTH + \"px\";\n  canvas.style.height = HEIGHT + \"px\";\n  canvas.setAttribute(\"width\", WIDTH);\n  canvas.setAttribute(\"height\", HEIGHT);\n\n  // Start screen assets: spawn some floating answers even on menu for lively feel\n  function initMenuAnswers() {\n    currentQuestion = generateQuestion(1);\n    spawnAnswers(currentQuestion);\n  }\n  initMenuAnswers();\n\n  // Expose small debug API (non-intrusive)\n  window._droneMathGame = {\n    start: startGame,\n    menu: goToMenu,\n    getState: () => ({ score, wrong, gameState })\n  };\n})();\n---\n",
  "improve_response_tokens": 21273,
  "formatted_code": true,
  "formatting_response_tokens": 23863,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}