# Game of the Day - 2025-11-16

## Metadata
- **Generated Date:** 2025-11-16
- **Generated Time:** 2025-11-16T00:31:17.557217
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-11-16.js
- **File Size:** 28341 bytes
- **Tokens Used:** 9920

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** âœ… PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** âœ… NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
â€¢ Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
â€¢ Use visually calming and interesting and wacky elements.
â€¢ Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
â€¢ Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
â€¢ Have a game area exactly 720px wide by 480px tall.
â€¢ Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
â€¢ Use modern JavaScript practices and avoid minification.
â€¢ Include proper error handling for audio and resource loading.
â€¢ Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
â€¢ Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
â€¢ Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
â€¢ Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
â€¢ Generate all sounds using Web Audio API oscillators and filters.
â€¢ Include proper error handling for audio context creation.
â€¢ Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
â€¢ Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-11-16.js` - The playable game
- `2025-11-16.meta.json` - Machine-readable metadata
- `2025-11-16.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 19586

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 21577

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** âœ… PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Drone Math Game for ages 7-9
  // Renders inside element with id "game-of-the-day-stage"
  // All visuals drawn on canvas. Sounds via Web Audio API.
  // Clear win: 10 correct answers. Clear loss: 3 wrong answers.
  // Accessible: keyboard controls, number-key answers, aria-live text updates.

  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const TARGET_CORRECT = 10;
  const MAX_WRONG = 3;
  const DRONE_SPEED = 180; // pixels per second
  const ANSWER_RADIUS = 36;
  const MIN_UI_PADDING = 10;

  // Locate container
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Container element with id "game-of-the-day-stage" not found.');
    return;
  }

  // Create a visually hidden live region for screen readers (text alternative)
  let liveRegion = document.createElement('div');
  liveRegion.setAttribute('aria-live', 'polite');
  liveRegion.style.position = 'absolute';
  liveRegion.style.left = '-9999px';
  liveRegion.style.width = '1px';
  liveRegion.style.height = '1px';
  liveRegion.style.overflow = 'hidden';
  container.appendChild(liveRegion);

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.tabIndex = 0; // make focusable for keyboard input
  canvas.style.outline = 'none';
  container.style.position = 'relative';
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Fonts
  const SMALL_FONT = '16px sans-serif'; // >=14px
  const BODY_FONT = '18px sans-serif'; // >=18px for important
  const TITLE_FONT = '28px sans-serif';

  // Game state
  let gameState = 'start'; // start, playing, win, gameover
  let correctCount = 0;
  let wrongCount = 0;
  let currentQuestion = null;
  let answers = [];
  let drone = null;
  let lastTime = performance.now();
  let keys = {};
  let audioAllowed = false;
  let audioEnabled = true;
  let audio = null;
  let ambientGain = null;
  let sounds = {};
  let questionId = 0;

  // Pre-calculate positions for UI to avoid overlap using ctx.measureText
  function measureTextWidth(text, font) {
    ctx.save();
    ctx.font = font;
    const w = ctx.measureText(text).width;
    ctx.restore();
    return w;
  }

  // Initialize audio context with error handling
  function initAudio() {
    if (audio) return;
    try {
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtx) throw new Error('Web Audio API not supported.');
      audio = new AudioCtx();
      // create master gain
      const masterGain = audio.createGain();
      masterGain.gain.value = 0.9;
      masterGain.connect(audio.destination);

      // ambient hum
      const osc = audio.createOscillator();
      ambientGain = audio.createGain();
      osc.type = 'sine';
      osc.frequency.value = 80; // low hum
      ambientGain.gain.value = 0.02;
      osc.connect(ambientGain);
      ambientGain.connect(masterGain);
      osc.start();

      // sound: correct (rising arpeggio)
      sounds.correct = function () {
        if (!audioEnabled) return;
        const now = audio.currentTime;
        const g = audio.createGain();
        g.connect(masterGain);
        g.gain.value = 0;
        const freqs = [880, 1320, 1760];
        freqs.forEach((f, i) => {
          const o = audio.createOscillator();
          const a = audio.createGain();
          o.type = 'triangle';
          o.frequency.value = f;
          o.connect(a);
          a.connect(g);
          const t = now + 0.02 * i;
          a.gain.setValueAtTime(0, t);
          a.gain.linearRampToValueAtTime(0.12, t + 0.06);
          a.gain.linearRampToValueAtTime(0, t + 0.26);
          o.start(t);
          o.stop(t + 0.3);
        });
        // Master envelope
        g.gain.setValueAtTime(0.001, now);
        g.gain.linearRampToValueAtTime(1.0, now + 0.02);
        g.gain.linearRampToValueAtTime(0.001, now + 0.5);
      };

      // sound: incorrect (descending buzzer)
      sounds.incorrect = function () {
        if (!audioEnabled) return;
        const now = audio.currentTime;
        const o = audio.createOscillator();
        const g = audio.createGain();
        o.type = 'sawtooth';
        o.frequency.value = 500;
        o.connect(g);
        g.connect(masterGain);
        g.gain.setValueAtTime(0.001, now);
        g.gain.linearRampToValueAtTime(0.18, now + 0.02);
        g.gain.linearRampToValueAtTime(0.001, now + 0.4);
        o.frequency.setValueAtTime(500, now);
        o.frequency.exponentialRampToValueAtTime(120, now + 0.4);
        o.start(now);
        o.stop(now + 0.45);
      };

      // sound: collect (short ping)
      sounds.collect = function () {
        if (!audioEnabled) return;
        const now = audio.currentTime;
        const o = audio.createOscillator();
        const g = audio.createGain();
        o.type = 'square';
        o.frequency.value = 1200;
        o.connect(g);
        g.connect(masterGain);
        g.gain.setValueAtTime(0.001, now);
        g.gain.linearRampToValueAtTime(0.12, now + 0.01);
        g.gain.linearRampToValueAtTime(0.001, now + 0.18);
        o.start(now);
        o.stop(now + 0.2);
      };

      // Visual cue if audio available
      audioAllowed = true;
    } catch (e) {
      console.warn('Audio initialization failed:', e);
      audioAllowed = false;
      audio = null;
      sounds = {};
      ambientGain = null;
    }
  }

  // Toggle audio on/off
  function toggleAudio() {
    audioEnabled = !audioEnabled;
    if (!audio) return;
    if (ambientGain) ambientGain.gain.setValueAtTime(audioEnabled ? 0.02 : 0, audio.currentTime);
    // Play a small sound to indicate toggle if enabled
    if (audioEnabled && sounds.collect) sounds.collect();
  }

  // Accessibility announcements
  function announce(text) {
    try {
      liveRegion.textContent = text;
    } catch (e) {
      console.warn('Failed to update live region', e);
    }
  }

  // Question generator for early ages
  function generateQuestion() {
    // mix: addition, subtraction, missing addend
    const kind = Math.random();
    if (kind < 0.45) {
      // addition up to 20
      const a = Math.floor(Math.random() * 12) + 1;
      const b = Math.floor(Math.random() * 12) + 1;
      const answer = a + b;
      return {
        text: `${a} + ${b} = ?`,
        correct: answer,
      };
    } else if (kind < 0.9) {
      // subtraction non-negative
      const a = Math.floor(Math.random() * 15) + 5;
      const b = Math.floor(Math.random() * (a - 2)) + 1;
      const answer = a - b;
      return {
        text: `${a} - ${b} = ?`,
        correct: answer,
      };
    } else {
      // missing addend: a + ? = b
      const a = Math.floor(Math.random() * 10) + 1;
      const b = a + Math.floor(Math.random() * 10) + 1;
      const answer = b - a;
      return {
        text: `${a} + ? = ${b}`,
        correct: answer,
      };
    }
  }

  // Generate answer options, ensure plausible distractors
  function generateAnswers(correct) {
    const set = new Set([correct]);
    while (set.size < 4) {
      // near misses
      const delta = Math.floor(Math.random() * 7) - 3;
      let val = correct + delta;
      if (Math.random() < 0.2) val = correct + (Math.random() < 0.5 ? 5 : -5);
      if (val < 0) val = Math.abs(val) + 1;
      set.add(val);
    }
    const arr = Array.from(set);
    // shuffle
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  // Place answer bubbles (ensure non-overlapping with safe attempts)
  function placeAnswerBubbles(values) {
    const positions = [];
    const attemptsLimit = 200;
    for (let val of values) {
      let tries = 0;
      let placed = false;
      while (!placed && tries < attemptsLimit) {
        tries++;
        // place within upper 60% of canvas, avoid center bottom area (for drone)
        const x = Math.floor(Math.random() * (WIDTH - ANSWER_RADIUS * 2)) + ANSWER_RADIUS;
        const y = Math.floor(Math.random() * (HEIGHT * 0.6 - ANSWER_RADIUS * 2)) + ANSWER_RADIUS + 60;
        let ok = true;
        for (let p of positions) {
          const dx = p.x - x;
          const dy = p.y - y;
          if (Math.sqrt(dx * dx + dy * dy) < ANSWER_RADIUS * 2 + 10) {
            ok = false;
            break;
          }
        }
        // avoid top UI area (top 70px)
        if (y < 70) ok = false;
        if (ok) {
          positions.push({ x, y, val });
          placed = true;
        }
      }
      if (!placed) {
        // fallback grid
        positions.push({
          x: ANSWER_RADIUS + (positions.length * ANSWER_RADIUS * 3) % (WIDTH - ANSWER_RADIUS * 2),
          y: 120 + Math.floor(positions.length / 3) * ANSWER_RADIUS * 3,
          val,
        });
      }
    }
    // add label numbers 1..4
    return positions.map((p, i) => ({ ...p, label: i + 1 }));
  }

  // Initialize or reset game
  function startNewGame() {
    correctCount = 0;
    wrongCount = 0;
    questionId = 0;
    drone = {
      x: WIDTH / 2,
      y: HEIGHT - 110,
      vx: 0,
      vy: 0,
      w: 56,
      h: 28,
      colorHue: Math.floor(Math.random() * 360),
    };
    gameState = 'playing';
    spawnQuestion();
    announce('Game started. Answer math questions by flying the drone to the correct bubble or press number keys 1 to 4.');
    // try to initialize audio on start interaction
    if (!audio && audioAllowed === false) {
      // try to init audio on user start
      initAudio();
    }
  }

  // Spawn a new question
  function spawnQuestion() {
    questionId++;
    currentQuestion = generateQuestion();
    answers = placeAnswerBubbles(generateAnswers(currentQuestion.correct));
    // Ensure one answer is the correct one (it should be)
    announce(`Question ${questionId}: ${currentQuestion.text}. Answers: ${answers.map(a => a.val).join(', ')}. Use arrow keys to fly or press number 1 to 4 to answer.`);
  }

  // Check collision between drone rectangle and circle (answer)
  function droneHitsAnswer(answer) {
    const nearestX = Math.max(answer.x - ANSWER_RADIUS, Math.min(drone.x, answer.x + ANSWER_RADIUS));
    const nearestY = Math.max(answer.y - ANSWER_RADIUS, Math.min(drone.y, answer.y + ANSWER_RADIUS));
    const dx = drone.x - nearestX;
    const dy = drone.y - nearestY;
    return dx * dx + dy * dy <= (drone.w / 2 + ANSWER_RADIUS) * (drone.w / 2 + ANSWER_RADIUS);
  }

  // Handle selecting an answer (either via collision or via number key)
  function selectAnswerByIndex(index) {
    if (gameState !== 'playing') return;
    const answer = answers[index];
    if (!answer) return;
    handleAnswerSelected(answer);
  }

  function handleAnswerSelected(answer) {
    if (gameState !== 'playing') return;
    if (answer.val === currentQuestion.correct) {
      correctCount++;
      if (sounds && sounds.correct) sounds.correct();
      if (sounds && sounds.collect) sounds.collect();
      announce(`Correct! ${currentQuestion.text} Answer ${answer.val}. Correct count: ${correctCount} of ${TARGET_CORRECT}.`);
      // small pop effect: move answer offscreen
      answer.collected = true;
      setTimeout(() => {
        // check win
        if (correctCount >= TARGET_CORRECT) {
          gameState = 'win';
          announce('Victory! You answered ten questions correctly. Press R or click Restart to play again.');
        } else {
          spawnQuestion();
        }
      }, 300);
    } else {
      wrongCount++;
      if (sounds && sounds.incorrect) sounds.incorrect();
      // shake drone
      drone.shake = 12;
      announce(`Oops! That's ${answer.val}. The correct answer was ${currentQuestion.correct}. Wrong answers: ${wrongCount} of ${MAX_WRONG}.`);
      if (wrongCount >= MAX_WRONG) {
        gameState = 'gameover';
        announce('Game over. You had three wrong answers. Press R or click Restart to try again.');
      } else {
        // move to next question
        setTimeout(spawnQuestion, 800);
      }
    }
  }

  // Draw UI rectangles with measured widths and padding, ensuring no overlap
  function drawUI() {
    ctx.save();

    // Score top-left
    ctx.font = BODY_FONT;
    const scoreText = `Correct: ${correctCount}/${TARGET_CORRECT}`;
    const scoreW = ctx.measureText(scoreText).width;
    const scorePadding = MIN_UI_PADDING;
    const scoreBoxWidth = scoreW + scorePadding * 2;
    const scoreBoxHeight = 28;
    const scoreX = MIN_UI_PADDING;
    const scoreY = MIN_UI_PADDING;
    ctx.fillStyle = 'rgba(255,255,255,0.75)';
    ctx.fillRect(scoreX, scoreY, scoreBoxWidth, scoreBoxHeight);
    ctx.strokeStyle = '#111';
    ctx.strokeRect(scoreX, scoreY, scoreBoxWidth, scoreBoxHeight);
    ctx.fillStyle = '#111';
    ctx.textBaseline = 'middle';
    ctx.font = BODY_FONT;
    ctx.fillText(scoreText, scoreX + scorePadding, scoreY + scoreBoxHeight / 2);

    // Audio indicator top-center (ensure not overlapping)
    const audioText = audio ? (audioEnabled ? 'Audio: ON (M to mute)' : 'Audio: OFF (M to unmute)') : 'Audio: unavailable';
    ctx.font = SMALL_FONT;
    const audioW = ctx.measureText(audioText).width;
    const audioBoxWidth = audioW + scorePadding * 2;
    const audioBoxHeight = 24;
    const audioX = Math.max((WIDTH - audioBoxWidth) / 2, scoreX + scoreBoxWidth + MIN_UI_PADDING);
    const audioY = MIN_UI_PADDING;
    ctx.fillStyle = 'rgba(240,240,255,0.9)';
    ctx.fillRect(audioX, audioY, audioBoxWidth, audioBoxHeight);
    ctx.strokeStyle = '#113';
    ctx.strokeRect(audioX, audioY, audioBoxWidth, audioBoxHeight);
    ctx.fillStyle = '#113';
    ctx.textBaseline = 'middle';
    ctx.fillText(audioText, audioX + scorePadding, audioY + audioBoxHeight / 2);

    // Lives top-right
    const livesText = `Wrong: ${wrongCount}/${MAX_WRONG}`;
    ctx.font = BODY_FONT;
    const livesW = ctx.measureText(livesText).width;
    const livesBoxWidth = livesW + scorePadding * 2;
    const livesBoxHeight = 28;
    const livesX = WIDTH - livesBoxWidth - MIN_UI_PADDING;
    const livesY = MIN_UI_PADDING;
    // Ensure not overlapping audio box
    if (livesX < audioX + audioBoxWidth + MIN_UI_PADDING) {
      // shift audio box left if possible
      // we won't attempt complex relocation; keep minimum spacing
    }
    ctx.fillStyle = 'rgba(255,240,240,0.9)';
    ctx.fillRect(livesX, livesY, livesBoxWidth, livesBoxHeight);
    ctx.strokeStyle = '#311';
    ctx.strokeRect(livesX, livesY, livesBoxWidth, livesBoxHeight);
    ctx.fillStyle = '#311';
    ctx.textBaseline = 'middle';
    ctx.fillText(livesText, livesX + scorePadding, livesY + livesBoxHeight / 2);

    ctx.restore();
  }

  // Draw instructions bottom-center with background rectangle and ensure multi-line spacing
  function drawInstructions(lines) {
    ctx.save();
    ctx.font = SMALL_FONT;
    const padding = 10;
    const lineHeight = 20;
    // compute max width
    let maxW = 0;
    for (let line of lines) {
      const w = ctx.measureText(line).width;
      if (w > maxW) maxW = w;
    }
    const boxW = maxW + padding * 2;
    const boxH = lines.length * lineHeight + padding * 2;
    const boxX = (WIDTH - boxW) / 2;
    const boxY = HEIGHT - boxH - MIN_UI_PADDING;
    ctx.fillStyle = 'rgba(250,250,230,0.9)';
    ctx.fillRect(boxX, boxY, boxW, boxH);
    ctx.strokeStyle = '#444';
    ctx.strokeRect(boxX, boxY, boxW, boxH);
    ctx.fillStyle = '#000';
    ctx.textBaseline = 'top';
    ctx.font = SMALL_FONT;
    for (let i = 0; i < lines.length; i++) {
      ctx.fillText(lines[i], boxX + padding, boxY + padding + i * lineHeight);
    }
    ctx.restore();
  }

  // Draw answer bubbles
  function drawAnswers() {
    ctx.save();
    for (let a of answers) {
      // background circle
      ctx.beginPath();
      // color friendly and wacky
      const hue = 180 + (a.label * 40);
      ctx.fillStyle = a.collected ? 'rgba(200,200,200,0.3)' : `hsl(${hue} 80% 65%)`;
      ctx.strokeStyle = '#222';
      ctx.lineWidth = 2;
      ctx.arc(a.x, a.y, ANSWER_RADIUS, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // number label small
      ctx.fillStyle = '#111';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(a.label.toString(), a.x - ANSWER_RADIUS + 12, a.y - ANSWER_RADIUS + 12);

      // value text centered
      ctx.font = '18px bold sans-serif';
      ctx.fillStyle = '#042';
      ctx.fillText(a.val.toString(), a.x, a.y + 2);
    }
    ctx.restore();
  }

  // Draw drone
  function drawDrone(dt) {
    ctx.save();
    // shaking effect
    const shake = drone.shake || 0;
    if (drone.shake) {
      drone.shake = Math.max(0, drone.shake - 20 * dt);
    }
    const shakeX = (Math.random() - 0.5) * shake;
    const shakeY = (Math.random() - 0.5) * shake;
    ctx.translate(shakeX, shakeY);

    // main body
    ctx.save();
    ctx.translate(drone.x, drone.y);
    ctx.rotate(Math.atan2(drone.vy, Math.max(1e-4, drone.vx + 0.0001)) * 0.05);
    // body
    ctx.fillStyle = `hsl(${drone.colorHue} 70% 50%)`;
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(0, 0, drone.w / 2, drone.h / 2, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // windows
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.beginPath();
    ctx.ellipse(-6, -2, 8, 6, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.beginPath();
    ctx.ellipse(-6, -2, 5, 3, 0, 0, Math.PI * 2);
    ctx.fill();

    // goofy antenna
    ctx.strokeStyle = '#111';
    ctx.beginPath();
    ctx.moveTo(drone.w / 4, -drone.h / 2);
    ctx.lineTo(drone.w / 4 + 10, -drone.h / 2 - 18);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(drone.w / 4 + 10, -drone.h / 2 - 18, 4, 0, Math.PI * 2);
    ctx.fillStyle = '#f55';
    ctx.fill();
    ctx.restore();

    // rotors (wacky shapes)
    const rotorCount = 3;
    for (let i = 0; i < rotorCount; i++) {
      const rx = drone.x + Math.cos((i / rotorCount) * Math.PI * 2 + performance.now() / 600) * 26;
      const ry = drone.y + Math.sin((i / rotorCount) * Math.PI * 2 + performance.now() / 600) * 12 - 14;
      // rotor shadow
      ctx.fillStyle = 'rgba(0,0,0,0.12)';
      ctx.beginPath();
      ctx.ellipse(rx + 2, ry + 6, 22, 6, 0, 0, Math.PI * 2);
      ctx.fill();

      // rotor blades (drawn as arcs)
      ctx.strokeStyle = 'rgba(30,30,30,0.9)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(rx, ry, 14, 0, Math.PI * 2);
      ctx.stroke();
    }

    ctx.restore();
  }

  // Draw question text at center-top
  function drawQuestion() {
    ctx.save();
    ctx.font = TITLE_FONT;
    const text = currentQuestion ? currentQuestion.text : 'Get ready!';
    const textW = ctx.measureText(text).width;
    const boxW = textW + MIN_UI_PADDING * 2;
    const boxH = 40;
    const boxX = (WIDTH - boxW) / 2;
    const boxY = 48;
    ctx.fillStyle = 'rgba(230,248,255,0.94)';
    ctx.fillRect(boxX, boxY, boxW, boxH);
    ctx.strokeStyle = '#064';
    ctx.strokeRect(boxX, boxY, boxW, boxH);
    ctx.fillStyle = '#023';
    ctx.textBaseline = 'middle';
    ctx.font = TITLE_FONT;
    ctx.fillText(text, boxX + MIN_UI_PADDING, boxY + boxH / 2);
    ctx.restore();
  }

  // Draw overlay screens: start, win, gameover
  function drawOverlay() {
    ctx.save();
    if (gameState === 'start') {
      // draw calm background and instructions
      ctx.fillStyle = '#eaf6ff';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      // big title
      const title = 'Drone Math Adventure';
      ctx.font = '32px sans-serif';
      const tw = ctx.measureText(title).width;
      ctx.fillStyle = '#023';
      ctx.fillText(title, (WIDTH - tw) / 2, 120);

      const lines = [
        'Welcome, pilot! Help the friendly drone collect the correct math bubbles.',
        `Goal: Answer ${TARGET_CORRECT} questions correctly.`,
        `You can make ${MAX_WRONG} mistakes before the game ends.`,
        'Controls: Arrow keys to fly, numbers 1-4 to pick an answer,',
        'Press M to toggle audio, press Enter or click to start.',
      ];
      drawInstructions(lines);
    } else if (gameState === 'win' || gameState === 'gameover') {
      // dim background
      ctx.fillStyle = 'rgba(10,10,30,0.35)';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      const boxW = WIDTH * 0.8;
      const boxH = 220;
      const boxX = (WIDTH - boxW) / 2;
      const boxY = (HEIGHT - boxH) / 2;
      ctx.fillStyle = 'rgba(255,255,255,0.96)';
      ctx.fillRect(boxX, boxY, boxW, boxH);
      ctx.strokeStyle = '#333';
      ctx.strokeRect(boxX, boxY, boxW, boxH);
      ctx.font = '28px sans-serif';
      ctx.fillStyle = '#022';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      const title = gameState === 'win' ? 'You Win! ðŸŽ‰' : 'Game Over';
      ctx.fillText(title, WIDTH / 2, boxY + 20);

      ctx.font = '18px sans-serif';
      ctx.fillStyle = '#111';
      ctx.textBaseline = 'top';
      if (gameState === 'win') {
        ctx.fillText(`Great flying! You answered ${correctCount} questions correctly.`, WIDTH / 2, boxY + 70);
      } else {
        ctx.fillText(`You answered ${correctCount} correct and made ${wrongCount} mistakes.`, WIDTH / 2, boxY + 70);
      }

      ctx.font = '16px sans-serif';
      ctx.fillText('Press R to Restart or click the Restart button below.', WIDTH / 2, boxY + 110);

      // draw restart button
      const btnW = 160;
      const btnH = 44;
      const btnX = WIDTH / 2 - btnW / 2;
      const btnY = boxY + boxH - 70;
      ctx.fillStyle = '#0a7';
      ctx.fillRect(btnX, btnY, btnW, btnH);
      ctx.strokeStyle = '#063';
      ctx.strokeRect(btnX, btnY, btnW, btnH);
      ctx.fillStyle = '#003';
      ctx.font = '18px sans-serif';
      ctx.textBaseline = 'middle';
      ctx.fillText('Restart (R)', WIDTH / 2, btnY + btnH / 2);

      // store button bounds for click detection
      overlayButton = { x: btnX, y: btnY, w: btnW, h: btnH };
    }
    ctx.restore();
  }

  let overlayButton = null;

  // Main render
  function render(now) {
    const dt = Math.min((now - lastTime) / 1000, 0.05);
    lastTime = now;

    // Clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // gentle sky background with wacky shapes
    // gradient
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#e6f7ff');
    g.addColorStop(1, '#f6fbff');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    // floating cloud doodles
    for (let i = 0; i < 5; i++) {
      ctx.beginPath();
      const cx = (i * 173 + (now / 50)) % (WIDTH + 200) - 100;
      const cy = 40 + (i % 2) * 18;
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.ellipse(cx, cy, 60, 22, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    if (gameState === 'start') {
      drawOverlay();
      requestAnimationFrame(render);
      return;
    }

    // Update drone physics
    if (gameState === 'playing') {
      const acc = { x: 0, y: 0 };
      if (keys['ArrowLeft']) acc.x -= 1;
      if (keys['ArrowRight']) acc.x += 1;
      if (keys['ArrowUp']) acc.y -= 1;
      if (keys['ArrowDown']) acc.y += 1;

      // normalize acceleration
      if (acc.x !== 0 || acc.y !== 0) {
        const mag = Math.sqrt(acc.x * acc.x + acc.y * acc.y);
        acc.x /= mag;
        acc.y /= mag;
        drone.vx = acc.x * DRONE_SPEED;
        drone.vy = acc.y * DRONE_SPEED;
      } else {
        // slow down gradually
        drone.vx *= 0.9;
        drone.vy *= 0.9;
      }

      drone.x += drone.vx * dt;
      drone.y += drone.vy * dt;

      // constrain within canvas
      drone.x = Math.max(16, Math.min(WIDTH - 16, drone.x));
      drone.y = Math.max(70, Math.min(HEIGHT - 40, drone.y));

      // collision with answers
      for (let i = 0; i < answers.length; i++) {
        const a = answers[i];
        if (!a.collected && droneHitsAnswer(a)) {
          handleAnswerSelected(a);
          break;
        }
      }
    }

    // draw answers and drone
    drawAnswers();
    drawDrone(1 / 60);

    // question UI
    drawQuestion();

    // UI
    drawUI();

    // instructions bottom
    if (gameState === 'playing') {
      drawInstructions([
        'Fly to the bubble with the correct answer, or press 1-4.',
        'Goal: answer 10 correctly. Three wrong answers = game over.',
        'Press M to toggle audio. Press R to restart anytime.',
      ]);
    }

    // overlay screens drawn last to ensure visibility
    if ((gameState === 'win' || gameState === 'gameover')) {
      drawOverlay();
    }

    requestAnimationFrame(render);
  }

  // Input handling
  canvas.addEventListener('keydown', (e) => {
    if (e.key === 'Tab') return; // allow tab navigation outside
    e.preventDefault();
    keys[e.key] = true;

    // initialize audio on first user gesture
    if (!audio && (e.key === 'Enter' || e.key === ' ' || e.key.startsWith('Arrow') || /^[1-4]$/.test(e.key))) {
      initAudio();
      if (audio && ambientGain) ambientGain.gain.setValueAtTime(audioEnabled ? 0.02 : 0, audio.currentTime);
    }

    if (gameState === 'start' && (e.key === 'Enter' || e.key === ' ')) {
      // start game
      startNewGame();
    } else if (gameState === 'playing') {
      if (/^[1-4]$/.test(e.key)) {
        const idx = Number(e.key) - 1;
        selectAnswerByIndex(idx);
      } else if (e.key === 'm' || e.key === 'M') {
        toggleAudio();
      } else if (e.key === 'r' || e.key === 'R') {
        startNewGame();
      }
    } else if ((gameState === 'win' || gameState === 'gameover')) {
      if (e.key === 'r' || e.key === 'R') {
        startNewGame();
      } else if (e.key === 'm' || e.key === 'M') {
        toggleAudio();
      }
    }
  });

  canvas.addEventListener('keyup', (e) => {
    keys[e.key] = false;
  });

  // Pointer input for clicking answer bubbles and UI
  canvas.addEventListener('pointerdown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);

    // start audio context on first user pointer
    initAudio();
    if (audio && ambientGain) ambientGain.gain.setValueAtTime(audioEnabled ? 0.02 : 0, audio.currentTime);

    if (gameState === 'start') {
      startNewGame();
      return;
    } else if (gameState === 'playing') {
      // check answer bubbles
      for (let i = 0; i < answers.length; i++) {
        const a = answers[i];
        const dx = x - a.x;
        const dy = y - a.y;
        if (dx * dx + dy * dy <= ANSWER_RADIUS * ANSWER_RADIUS) {
          handleAnswerSelected(a);
          return;
        }
      }
      // allow clicking anywhere to move drone (set velocity towards click)
      // simple immediate reposition: set drone velocity toward point
      const dx = x - drone.x;
      const dy = y - drone.y;
      const mag = Math.sqrt(dx * dx + dy * dy);
      if (mag > 5) {
        drone.vx = (dx / mag) * DRONE_SPEED * 0.8;
        drone.vy = (dy / mag) * DRONE_SPEED * 0.8;
      }
    } else if (gameState === 'win' || gameState === 'gameover') {
      if (overlayButton) {
        if (x >= overlayButton.x && x <= overlayButton.x + overlayButton.w &&
          y >= overlayButton.y && y <= overlayButton.y + overlayButton.h) {
          startNewGame();
          return;
        }
      }
      // click in overlay area triggers restart instruction too
      startNewGame();
    }
  });

  // resizing & focus
  canvas.addEventListener('blur', () => {
    keys = {}; // stop movement on blur
  });
  // ensure keyboard focus instructions
  canvas.addEventListener('focus', () => {
    announce('Canvas focused. Use arrow keys to fly. Press Enter to start.');
  });

  // Start rendering loop
  lastTime = performance.now();
  requestAnimationFrame(render);

  // initial overlay
  gameState = 'start';

  // Announce initial instructions
  announce('Press Enter to start Drone Math Adventure. Use arrow keys to fly, 1-4 to answer, M to toggle audio, R to restart.');

  // Provide some error handling for unexpected exceptions
  window.addEventListener('error', (ev) => {
    console.error('Unexpected error in game:', ev.message);
    announce('An error occurred in the game. Please reload the page.');
  });
})();
---

