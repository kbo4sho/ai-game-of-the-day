{
  "generated_date": "2025-11-05",
  "generated_timestamp": "2025-11-05T00:28:58.883405",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9254,
  "game_filename": "2025-11-05.js",
  "game_size_bytes": 25419,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Drone Math Collector - JavaScript Game\n  // Rendered inside existing element with id \"game-of-the-day-stage\"\n  // All graphics via Canvas; all sounds generated with Web Audio API.\n  // Designed for children ages 7-9; goal: collect 10 correct packages, lose after 3 wrong picks.\n\n  // ------------------------------\n  // Initialization and Utilities\n  // ------------------------------\n\n  const CONTAINER_ID = \"game-of-the-day-stage\";\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const GOAL_CORRECT = 10;\n  const MAX_WRONG = 3;\n  const PACKAGE_SPAWN_INTERVAL = 1400; // ms\n  const PACKAGE_SPEED_MIN = 0.4;\n  const PACKAGE_SPEED_MAX = 1.2;\n\n  const container = document.getElementById(CONTAINER_ID);\n  if (!container) {\n    console.error(`Container element with id \"${CONTAINER_ID}\" not found.`);\n    return;\n  }\n\n  // Clear container and set relative positioning\n  container.innerHTML = \"\";\n  container.style.position = \"relative\";\n  container.setAttribute(\"tabindex\", \"0\"); // allow keyboard focus\n\n  // Create accessible text area for screen readers (visually hidden)\n  const liveRegion = document.createElement(\"div\");\n  liveRegion.setAttribute(\"aria-live\", \"polite\");\n  liveRegion.style.position = \"absolute\";\n  liveRegion.style.left = \"-9999px\";\n  container.appendChild(liveRegion);\n\n  // Create the canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute(\"role\", \"img\");\n  canvas.setAttribute(\"aria-label\", \"Drone math game. Move with arrow keys or WASD. Press space to pick packages.\");\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    console.error(\"2D context not available.\");\n    return;\n  }\n\n  // Utility clamp\n  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));\n\n  // ------------------------------\n  // Audio Setup with Error Handling\n  // ------------------------------\n  let audioCtx = null;\n  let audioEnabled = true;\n  try {\n    const AudioContext = window.AudioContext || window.webkitAudioContext;\n    audioCtx = new AudioContext();\n    // Gentle background hum\n    const bgOsc = audioCtx.createOscillator();\n    const bgGain = audioCtx.createGain();\n    bgOsc.type = \"sine\";\n    bgOsc.frequency.value = 110; // low hum\n    bgGain.gain.value = 0.003; // very subtle\n    bgOsc.connect(bgGain).connect(audioCtx.destination);\n    bgOsc.start();\n  } catch (e) {\n    console.warn(\"AudioContext not available or failed to create:\", e);\n    audioEnabled = false;\n    audioCtx = null;\n  }\n\n  function playCorrectSound() {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = \"triangle\";\n      o.frequency.setValueAtTime(440, audioCtx.currentTime);\n      o.frequency.exponentialRampToValueAtTime(880, audioCtx.currentTime + 0.25);\n      g.gain.setValueAtTime(0, audioCtx.currentTime);\n      g.gain.linearRampToValueAtTime(0.12, audioCtx.currentTime + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.7);\n      o.connect(g).connect(audioCtx.destination);\n      o.start();\n      o.stop(audioCtx.currentTime + 0.8);\n    } catch (e) {\n      console.warn(\"Error playing correct sound:\", e);\n    }\n  }\n\n  function playWrongSound() {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = \"square\";\n      o.frequency.setValueAtTime(200, audioCtx.currentTime);\n      o.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.25);\n      g.gain.setValueAtTime(0.15, audioCtx.currentTime);\n      g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);\n      const f = audioCtx.createBiquadFilter();\n      f.type = \"lowpass\";\n      f.frequency.value = 1200;\n      o.connect(f).connect(g).connect(audioCtx.destination);\n      o.start();\n      o.stop(audioCtx.currentTime + 0.6);\n    } catch (e) {\n      console.warn(\"Error playing wrong sound:\", e);\n    }\n  }\n\n  // Toggle audio on/off\n  function toggleAudio() {\n    if (!audioCtx) {\n      audioEnabled = false;\n      return;\n    }\n    if (audioCtx.state === \"suspended\") {\n      audioCtx.resume().then(() => {\n        audioEnabled = true;\n      });\n    } else {\n      // Can't really suspend the one-time bg oscillator easily, but we can set a flag\n      audioEnabled = !audioEnabled;\n    }\n  }\n\n  // ------------------------------\n  // Game State\n  // ------------------------------\n\n  let lastTime = performance.now();\n  let spawnTimer = 0;\n  let packages = [];\n  let keys = {};\n  let mouse = { x: 0, y: 0, down: false };\n  let gameState = \"playing\"; // 'playing', 'victory', 'gameover'\n  let correctCount = 0;\n  let wrongCount = 0;\n  let currentQuestion = null;\n  let accessibleMessage = \"\";\n\n  // Drone object\n  const drone = {\n    x: WIDTH / 2,\n    y: HEIGHT / 2,\n    radius: 26,\n    vx: 0,\n    vy: 0,\n    speed: 2.2,\n    propellerAngle: 0\n  };\n\n  // Colors (calming pastel palette)\n  const BG_COLOR = \"#E8F6FF\";\n  const CLOUD_COLOR = \"#FFFFFF\";\n  const PACKAGE_COLORS = [\"#FFD6A5\", \"#BDE0FE\", \"#CDEAC0\", \"#F6C2D7\"];\n  const DRONE_COLOR = \"#6C6CE5\";\n  const TEXT_COLOR = \"#123456\";\n  const UI_BG = \"rgba(255,255,255,0.85)\";\n\n  // ------------------------------\n  // Math Question Generation\n  // ------------------------------\n\n  function generateQuestion() {\n    // For ages 7-9: addition and subtraction within 0-20, occasional small multiplies.\n    const types = [\"add\", \"sub\", \"add\", \"add\", \"mul\"]; // weighting addition\n    const t = types[Math.floor(Math.random() * types.length)];\n    let a, b, answer, text;\n    if (t === \"add\") {\n      a = Math.floor(Math.random() * 11); // 0..10\n      b = Math.floor(Math.random() * 11);\n      answer = a + b;\n      text = `${a} + ${b} = ?`;\n    } else if (t === \"sub\") {\n      a = Math.floor(Math.random() * 11) + 5; // 5..15\n      b = Math.floor(Math.random() * 6); // 0..5\n      answer = a - b;\n      text = `${a} - ${b} = ?`;\n    } else {\n      a = Math.floor(Math.random() * 5) + 2; // 2..6\n      b = Math.floor(Math.random() * 5) + 2;\n      answer = a * b;\n      text = `${a} \u00d7 ${b} = ?`;\n    }\n    return { a, b, answer, text, type: t };\n  }\n\n  function createPackagesForQuestion(question) {\n    const correct = question.answer;\n    // Create two plausible wrong answers\n    const wrongs = new Set();\n    while (wrongs.size < 2) {\n      let candidate;\n      if (Math.random() < 0.5) {\n        candidate = correct + (Math.floor(Math.random() * 5) - 2);\n      } else {\n        candidate = Math.max(0, correct + (Math.random() < 0.5 ? -3 : 3) + Math.floor(Math.random() * 3));\n      }\n      if (candidate !== correct && candidate >= 0 && candidate <= 100) wrongs.add(candidate);\n    }\n    const answers = shuffleArray([correct, ...Array.from(wrongs)]);\n    // Place packages spaced across top\n    const margin = 60;\n    const step = (WIDTH - margin * 2) / (answers.length - 1);\n    const list = answers.map((ans, i) => {\n      return {\n        id: Math.random().toString(36).slice(2, 9),\n        x: margin + step * i,\n        y: -30 - Math.random() * 80,\n        w: 82,\n        h: 54,\n        vx: (Math.random() - 0.5) * 0.2,\n        vy: PACKAGE_SPEED_MIN + Math.random() * (PACKAGE_SPEED_MAX - PACKAGE_SPEED_MIN),\n        value: ans,\n        color: PACKAGE_COLORS[i % PACKAGE_COLORS.length],\n        alive: true\n      };\n    });\n    return list;\n  }\n\n  function shuffleArray(arr) {\n    const copy = arr.slice();\n    for (let i = copy.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [copy[i], copy[j]] = [copy[j], copy[i]];\n    }\n    return copy;\n  }\n\n  // Initialize first question and packages\n  function newQuestion() {\n    currentQuestion = generateQuestion();\n    packages = createPackagesForQuestion(currentQuestion);\n    announce(`New question: ${currentQuestion.text}`);\n  }\n\n  // Accessibility announcer\n  function announce(text) {\n    accessibleMessage = text;\n    liveRegion.textContent = text;\n  }\n\n  // ------------------------------\n  // Input Handling\n  // ------------------------------\n  window.addEventListener(\"keydown\", (e) => {\n    keys[e.key.toLowerCase()] = true;\n\n    // Help: restart with r\n    if (e.key.toLowerCase() === \"r\") {\n      if (gameState === \"victory\" || gameState === \"gameover\") {\n        restartGame();\n      } else {\n        // Also allow mid-game restart\n        restartGame();\n      }\n    }\n\n    // Space to pick overlapping package\n    if (e.key === \" \" || e.key === \"Spacebar\") {\n      if (gameState === \"playing\") {\n        pickOverlappingPackage();\n      }\n      e.preventDefault();\n    }\n\n    // Number keys 1-3 to pick left-to-right packages\n    if ([\"1\", \"2\", \"3\"].includes(e.key) && gameState === \"playing\") {\n      const idx = parseInt(e.key, 10) - 1;\n      if (packages[idx]) {\n        pickPackage(packages[idx]);\n      }\n    }\n\n    // Toggle audio with m\n    if (e.key.toLowerCase() === \"m\") {\n      toggleAudio();\n      announce(audioEnabled ? \"Audio on\" : \"Audio off\");\n    }\n  });\n\n  window.addEventListener(\"keyup\", (e) => {\n    keys[e.key.toLowerCase()] = false;\n  });\n\n  canvas.addEventListener(\"mousemove\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);\n    mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);\n  });\n\n  canvas.addEventListener(\"mousedown\", (e) => {\n    mouse.down = true;\n    // click picks a package when clicking on it\n    const p = packages.find((pck) => {\n      return (\n        mouse.x >= pck.x - pck.w / 2 &&\n        mouse.x <= pck.x + pck.w / 2 &&\n        mouse.y >= pck.y - pck.h / 2 &&\n        mouse.y <= pck.y + pck.h / 2\n      );\n    });\n    if (p && gameState === \"playing\") {\n      pickPackage(p);\n    }\n\n    // If in end screen, check restart button area\n    if ((gameState === \"victory\" || gameState === \"gameover\") && restartButtonRect) {\n      const r = restartButtonRect;\n      if (mouse.x >= r.x && mouse.x <= r.x + r.w && mouse.y >= r.y && mouse.y <= r.y + r.h) {\n        restartGame();\n      }\n    }\n  });\n\n  canvas.addEventListener(\"mouseup\", () => {\n    mouse.down = false;\n  });\n\n  // ------------------------------\n  // Picking and Collision\n  // ------------------------------\n  function pickOverlappingPackage() {\n    const collided = packages.find((p) => circleRectCollision(drone.x, drone.y, drone.radius, p));\n    if (collided) {\n      pickPackage(collided);\n    } else {\n      announce(\"No package in reach. Fly closer to a package and press space.\");\n    }\n  }\n\n  function circleRectCollision(cx, cy, r, rect) {\n    const rx = rect.x - rect.w / 2;\n    const ry = rect.y - rect.h / 2;\n    // Find closest point\n    const closestX = clamp(cx, rx, rx + rect.w);\n    const closestY = clamp(cy, ry, ry + rect.h);\n    const dx = cx - closestX;\n    const dy = cy - closestY;\n    return dx * dx + dy * dy <= r * r;\n  }\n\n  function pickPackage(p) {\n    if (!p || !p.alive) return;\n    p.alive = false;\n    if (p.value === currentQuestion.answer) {\n      correctCount++;\n      playCorrectSound();\n      announce(`Correct! ${currentQuestion.text} Answer: ${currentQuestion.answer}. ${correctCount} correct collected.`);\n      // Check win\n      if (correctCount >= GOAL_CORRECT) {\n        gameState = \"victory\";\n        announce(`You collected ${GOAL_CORRECT} correct packages! Victory! Press R to restart.`);\n      } else {\n        // new question after a short delay\n        setTimeout(newQuestion, 700);\n      }\n    } else {\n      wrongCount++;\n      playWrongSound();\n      announce(`Oops! That was ${p.value}. Wrong answers: ${wrongCount} out of ${MAX_WRONG}.`);\n      if (wrongCount >= MAX_WRONG) {\n        gameState = \"gameover\";\n        announce(`Game over. You made ${wrongCount} incorrect picks. Press R to try again.`);\n      } else {\n        // small shake / visual; continue with same question but remove package\n      }\n    }\n  }\n\n  // ------------------------------\n  // Restart\n  // ------------------------------\n  function restartGame() {\n    correctCount = 0;\n    wrongCount = 0;\n    packages = [];\n    gameState = \"playing\";\n    drone.x = WIDTH / 2;\n    drone.y = HEIGHT / 2;\n    newQuestion();\n    announce(\"Game restarted. \" + currentQuestion.text);\n  }\n\n  // ------------------------------\n  // UI Layout helpers (measureText)\n  // ------------------------------\n  function measureTextSize(text, font = \"16px sans-serif\") {\n    ctx.save();\n    ctx.font = font;\n    const metrics = ctx.measureText(text);\n    const w = metrics.width;\n    ctx.restore();\n    return w;\n  }\n\n  // ------------------------------\n  // Drawing Functions\n  // ------------------------------\n\n  function drawBackground(delta) {\n    // Sky\n    ctx.fillStyle = BG_COLOR;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Gentle moving clouds (two layers)\n    const t = performance.now() / 1000;\n    ctx.fillStyle = CLOUD_COLOR;\n    drawCloud(WIDTH * 0.2 + Math.sin(t * 0.3) * 20, 80, 60);\n    drawCloud(WIDTH * 0.7 + Math.cos(t * 0.2) * 30, 120, 50);\n    drawCloud(WIDTH * 0.5 + Math.sin(t * 0.15) * 40, 40, 40);\n  }\n\n  function drawCloud(cx, cy, size) {\n    ctx.beginPath();\n    ctx.ellipse(cx - size * 0.5, cy, size * 0.6, size * 0.45, 0, 0, Math.PI * 2);\n    ctx.ellipse(cx + size * 0.2, cy - size * 0.1, size * 0.7, size * 0.5, 0, 0, Math.PI * 2);\n    ctx.ellipse(cx + size * 0.7, cy, size * 0.5, size * 0.36, 0, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  function drawDrone() {\n    // Slight bob\n    const bob = Math.sin(performance.now() / 220) * 2;\n    ctx.save();\n    ctx.translate(drone.x, drone.y + bob);\n\n    // Drone body\n    ctx.fillStyle = DRONE_COLOR;\n    roundRect(ctx, -28, -12, 56, 24, 8, true, false);\n\n    // Drone dome\n    ctx.fillStyle = \"#A9B0FF\";\n    ctx.beginPath();\n    ctx.arc(0, -6, 12, Math.PI, 2 * Math.PI);\n    ctx.fill();\n\n    // Propellers - wacky shapes\n    ctx.save();\n    ctx.translate(-24, -10);\n    ctx.rotate(drone.propellerAngle);\n    drawPropeller(ctx);\n    ctx.restore();\n\n    ctx.save();\n    ctx.translate(24, -10);\n    ctx.rotate(-drone.propellerAngle);\n    drawPropeller(ctx);\n    ctx.restore();\n\n    // Eyes / face (funny)\n    ctx.fillStyle = \"#123456\";\n    ctx.beginPath();\n    ctx.arc(-8, -2, 3.2, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(8, -2, 3.2, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.restore();\n\n    // Propeller angle animation\n    drone.propellerAngle += 0.18 + Math.abs(drone.vx) * 0.02 + Math.abs(drone.vy) * 0.02;\n  }\n\n  function drawPropeller(ctxLocal) {\n    ctxLocal.fillStyle = \"rgba(0,0,0,0.15)\";\n    ctxLocal.beginPath();\n    ctxLocal.ellipse(0, 0, 20, 6, 0, 0, Math.PI * 2);\n    ctxLocal.fill();\n  }\n\n  function roundRect(ctxLocal, x, y, w, h, r, fill, stroke) {\n    ctxLocal.beginPath();\n    ctxLocal.moveTo(x + r, y);\n    ctxLocal.arcTo(x + w, y, x + w, y + h, r);\n    ctxLocal.arcTo(x + w, y + h, x, y + h, r);\n    ctxLocal.arcTo(x, y + h, x, y, r);\n    ctxLocal.arcTo(x, y, x + w, y, r);\n    ctxLocal.closePath();\n    if (fill) ctxLocal.fill();\n    if (stroke) ctxLocal.stroke();\n  }\n\n  function drawPackages(delta) {\n    packages.forEach((p, i) => {\n      if (!p.alive) return;\n      // update position\n      p.x += p.vx * delta;\n      p.y += p.vy * delta;\n      // drift horizontally gently\n      p.vx += (Math.random() - 0.5) * 0.01;\n      p.vx = clamp(p.vx, -0.6, 0.6);\n\n      // Draw package shadow\n      ctx.fillStyle = \"rgba(0,0,0,0.08)\";\n      ctx.beginPath();\n      ctx.ellipse(p.x, p.y + p.h / 2 + 6, p.w * 0.4, 6, 0, 0, Math.PI * 2);\n      ctx.fill();\n\n      // package box\n      ctx.fillStyle = p.color;\n      roundRect(ctx, p.x - p.w / 2, p.y - p.h / 2, p.w, p.h, 6, true, false);\n\n      // label band\n      ctx.fillStyle = \"rgba(255,255,255,0.85)\";\n      roundRect(ctx, p.x - p.w / 2 + 8, p.y - 10, p.w - 16, 20, 4, true, false);\n\n      // value text\n      ctx.fillStyle = TEXT_COLOR;\n      ctx.font = \"18px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillText(String(p.value), p.x, p.y);\n\n      // If package is off-screen below, respawn above\n      if (p.y - p.h / 2 > HEIGHT + 40) {\n        p.y = -40;\n        p.x = 40 + Math.random() * (WIDTH - 80);\n      }\n    });\n  }\n\n  // ------------------------------\n  // UI Drawing (score, lives, audio, instructions)\n  // ------------------------------\n  let restartButtonRect = null;\n\n  function drawUI() {\n    // Score top-left\n    ctx.font = \"20px sans-serif\";\n    ctx.textBaseline = \"middle\";\n    ctx.textAlign = \"left\";\n\n    const scoreText = `Correct: ${correctCount}/${GOAL_CORRECT}`;\n    const scoreW = measureTextSize(scoreText, \"20px sans-serif\");\n    const scorePad = 10;\n    const scoreBox = { x: 10, y: 10, w: scoreW + scorePad * 2, h: 36 };\n\n    ctx.fillStyle = UI_BG;\n    roundRect(ctx, scoreBox.x, scoreBox.y, scoreBox.w, scoreBox.h, 8, true, false);\n    ctx.fillStyle = TEXT_COLOR;\n    ctx.fillText(scoreText, scoreBox.x + scorePad, scoreBox.y + scoreBox.h / 2);\n\n    // Lives top-right\n    const livesText = `Lives: ${Math.max(0, MAX_WRONG - wrongCount)}`;\n    const livesW = measureTextSize(livesText, \"20px sans-serif\");\n    const livesPad = 10;\n    const livesBox = { x: WIDTH - livesW - livesPad * 2 - 10, y: 10, w: livesW + livesPad * 2, h: 36 };\n    ctx.fillStyle = UI_BG;\n    roundRect(ctx, livesBox.x, livesBox.y, livesBox.w, livesBox.h, 8, true, false);\n    ctx.fillStyle = TEXT_COLOR;\n    ctx.textAlign = \"left\";\n    ctx.fillText(livesText, livesBox.x + livesPad, livesBox.y + livesBox.h / 2);\n\n    // Audio indicator top-center\n    const audioText = audioEnabled ? \"Audio: On (M)\" : \"Audio: Off (M)\";\n    ctx.font = \"16px sans-serif\";\n    const audioW = measureTextSize(audioText, \"16px sans-serif\");\n    const audioPad = 8;\n    let audioX = Math.floor((WIDTH - audioW - audioPad * 2) / 2);\n    const audioBox = { x: audioX, y: 12, w: audioW + audioPad * 2, h: 30 };\n\n    // Ensure 10px spacing between audioBox and scoreBox/livesBox\n    if (audioBox.x - (scoreBox.x + scoreBox.w) < 10) {\n      audioBox.x = scoreBox.x + scoreBox.w + 10;\n    }\n    if ((livesBox.x - (audioBox.x + audioBox.w)) < 10) {\n      audioBox.x = livesBox.x - audioBox.w - 10;\n    }\n    ctx.fillStyle = UI_BG;\n    roundRect(ctx, audioBox.x, audioBox.y, audioBox.w, audioBox.h, 8, true, false);\n    ctx.fillStyle = TEXT_COLOR;\n    ctx.textAlign = \"left\";\n    ctx.fillText(audioText, audioBox.x + audioPad, audioBox.y + audioBox.h / 2);\n\n    // Current Question center-top below the audio\n    ctx.font = \"22px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"top\";\n    const qText = currentQuestion ? currentQuestion.text : \"\";\n    const qW = measureTextSize(qText, \"22px sans-serif\");\n    const qPad = 12;\n    const qBox = {\n      x: Math.floor((WIDTH - qW - qPad * 2) / 2),\n      y: audioBox.y + audioBox.h + 8,\n      w: qW + qPad * 2,\n      h: 40\n    };\n    ctx.fillStyle = UI_BG;\n    roundRect(ctx, qBox.x, qBox.y, qBox.w, qBox.h, 8, true, false);\n    ctx.fillStyle = TEXT_COLOR;\n    ctx.fillText(qText, qBox.x + qBox.w / 2, qBox.y + 8);\n\n    // Place instructions bottom-center with multi-line support\n    const instructions = [\n      \"Controls: Arrow keys or WASD to fly. Space to pick up a package.\",\n      \"You can also click or press 1/2/3 to pick the left/middle/right package.\",\n      `Goal: Collect ${GOAL_CORRECT} correct packages. Wrong picks allowed: ${MAX_WRONG}.`,\n      \"Press M to toggle audio. Press R to restart.\"\n    ];\n    ctx.font = \"16px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"top\";\n    const lineHeight = 20;\n    const maxLineWidth = WIDTH - 40;\n    // Compute width as max of lines\n    let maxW = 0;\n    const measuredLines = instructions.map((line) => {\n      const w = Math.min(measureTextSize(line, \"16px sans-serif\"), maxLineWidth);\n      if (w > maxW) maxW = w;\n      return { line, w };\n    });\n    const instrW = maxW + 24;\n    const instrH = instructions.length * lineHeight + 18;\n    const instrX = Math.floor((WIDTH - instrW) / 2);\n    const instrY = HEIGHT - instrH - 10;\n    ctx.fillStyle = \"rgba(255,255,255,0.92)\";\n    roundRect(ctx, instrX, instrY, instrW, instrH, 10, true, false);\n    ctx.fillStyle = TEXT_COLOR;\n    instructions.forEach((line, idx) => {\n      ctx.fillText(line, WIDTH / 2, instrY + 10 + idx * lineHeight);\n    });\n  }\n\n  // ------------------------------\n  // End Screens\n  // ------------------------------\n  function drawEndScreen() {\n    ctx.save();\n    // Dim background\n    ctx.fillStyle = \"rgba(8,12,20,0.48)\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Panel\n    const panelW = 520;\n    const panelH = 260;\n    const panelX = (WIDTH - panelW) / 2;\n    const panelY = (HEIGHT - panelH) / 2;\n    ctx.fillStyle = \"rgba(255,255,255,0.98)\";\n    roundRect(ctx, panelX, panelY, panelW, panelH, 12, true, false);\n\n    // Title\n    ctx.fillStyle = TEXT_COLOR;\n    ctx.font = \"28px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"top\";\n\n    if (gameState === \"victory\") {\n      ctx.fillText(\"\ud83c\udf89 Victory! \ud83c\udf89\", panelX + panelW / 2, panelY + 18);\n      ctx.font = \"20px sans-serif\";\n      ctx.fillText(`You collected ${correctCount} correct packages!`, panelX + panelW / 2, panelY + 62);\n    } else {\n      ctx.fillText(\"Game Over\", panelX + panelW / 2, panelY + 18);\n      ctx.font = \"20px sans-serif\";\n      ctx.fillText(`You made ${wrongCount} incorrect picks.`, panelX + panelW / 2, panelY + 62);\n    }\n\n    // Small friendly message\n    ctx.font = \"16px sans-serif\";\n    ctx.fillText(\"Great flying! Try again to beat your best.\", panelX + panelW / 2, panelY + 110);\n\n    // Restart button\n    const btnW = 180;\n    const btnH = 46;\n    const btnX = panelX + panelW / 2 - btnW / 2;\n    const btnY = panelY + panelH - btnH - 28;\n    restartButtonRect = { x: btnX, y: btnY, w: btnW, h: btnH };\n\n    ctx.fillStyle = \"#6C6CE5\";\n    roundRect(ctx, btnX, btnY, btnW, btnH, 8, true, false);\n    ctx.fillStyle = \"#FFFFFF\";\n    ctx.font = \"18px sans-serif\";\n    ctx.fillText(\"Restart (R)\", btnX + btnW / 2, btnY + 12);\n\n    // Extra small instruction below button\n    ctx.font = \"14px sans-serif\";\n    ctx.fillStyle = \"#333\";\n    ctx.fillText(\"Or press R key\", panelX + panelW / 2, btnY + btnH + 6);\n\n    ctx.restore();\n  }\n\n  // ------------------------------\n  // Game Loop\n  // ------------------------------\n  function update(delta) {\n    if (gameState !== \"playing\") return;\n\n    // Drone movement\n    const moveX = (keys[\"arrowleft\"] || keys[\"a\"]) ? -1 : (keys[\"arrowright\"] || keys[\"d\"]) ? 1 : 0;\n    const moveY = (keys[\"arrowup\"] || keys[\"w\"]) ? -1 : (keys[\"arrowdown\"] || keys[\"s\"]) ? 1 : 0;\n    drone.vx = moveX * drone.speed;\n    drone.vy = moveY * drone.speed;\n\n    drone.x += drone.vx * delta;\n    drone.y += drone.vy * delta;\n    drone.x = clamp(drone.x, drone.radius + 6, WIDTH - drone.radius - 6);\n    drone.y = clamp(drone.y, drone.radius + 20, HEIGHT - drone.radius - 100);\n\n    // Spawn packages occasionally if less than 3 alive\n    spawnTimer += delta;\n    const aliveCount = packages.filter((p) => p.alive).length;\n    if (spawnTimer > PACKAGE_SPAWN_INTERVAL && aliveCount < 3) {\n      spawnTimer = 0;\n      // Spawn a new package with wrong or correct occasionally\n      const p = {\n        id: Math.random().toString(36).slice(2, 9),\n        x: 40 + Math.random() * (WIDTH - 80),\n        y: -30,\n        w: 82,\n        h: 54,\n        vx: (Math.random() - 0.5) * 0.4,\n        vy: PACKAGE_SPEED_MIN + Math.random() * (PACKAGE_SPEED_MAX - PACKAGE_SPEED_MIN),\n        value: Math.random() < 0.4 ? currentQuestion.answer : Math.max(0, currentQuestion.answer + (Math.floor(Math.random() * 7) - 3)),\n        color: PACKAGE_COLORS[Math.floor(Math.random() * PACKAGE_COLORS.length)],\n        alive: true\n      };\n      packages.push(p);\n    }\n\n    // Check automatic collision pickup (if drone touches package, automatically pick in case player wants)\n    packages.forEach((p) => {\n      if (p.alive && circleRectCollision(drone.x, drone.y, drone.radius, p)) {\n        // gentle auto pickup to avoid requiring precise Space presses\n        pickPackage(p);\n      }\n    });\n  }\n\n  function render(now) {\n    const dt = now - lastTime;\n    const delta = dt / 16.6667; // approx frames\n    lastTime = now;\n\n    // Draw scene\n    drawBackground(delta);\n    drawPackages(delta);\n    drawDrone();\n    drawUI();\n\n    // Draw helpful targeting indicator near drone\n    ctx.save();\n    ctx.strokeStyle = \"rgba(18,52,86,0.12)\";\n    ctx.beginPath();\n    ctx.arc(drone.x, drone.y, drone.radius + 8, 0, Math.PI * 2);\n    ctx.stroke();\n    ctx.restore();\n\n    // If end screen\n    if (gameState === \"victory\" || gameState === \"gameover\") {\n      drawEndScreen();\n    }\n\n    // Update\n    update(delta);\n\n    requestAnimationFrame(render);\n  }\n\n  // ------------------------------\n  // Start the Game\n  // ------------------------------\n  try {\n    newQuestion();\n    announce(\"Welcome! Solve the math questions by picking the correct packages. Use arrow keys or WASD to fly. Press R to restart anytime.\");\n    lastTime = performance.now();\n    requestAnimationFrame(render);\n  } catch (e) {\n    console.error(\"Error starting the game:\", e);\n    ctx.fillStyle = \"#000\";\n    ctx.font = \"18px sans-serif\";\n    ctx.fillText(\"An error occurred starting the game. Please reload.\", 20, 40);\n    announce(\"An error occurred starting the game. Please reload the page.\");\n  }\n})();\n---\n",
  "improve_response_tokens": 17847,
  "formatted_code": true,
  "formatting_response_tokens": 19133,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}