# Game of the Day - 2025-11-08

## Metadata
- **Generated Date:** 2025-11-08
- **Generated Time:** 2025-11-08T00:26:22.851045
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-11-08.js
- **File Size:** 29376 bytes
- **Tokens Used:** 10114

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** âœ… PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** âœ… NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
â€¢ Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
â€¢ Use visually calming and interesting and wacky elements.
â€¢ Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
â€¢ Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
â€¢ Have a game area exactly 720px wide by 480px tall.
â€¢ Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
â€¢ Use modern JavaScript practices and avoid minification.
â€¢ Include proper error handling for audio and resource loading.
â€¢ Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
â€¢ Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
â€¢ Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
â€¢ Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
â€¢ Generate all sounds using Web Audio API oscillators and filters.
â€¢ Include proper error handling for audio context creation.
â€¢ Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
â€¢ Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-11-08.js` - The playable game
- `2025-11-08.meta.json` - Machine-readable metadata
- `2025-11-08.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 20836

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 22636

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** âœ… PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Drone Math Harvest - Canvas Game
  // Renders inside element with id "game-of-the-day-stage"
  // Designed for children ages 7-9. Use arrow keys/WASD to fly the drone and collect the correct answer balloon.
  // Goal: collect 10 correct balloons. Lose: collect 3 wrong balloons. Restart from end screens.

  // -----------------------
  // Basic setup and safety
  // -----------------------
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Container element with id "game-of-the-day-stage" not found.');
    return;
  }

  // Clear container and create canvas
  container.innerHTML = '';
  const canvas = document.createElement('canvas');
  canvas.width = 720;
  canvas.height = 480;
  canvas.style.width = '720px';
  canvas.style.height = '480px';
  canvas.setAttribute('role', 'img'); // accessibility role
  canvas.setAttribute('aria-label', 'Drone Math Harvest. Use arrow keys to fly the drone. Collect the balloon with the correct answer. Press number keys 1-4 to choose answers.'); 
  canvas.tabIndex = 0; // allow keyboard focus
  container.appendChild(canvas);

  const ctx = canvas.getContext('2d');

  // Fonts
  const TITLE_FONT = 'bold 22px Verdana, sans-serif';
  const UI_FONT = 'bold 20px Verdana, sans-serif';
  const BODY_FONT = '16px Verdana, sans-serif'; // >=14px
  const SMALL_FONT = '14px Verdana, sans-serif';

  // UI padding constraints
  const UI_PADDING = 12; // ensure 10px+ spacing

  // -----------------------
  // Audio setup with safe handling
  // -----------------------
  let audioEnabled = true;
  let audioContext = null;
  let masterGain = null;
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (!AudioContext) {
      audioEnabled = false;
      console.warn('Web Audio API not supported in this browser.');
    } else {
      audioContext = new AudioContext();
      masterGain = audioContext.createGain();
      masterGain.gain.value = 0.08; // gentle background volume
      masterGain.connect(audioContext.destination);
      // Create a gentle ambient background oscillator (very subtle)
      const ambient = audioContext.createOscillator();
      ambient.type = 'sine';
      ambient.frequency.value = 120; // low frequency
      const ambientGain = audioContext.createGain();
      ambientGain.gain.value = 0.002; // very soft
      ambient.connect(ambientGain);
      ambientGain.connect(masterGain);
      ambient.start();
      // Fade in volume slightly to avoid click
      masterGain.gain.setValueAtTime(0.0, audioContext.currentTime);
      masterGain.gain.linearRampToValueAtTime(0.08, audioContext.currentTime + 0.5);
    }
  } catch (err) {
    console.error('AudioContext creation failed:', err);
    audioEnabled = false;
  }

  // Helper: play a short tone (frequency in Hz, duration in seconds, type)
  function playTone({ freq = 440, duration = 0.2, type = 'sine', volume = 0.18 }) {
    if (!audioEnabled || !audioContext) return;
    try {
      const o = audioContext.createOscillator();
      const g = audioContext.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = 0;
      o.connect(g);
      g.connect(masterGain);
      const now = audioContext.currentTime;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(volume, now + 0.02);
      o.start(now);
      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);
      o.stop(now + duration + 0.02);
    } catch (err) {
      console.warn('Error playing tone:', err);
    }
  }

  // Correct ascending chime
  function playCorrectSound() {
    if (!audioEnabled) return;
    // play three quick ascending tones
    playTone({ freq: 440, duration: 0.08, type: 'triangle', volume: 0.14 });
    setTimeout(() => playTone({ freq: 550, duration: 0.08, type: 'triangle', volume: 0.14 }), 80);
    setTimeout(() => playTone({ freq: 660, duration: 0.14, type: 'sine', volume: 0.16 }), 160);
  }

  // Incorrect buzz
  function playIncorrectSound() {
    if (!audioEnabled) return;
    // a short descending buzz
    playTone({ freq: 220, duration: 0.2, type: 'square', volume: 0.14 });
    setTimeout(() => playTone({ freq: 180, duration: 0.16, type: 'square', volume: 0.12 }), 60);
  }

  // Click-ish UI sound
  function playClick() {
    if (!audioEnabled) return;
    playTone({ freq: 880, duration: 0.06, type: 'sine', volume: 0.06 });
  }

  // -----------------------
  // Game variables
  // -----------------------
  let keys = {};
  let mouse = { x: 0, y: 0, down: false };
  let gameState = 'menu'; // 'playing', 'gameover', 'victory', 'menu'
  let score = 0;
  let wrong = 0;
  const MAX_SCORE = 10;
  const MAX_WRONG = 3;
  let roundQuestion = null; // {a, b, op, answer}
  let balloons = []; // array of answer balloon objects
  let drone = null; // player object
  let lastSpawnTime = 0;
  let spawnInterval = 0; // not used maybe
  let roundStartTime = 0;
  let showAudioMutedFlash = false;
  let audioToggleRect = null; // area for audio toggle on canvas
  let lastFrameTime = performance.now();

  // -----------------------
  // Utility functions
  // -----------------------
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function clamp(v, a, b) {
    return Math.max(a, Math.min(b, v));
  }

  // Accessibility: update aria-label with dynamic info
  function updateAriaLabel() {
    const label = `Drone Math Harvest. Score ${score}. Wrong ${wrong}. ${gameState === 'playing' ? `Question: ${roundQuestion && roundQuestion.text ? roundQuestion.text : ''}` : gameState}. Use arrow keys to fly the drone or press keys 1 to 4 to choose answers.`;
    canvas.setAttribute('aria-label', label);
  }

  // -----------------------
  // Game objects creation
  // -----------------------
  function createQuestion() {
    // Create a friendly arithmetic question appropriate for ages 7-9
    // Use addition and subtraction with small numbers
    const op = Math.random() < 0.6 ? '+' : '-';
    let a, b;
    if (op === '+') {
      a = randInt(1, 12);
      b = randInt(1, 12);
    } else {
      a = randInt(5, 15);
      b = randInt(1, a - 1);
    }
    const answer = op === '+' ? a + b : a - b;
    const text = `${a} ${op} ${b} = ?`;
    return { a, b, op, answer, text };
  }

  function spawnBalloonsForQuestion(q) {
    balloons = [];
    const correctIndex = randInt(0, 3);
    const answers = new Set();
    answers.add(q.answer);
    for (let i = 0; i < 4; i++) {
      let val;
      if (i === correctIndex) {
        val = q.answer;
      } else {
        // generate plausible wrong answers
        do {
          const delta = randInt(-6, 6);
          val = q.answer + delta;
        } while (val < 0 || answers.has(val));
        answers.add(val);
      }

      // Position balloons in a spread-out layout to avoid overlap with UI
      const marginX = 80;
      const marginY = 90;
      const x = marginX + i * ((canvas.width - marginX * 2) / 4) + randInt(-20, 20);
      const y = randInt(120, 300) + (i % 2 === 0 ? -20 : 20);
      const radius = 34;
      const color = `hsl(${randInt(160, 320)} ${randInt(45, 75)}% ${randInt(50, 70)}%)`;
      const vy = randInt(-8, 8) / 100 + (i % 2 === 0 ? -0.15 : -0.05);
      balloons.push({
        x,
        y,
        vy,
        targetVy: vy,
        radius,
        value: val,
        color,
        id: i + 1,
        floatingOffset: Math.random() * Math.PI * 2
      });
    }
  }

  function resetDrone() {
    drone = {
      x: canvas.width / 2,
      y: canvas.height - 80,
      vx: 0,
      vy: 0,
      speed: 2.6,
      radius: 22,
      tilt: 0 // for visual tilt
    };
  }

  // -----------------------
  // Start / restart
  // -----------------------
  function startGame() {
    score = 0;
    wrong = 0;
    gameState = 'playing';
    roundQuestion = createQuestion();
    spawnBalloonsForQuestion(roundQuestion);
    resetDrone();
    roundStartTime = performance.now();
    updateAriaLabel();
    playClick();
  }

  function endGame(victory) {
    gameState = victory ? 'victory' : 'gameover';
    updateAriaLabel();
    playClick();
  }

  // -----------------------
  // Collisions and answer handling
  // -----------------------
  function checkCollisions() {
    for (let i = 0; i < balloons.length; i++) {
      const b = balloons[i];
      // simple circle collision between drone and balloon
      const dx = b.x - drone.x;
      const dy = b.y - drone.y;
      const distSq = dx * dx + dy * dy;
      const minDist = b.radius + drone.radius;
      if (distSq <= minDist * minDist) {
        // collide
        handleBalloonCollected(b);
        return;
      }
    }
  }

  function handleBalloonCollected(b) {
    if (!b) return;
    const isCorrect = b.value === roundQuestion.answer;
    // small visual pop and sound
    if (isCorrect) {
      score += 1;
      playCorrectSound();
    } else {
      wrong += 1;
      playIncorrectSound();
    }
    // simple balloon pop animation: remove balloon and trigger next question or end
    balloons = balloons.filter(bb => bb !== b);
    // after short delay, either spawn next question or end
    setTimeout(() => {
      if (score >= MAX_SCORE) {
        endGame(true);
        return;
      }
      if (wrong >= MAX_WRONG) {
        endGame(false);
        return;
      }
      roundQuestion = createQuestion();
      spawnBalloonsForQuestion(roundQuestion);
      updateAriaLabel();
    }, 220);
  }

  // Keyboard selection fallback (1-4)
  function selectAnswerByIndex(index) {
    const b = balloons[index];
    if (b) {
      handleBalloonCollected(b);
    }
  }

  // -----------------------
  // Input handling
  // -----------------------
  canvas.addEventListener('keydown', (e) => {
    keys[e.key] = true;
    // Ensure audio context resumes on keyboard interaction for some browsers
    if (audioContext && audioContext.state === 'suspended') {
      audioContext.resume().catch(() => {});
    }
    // Number keys to select balloon 1-4
    if (gameState === 'playing') {
      if (e.key >= '1' && e.key <= '4') {
        const idx = parseInt(e.key, 10) - 1;
        selectAnswerByIndex(idx);
      } else if (e.key === 'Enter') {
        // attempt center-pick: pick balloon with smallest distance
        if (balloons.length > 0) {
          let closest = balloons[0];
          let bestDist = Infinity;
          for (const b of balloons) {
            const d = (b.x - drone.x) ** 2 + (b.y - drone.y) ** 2;
            if (d < bestDist) {
              bestDist = d;
              closest = b;
            }
          }
          handleBalloonCollected(closest);
        }
      } else if (e.key === 'm') {
        toggleAudio();
      }
    } else {
      // End screen: Enter or Space restarts
      if (e.key === 'Enter' || e.key === ' ') {
        startGame();
      }
    }
  });
  canvas.addEventListener('keyup', (e) => {
    delete keys[e.key];
  });

  // Mouse
  canvas.addEventListener('mousemove', (e) => {
    const r = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - r.left) * (canvas.width / r.width);
    mouse.y = (e.clientY - r.top) * (canvas.height / r.height);
  });
  canvas.addEventListener('mousedown', (e) => {
    mouse.down = true;
    // If clicking audio toggle on top-right
    if (audioToggleRect && pointInRect(mouse.x, mouse.y, audioToggleRect)) {
      toggleAudio();
      return;
    }
    // If end screens show, check for restart button click
    if ((gameState === 'gameover' || gameState === 'victory')) {
      const btn = getEndScreenButtonRect();
      if (pointInRect(mouse.x, mouse.y, btn)) {
        startGame();
        return;
      }
    }
    // If playing and clicking on a balloon, pick it
    if (gameState === 'playing') {
      for (let i = 0; i < balloons.length; i++) {
        const b = balloons[i];
        const dx = mouse.x - b.x;
        const dy = mouse.y - b.y;
        if (dx * dx + dy * dy <= b.radius * b.radius) {
          handleBalloonCollected(b);
          return;
        }
      }
    }
  });
  canvas.addEventListener('mouseup', () => { mouse.down = false; });

  // Helper: rectangle tests
  function pointInRect(px, py, rect) {
    if (!rect) return false;
    return px >= rect.x && px <= rect.x + rect.w && py >= rect.y && py <= rect.y + rect.h;
  }

  // Toggle audio (visual cue)
  function toggleAudio() {
    if (!audioContext) {
      audioEnabled = false;
      showAudioMutedFlash = true;
      setTimeout(() => (showAudioMutedFlash = false), 600);
      return;
    }
    if (audioContext.state === 'suspended') {
      audioContext.resume().then(() => {
        audioEnabled = true;
        showAudioMutedFlash = true;
        setTimeout(() => (showAudioMutedFlash = false), 400);
      }).catch(() => {
        audioEnabled = false;
      });
    } else {
      audioContext.suspend().then(() => {
        audioEnabled = false;
        showAudioMutedFlash = true;
        setTimeout(() => (showAudioMutedFlash = false), 400);
      }).catch(() => {
        audioEnabled = false;
      });
    }
    playClick();
  }

  // -----------------------
  // Drawing helpers
  // -----------------------
  function drawRoundedRect(x, y, w, h, r, fillStyle, strokeStyle) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fillStyle) {
      ctx.fillStyle = fillStyle;
      ctx.fill();
    }
    if (strokeStyle) {
      ctx.strokeStyle = strokeStyle;
      ctx.stroke();
    }
  }

  // Draw background: calming sky with wacky clouds and simple hills
  function drawBackground(time) {
    // gradient sky
    const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
    g.addColorStop(0, '#eaf6ff');
    g.addColorStop(1, '#dfeef6');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // sun: subtle
    ctx.beginPath();
    ctx.fillStyle = '#fff8c6';
    ctx.shadowColor = 'rgba(255, 230, 120, 0.25)';
    ctx.shadowBlur = 30;
    ctx.arc(90, 80, 36, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;

    // rolling hills (wacky shapes)
    ctx.fillStyle = '#cdeecf';
    ctx.beginPath();
    ctx.moveTo(0, 330);
    ctx.quadraticCurveTo(120, 300, 240, 340);
    ctx.quadraticCurveTo(360, 380, 480, 340);
    ctx.quadraticCurveTo(600, 300, 720, 330);
    ctx.lineTo(720, 480);
    ctx.lineTo(0, 480);
    ctx.closePath();
    ctx.fill();

    // floating clouds (wacky)
    ctx.fillStyle = '#ffffff';
    for (let i = 0; i < 5; i++) {
      const cx = (i * 160 + (time * 0.03 * (i % 2 === 0 ? 1 : -1))) % 840 - 60;
      const cy = 60 + (i % 2) * 18;
      drawCloud(cx, cy, 28 + (i % 3) * 8);
    }
  }

  function drawCloud(cx, cy, s) {
    ctx.beginPath();
    ctx.moveTo(cx - s * 1.2, cy);
    ctx.arc(cx - s * 0.6, cy - s * 0.2, s * 0.7, Math.PI * 0.5, Math.PI * 1.5);
    ctx.arc(cx + s * 0.1, cy - s * 0.4, s * 0.9, Math.PI * 1.0, Math.PI * 1.9);
    ctx.arc(cx + s * 0.9, cy - s * 0.1, s * 0.7, Math.PI * 1.5, Math.PI * 0.5);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.02)';
    ctx.stroke();
  }

  // Draw drone
  function drawDrone(dr, time) {
    const x = dr.x;
    const y = dr.y;
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(dr.tilt * 0.02);
    // shadow
    ctx.beginPath();
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.ellipse(0, 30, dr.radius * 1.2, dr.radius * 0.5, 0, 0, Math.PI * 2);
    ctx.fill();

    // body
    ctx.beginPath();
    ctx.fillStyle = '#2a9df4';
    ctx.strokeStyle = '#083e6d';
    ctx.lineWidth = 2;
    ctx.moveTo(-28, -6);
    ctx.quadraticCurveTo(0, -36, 28, -6); // canopy
    ctx.quadraticCurveTo(0, 10, -28, -6);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // window
    ctx.beginPath();
    ctx.fillStyle = '#bde9ff';
    ctx.ellipse(0, -2, 10, 7, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
    ctx.stroke();

    // propellers: wacky spinning
    for (let i = -1; i <= 1; i += 2) {
      const px = i * 26;
      const py = -12;
      ctx.beginPath();
      ctx.fillStyle = '#f6f6f6';
      ctx.ellipse(px, py, 12, 6, 0, 0, Math.PI * 2);
      ctx.fill();
      // blades
      ctx.save();
      ctx.translate(px, py);
      ctx.rotate((time / 120) * (i === -1 ? 1 : -1));
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.fillRect(-18, -2, 36, 4);
      ctx.restore();
    }
    ctx.restore();
  }

  // Draw balloons
  function drawBalloons(balloonsArr, time) {
    for (const b of balloonsArr) {
      // floating movement
      const floaty = Math.sin((time / 600) + b.floatingOffset) * 4;
      const bx = b.x;
      const by = b.y + floaty;
      // string
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.lineWidth = 2;
      ctx.moveTo(bx, by + b.radius - 2);
      ctx.quadraticCurveTo(bx + 8, by + b.radius + 18, bx + 4, by + b.radius + 32);
      ctx.stroke();

      // balloon
      ctx.beginPath();
      ctx.fillStyle = b.color;
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.lineWidth = 1;
      ctx.ellipse(bx, by, b.radius, b.radius * 1.14, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // highlight patch
      ctx.beginPath();
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.ellipse(bx - b.radius * 0.25, by - b.radius * 0.3, b.radius * 0.3, b.radius * 0.14, 0, 0, Math.PI * 2);
      ctx.fill();

      // Number label (body text)
      ctx.font = 'bold 18px Verdana, sans-serif';
      ctx.fillStyle = '#083e6d';
      const text = String(b.value);
      const metrics = ctx.measureText(text);
      ctx.fillText(text, bx - metrics.width / 2, by + 6);

      // Small index number for keyboard selection: 1-4
      ctx.font = SMALL_FONT;
      ctx.fillStyle = 'rgba(0,0,0,0.4)';
      const idxText = `(${b.id})`;
      const idxW = ctx.measureText(idxText).width;
      ctx.fillText(idxText, bx - idxW / 2, by + b.radius * 1.5 + 8);
    }
  }

  // Draw top-left score and top-right lives and audio control
  function drawUI() {
    // Score - top-left
    ctx.font = UI_FONT;
    ctx.textBaseline = 'top';
    const scoreText = `Score: ${score}/${MAX_SCORE}`;
    const scW = ctx.measureText(scoreText).width;
    const scRect = {
      x: UI_PADDING,
      y: UI_PADDING,
      w: scW + 16,
      h: 36
    };
    drawRoundedRect(scRect.x, scRect.y, scRect.w, scRect.h, 8, 'rgba(255,255,255,0.9)', 'rgba(0,0,0,0.06)');
    ctx.fillStyle = '#083e6d';
    ctx.fillText(scoreText, scRect.x + 8, scRect.y + 6);

    // Lives/wrong - top-right
    ctx.font = UI_FONT;
    const livesText = `Lives left: ${Math.max(0, MAX_WRONG - wrong)}`;
    const lvW = ctx.measureText(livesText).width;
    const lvRect = {
      x: canvas.width - lvW - UI_PADDING - 16,
      y: UI_PADDING,
      w: lvW + 16,
      h: 36
    };
    drawRoundedRect(lvRect.x, lvRect.y, lvRect.w, lvRect.h, 8, 'rgba(255,255,255,0.9)', 'rgba(0,0,0,0.06)');
    ctx.fillStyle = '#083e6d';
    ctx.fillText(livesText, lvRect.x + 8, lvRect.y + 6);

    // Audio toggle small icon near lives (left of it)
    const audSize = 28;
    const audX = lvRect.x - audSize - 10;
    const audY = UI_PADDING + (36 - audSize) / 2;
    audioToggleRect = { x: audX, y: audY, w: audSize, h: audSize };
    ctx.beginPath();
    drawRoundedRect(audX, audY, audSize, audSize, 6, audioEnabled ? 'rgba(200,255,200,0.95)' : 'rgba(255,200,200,0.95)', 'rgba(0,0,0,0.06)');
    ctx.fillStyle = audioEnabled ? '#036a0d' : '#8b0000';
    ctx.font = 'bold 14px Verdana, sans-serif';
    const spText = audioEnabled ? 'ðŸ”Š' : 'ðŸ”ˆ';
    const spW = ctx.measureText(spText).width;
    ctx.fillText(spText, audX + (audSize - spW) / 2, audY + 6);

    // If audio is disabled, show a small visual cue near bottom
    if (!audioEnabled || showAudioMutedFlash) {
      ctx.font = SMALL_FONT;
      ctx.fillStyle = showAudioMutedFlash ? '#ff7700' : '#8b0000';
      const hint = audioEnabled ? 'Audio on' : 'Audio off (press M)';
      const w = ctx.measureText(hint).width;
      const hx = canvas.width - w - UI_PADDING - 6;
      const hy = UI_PADDING + 36 + 8;
      drawRoundedRect(hx - 6, hy - 4, w + 12, 26, 6, 'rgba(255,255,255,0.92)', 'rgba(0,0,0,0.06)');
      ctx.fillText(hint, hx, hy);
    }
  }

  // Bottom-center instructions - ensure non-overlap
  function drawInstructions() {
    ctx.font = BODY_FONT;
    ctx.textBaseline = 'top';
    const lines = [
      'Fly the friendly drone to the balloon that shows the correct answer.',
      'Use arrow keys or W/A/S/D to move. Press 1-4 to pick an answer, or click a balloon.',
      `Goal: collect ${MAX_SCORE} correct balloons. Lose after ${MAX_WRONG} wrong ones.`,
      'Press M to toggle audio. Press Enter to start / restart.'
    ];
    // measure widest
    let maxW = 0;
    for (const l of lines) {
      maxW = Math.max(maxW, ctx.measureText(l).width);
    }
    const rectW = maxW + 20;
    const rectH = lines.length * 22 + 18;
    const rectX = (canvas.width - rectW) / 2;
    const rectY = canvas.height - rectH - UI_PADDING;
    drawRoundedRect(rectX, rectY, rectW, rectH, 10, 'rgba(255,255,255,0.92)', 'rgba(0,0,0,0.06)');
    ctx.fillStyle = '#083e6d';
    let y = rectY + 8;
    for (const l of lines) {
      ctx.fillText(l, rectX + 10, y);
      y += 22;
    }
  }

  // End screen button rectangle calculation
  function getEndScreenButtonRect() {
    const w = 220;
    const h = 48;
    return {
      x: (canvas.width - w) / 2,
      y: canvas.height - 120,
      w,
      h
    };
  }

  // Render gameover or victory screen
  function drawEndScreen() {
    ctx.font = TITLE_FONT;
    ctx.textBaseline = 'top';
    // translucent overlay
    ctx.fillStyle = 'rgba(10, 20, 30, 0.35)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // message
    const title = gameState === 'victory' ? 'Mission Complete!' : 'Game Over';
    const subtitle = gameState === 'victory'
      ? `You collected ${score} correct balloons!`
      : `You made ${wrong} wrong picks. Score: ${score}`;

    // Title box
    ctx.font = TITLE_FONT;
    const tW = ctx.measureText(title).width;
    const titleX = (canvas.width - tW) / 2;
    const titleY = 120;
    drawRoundedRect(titleX - 14, titleY - 12, tW + 28, 50, 12, 'rgba(255,255,255,0.95)', 'rgba(0,0,0,0.06)');
    ctx.fillStyle = '#0d3b5a';
    ctx.fillText(title, titleX, titleY);

    // Subtitle
    ctx.font = BODY_FONT;
    const subW = ctx.measureText(subtitle).width;
    const subX = (canvas.width - subW) / 2;
    const subY = titleY + 58;
    drawRoundedRect(subX - 12, subY - 8, subW + 24, 40, 8, 'rgba(255,255,255,0.95)', 'rgba(0,0,0,0.04)');
    ctx.fillStyle = '#083e6d';
    ctx.fillText(subtitle, subX, subY);

    // Restart button
    const btn = getEndScreenButtonRect();
    drawRoundedRect(btn.x, btn.y, btn.w, btn.h, 10, 'rgba(255,255,255,0.98)', 'rgba(0,0,0,0.08)');
    ctx.font = UI_FONT;
    ctx.fillStyle = '#0266a6';
    const btText = 'Play Again (Enter)';
    const btW = ctx.measureText(btText).width;
    ctx.fillText(btText, btn.x + (btn.w - btW) / 2, btn.y + 10);
  }

  // Draw current question area - bottom-left area reserved to avoid overlap
  function drawQuestionPanel() {
    // place near center-top-ish to avoid overlapping balloons
    ctx.font = 'bold 20px Verdana, sans-serif';
    const qText = roundQuestion ? roundQuestion.text : '';
    const qW = ctx.measureText(qText).width;
    const boxW = qW + 40;
    const boxH = 48;
    const boxX = (canvas.width - boxW) / 2;
    const boxY = 18 + 36; // under top UI
    drawRoundedRect(boxX, boxY, boxW, boxH, 10, 'rgba(255,255,255,0.96)', 'rgba(0,0,0,0.04)');
    ctx.fillStyle = '#083e6d';
    ctx.fillText(qText, boxX + 20, boxY + 12);
    // Also show small hint for keyboard numbers
    ctx.font = SMALL_FONT;
    const hint = 'Press 1-4 or fly to the correct balloon';
    const hintW = ctx.measureText(hint).width;
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    ctx.fillText(hint, (canvas.width - hintW) / 2, boxY + boxH + 6);
  }

  // -----------------------
  // Game loop and updates
  // -----------------------
  function update(dt, t) {
    if (gameState !== 'playing') return;

    // Control drone
    const moveLeft = keys.ArrowLeft || keys.a || keys.A;
    const moveRight = keys.ArrowRight || keys.d || keys.D;
    const moveUp = keys.ArrowUp || keys.w || keys.W;
    const moveDown = keys.ArrowDown || keys.s || keys.S;

    const acc = 0.12;
    if (moveLeft) drone.vx -= acc;
    if (moveRight) drone.vx += acc;
    if (moveUp) drone.vy -= acc;
    if (moveDown) drone.vy += acc;

    // gentle damping
    drone.vx *= 0.96;
    drone.vy *= 0.96;

    // apply speed clamp
    drone.vx = clamp(drone.vx, -drone.speed, drone.speed);
    drone.vy = clamp(drone.vy, -drone.speed, drone.speed);

    drone.x += drone.vx * dt;
    drone.y += drone.vy * dt;

    // Keep inside canvas bounds (with padding)
    drone.x = clamp(drone.x, 30, canvas.width - 30);
    drone.y = clamp(drone.y, 80, canvas.height - 40);

    // tilt based on vx
    drone.tilt = drone.vx * 12;

    // Update balloons floating and slight random horizontal drift
    for (const b of balloons) {
      b.floatingOffset += dt * 0.001;
      b.y += b.vy * dt;
      // small horizontal drift to keep lively
      b.x += Math.sin((t + b.x) / 4000) * 0.3;

      // gentle bounce if hit bounds
      if (b.x < 40) b.x = 40;
      if (b.x > canvas.width - 40) b.x = canvas.width - 40;
      if (b.y < 90) b.y = 90;
      if (b.y > canvas.height - 120) b.y = canvas.height - 120;
    }

    // collision checks
    checkCollisions();
  }

  function render(t) {
    // Clear
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // draw background
    drawBackground(t);
    // draw balloons under drone to create depth
    drawBalloons(balloons, t);
    // draw drone on top
    if (drone) drawDrone(drone, t);
    // UI
    drawUI();
    // question panel
    if (gameState === 'playing') {
      drawQuestionPanel();
    }
    // instructions bottom
    drawInstructions();
    // end screens
    if (gameState === 'gameover' || gameState === 'victory') {
      drawEndScreen();
    }
  }

  function loop(now) {
    const dt = Math.min(50, now - lastFrameTime); // ms, capped for stability
    update(dt / 16.67, now); // normalize roughly to frame scaling
    render(now);
    lastFrameTime = now;
    requestAnimationFrame(loop);
  }

  // -----------------------
  // Initialization
  // -----------------------
  function init() {
    // Initial focus
    canvas.focus();

    // Friendly starting menu
    gameState = 'menu';
    score = 0;
    wrong = 0;
    roundQuestion = createQuestion();
    spawnBalloonsForQuestion(roundQuestion);
    resetDrone();

    // Start the animation loop
    requestAnimationFrame(loop);

    // Draw a simple initial frame immediately
    render(performance.now());
  }

  // Start when user interacts or immediately
  // Some browsers block AudioContext until user gesture; audio handling attempts to resume on first key or mouse.
  canvas.addEventListener('click', () => {
    if (gameState === 'menu') {
      startGame();
    }
  });

  // Show initial menu overlay drawn each frame from gameState === 'menu'
  function drawMenuOverlay() {
    // will be drawn inside render when gameState === 'menu'
    ctx.fillStyle = 'rgba(255,255,255,0.96)';
    drawRoundedRect(80, 80, canvas.width - 160, canvas.height - 160, 12, 'rgba(255,255,255,0.96)', 'rgba(0,0,0,0.06)');
    ctx.font = 'bold 28px Verdana, sans-serif';
    ctx.fillStyle = '#084b6b';
    const title = 'Drone Math Harvest';
    const w = ctx.measureText(title).width;
    ctx.fillText(title, (canvas.width - w) / 2, 120);

    ctx.font = '18px Verdana, sans-serif';
    ctx.fillStyle = '#083e6d';
    const lines = [
      'Help the friendly drone collect the balloon with the correct answer.',
      'Use arrow keys or W/A/S/D to move. Press 1-4 to choose answers.',
      `Goal: collect ${MAX_SCORE} correct balloons. Lose after ${MAX_WRONG} wrong picks.`,
      'Click anywhere or press Enter to start.'
    ];
    let y = 180;
    for (const line of lines) {
      const lw = ctx.measureText(line).width;
      ctx.fillText(line, (canvas.width - lw) / 2, y);
      y += 28;
    }

    // small playful hint
    ctx.font = '16px Verdana, sans-serif';
    const hint = 'Tip: keyboard selection is a helpful accessible option!';
    const hw = ctx.measureText(hint).width;
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    ctx.fillText(hint, (canvas.width - hw) / 2, y + 16);
  }

  // We will override render to include menu drawing
  const originalRender = render;
  function renderWithMenu(t) {
    originalRender(t);
    if (gameState === 'menu') {
      drawMenuOverlay();
    }
  }
  // Replace render used in loop
  render = renderWithMenu;

  // Start initialization
  try {
    init();
  } catch (err) {
    console.error('Game initialization error:', err);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.font = TITLE_FONT;
    ctx.fillStyle = '#000';
    ctx.fillText('An error occurred starting the game.', 20, 40);
  }

  // Ensure aria label updates periodically
  setInterval(updateAriaLabel, 1200);
})();
---

