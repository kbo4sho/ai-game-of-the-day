{
  "generated_date": "2025-10-14",
  "generated_timestamp": "2025-10-14T00:26:05.276231",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8730,
  "game_filename": "2025-10-14.js",
  "game_size_bytes": 23746,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Drone Math Adventure\n  // Educational game for ages 7-9. Rendered into #game-of-the-day-stage\n  // Uses Canvas and Web Audio API. No external assets.\n\n  // Configuration constants\n  const CANVAS_WIDTH = 720;\n  const CANVAS_HEIGHT = 480;\n  const GOAL_SCORE = 10;\n  const MAX_LIVES = 3;\n  const QUESTION_FONT = \"22px Arial\";\n  const BODY_FONT = \"16px Arial\";\n  const IMPORTANT_FONT = \"26px Arial\";\n  const UI_PADDING = 10; // minimum spacing between UI elements (pixels)\n  const OPTION_FONT = \"20px Arial\";\n  const AUDIO_ENABLED_DEFAULT = true;\n\n  // Access the stage element and create canvas\n  const stage = document.getElementById(\"game-of-the-day-stage\");\n  if (!stage) {\n    console.error(\"No element with id 'game-of-the-day-stage' found.\");\n    return;\n  }\n  // Clear stage and create canvas\n  stage.innerHTML = \"\";\n  stage.style.position = \"relative\";\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = CANVAS_WIDTH;\n  canvas.height = CANVAS_HEIGHT;\n  canvas.setAttribute(\"role\", \"img\");\n  canvas.setAttribute(\"aria-label\", \"Drone Math Adventure: solve addition and subtraction questions. Use number keys 1 to 4 to answer. Press M to toggle sound. Press R to restart.\");\n  canvas.setAttribute(\"tabindex\", \"0\"); // allow keyboard focus\n  stage.appendChild(canvas);\n  const ctx = canvas.getContext(\"2d\");\n\n  // Audio setup with proper error handling\n  let audioCtx = null;\n  let audioAllowed = AUDIO_ENABLED_DEFAULT;\n  let ambientGain = null;\n  try {\n    const AudioContext = window.AudioContext || window.webkitAudioContext;\n    if (!AudioContext) {\n      throw new Error(\"Web Audio API not supported\");\n    }\n    audioCtx = new AudioContext();\n    // create gentle ambient drone (subtle)\n    ambientGain = audioCtx.createGain();\n    ambientGain.gain.value = 0.02; // subtle background\n    ambientGain.connect(audioCtx.destination);\n    const ambientOsc = audioCtx.createOscillator();\n    ambientOsc.type = \"sine\";\n    ambientOsc.frequency.value = 120; // low tone\n    const ambientLFO = audioCtx.createOscillator();\n    ambientLFO.type = \"sine\";\n    ambientLFO.frequency.value = 0.2;\n    const ambientLFPGain = audioCtx.createGain();\n    ambientLFPGain.gain.value = 30;\n    ambientLFO.connect(ambientLFPGain);\n    ambientLFPGain.connect(ambientOsc.frequency);\n    ambientOsc.connect(ambientGain);\n    // Start oscillators only if audioAllowed will be true and context is running.\n    // We'll start after a first user gesture to avoid autoplay blocking.\n    ambientOsc.start();\n    ambientLFO.start();\n\n    // mute ambient until resumed\n    ambientGain.gain.value = audioAllowed ? 0.02 : 0;\n    // store oscillators for later control\n    audioCtx._ambientOsc = ambientOsc;\n    audioCtx._ambientLFO = ambientLFO;\n  } catch (err) {\n    console.warn(\"Audio disabled or failed to initialize:\", err);\n    audioCtx = null;\n    audioAllowed = false;\n  }\n\n  // Utility for short sound effects (correct/incorrect)\n  function playBeep(type = \"correct\") {\n    if (!audioAllowed || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      const f = type === \"correct\" ? 880 : 240; // higher for correct\n      o.frequency.setValueAtTime(f, now);\n      o.type = type === \"correct\" ? \"triangle\" : \"sawtooth\";\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.exponentialRampToValueAtTime(0.2, now + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.22);\n      o.connect(g);\n      g.connect(audioCtx.destination);\n      o.start(now);\n      o.stop(now + 0.24);\n    } catch (err) {\n      console.warn(\"Failed to play beeps:\", err);\n    }\n  }\n\n  // Ensure audio context resumes on first user gesture if suspended\n  async function ensureAudioRunning() {\n    if (!audioCtx) return;\n    try {\n      if (audioCtx.state === \"suspended\") {\n        await audioCtx.resume();\n      }\n    } catch (err) {\n      console.warn(\"Audio resume failed:\", err);\n    }\n    // ensure ambient gain reflects audioAllowed\n    if (audioCtx._ambientOsc && ambientGain) {\n      ambientGain.gain.value = audioAllowed ? 0.02 : 0;\n    }\n  }\n\n  // Game state\n  let score = 0;\n  let lives = MAX_LIVES;\n  let question = null;\n  let options = [];\n  let selectedOptionIndex = -1;\n  let questionCount = 0;\n  let gameState = \"playing\"; // playing, victory, gameover\n  let lastTime = performance.now();\n  let hoverIndex = -1;\n  let animationTime = 0;\n  let particles = [];\n  let drones = []; // for option visuals\n\n  // Accessibility: update canvas aria-label with current state\n  function updateAriaLabel() {\n    let label = `Drone Math Adventure. Score ${score}. Lives ${lives}. `;\n    if (gameState === \"playing\") {\n      label += `Question: ${question ? question.text : \"\"} `;\n      label += `Options: `;\n      options.forEach((opt, i) => {\n        label += `${i + 1}: ${opt}. `;\n      });\n      label += \"Press number keys 1 to 4 to answer.\";\n    } else if (gameState === \"victory\") {\n      label += \"You won! Press R to restart.\";\n    } else if (gameState === \"gameover\") {\n      label += \"Game over. Press R to restart.\";\n    }\n    canvas.setAttribute(\"aria-label\", label);\n  }\n\n  // Question generator: simple addition/subtraction within 20\n  function generateQuestion() {\n    const a = Math.floor(Math.random() * 18) + 1; // 1..18\n    const b = Math.floor(Math.random() * 9) + 1;  // 1..9\n    const add = Math.random() > 0.5;\n    const answer = add ? a + b : a - b;\n    const text = add ? `${a} + ${b} = ?` : `${a} - ${b} = ?`;\n    // create 3 distractors within +/- 5 but unique and >= -20 and <= 40\n    const set = new Set([answer]);\n    while (set.size < 4) {\n      let delta = Math.floor(Math.random() * 11) - 5; // -5..5\n      if (delta === 0) delta = (Math.random() > 0.5) ? 1 : -1;\n      let v = answer + delta;\n      if (v < -20) v = answer + Math.abs(delta) + 1;\n      set.add(v);\n    }\n    const arr = Array.from(set);\n    // shuffle options\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    // calculate which index is correct\n    const correctIndex = arr.indexOf(answer);\n    return {\n      text,\n      answer,\n      options: arr,\n      correctIndex\n    };\n  }\n\n  // Setup new question and visual drones for options\n  function nextQuestion() {\n    question = generateQuestion();\n    options = question.options.slice();\n    selectedOptionIndex = -1;\n    hoverIndex = -1;\n    questionCount++;\n    // create drones for each option with positions\n    drones = [];\n    const positions = [\n      { x: 180, y: 210 },\n      { x: 540, y: 210 },\n      { x: 180, y: 340 },\n      { x: 540, y: 340 }\n    ];\n    for (let i = 0; i < 4; i++) {\n      const p = positions[i];\n      drones.push({\n        x: p.x,\n        y: p.y,\n        targetY: p.y,\n        angle: Math.random() * Math.PI * 2,\n        wobble: Math.random() * 0.5 + 0.5,\n        label: String(options[i])\n      });\n    }\n    updateAriaLabel();\n  }\n\n  // Initialize new game\n  function restartGame() {\n    score = 0;\n    lives = MAX_LIVES;\n    questionCount = 0;\n    gameState = \"playing\";\n    nextQuestion();\n    particles = [];\n    animationTime = 0;\n    selectedOptionIndex = -1;\n    hoverIndex = -1;\n    updateAriaLabel();\n  }\n\n  // Start the game initially\n  restartGame();\n\n  // Mouse and keyboard events\n  canvas.addEventListener(\"mousemove\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    hoverIndex = -1;\n    for (let i = 0; i < drones.length; i++) {\n      const d = drones[i];\n      // option bounding box\n      const w = 220;\n      const h = 80;\n      if (mx >= d.x - w / 2 && mx <= d.x + w / 2 && my >= d.y - h / 2 && my <= d.y + h / 2) {\n        hoverIndex = i;\n        canvas.style.cursor = \"pointer\";\n        return;\n      }\n    }\n    canvas.style.cursor = \"default\";\n  });\n\n  canvas.addEventListener(\"click\", async (e) => {\n    await ensureAudioRunning();\n    if (gameState !== \"playing\") {\n      // check restart button click\n      const rect = canvas.getBoundingClientRect();\n      const mx = e.clientX - rect.left;\n      const my = e.clientY - rect.top;\n      // restart button center\n      const btnW = 180, btnH = 48;\n      const btnX = CANVAS_WIDTH / 2 - btnW / 2;\n      const btnY = CANVAS_HEIGHT / 2 + 60;\n      if (mx >= btnX && mx <= btnX + btnW && my >= btnY && my <= btnY + btnH) {\n        restartGame();\n      }\n      return;\n    }\n    // playing: check option click\n    if (hoverIndex >= 0) {\n      chooseOption(hoverIndex);\n    }\n  });\n\n  // keyboard controls: 1-4 to choose, M to toggle audio, R to restart\n  canvas.addEventListener(\"keydown\", async (e) => {\n    await ensureAudioRunning();\n    if (e.key >= \"1\" && e.key <= \"4\") {\n      const idx = parseInt(e.key, 10) - 1;\n      if (gameState === \"playing\") chooseOption(idx);\n    } else if (e.key.toLowerCase() === \"m\") {\n      toggleAudio();\n    } else if (e.key.toLowerCase() === \"r\") {\n      restartGame();\n    } else if (e.key === \"ArrowLeft\") {\n      // optional: navigate hover for accessibility\n      if (gameState === \"playing\") {\n        hoverIndex = (hoverIndex <= 0) ? drones.length - 1 : hoverIndex - 1;\n      }\n    } else if (e.key === \"ArrowRight\") {\n      if (gameState === \"playing\") {\n        hoverIndex = (hoverIndex + 1) % drones.length;\n      }\n    } else if (e.key === \"Enter\") {\n      if (gameState === \"playing\" && hoverIndex >= 0) {\n        chooseOption(hoverIndex);\n      } else if (gameState !== \"playing\") {\n        restartGame();\n      }\n    }\n    updateAriaLabel();\n  });\n\n  // make sure canvas is focusable and focused so keyboard works\n  canvas.addEventListener(\"focus\", () => {\n    canvas.style.outline = \"2px solid rgba(0,0,0,0.1)\";\n  });\n  canvas.addEventListener(\"blur\", () => {\n    canvas.style.outline = \"none\";\n  });\n  // Autofocus to allow keyboard immediately if possible\n  setTimeout(() => {\n    try {\n      canvas.focus();\n    } catch (err) {}\n  }, 100);\n\n  // Choose an option index (player action)\n  function chooseOption(idx) {\n    if (gameState !== \"playing\") return;\n    selectedOptionIndex = idx;\n    // Visual: make chosen drone bounce upward slightly\n    const d = drones[idx];\n    d.targetY = d.y - 30;\n    // Check correctness\n    if (idx === question.correctIndex) {\n      score++;\n      playBeep(\"correct\");\n      spawnParticles(d.x, d.y, \"#FFD700\"); // golden stars\n      // Move drone off-screen to \"deliver\" package\n      d.delivering = true;\n      d.deliveryTarget = { x: CANVAS_WIDTH - 60, y: 60 };\n    } else {\n      lives--;\n      playBeep(\"incorrect\");\n      spawnParticles(d.x, d.y, \"#FF6B6B\");\n      // shake the drone\n      d.shakeTime = 0.4;\n    }\n    // Check win/lose conditions after small timeout so player sees effect\n    setTimeout(() => {\n      if (score >= GOAL_SCORE) {\n        gameState = \"victory\";\n      } else if (lives <= 0) {\n        gameState = \"gameover\";\n      } else {\n        nextQuestion();\n      }\n      updateAriaLabel();\n    }, 500);\n  }\n\n  // Particle effect for feedback\n  function spawnParticles(x, y, color) {\n    for (let i = 0; i < 12; i++) {\n      particles.push({\n        x,\n        y,\n        vx: (Math.random() - 0.5) * 200,\n        vy: (Math.random() - 0.8) * -180,\n        life: Math.random() * 0.8 + 0.4,\n        ttl: Math.random() * 0.8 + 0.4,\n        color,\n        size: Math.random() * 4 + 2\n      });\n    }\n  }\n\n  // Toggle audio on/off\n  function toggleAudio() {\n    if (!audioCtx) return;\n    audioAllowed = !audioAllowed;\n    try {\n      if (ambientGain) ambientGain.gain.value = audioAllowed ? 0.02 : 0;\n    } catch (err) {\n      console.warn(\"Failed to toggle ambient:\", err);\n    }\n    updateAriaLabel();\n  }\n\n  // Draw helper functions with measured backgrounds to avoid overlapping text\n  function drawTextWithBackground(text, x, y, font, padding = 8, align = \"left\", bgColor = \"rgba(255,255,255,0.6)\", textColor = \"#000\") {\n    ctx.font = font;\n    const metrics = ctx.measureText(text);\n    const width = metrics.width;\n    const height = parseInt(font, 10);\n    let drawX = x;\n    if (align === \"center\") drawX = x - (width / 2);\n    if (align === \"right\") drawX = x - width;\n    const rectX = drawX - padding;\n    const rectY = y - height + -2 - padding / 2;\n    const rectW = width + padding * 2;\n    const rectH = height + padding;\n    // background\n    ctx.fillStyle = bgColor;\n    roundRect(ctx, rectX, rectY, rectW, rectH, 6);\n    ctx.fill();\n    // text\n    ctx.fillStyle = textColor;\n    ctx.textAlign = align;\n    ctx.fillText(text, x, y);\n    return { x: rectX, y: rectY, w: rectW, h: rectH };\n  }\n\n  // Rounded rectangle utility\n  function roundRect(ctx, x, y, w, h, r) {\n    r = Math.min(r, w / 2, h / 2);\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n  }\n\n  // Main render loop\n  function render(now) {\n    const dt = Math.min(0.05, (now - lastTime) / 1000);\n    lastTime = now;\n    animationTime += dt;\n\n    // Update particles\n    for (let i = particles.length - 1; i >= 0; i--) {\n      const p = particles[i];\n      p.vy += 500 * dt; // gravity\n      p.x += p.vx * dt;\n      p.y += p.vy * dt;\n      p.life -= dt;\n      if (p.life <= 0) particles.splice(i, 1);\n    }\n\n    // Update drones\n    for (let i = 0; i < drones.length; i++) {\n      const d = drones[i];\n      // gentle bobbing\n      d.angle += dt * 2 * d.wobble;\n      const bob = Math.sin(animationTime * 2 + i) * 6;\n      // shake effect\n      if (d.shakeTime && d.shakeTime > 0) {\n        d.shakeTime -= dt;\n      }\n      if (d.delivering) {\n        // move toward delivery target\n        const tx = d.deliveryTarget.x;\n        const ty = d.deliveryTarget.y;\n        d.x += (tx - d.x) * Math.min(1, dt * 2.5);\n        d.y += (ty - d.y) * Math.min(1, dt * 2.5);\n      } else {\n        // return to base targetY\n        d.y += (d.targetY - d.y) * Math.min(1, dt * 4);\n      }\n      d.renderY = d.y + bob;\n    }\n\n    // Clear canvas and draw background with gentle gradient\n    const skyGrad = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);\n    skyGrad.addColorStop(0, \"#E6F7FF\");\n    skyGrad.addColorStop(1, \"#CFEFFA\");\n    ctx.fillStyle = skyGrad;\n    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n    // Draw whimsical clouds (wacky shapes)\n    drawWackyCloud(80 + Math.sin(animationTime) * 10, 70, 80, 40, \"#FFFFFF\", \"#EAF6FF\");\n    drawWackyCloud(560 + Math.cos(animationTime * 0.7) * 12, 60, 120, 54, \"#FFFFFF\", \"#F0FBFF\");\n    drawWackyCloud(340, 45 + Math.sin(animationTime * 0.9) * 8, 60, 30, \"#FFFFFF\", \"#F8FDFF\");\n\n    // Draw question box at top center\n    ctx.textBaseline = \"alphabetic\";\n    ctx.font = IMPORTANT_FONT;\n    ctx.fillStyle = \"#000\";\n    ctx.textAlign = \"center\";\n    const questionBox = drawTextWithBackground(question.text, CANVAS_WIDTH / 2, 60, IMPORTANT_FONT, 14, \"center\", \"rgba(255,255,255,0.8)\", \"#0B3D91\");\n\n    // Draw score top-left and lives top-right using measureText to avoid overlapping\n    ctx.font = BODY_FONT;\n    ctx.textBaseline = \"alphabetic\";\n    ctx.textAlign = \"left\";\n    const scoreText = `Score: ${score}/${GOAL_SCORE}`;\n    const scoreBox = drawTextWithBackground(scoreText, UI_PADDING + 2, UI_PADDING + 20, BODY_FONT, 8, \"left\", \"rgba(255,255,255,0.8)\", \"#003366\");\n\n    ctx.textAlign = \"right\";\n    const livesText = `Lives: ${lives}`;\n    // Place lives at top-right with padding\n    const livesX = CANVAS_WIDTH - UI_PADDING - 2;\n    const livesBox = drawTextWithBackground(livesText, livesX, UI_PADDING + 20, BODY_FONT, 8, \"right\", \"rgba(255,255,255,0.8)\", \"#7A0000\");\n\n    // Draw audio state icon (top-left near score) - use small text\n    ctx.font = \"14px Arial\";\n    const audioText = audioAllowed ? \"\ud83d\udd0a Sound: On (M)\" : \"\ud83d\udd08 Sound: Off (M)\";\n    ctx.textAlign = \"left\";\n    drawTextWithBackground(audioText, UI_PADDING + 2, scoreBox.y + scoreBox.h + 20, \"14px Arial\", 6, \"left\", \"rgba(255,255,255,0.75)\", \"#004d40\");\n\n    // Draw instructions bottom-center\n    ctx.font = BODY_FONT;\n    ctx.textAlign = \"center\";\n    const instructions = \"Choose the correct answer. Use keys 1-4 or click a drone. Press R to restart.\";\n    drawTextWithBackground(instructions, CANVAS_WIDTH / 2, CANVAS_HEIGHT - UI_PADDING - 10, BODY_FONT, 10, \"center\", \"rgba(255,255,255,0.8)\", \"#002b3a\");\n\n    // Draw option drones with labels and option numbers\n    for (let i = 0; i < drones.length; i++) {\n      const d = drones[i];\n      const x = d.x;\n      const y = d.renderY;\n      // Option background box\n      const boxW = 220;\n      const boxH = 80;\n      const isHover = hoverIndex === i;\n      const isSelected = selectedOptionIndex === i;\n      ctx.save();\n      ctx.translate(x, y);\n      // draw drone body\n      // shadow\n      ctx.fillStyle = \"rgba(0,0,0,0.08)\";\n      roundRect(ctx, -boxW / 2 + 8, boxH / 2 - 6, boxW - 16, 8, 6);\n      ctx.fill();\n      // box\n      const bg = isSelected ? \"#E8FFF2\" : isHover ? \"#FFF7E6\" : \"#FFFFFF\";\n      ctx.fillStyle = bg;\n      roundRect(ctx, -boxW / 2, -boxH / 2, boxW, boxH, 12);\n      ctx.fill();\n      ctx.strokeStyle = \"#D0D6DE\";\n      ctx.lineWidth = 2;\n      ctx.stroke();\n      // draw drone \"roof\" - semi circle\n      ctx.beginPath();\n      ctx.fillStyle = \"#8CCBF3\";\n      ctx.arc(-boxW / 2 + 60, -boxH / 2 + 12, 18, Math.PI, 0, false);\n      ctx.fill();\n      ctx.closePath();\n\n      // propeller (animated)\n      ctx.save();\n      ctx.translate(-boxW / 2 + 60, -boxH / 2 + 12);\n      ctx.rotate(animationTime * 12 + d.angle);\n      ctx.fillStyle = \"#333333\";\n      for (let k = 0; k < 3; k++) {\n        ctx.beginPath();\n        ctx.ellipse(0, -10, 4, 14, k * Math.PI / 3, 0, Math.PI * 2);\n        ctx.fill();\n      }\n      ctx.restore();\n\n      // draw label text (option number and value)\n      ctx.font = \"18px Arial\";\n      ctx.fillStyle = \"#00334d\";\n      ctx.textAlign = \"left\";\n      ctx.fillText(`${i + 1}.`, -boxW / 2 + 12, 10);\n      ctx.font = OPTION_FONT;\n      ctx.fillStyle = \"#002b36\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(d.label, 0, 12);\n\n      // subtle decorative antenna\n      ctx.strokeStyle = \"#B7E0FA\";\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(boxW / 2 - 18, -boxH / 2 + 6);\n      ctx.quadraticCurveTo(boxW / 2 - 12, -boxH / 2 - 16, boxW / 2 - 36, -boxH / 2 - 12);\n      ctx.stroke();\n\n      // if wrong recently, add red flash\n      if (d.shakeTime && d.shakeTime > 0) {\n        ctx.fillStyle = \"rgba(255,100,100,0.08)\";\n        roundRect(ctx, -boxW / 2, -boxH / 2, boxW, boxH, 12);\n        ctx.fill();\n      }\n\n      ctx.restore();\n    }\n\n    // Draw floating stars indicating progress top-center under question\n    for (let i = 0; i < GOAL_SCORE; i++) {\n      const starX = CANVAS_WIDTH / 2 - ((GOAL_SCORE - 1) * 18) + i * 36;\n      const starY = questionBox.y + questionBox.h + 40;\n      drawStar(ctx, starX, starY, 5, 8, 4, i < score ? \"#FFD24D\" : \"rgba(255,255,255,0.35)\");\n    }\n\n    // Draw particles\n    particles.forEach((p) => {\n      ctx.globalAlpha = Math.max(0, p.life / p.ttl);\n      ctx.fillStyle = p.color;\n      ctx.beginPath();\n      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.globalAlpha = 1;\n    });\n\n    // If game ended, draw overlay screens\n    if (gameState === \"victory\") {\n      drawOverlay(\"Victory!\", `You delivered ${score} drone packages!`, \"\ud83c\udf89\");\n      drawRestartButton();\n    } else if (gameState === \"gameover\") {\n      drawOverlay(\"Game Over\", `You ran out of lives after ${questionCount} questions.`, \"\ud83d\udca5\");\n      drawRestartButton();\n    }\n\n    requestAnimationFrame(render);\n  }\n\n  // Draw overlay for victory/game over\n  function drawOverlay(title, subtitle, emoji) {\n    // translucent background\n    ctx.fillStyle = \"rgba(2,12,22,0.4)\";\n    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n    // central box\n    ctx.fillStyle = \"rgba(255,255,255,0.98)\";\n    const boxW = 560;\n    const boxH = 220;\n    const bx = CANVAS_WIDTH / 2 - boxW / 2;\n    const by = CANVAS_HEIGHT / 2 - boxH / 2 - 20;\n    roundRect(ctx, bx, by, boxW, boxH, 12);\n    ctx.fill();\n\n    // Title and subtitle\n    ctx.textAlign = \"center\";\n    ctx.fillStyle = \"#04395E\";\n    ctx.font = \"34px Arial\";\n    ctx.fillText(`${emoji} ${title}`, CANVAS_WIDTH / 2, by + 60);\n\n    ctx.font = \"18px Arial\";\n    ctx.fillStyle = \"#074b6a\";\n    wrapText(ctx, subtitle, CANVAS_WIDTH / 2, by + 100, boxW - 60, 22);\n\n    // hint\n    ctx.font = \"16px Arial\";\n    ctx.fillStyle = \"#0b3d91\";\n    ctx.fillText(\"Press R or click Restart to play again.\", CANVAS_WIDTH / 2, by + boxH - 20);\n  }\n\n  // Draw restart button\n  function drawRestartButton() {\n    const btnW = 180, btnH = 48;\n    const btnX = CANVAS_WIDTH / 2 - btnW / 2;\n    const btnY = CANVAS_HEIGHT / 2 + 60;\n    ctx.fillStyle = \"#00A896\";\n    roundRect(ctx, btnX, btnY, btnW, btnH, 10);\n    ctx.fill();\n    ctx.fillStyle = \"#FFFFFF\";\n    ctx.font = \"18px Arial\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"Restart (R)\", CANVAS_WIDTH / 2, btnY + 32);\n  }\n\n  // Draw star helper\n  function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius, color) {\n    let rot = Math.PI / 2 * 3;\n    let x = cx;\n    let y = cy;\n    let step = Math.PI / spikes;\n    ctx.beginPath();\n    ctx.moveTo(cx, cy - outerRadius);\n    for (let i = 0; i < spikes; i++) {\n      x = cx + Math.cos(rot) * outerRadius;\n      y = cy + Math.sin(rot) * outerRadius;\n      ctx.lineTo(x, y);\n      rot += step;\n\n      x = cx + Math.cos(rot) * innerRadius;\n      y = cy + Math.sin(rot) * innerRadius;\n      ctx.lineTo(x, y);\n      rot += step;\n    }\n    ctx.lineTo(cx, cy - outerRadius);\n    ctx.closePath();\n    ctx.fillStyle = color;\n    ctx.fill();\n    ctx.strokeStyle = \"rgba(0,0,0,0.08)\";\n    ctx.stroke();\n  }\n\n  // Draw a wacky cloud using Bezier curves\n  function drawWackyCloud(cx, cy, w, h, color1, color2) {\n    const grad = ctx.createRadialGradient(cx, cy - 10, 10, cx, cy, w);\n    grad.addColorStop(0, color1);\n    grad.addColorStop(1, color2);\n    ctx.fillStyle = grad;\n    ctx.beginPath();\n    ctx.ellipse(cx, cy, w, h, 0, 0, Math.PI * 2);\n    // add small lumps\n    ctx.ellipse(cx - w * 0.4, cy - h * 0.2, w * 0.55, h * 0.55, -0.2, 0, Math.PI * 2);\n    ctx.ellipse(cx + w * 0.35, cy - h * 0.25, w * 0.45, h * 0.45, 0.3, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  // Wrap text in canvas\n  function wrapText(ctx, text, x, y, maxWidth, lineHeight) {\n    const words = text.split(\" \");\n    let line = \"\";\n    let test = \"\";\n    let currentY = y;\n    ctx.textAlign = \"center\";\n    for (let n = 0; n < words.length; n++) {\n      const testLine = line + words[n] + \" \";\n      const metrics = ctx.measureText(testLine);\n      const testWidth = metrics.width;\n      if (testWidth > maxWidth && n > 0) {\n        ctx.fillText(line, x, currentY);\n        line = words[n] + \" \";\n        currentY += lineHeight;\n      } else {\n        line = testLine;\n      }\n    }\n    ctx.fillText(line, x, currentY);\n  }\n\n  // Start animation loop\n  requestAnimationFrame(render);\n\n  // Ensure canvas does not overflow stage and is exact size\n  canvas.style.width = `${CANVAS_WIDTH}px`;\n  canvas.style.height = `${CANVAS_HEIGHT}px`;\n  canvas.style.display = \"block\";\n\n  // Provide visual cue for audio toggle when clicking stage background\n  // Also handle first click to resume audio context\n  stage.addEventListener(\"click\", async () => {\n    await ensureAudioRunning();\n  }, { once: true });\n\n  // Expose some debug methods for console if needed\n  window._droneMathGame = {\n    restart: restartGame,\n    toggleAudio: toggleAudio,\n    getState: () => ({ score, lives, questionCount, gameState })\n  };\n\n})();\n---\n",
  "improve_response_tokens": 18015,
  "formatted_code": true,
  "formatting_response_tokens": 20010,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}