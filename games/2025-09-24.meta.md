# Game of the Day - 2025-09-24

## Metadata
- **Generated Date:** 2025-09-24
- **Generated Time:** 2025-09-24T00:26:51.772115
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-24.js
- **File Size:** 28385 bytes
- **Tokens Used:** 9370

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** âœ… PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** âœ… NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
â€¢ Be beatable.
â€¢ Use visually calming and interesting and wacky elements.
â€¢ Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
â€¢ Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
â€¢ Have a game area exactly 720px wide by 480px tall.
â€¢ Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
â€¢ Use modern JavaScript practices and avoid minification.
â€¢ Include proper error handling for audio and resource loading.
â€¢ Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
â€¢ Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
â€¢ Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
â€¢ Generate all sounds using Web Audio API oscillators and filters.
â€¢ Include proper error handling for audio context creation.
â€¢ Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
â€¢ Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-24.js` - The playable game
- `2025-09-24.meta.json` - Machine-readable metadata
- `2025-09-24.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 18849

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 20065

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** âœ… PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Machine Math â€” a calming, wacky educational game for ages 7-9
  // Renders into the element with ID "game-of-the-day-stage"
  // All visuals drawn to a 720x480 canvas. Sounds generated with Web Audio API.
  // Accessible text updates via an offscreen live region. Keyboard controls supported.

  // -------------------------
  // Basic setup and utilities
  // -------------------------
  const STAGE_ID = 'game-of-the-day-stage';
  const WIDTH = 720;
  const HEIGHT = 480;

  const stage = document.getElementById(STAGE_ID);
  if (!stage) {
    console.error('Game stage element with ID "' + STAGE_ID + '" not found.');
    return;
  }

  // Clear any existing children, then create needed UI nodes
  stage.innerHTML = '';
  stage.style.position = 'relative';

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute('role', 'application');
  canvas.setAttribute('aria-label', 'Machine Math game. Use left and right arrows to pick a gear, press Enter to place it. Press M to toggle sound, R to restart.');
  canvas.tabIndex = 0; // make focusable for keyboard events
  canvas.style.outline = 'none';
  stage.appendChild(canvas);

  // Offscreen live region for screen readers
  const a11y = document.createElement('div');
  a11y.setAttribute('role', 'status');
  a11y.setAttribute('aria-live', 'polite');
  a11y.style.position = 'absolute';
  a11y.style.left = '-10000px';
  a11y.style.width = '1px';
  a11y.style.height = '1px';
  a11y.style.overflow = 'hidden';
  stage.appendChild(a11y);

  // Visible, small control buttons (canvas-only visuals exist, but include small DOM buttons for accessibility)
  const controls = document.createElement('div');
  controls.style.position = 'absolute';
  controls.style.right = '8px';
  controls.style.top = '8px';
  controls.style.fontSize = '12px';
  controls.style.fontFamily = 'sans-serif';
  controls.style.color = '#333';
  stage.appendChild(controls);

  const soundIndicator = document.createElement('button');
  soundIndicator.textContent = 'Sound: On';
  soundIndicator.setAttribute('aria-pressed', 'true');
  soundIndicator.style.padding = '6px 8px';
  soundIndicator.style.marginBottom = '4px';
  soundIndicator.style.cursor = 'pointer';
  controls.appendChild(soundIndicator);

  const restartButton = document.createElement('button');
  restartButton.textContent = 'Restart (R)';
  restartButton.style.display = 'block';
  restartButton.style.padding = '6px 8px';
  restartButton.style.cursor = 'pointer';
  controls.appendChild(restartButton);

  const ctx = canvas.getContext('2d');
  if (!ctx) {
    console.error('Failed to get 2D context on canvas.');
    a11y.textContent = 'Error: Canvas not available.';
    return;
  }

  // Helper random
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // -------------------------
  // Audio setup with error handling
  // -------------------------
  let audioEnabled = true;
  let audioContext = null;
  let bgGain = null;
  let bgSource = null;
  let masterGain = null;

  function tryCreateAudioContext() {
    if (audioContext) return;
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) throw new Error('Web Audio API not supported.');
      audioContext = new AC();
      masterGain = audioContext.createGain();
      masterGain.gain.value = 0.9;
      masterGain.connect(audioContext.destination);

      // background gentle hum: oscillator + filter + LFO
      bgGain = audioContext.createGain();
      bgGain.gain.value = 0.03; // very quiet
      const osc = audioContext.createOscillator();
      osc.type = 'sine';
      osc.frequency.value = 110; // low pitch
      const filter = audioContext.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 600;
      // LFO for filter movement
      const lfo = audioContext.createOscillator();
      lfo.frequency.value = 0.08;
      const lfoGain = audioContext.createGain();
      lfoGain.gain.value = 220;
      lfo.connect(lfoGain);
      lfoGain.connect(filter.frequency);
      osc.connect(filter);
      filter.connect(bgGain);
      bgGain.connect(masterGain);
      osc.start();
      lfo.start();
      bgSource = { osc, lfo, lfoGain, filter, gain: bgGain };
    } catch (e) {
      console.warn('Audio initialization failed:', e);
      audioEnabled = false;
      audioContext = null;
      a11y.textContent = 'Audio unavailable. The game will continue without sound.';
      soundIndicator.textContent = 'Sound: Off';
      soundIndicator.setAttribute('aria-pressed', 'false');
    }
  }

  // Start background if audio allowed; ensure it only starts on user gesture where required.
  function startBackground() {
    if (!audioEnabled) return;
    try {
      tryCreateAudioContext();
      if (!audioContext || !bgSource) return;
      // Ensure context resumed (some browsers require user gesture)
      if (audioContext.state === 'suspended') {
        audioContext.resume().catch(() => {
          // ignore resume errors until user interacts
        });
      }
      // bgGain already connected and oscillators started in tryCreateAudioContext()
    } catch (e) {
      console.warn('Background sound failed', e);
    }
  }

  // Sound effects
  function playTone({ type = 'sine', freq = 440, duration = 0.2, attack = 0.01, release = 0.12, gain = 0.15, detune = 0 } = {}) {
    if (!audioEnabled) return;
    try {
      tryCreateAudioContext();
      if (!audioContext) return;
      const now = audioContext.currentTime;
      const o = audioContext.createOscillator();
      const g = audioContext.createGain();
      o.type = type;
      o.frequency.value = freq;
      o.detune.value = detune;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.linearRampToValueAtTime(gain, now + attack);
      g.gain.linearRampToValueAtTime(0.0001, now + duration - release);
      g.gain.linearRampToValueAtTime(0, now + duration + 0.001);
      o.connect(g);
      g.connect(masterGain);
      o.start(now);
      o.stop(now + duration + 0.02);
    } catch (e) {
      console.warn('playTone error', e);
    }
  }

  function playCorrect() {
    // pleasant ascending arpeggio
    playTone({ type: 'triangle', freq: 660, duration: 0.18, attack: 0.005, release: 0.06, gain: 0.08 });
    setTimeout(() => playTone({ type: 'triangle', freq: 880, duration: 0.18, attack: 0.005, release: 0.06, gain: 0.06 }), 120);
  }

  function playIncorrect() {
    // low buzz
    if (!audioEnabled || !audioContext) return;
    try {
      const now = audioContext.currentTime;
      const o = audioContext.createOscillator();
      const f = audioContext.createBiquadFilter();
      const g = audioContext.createGain();
      o.type = 'square';
      o.frequency.value = 110;
      f.type = 'lowpass';
      f.frequency.value = 400;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.linearRampToValueAtTime(0.15, now + 0.02);
      g.gain.linearRampToValueAtTime(0.0001, now + 0.3);
      o.connect(f);
      f.connect(g);
      g.connect(masterGain);
      o.start(now);
      o.stop(now + 0.32);
    } catch (e) {
      console.warn('playIncorrect error', e);
    }
  }

  function playClick() {
    playTone({ type: 'square', freq: 1200, duration: 0.06, attack: 0.001, release: 0.02, gain: 0.06 });
  }

  // Toggle audio, resume context if needed
  function toggleAudio() {
    audioEnabled = !audioEnabled;
    soundIndicator.textContent = 'Sound: ' + (audioEnabled ? 'On' : 'Off');
    soundIndicator.setAttribute('aria-pressed', audioEnabled ? 'true' : 'false');
    if (audioEnabled) {
      tryCreateAudioContext();
      if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume().catch(() => {});
      }
    } else {
      // reduce background
      if (bgGain) bgGain.gain.value = 0;
    }
    a11y.textContent = audioEnabled ? 'Sound enabled.' : 'Sound disabled.';
  }

  soundIndicator.addEventListener('click', () => {
    toggleAudio();
    playClick();
    canvas.focus();
  });

  restartButton.addEventListener('click', () => {
    playClick();
    resetGame();
    canvas.focus();
  });

  // -------------------------
  // Game logic
  // -------------------------
  let animationFrameId = null;
  let lastTime = 0;

  const MAX_LIVES = 3;

  const state = {
    levelIndex: 0,
    lives: MAX_LIVES,
    score: 0,
    gears: [], // moving gear objects
    selectedIndex: 0,
    phase: 'intro', // intro, play, correct, incorrect, win, gameover
    machineBase: 0,
    machineTarget: 0,
    awaiting: false,
    timeSincePhaseStart: 0,
    showAudioCue: false // visual cue whether audio is active
  };

  // Predefined levels that escalate difficulty gently
  const LEVEL_COUNT = 8;
  const levels = [];

  // Generate levels: choose base and target such that 1<=diff<=9, different strategies.
  (function generateLevels() {
    for (let i = 0; i < LEVEL_COUNT; i++) {
      let base = randInt(1, Math.min(9, 2 + i)); // base increases slowly
      let diff = randInt(1, Math.min(9, 3 + Math.floor(i / 2)));
      let target = base + diff;
      // occasionally require subtractive thinking (smaller gear to subtract)
      const needsSubtract = Math.random() < 0.15 && base > 1;
      if (needsSubtract) {
        // target < base, so gear is negative conceptually â€” for simplicity present as "remove" action
        const reduce = randInt(1, Math.min(base - 1, 4));
        target = base - reduce;
      }
      levels.push({ base, target });
    }
  })();

  function prepareLevel(index) {
    const level = levels[index];
    state.machineBase = level.base;
    state.machineTarget = level.target;
    state.phase = 'play';
    state.awaiting = false;
    state.timeSincePhaseStart = 0;
    state.selectedIndex = 0;
    // create 3 moving gears: one correct (difference or subtract), two distractors
    const diff = state.machineTarget - state.machineBase; // correct gear value (can be negative)
    const correct = diff;
    const options = new Set();
    options.add(correct);
    while (options.size < 3) {
      let pick;
      if (Math.random() < 0.6) {
        // distractor near the correct
        pick = correct + randInt(-3, 3);
      } else {
        pick = randInt(-4, 9);
      }
      if (pick === correct) continue;
      // avoid zero for clarity unless correct is zero
      if (pick === 0 && correct !== 0) continue;
      options.add(pick);
    }
    const arr = Array.from(options);
    // shuffle
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }

    // place gears to the right moving left
    state.gears = arr.map((value, i) => {
      return {
        id: i,
        value,
        x: WIDTH + i * 160 + randInt(0, 60),
        y: 320 + (i % 2) * -18 + randInt(-6, 6),
        radius: 36 + randInt(-4, 8),
        speed: 40 + randInt(-10, 30) + i * 8
      };
    });

    announce(`Level ${index + 1}. Machine shows ${state.machineBase} aiming for ${state.machineTarget}. Choose the gear that makes ${state.machineBase} become ${state.machineTarget}.`);
  }

  function resetGame() {
    state.levelIndex = 0;
    state.lives = MAX_LIVES;
    state.score = 0;
    state.phase = 'intro';
    state.timeSincePhaseStart = 0;
    prepareLevel(0);
    startBackground();
    draw(); // immediate redraw
    a11y.textContent = 'Game restarted. Press Enter to begin.';
  }

  // Start initially
  prepareLevel(0);
  startBackground();

  // -------------------------
  // Interaction: keyboard & mouse
  // -------------------------
  canvas.addEventListener('keydown', (e) => {
    const key = e.key;
    if (state.phase === 'intro') {
      if (key === 'Enter' || key === ' ') {
        state.phase = 'play';
        a11y.textContent = 'Game started. Use left and right to move, Enter to choose a gear.';
        e.preventDefault();
        playClick();
        return;
      }
    }

    if (key === 'ArrowLeft') {
      state.selectedIndex = Math.max(0, state.selectedIndex - 1);
      playClick();
      e.preventDefault();
    } else if (key === 'ArrowRight') {
      state.selectedIndex = Math.min(state.gears.length - 1, state.selectedIndex + 1);
      playClick();
      e.preventDefault();
    } else if (key === 'Enter' || key === ' ') {
      // place gear
      attemptPlaceGear(state.selectedIndex);
      e.preventDefault();
    } else if (key.toLowerCase() === 'm') {
      toggleAudio();
      playClick();
    } else if (key.toLowerCase() === 'r') {
      resetGame();
      playClick();
    }
  });

  // Mouse clicks for selection and gear placement
  canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    // If clicking on a gear, select it or if it's near the place zone, place it
    for (let i = 0; i < state.gears.length; i++) {
      const g = state.gears[i];
      const dx = mx - g.x;
      const dy = my - g.y;
      if (dx * dx + dy * dy <= g.radius * g.radius) {
        state.selectedIndex = i;
        playClick();
        // If clicked twice quickly, place
        const now = performance.now();
        if (state.lastClickGear === i && now - state.lastClickTime < 400) {
          attemptPlaceGear(i);
        }
        state.lastClickGear = i;
        state.lastClickTime = now;
        break;
      }
    }
    canvas.focus();
  });

  // Attempt to place a gear by index
  function attemptPlaceGear(index) {
    if (state.phase !== 'play') return;
    const gear = state.gears[index];
    if (!gear) return;
    // place animation start
    state.phase = 'placing';
    state.awaiting = true;
    state.timeSincePhaseStart = 0;
    state.placing = {
      gearIndex: index,
      startX: gear.x,
      startY: gear.y,
      progress: 0 // 0..1
    };
    playClick();
    a11y.textContent = `You picked gear ${gear.value}. Placing...`;
  }

  // Evaluate placed gear when placement animation completes
  function evaluatePlacement(gearValue) {
    const required = state.machineTarget - state.machineBase;
    if (gearValue === required) {
      // correct
      state.score += 10;
      state.phase = 'correct';
      state.timeSincePhaseStart = 0;
      a11y.textContent = `Great! That was correct. Machine now reaches ${state.machineTarget}.`;
      playCorrect();
      // proceed to next level after short delay
      setTimeout(() => {
        state.levelIndex++;
        if (state.levelIndex >= LEVEL_COUNT) {
          state.phase = 'win';
          a11y.textContent = `Congratulations! You fixed all machines. Score ${state.score}. Press R to play again.`;
        } else {
          prepareLevel(state.levelIndex);
        }
      }, 900);
    } else {
      // incorrect
      state.lives--;
      state.phase = 'incorrect';
      state.timeSincePhaseStart = 0;
      a11y.textContent = `Oops. That gear did not work. ${state.lives} ${state.lives === 1 ? 'life' : 'lives'} remaining.`;
      playIncorrect();
      setTimeout(() => {
        if (state.lives <= 0) {
          state.phase = 'gameover';
          a11y.textContent = `Game over. Score ${state.score}. Press R to try again.`;
        } else {
          // return to same level with new gear positions (regenerate distractors)
          prepareLevel(state.levelIndex);
        }
      }, 900);
    }
  }

  // -------------------------
  // Drawing functions
  // -------------------------
  function clear() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
  }

  function drawBackground(t) {
    // calming pastel gradient sky
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#eaf6ff');
    g.addColorStop(1, '#f6f9ff');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // floating bubbles/wacky shapes for whimsy
    ctx.globalAlpha = 0.12;
    for (let i = 0; i < 7; i++) {
      const bx = (i * 137 + (t * 0.02 * (i + 1))) % (WIDTH + 100) - 50;
      const by = 40 + ((i * 77) % 180) + 10 * Math.sin((t / 800) + i);
      ctx.beginPath();
      ctx.fillStyle = ['#ffe8f0', '#e8fff4', '#fff0e8', '#e8f0ff'][i % 4];
      ctx.arc(bx, by, 28 + (i % 3) * 6, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  function drawConveyor() {
    // conveyor base
    ctx.fillStyle = '#d3e2ea';
    roundRect(ctx, 50, 260, 620, 110, 20);
    ctx.fill();

    // belt stripes
    ctx.save();
    ctx.beginPath();
    ctx.rect(60, 270, 600, 90);
    ctx.clip();
    for (let i = 0; i < 30; i++) {
      ctx.fillStyle = i % 2 === 0 ? '#cbdfe8' : '#bcd0da';
      ctx.fillRect(60 + (i * 40 + (performance.now() / 30)) % 40 - 40, 270, 30, 90);
    }
    ctx.restore();

    // bolts
    for (let i = 0; i < 8; i++) {
      drawBolt(70 + i * 86, 282);
      drawBolt(70 + i * 86, 342);
    }
  }

  function drawBolt(x, y) {
    ctx.fillStyle = '#f2f8fb';
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#bcd0da';
    ctx.stroke();
  }

  function drawMachine() {
    // machine body
    const mx = 180;
    const my = 110;
    ctx.save();
    // main panel
    ctx.fillStyle = '#cfe6ff';
    roundRect(ctx, 120, 60, 420, 180, 18);
    ctx.fill();
    // window
    ctx.fillStyle = '#ffffff';
    roundRect(ctx, 420, 82, 110, 50, 8);
    ctx.fill();
    // screen showing base and target
    ctx.fillStyle = '#1b3b4b';
    ctx.font = '20px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(`Base: ${state.machineBase}`, 140, 110);
    ctx.fillText(`Target: ${state.machineTarget}`, 140, 140);

    // wacky robot face
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(470, 165, 36, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.arc(458, 158, 6, 0, Math.PI * 2);
    ctx.arc(482, 158, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#333';
    ctx.beginPath();
    ctx.moveTo(458, 175);
    ctx.quadraticCurveTo(470, 182, 482, 175);
    ctx.stroke();

    ctx.restore();

    // slot where gear is placed
    ctx.save();
    ctx.fillStyle = '#f1f7fb';
    roundRect(ctx, 330, 250, 160, 76, 12);
    ctx.fill();
    ctx.strokeStyle = '#bcd0da';
    ctx.strokeRect(330, 250, 160, 76);
    ctx.fillStyle = '#7aa5c8';
    ctx.font = '18px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Place Gear Here', 410, 290);
    ctx.restore();
  }

  function drawGears(t) {
    // animate gears moving, draw selected highlight
    for (let i = 0; i < state.gears.length; i++) {
      const g = state.gears[i];
      // update positions during play
      if (state.phase === 'play') {
        g.x -= (g.speed * (1 / 60)); // simple time step
        if (g.x < -80) {
          // wrap around
          g.x = WIDTH + randInt(40, 160);
          g.y = 300 + randInt(-20, 20);
        }
      }
      // if placing this gear, the animation handled elsewhere
      if (state.phase === 'placing' && state.placing && state.placing.gearIndex === i) {
        // position will be set by placing progress during draw
      }

      // gear body
      ctx.save();
      const isSelected = i === state.selectedIndex;
      ctx.translate(g.x, g.y);

      // rotation for whimsy
      const rot = (t / 800) * (i % 2 === 0 ? 1 : -1);
      ctx.rotate(rot);

      // teeth
      const teeth = 8 + (g.radius % 5);
      for (let j = 0; j < teeth; j++) {
        ctx.beginPath();
        ctx.fillStyle = '#e8f5ff';
        const angle = (j / teeth) * Math.PI * 2;
        const tx = Math.cos(angle) * (g.radius + 6);
        const ty = Math.sin(angle) * (g.radius + 6);
        ctx.arc(tx, ty, 6, 0, Math.PI * 2);
        ctx.fill();
      }

      // main circle
      ctx.beginPath();
      ctx.fillStyle = isSelected ? '#ffd8a8' : '#fff';
      ctx.arc(0, 0, g.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#b4cfe0';
      ctx.lineWidth = 3;
      ctx.stroke();

      // value text
      ctx.fillStyle = '#123';
      ctx.font = '20px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(String(g.value), 0, 6);

      // small face
      ctx.fillStyle = '#123';
      ctx.beginPath();
      ctx.arc(-g.radius / 3, -g.radius / 5, 3, 0, Math.PI * 2);
      ctx.arc(g.radius / 3, -g.radius / 5, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawHUD() {
    // Lives hearts
    ctx.fillStyle = '#333';
    ctx.font = '16px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Lives: ', 16, 26);
    for (let i = 0; i < MAX_LIVES; i++) {
      ctx.beginPath();
      const x = 80 + i * 22;
      const y = 14;
      heart(ctx, x, y, 12, i < state.lives ? '#ff7b86' : '#f1c7cc');
    }

    // Score
    ctx.fillStyle = '#123';
    ctx.font = '16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Score: ' + state.score, WIDTH / 2, 26);

    // Level indicator
    ctx.textAlign = 'right';
    ctx.fillText(`Level ${state.levelIndex + 1}/${LEVEL_COUNT}`, WIDTH - 12, 26);

    // Sound visual cue
    ctx.fillStyle = audioEnabled ? '#1b9e7a' : '#c8c8c8';
    ctx.beginPath();
    ctx.arc(WIDTH - 30, HEIGHT - 30, 10, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(audioEnabled ? 'ðŸ”Š' : 'ðŸ”ˆ', WIDTH - 30, HEIGHT - 26);

    // Instructions short
    ctx.fillStyle = '#123';
    ctx.font = '12px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Arrows: move  Enter: place  M: sound  R: restart', 12, HEIGHT - 12);
  }

  function drawOverlay() {
    ctx.save();
    if (state.phase === 'intro') {
      ctx.fillStyle = 'rgba(20,30,40,0.2)';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = '#123';
      ctx.font = '28px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Machine Math', WIDTH / 2, HEIGHT / 2 - 40);
      ctx.font = '16px Arial';
      ctx.fillText('Get the machine to the target by placing the right gear.', WIDTH / 2, HEIGHT / 2);
      ctx.fillText('Press Enter to start.', WIDTH / 2, HEIGHT / 2 + 28);
    } else if (state.phase === 'correct') {
      // celebratory overlay
      ctx.fillStyle = 'rgba(60,170,100,0.06)';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
    } else if (state.phase === 'incorrect') {
      // red flash
      const alpha = 0.2;
      ctx.fillStyle = `rgba(200,50,50,${alpha})`;
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
    } else if (state.phase === 'gameover') {
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = '#fff';
      ctx.font = '28px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over', WIDTH / 2, HEIGHT / 2 - 20);
      ctx.font = '16px Arial';
      ctx.fillText(`Score: ${state.score}`, WIDTH / 2, HEIGHT / 2 + 6);
      ctx.fillText('Press R to restart', WIDTH / 2, HEIGHT / 2 + 34);
    } else if (state.phase === 'win') {
      ctx.fillStyle = 'rgba(255,255,255,0.35)';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = '#123';
      ctx.font = '26px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('You fixed all the machines!', WIDTH / 2, HEIGHT / 2 - 10);
      ctx.font = '16px Arial';
      ctx.fillText(`Final Score: ${state.score}`, WIDTH / 2, HEIGHT / 2 + 20);
      ctx.fillText('Press R to play again', WIDTH / 2, HEIGHT / 2 + 46);
    }
    ctx.restore();
  }

  function drawPlacing(t, dt) {
    // If placing, animate the chosen gear moving into the machine slot
    if (!state.placing) return;
    const g = state.gears[state.placing.gearIndex];
    const p = state.placing;
    p.progress += dt / 500; // half-second travel
    if (p.progress >= 1) p.progress = 1;
    // ease
    const e = easeOutCubic(p.progress);
    const targetX = 410;
    const targetY = 290;
    const x = p.startX + (targetX - p.startX) * e;
    const y = p.startY + (targetY - p.startY) * e;
    // draw the moving gear above others
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate((t / 800) * 1.3);
    // transient scale
    const s = 1 + 0.12 * (1 - Math.abs(0.5 - p.progress) * 2);
    ctx.scale(s, s);
    // gear visuals
    const gr = g.radius;
    for (let j = 0; j < 9; j++) {
      ctx.beginPath();
      ctx.fillStyle = '#e8f5ff';
      const angle = (j / 9) * Math.PI * 2;
      const tx = Math.cos(angle) * (gr + 6);
      const ty = Math.sin(angle) * (gr + 6);
      ctx.arc(tx, ty, 6, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.beginPath();
    ctx.fillStyle = '#fff';
    ctx.arc(0, 0, gr, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#b4cfe0';
    ctx.lineWidth = 3;
    ctx.stroke();
    ctx.fillStyle = '#123';
    ctx.font = '20px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(String(g.value), 0, 6);
    ctx.restore();

    if (p.progress >= 1 && state.awaiting) {
      // finalize placement after slight pause
      state.awaiting = false;
      setTimeout(() => {
        evaluatePlacement(g.value);
      }, 150);
    }
  }

  // -------------------------
  // Main loop
  // -------------------------
  function loop(timestamp) {
    const dt = lastTime ? timestamp - lastTime : 16;
    lastTime = timestamp;
    state.timeSincePhaseStart += dt;

    // update placing progress if any
    if (state.phase === 'placing' && state.placing) {
      // nothing else; drawPlacing handles progress increment
    }

    // draw frame
    draw(timestamp, dt);

    animationFrameId = requestAnimationFrame(loop);
  }

  function draw(t = performance.now(), dt = 16) {
    clear();
    drawBackground(t);
    drawConveyor();
    drawMachine();
    // update gear positions
    if (state.phase === 'placing') {
      // while placing, still move other gears a little
      for (const g of state.gears) {
        if (state.placing && state.placing.gearIndex === g.id) continue;
        g.x -= (g.speed * (dt / 1000));
        if (g.x < -80) g.x = WIDTH + randInt(40, 160);
      }
    }
    drawGears(t);
    drawPlacing(t, dt);
    drawHUD();
    drawOverlay();
  }

  // Start animation
  animationFrameId = requestAnimationFrame(loop);

  // -------------------------
  // Utility drawing helpers
  // -------------------------
  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  function heart(ctx, x, y, size, color) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(size / 24, size / 24);
    ctx.beginPath();
    ctx.moveTo(0, 10);
    ctx.bezierCurveTo(-12, -2, -12, -10, 0, -10);
    ctx.bezierCurveTo(12, -10, 12, -2, 0, 10);
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
    ctx.restore();
  }

  function easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3);
  }

  // -------------------------
  // Announcements and accessibility
  // -------------------------
  function announce(text) {
    a11y.textContent = text;
    // also console for debug
    console.log('Announce:', text);
  }

  // -------------------------
  // Clean up on page unload
  // -------------------------
  window.addEventListener('unload', () => {
    if (animationFrameId) cancelAnimationFrame(animationFrameId);
    if (audioContext) {
      try {
        audioContext.close();
      } catch (e) {}
    }
  });

  // -------------------------
  // Provide a small warm greeting
  // -------------------------
  a11y.textContent = 'Welcome to Machine Math. Press Enter to begin, or use the controls.';

  // Set initial focus to canvas
  setTimeout(() => { canvas.focus(); }, 200);

  // Ensure audio starts on user gesture if blocked
  function handleFirstInteraction() {
    if (audioEnabled) {
      try {
        tryCreateAudioContext();
        if (audioContext && audioContext.state === 'suspended') {
          audioContext.resume().catch(() => {});
        }
      } catch (e) {}
    }
    // remove listener after first use
    window.removeEventListener('pointerdown', handleFirstInteraction);
    window.removeEventListener('keydown', handleFirstInteraction);
  }
  window.addEventListener('pointerdown', handleFirstInteraction);
  window.addEventListener('keydown', handleFirstInteraction);

})();
---

