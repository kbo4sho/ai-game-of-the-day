# Game of the Day - 2025-09-23

## Metadata
- **Generated Date:** 2025-09-23
- **Generated Time:** 2025-09-23T00:27:00.699172
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-23.js
- **File Size:** 28781 bytes
- **Tokens Used:** 9400

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-23.js` - The playable game
- `2025-09-23.meta.json` - Machine-readable metadata
- `2025-09-23.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 19213

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 20846

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Machine Math Game for ages 7-9
  // Renders into the existing element with ID 'game-of-the-day-stage'
  // Uses Canvas-only graphics and Web Audio API for sounds
  // Accessible: keyboard controls, aria-live status, visual audio indicator
  // All resources generated in code; no external files

  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const ROUNDS = 8; // Beat after completing ROUNDS targets

  // Helper: get container element
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Game container element with ID "game-of-the-day-stage" not found.');
    return;
  }

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute('role', 'application');
  canvas.setAttribute('aria-label', 'Machine Math Game canvas');
  canvas.tabIndex = 0; // Make focusable for keyboard controls
  container.innerHTML = '';
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Responsive font smoothing
  ctx.imageSmoothingEnabled = true;

  // Accessibility: live region for screen readers
  const liveRegion = document.createElement('div');
  liveRegion.style.position = 'absolute';
  liveRegion.style.left = '-9999px';
  liveRegion.style.width = '1px';
  liveRegion.style.height = '1px';
  liveRegion.style.overflow = 'hidden';
  liveRegion.setAttribute('aria-live', 'assertive');
  container.appendChild(liveRegion);

  // Audio setup with error handling
  let audioCtx = null;
  let bgGain = null;
  let bgOsc = null;
  let audioAvailable = false;
  let audioMuted = false;

  async function createAudio() {
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) throw new Error('Web Audio API not supported in this browser.');
      audioCtx = new AC();
      // Create background hum
      bgGain = audioCtx.createGain();
      bgGain.gain.value = 0.03; // gentle
      bgGain.connect(audioCtx.destination);

      bgOsc = audioCtx.createOscillator();
      bgOsc.type = 'sine';
      bgOsc.frequency.value = 110; // low hum
      // subtle vibrato via LFO
      const lfo = audioCtx.createOscillator();
      lfo.type = 'sine';
      lfo.frequency.value = 0.25;
      const lfoGain = audioCtx.createGain();
      lfoGain.gain.value = 3; // small frequency modulation
      lfo.connect(lfoGain);
      lfoGain.connect(bgOsc.frequency);

      bgOsc.connect(bgGain);
      bgOsc.start();
      lfo.start();

      audioAvailable = true;
    } catch (err) {
      console.warn('Audio unavailable:', err);
      audioAvailable = false;
      audioCtx = null;
    }
  }

  // Ensure audio context resumed on user gesture
  async function ensureAudioRunning() {
    if (!audioAvailable || !audioCtx) return;
    if (audioCtx.state === 'suspended') {
      try {
        await audioCtx.resume();
      } catch (e) {
        console.warn('Failed to resume AudioContext:', e);
      }
    }
  }

  // Sound effects using Oscillator + filters + envelopes
  function playCorrect() {
    if (!audioAvailable || audioMuted) return;
    try {
      const t = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 1200;

      osc.type = 'sine';
      osc.frequency.setValueAtTime(600, t);
      osc.frequency.exponentialRampToValueAtTime(1200, t + 0.18);

      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.08, t + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.4);

      osc.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);

      osc.start(t);
      osc.stop(t + 0.45);
    } catch (e) {
      console.warn('playCorrect error', e);
    }
  }

  function playIncorrect() {
    if (!audioAvailable || audioMuted) return;
    try {
      const t = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.value = 800;

      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(180, t);
      osc.frequency.exponentialRampToValueAtTime(80, t + 0.12);

      gain.gain.setValueAtTime(0.0001, t);
      gain.gain.linearRampToValueAtTime(0.08, t + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.22);

      osc.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);

      osc.start(t);
      osc.stop(t + 0.25);
    } catch (e) {
      console.warn('playIncorrect error', e);
    }
  }

  function playPlace() {
    if (!audioAvailable || audioMuted) return;
    try {
      const t = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = 'triangle';
      osc.frequency.setValueAtTime(800, t);
      osc.frequency.exponentialRampToValueAtTime(500, t + 0.1);
      gain.gain.setValueAtTime(0.0001, t);
      gain.gain.linearRampToValueAtTime(0.06, t + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.18);

      osc.connect(gain);
      gain.connect(audioCtx.destination);

      osc.start(t);
      osc.stop(t + 0.22);
    } catch (e) {
      console.warn('playPlace error', e);
    }
  }

  // Game state
  const game = {
    round: 0,
    score: 0,
    target: 0,
    gears: [], // each gear: {x, y, r, value, picked, id}
    selectedGearId: null,
    slots: [null, null], // gear ids placed
    dragging: false,
    dragOffset: { x: 0, y: 0 },
    finished: false,
    muted: false,
    message: 'Click a gear to pick it, then place in Slot A or B. Use arrow keys and Enter for keyboard play.',
    focusIndex: 0, // for keyboard navigation across gears and slots
    activeElement: 'gear', // 'gear' or 'slot' for keyboard
    roundsToWin: ROUNDS,
  };

  // Utility: announce to screen reader
  function announce(text) {
    liveRegion.textContent = '';
    // Small timeout to ensure screen readers register update
    setTimeout(() => (liveRegion.textContent = text), 50);
  }

  // Initialize game
  function initGame() {
    // Create audio (but do not resume until user gesture)
    createAudio().catch((e) => console.warn('createAudio catch', e));

    resetRounds();
    attachEvents();
    draw();
    announce('Machine Math ready. Press Space to start. ' + game.message);
  }

  function resetRounds() {
    game.round = 0;
    game.score = 0;
    game.finished = false;
    startNewRound();
  }

  // Generate gears for a round
  function spawnGears() {
    const gears = [];
    // We'll generate a set of numbers that includes at least one valid pair for the target.
    // Choose target between 3 and 15
    const minTarget = 3;
    const maxTarget = 15;
    game.target = Math.floor(Math.random() * (maxTarget - minTarget + 1)) + minTarget;

    // Generate a valid pair first
    const a = Math.floor(Math.random() * Math.min(9, game.target - 1)) + 1;
    const b = game.target - a;
    const values = [a, b];

    // Fill more gears with random numbers 1..12
    while (values.length < 8) {
      const v = Math.floor(Math.random() * 12) + 1;
      // small chance to include duplicates
      values.push(v);
    }

    // Shuffle values
    for (let i = values.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [values[i], values[j]] = [values[j], values[i]];
    }

    // Place gears on a conveyor belt
    const startX = 110;
    const gap = 70;
    const y = 380;
    for (let i = 0; i < values.length; i++) {
      gears.push({
        id: `g${Date.now()}_${i}`,
        x: startX + i * gap,
        y,
        r: 24,
        value: values[i],
        picked: false,
        restingX: startX + i * gap,
        restingY: y,
      });
    }
    return gears;
  }

  function startNewRound() {
    if (game.round >= game.roundsToWin) {
      game.finished = true;
      announce('You have completed all rounds! Press Space to play again.');
      return;
    }

    game.round += 1;
    game.gears = spawnGears();
    game.selectedGearId = null;
    game.slots = [null, null];
    game.dragging = false;
    game.focusIndex = 0;
    game.activeElement = 'gear';
    game.finished = false;
    announce(`Round ${game.round} of ${game.roundsToWin}. Target number ${game.target}. Pick two gears that add up to ${game.target}.`);
  }

  // Drawing helpers
  function clearBG() {
    ctx.fillStyle = '#F2F8FF'; // soft sky
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
  }

  function drawMachine() {
    // Wacky machine body
    // Main box
    ctx.save();
    ctx.translate(20, 20);
    // Machine base
    ctx.fillStyle = '#DDEFF7';
    roundRect(ctx, 60, 30, 540, 320, 20);
    ctx.fill();

    // Highlights
    ctx.fillStyle = '#FFFFFFAA';
    roundRect(ctx, 70, 40, 200, 40, 8);
    ctx.fill();

    // Control panel
    ctx.fillStyle = '#2E6B8A';
    roundRect(ctx, 280, 50, 180, 80, 12);
    ctx.fill();

    // Opening where slots are
    ctx.fillStyle = '#EAF6FF';
    roundRect(ctx, 110, 120, 400, 140, 10);
    ctx.fill();

    // Decorative tubes
    ctx.strokeStyle = '#A2C6D9';
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(480, 80);
    ctx.lineTo(560, 40);
    ctx.stroke();

    ctx.restore();

    // Draw target display
    ctx.fillStyle = '#3A6B89';
    ctx.fillRect(520, 60, 160, 60);
    ctx.fillStyle = '#FFF';
    ctx.font = '20px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('TARGET', 600, 78);
    ctx.font = '34px serif';
    ctx.fillText(String(game.target), 600, 108);

    // Draw two slots A and B
    drawSlot('A', 200, 190, 70, 70, game.slots[0]);
    drawSlot('B', 350, 190, 70, 70, game.slots[1]);
  }

  function drawSlot(letter, x, y, w, h, gearId) {
    ctx.save();
    // slot background
    ctx.fillStyle = '#CCDFF0';
    roundRect(ctx, x - w / 2 - 4, y - h / 2 - 4, w + 8, h + 8, 10);
    ctx.fill();

    ctx.fillStyle = '#FFFFFF';
    roundRect(ctx, x - w / 2, y - h / 2, w, h, 8);
    ctx.fill();

    // Label
    ctx.fillStyle = '#556B78';
    ctx.font = '16px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(letter, x - w / 2 + 14, y - h / 2 + 20);

    // If gear placed, draw it inside
    if (gearId) {
      const gear = game.gears.find((g) => g.id === gearId);
      if (gear) {
        drawGear(x + 10, y, gear.r, gear.value, true);
      }
    } else {
      // placeholder small cog
      drawGear(x + 10, y, 16, '-', true, 0.15);
    }
    ctx.restore();
  }

  function drawConveyor() {
    // Conveyor belt at bottom for gears
    ctx.fillStyle = '#2B3E4E';
    roundRect(ctx, 60, 340, 600, 100, 14);
    ctx.fill();

    // Decorative bolts
    ctx.fillStyle = '#7FA3B8';
    for (let i = 0; i < 12; i++) {
      ctx.beginPath();
      ctx.arc(90 + i * 48, 380, 8, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Draw a gear with teeth and number
  function drawGear(x, y, r, value, flat = false, wobble = 0) {
    ctx.save();
    // Base circle
    ctx.translate(x, y);
    // Wobble rotation to look wacky
    const wobRot = wobble ? Math.sin(Date.now() / 300 + x) * wobble : 0;
    ctx.rotate(wobRot);

    // Teeth
    const teeth = Math.max(8, Math.round(r / 4 + 6));
    for (let i = 0; i < teeth; i++) {
      const angle = (i / teeth) * Math.PI * 2;
      const tx = Math.cos(angle) * (r + 8);
      const ty = Math.sin(angle) * (r + 8);
      ctx.fillStyle = '#B7DEFF';
      ctx.beginPath();
      ctx.ellipse(tx, ty, 6, 8, angle, 0, Math.PI * 2);
      ctx.fill();
    }

    // Main circle
    ctx.beginPath();
    ctx.fillStyle = '#7EC6FF';
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fill();

    // Inner circle
    ctx.beginPath();
    ctx.fillStyle = '#E9F8FF';
    ctx.arc(0, 0, r - 8, 0, Math.PI * 2);
    ctx.fill();

    // Number
    ctx.fillStyle = '#1B4050';
    ctx.font = `${r}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(String(value), 0, 0);

    ctx.restore();
  }

  // UI overlay: score, round, instructions, audio icon
  function drawHUD() {
    // Top bar
    ctx.fillStyle = '#EAF6FF';
    ctx.fillRect(0, 0, WIDTH, 28);

    ctx.fillStyle = '#2D4C57';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`Round: ${Math.min(game.round, game.roundsToWin)} / ${game.roundsToWin}`, 12, 18);
    ctx.fillText(`Score: ${game.score}`, 140, 18);

    // Instructions
    ctx.textAlign = 'center';
    ctx.fillText('Pick two gears that add up to the target. Click/Drag or use keyboard. Press M to mute/unmute.', WIDTH / 2, 18);

    // Audio visual cue (speaker icon)
    drawAudioIcon(WIDTH - 60, 6, audioMuted);
  }

  function drawAudioIcon(x, y, muted) {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = muted ? '#D9534F' : '#4CAF50';
    ctx.beginPath();
    ctx.moveTo(0, 8);
    ctx.lineTo(8, 8);
    ctx.lineTo(14, 2);
    ctx.lineTo(14, 22);
    ctx.lineTo(8, 16);
    ctx.lineTo(0, 16);
    ctx.closePath();
    ctx.fill();

    if (muted) {
      ctx.strokeStyle = '#FFF';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-2, 2);
      ctx.lineTo(18, 26);
      ctx.stroke();
    } else {
      ctx.strokeStyle = '#FFF';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(20, 12, 6, -0.6, 0.6);
      ctx.stroke();
    }
    ctx.restore();
  }

  // Draw gears on conveyor
  function drawGears() {
    for (const g of game.gears) {
      let x = g.x;
      let y = g.y;
      // If placed in slot, draw at slot position instead
      if (game.slots.includes(g.id)) {
        // handled in slot drawing
        continue;
      }
      drawGear(x, y, g.r, g.value, false, 0.04);
      // outline if selected
      if (game.selectedGearId === g.id) {
        ctx.strokeStyle = '#FFD54F';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(x, y, g.r + 10, 0, Math.PI * 2);
        ctx.stroke();
      }
      // Keyboard focus highlight for first run
      if (game.activeElement === 'gear') {
        const idx = game.gears.indexOf(g);
        if (idx === game.focusIndex) {
          ctx.strokeStyle = '#8EE5A1';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(x, y, g.r + 14, 0, Math.PI * 2);
          ctx.stroke();
        }
      }
    }
  }

  // Render everything
  function draw() {
    clearBG();
    drawMachine();
    drawConveyor();
    drawGears();
    drawHUD();

    // Draw slot labels text for clarity
    ctx.fillStyle = '#264653';
    ctx.font = '18px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Slot A', 150, 170);
    ctx.fillText('Slot B', 300, 170);

    // Draw messages
    ctx.fillStyle = '#235A6B';
    ctx.font = '16px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(game.message, 12, HEIGHT - 12);

    // If finished show overlay
    if (game.finished) {
      ctx.save();
      ctx.fillStyle = 'rgba(10, 20, 30, 0.6)';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = '#FFF';
      ctx.font = '34px serif';
      ctx.textAlign = 'center';
      if (game.score >= game.roundsToWin) {
        ctx.fillText('Machine Master! You win!', WIDTH / 2, HEIGHT / 2 - 20);
        ctx.font = '20px sans-serif';
        ctx.fillText('Press Space to play again.', WIDTH / 2, HEIGHT / 2 + 20);
      } else {
        ctx.fillText('All rounds complete', WIDTH / 2, HEIGHT / 2 - 20);
        ctx.font = '20px sans-serif';
        ctx.fillText('Press Space to play again.', WIDTH / 2, HEIGHT / 2 + 20);
      }
      ctx.restore();
    }

    requestAnimationFrame(draw);
  }

  // Geometry helpers
  function pointInRect(px, py, rx, ry, rw, rh) {
    return px >= rx && px <= rx + rw && py >= ry && py <= ry + rh;
  }

  function roundRect(ctx, x, y, w, h, r) {
    const radius = r || 5;
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.arcTo(x + w, y, x + w, y + h, radius);
    ctx.arcTo(x + w, y + h, x, y + h, radius);
    ctx.arcTo(x, y + h, x, y, radius);
    ctx.arcTo(x, y, x + w, y, radius);
    ctx.closePath();
  }

  // Input handling: mouse/keyboard
  function attachEvents() {
    // Focus canvas for keyboard
    canvas.addEventListener('click', async (e) => {
      canvas.focus();
      await ensureAudioRunning();
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      // Check if clicked on audio icon
      if (mx >= WIDTH - 80 && mx <= WIDTH - 40 && my >= 0 && my <= 28) {
        toggleMute();
        return;
      }
      // If finished overlay clicked, restart
      if (game.finished) {
        resetRounds();
        startNewRound();
        return;
      }
      // Check gears
      for (const g of game.gears) {
        // skip if already placed in slot
        if (game.slots.includes(g.id)) continue;
        const dx = mx - g.x;
        const dy = my - g.y;
        if (Math.hypot(dx, dy) <= g.r + 8) {
          // pick this gear
          pickGear(g.id);
          // set drag offset
          game.dragging = true;
          game.dragOffset.x = dx;
          game.dragOffset.y = dy;
          return;
        }
      }

      // If clicked on slot A or B
      // slot A coords we used earlier: center at (200+10,190) (since drawSlot drew gear at x+10)
      const slotACenter = { x: 210, y: 190, r: 40 };
      const slotBCenter = { x: 360, y: 190, r: 40 };
      if (pointInsideCircle(mx, my, slotACenter.x, slotACenter.y, slotACenter.r)) {
        placeSelectedInSlot(0);
      } else if (pointInsideCircle(mx, my, slotBCenter.x, slotBCenter.y, slotBCenter.r)) {
        placeSelectedInSlot(1);
      }
    });

    // Mouse move for dragging
    canvas.addEventListener('mousemove', (e) => {
      if (!game.dragging || !game.selectedGearId) return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const g = game.gears.find((x) => x.id === game.selectedGearId);
      if (g) {
        g.x = mx - game.dragOffset.x;
        g.y = my - game.dragOffset.y;
      }
    });

    // Mouse up to drop
    canvas.addEventListener('mouseup', () => {
      if (!game.dragging) return;
      game.dragging = false;
      // If released over a slot, place it
      // compute gear center
      const g = game.gears.find((x) => x.id === game.selectedGearId);
      if (!g) return;
      const mx = g.x;
      const my = g.y;
      // slot centers as before
      const slotACenter = { x: 210, y: 190, r: 40 };
      const slotBCenter = { x: 360, y: 190, r: 40 };
      if (pointInsideCircle(mx, my, slotACenter.x, slotACenter.y, slotACenter.r)) {
        placeSelectedInSlot(0);
      } else if (pointInsideCircle(mx, my, slotBCenter.x, slotBCenter.y, slotBCenter.r)) {
        placeSelectedInSlot(1);
      } else {
        // snap back to conveyor resting position
        if (g.restingX && g.restingY) {
          g.x = g.restingX;
          g.y = g.restingY;
        }
      }
    });

    // Keyboard controls
    canvas.addEventListener('keydown', async (e) => {
      await ensureAudioRunning();
      if (e.key === ' ' || e.key === 'Spacebar') {
        e.preventDefault();
        if (game.finished) {
          resetRounds();
          startNewRound();
          return;
        }
        // Space toggles start/resume round by announcing goal
        announce(`Round ${game.round} target ${game.target}. Pick two gears that sum to ${game.target}.`);
        return;
      }

      if (e.key === 'm' || e.key === 'M') {
        toggleMute();
        return;
      }

      // Navigation: left/right/up/down, Enter to pick/place, Escape to cancel selection
      if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
        handleArrowKey(e.key);
        return;
      }
      if (e.key === 'Enter') {
        handleEnterKey();
        return;
      }
      if (e.key === 'Escape') {
        cancelSelection();
        return;
      }
      // Numbers 1-8 correspond to gears for quick selection
      if (/^[1-8]$/.test(e.key)) {
        const idx = parseInt(e.key, 10) - 1;
        if (game.gears[idx]) {
          pickGear(game.gears[idx].id);
        }
      }
    });

    // Touch support minimal: emulate mouse
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const mx = touch.clientX - rect.left;
      const my = touch.clientY - rect.top;
      // same as click
      for (const g of game.gears) {
        if (game.slots.includes(g.id)) continue;
        const dx = mx - g.x;
        const dy = my - g.y;
        if (Math.hypot(dx, dy) <= g.r + 8) {
          pickGear(g.id);
          game.dragging = true;
          game.dragOffset.x = dx;
          game.dragOffset.y = dy;
          return;
        }
      }
    });
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!game.dragging || !game.selectedGearId) return;
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const mx = touch.clientX - rect.left;
      const my = touch.clientY - rect.top;
      const g = game.gears.find((x) => x.id === game.selectedGearId);
      if (g) {
        g.x = mx - game.dragOffset.x;
        g.y = my - game.dragOffset.y;
      }
    });
    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      if (!game.dragging) return;
      game.dragging = false;
      const g = game.gears.find((x) => x.id === game.selectedGearId);
      if (!g) return;
      const mx = g.x;
      const my = g.y;
      const slotACenter = { x: 210, y: 190, r: 40 };
      const slotBCenter = { x: 360, y: 190, r: 40 };
      if (pointInsideCircle(mx, my, slotACenter.x, slotACenter.y, slotACenter.r)) {
        placeSelectedInSlot(0);
      } else if (pointInsideCircle(mx, my, slotBCenter.x, slotBCenter.y, slotBCenter.r)) {
        placeSelectedInSlot(1);
      } else {
        if (g.restingX && g.restingY) {
          g.x = g.restingX;
          g.y = g.restingY;
        }
      }
    });

    // Ensure initial focus
    canvas.addEventListener('focus', () => {
      // Visual focus captured in draw loop via keyboard events
    });
  }

  // Input helpers
  function handleArrowKey(key) {
    if (game.activeElement === 'gear') {
      // Move focus across gears
      const count = game.gears.length;
      if (key === 'ArrowLeft') {
        game.focusIndex = Math.max(0, game.focusIndex - 1);
      } else if (key === 'ArrowRight') {
        game.focusIndex = Math.min(count - 1, game.focusIndex + 1);
      } else if (key === 'ArrowUp' || key === 'ArrowDown') {
        // switch to slots
        game.activeElement = 'slot';
        game.focusIndex = 0; // slot A focus
      }
    } else if (game.activeElement === 'slot') {
      // Toggle between slot A and B with left/right
      if (key === 'ArrowLeft' || key === 'ArrowRight') {
        game.focusIndex = game.focusIndex === 0 ? 1 : 0;
      } else if (key === 'ArrowUp' || key === 'ArrowDown') {
        // back to gears
        game.activeElement = 'gear';
        game.focusIndex = 0;
      }
    }
    // Announce current focus
    if (game.activeElement === 'gear') {
      const g = game.gears[game.focusIndex];
      if (g) announce(`Focused gear ${game.focusIndex + 1}, value ${g.value}`);
    } else {
      announce(`Focused slot ${game.focusIndex === 0 ? 'A' : 'B'}`);
    }
  }

  function handleEnterKey() {
    if (game.activeElement === 'gear') {
      const g = game.gears[game.focusIndex];
      if (g && !game.slots.includes(g.id)) {
        pickGear(g.id);
      } else {
        announce('No gear to pick here.');
      }
    } else {
      // Place currently selected gear into focused slot
      placeSelectedInSlot(game.focusIndex);
    }
  }

  function pointInsideCircle(px, py, cx, cy, r) {
    return (px - cx) * (px - cx) + (py - cy) * (py - cy) <= r * r;
  }

  function pickGear(gearId) {
    // If already selected, deselect
    if (game.selectedGearId === gearId) {
      game.selectedGearId = null;
      announce('Gear deselected');
      return;
    }
    const gear = game.gears.find((g) => g.id === gearId);
    if (!gear) return;
    game.selectedGearId = gearId;
    // bring to front by moving to end of array
    const idx = game.gears.indexOf(gear);
    if (idx >= 0) {
      game.gears.splice(idx, 1);
      game.gears.push(gear);
    }
    announce(`Picked gear with value ${gear.value}. Place it in Slot A or B.`);
    playPlace();
  }

  function placeSelectedInSlot(slotIndex) {
    if (!game.selectedGearId) {
      announce('No gear selected to place.');
      return;
    }
    if (game.slots[slotIndex]) {
      announce(`Slot ${slotIndex === 0 ? 'A' : 'B'} already occupied. Remove gear first.`);
      return;
    }
    // Place gear
    const gear = game.gears.find((g) => g.id === game.selectedGearId);
    if (!gear) return;
    game.slots[slotIndex] = gear.id;
    // set gear coords to slot center visually
    const slotCenter = slotIndex === 0 ? { x: 210, y: 190 } : { x: 360, y: 190 };
    gear.x = slotCenter.x + 10;
    gear.y = slotCenter.y;
    game.selectedGearId = null;
    playPlace();
    announce(`Placed gear with value ${gear.value} into Slot ${slotIndex === 0 ? 'A' : 'B'}.`);

    // If both slots filled, evaluate
    if (game.slots[0] && game.slots[1]) {
      setTimeout(evaluateSlots, 250);
    }
  }

  function cancelSelection() {
    if (game.selectedGearId) {
      const g = game.gears.find((x) => x.id === game.selectedGearId);
      if (g && g.restingX && g.restingY) {
        g.x = g.restingX;
        g.y = g.restingY;
      }
      game.selectedGearId = null;
      game.dragging = false;
      announce('Selection cancelled.');
    }
  }

  function evaluateSlots() {
    const gidA = game.slots[0];
    const gidB = game.slots[1];
    const gearA = game.gears.find((g) => g.id === gidA);
    const gearB = game.gears.find((g) => g.id === gidB);
    if (!gearA || !gearB) {
      announce('Error: missing gear in slot.');
      return;
    }
    const sum = gearA.value + gearB.value;
    if (sum === game.target) {
      // success!
      playCorrect();
      game.score += 1;
      game.message = `Nice! ${gearA.value} + ${gearB.value} = ${game.target}.`;
      announce(`Correct! ${gearA.value} + ${gearB.value} equals ${game.target}.`);
      // Light up machine animation: we'll animate by temporarily showing success message and then next round
      setTimeout(() => {
        // Clear placed gears by removing them from list to avoid duplicates
        game.gears = game.gears.filter((g) => ![gidA, gidB].includes(g.id));
        game.slots = [null, null];
        if (game.round >= game.roundsToWin) {
          game.finished = true;
          announce(`You finished all ${game.roundsToWin} rounds. Score ${game.score}. Press Space to play again.`);
        } else {
          startNewRound();
        }
      }, 800);
    } else {
      // incorrect
      playIncorrect();
      game.message = `Oops: ${gearA.value} + ${gearB.value} = ${sum}, not ${game.target}. Try again.`;
      announce(`Incorrect. ${gearA.value} plus ${gearB.value} makes ${sum}. Remove a gear or try different ones.`);
      // Unset one slot (B) and snap back A to conveyor for retry to encourage different combos
      setTimeout(() => {
        // Snap both back to conveyor but keep values; they stay in gears array
        for (const sid of [gidA, gidB]) {
          const gg = game.gears.find((x) => x.id === sid);
          if (gg) {
            // Place back at resting pos or nearest slot replaced
            gg.x = gg.restingX || gg.x;
            gg.y = gg.restingY || gg.y;
          }
        }
        game.slots = [null, null];
      }, 600);
    }
  }

  function toggleMute() {
    audioMuted = !audioMuted;
    if (bgGain) bgGain.gain.value = audioMuted ? 0 : 0.03;
    game.message = audioMuted ? 'Sound muted' : 'Sound on';
    announce(game.message);
  }

  // Start the game initialization
  initGame();

  // Expose minimal debug controls to window (safe)
  window.__MachineMathGame = {
    restart: () => {
      resetRounds();
      startNewRound();
    },
    mute: () => {
      audioMuted = true;
      if (bgGain) bgGain.gain.value = 0;
    },
    unmute: () => {
      audioMuted = false;
      if (bgGain) bgGain.gain.value = 0.03;
    },
  };

  // Start the first round after a user gesture requirement, but allow manual start
  // Provide instructions visually; already included.

})();
---

