{
  "generated_date": "2025-10-23",
  "generated_timestamp": "2025-10-23T00:28:41.545144",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8975,
  "game_filename": "2025-10-23.js",
  "game_size_bytes": 26134,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Drone Math Adventure - Canvas Game for ages 7-9\n  // Renders inside element with ID 'game-of-the-day-stage'\n  // Strictly uses Canvas and Web Audio API, no external assets.\n\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const TARGET_CORRECT = 10;\n  const MAX_WRONG = 3;\n  const PADDING = 12; // minimum spacing between UI elements\n  const BODY_FONT = '16px Arial';\n  const IMPORTANT_FONT = '22px Arial';\n  const TITLE_FONT = '28px Arial';\n  const ANSWER_FONT = '20px Arial';\n\n  // Get stage element\n  const stage = document.getElementById('game-of-the-day-stage');\n  if (!stage) {\n    console.error('Element with id \"game-of-the-day-stage\" not found.');\n    return;\n  }\n\n  // Clear stage and set up\n  stage.innerHTML = '';\n  stage.style.position = 'relative';\n\n  // Create an accessibility live region (hidden visually but available to screen readers)\n  const liveRegion = document.createElement('div');\n  liveRegion.setAttribute('aria-live', 'polite');\n  liveRegion.style.position = 'absolute';\n  liveRegion.style.left = '-9999px';\n  liveRegion.style.width = '1px';\n  liveRegion.style.height = '1px';\n  liveRegion.style.overflow = 'hidden';\n  stage.appendChild(liveRegion);\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute('tabindex', '0'); // make focusable for keyboard input\n  canvas.style.outline = 'none';\n  stage.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Audio setup with error handling\n  let audioCtx = null;\n  let masterGain = null;\n  let ambientOsc = null;\n  let audioEnabled = true;\n\n  function initAudio() {\n    if (audioCtx) return;\n    try {\n      const AudioContext = window.AudioContext || window.webkitAudioContext;\n      audioCtx = new AudioContext();\n      masterGain = audioCtx.createGain();\n      masterGain.gain.value = 0.18; // gentle volume\n      masterGain.connect(audioCtx.destination);\n\n      // Create ambient hum (soft drone)\n      ambientOsc = audioCtx.createOscillator();\n      const ambientGain = audioCtx.createGain();\n      ambientOsc.type = 'sine';\n      ambientOsc.frequency.value = 80; // low hum\n      ambientGain.gain.value = 0.03;\n      const lpf = audioCtx.createBiquadFilter();\n      lpf.type = 'lowpass';\n      lpf.frequency.value = 500;\n      ambientOsc.connect(ambientGain);\n      ambientGain.connect(lpf);\n      lpf.connect(masterGain);\n      ambientOsc.start();\n      // gently modulate\n      const lfo = audioCtx.createOscillator();\n      const lfoGain = audioCtx.createGain();\n      lfo.type = 'sine';\n      lfo.frequency.value = 0.15;\n      lfoGain.gain.value = 20;\n      lfo.connect(lfoGain);\n      lfoGain.connect(ambientOsc.frequency);\n      lfo.start();\n    } catch (e) {\n      console.warn('Web Audio API not available:', e);\n      audioEnabled = false;\n      audioCtx = null;\n    }\n  }\n\n  function playTone({ freq = 440, duration = 0.2, type = 'sine', attack = 0.01, decay = 0.05, isCorrect = true } = {}) {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      const osc = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n      osc.type = type;\n      osc.frequency.value = freq;\n      gain.gain.value = 0;\n      osc.connect(gain);\n      const filter = audioCtx.createBiquadFilter();\n      filter.type = isCorrect ? 'lowpass' : 'highshelf';\n      filter.frequency.value = isCorrect ? 1200 : 800;\n      gain.connect(filter);\n      filter.connect(masterGain);\n\n      const t = audioCtx.currentTime;\n      gain.gain.cancelScheduledValues(t);\n      gain.gain.setValueAtTime(0, t);\n      gain.gain.linearRampToValueAtTime(0.12, t + attack);\n      gain.gain.exponentialRampToValueAtTime(0.001, t + duration);\n      osc.start(t);\n      osc.stop(t + duration + 0.05);\n    } catch (e) {\n      console.warn('Audio play error:', e);\n    }\n  }\n\n  // Utility helpers\n  const randInt = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;\n\n  function generateQuestion() {\n    // Randomly choose addition or subtraction, easy levels\n    const type = Math.random() < 0.6 ? 'add' : 'sub';\n    if (type === 'add') {\n      const a = randInt(1, 12);\n      const b = randInt(1, 12);\n      const answer = a + b;\n      const options = makeOptions(answer, 4, 1, 24);\n      return { text: `${a} + ${b} = ?`, answer, options };\n    } else {\n      let a = randInt(5, 20);\n      let b = randInt(1, a - 1);\n      const answer = a - b;\n      const options = makeOptions(answer, 4, 0, 20);\n      return { text: `${a} - ${b} = ?`, answer, options };\n    }\n  }\n\n  function makeOptions(correct, count, min, max) {\n    const set = new Set();\n    set.add(correct);\n    while (set.size < count) {\n      const delta = randInt(-4, 4);\n      const candidate = correct + delta;\n      if (candidate >= min && candidate <= max) set.add(candidate);\n    }\n    const arr = Array.from(set);\n    // shuffle\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    return arr;\n  }\n\n  // Game State\n  let state = {\n    screen: 'start', // 'start', 'playing', 'win', 'lose'\n    score: 0,\n    wrong: 0,\n    question: null,\n    selectedIndex: 0,\n    optionsBoxes: [], // store rectangles for click detection\n    drones: [],\n    clock: 0,\n    audioOn: true,\n  };\n\n  // Create some drone objects for calming wacky visuals\n  function createDrones() {\n    state.drones = [];\n    const colors = ['#FFA7C4', '#A7D8FF', '#FFF7A7', '#B8FFA7', '#D0A7FF'];\n    for (let i = 0; i < 5; i++) {\n      state.drones.push({\n        x: Math.random() * WIDTH,\n        y: 80 + Math.random() * 220,\n        vx: 0.3 + Math.random() * 0.9,\n        vy: Math.sin(Math.random() * Math.PI * 2) * 0.2,\n        size: 22 + Math.random() * 14,\n        color: colors[i % colors.length],\n        rotorAng: Math.random() * Math.PI * 2,\n      });\n    }\n  }\n\n  createDrones();\n\n  // UI layout positions\n  function layoutPositions() {\n    // Score top-left\n    const scorePos = { x: PADDING, y: PADDING };\n    // Lives top-right\n    const livesPos = { x: WIDTH - PADDING, y: PADDING };\n    // Question top center\n    const questionPos = { x: WIDTH / 2, y: 70 };\n    // Answers block center\n    const answersArea = { x: WIDTH / 2, y: 180, width: WIDTH - 2 * PADDING, height: 220 };\n    // Instructions bottom center\n    const instructionPos = { x: WIDTH / 2, y: HEIGHT - 60 };\n    return { scorePos, livesPos, questionPos, answersArea, instructionPos };\n  }\n\n  // Drawing helpers with measureText to ensure proper background rectangles\n  function drawTextWithBackground(text, font, x, y, align = 'left', textColor = '#000', bgColor = 'rgba(255,255,255,0.7)') {\n    ctx.save();\n    ctx.font = font;\n    ctx.textAlign = align;\n    ctx.textBaseline = 'top';\n    const metrics = ctx.measureText(text);\n    const textWidth = metrics.width;\n    const textHeight = parseInt(font, 10) + 6; // approximate height\n    let bx = x;\n    if (align === 'center') bx = x - textWidth / 2;\n    else if (align === 'right') bx = x - textWidth;\n    const padding = 8;\n    ctx.fillStyle = bgColor;\n    ctx.fillRect(bx - padding, y - padding / 2, textWidth + padding * 2, textHeight + padding);\n    ctx.fillStyle = textColor;\n    ctx.fillText(text, x, y);\n    ctx.restore();\n    return { bx: bx - padding, by: y - padding / 2, bw: textWidth + padding * 2, bh: textHeight + padding };\n  }\n\n  // Draw calming background with clouds\n  function drawBackground(t) {\n    // gradient sky\n    const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    grad.addColorStop(0, '#E8F6FF');\n    grad.addColorStop(1, '#F8FFF4');\n    ctx.fillStyle = grad;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // soft ground\n    ctx.fillStyle = '#EAF7E6';\n    ctx.fillRect(0, HEIGHT - 80, WIDTH, 80);\n\n    // moving clouds\n    const cloudCount = 6;\n    for (let i = 0; i < cloudCount; i++) {\n      const cx = ((t * 0.02) + i * 140) % (WIDTH + 200) - 100;\n      const cy = 40 + ((i % 3) * 30);\n      drawCloud(cx, cy, 40 + (i % 3) * 10, 0.85);\n    }\n  }\n\n  function drawCloud(cx, cy, size, alpha) {\n    ctx.save();\n    ctx.globalAlpha = alpha;\n    ctx.fillStyle = '#FFFFFF';\n    ctx.beginPath();\n    ctx.arc(cx, cy, size * 0.6, 0, Math.PI * 2);\n    ctx.arc(cx + size * 0.5, cy + 4, size * 0.5, 0, Math.PI * 2);\n    ctx.arc(cx - size * 0.5, cy + 6, size * 0.45, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function drawDrone(drone, t) {\n    ctx.save();\n    ctx.translate(drone.x, drone.y);\n    // body\n    ctx.fillStyle = drone.color;\n    ctx.beginPath();\n    ctx.ellipse(0, 0, drone.size * 1.2, drone.size * 0.75, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // cockpit\n    ctx.fillStyle = '#ffffff';\n    ctx.globalAlpha = 0.7;\n    ctx.beginPath();\n    ctx.ellipse(-drone.size * 0.2, 0, drone.size * 0.5, drone.size * 0.35, -0.3, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.globalAlpha = 1;\n\n    // legs\n    ctx.strokeStyle = '#6b6b6b';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(-drone.size * 0.6, drone.size * 0.5);\n    ctx.lineTo(-drone.size * 0.8, drone.size * 0.9);\n    ctx.moveTo(drone.size * 0.6, drone.size * 0.5);\n    ctx.lineTo(drone.size * 0.8, drone.size * 0.9);\n    ctx.stroke();\n\n    // rotors - 2\n    const rotorOffset = drone.size * 0.9;\n    for (let i = -1; i <= 1; i += 2) {\n      ctx.save();\n      ctx.translate(i * rotorOffset, -drone.size * 0.4);\n      ctx.rotate(drone.rotorAng);\n      ctx.fillStyle = '#444';\n      ctx.fillRect(-drone.size * 0.05, -drone.size * 0.8, drone.size * 0.1, drone.size * 1.6);\n      ctx.beginPath();\n      ctx.fillStyle = '#222';\n      ctx.ellipse(0, -drone.size * 0.95, drone.size * 0.12, drone.size * 0.02, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n    }\n\n    ctx.restore();\n  }\n\n  // Draw UI frames\n  function drawUI() {\n    ctx.save();\n    ctx.font = BODY_FONT;\n    ctx.textBaseline = 'top';\n\n    const pos = layoutPositions();\n\n    // Score top-left\n    const scoreText = `Score: ${state.score}`;\n    drawTextWithBackground(scoreText, BODY_FONT, pos.scorePos.x + 4, pos.scorePos.y + 4, 'left', '#003', 'rgba(255,255,255,0.8)');\n\n    // Lives top-right and audio toggle\n    const livesText = `Wrong: ${state.wrong} / ${MAX_WRONG}`;\n    // measure lives width\n    ctx.font = BODY_FONT;\n    const livesW = ctx.measureText(livesText).width;\n    const livesX = WIDTH - PADDING;\n    // draw background aligned to right\n    const livesBox = drawTextWithBackground(livesText, BODY_FONT, livesX, pos.livesPos.y + 4, 'right', '#600', 'rgba(255,255,255,0.8)');\n\n    // Audio toggle small icon next to lives (left of lives box)\n    const iconSize = 28;\n    const iconX = livesBox.bx - PADDING - iconSize;\n    const iconY = pos.livesPos.y + 4;\n    ctx.fillStyle = state.audioOn ? '#4CAF50' : '#B0B0B0';\n    ctx.fillRect(iconX, iconY, iconSize, iconSize);\n    ctx.fillStyle = '#fff';\n    ctx.font = '16px Arial';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(state.audioOn ? '\ud83d\udd0a' : '\ud83d\udd08', iconX + iconSize / 2, iconY + iconSize / 2);\n\n    // Store audio icon rect for clicks\n    state.audioIconRect = { x: iconX, y: iconY, w: iconSize, h: iconSize };\n\n    ctx.restore();\n  }\n\n  function drawQuestionAndAnswers() {\n    const pos = layoutPositions();\n    ctx.save();\n    // Question\n    ctx.font = IMPORTANT_FONT;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'top';\n    const q = state.question ? state.question.text : 'Press Start to begin';\n    // draw background wide enough\n    const qMetrics = ctx.measureText(q);\n    ctx.fillStyle = 'rgba(255,255,255,0.85)';\n    const qPad = 10;\n    ctx.fillRect(pos.questionPos.x - qMetrics.width / 2 - qPad, pos.questionPos.y - qPad, qMetrics.width + qPad * 2, 36 + qPad);\n    ctx.fillStyle = '#1a3';\n    ctx.fillText(q, pos.questionPos.x, pos.questionPos.y + 6);\n    ctx.restore();\n\n    // Answers: arrange in two rows of two\n    const opts = state.question ? state.question.options : [];\n    state.optionsBoxes = [];\n    const area = { x: WIDTH / 2 - 260, y: pos.questionPos.y + 60, w: 520, h: 220 };\n    const boxW = 240;\n    const boxH = 80;\n    const gapX = 40;\n    const gapY = 20;\n    ctx.save();\n    ctx.font = ANSWER_FONT;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    for (let i = 0; i < opts.length; i++) {\n      const col = i % 2;\n      const row = Math.floor(i / 2);\n      const bx = area.x + col * (boxW + gapX);\n      const by = area.y + row * (boxH + gapY);\n      // highlight if selected\n      const isSelected = state.selectedIndex === i && state.screen === 'playing';\n      ctx.fillStyle = isSelected ? 'rgba(200,255,200,0.95)' : 'rgba(255,255,255,0.9)';\n      // rounded rect\n      roundRect(ctx, bx, by, boxW, boxH, 10, true, false, isSelected ? '#bfe7be' : '#eee');\n      ctx.fillStyle = '#003';\n      ctx.fillText(String(opts[i]), bx + boxW / 2, by + boxH / 2);\n      state.optionsBoxes.push({ x: bx, y: by, w: boxW, h: boxH });\n    }\n    ctx.restore();\n  }\n\n  // Utility to draw a rounded rectangle with optional fill\n  function roundRect(ctx, x, y, w, h, r, fill, stroke, fillColor) {\n    if (r < 0) r = 0;\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fill) {\n      ctx.fillStyle = fillColor || '#fff';\n      ctx.fill();\n    }\n    if (stroke) ctx.stroke();\n  }\n\n  // Draw start screen, win screen, lose screen overlays\n  function drawOverlay() {\n    ctx.save();\n    ctx.fillStyle = 'rgba(0,0,0,0.2)';\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.restore();\n  }\n\n  function drawStartScreen() {\n    drawOverlay();\n    ctx.save();\n    ctx.font = TITLE_FONT;\n    ctx.textAlign = 'center';\n    ctx.fillStyle = '#012';\n    const title = 'Drone Math Adventure';\n    ctx.fillText(title, WIDTH / 2, 120);\n\n    ctx.font = IMPORTANT_FONT;\n    ctx.fillStyle = '#044';\n    ctx.fillText('Help the friendly drones deliver parcels by solving math!', WIDTH / 2, 170);\n\n    ctx.font = BODY_FONT;\n    ctx.fillStyle = '#003';\n    ctx.textAlign = 'center';\n    const lines = [\n      'Goal: Answer 10 questions correctly.',\n      `You can get ${MAX_WRONG} wrong answers before the game is over.`,\n      'Use number keys 1-4, arrow keys, or click answers. Press Enter to confirm.',\n      'Press SPACE or click START to begin. Toggle sound with the speaker icon.',\n    ];\n    let y = 230;\n    for (let line of lines) {\n      const metrics = ctx.measureText(line);\n      // draw background\n      ctx.fillStyle = 'rgba(255,255,255,0.9)';\n      ctx.fillRect(WIDTH / 2 - metrics.width / 2 - 10, y - 6, metrics.width + 20, 28);\n      ctx.fillStyle = '#002';\n      ctx.fillText(line, WIDTH / 2, y);\n      y += 34;\n    }\n\n    // Draw start button\n    const btnW = 160;\n    const btnH = 54;\n    const bx = WIDTH / 2 - btnW / 2;\n    const by = y + 12;\n    roundRect(ctx, bx, by, btnW, btnH, 10, true, false, '#6BC8FF');\n    ctx.font = IMPORTANT_FONT;\n    ctx.fillStyle = '#013';\n    ctx.fillText('START', WIDTH / 2, by + 12);\n    state.startButton = { x: bx, y: by, w: btnW, h: btnH };\n    ctx.restore();\n  }\n\n  function drawEndScreen(win) {\n    drawOverlay();\n    ctx.save();\n    ctx.font = TITLE_FONT;\n    ctx.textAlign = 'center';\n    ctx.fillStyle = win ? '#0A6' : '#A00';\n    const title = win ? 'Hooray! Drones Delivered Everything!' : 'Uh-oh! Parcels missed!';\n    ctx.fillText(title, WIDTH / 2, 120);\n\n    ctx.font = IMPORTANT_FONT;\n    ctx.fillStyle = '#013';\n    ctx.fillText(`Score: ${state.score}`, WIDTH / 2, 170);\n\n    ctx.font = BODY_FONT;\n    ctx.fillStyle = '#013';\n    const message = win\n      ? 'You answered enough questions to guide the drones home. Great job!'\n      : 'The drones need more practice. Try again to improve your score!';\n    const metrics = ctx.measureText(message);\n    ctx.fillStyle = 'rgba(255,255,255,0.9)';\n    ctx.fillRect(WIDTH / 2 - metrics.width / 2 - 10, 220 - 6, metrics.width + 20, 28);\n    ctx.fillStyle = '#013';\n    ctx.fillText(message, WIDTH / 2, 220);\n\n    // Restart button\n    const btnW = 180;\n    const btnH = 54;\n    const bx = WIDTH / 2 - btnW / 2;\n    const by = 260;\n    roundRect(ctx, bx, by, btnW, btnH, 10, true, false, '#FFD76B');\n    ctx.font = IMPORTANT_FONT;\n    ctx.fillStyle = '#333';\n    ctx.fillText('PLAY AGAIN', WIDTH / 2, by + 12);\n    state.restartButton = { x: bx, y: by, w: btnW, h: btnH };\n\n    // Instructions for restart with keyboard\n    ctx.font = BODY_FONT;\n    ctx.fillStyle = '#023';\n    ctx.fillText('Press R to restart', WIDTH / 2, by + btnH + 18);\n    ctx.restore();\n  }\n\n  // Feedback messages and live region updates\n  function announceForAccessibility(text) {\n    if (!liveRegion) return;\n    liveRegion.textContent = text;\n  }\n\n  // Input handling\n  canvas.addEventListener('click', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    handleClick(mx, my);\n    // Ensure audio context unlocked on first tap\n    if (audioEnabled && audioCtx && audioCtx.state === 'suspended') {\n      audioCtx.resume().catch(() => {});\n    }\n    canvas.focus();\n  });\n\n  function handleClick(mx, my) {\n    if (state.screen === 'start') {\n      const b = state.startButton;\n      if (b && pointInRect(mx, my, b)) {\n        startGame();\n        return;\n      }\n    } else if (state.screen === 'playing') {\n      // audio toggle\n      if (state.audioIconRect && pointInRect(mx, my, state.audioIconRect)) {\n        toggleAudio();\n        return;\n      }\n      // click answer boxes\n      for (let i = 0; i < state.optionsBoxes.length; i++) {\n        if (pointInRect(mx, my, state.optionsBoxes[i])) {\n          state.selectedIndex = i;\n          submitAnswer();\n          return;\n        }\n      }\n    } else if (state.screen === 'win' || state.screen === 'lose') {\n      const b = state.restartButton;\n      if (b && pointInRect(mx, my, b)) {\n        restartGame();\n        return;\n      }\n    }\n  }\n\n  function pointInRect(px, py, r) {\n    return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;\n  }\n\n  // Keyboard controls\n  canvas.addEventListener('keydown', (e) => {\n    if (state.screen === 'start') {\n      if (e.code === 'Space' || e.code === 'Enter') {\n        startGame();\n        e.preventDefault();\n      }\n      if (e.key.toLowerCase() === 'm') toggleAudio();\n    } else if (state.screen === 'playing') {\n      if (e.key >= '1' && e.key <= '4') {\n        const idx = parseInt(e.key, 10) - 1;\n        if (idx < state.question.options.length) {\n          state.selectedIndex = idx;\n          submitAnswer();\n        }\n      } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {\n        state.selectedIndex = (state.selectedIndex + state.question.options.length - 1) % state.question.options.length;\n      } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {\n        state.selectedIndex = (state.selectedIndex + 1) % state.question.options.length;\n      } else if (e.key === 'Enter') {\n        submitAnswer();\n      } else if (e.key.toLowerCase() === 'm') {\n        toggleAudio();\n      }\n    } else if (state.screen === 'win' || state.screen === 'lose') {\n      if (e.key.toLowerCase() === 'r' || e.code === 'Enter') {\n        restartGame();\n      }\n      if (e.key.toLowerCase() === 'm') toggleAudio();\n    }\n  });\n\n  // Toggle audio on/off\n  function toggleAudio() {\n    if (!audioCtx && audioEnabled) {\n      initAudio();\n      if (!audioCtx) {\n        audioEnabled = false;\n        state.audioOn = false;\n        announceForAccessibility('Audio not available.');\n        return;\n      }\n    }\n    state.audioOn = !state.audioOn;\n    if (audioCtx && masterGain) {\n      masterGain.gain.value = state.audioOn ? 0.18 : 0;\n    }\n    announceForAccessibility(`Audio ${state.audioOn ? 'on' : 'off'}`);\n  }\n\n  // Game control functions\n  function startGame() {\n    initAudio();\n    state.screen = 'playing';\n    state.score = 0;\n    state.wrong = 0;\n    state.selectedIndex = 0;\n    state.question = generateQuestion();\n    announceForAccessibility('Game started. ' + state.question.text);\n  }\n\n  function restartGame() {\n    state.screen = 'start';\n    state.score = 0;\n    state.wrong = 0;\n    state.selectedIndex = 0;\n    state.question = null;\n    announceForAccessibility('Game restarted. Press start to play again.');\n  }\n\n  function submitAnswer() {\n    if (!state.question) return;\n    const chosen = state.question.options[state.selectedIndex];\n    if (chosen === state.question.answer) {\n      state.score += 1;\n      playFeedback(true);\n      announceForAccessibility(`Correct! ${state.question.text.replace('= ?', `= ${chosen}`)}. Score ${state.score}.`);\n      // check for win\n      if (state.score >= TARGET_CORRECT) {\n        state.screen = 'win';\n        announceForAccessibility('You won! All packages delivered. Press R to play again.');\n        return;\n      }\n    } else {\n      state.wrong += 1;\n      playFeedback(false);\n      announceForAccessibility(`Oops, ${chosen} is not correct. ${state.question.text.replace('= ?', `= ${state.question.answer}`)}. Wrong ${state.wrong} of ${MAX_WRONG}.`);\n      if (state.wrong >= MAX_WRONG) {\n        state.screen = 'lose';\n        announceForAccessibility('Game over. The drones need practice. Press R to try again.');\n        return;\n      }\n    }\n    // next question\n    state.question = generateQuestion();\n    state.selectedIndex = 0;\n  }\n\n  function playFeedback(correct) {\n    if (!audioEnabled) return;\n    if (!audioCtx) {\n      initAudio();\n      if (!audioCtx) return;\n    }\n    // ensure audio context is resumed on interaction\n    if (audioCtx.state === 'suspended') audioCtx.resume().catch(() => {});\n    if (correct) {\n      // pleasant chirp sequence\n      playTone({ freq: 600, duration: 0.12, type: 'sine', isCorrect: true });\n      setTimeout(() => playTone({ freq: 800, duration: 0.08, type: 'sine', isCorrect: true }), 100);\n    } else {\n      // soft buzzer\n      playTone({ freq: 250, duration: 0.25, type: 'square', isCorrect: false });\n    }\n  }\n\n  // Animation loop\n  let lastTS = performance.now();\n  function loop(ts) {\n    const dt = ts - lastTS;\n    lastTS = ts;\n    state.clock += dt;\n    update(dt / 1000);\n    render();\n    requestAnimationFrame(loop);\n  }\n\n  function update(dt) {\n    // Update drones positions\n    for (let d of state.drones) {\n      d.x += d.vx * dt * 40;\n      d.rotorAng += 0.6 + dt * 10;\n      d.y += Math.sin((state.clock * 0.002) + d.x * 0.01) * 0.2;\n      if (d.x - d.size > WIDTH + 40) {\n        d.x = -40 - d.size;\n        d.y = 80 + Math.random() * 200;\n      }\n    }\n  }\n\n  function render() {\n    // clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // background\n    drawBackground(state.clock);\n\n    // draw drones behind UI\n    for (let d of state.drones) drawDrone(d, state.clock);\n\n    // UI\n    drawUI();\n\n    // Question + answers (or start or end screens)\n    if (state.screen === 'start') {\n      drawQuestionAndAnswers(); // show placeholders\n      drawStartScreen();\n    } else if (state.screen === 'playing') {\n      drawQuestionAndAnswers();\n      // instructions bottom center\n      const ipos = layoutPositions().instructionPos;\n      ctx.save();\n      ctx.font = BODY_FONT;\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'top';\n      const instr = '1-4 or click an answer. Use arrows/Enter. Toggle sound with speaker icon';\n      const metrics = ctx.measureText(instr);\n      ctx.fillStyle = 'rgba(255,255,255,0.85)';\n      ctx.fillRect(ipos.x - metrics.width / 2 - 10, ipos.y - 6, metrics.width + 20, 28);\n      ctx.fillStyle = '#012';\n      ctx.fillText(instr, ipos.x, ipos.y);\n      ctx.restore();\n    } else if (state.screen === 'win') {\n      drawQuestionAndAnswers();\n      drawEndScreen(true);\n    } else if (state.screen === 'lose') {\n      drawQuestionAndAnswers();\n      drawEndScreen(false);\n    }\n\n    // ensure no overlapping text: check bounding boxes and adjust if needed\n    ensureNoOverlap();\n  }\n\n  // Basic overlapping check: move instruction area slightly if overlaps answers boxes or header\n  function ensureNoOverlap() {\n    // For simplicity, ensure instruction area doesn't overlap answer area\n    const pos = layoutPositions();\n    // instruction rectangle\n    ctx.font = BODY_FONT;\n    const instr = state.screen === 'playing'\n      ? '1-4 or click an answer. Use arrows/Enter. Toggle sound with speaker icon'\n      : '';\n    const metrics = ctx.measureText(instr);\n    const instrRect = {\n      x: pos.instructionPos.x - metrics.width / 2 - 10,\n      y: pos.instructionPos.y - 6,\n      w: metrics.width + 20,\n      h: 28,\n    };\n    // answer area\n    const answersTop = pos.questionPos.y + 60;\n    const answersRect = { x: WIDTH / 2 - 260, y: answersTop, w: 520, h: 220 };\n    if (rectsOverlap(instrRect, answersRect)) {\n      // draw a small divider so they don't visually overlap (move instruction lower)\n      ctx.save();\n      ctx.fillStyle = 'rgba(255,255,255,0.95)';\n      ctx.fillRect(instrRect.x, answersRect.y + answersRect.h + 6, instrRect.w, instrRect.h);\n      ctx.fillStyle = '#012';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'top';\n      ctx.fillText(instr, pos.instructionPos.x, answersRect.y + answersRect.h + 10);\n      ctx.restore();\n    }\n  }\n\n  function rectsOverlap(a, b) {\n    return !(a.x + a.w < b.x || b.x + b.w < a.x || a.y + a.h < b.y || b.y + b.h < a.y);\n  }\n\n  // Start the animation loop\n  requestAnimationFrame(loop);\n\n  // Initial focus for keyboard\n  canvas.addEventListener('focus', () => {\n    // ensure audio unlocked on first focus if necessary\n    if (audioEnabled && audioCtx && audioCtx.state === 'suspended') {\n      audioCtx.resume().catch(() => {});\n    }\n  });\n\n  // Initialize audio if user allows on first interaction - hint: draw audio toggling\n  // Also ensure initial accessibility message\n  announceForAccessibility('Welcome to Drone Math Adventure. Press Space to start.');\n\n  // Expose some functions for debugging (not required)\n  window._droneMathGame = {\n    state,\n    startGame,\n    restartGame,\n    toggleAudio,\n  };\n})();\n---\n",
  "improve_response_tokens": 19015,
  "formatted_code": true,
  "formatting_response_tokens": 21550,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}