{
  "generated_date": "2025-09-01",
  "generated_timestamp": "2025-09-01T00:33:12.806784",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9982,
  "game_filename": "2025-09-01.js",
  "game_size_bytes": 30487,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Machine Math \u2014 Canvas Game for ages 7-9\n// Renders into the element with id \"game-of-the-day-stage\"\n// All visuals drawn with canvas; all sounds generated with Web Audio API oscillators/filters.\n// Accessible keyboard controls and screen-reader text included.\n\n// Immediately-invoked function to avoid polluting global scope\n(function() {\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const container = document.getElementById('game-of-the-day-stage');\n\n  if (!container) {\n    console.error('Game container element with id \"game-of-the-day-stage\" not found.');\n    return;\n  }\n\n  // Clear any existing content inside the container\n  container.innerHTML = '';\n\n  // Create an offscreen but accessible instructions element for screen readers\n  const srInstructions = document.createElement('div');\n  srInstructions.setAttribute('role', 'status');\n  srInstructions.setAttribute('aria-live', 'polite');\n  srInstructions.style.position = 'absolute';\n  srInstructions.style.left = '-9999px';\n  srInstructions.style.width = '1px';\n  srInstructions.style.height = '1px';\n  srInstructions.style.overflow = 'hidden';\n  srInstructions.textContent = 'Machine Math game loaded. Use mouse or keyboard. Arrow keys to navigate, Enter to place, Backspace to remove, M to toggle sound.';\n  container.appendChild(srInstructions);\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.width = WIDTH + 'px';\n  canvas.style.height = HEIGHT + 'px';\n  canvas.setAttribute('role', 'application');\n  canvas.setAttribute('aria-label', 'Machine Math game canvas. Visual math puzzles to power a machine.');\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Accessibility: show visible textual instructions below canvas inside container (not external)\n  const visibleInstructions = document.createElement('div');\n  visibleInstructions.style.fontFamily = 'Arial, sans-serif';\n  visibleInstructions.style.fontSize = '13px';\n  visibleInstructions.style.color = '#234';\n  visibleInstructions.style.marginTop = '8px';\n  visibleInstructions.textContent = 'Instructions: Solve the machine puzzles by placing the correct numbered gears into the slots. Use mouse drag or keyboard. Left/Right to pick a gear, Up/Down to pick a slot, Enter to place, Backspace to remove, M to mute.';\n  container.appendChild(visibleInstructions);\n\n  // Set up audio\n  let audioCtx = null;\n  let audioAllowed = false;\n  let ambientGain = null;\n  let masterGain = null;\n  let ambientOsc = null;\n\n  function initAudio() {\n    try {\n      const Ctx = window.AudioContext || window.webkitAudioContext;\n      if (!Ctx) {\n        throw new Error('Web Audio API not supported.');\n      }\n      audioCtx = new Ctx();\n      masterGain = audioCtx.createGain();\n      masterGain.gain.value = 0.9;\n      masterGain.connect(audioCtx.destination);\n\n      ambientGain = audioCtx.createGain();\n      ambientGain.gain.value = 0.03; // very gentle background\n      ambientGain.connect(masterGain);\n\n      // Ambient oscillator (gentle hum with slow LFO)\n      ambientOsc = audioCtx.createOscillator();\n      ambientOsc.type = 'sine';\n      ambientOsc.frequency.value = 110; // low hum\n      const ambientFilter = audioCtx.createBiquadFilter();\n      ambientFilter.type = 'lowpass';\n      ambientFilter.frequency.value = 600;\n      ambientOsc.connect(ambientFilter);\n      ambientFilter.connect(ambientGain);\n\n      // Create slow LFO for slight volume wobble\n      const lfo = audioCtx.createOscillator();\n      lfo.type = 'sine';\n      lfo.frequency.value = 0.08;\n      const lfoGain = audioCtx.createGain();\n      lfoGain.gain.value = 0.02;\n      lfo.connect(lfoGain);\n      lfoGain.connect(ambientGain.gain);\n\n      ambientOsc.start();\n      lfo.start();\n\n      audioAllowed = true;\n    } catch (e) {\n      console.warn('Audio initialization failed:', e);\n      audioCtx = null;\n      audioAllowed = false;\n    }\n  }\n\n  // Attempt to initialize audio immediately. Many browsers require user gesture to resume; we'll resume on first interaction.\n  initAudio();\n\n  // Utility: resume audio context on gesture\n  function tryResumeAudio() {\n    if (!audioCtx) return;\n    if (audioCtx.state === 'suspended') {\n      audioCtx.resume().then(() => {\n        audioAllowed = true;\n      }).catch((e) => {\n        console.warn('Audio resume failed:', e);\n        audioAllowed = false;\n      });\n    }\n  }\n\n  // Audio feedback functions\n  function playCorrect() {\n    if (!audioAllowed || !audioCtx) return;\n    tryResumeAudio();\n    try {\n      const t = audioCtx.currentTime;\n      const g = audioCtx.createGain();\n      g.gain.value = 0.0001;\n      g.connect(masterGain);\n      // quick envelope\n      g.gain.linearRampToValueAtTime(0.12, t + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.001, t + 0.6);\n\n      // small chord: three oscillators\n      const freqs = [660, 880, 990];\n      freqs.forEach((f, i) => {\n        const o = audioCtx.createOscillator();\n        o.type = i === 0 ? 'sine' : 'triangle';\n        o.frequency.value = f;\n        const filter = audioCtx.createBiquadFilter();\n        filter.type = 'lowpass';\n        filter.frequency.value = 1200;\n        o.connect(filter);\n        filter.connect(g);\n        o.start(t);\n        o.stop(t + 0.6);\n      });\n    } catch (e) {\n      console.warn('playCorrect error:', e);\n    }\n  }\n\n  function playIncorrect() {\n    if (!audioAllowed || !audioCtx) return;\n    tryResumeAudio();\n    try {\n      const t = audioCtx.currentTime;\n      const o = audioCtx.createOscillator();\n      o.type = 'sawtooth';\n      o.frequency.setValueAtTime(160, t);\n      const g = audioCtx.createGain();\n      g.gain.value = 0.0001;\n      g.connect(masterGain);\n      o.connect(g);\n      g.gain.linearRampToValueAtTime(0.13, t + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.35);\n      o.start();\n      o.stop(t + 0.35);\n    } catch (e) {\n      console.warn('playIncorrect error:', e);\n    }\n  }\n\n  function playClick() {\n    if (!audioAllowed || !audioCtx) return;\n    tryResumeAudio();\n    try {\n      const t = audioCtx.currentTime;\n      const o = audioCtx.createOscillator();\n      o.type = 'square';\n      o.frequency.value = 520;\n      const g = audioCtx.createGain();\n      g.gain.value = 0.0001;\n      g.connect(masterGain);\n      o.connect(g);\n      g.gain.linearRampToValueAtTime(0.08, t + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.18);\n      o.start();\n      o.stop(t + 0.18);\n    } catch (e) {\n      console.warn('playClick error:', e);\n    }\n  }\n\n  // Sound toggle\n  let soundOn = audioAllowed;\n\n  function toggleSound() {\n    soundOn = !soundOn;\n    if (!audioCtx) {\n      // If audio was not created initially, try creating on toggle\n      if (soundOn) initAudio();\n      else soundOn = false;\n    }\n    if (ambientGain) ambientGain.gain.value = soundOn ? 0.03 : 0;\n    if (masterGain) masterGain.gain.value = soundOn ? 0.9 : 0;\n    srInstructions.textContent = soundOn ? 'Sound turned on.' : 'Sound muted.';\n    playClick();\n  }\n\n  // Colors and visual theme\n  const colors = {\n    bg: '#E7F0F6',\n    machineBody: '#cfe3f2',\n    slot: '#e8f6ff',\n    gear: '#f7b2a8',\n    gearAlt: '#f7d7a8',\n    text: '#13304a',\n    highlight: '#9ee7c4',\n    shadow: 'rgba(0,0,0,0.08)',\n    ok: '#2a9d8f',\n    bad: '#e76f51',\n    speaker: '#234'\n  };\n\n  // Game state\n  let levelIndex = 0;\n  const MAX_LEVELS = 5;\n  let levels = [];\n  let running = true;\n  let lastTime = 0;\n\n  // Generate levels (beatable). Each level has 3 slots, with an operation and target answers.\n  function generateLevels() {\n    // For age 7-9: addition and subtraction early, then simple multiplication.\n    const ops = [\n      { type: 'add', range: [2, 10] },\n      { type: 'sub', range: [1, 9] },\n      { type: 'add', range: [5, 15] },\n      { type: 'mul', range: [2, 6] },\n      { type: 'mul', range: [2, 8] }\n    ];\n    levels = ops.slice(0, MAX_LEVELS).map((opDef, i) => {\n      const slots = [];\n      for (let s = 0; s < 3; s++) {\n        let a, b, answer;\n        if (opDef.type === 'add') {\n          a = randInt(opDef.range[0], opDef.range[1]);\n          b = randInt(0, opDef.range[1]);\n          answer = a + b;\n        } else if (opDef.type === 'sub') {\n          a = randInt(opDef.range[0], opDef.range[1]);\n          b = randInt(0, a);\n          answer = a - b;\n        } else if (opDef.type === 'mul') {\n          a = randInt(opDef.range[0], opDef.range[1]);\n          b = randInt(1, 5);\n          answer = a * b;\n        }\n        const label = `${a} ${opSymbol(opDef.type)} ${b}`;\n        slots.push({ label, answer, placed: null });\n      }\n\n      // Create candidate gears: include correct answers and distractors\n      const correctAnswers = slots.map(s => s.answer);\n      const candidates = [...correctAnswers];\n      // Add distractors carefully near correct answers\n      while (candidates.length < 6) {\n        const base = correctAnswers[randInt(0, correctAnswers.length - 1)];\n        let distractor = base + (Math.random() < 0.5 ? -1 : 1) * randInt(1, 4);\n        if (distractor < 0) distractor = base + randInt(2, 4);\n        if (!candidates.includes(distractor)) candidates.push(distractor);\n      }\n      // Shuffle candidates\n      shuffleArray(candidates);\n\n      return {\n        type: opDef.type,\n        slots,\n        candidates\n      };\n    });\n  }\n\n  function opSymbol(type) {\n    if (type === 'add') return '+';\n    if (type === 'sub') return '\u2212';\n    if (type === 'mul') return '\u00d7';\n    return '?';\n  }\n\n  // Utility functions\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n  function shuffleArray(arr) {\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    return arr;\n  }\n\n  generateLevels();\n\n  // UI elements positions\n  const slotPositions = [\n    { x: 180, y: 150 },\n    { x: 360, y: 120 },\n    { x: 540, y: 150 }\n  ];\n\n  const conveyorY = 360;\n  const conveyorStartX = 80;\n  const conveyorGap = 100;\n\n  // Gear objects for current level\n  let gears = []; // {value, x, y, radius, placedSlotIndex, homeX, homeY, dragging}\n  let selection = { gearIndex: 0, slotIndex: 0 }; // keyboard selection\n\n  // Load level into gears\n  function loadLevel(index) {\n    const lvl = levels[index];\n    gears = [];\n    const startX = conveyorStartX;\n    lvl.candidates.forEach((val, i) => {\n      const x = startX + i * conveyorGap;\n      const y = conveyorY;\n      gears.push({\n        value: val,\n        x,\n        y,\n        homeX: x,\n        homeY: y,\n        radius: 38,\n        placedSlotIndex: null,\n        dragging: false,\n        wobble: Math.random() * Math.PI * 2\n      });\n    });\n    // Reset slot placement\n    lvl.slots.forEach(s => {\n      s.placed = null;\n    });\n\n    selection.gearIndex = 0;\n    selection.slotIndex = 0;\n    srInstructions.textContent = `Level ${index + 1} loaded. Solve three puzzles on the machine.`;\n  }\n\n  loadLevel(0);\n\n  // Event handling: mouse, touch, keyboard\n  let pointerDown = false;\n  let dragGear = null;\n  let dragOffset = { x: 0, y: 0 };\n\n  function getPointerPos(e) {\n    const rect = canvas.getBoundingClientRect();\n    if (e.touches && e.touches[0]) {\n      return {\n        x: (e.touches[0].clientX - rect.left) * (canvas.width / rect.width),\n        y: (e.touches[0].clientY - rect.top) * (canvas.height / rect.height)\n      };\n    } else {\n      return {\n        x: (e.clientX - rect.left) * (canvas.width / rect.width),\n        y: (e.clientY - rect.top) * (canvas.height / rect.height)\n      };\n    }\n  }\n\n  canvas.addEventListener('mousedown', onPointerDown);\n  canvas.addEventListener('touchstart', onPointerDown, { passive: false });\n  window.addEventListener('mousemove', onPointerMove);\n  window.addEventListener('touchmove', onPointerMove, { passive: false });\n  window.addEventListener('mouseup', onPointerUp);\n  window.addEventListener('touchend', onPointerUp);\n\n  function onPointerDown(e) {\n    e.preventDefault();\n    tryResumeAudio();\n    pointerDown = true;\n    const pos = getPointerPos(e);\n    // check if clicked on a gear\n    for (let i = gears.length - 1; i >= 0; i--) {\n      const g = gears[i];\n      const dx = pos.x - g.x;\n      const dy = pos.y - g.y;\n      if (Math.sqrt(dx * dx + dy * dy) <= g.radius + 6) {\n        // start dragging this gear\n        dragGear = g;\n        g.dragging = true;\n        dragOffset.x = dx;\n        dragOffset.y = dy;\n        selection.gearIndex = i;\n        playClick();\n        // resume audio on gesture\n        if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();\n        return;\n      }\n    }\n    // If clicked on a slot area (for quick keyboard-like placement)\n    const lvl = levels[levelIndex];\n    for (let si = 0; si < lvl.slots.length; si++) {\n      const posSlot = slotPositions[si];\n      const sx = posSlot.x;\n      const sy = posSlot.y;\n      if (Math.abs(pos.x - sx) < 60 && Math.abs(pos.y - sy) < 60) {\n        // Place the currently selected gear into this slot if possible\n        placeGearInSlot(selection.gearIndex, si);\n        return;\n      }\n    }\n  }\n\n  function onPointerMove(e) {\n    if (!pointerDown) return;\n    const pos = getPointerPos(e);\n    if (dragGear) {\n      dragGear.x = pos.x - dragOffset.x;\n      dragGear.y = pos.y - dragOffset.y;\n    }\n  }\n\n  function onPointerUp(e) {\n    if (!pointerDown) return;\n    pointerDown = false;\n    if (dragGear) {\n      // detect nearest slot\n      const gear = dragGear;\n      dragGear.dragging = false;\n      let nearest = null;\n      let nearestDist = Infinity;\n      levels[levelIndex].slots.forEach((slot, si) => {\n        const sp = slotPositions[si];\n        const dx = gear.x - sp.x;\n        const dy = gear.y - sp.y;\n        const d = Math.sqrt(dx * dx + dy * dy);\n        if (d < nearestDist) {\n          nearestDist = d;\n          nearest = si;\n        }\n      });\n      // if close enough, attempt to place\n      if (nearest !== null && nearestDist < 80) {\n        placeGearInSlot(gears.indexOf(gear), nearest);\n      } else {\n        // return home\n        animateReturn(gear);\n      }\n      dragGear = null;\n    }\n  }\n\n  function animateReturn(gear) {\n    // Gentle animated return to home\n    const sx = gear.x;\n    const sy = gear.y;\n    const dx = gear.homeX - sx;\n    const dy = gear.homeY - sy;\n    const duration = 300; // ms\n    const start = performance.now();\n    function step(ts) {\n      const t = Math.min(1, (ts - start) / duration);\n      const ease = easeOutCubic(t);\n      gear.x = sx + dx * ease;\n      gear.y = sy + dy * ease;\n      if (t < 1) requestAnimationFrame(step);\n      else {\n        gear.x = gear.homeX;\n        gear.y = gear.homeY;\n      }\n    }\n    requestAnimationFrame(step);\n  }\n\n  function easeOutCubic(t) {\n    return 1 - Math.pow(1 - t, 3);\n  }\n\n  // Place gear into slot with validation\n  function placeGearInSlot(gearIndex, slotIndex) {\n    if (gearIndex < 0 || gearIndex >= gears.length) return;\n    const gear = gears[gearIndex];\n    const lvl = levels[levelIndex];\n    const slot = lvl.slots[slotIndex];\n\n    // If slot already has a gear, prevent unless replacing\n    if (slot.placed) {\n      // If placing same gear that's already there, remove instead\n      if (slot.placed === gear) {\n        // remove\n        slot.placed.placedSlotIndex = null;\n        slot.placed = null;\n        playClick();\n        return;\n      } else {\n        // return existing gear to home first\n        const existing = slot.placed;\n        existing.placedSlotIndex = null;\n        existing.homeX = existing.homeX;\n        animateReturn(existing);\n        slot.placed = null;\n      }\n    }\n\n    // Check correctness\n    if (gear.value === slot.answer) {\n      // Snap into place\n      gear.placedSlotIndex = slotIndex;\n      gear.x = slotPositions[slotIndex].x;\n      gear.y = slotPositions[slotIndex].y;\n      slot.placed = gear;\n      playCorrect();\n      srInstructions.textContent = `Correct! ${slot.label} = ${slot.answer}.`;\n      checkLevelComplete();\n    } else {\n      // Wrong \u2014 gentle shake and return to conveyor\n      playIncorrect();\n      srInstructions.textContent = `Try again. ${gear.value} does not match ${slot.label}.`;\n      // Visual shake animation\n      const startX = gear.x;\n      const startY = gear.y;\n      const duration = 420;\n      const start = performance.now();\n      function step(ts) {\n        const t = (ts - start) / duration;\n        if (t >= 1) {\n          animateReturn(gear);\n          return;\n        }\n        const shake = Math.sin(t * Math.PI * 8) * (1 - t) * 12;\n        gear.x = startX + shake;\n        gear.y = startY;\n        requestAnimationFrame(step);\n      }\n      requestAnimationFrame(step);\n    }\n  }\n\n  function checkLevelComplete() {\n    const lvl = levels[levelIndex];\n    const allPlaced = lvl.slots.every(s => s.placed !== null);\n    if (allPlaced) {\n      // Small celebration, then advance\n      srInstructions.textContent = `Level ${levelIndex + 1} complete!`;\n      playCorrect();\n      setTimeout(() => {\n        if (levelIndex < MAX_LEVELS - 1) {\n          levelIndex++;\n          loadLevel(levelIndex);\n        } else {\n          // game won\n          showVictory();\n        }\n      }, 900);\n    }\n  }\n\n  // Victory screen\n  let victory = false;\n  let confettiParticles = [];\n  function showVictory() {\n    victory = true;\n    srInstructions.textContent = 'You fixed all the machines! Great job!';\n    // Create confetti particles\n    for (let i = 0; i < 80; i++) {\n      confettiParticles.push({\n        x: randInt(100, WIDTH - 100),\n        y: randInt(-100, -10),\n        vx: (Math.random() - 0.5) * 2,\n        vy: randInt(1, 4),\n        size: randInt(6, 12),\n        color: [colors.highlight, colors.gear, colors.gearAlt, colors.ok][randInt(0, 3)],\n        rot: Math.random() * Math.PI * 2,\n        rotSpeed: (Math.random() - 0.5) * 0.2\n      });\n    }\n    // Play a bright jingle\n    if (audioAllowed) {\n      tryResumeAudio();\n      const t = audioCtx.currentTime;\n      const g = audioCtx.createGain();\n      g.gain.value = 0.0001;\n      g.connect(masterGain);\n      g.gain.linearRampToValueAtTime(0.18, t + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.001, t + 1.6);\n      const freqs = [440, 660, 880, 1100];\n      freqs.forEach((f, i) => {\n        const o = audioCtx.createOscillator();\n        o.type = i % 2 ? 'triangle' : 'sine';\n        o.frequency.value = f;\n        const delay = i * 0.05;\n        o.connect(g);\n        o.start(t + delay);\n        o.stop(t + 1.2);\n      });\n    }\n  }\n\n  // Keyboard controls\n  window.addEventListener('keydown', (e) => {\n    // Allow keyboard to resume audio\n    tryResumeAudio();\n    if (!running) return;\n    const lvl = levels[levelIndex];\n    const gearCount = gears.length;\n    switch (e.key) {\n      case 'ArrowLeft':\n        // pick previous gear\n        selection.gearIndex = (selection.gearIndex - 1 + gearCount) % gearCount;\n        playClick();\n        e.preventDefault();\n        break;\n      case 'ArrowRight':\n        selection.gearIndex = (selection.gearIndex + 1) % gearCount;\n        playClick();\n        e.preventDefault();\n        break;\n      case 'ArrowUp':\n        selection.slotIndex = (selection.slotIndex - 1 + lvl.slots.length) % lvl.slots.length;\n        playClick();\n        e.preventDefault();\n        break;\n      case 'ArrowDown':\n        selection.slotIndex = (selection.slotIndex + 1) % lvl.slots.length;\n        playClick();\n        e.preventDefault();\n        break;\n      case 'Enter':\n      case ' ':\n        // place selected gear into selected slot\n        placeGearInSlot(selection.gearIndex, selection.slotIndex);\n        e.preventDefault();\n        break;\n      case 'Backspace':\n      case 'Delete':\n        // remove gear from selected slot\n        const s = lvl.slots[selection.slotIndex];\n        if (s.placed) {\n          s.placed.placedSlotIndex = null;\n          s.placed = null;\n          playClick();\n        } else {\n          playIncorrect();\n        }\n        e.preventDefault();\n        break;\n      case 'm':\n      case 'M':\n        toggleSound();\n        e.preventDefault();\n        break;\n      default:\n        // number keys 0-9 quick placement: attempt to place a gear with that number (if present)\n        if (/^\\d$/.test(e.key)) {\n          const num = parseInt(e.key, 10);\n          const gearIdx = gears.findIndex(g => g.value === num && !g.placedSlotIndex);\n          if (gearIdx >= 0) {\n            placeGearInSlot(gearIdx, selection.slotIndex);\n          } else {\n            playIncorrect();\n          }\n        }\n        break;\n    }\n  });\n\n  // Drawing functions\n  function draw() {\n    // Clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    // Background\n    drawBackground();\n    // Machine body\n    drawMachineBody();\n    // Slots with labels and gears\n    drawSlotsAndGears();\n    // Conveyor belt and gears\n    drawConveyorAndGears();\n    // UI overlays: level, sound icon, instructions\n    drawUI();\n    if (victory) drawConfetti();\n  }\n\n  function drawBackground() {\n    // soft gradient with subtle shapes\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, '#F6FBFF');\n    g.addColorStop(1, colors.bg);\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // gentle floating cogs as background decorative elements\n    ctx.save();\n    ctx.globalAlpha = 0.12;\n    for (let i = 0; i < 6; i++) {\n      const x = 80 + i * 110 + Math.sin(performance.now() * 0.0006 + i) * 8;\n      const y = 60 + (i % 3) * 30;\n      drawGearShape(ctx, x, y, 26, 8, '#d5eaf6', '#d5eaf6', 0.9);\n    }\n    ctx.restore();\n  }\n\n  function drawMachineBody() {\n    // Main machine rectangle\n    ctx.fillStyle = colors.machineBody;\n    roundRect(ctx, 60, 80, WIDTH - 120, 200, 18);\n    ctx.fill();\n\n    // Shadow\n    ctx.fillStyle = colors.shadow;\n    roundRect(ctx, 62, 80 + 8, WIDTH - 124, 200, 18);\n    ctx.fill();\n\n    // Decorative pipes\n    ctx.strokeStyle = '#b9d9f0';\n    ctx.lineWidth = 8;\n    ctx.lineCap = 'round';\n    ctx.beginPath();\n    ctx.moveTo(80, 160);\n    ctx.lineTo(160, 160);\n    ctx.lineTo(160, 220);\n    ctx.stroke();\n\n    ctx.beginPath();\n    ctx.moveTo(WIDTH - 80, 160);\n    ctx.lineTo(WIDTH - 160, 160);\n    ctx.lineTo(WIDTH - 160, 220);\n    ctx.stroke();\n\n    // Machine title text\n    ctx.fillStyle = colors.text;\n    ctx.font = 'bold 20px Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText('WHIMSY MACHINE WORKS', WIDTH / 2, 110);\n  }\n\n  function drawSlotsAndGears() {\n    const lvl = levels[levelIndex];\n    ctx.textAlign = 'center';\n    ctx.font = 'bold 16px Arial';\n    // Draw each slot\n    lvl.slots.forEach((slot, si) => {\n      const pos = slotPositions[si];\n      // Slot base\n      ctx.save();\n      // highlight if keyboard selected\n      if (selection.slotIndex === si) {\n        ctx.shadowColor = colors.highlight;\n        ctx.shadowBlur = 18;\n      } else {\n        ctx.shadowColor = 'transparent';\n      }\n      // slot background\n      ctx.fillStyle = colors.slot;\n      roundRect(ctx, pos.x - 56, pos.y - 56, 112, 112, 16);\n      ctx.fill();\n\n      // Label above slot\n      ctx.fillStyle = colors.text;\n      ctx.font = '14px Arial';\n      ctx.fillText(slot.label, pos.x, pos.y - 70);\n\n      // If there's a placed gear draw it there (otherwise draw empty gear placeholder)\n      if (slot.placed) {\n        drawGearWithNumber(ctx, slot.placed.x, slot.placed.y, slot.placed.radius, slot.placed.value, true);\n      } else {\n        // placeholder ghost gear\n        ctx.globalAlpha = 0.22;\n        drawGearShape(ctx, pos.x, pos.y, 46, 10, '#ffffff', '#e0f3ff', 1);\n        ctx.globalAlpha = 1;\n      }\n\n      ctx.restore();\n    });\n\n    // Small hint: show operation type for the level\n    ctx.font = '14px Arial';\n    ctx.fillStyle = '#0f3345';\n    ctx.fillText('Solve to power the machine', WIDTH / 2, 170);\n  }\n\n  function drawConveyorAndGears() {\n    // Conveyor\n    ctx.fillStyle = '#c9dff0';\n    roundRect(ctx, 40, conveyorY - 56, WIDTH - 80, 140, 18);\n    ctx.fill();\n\n    // draw a dashed moving line to indicate motion\n    ctx.strokeStyle = '#b6d1e8';\n    ctx.lineWidth = 6;\n    ctx.beginPath();\n    const offset = (performance.now() * 0.02) % 40;\n    for (let x = 60 - offset; x < WIDTH - 60; x += 40) {\n      ctx.moveTo(x, conveyorY + 40);\n      ctx.lineTo(x + 20, conveyorY + 40);\n    }\n    ctx.stroke();\n\n    // Draw gear objects\n    gears.forEach((g, i) => {\n      // wobble animation for idle gears\n      if (!g.dragging && g.placedSlotIndex === null) {\n        g.wobble += 0.02;\n        g.y = g.homeY + Math.sin(g.wobble) * 4;\n      }\n      // highlight if selected via keyboard\n      const isSelected = selection.gearIndex === i;\n      drawGearWithNumber(ctx, g.x, g.y, g.radius, g.value, isSelected);\n    });\n  }\n\n  function drawGearWithNumber(ctx, x, y, r, value, highlight = false) {\n    // base gear\n    drawGearShape(ctx, x, y, r, 10, highlight ? colors.highlight : colors.gear, highlight ? '#fff7f2' : '#fff8f7', 1);\n    // center circle\n    ctx.fillStyle = '#fff';\n    ctx.beginPath();\n    ctx.arc(x, y, r * 0.5, 0, Math.PI * 2);\n    ctx.fill();\n\n    // number\n    ctx.fillStyle = colors.text;\n    ctx.font = 'bold 18px Arial';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(String(value), x, y);\n    // small shadow\n    ctx.globalAlpha = 0.06;\n    ctx.fillStyle = '#000';\n    ctx.fillRect(x - r, y + r + 6, r * 2, 4);\n    ctx.globalAlpha = 1;\n  }\n\n  function drawGearShape(ctx, x, y, radius, teeth, fill, stroke, alpha) {\n    ctx.save();\n    ctx.globalAlpha = alpha !== undefined ? alpha : 1;\n    // draw gear using arcs and rectangles for teeth\n    ctx.translate(x, y);\n    ctx.beginPath();\n    const toothAngle = (Math.PI * 2) / (teeth * 2);\n    for (let i = 0; i < teeth * 2; i++) {\n      const angle = i * toothAngle;\n      const r = (i % 2 === 0) ? radius : radius * 0.78;\n      ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);\n    }\n    ctx.closePath();\n    ctx.fillStyle = fill;\n    ctx.fill();\n    ctx.strokeStyle = stroke;\n    ctx.lineWidth = 3;\n    ctx.stroke();\n\n    // center hole\n    ctx.beginPath();\n    ctx.fillStyle = stroke;\n    ctx.arc(0, 0, radius * 0.14, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  function drawUI() {\n    // Level indicator\n    ctx.fillStyle = colors.text;\n    ctx.font = 'bold 16px Arial';\n    ctx.textAlign = 'left';\n    ctx.fillText(`Level ${levelIndex + 1} / ${MAX_LEVELS}`, 24, 30);\n\n    // Sound icon\n    const sx = WIDTH - 60;\n    const sy = 24;\n    ctx.save();\n    ctx.fillStyle = colors.speaker;\n    if (!soundOn) ctx.globalAlpha = 0.28;\n    // speaker box\n    ctx.beginPath();\n    ctx.moveTo(sx - 12, sy - 8);\n    ctx.lineTo(sx - 12, sy + 8);\n    ctx.lineTo(sx, sy + 8);\n    ctx.lineTo(sx + 12, sy + 14);\n    ctx.lineTo(sx + 12, sy - 14);\n    ctx.lineTo(sx, sy - 8);\n    ctx.closePath();\n    ctx.fill();\n    // waves when soundOn\n    if (soundOn) {\n      ctx.strokeStyle = colors.speaker;\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.arc(sx + 18, sy, 8, -0.5, 0.5);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.arc(sx + 22, sy, 12, -0.6, 0.6);\n      ctx.stroke();\n    } else {\n      // draw cross\n      ctx.strokeStyle = '#f55';\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(sx + 28, sy - 12);\n      ctx.lineTo(sx + 12, sy + 8);\n      ctx.moveTo(sx + 12, sy - 12);\n      ctx.lineTo(sx + 28, sy + 8);\n      ctx.stroke();\n    }\n    ctx.restore();\n\n    // Text hint on keyboard controls (small)\n    ctx.font = '12px Arial';\n    ctx.fillStyle = '#0f3345';\n    ctx.textAlign = 'right';\n    ctx.fillText('Keys: \u2190\u2192 gears  \u2191\u2193 slots  Enter place  Backspace remove  M mute', WIDTH - 20, HEIGHT - 12);\n  }\n\n  function drawConfetti() {\n    // update and draw particles\n    confettiParticles.forEach(p => {\n      p.x += p.vx;\n      p.y += p.vy;\n      p.vy += 0.08;\n      p.rot += p.rotSpeed;\n      ctx.save();\n      ctx.translate(p.x, p.y);\n      ctx.rotate(p.rot);\n      ctx.fillStyle = p.color;\n      ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size * 0.6);\n      ctx.restore();\n    });\n    // remove offscreen particles and let them loop\n    if (confettiParticles.length === 0) return;\n    confettiParticles = confettiParticles.filter(p => p.y < HEIGHT + 200);\n  }\n\n  // Main loop\n  function loop(ts) {\n    const dt = ts - lastTime;\n    lastTime = ts;\n    draw();\n    if (running) requestAnimationFrame(loop);\n  }\n\n  requestAnimationFrame(loop);\n\n  // Utility: rounded rect\n  function roundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n  }\n\n  // Error handling: capture errors\n  window.addEventListener('error', (ev) => {\n    console.error('Game error:', ev.error || ev.message);\n    srInstructions.textContent = 'An unexpected error occurred in the game. Please reload.';\n  });\n\n  // Expose a small debug API on container (non-intrusive)\n  container.gameAPI = {\n    restart: function() {\n      levelIndex = 0;\n      victory = false;\n      confettiParticles = [];\n      generateLevels();\n      loadLevel(0);\n      srInstructions.textContent = 'Game restarted.';\n    },\n    toggleSound\n  };\n\n  // Provide initial instruction spoken-like text for screen readers\n  setTimeout(() => {\n    srInstructions.textContent = 'Welcome to Machine Math! Click or press keys to begin. Solve the math puzzles to fix the machines.';\n  }, 600);\n\n  // Final: ensure first-click resumes audio for browsers that require gesture\n  canvas.addEventListener('click', () => {\n    if (audioCtx && audioCtx.state === 'suspended') {\n      audioCtx.resume().then(() => {\n        audioAllowed = true;\n        soundOn = true;\n        if (ambientGain) ambientGain.gain.value = 0.03;\n        srInstructions.textContent = 'Audio enabled.';\n      }).catch(() => {\n        audioAllowed = false;\n        srInstructions.textContent = 'Audio is not available.';\n      });\n    }\n  });\n\n  // Ensure focus for keyboard controls and positive UX\n  canvas.tabIndex = 0;\n  canvas.style.outline = 'none';\n  canvas.addEventListener('focus', () => {\n    srInstructions.textContent = 'Canvas focused. Use keyboard to play.';\n  });\n  canvas.addEventListener('blur', () => {\n    srInstructions.textContent = 'Canvas lost focus. Click to regain control.';\n  });\n\n})();\n---\n",
  "improve_response_tokens": 19953,
  "formatted_code": true,
  "formatting_response_tokens": 21120,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}