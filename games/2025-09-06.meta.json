{
  "generated_date": "2025-09-06",
  "generated_timestamp": "2025-09-06T00:25:36.632986",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8564,
  "game_filename": "2025-09-06.js",
  "game_size_bytes": 25792,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Machine Math \u2014 Canvas Game for ages 7-9\n  // Renders inside #game-of-the-day-stage, canvas size 720x480\n  // Uses Web Audio API for sounds (created with oscillators)\n  // Accessible: keyboard controls, focusable canvas, aria-live status region\n  // Author: Generated by assistant (example code)\n\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const STAGE_ID = \"game-of-the-day-stage\";\n\n  // Game parameters\n  const TOTAL_LEVELS = 6;\n  const GEAR_MIN = 1;\n  const GEAR_MAX = 9; // numbers on gears\n  const MAX_GEARS = 6; // number of gears placed per level\n  const PLAYER_SPEED = 4;\n  const PICK_RANGE = 40;\n\n  // Colors and style (calming, wacky palette)\n  const COLORS = {\n    background: \"#F0F7F6\",\n    panel: \"#E8F1EF\",\n    machine: \"#D6E9E6\",\n    accent: \"#7FB7B0\",\n    accent2: \"#F6C1C1\",\n    text: \"#2E3B3A\",\n    gearFill: \"#FFFFFF\",\n    gearStroke: \"#B2D6D1\",\n    robotBody: \"#F7D9A7\",\n    highlight: \"#C3F0E8\",\n    wrong: \"#F6B6B6\",\n    success: \"#BEE7D8\",\n  };\n\n  // Utility: clamp\n  function clamp(v, a, b) {\n    return Math.max(a, Math.min(b, v));\n  }\n\n  // Get stage element\n  const stage = document.getElementById(STAGE_ID);\n  if (!stage) {\n    console.error(\"Stage element with id '\" + STAGE_ID + \"' not found.\");\n    return;\n  }\n\n  // Clear stage and create canvas and accessibility region\n  stage.innerHTML = \"\";\n  stage.style.position = \"relative\";\n  stage.style.width = WIDTH + \"px\";\n  stage.style.height = HEIGHT + \"px\";\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.display = \"block\";\n  canvas.style.outline = \"none\";\n  canvas.setAttribute(\"role\", \"application\");\n  canvas.setAttribute(\"aria-label\", \"Machine Math game area. Use left and right arrows to move. Press space to pick up a gear. Press N for next level or R to restart.\");\n  canvas.tabIndex = 0; // make focusable for keyboard controls\n  stage.appendChild(canvas);\n\n  // Create a small visible audio control and an aria-live status region (for screen readers)\n  const audioControl = document.createElement(\"button\");\n  audioControl.textContent = \"Enable sound\";\n  audioControl.style.position = \"absolute\";\n  audioControl.style.right = \"8px\";\n  audioControl.style.top = \"8px\";\n  audioControl.style.padding = \"6px 10px\";\n  audioControl.style.borderRadius = \"6px\";\n  audioControl.style.border = \"none\";\n  audioControl.style.background = COLORS.accent;\n  audioControl.style.color = COLORS.text;\n  audioControl.style.fontWeight = \"600\";\n  audioControl.style.cursor = \"pointer\";\n  audioControl.title = \"Click to allow sound (some browsers require a gesture)\";\n  stage.appendChild(audioControl);\n\n  const statusRegion = document.createElement(\"div\");\n  statusRegion.setAttribute(\"aria-live\", \"polite\"); // screen readers\n  statusRegion.style.position = \"absolute\";\n  statusRegion.style.left = \"-9999px\";\n  statusRegion.style.width = \"1px\";\n  statusRegion.style.height = \"1px\";\n  statusRegion.style.overflow = \"hidden\";\n  stage.appendChild(statusRegion);\n\n  // Canvas context\n  const ctx = canvas.getContext(\"2d\");\n\n  // Audio setup\n  let audioContext = null;\n  let masterGain = null;\n  let backgroundOsc = null;\n  let audioEnabled = false;\n  let audioAllowed = false; // whether user has enabled audio via button\n  let audioInitialized = false;\n\n  function initAudio() {\n    if (audioInitialized) return;\n    audioInitialized = true;\n    try {\n      const AudioContext = window.AudioContext || window.webkitAudioContext;\n      if (!AudioContext) {\n        throw new Error(\"Web Audio API not supported.\");\n      }\n      audioContext = new AudioContext();\n      masterGain = audioContext.createGain();\n      masterGain.gain.value = 0.15; // gentle overall volume\n      masterGain.connect(audioContext.destination);\n\n      // Background hum (low, gentle)\n      backgroundOsc = audioContext.createOscillator();\n      const bgGain = audioContext.createGain();\n      backgroundOsc.type = \"sine\";\n      backgroundOsc.frequency.value = 110; // low hum\n      bgGain.gain.value = 0.02;\n      // subtle filter for warmth\n      const bgFilter = audioContext.createBiquadFilter();\n      bgFilter.type = \"lowpass\";\n      bgFilter.frequency.value = 800;\n      backgroundOsc.connect(bgFilter);\n      bgFilter.connect(bgGain);\n      bgGain.connect(masterGain);\n\n      // Do not start background until user allows audio.\n      audioEnabled = false;\n    } catch (e) {\n      audioContext = null;\n      audioEnabled = false;\n      console.warn(\"Audio disabled due to error:\", e);\n      statusRegion.textContent = \"Audio is not available in this browser.\";\n    }\n  }\n\n  // Play a success melody (pleasant arpeggio)\n  function playSuccess() {\n    if (!audioContext || !audioAllowed) return;\n    const now = audioContext.currentTime;\n    const notes = [660, 880, 990]; // a short ascending arpeggio\n    notes.forEach((freq, i) => {\n      try {\n        const o = audioContext.createOscillator();\n        o.type = \"sine\";\n        o.frequency.value = freq;\n        const g = audioContext.createGain();\n        g.gain.value = 0;\n        o.connect(g);\n        g.connect(masterGain);\n        g.gain.setValueAtTime(0, now + i * 0.12);\n        g.gain.linearRampToValueAtTime(0.12, now + i * 0.12 + 0.04);\n        g.gain.exponentialRampToValueAtTime(0.0001, now + i * 0.12 + 0.24);\n        o.start(now + i * 0.12);\n        o.stop(now + i * 0.12 + 0.26);\n      } catch (e) {\n        console.warn(\"Audio node error\", e);\n      }\n    });\n  }\n\n  // Play incorrect buzz (gentle)\n  function playIncorrect() {\n    if (!audioContext || !audioAllowed) return;\n    const now = audioContext.currentTime;\n    try {\n      const o = audioContext.createOscillator();\n      o.type = \"triangle\";\n      o.frequency.value = 240;\n      const g = audioContext.createGain();\n      g.gain.value = 0;\n      o.connect(g);\n      g.connect(masterGain);\n      g.gain.setValueAtTime(0, now);\n      g.gain.linearRampToValueAtTime(0.12, now + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.28);\n      o.start(now);\n      o.frequency.exponentialRampToValueAtTime(120, now + 0.28);\n      o.stop(now + 0.3);\n    } catch (e) {\n      console.warn(\"Audio node error\", e);\n    }\n  }\n\n  // Small pluck for pickup\n  function playPick() {\n    if (!audioContext || !audioAllowed) return;\n    const now = audioContext.currentTime;\n    try {\n      const o = audioContext.createOscillator();\n      o.type = \"sine\";\n      o.frequency.value = 880;\n      const g = audioContext.createGain();\n      const filter = audioContext.createBiquadFilter();\n      filter.type = \"highpass\";\n      filter.frequency.value = 600;\n      o.connect(filter);\n      filter.connect(g);\n      g.connect(masterGain);\n      g.gain.setValueAtTime(0, now);\n      g.gain.linearRampToValueAtTime(0.18, now + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.2);\n      o.start(now);\n      o.stop(now + 0.22);\n    } catch (e) {\n      console.warn(\"Audio node error\", e);\n    }\n  }\n\n  // Start background hum when user allows audio\n  function startBackground() {\n    if (!audioContext || !audioAllowed) return;\n    try {\n      if (backgroundOsc) {\n        backgroundOsc.start();\n      }\n    } catch (e) {\n      // Could be already started \u2014 ignore\n    }\n  }\n\n  // Stop background gracefully (when audio disabled)\n  function stopBackground() {\n    if (!audioContext) return;\n    if (backgroundOsc) {\n      try {\n        backgroundOsc.stop();\n      } catch (e) {\n        // ignore\n      }\n      // recreate a fresh oscillator for next time\n      backgroundOsc = audioContext.createOscillator();\n      const bgGain = audioContext.createGain();\n      backgroundOsc.type = \"sine\";\n      backgroundOsc.frequency.value = 110;\n      bgGain.gain.value = 0.02;\n      const bgFilter = audioContext.createBiquadFilter();\n      bgFilter.type = \"lowpass\";\n      bgFilter.frequency.value = 800;\n      backgroundOsc.connect(bgFilter);\n      bgFilter.connect(bgGain);\n      bgGain.connect(masterGain);\n    }\n  }\n\n  audioControl.addEventListener(\"click\", function () {\n    initAudio();\n    if (!audioContext) {\n      audioControl.textContent = \"Audio unavailable\";\n      audioControl.disabled = true;\n      return;\n    }\n    // resume audio context if suspended (some browsers require user gesture)\n    audioContext\n      .resume()\n      .then(() => {\n        audioAllowed = true;\n        audioEnabled = true;\n        startBackground();\n        audioControl.textContent = \"Sound on\";\n        audioControl.style.background = COLORS.accent2;\n        statusRegion.textContent = \"Audio enabled.\";\n      })\n      .catch((e) => {\n        audioAllowed = false;\n        audioControl.textContent = \"Enable sound\";\n        statusRegion.textContent = \"Audio failed to start.\";\n        console.warn(\"Audio resume failed:\", e);\n      });\n  });\n\n  // Game state\n  let level = 1;\n  let target = 0;\n  let gears = []; // gear objects\n  let player = {\n    x: WIDTH / 2,\n    y: HEIGHT - 110,\n    radius: 22,\n    carrying: [], // collected gears\n  };\n  let keys = {};\n  let message = \"\"; // temporary feedback\n  let messageTimer = 0;\n  let levelComplete = false;\n  let gameComplete = false;\n  let moves = 0;\n\n  // Accessibility announcement\n  function announce(text) {\n    statusRegion.textContent = text;\n  }\n\n  // Utility: random int inclusive\n  function randInt(a, b) {\n    return Math.floor(Math.random() * (b - a + 1)) + a;\n  }\n\n  // Generate a solvable set of gears that can sum to target\n  function generateLevel(lv) {\n    // scale difficulty: higher levels have larger targets and more gears\n    const gearCount = Math.min(MAX_GEARS, Math.max(3, 2 + lv));\n    // produce a target between 5 and maybe 15+ depending on level\n    const baseMax = GEAR_MAX + Math.min(5, lv);\n    target = randInt(5 + lv, 8 + baseMax);\n    gears = [];\n    // Guarantee solvability: create some numbers that sum to target then add distractors\n    // First create a solution: split target into 2-3 parts within GEAR_MIN..GEAR_MAX\n    const partsCount = randInt(2, Math.min(3, gearCount));\n    let remaining = target;\n    let solutionParts = [];\n    for (let i = 0; i < partsCount - 1; i++) {\n      // ensure remaining can be split\n      const maxPart = Math.min(GEAR_MAX, remaining - (partsCount - i - 1) * GEAR_MIN);\n      const minPart = Math.max(GEAR_MIN, remaining - (partsCount - i - 1) * GEAR_MAX);\n      const part = randInt(minPart, maxPart);\n      solutionParts.push(part);\n      remaining -= part;\n    }\n    solutionParts.push(remaining); // last part\n\n    // Place solution gears\n    for (let v of solutionParts) {\n      gears.push({\n        x: randInt(80, WIDTH - 80),\n        y: randInt(140, HEIGHT - 220),\n        val: v,\n        taken: false,\n        id: cryptoRandomId(),\n      });\n    }\n\n    // Add distractor gears\n    while (gears.length < gearCount) {\n      const v = randInt(GEAR_MIN, Math.max(GEAR_MAX, Math.floor(target / 2) + 2));\n      // avoid creating duplicates of solution too often\n      gears.push({\n        x: randInt(80, WIDTH - 80),\n        y: randInt(140, HEIGHT - 220),\n        val: v,\n        taken: false,\n        id: cryptoRandomId(),\n      });\n    }\n\n    // Slightly nudge positions to avoid overlap\n    for (let i = 0; i < gears.length; i++) {\n      for (let j = i + 1; j < gears.length; j++) {\n        const a = gears[i], b = gears[j];\n        const dx = b.x - a.x;\n        const dy = b.y - a.y;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        if (dist < 60) {\n          b.x += (dx / dist) * 40 + randInt(-10, 10);\n          b.y += (dy / dist) * 40 + randInt(-10, 10);\n        }\n      }\n    }\n\n    // Reset player and state\n    player.x = WIDTH / 2;\n    player.carrying = [];\n    levelComplete = false;\n    gameComplete = false;\n    moves = 0;\n    announce(`Level ${level}. Fix the machine by collecting gears that add to ${target}. Use left and right arrows, press space to pick up a gear.`);\n  }\n\n  // Generate a short random id\n  function cryptoRandomId() {\n    try {\n      return Math.random().toString(36).slice(2, 9);\n    } catch (e) {\n      return Date.now().toString(36);\n    }\n  }\n\n  // Input handling\n  window.addEventListener(\"keydown\", function (e) {\n    if (e.repeat) return;\n    keys[e.key] = true;\n    // Acceptable keys: ArrowLeft, ArrowRight, Space, Enter, r, R, n, N\n    if (e.key === \" \" || e.key === \"Spacebar\") {\n      e.preventDefault();\n      attemptPick();\n    } else if (e.key === \"Enter\") {\n      attemptPick();\n    } else if (e.key === \"r\" || e.key === \"R\") {\n      resetGame();\n    } else if (e.key === \"n\" || e.key === \"N\") {\n      nextLevel();\n    } else if (e.key === \"ArrowLeft\" || e.key === \"ArrowRight\") {\n      // nothing extra\n    }\n  });\n\n  window.addEventListener(\"keyup\", function (e) {\n    delete keys[e.key];\n  });\n\n  // Make canvas clickable for mouse interactions\n  canvas.addEventListener(\"click\", function (ev) {\n    const rect = canvas.getBoundingClientRect();\n    const mx = ev.clientX - rect.left;\n    const my = ev.clientY - rect.top;\n    // Click near a gear picks it\n    let clicked = false;\n    for (let g of gears) {\n      if (!g.taken) {\n        const d = Math.hypot(g.x - mx, g.y - my);\n        if (d < 40) {\n          // Move player to gear instantly and pick\n          player.x = clamp(g.x + randInt(-10, 10), 40, WIDTH - 40);\n          attemptPick();\n          clicked = true;\n          break;\n        }\n      }\n    }\n    if (!clicked) {\n      // toggle audio control if clicking its visible area\n      // ignore; no action\n    }\n  });\n\n  // Attempt to pick up gears when near\n  function attemptPick() {\n    if (levelComplete || gameComplete) return;\n    // find nearest untaken gear within PICK_RANGE\n    let nearest = null;\n    let nearestDist = Infinity;\n    for (let g of gears) {\n      if (g.taken) continue;\n      const d = Math.hypot(g.x - player.x, g.y - player.y);\n      if (d < nearestDist) {\n        nearestDist = d;\n        nearest = g;\n      }\n    }\n    if (nearest && nearestDist <= PICK_RANGE) {\n      // pick it\n      nearest.taken = true;\n      player.carrying.push(nearest);\n      moves++;\n      playPick();\n      announce(`Picked gear ${nearest.val}. Current sum is ${currentSum()}.`);\n      // Check sum\n      const sum = currentSum();\n      if (sum === target) {\n        onLevelSuccess();\n      } else if (sum > target) {\n        // incorrect: sum too high \u2014 allow player to reset or continue (can't drop gears in this simple game)\n        message = \"Too many! Try again (press R to reset).\";\n        messageTimer = 240;\n        playIncorrect();\n        announce(\"Too many. Press R to try again.\");\n      } else {\n        // still under target \u2014 encourage\n        message = \"Nice! You're not there yet.\";\n        messageTimer = 80;\n      }\n    } else {\n      // no gear in range\n      message = \"No gear nearby. Move closer to pick a gear.\";\n      messageTimer = 80;\n      playIncorrect();\n      announce(\"No gear nearby.\");\n    }\n  }\n\n  function currentSum() {\n    return player.carrying.reduce((s, g) => s + g.val, 0);\n  }\n\n  function onLevelSuccess() {\n    levelComplete = true;\n    playSuccess();\n    message = \"Machine fixed! Nice work.\";\n    messageTimer = 240;\n    announce(`Level ${level} complete! You fixed the machine.`);\n    // If last level reached, mark game complete\n    if (level >= TOTAL_LEVELS) {\n      gameComplete = true;\n      announce(\"Congratulations! You repaired all the machines. Press R to play again.\");\n    }\n  }\n\n  function nextLevel() {\n    if (levelComplete && level < TOTAL_LEVELS) {\n      level++;\n      generateLevel(level);\n    } else if (!levelComplete) {\n      // allow skipping? No. We can encourage finishing\n      message = \"Finish the current level before moving on.\";\n      messageTimer = 120;\n      announce(\"Finish the current level first.\");\n    } else if (gameComplete) {\n      // restart fresh\n      level = 1;\n      generateLevel(level);\n    }\n  }\n\n  function resetGame() {\n    // Reset current level: return all taken gears\n    for (let g of gears) {\n      g.taken = false;\n    }\n    player.carrying = [];\n    message = \"Level reset. Try a new combination!\";\n    messageTimer = 120;\n    announce(\"Level reset.\");\n  }\n\n  // Drawing helpers\n  function drawRoundedRect(ctx, x, y, w, h, r, fillStyle, strokeStyle) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fillStyle) {\n      ctx.fillStyle = fillStyle;\n      ctx.fill();\n    }\n    if (strokeStyle) {\n      ctx.strokeStyle = strokeStyle;\n      ctx.stroke();\n    }\n  }\n\n  function drawGear(ctx, x, y, radius, teeth, colorFill, colorStroke, rotation = 0) {\n    // Draw a simple gear by creating radial teeth\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(rotation);\n    // teeth parameters\n    const inner = radius * 0.7;\n    const toothWidth = Math.PI * 2 / (teeth * 2);\n    ctx.beginPath();\n    for (let i = 0; i < teeth * 2; i++) {\n      const angle = i * toothWidth;\n      const r = i % 2 === 0 ? radius : inner;\n      const px = Math.cos(angle) * r;\n      const py = Math.sin(angle) * r;\n      if (i === 0) ctx.moveTo(px, py);\n      else ctx.lineTo(px, py);\n    }\n    ctx.closePath();\n    ctx.fillStyle = colorFill;\n    ctx.fill();\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = colorStroke;\n    ctx.stroke();\n\n    // center hole\n    ctx.beginPath();\n    ctx.arc(0, 0, radius * 0.35, 0, Math.PI * 2);\n    ctx.fillStyle = \"#F5F7F7\";\n    ctx.fill();\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  function drawRobot(ctx, x, y, carrying) {\n    // Simple friendly robot with round body and eyes\n    ctx.save();\n    ctx.translate(x, y);\n    // body\n    drawRoundedRect(ctx, -24, -28, 48, 48, 8, COLORS.robotBody, \"#A37A49\");\n    // head\n    drawRoundedRect(ctx, -18, -56, 36, 34, 6, COLORS.robotBody, \"#A37A49\");\n    // eyes\n    ctx.fillStyle = \"#2E3B3A\";\n    ctx.beginPath();\n    ctx.arc(-6, -44, 4, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(6, -44, 4, 0, Math.PI * 2);\n    ctx.fill();\n    // mouth\n    ctx.strokeStyle = \"#2E3B3A\";\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.arc(0, -36, 6, 0, Math.PI, false);\n    ctx.stroke();\n\n    // arm holding gears: draw small stack of carried gears\n    const startX = 18;\n    let sy = -4;\n    for (let i = 0; i < carrying.length; i++) {\n      const g = carrying[i];\n      drawGear(ctx, startX + (i % 2) * 10, sy - i * 6, 10, 8, COLORS.gearFill, COLORS.gearStroke, (i * 0.3) % 6);\n      ctx.fillStyle = COLORS.text;\n      ctx.font = \"10px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(g.val, startX + (i % 2) * 10, sy - i * 6 + 4);\n    }\n\n    ctx.restore();\n  }\n\n  // Main draw loop\n  let lastTime = 0;\n  function loop(ts) {\n    const dt = (ts - lastTime) || 16;\n    lastTime = ts;\n    update(dt);\n    draw();\n    requestAnimationFrame(loop);\n  }\n\n  function update(dt) {\n    // Input movement\n    if (keys[\"ArrowLeft\"]) {\n      player.x -= PLAYER_SPEED;\n    }\n    if (keys[\"ArrowRight\"]) {\n      player.x += PLAYER_SPEED;\n    }\n    player.x = clamp(player.x, 40, WIDTH - 40);\n\n    // handle message timer\n    if (messageTimer > 0) {\n      messageTimer--;\n      if (messageTimer === 0) {\n        message = \"\";\n      }\n    }\n  }\n\n  function draw() {\n    // clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // background\n    ctx.fillStyle = COLORS.background;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // top panel (instructions)\n    drawRoundedRect(ctx, 12, 12, WIDTH - 24, 96, 12, COLORS.panel, COLORS.accent);\n    ctx.fillStyle = COLORS.text;\n    ctx.font = \"20px sans-serif\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(`Machine Math \u2014 Level ${level} of ${TOTAL_LEVELS}`, 28, 38);\n    ctx.font = \"14px sans-serif\";\n    ctx.fillStyle = COLORS.text;\n    ctx.fillText(`Fix the machine by collecting gears that add to:`, 28, 60);\n    ctx.font = \"28px monospace\";\n    ctx.fillStyle = COLORS.accent2;\n    ctx.fillText(`${target}`, 320, 72);\n\n    // sub-instructions\n    ctx.font = \"12px sans-serif\";\n    ctx.fillStyle = \"#4F6B6A\";\n    ctx.fillText(\"Use left/right arrows. Press Space or Enter to pick up a gear when you're close.\", 28, 84);\n\n    // machine area (big rounded)\n    drawRoundedRect(ctx, 36, 120, WIDTH - 72, HEIGHT - 170, 14, COLORS.machine, COLORS.accent);\n\n    // conveyor belt background\n    ctx.fillStyle = \"#E6F2F1\";\n    ctx.fillRect(36, HEIGHT - 160, WIDTH - 72, 24);\n\n    // decorative piping and dials (wacky)\n    ctx.strokeStyle = \"#C9E7E3\";\n    ctx.lineWidth = 6;\n    ctx.beginPath();\n    ctx.moveTo(60, 160);\n    ctx.bezierCurveTo(120, 130, 240, 200, 380, 160);\n    ctx.bezierCurveTo(500, 120, 620, 200, 660, 160);\n    ctx.stroke();\n\n    // Draw gears\n    for (let g of gears) {\n      ctx.save();\n      // subtle bobbing\n      const rot = ((Date.now() / 800) % (Math.PI * 2)) * 0.6;\n      const bob = Math.sin((g.x + g.y + Date.now() / 200) / 150) * 6;\n      const x = g.x;\n      const y = g.y + bob;\n      // highlight if near player\n      const dist = Math.hypot(player.x - x, player.y - y);\n      const near = dist < PICK_RANGE;\n      ctx.globalAlpha = g.taken ? 0.3 : 1;\n      // gear body\n      drawGear(ctx, x, y, 28, 12, COLORS.gearFill, near ? COLORS.accent2 : COLORS.gearStroke, rot);\n      // number label\n      ctx.fillStyle = COLORS.text;\n      ctx.font = \"20px monospace\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(g.val, x, y + 6);\n      ctx.restore();\n    }\n\n    // Draw robot (player)\n    drawRobot(ctx, player.x, player.y, player.carrying);\n\n    // Draw player foot/shadow\n    ctx.fillStyle = \"rgba(0,0,0,0.05)\";\n    ctx.beginPath();\n    ctx.ellipse(player.x, player.y + 30, 28, 8, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Display current sum and moves\n    ctx.font = \"16px sans-serif\";\n    ctx.fillStyle = COLORS.text;\n    ctx.textAlign = \"left\";\n    ctx.fillText(`Current sum: ${currentSum()}`, 48, HEIGHT - 28);\n    ctx.fillText(`Moves: ${moves}`, WIDTH - 120, HEIGHT - 28);\n\n    // Message box\n    if (message) {\n      const boxW = WIDTH - 120;\n      drawRoundedRect(ctx, 60, HEIGHT - 110, boxW, 36, 8, message.includes(\"Too\") ? COLORS.wrong : COLORS.success, \"#B7D9D0\");\n      ctx.fillStyle = COLORS.text;\n      ctx.font = \"16px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(message, 60 + boxW / 2, HEIGHT - 84);\n    }\n\n    // Visual cue for audio status near control\n    ctx.save();\n    ctx.textAlign = \"right\";\n    ctx.font = \"12px sans-serif\";\n    ctx.fillStyle = COLORS.text;\n    if (audioAllowed) {\n      ctx.fillStyle = COLORS.accent2;\n      ctx.fillText(\"Audio: ON\", WIDTH - 20, 30);\n      // draw small sound wave icon\n      ctx.strokeStyle = COLORS.accent2;\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(WIDTH - 60, 20);\n      ctx.quadraticCurveTo(WIDTH - 55, 12, WIDTH - 50, 20);\n      ctx.quadraticCurveTo(WIDTH - 45, 28, WIDTH - 40, 20);\n      ctx.stroke();\n    } else {\n      ctx.fillStyle = \"#A7BFB9\";\n      ctx.fillText(\"Audio: OFF\", WIDTH - 20, 30);\n      ctx.strokeStyle = \"#A7BFB9\";\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(WIDTH - 60, 20);\n      ctx.lineTo(WIDTH - 40, 20);\n      ctx.stroke();\n    }\n    ctx.restore();\n\n    // If level complete overlay\n    if (levelComplete) {\n      ctx.save();\n      ctx.globalAlpha = 0.92;\n      drawRoundedRect(ctx, WIDTH / 2 - 180, HEIGHT / 2 - 70, 360, 140, 12, \"#FFFFFF\", \"#BCEEDD\");\n      ctx.fillStyle = COLORS.text;\n      ctx.font = \"22px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(level >= TOTAL_LEVELS ? \"Well done!\" : \"Machine repaired!\", WIDTH / 2, HEIGHT / 2 - 18);\n      ctx.font = \"16px sans-serif\";\n      ctx.fillStyle = \"#4F6B6A\";\n      ctx.fillText(level >= TOTAL_LEVELS ? \"You fixed all the machines.\" : \"Press N to move to the next machine.\", WIDTH / 2, HEIGHT / 2 + 12);\n      ctx.restore();\n    }\n\n    // If game complete overlay\n    if (gameComplete) {\n      ctx.save();\n      ctx.globalAlpha = 0.96;\n      drawRoundedRect(ctx, WIDTH / 2 - 200, HEIGHT / 2 - 80, 400, 160, 16, \"#F8FFFB\", \"#A7EAC6\");\n      ctx.fillStyle = COLORS.text;\n      ctx.font = \"24px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(\"All Machines Fixed!\", WIDTH / 2, HEIGHT / 2 - 10);\n      ctx.font = \"16px sans-serif\";\n      ctx.fillStyle = \"#4F6B6A\";\n      ctx.fillText(\"Great job! Press R to play again.\", WIDTH / 2, HEIGHT / 2 + 20);\n      ctx.restore();\n    }\n\n    // small caption for help\n    ctx.font = \"11px sans-serif\";\n    ctx.fillStyle = \"#6D8B88\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(\"Keyboard: \u2190 \u2192 to move \u2022 Space/Enter to pick \u2022 R reset \u2022 N next\", 40, HEIGHT - 8);\n  }\n\n  // Initialize first level\n  generateLevel(level);\n  initAudio();\n\n  // Start loop\n  requestAnimationFrame(loop);\n\n  // Expose some helpful console functions (optional)\n  window.machineMathGame = {\n    nextLevel: function () {\n      nextLevel();\n    },\n    resetLevel: function () {\n      resetGame();\n    },\n    enableAudio: function () {\n      audioControl.click();\n    },\n    getState: function () {\n      return {\n        level,\n        target,\n        sum: currentSum(),\n        moves,\n        audioAllowed,\n      };\n    },\n  };\n\n  // Safety: if audio not enabled within a while, show hint\n  setTimeout(() => {\n    if (!audioAllowed && audioContext) {\n      statusRegion.textContent = \"Tip: Click 'Enable sound' to hear friendly game sounds.\";\n    }\n  }, 4000);\n\n  // Error handling for visibility: if canvas context lost\n  canvas.addEventListener(\"webglcontextlost\", function (e) {\n    e.preventDefault();\n    alert(\"Canvas context lost \u2014 please reload the page.\");\n  });\n\n  // Focus canvas to allow keyboard immediately (best effort)\n  try {\n    canvas.focus();\n  } catch (e) {\n    // ignore\n  }\n\n})();\n---\n",
  "improve_response_tokens": 18243,
  "formatted_code": true,
  "formatting_response_tokens": 20258,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}