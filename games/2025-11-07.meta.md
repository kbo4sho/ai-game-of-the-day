# Game of the Day - 2025-11-07

## Metadata
- **Generated Date:** 2025-11-07
- **Generated Time:** 2025-11-07T00:29:08.415820
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-11-07.js
- **File Size:** 28476 bytes
- **Tokens Used:** 10001

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-11-07.js` - The playable game
- `2025-11-07.meta.json` - Machine-readable metadata
- `2025-11-07.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 21155

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 23805

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Drone Math Game for ages 7-9
  // Renders entirely into the element with id "game-of-the-day-stage".
  // Requirements: canvas 720x480, WebAudio API sounds, accessible keyboard controls,
  // clear win/loss conditions, non-overlapping UI using ctx.measureText(), etc.

  // Basic config
  const WIDTH = 720;
  const HEIGHT = 480;
  const GOAL = 10; // number of correct answers needed to win
  const MAX_WRONG = 3; // lives

  // Find container and create canvas
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Container element #game-of-the-day-stage not found.');
    return;
  }
  container.innerHTML = ''; // clear
  container.style.position = 'relative';

  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute('role', 'application');
  canvas.setAttribute('aria-label', 'Drone Math Game canvas');
  container.appendChild(canvas);

  const ctx = canvas.getContext('2d', { alpha: false });

  // Fonts and spacing
  const PADDING = 12;
  const UI_FONT = '16px sans-serif';
  const IMPORTANT_FONT = '22px sans-serif';
  const TITLE_FONT = '28px sans-serif';

  // Audio
  let audioCtx = null;
  let audioAvailable = true;
  let bgGain = null;
  let bgOsc = null;
  let bgLFO = null;
  let audioInitialized = false;
  let muted = false;

  function initAudio() {
    // Initialize Web Audio API with error handling.
    if (audioInitialized) return;
    audioInitialized = true;
    try {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AudioContext();
      // Create background hum with low volume
      bgGain = audioCtx.createGain();
      bgGain.gain.value = 0.02; // gentle
      bgGain.connect(audioCtx.destination);

      bgOsc = audioCtx.createOscillator();
      bgOsc.type = 'sine';
      bgOsc.frequency.value = 80; // base hum
      // Slight vibrato via LFO
      bgLFO = audioCtx.createOscillator();
      const lfoGain = audioCtx.createGain();
      lfoGain.gain.value = 6;
      bgLFO.frequency.value = 0.15; // slow
      bgLFO.connect(lfoGain);
      lfoGain.connect(bgOsc.frequency);

      bgOsc.connect(bgGain);

      // Start oscillators only when user interacts (to satisfy browser autoplay policies)
    } catch (e) {
      console.warn('Audio not available:', e);
      audioAvailable = false;
      audioCtx = null;
    }
  }

  function resumeAudioIfNeeded() {
    if (!audioAvailable || !audioCtx) return;
    if (audioCtx.state === 'suspended') {
      audioCtx.resume().catch((e) => {
        console.warn('Could not resume audio context:', e);
      });
    }
  }

  function startBackground() {
    if (!audioAvailable || !audioCtx || !bgOsc) return;
    try {
      if (bgOsc.start) {
        // start only if not already started. Creating new oscillator each start could be needed,
        // but we created them once and haven't started yet.
      }
      // If oscillators were already started earlier, don't start again.
      try {
        bgOsc.start();
        bgLFO.start();
      } catch (e) {
        // already started - that's okay
      }
      bgGain.gain.value = muted ? 0 : 0.02;
    } catch (e) {
      console.warn('Error starting background audio:', e);
    }
  }

  function stopBackground() {
    if (!audioAvailable || !audioCtx || !bgGain) return;
    bgGain.gain.value = 0;
  }

  function playTone(freq, duration = 0.25, type = 'sine', volume = 0.12) {
    if (!audioAvailable || !audioCtx) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = 0;
      o.connect(g);
      g.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      g.gain.cancelScheduledValues(now);
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(volume, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);
      o.start(now);
      o.stop(now + duration + 0.05);
    } catch (e) {
      console.warn('Error playing tone:', e);
    }
  }

  function playCorrectSound() {
    if (!audioAvailable || !audioCtx) return;
    try {
      // pleasant arpeggio
      const now = audioCtx.currentTime;
      const freqs = [660, 880, 990];
      freqs.forEach((f, i) => {
        const o = audioCtx.createOscillator();
        o.type = 'triangle';
        o.frequency.value = f;
        const g = audioCtx.createGain();
        g.gain.value = 0;
        o.connect(g);
        g.connect(audioCtx.destination);
        const start = now + i * 0.06;
        g.gain.setValueAtTime(0.0001, start);
        g.gain.linearRampToValueAtTime(0.11, start + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, start + 0.26);
        o.start(start);
        o.stop(start + 0.3);
      });
    } catch (e) {
      console.warn('Error playing correct sound:', e);
    }
  }

  function playWrongSound() {
    if (!audioAvailable || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      o.type = 'sawtooth';
      o.frequency.setValueAtTime(220, now);
      const g = audioCtx.createGain();
      o.connect(g);
      g.connect(audioCtx.destination);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.linearRampToValueAtTime(0.18, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);
      o.frequency.linearRampToValueAtTime(120, now + 0.4);
      o.start(now);
      o.stop(now + 0.45);
    } catch (e) {
      console.warn('Error playing wrong sound:', e);
    }
  }

  // Game state
  let state = {
    mode: 'start', // 'start' | 'playing' | 'victory' | 'gameover'
    correct: 0,
    wrong: 0,
    question: null,
    choices: [],
    selectedIndex: 0,
    // Drone visual progress (0..GOAL)
    progress: 0,
    lastActionTime: 0,
  };

  // Answer boxes rectangles for hit testing
  let answerBoxes = [];

  // Utility to generate question appropriate for ages 7-9
  function generateQuestion() {
    // choose operation weighted: addition/subtraction common, multiplication sometimes
    const ops = ['+', '+', '+', '-', '-', '×'];
    const op = ops[Math.floor(Math.random() * ops.length)];
    let a, b, answer;
    if (op === '+') {
      a = Math.floor(Math.random() * 20) + 1; // 1-20
      b = Math.floor(Math.random() * 20) + 1;
      answer = a + b;
    } else if (op === '-') {
      a = Math.floor(Math.random() * 20) + 1;
      b = Math.floor(Math.random() * a) + 0; // ensure non-negative result
      answer = a - b;
    } else {
      // multiplication small
      a = Math.floor(Math.random() * 6) + 1; // 1-6
      b = Math.floor(Math.random() * 6) + 1;
      answer = a * b;
    }
    const qText = `${a} ${op} ${b} = ?`;
    // create 3 choices
    const choices = new Set();
    choices.add(answer);
    while (choices.size < 3) {
      // plausible distractor: answer +/- small value
      const delta = Math.floor(Math.random() * 5) + 1;
      const sign = Math.random() < 0.5 ? -1 : 1;
      const choiceValue = Math.max(0, answer + sign * delta);
      choices.add(choiceValue);
    }
    const choicesArr = Array.from(choices);
    // shuffle
    for (let i = choicesArr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [choicesArr[i], choicesArr[j]] = [choicesArr[j], choicesArr[i]];
    }
    return {
      text: qText,
      answer,
      choices: choicesArr,
    };
  }

  function startNewQuestion() {
    const q = generateQuestion();
    state.question = q.text;
    state.choices = q.choices;
    state.correctAnswer = q.answer;
    state.selectedIndex = 0;
    state.lastActionTime = Date.now();
    computeAnswerBoxes(); // places boxes based on choices
  }

  // Layout helpers using ctx.measureText
  function drawTextWithBackground(text, x, y, font, textColor = '#051', bgColor = 'rgba(255,255,255,0.8)', padding = 10, align = 'left') {
    ctx.font = font;
    const metrics = ctx.measureText(text);
    const textWidth = Math.ceil(metrics.width);
    const textHeight = Math.ceil(parseInt(font, 10)); // approximate
    let bx = x;
    if (align === 'center') {
      bx = x - textWidth / 2 - padding;
    } else if (align === 'right') {
      bx = x - textWidth - padding * 2;
    }
    const by = y;
    ctx.fillStyle = bgColor;
    ctx.fillRect(bx, by, textWidth + padding * 2, textHeight + padding);
    ctx.fillStyle = textColor;
    ctx.textBaseline = 'top';
    if (align === 'center') {
      ctx.textAlign = 'center';
      ctx.fillText(text, x, y + padding / 2);
    } else if (align === 'right') {
      ctx.textAlign = 'right';
      ctx.fillText(text, bx + textWidth + padding, y + padding / 2);
    } else {
      ctx.textAlign = 'left';
      ctx.fillText(text, bx + padding, y + padding / 2);
    }
    return { bx, by, bw: textWidth + padding * 2, bh: textHeight + padding };
  }

  // Compute answer box positions ensuring non-overlap and using measureText
  function computeAnswerBoxes() {
    // We'll place three boxes centered horizontally in the lower-middle area
    ctx.font = IMPORTANT_FONT;
    const textWidths = state.choices.map((c) => Math.ceil(ctx.measureText(String(c)).width));
    const boxHe = Math.max(40, parseInt(IMPORTANT_FONT, 10) + 14);
    const spacingMin = 12; // minimum spacing between boxes
    // Total width
    const totalTextWidth = textWidths.reduce((a, b) => a + b, 0);
    const totalBoxPadding = (textWidths.length) * 24; // left+right padding ~24 each
    let totalWidth = totalTextWidth + totalBoxPadding + (state.choices.length - 1) * spacingMin;
    const maxAreaWidth = WIDTH - 240; // leave room for drone on right
    if (totalWidth > maxAreaWidth) {
      // If too wide, reduce padding and spacing
      const extra = totalWidth - maxAreaWidth;
      // reduce spacing proportionally
      totalWidth = maxAreaWidth;
    }
    const startX = Math.round((WIDTH - totalWidth) / 2);
    const y = Math.round(HEIGHT * 0.45);
    answerBoxes = [];
    let x = startX;
    for (let i = 0; i < state.choices.length; i++) {
      const tw = textWidths[i];
      const boxW = tw + 24;
      answerBoxes.push({
        x,
        y,
        w: boxW,
        h: boxHe,
        text: String(state.choices[i]),
        index: i,
      });
      x += boxW + spacingMin;
    }
  }

  // Hit test for clicks
  function hitTestAnswer(mx, my) {
    for (const box of answerBoxes) {
      if (mx >= box.x && mx <= box.x + box.w && my >= box.y && my <= box.y + box.h) {
        return box.index;
      }
    }
    return -1;
  }

  // Input handlers
  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    resumeAudioIfNeeded();
    initAudio();
    if (!audioInitialized) initAudio();
    if (!audioAvailable && !audioInitialized) {
      // Audio unavailable - continue anyway
    } else {
      startBackground();
    }

    if (state.mode === 'start') {
      // Start the game
      startGame();
      return;
    } else if (state.mode === 'playing') {
      const hit = hitTestAnswer(mx, my);
      if (hit >= 0) {
        state.selectedIndex = hit;
        submitAnswer();
        return;
      }
    } else if (state.mode === 'victory' || state.mode === 'gameover') {
      // Check if clicked restart button area
      if (isInsideRestart(mx, my)) {
        restartGame();
      } else {
        // clicking anywhere also restarts for convenience
        restartGame();
      }
    }
    // Handle clicking audio icon
    if (isInsideAudioToggle(mx, my)) {
      toggleMute();
    }
  });

  function isInsideRestart(mx, my) {
    // We'll draw restart button at bottom center; check approximate area
    const bw = 160;
    const bh = 46;
    const bx = (WIDTH - bw) / 2;
    const by = HEIGHT - bh - 20;
    return mx >= bx && mx <= bx + bw && my >= by && my <= by + bh;
  }

  function isInsideAudioToggle(mx, my) {
    // small rectangle top-left offset
    const bx = 10;
    const by = HEIGHT - 44;
    const bw = 110;
    const bh = 34;
    return mx >= bx && mx <= bx + bw && my >= by && my <= by + bh;
  }

  window.addEventListener('keydown', (e) => {
    const key = e.key;
    if (key === 'm' || key === 'M') {
      toggleMute();
    } else if ((key === 'r' || key === 'R')) {
      if (state.mode === 'victory' || state.mode === 'gameover') {
        restartGame();
      } else if (state.mode === 'start') {
        startGame();
      } else {
        restartGame();
      }
    } else if ((key === ' ' || key === 'Spacebar') && state.mode === 'start') {
      startGame();
      e.preventDefault();
    } else if (state.mode === 'playing') {
      // number keys 1-3 to pick choices
      if (key >= '1' && key <= '3') {
        const idx = parseInt(key, 10) - 1;
        if (idx < state.choices.length) {
          state.selectedIndex = idx;
          submitAnswer();
        }
      } else if (key === 'ArrowLeft') {
        state.selectedIndex = (state.selectedIndex - 1 + state.choices.length) % state.choices.length;
      } else if (key === 'ArrowRight') {
        state.selectedIndex = (state.selectedIndex + 1) % state.choices.length;
      } else if (key === 'Enter') {
        submitAnswer();
      }
    }
    resumeAudioIfNeeded();
    initAudio();
    startBackground();
  });

  function toggleMute() {
    muted = !muted;
    if (bgGain) bgGain.gain.value = muted ? 0 : 0.02;
  }

  // Game flow
  function startGame() {
    state.mode = 'playing';
    state.correct = 0;
    state.wrong = 0;
    state.progress = 0;
    startNewQuestion();
    resumeAudioIfNeeded();
    initAudio();
    startBackground();
    lastTick = performance.now();
  }

  function restartGame() {
    state.mode = 'start';
    state.correct = 0;
    state.wrong = 0;
    state.progress = 0;
    state.question = null;
    state.choices = [];
    state.selectedIndex = 0;
    answerBoxes = [];
    stopBackground();
  }

  function submitAnswer() {
    if (state.mode !== 'playing') return;
    const chosen = state.choices[state.selectedIndex];
    const isCorrect = Number(chosen) === Number(state.correctAnswer);
    if (isCorrect) {
      // correct
      state.correct++;
      state.progress = Math.min(GOAL, state.progress + 1);
      playCorrectSound();
      // small boost animation/time
      if (state.correct >= GOAL) {
        // victory
        state.mode = 'victory';
        stopBackground();
        setTimeout(() => {
          // leave as is
        }, 300);
        return;
      }
      // next question after brief delay
      setTimeout(startNewQuestion, 400);
    } else {
      state.wrong++;
      playWrongSound();
      // vibrate drone or show wobble
      if (state.wrong >= MAX_WRONG) {
        state.mode = 'gameover';
        stopBackground();
        return;
      } else {
        // new question after a small delay
        setTimeout(startNewQuestion, 450);
      }
    }
  }

  // Drawing utilities
  function drawBackground() {
    // calming gradient with wacky elements (floating clouds)
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#dff3ff');
    g.addColorStop(1, '#ffffff');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Draw softly wavy lines (wind)
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(120,180,220,0.12)';
    for (let i = 0; i < 5; i++) {
      ctx.beginPath();
      const y = 40 + i * 70;
      ctx.moveTo(0, y);
      for (let x = 0; x <= WIDTH; x += 20) {
        const yy = y + Math.sin((x + performance.now() / 60) / 40 + i) * 8;
        ctx.lineTo(x, yy);
      }
      ctx.stroke();
    }
    // soft clouds: made with arcs
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    const t = performance.now() / 1000;
    const cloudCenters = [
      { x: 120 + Math.sin(t / 4) * 16, y: 60 },
      { x: 320 + Math.cos(t / 5) * 12, y: 80 },
      { x: 520 + Math.sin(t / 6) * 10, y: 50 },
    ];
    for (const c of cloudCenters) {
      ctx.beginPath();
      ctx.arc(c.x, c.y, 24, 0, Math.PI * 2);
      ctx.arc(c.x + 28, c.y + 4, 30, 0, Math.PI * 2);
      ctx.arc(c.x + 56, c.y, 22, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawTopUI() {
    // Score top-left
    ctx.font = UI_FONT;
    ctx.textBaseline = 'top';
    ctx.fillStyle = '#053';
    const scoreText = `Correct: ${state.correct}/${GOAL}`;
    const sBox = drawTextWithBackground(scoreText, PADDING, PADDING, UI_FONT, '#053', 'rgba(255,255,255,0.9)', PADDING, 'left');

    // Lives top-right with hearts
    const livesText = `Lives: ${Math.max(0, MAX_WRONG - state.wrong)}`;
    const metrics = ctx.measureText(livesText);
    ctx.font = UI_FONT;
    const textWidth = Math.ceil(metrics.width);
    const bx = WIDTH - textWidth - PADDING * 3;
    const by = PADDING;
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.fillRect(bx, by, textWidth + PADDING * 2, parseInt(UI_FONT, 10) + PADDING);
    ctx.fillStyle = '#550';
    ctx.textAlign = 'left';
    ctx.fillText(livesText, bx + PADDING, by + PADDING / 2);

    // Audio status bottom-left-ish (accessible)
    ctx.font = '14px sans-serif';
    const audioText = audioAvailable ? (muted ? 'Audio: Off (M)' : 'Audio: On (M)') : 'Audio: Unavailable';
    const ax = PADDING;
    const ay = HEIGHT - 44;
    const audMetrics = ctx.measureText(audioText);
    const aw = Math.ceil(audMetrics.width) + PADDING * 2;
    const ah = 34;
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.fillRect(ax, ay, aw, ah);
    ctx.fillStyle = '#333';
    ctx.fillText(audioText, ax + PADDING, ay + 10);

    // Instructions bottom-center (non-overlapping)
    ctx.font = '18px sans-serif';
    const inst = state.mode === 'start' ? 'Press Space or Click to Start. Use 1-3, arrows or click answers.' : 'Use 1-3 or click. Enter to submit. Press M to toggle audio.';
    const centerX = WIDTH / 2;
    // measure
    const instWidth = Math.ceil(ctx.measureText(inst).width);
    const ix = centerX - instWidth / 2 - PADDING;
    const iy = HEIGHT - 44;
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.fillRect(ix, iy, instWidth + PADDING * 2, 34);
    ctx.fillStyle = '#014';
    ctx.textAlign = 'center';
    ctx.fillText(inst, centerX, iy + 8);
  }

  function drawQuestionArea() {
    // centered near top middle-left (leave room for drone)
    ctx.font = TITLE_FONT;
    ctx.textBaseline = 'top';
    ctx.fillStyle = '#053';
    const question = state.question || 'Get ready!';
    const x = WIDTH / 2 - 120;
    const y = 80;
    // use measureText to compute rect
    ctx.font = TITLE_FONT;
    const metrics = ctx.measureText(question);
    const w = Math.ceil(metrics.width);
    const h = parseInt(TITLE_FONT, 10) + 8;
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.fillRect(x - PADDING, y - PADDING, w + PADDING * 2 + 20, h + PADDING);
    ctx.fillStyle = '#024';
    ctx.textAlign = 'left';
    ctx.fillText(question, x + 8, y);
  }

  function drawChoices() {
    // draw boxes from answerBoxes
    ctx.font = IMPORTANT_FONT;
    for (const box of answerBoxes) {
      // background
      const isSelected = state.selectedIndex === box.index && state.mode === 'playing';
      ctx.fillStyle = isSelected ? 'rgba(245,235,200,0.95)' : 'rgba(255,255,255,0.95)';
      ctx.fillRect(box.x, box.y, box.w, box.h);
      // border
      ctx.strokeStyle = isSelected ? '#f7a' : '#cce';
      ctx.lineWidth = isSelected ? 3 : 2;
      ctx.strokeRect(box.x + 0.5, box.y + 0.5, box.w - 1, box.h - 1);
      // text
      ctx.fillStyle = '#023';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(box.text, box.x + box.w / 2, box.y + box.h / 2);
      // small label number
      ctx.font = '12px sans-serif';
      ctx.fillStyle = '#666';
      ctx.textAlign = 'left';
      ctx.fillText(String(box.index + 1), box.x + 6, box.y + 6);
      ctx.font = IMPORTANT_FONT;
    }
  }

  // Drone drawing
  function drawDrone() {
    // Position drone on right side. Vertical bobbing based on time and progress.
    const baseX = WIDTH - 160;
    const baseY = HEIGHT / 2 + (GOAL - state.progress) * 6 - 20; // progress causes ascent
    const t = performance.now() / 500;
    const bob = Math.sin(t) * 6;
    const x = baseX;
    const y = baseY + bob;
    // Body
    ctx.save();
    ctx.translate(x, y);
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,0.08)';
    ctx.beginPath();
    ctx.ellipse(18, 54, 46, 12, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#fffbcc';
    ctx.strokeStyle = '#333';
    // main body
    ctx.fillStyle = '#eaf7ff';
    ctx.strokeStyle = '#0b3';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(0, 0, 48, 26, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    // cockpit
    ctx.fillStyle = '#d0f0ff';
    ctx.beginPath();
    ctx.ellipse(8, -4, 18, 12, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // weird wacky smile
    ctx.strokeStyle = '#0a4';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(8, 2, 8, 0.2, Math.PI - 0.2);
    ctx.stroke();

    // rotor arms and rotors
    const rotorOffsets = [
      { rx: -38, ry: -18 },
      { rx: 38, ry: -18 },
      { rx: -38, ry: 18 },
      { rx: 38, ry: 18 },
    ];
    const rotAngle = performance.now() / 120;
    rotorOffsets.forEach((o, i) => {
      // arm
      ctx.strokeStyle = 'rgba(10,60,80,0.6)';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(o.rx / 2, o.ry / 2);
      ctx.lineTo(o.rx, o.ry);
      ctx.stroke();
      // rotor hub
      ctx.fillStyle = '#f5f5f0';
      ctx.beginPath();
      ctx.arc(o.rx, o.ry, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      // blades - wacky: 3 blades rotating
      ctx.save();
      ctx.translate(o.rx, o.ry);
      ctx.rotate(rotAngle + i);
      ctx.fillStyle = 'rgba(120,160,180,0.85)';
      for (let b = 0; b < 3; b++) {
        ctx.beginPath();
        ctx.ellipse(0, 14, 3.5, 14, b * (Math.PI * 2 / 3), 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    });

    ctx.restore();

    // Altitude meter (progress)
    const meterX = WIDTH - 80;
    const meterY = 40;
    const meterW = 24;
    const meterH = 240;
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.fillRect(meterX - 12, meterY - 8, meterW + 24, meterH + 16);
    ctx.strokeStyle = '#cce';
    ctx.strokeRect(meterX - 12 + 0.5, meterY - 8 + 0.5, meterW + 24 - 1, meterH + 16 - 1);
    // meter bar background
    ctx.fillStyle = '#eef6ff';
    ctx.fillRect(meterX, meterY, meterW, meterH);
    // filled portion
    const filledH = Math.round((state.progress / GOAL) * meterH);
    ctx.fillStyle = '#7fd3a6';
    ctx.fillRect(meterX, meterY + (meterH - filledH), meterW, filledH);
    ctx.strokeStyle = '#2b8';
    ctx.strokeRect(meterX, meterY, meterW, meterH);
    // small labels
    ctx.fillStyle = '#224';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Altitude', meterX + meterW / 2, meterY - 20);
    ctx.fillText(`${state.progress}/${GOAL}`, meterX + meterW / 2, meterY + meterH + 6);
  }

  function drawStarsCollected() {
    // Draw collected little stars near top-right below score
    const sx = WIDTH - 180;
    const sy = 18 + 40;
    for (let i = 0; i < GOAL; i++) {
      const cx = sx + (i % 5) * 18;
      const cy = sy + Math.floor(i / 5) * 18;
      drawStar(cx, cy, 6, i < state.progress ? '#ffd24d' : '#f0f0f0', i < state.progress ? '#e68400' : '#ccc');
    }
  }

  function drawStar(cx, cy, r, fill, stroke) {
    ctx.save();
    ctx.beginPath();
    for (let i = 0; i < 5; i++) {
      const a = (Math.PI * 2 * i) / 5 - Math.PI / 2;
      const sx = cx + Math.cos(a) * r;
      const sy = cy + Math.sin(a) * r;
      ctx.lineTo(sx, sy);
      const a2 = a + Math.PI / 5;
      ctx.lineTo(cx + Math.cos(a2) * (r / 2), cy + Math.sin(a2) * (r / 2));
    }
    ctx.closePath();
    ctx.fillStyle = fill;
    ctx.fill();
    ctx.strokeStyle = stroke;
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.restore();
  }

  // Victory and Game Over screens
  function drawEndScreen() {
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    ctx.textAlign = 'center';
    ctx.fillStyle = '#fff';
    ctx.font = '40px sans-serif';
    const title = state.mode === 'victory' ? 'Mission Accomplished!' : 'Game Over';
    const subtitle = state.mode === 'victory' ? 'The drone is airborne! Great job!' : `You had ${state.wrong} wrong answers. Try again!`;
    // compute text widths and draw background box using measureText
    ctx.font = TITLE_FONT;
    const titleW = Math.ceil(ctx.measureText(title).width);
    const boxW = Math.max(420, titleW + 60);
    const bx = (WIDTH - boxW) / 2;
    const by = HEIGHT / 2 - 110;
    ctx.fillStyle = 'rgba(255,255,255,0.96)';
    ctx.fillRect(bx, by, boxW, 220);
    ctx.fillStyle = '#063';
    ctx.font = TITLE_FONT;
    ctx.fillText(title, WIDTH / 2, by + 22);
    ctx.font = IMPORTANT_FONT;
    ctx.fillStyle = '#024';
    ctx.fillText(subtitle, WIDTH / 2, by + 72);

    // restart button
    const bw = 160;
    const bh = 46;
    const rx = (WIDTH - bw) / 2;
    const ry = by + 130;
    ctx.fillStyle = '#e6f8ff';
    ctx.fillRect(rx, ry, bw, bh);
    ctx.strokeStyle = '#7cc';
    ctx.strokeRect(rx + 0.5, ry + 0.5, bw - 1, bh - 1);
    ctx.fillStyle = '#045';
    ctx.font = '18px sans-serif';
    ctx.fillText('Restart (R)', WIDTH / 2, ry + 12);

    // small hint for accessibility
    ctx.font = '14px sans-serif';
    ctx.fillStyle = '#113';
    ctx.fillText('Press R or click Restart to play again.', WIDTH / 2, ry + 40);
  }

  // Main draw loop
  let lastTick = performance.now();
  function frame() {
    // update
    const now = performance.now();
    const dt = (now - lastTick) / 1000;
    lastTick = now;

    // clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    drawBackground();
    drawTopUI();
    drawQuestionArea();

    if (state.mode === 'start') {
      // big start card in center
      ctx.font = '26px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillStyle = '#023';
      const title = 'Drone Math — Power the Drone!';
      const subtitle = 'Answer 10 questions correctly to lift off. 3 wrong answers and the mission fails.';
      // measure and background
      const w1 = Math.ceil(ctx.measureText(title).width);
      ctx.font = '16px sans-serif';
      const w2 = Math.ceil(ctx.measureText(subtitle).width);
      const boxW = Math.max(w1, w2) + 40;
      const bx = (WIDTH - boxW) / 2;
      const by = HEIGHT / 2 - 70;
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.fillRect(bx, by, boxW, 140);
      ctx.fillStyle = '#024';
      ctx.font = '26px sans-serif';
      ctx.fillText(title, WIDTH / 2, by + 10);
      ctx.font = '16px sans-serif';
      ctx.fillText(subtitle, WIDTH / 2, by + 52);
      ctx.fillStyle = '#046';
      ctx.font = '18px sans-serif';
      ctx.fillText('Press Space or Click to Start. Use 1-3 or click answers.', WIDTH / 2, by + 92);

      // tiny robot/drone doodle
      ctx.save();
      ctx.translate(WIDTH / 2 + 180, HEIGHT / 2 - 40);
      ctx.fillStyle = '#fff2cc';
      ctx.beginPath();
      ctx.ellipse(0, 0, 30, 16, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#c89';
      ctx.stroke();
      ctx.restore();
    } else if (state.mode === 'playing') {
      drawChoices();
      drawDrone();
      drawStarsCollected();
    } else if (state.mode === 'victory' || state.mode === 'gameover') {
      drawDrone();
      drawStarsCollected();
      drawEndScreen();
    }

    // accessibility focus highlight for selected answer (if playing)
    if (state.mode === 'playing' && answerBoxes[state.selectedIndex]) {
      const b = answerBoxes[state.selectedIndex];
      ctx.save();
      ctx.strokeStyle = '#ff8';
      ctx.lineWidth = 3;
      ctx.setLineDash([6, 6]);
      ctx.strokeRect(b.x - 4, b.y - 4, b.w + 8, b.h + 8);
      ctx.restore();
    }

    // next frame
    requestAnimationFrame(frame);
  }

  // initial setup
  initAudio();
  restartGame();
  // compute initial text layout to ensure no overlaps
  ctx.font = UI_FONT;
  computeAnswerBoxes();

  // Start render loop
  requestAnimationFrame(frame);

  // Expose some debug functions to console (optional)
  window.__droneMathGame = {
    restart: restartGame,
    start: startGame,
    state,
  };
})();
---

