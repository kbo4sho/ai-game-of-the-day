{
  "generated_date": "2025-08-23",
  "generated_timestamp": "2025-08-23T00:27:45.733918",
  "model": "gpt-5-mini",
  "theme": "electricity",
  "prompt": "You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity\n\nThe game must:\n\u2022 Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.\n\u2022 Reinforce the math concept through a real-world narratives tied to theme.\n\u2022 Include fun, unique memorable characters tied to the theme.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9413,
  "game_filename": "2025-08-23.js",
  "game_size_bytes": 24904,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Electricity Math Game for ages 7-9\n// Renders inside element with ID \"game-of-the-day-stage\"\n// Canvas-only visuals and Web Audio API sounds\n// Accessible with keyboard, has ARIA status, and error handling for audio\n\n(function () {\n  // Config\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const CONTAINER_ID = \"game-of-the-day-stage\";\n  const MAX_ORBS = 7;\n  const ROBOT_SPEED = 160; // pixels per second\n  const ORB_RADIUS = 20;\n  const ROBOT_RADIUS = 24;\n  const BG_COLOR = \"#edf6fb\";\n  const ORB_COLORS = [\"#FFD166\", \"#06D6A0\", \"#118AB2\", \"#EF476F\", \"#06B6D4\", \"#7C4DFF\"];\n  const FONT = \"16px Georgia\";\n  const TITLE_FONT = \"26px Georgia\";\n  const SMALL_FONT = \"14px Georgia\";\n\n  // State\n  let container, canvas, ctx, lastTime = 0, rafId;\n  let keys = {};\n  let gameState = \"title\"; // title, playing, success\n  let robot = { x: WIDTH / 2, y: HEIGHT - 80, r: ROBOT_RADIUS, vx: 0, vy: 0 };\n  let orbs = [];\n  let collected = []; // orb indices\n  let target = 0;\n  let statusMessage = \"\";\n  let level = 1;\n  let audioAvailable = false;\n  let audioEnabled = true;\n  let audioCtx = null;\n  let humGainNode = null;\n  let speakerIconHover = false;\n  let sparks = []; // visual particle sparks\n  let accessibleStatusEl;\n\n  // Utility helpers\n  function randRange(a, b) {\n    return Math.floor(Math.random() * (b - a + 1)) + a;\n  }\n  function pick(arr) {\n    return arr[Math.floor(Math.random() * arr.length)];\n  }\n  function clamp(v, a, b) {\n    return Math.max(a, Math.min(b, v));\n  }\n  function dist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  // Audio helpers with proper error handling\n  function initAudio() {\n    try {\n      const AudioContext = window.AudioContext || window.webkitAudioContext;\n      if (!AudioContext) throw new Error(\"Web Audio API not supported\");\n      audioCtx = new AudioContext();\n      audioAvailable = true;\n      // create gentle background hum\n      try {\n        const osc = audioCtx.createOscillator();\n        const gain = audioCtx.createGain();\n        const filter = audioCtx.createBiquadFilter();\n        filter.type = \"lowpass\";\n        filter.frequency.value = 600;\n        osc.type = \"sine\";\n        osc.frequency.value = 60; // low hum\n        gain.gain.value = 0.01; // very quiet by default\n        osc.connect(filter);\n        filter.connect(gain);\n        gain.connect(audioCtx.destination);\n        osc.start();\n        humGainNode = gain;\n        // Start muted until explicit enable by user (audioEnabled flag)\n        setHumOn(audioEnabled);\n      } catch (err) {\n        console.warn(\"Background hum init error:\", err);\n      }\n    } catch (err) {\n      console.warn(\"Audio init failed:\", err);\n      audioAvailable = false;\n      audioCtx = null;\n    }\n  }\n\n  function resumeAudioContextIfNeeded() {\n    if (!audioCtx) return;\n    if (audioCtx.state === \"suspended\") {\n      audioCtx.resume().catch((e) => {\n        console.warn(\"Audio resume failed:\", e);\n      });\n    }\n  }\n\n  function setHumOn(on) {\n    if (!audioAvailable || !humGainNode) return;\n    humGainNode.gain.setTargetAtTime(on ? 0.01 : 0.0, audioCtx.currentTime, 0.05);\n  }\n\n  // Create a short beep using oscillator\n  function playBeep(freq = 440, time = 0.12, type = \"sine\", volume = 0.08) {\n    if (!audioAvailable || !audioEnabled) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      o.type = type;\n      o.frequency.value = freq;\n      g.gain.value = volume;\n      o.connect(g);\n      g.connect(audioCtx.destination);\n      const now = audioCtx.currentTime;\n      g.gain.setValueAtTime(volume, now);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + time);\n      o.start(now);\n      o.stop(now + time + 0.02);\n    } catch (err) {\n      console.warn(\"playBeep error\", err);\n    }\n  }\n\n  // Chime for success (sequence of notes)\n  function playChime() {\n    if (!audioAvailable || !audioEnabled) return;\n    try {\n      const freqs = [660, 880, 990, 880];\n      freqs.forEach((f, i) => {\n        setTimeout(() => playBeep(f, 0.18, \"triangle\", 0.06), i * 160);\n      });\n    } catch (err) {\n      console.warn(\"playChime error\", err);\n    }\n  }\n\n  // Buzz for error\n  function playBuzz() {\n    if (!audioAvailable || !audioEnabled) return;\n    try {\n      const o = audioCtx.createOscillator();\n      const g = audioCtx.createGain();\n      const filter = audioCtx.createBiquadFilter();\n      filter.type = \"lowpass\";\n      filter.frequency.value = 600;\n      o.type = \"square\";\n      o.frequency.value = 120;\n      g.gain.value = 0.08;\n      o.connect(filter);\n      filter.connect(g);\n      g.connect(audioCtx.destination);\n      const now = audioCtx.currentTime;\n      g.gain.setValueAtTime(0.08, now);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);\n      o.start(now);\n      o.stop(now + 0.25);\n    } catch (err) {\n      console.warn(\"playBuzz error\", err);\n    }\n  }\n\n  // Announce status for screen readers\n  function announce(text) {\n    if (accessibleStatusEl) {\n      accessibleStatusEl.textContent = text;\n    }\n  }\n\n  // DOM & Canvas Setup\n  function initDOM() {\n    container = document.getElementById(CONTAINER_ID);\n    if (!container) {\n      console.error(\"Container element with ID\", CONTAINER_ID, \"not found.\");\n      return;\n    }\n    // Clear container\n    container.innerHTML = \"\";\n    container.style.position = \"relative\";\n    container.style.width = WIDTH + \"px\";\n    container.style.height = HEIGHT + \"px\";\n\n    // Create canvas\n    canvas = document.createElement(\"canvas\");\n    canvas.width = WIDTH;\n    canvas.height = HEIGHT;\n    canvas.setAttribute(\"aria-label\", \"Electric Sparks Math Game\");\n    canvas.style.outline = \"none\";\n    canvas.tabIndex = 0; // make focusable\n    container.appendChild(canvas);\n    ctx = canvas.getContext(\"2d\", { alpha: false });\n\n    // Accessible live region (offscreen)\n    accessibleStatusEl = document.createElement(\"div\");\n    accessibleStatusEl.setAttribute(\"role\", \"status\");\n    accessibleStatusEl.setAttribute(\"aria-live\", \"polite\");\n    accessibleStatusEl.style.position = \"absolute\";\n    accessibleStatusEl.style.left = \"-9999px\";\n    accessibleStatusEl.style.width = \"1px\";\n    accessibleStatusEl.style.height = \"1px\";\n    container.appendChild(accessibleStatusEl);\n  }\n\n  // Level generation guaranteeing solvable target (subset sum)\n  function generateLevel() {\n    orbs = [];\n    collected = [];\n    // Create orb values\n    for (let i = 0; i < MAX_ORBS; i++) {\n      const v = randRange(1, 9);\n      const x = randRange(60, WIDTH - 60);\n      const y = randRange(80, HEIGHT - 160);\n      const color = ORB_COLORS[i % ORB_COLORS.length];\n      orbs.push({ x, y, origX: x, origY: y, yOffset: 0, value: v, color, r: ORB_RADIUS, collected: false });\n    }\n    // pick random subset to be target\n    const indices = [];\n    for (let i = 0; i < orbs.length; i++) indices.push(i);\n    // shuffle\n    for (let i = indices.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [indices[i], indices[j]] = [indices[j], indices[i]];\n    }\n    const subsetCount = randRange(2, 4);\n    const subset = indices.slice(0, subsetCount);\n    target = subset.reduce((s, idx) => s + orbs[idx].value, 0);\n    // Slightly move orbs if overlap\n    for (let i = 0; i < orbs.length; i++) {\n      for (let j = i + 1; j < orbs.length; j++) {\n        const a = orbs[i], b = orbs[j];\n        const d = dist(a.x, a.y, b.x, b.y);\n        if (d < a.r + b.r + 6) {\n          // push b away\n          const angle = Math.atan2(b.y - a.y, b.x - a.x) || Math.random() * Math.PI * 2;\n          b.x += Math.cos(angle) * (a.r + b.r + 8 - d);\n          b.y += Math.sin(angle) * (a.r + b.r + 8 - d);\n          b.x = clamp(b.x, 60, WIDTH - 60);\n          b.y = clamp(b.y, 80, HEIGHT - 160);\n        }\n      }\n    }\n\n    statusMessage = `Level ${level}: Power the house with ${target} energy. Collect orbs that add to ${target}. Use arrows or WASD to move. Press Backspace to undo last orb. Press M to toggle sound.`;\n    announce(statusMessage);\n    robot.x = WIDTH / 2;\n    robot.y = HEIGHT - 80;\n    sparks = [];\n  }\n\n  // Input handling\n  function setupInput() {\n    window.addEventListener(\"keydown\", (e) => {\n      if (e.repeat) return;\n      keys[e.key.toLowerCase()] = true;\n      // Prevent scrolling with arrows and space/backspace\n      if ([\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\", \" \", \"Backspace\"].includes(e.key)) {\n        e.preventDefault();\n      }\n      // On first user gesture, resume audio context if possible\n      resumeAudioContextIfNeeded();\n\n      if (e.key === \"m\" || e.key === \"M\") {\n        audioEnabled = !audioEnabled;\n        setHumOn(audioEnabled);\n        announce(\"Sound \" + (audioEnabled ? \"on\" : \"off\"));\n      }\n\n      if (gameState === \"title\" && (e.key === \"Enter\" || e.key === \" \")) {\n        startGame();\n      } else if (gameState === \"success\") {\n        if (e.key === \"Enter\" || e.key === \" \") {\n          level++;\n          generateLevel();\n          gameState = \"playing\";\n        }\n      } else if (gameState === \"playing\") {\n        if (e.key === \"Backspace\" || e.key === \"Delete\") {\n          undoLastOrb();\n        } else if (e.key === \"r\" || e.key === \"R\") {\n          level = 1;\n          startGame();\n        }\n      }\n    });\n\n    window.addEventListener(\"keyup\", (e) => {\n      keys[e.key.toLowerCase()] = false;\n    });\n\n    // Canvas focus styling and mouse control\n    canvas.addEventListener(\"click\", (e) => {\n      canvas.focus();\n      resumeAudioContextIfNeeded();\n      // Toggle speaker if click in its area\n      const rect = canvas.getBoundingClientRect();\n      const mx = e.clientX - rect.left;\n      const my = e.clientY - rect.top;\n      if (mx > WIDTH - 60 && my < 40) {\n        audioEnabled = !audioEnabled;\n        setHumOn(audioEnabled);\n        announce(\"Sound \" + (audioEnabled ? \"on\" : \"off\"));\n      } else if (gameState === \"title\") {\n        startGame();\n      } else if (gameState === \"success\") {\n        level++;\n        generateLevel();\n        gameState = \"playing\";\n      }\n    });\n\n    canvas.addEventListener(\"mousemove\", (e) => {\n      const rect = canvas.getBoundingClientRect();\n      const mx = e.clientX - rect.left;\n      const my = e.clientY - rect.top;\n      speakerIconHover = mx > WIDTH - 60 && my < 40;\n    });\n\n    // Touch support: simple joystick by touching left/right halves\n    canvas.addEventListener(\"touchstart\", (e) => {\n      resumeAudioContextIfNeeded();\n      if (e.touches.length > 0) {\n        const t = e.touches[0];\n        const rect = canvas.getBoundingClientRect();\n        const mx = t.clientX - rect.left;\n        const my = t.clientY - rect.top;\n        // If touch near top-right toggle speaker\n        if (mx > WIDTH - 60 && my < 40) {\n          audioEnabled = !audioEnabled;\n          setHumOn(audioEnabled);\n          announce(\"Sound \" + (audioEnabled ? \"on\" : \"off\"));\n        } else {\n          // move robot toward touch location\n          robot.x = clamp(mx, robot.r, WIDTH - robot.r);\n          robot.y = clamp(my, robot.r, HEIGHT - robot.r);\n        }\n      }\n    });\n  }\n\n  // Undo last collected orb\n  function undoLastOrb() {\n    if (collected.length === 0) {\n      statusMessage = \"No orbs to undo.\";\n      announce(statusMessage);\n      playBuzz();\n      return;\n    }\n    const lastIndex = collected.pop();\n    const orb = orbs[lastIndex];\n    orb.collected = false;\n    orb.x = orb.origX;\n    orb.y = orb.origY;\n    statusMessage = `Removed orb ${orb.value}. Current total: ${getCollectedSum()}.`;\n    announce(statusMessage);\n    playBeep(240, 0.12, \"sine\", 0.06);\n  }\n\n  function getCollectedSum() {\n    return collected.reduce((s, idx) => s + orbs[idx].value, 0);\n  }\n\n  // Collect orb when robot touches\n  function tryCollectOrb(idx) {\n    const orb = orbs[idx];\n    if (orb.collected) return;\n    orb.collected = true;\n    collected.push(idx);\n    // animate orb moving near robot by setting original coords\n    playBeep(420 + orb.value * 20, 0.12, \"sine\", 0.06);\n    // create sparks\n    for (let i = 0; i < 8; i++) {\n      sparks.push({\n        x: orb.x,\n        y: orb.y,\n        vx: (Math.random() - 0.5) * 80,\n        vy: (Math.random() - 0.5) * 80,\n        life: 0.6 + Math.random() * 0.6,\n        color: orb.color,\n      });\n    }\n    const sum = getCollectedSum();\n    statusMessage = `Picked ${orb.value}. Current total: ${sum}.`;\n    announce(statusMessage);\n    // Check win or over\n    if (sum === target) {\n      // success\n      playChime();\n      gameState = \"success\";\n      statusMessage = `Great! You powered the house with exactly ${target} energy! Press Enter to continue.`;\n      announce(statusMessage);\n    } else if (sum > target) {\n      // overshoot\n      playBuzz();\n      statusMessage = `Too much energy! You have ${sum}, target is ${target}. Undo the last orb with Backspace.`;\n      announce(statusMessage);\n      // visual shake\n      shakeScreen = 8;\n    }\n  }\n\n  // Draw helpers\n  function clearScreen() {\n    ctx.fillStyle = BG_COLOR;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n  }\n\n  function drawHeader() {\n    ctx.fillStyle = \"#073b4c\";\n    ctx.font = TITLE_FONT;\n    ctx.textAlign = \"left\";\n    ctx.fillText(\"Sparky Circuit: Add the Energy!\", 18, 36);\n\n    // Speaker icon\n    const sx = WIDTH - 46;\n    const sy = 8;\n    // background circle\n    ctx.beginPath();\n    ctx.fillStyle = speakerIconHover ? \"#ffd166\" : \"#ffffff\";\n    ctx.fillRect(sx - 6, sy - 6, 48, 32);\n    // draw speaker\n    ctx.fillStyle = audioAvailable ? (audioEnabled ? \"#06D6A0\" : \"#EF476F\") : \"#999\";\n    // speaker box\n    ctx.fillRect(sx, sy + 6, 12, 16);\n    // triangle\n    ctx.beginPath();\n    ctx.moveTo(sx + 12, sy + 6);\n    ctx.lineTo(sx + 28, sy + 2);\n    ctx.lineTo(sx + 28, sy + 30);\n    ctx.lineTo(sx + 12, sy + 26);\n    ctx.closePath();\n    ctx.fill();\n\n    // cross if audio not available\n    if (!audioAvailable) {\n      ctx.strokeStyle = \"#555\";\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(sx + 4, sy + 8);\n      ctx.lineTo(sx + 36, sy + 28);\n      ctx.moveTo(sx + 36, sy + 8);\n      ctx.lineTo(sx + 4, sy + 28);\n      ctx.stroke();\n    }\n\n    // small controls hint\n    ctx.font = SMALL_FONT;\n    ctx.fillStyle = \"#073b4c\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(\"Use arrows/WASD to move \u2022 Backspace to undo \u2022 M toggles sound\", 18, 60);\n  }\n\n  function drawHouse() {\n    // House needs power target shown\n    const hx = 80;\n    const hy = 130;\n    const hw = 120;\n    const hh = 100;\n    // house body\n    ctx.fillStyle = \"#FFE8A1\";\n    ctx.fillRect(hx, hy, hw, hh);\n    // roof\n    ctx.beginPath();\n    ctx.moveTo(hx - 10, hy);\n    ctx.lineTo(hx + hw / 2, hy - 40);\n    ctx.lineTo(hx + hw + 10, hy);\n    ctx.closePath();\n    ctx.fillStyle = \"#ef476f\";\n    ctx.fill();\n    // door\n    ctx.fillStyle = \"#7C4DFF\";\n    ctx.fillRect(hx + hw / 2 - 14, hy + hh - 36, 28, 36);\n    // windows (eyes)\n    ctx.fillStyle = \"#fff\";\n    ctx.fillRect(hx + 18, hy + 20, 22, 18);\n    ctx.fillRect(hx + hw - 40, hy + 20, 22, 18);\n    // smiling mouth to show happy when powered\n    const sum = getCollectedSum();\n    ctx.beginPath();\n    ctx.strokeStyle = sum === target && sum > 0 ? \"#06D6A0\" : \"#073b4c\";\n    ctx.lineWidth = 3;\n    ctx.arc(hx + hw / 2, hy + hh / 2 + 10, 20, 0, Math.PI, false);\n    ctx.stroke();\n    // target label\n    ctx.font = FONT;\n    ctx.fillStyle = \"#073b4c\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(\"House needs:\", hx, hy + hh + 30);\n    ctx.font = \"22px Georgia\";\n    ctx.fillStyle = \"#ef476f\";\n    ctx.fillText(target + \" energy\", hx + 110, hy + hh + 30);\n  }\n\n  // Draw robot character 'Volt'\n  function drawRobot() {\n    // body\n    ctx.save();\n    ctx.translate(robot.x, robot.y);\n    // shadow\n    ctx.beginPath();\n    ctx.fillStyle = \"rgba(0,0,0,0.08)\";\n    ctx.ellipse(0, robot.r + 18, robot.r + 12, 8, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // body circle\n    ctx.beginPath();\n    ctx.fillStyle = \"#06B6D4\";\n    ctx.arc(0, 0, robot.r, 0, Math.PI * 2);\n    ctx.fill();\n\n    // face\n    ctx.fillStyle = \"#ffffff\";\n    ctx.fillRect(-12, -8, 24, 12);\n    ctx.fillStyle = \"#073b4c\";\n    ctx.fillRect(-6, -6, 4, 6);\n    ctx.fillRect(2, -6, 4, 6);\n    // smile\n    ctx.beginPath();\n    ctx.strokeStyle = \"#073b4c\";\n    ctx.lineWidth = 2;\n    ctx.arc(0, 2, 8, 0, Math.PI, false);\n    ctx.stroke();\n\n    // antenna\n    ctx.beginPath();\n    ctx.strokeStyle = \"#ffd166\";\n    ctx.lineWidth = 4;\n    ctx.moveTo(12, -robot.r + 4);\n    ctx.lineTo(18, -robot.r - 18);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.fillStyle = \"#ffd166\";\n    ctx.arc(18, -robot.r - 18, 5, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  // Draw orbs (collected ones fade/float near top right)\n  function drawOrbs(delta) {\n    // animate y offset for orbs\n    for (let i = 0; i < orbs.length; i++) {\n      const o = orbs[i];\n      if (!o.collected) {\n        o.yOffset = Math.sin((Date.now() / 800) + i) * 4;\n        // jitter a little\n      } else {\n        // animate collected orb to the top-right HUD region\n        const idxInCollected = collected.indexOf(i);\n        const vxTarget = WIDTH - 200 + idxInCollected * 36;\n        const vyTarget = 92;\n        // approach target location\n        o.x += (vxTarget - o.x) * 6 * delta;\n        o.y += (vyTarget - o.y) * 6 * delta;\n      }\n    }\n\n    // draw orbs\n    for (let i = 0; i < orbs.length; i++) {\n      const o = orbs[i];\n      ctx.beginPath();\n      ctx.fillStyle = o.color;\n      ctx.strokeStyle = \"#073b4c\";\n      ctx.lineWidth = 2;\n      ctx.arc(o.x, o.y + o.yOffset, o.r, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n      ctx.fillStyle = \"#073b4c\";\n      ctx.font = \"bold 18px Georgia\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(String(o.value), o.x, o.y + o.yOffset + 6);\n      if (!o.collected) {\n        // little electric halo\n        ctx.beginPath();\n        ctx.strokeStyle = \"rgba(6,214,160,0.06)\";\n        ctx.lineWidth = 6;\n        ctx.arc(o.x, o.y + o.yOffset, o.r + 8, 0, Math.PI * 2);\n        ctx.stroke();\n      }\n    }\n  }\n\n  // Draw HUD showing collected sum and collected orbs icons\n  function drawHUD() {\n    ctx.textAlign = \"left\";\n    ctx.font = \"18px Georgia\";\n    ctx.fillStyle = \"#073b4c\";\n    ctx.fillText(\"Collected total: \" + getCollectedSum(), WIDTH - 260, 84);\n\n    // drawn small slot for each collected orb\n    for (let i = 0; i < collected.length; i++) {\n      const idx = collected[i];\n      const ox = WIDTH - 200 + i * 36;\n      const oy = 92;\n      ctx.beginPath();\n      ctx.fillStyle = orbs[idx].color;\n      ctx.strokeStyle = \"#073b4c\";\n      ctx.arc(ox, oy, 14, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n      ctx.fillStyle = \"#073b4c\";\n      ctx.font = \"bold 14px Georgia\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(String(orbs[idx].value), ox, oy + 5);\n    }\n  }\n\n  // Draw recycle bin\n  function drawBin() {\n    const bx = WIDTH - 80;\n    const by = HEIGHT - 72;\n    // bin box\n    ctx.fillStyle = \"#b8bedd\";\n    ctx.fillRect(bx - 28, by - 10, 56, 48);\n    // lid\n    ctx.fillStyle = \"#9aa0b4\";\n    ctx.fillRect(bx - 34, by - 22, 68, 12);\n    // label\n    ctx.fillStyle = \"#073b4c\";\n    ctx.font = \"12px Georgia\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"Recycle\", bx, by + 44);\n    // hint\n    ctx.font = \"12px Georgia\";\n    ctx.fillText(\"Backspace to undo\", bx, by + 58);\n  }\n\n  // Sparks particles\n  function updateSparks(delta) {\n    for (let i = sparks.length - 1; i >= 0; i--) {\n      const s = sparks[i];\n      s.life -= delta;\n      if (s.life <= 0) {\n        sparks.splice(i, 1);\n        continue;\n      }\n      s.x += s.vx * delta;\n      s.y += s.vy * delta;\n      s.vy += 80 * delta; // gravity-ish\n    }\n  }\n\n  function drawSparks() {\n    for (const s of sparks) {\n      ctx.beginPath();\n      ctx.fillStyle = s.color;\n      ctx.globalAlpha = Math.max(0.12, s.life);\n      ctx.arc(s.x, s.y, 3 + Math.random() * 3, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.globalAlpha = 1;\n    }\n  }\n\n  // Main update/draw loop\n  let shakeScreen = 0;\n  function gameLoop(ts) {\n    if (!lastTime) lastTime = ts;\n    const delta = Math.min(0.05, (ts - lastTime) / 1000);\n    lastTime = ts;\n\n    // Update\n    if (gameState === \"playing\") {\n      // movement\n      let moveX = 0,\n        moveY = 0;\n      if (keys[\"arrowleft\"] || keys[\"a\"]) moveX -= 1;\n      if (keys[\"arrowright\"] || keys[\"d\"]) moveX += 1;\n      if (keys[\"arrowup\"] || keys[\"w\"]) moveY -= 1;\n      if (keys[\"arrowdown\"] || keys[\"s\"]) moveY += 1;\n      const len = Math.hypot(moveX, moveY) || 1;\n      robot.x += (moveX / len) * ROBOT_SPEED * delta;\n      robot.y += (moveY / len) * ROBOT_SPEED * delta;\n      robot.x = clamp(robot.x, robot.r, WIDTH - robot.r);\n      robot.y = clamp(robot.y, robot.r, HEIGHT - robot.r);\n\n      // Check collisions with orbs\n      for (let i = 0; i < orbs.length; i++) {\n        const o = orbs[i];\n        if (!o.collected) {\n          if (dist(robot.x, robot.y, o.x, o.y + o.yOffset) < robot.r + o.r - 4) {\n            tryCollectOrb(i);\n          }\n        }\n      }\n\n      // Check if robot over recycle bin and hitting backspace\n      // (Alternate: pressing backspace triggers undo regardless of location)\n      updateSparks(delta);\n    }\n\n    // Draw\n    clearScreen();\n\n    // optional screen shake\n    ctx.save();\n    if (shakeScreen > 0) {\n      const sx = (Math.random() - 0.5) * shakeScreen;\n      const sy = (Math.random() - 0.5) * shakeScreen;\n      ctx.translate(sx, sy);\n      shakeScreen -= 0.3;\n    }\n\n    drawHeader();\n    drawHouse();\n    drawOrbs(delta);\n    drawBin();\n    drawRobot();\n    drawSparks();\n    drawHUD();\n\n    // bottom instructions / status message\n    ctx.fillStyle = \"#073b4c\";\n    ctx.font = FONT;\n    ctx.textAlign = \"left\";\n    ctx.fillText(statusMessage, 18, HEIGHT - 18);\n\n    ctx.restore();\n\n    // Title / success overlays\n    if (gameState === \"title\") {\n      ctx.fillStyle = \"rgba(3,59,76,0.7)\";\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n      ctx.fillStyle = \"#fff\";\n      ctx.font = \"34px Georgia\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(\"Spark & Volt\", WIDTH / 2, HEIGHT / 2 - 40);\n      ctx.font = \"18px Georgia\";\n      ctx.fillText(\"Help Volt collect orbs that add up to power the house!\", WIDTH / 2, HEIGHT / 2 - 8);\n      ctx.fillStyle = \"#ffd166\";\n      ctx.fillRect(WIDTH / 2 - 90, HEIGHT / 2 + 18, 180, 42);\n      ctx.fillStyle = \"#073b4c\";\n      ctx.font = \"20px Georgia\";\n      ctx.fillText(\"Start Game\", WIDTH / 2, HEIGHT / 2 + 48);\n      ctx.font = \"14px Georgia\";\n      ctx.fillStyle = \"#fff\";\n      ctx.fillText(\"Press Enter or click to begin\", WIDTH / 2, HEIGHT / 2 + 78);\n    } else if (gameState === \"success\") {\n      ctx.fillStyle = \"rgba(6,214,160,0.08)\";\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n      ctx.fillStyle = \"#073b4c\";\n      ctx.font = \"28px Georgia\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(\"Great job!\", WIDTH / 2, HEIGHT / 2 - 16);\n      ctx.font = \"18px Georgia\";\n      ctx.fillText(`You powered the house with ${target} energy!`, WIDTH / 2, HEIGHT / 2 + 12);\n      ctx.fillStyle = \"#ffd166\";\n      ctx.fillRect(WIDTH / 2 - 120, HEIGHT / 2 + 28, 240, 42);\n      ctx.fillStyle = \"#073b4c\";\n      ctx.font = \"20px Georgia\";\n      ctx.fillText(\"Next Level\", WIDTH / 2, HEIGHT / 2 + 58);\n      ctx.font = \"14px Georgia\";\n      ctx.fillStyle = \"#073b4c\";\n      ctx.fillText(\"Press Enter or click to play the next level\", WIDTH / 2, HEIGHT / 2 + 88);\n    }\n\n    rafId = requestAnimationFrame(gameLoop);\n  }\n\n  function startGame() {\n    // ensure audio context exists (but may be suspended until user gesture)\n    if (!audioCtx) initAudio();\n    resumeAudioContextIfNeeded();\n    level = 1;\n    generateLevel();\n    gameState = \"playing\";\n    announce(statusMessage);\n  }\n\n  // Initialize and start\n  function init() {\n    initDOM();\n    initAudio();\n    setupInput();\n    // initial screen\n    statusMessage = \"Press Enter or click to start. Help Volt (the friendly robot) collect energy orbs to power the house.\";\n    announce(statusMessage);\n    gameState = \"title\";\n    lastTime = 0;\n    if (rafId) cancelAnimationFrame(rafId);\n    rafId = requestAnimationFrame(gameLoop);\n  }\n\n  // Start\n  try {\n    init();\n  } catch (err) {\n    console.error(\"Game initialization error:\", err);\n    // If critical error, show fallback message in container\n    if (container) {\n      container.innerHTML = \"\";\n      const message = document.createElement(\"div\");\n      message.style.width = WIDTH + \"px\";\n      message.style.height = HEIGHT + \"px\";\n      message.style.display = \"flex\";\n      message.style.alignItems = \"center\";\n      message.style.justifyContent = \"center\";\n      message.style.background = \"#fff3cd\";\n      message.style.color = \"#856404\";\n      message.textContent = \"An error occurred while loading the game. Please try refreshing the page.\";\n      container.appendChild(message);\n    }\n  }\n})();\n---\n",
  "improve_response_tokens": 18875,
  "formatted_code": true,
  "formatting_response_tokens": 21926,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}