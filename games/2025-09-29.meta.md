# Game of the Day - 2025-09-29

## Metadata
- **Generated Date:** 2025-09-29
- **Generated Time:** 2025-09-29T00:27:42.027199
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-29.js
- **File Size:** 28562 bytes
- **Tokens Used:** 9414

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-29.js` - The playable game
- `2025-09-29.meta.json` - Machine-readable metadata
- `2025-09-29.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 19150

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 20642

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Machine Math Game for ages 7-9
  // Renders inside element with ID "game-of-the-day-stage"
  // Canvas-based graphics and Web Audio API sounds (no external resources)
  "use strict";

  // --- Configuration ---
  const WIDTH = 720;
  const HEIGHT = 480;
  const STAGE_ID = "game-of-the-day-stage";
  const MAX_LEVELS = 5;

  // Levels: each has number of dials and target sum (constructed to be solvable)
  const LEVELS = [
    { dials: 2, target: 7 }, // e.g., 2 dials, sum 7
    { dials: 2, target: 11 },
    { dials: 3, target: 12 },
    { dials: 3, target: 18 },
    { dials: 4, target: 20 }
  ].slice(0, MAX_LEVELS);

  // --- DOM Setup ---
  const root = document.getElementById(STAGE_ID);
  if (!root) {
    // If the stage element is missing, stop gracefully
    console.error(`Element with ID "${STAGE_ID}" not found.`);
    return;
  }
  // Clear any existing children
  while (root.firstChild) root.removeChild(root.firstChild);

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute("role", "img");
  canvas.setAttribute("aria-label", "Machine Math Game canvas");
  canvas.style.width = WIDTH + "px";
  canvas.style.height = HEIGHT + "px";
  canvas.tabIndex = 0; // for keyboard focus
  root.appendChild(canvas);
  const ctx = canvas.getContext("2d", { alpha: false });

  // Create accessible live region for screen reader updates
  const liveRegion = document.createElement("div");
  liveRegion.setAttribute("aria-live", "polite");
  liveRegion.style.position = "absolute";
  liveRegion.style.left = "-9999px";
  liveRegion.style.width = "1px";
  liveRegion.style.height = "1px";
  liveRegion.style.overflow = "hidden";
  root.appendChild(liveRegion);

  // Controls container (visible): Start button and audio toggle
  const controls = document.createElement("div");
  controls.style.position = "relative";
  controls.style.width = WIDTH + "px";
  controls.style.marginTop = "6px";
  controls.style.fontFamily = "sans-serif";
  controls.style.fontSize = "14px";
  // Start / Resume button
  const startButton = document.createElement("button");
  startButton.textContent = "Start Game";
  startButton.style.marginRight = "8px";
  startButton.setAttribute("aria-label", "Start the game");
  controls.appendChild(startButton);
  // Audio toggle
  const audioButton = document.createElement("button");
  audioButton.textContent = "Audio: On";
  audioButton.setAttribute("aria-pressed", "true");
  audioButton.style.marginRight = "8px";
  audioButton.setAttribute("aria-label", "Toggle audio on or off");
  controls.appendChild(audioButton);
  // Hint button
  const hintButton = document.createElement("button");
  hintButton.textContent = "Hint";
  hintButton.setAttribute("aria-label", "Show a hint");
  controls.appendChild(hintButton);
  root.appendChild(controls);

  // Instruction text under canvas (visible)
  const instructions = document.createElement("div");
  instructions.style.width = WIDTH + "px";
  instructions.style.marginTop = "8px";
  instructions.style.fontFamily = "sans-serif";
  instructions.style.fontSize = "13px";
  instructions.innerHTML =
    "Use mouse or keyboard. Left/Right to pick a dial, Up/Down to change values. Enter to submit. Space toggles audio. H shows a hint.";
  root.appendChild(instructions);

  // --- Audio Setup ---
  let audioAllowed = true;
  let audioCtx = null;
  let masterGain = null;
  let bgGain = null;
  let bgOsc = null;
  let audioError = false;

  function initAudio() {
    if (!audioAllowed) return;
    if (audioCtx) return;

    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) {
        throw new Error("Web Audio API not supported");
      }
      audioCtx = new AC();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.9;
      masterGain.connect(audioCtx.destination);

      // Gentle background hum with a slow LFO on gain
      bgGain = audioCtx.createGain();
      bgGain.gain.value = 0.04;
      bgGain.connect(masterGain);

      bgOsc = audioCtx.createOscillator();
      bgOsc.type = "sine";
      bgOsc.frequency.value = 110; // low warm tone
      bgOsc.connect(bgGain);
      // Create a slow LFO to modulate bgGain for gentle breathing
      const lfo = audioCtx.createOscillator();
      lfo.type = "sine";
      lfo.frequency.value = 0.25; // slow
      const lfoGain = audioCtx.createGain();
      lfoGain.gain.value = 0.02;
      lfo.connect(lfoGain);
      lfoGain.connect(bgGain.gain);
      lfo.start();
      bgOsc.start();
    } catch (err) {
      console.warn("Audio initialization failed:", err);
      audioError = true;
      audioAllowed = false;
      audioCtx = null;
      masterGain = null;
      bgGain = null;
      bgOsc = null;
      liveRegion.textContent = "Audio is not available on this device.";
    }
  }

  function safeCreateAudioContextOnGesture() {
    // Some browsers require resume on user gesture. Try resuming or creating when user clicks Start.
    try {
      if (!audioCtx && audioAllowed) {
        initAudio();
      } else if (audioCtx && audioCtx.state === "suspended") {
        audioCtx.resume().catch((err) => {
          console.warn("Audio resume failed:", err);
        });
      }
    } catch (err) {
      console.warn("Audio gesture handling error:", err);
    }
  }

  // Play a short tone using oscillator
  function playTone({ freq = 440, type = "sine", duration = 0.25, vol = 0.12, release = 0.04 } = {}) {
    if (!audioAllowed || !audioCtx || audioError) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = 0;
      o.connect(g);
      g.connect(masterGain);
      const now = audioCtx.currentTime;
      // Attack
      g.gain.cancelScheduledValues(now);
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(vol, now + 0.01);
      // Release
      g.gain.linearRampToValueAtTime(0.0001, now + duration + release);
      o.start(now);
      o.stop(now + duration + release + 0.02);
    } catch (err) {
      console.warn("playTone error:", err);
    }
  }

  // Play success chime (ascending arpeggio)
  function playSuccess() {
    if (!audioAllowed || !audioCtx) return;
    const now = audioCtx.currentTime;
    const notes = [440, 550, 660];
    notes.forEach((f, i) => {
      try {
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = "sine";
        o.frequency.value = f;
        g.gain.value = 0;
        o.connect(g);
        g.connect(masterGain);
        const t = now + i * 0.12;
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.14, t + 0.01);
        g.gain.linearRampToValueAtTime(0.0001, t + 0.12);
        o.start(t);
        o.stop(t + 0.2);
      } catch (err) {
        console.warn("playSuccess error:", err);
      }
    });
  }

  function playError() {
    // Low buzz
    playTone({ freq: 120, type: "sawtooth", duration: 0.32, vol: 0.14, release: 0.06 });
    // small click after
    setTimeout(() => {
      playTone({ freq: 880, type: "square", duration: 0.06, vol: 0.05 });
    }, 260);
  }

  function playClick() {
    playTone({ freq: 880, type: "square", duration: 0.06, vol: 0.06 });
  }

  // --- Game State ---
  let state = {
    running: false,
    levelIndex: 0,
    dials: [], // values for current level
    selectedDial: 0,
    attempts: 0,
    solvedLevels: 0,
    showHint: false,
    animT: 0,
    shakeAmount: 0
  };

  function startLevel(index) {
    state.levelIndex = index;
    const level = LEVELS[index];
    state.dials = new Array(level.dials).fill(0).map(() => Math.floor(Math.random() * 10));
    // Ensure solvable: create a solution by adjusting randomly if sum != target, but we want challenge so not pre-solving.
    // However make sure target is reachable with digit limits: adjust target if needed
    // For safety, if target can't be achieved with given dials (target > 9*dials or < 0), adjust target to mid-range
    if (level.target > level.dials * 9 || level.target < 0) {
      level.target = Math.min(level.dials * 9, Math.max(1, Math.floor((level.dials * 9) / 2)));
    }
    state.selectedDial = 0;
    state.attempts = 0;
    state.showHint = false;
    state.animT = 0;
    state.shakeAmount = 0;
    liveRegion.textContent = `Level ${index + 1}. Set the dials to add up to ${level.target}.`;
  }

  // Start game from scratch
  function startGame() {
    state.running = true;
    state.levelIndex = 0;
    state.solvedLevels = 0;
    startLevel(0);
    safeCreateAudioContextOnGesture();
  }

  // Progress to next level, or show end screen
  function nextLevel() {
    state.solvedLevels++;
    if (state.levelIndex + 1 < LEVELS.length) {
      startLevel(state.levelIndex + 1);
    } else {
      // Finished
      state.running = false;
      liveRegion.textContent = "All machines fixed! Great job!";
    }
  }

  // Hint generator: show one dial value that would help
  function getHint() {
    const level = LEVELS[state.levelIndex];
    const curSum = state.dials.reduce((a, b) => a + b, 0);
    const remaining = level.target - curSum;
    if (Math.abs(remaining) <= 9) {
      // Suggest a change to selected dial if feasible
      const needed = state.dials[state.selectedDial] + remaining;
      if (needed >= 0 && needed <= 9) {
        return `Try setting dial ${state.selectedDial + 1} to ${needed}`;
      }
    }
    // Otherwise suggest a small positive adjustment
    return `Try changing a dial by ${remaining > 0 ? "+" : ""}${remaining}`;
  }

  // Submit attempt: checks sum
  function submitAttempt() {
    const level = LEVELS[state.levelIndex];
    const sum = state.dials.reduce((a, b) => a + b, 0);
    state.attempts++;
    if (sum === level.target) {
      // Success animation and sound
      playSuccess();
      state.shakeAmount = 12;
      setTimeout(() => {
        state.shakeAmount = 0;
      }, 320);
      liveRegion.textContent = `Correct! You fixed machine ${state.levelIndex + 1}.`;
      // Move to next level after a short delay
      setTimeout(nextLevel, 800);
    } else {
      // Wrong
      playError();
      state.shakeAmount = 8;
      setTimeout(() => {
        state.shakeAmount = 0;
      }, 420);
      liveRegion.textContent = `Not yet. The sum is ${sum}. Try again.`;
    }
  }

  // --- Input Handling ---
  // Mouse: clicking on dials changes selected or increments
  function getDialHit(x, y) {
    // dials drawn horizontally centered; compute bounding boxes similar to drawDials
    const level = LEVELS[state.levelIndex];
    const count = level.dials;
    const dialSize = 64;
    const spacing = 18;
    const totalW = count * dialSize + (count - 1) * spacing;
    const startX = WIDTH / 2 - totalW / 2;
    const yTop = HEIGHT / 2 - 24;
    for (let i = 0; i < count; i++) {
      const dx = startX + i * (dialSize + spacing);
      const dy = yTop;
      if (x >= dx && x <= dx + dialSize && y >= dy && y <= dy + dialSize) return i;
    }
    return -1;
  }

  canvas.addEventListener("mousedown", (ev) => {
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;
    if (!state.running) {
      // clicking canvas may start audio context but game controlled by Start button
      safeCreateAudioContextOnGesture();
    }
    const dialIdx = getDialHit(x, y);
    if (dialIdx >= 0) {
      state.selectedDial = dialIdx;
      // Left-click increments
      if (ev.button === 0) {
        state.dials[dialIdx] = (state.dials[dialIdx] + 1) % 10;
      } else if (ev.button === 2) {
        // right-click decrements
        state.dials[dialIdx] = (state.dials[dialIdx] + 9) % 10;
      }
      playClick();
    } else {
      // If click on top area where submit button is drawn, maybe commit - allow clicking roughly under machine center
      // We'll detect near the "Submit" machine lever region
      const submitRect = getSubmitRect();
      if (x >= submitRect.x && x <= submitRect.x + submitRect.w && y >= submitRect.y && y <= submitRect.y + submitRect.h) {
        submitAttempt();
      }
    }
  });

  canvas.addEventListener("contextmenu", (ev) => {
    // Prevent default context menu while right-clicking on canvas for decrement
    ev.preventDefault();
  });

  // Keyboard controls
  canvas.addEventListener("keydown", (ev) => {
    if (!state.running && ev.key === "Enter") {
      startButton.focus();
      startButton.click();
      return;
    }
    if (!state.running) {
      // If not running, ignore other keys
      return;
    }
    const level = LEVELS[state.levelIndex];
    if (!level) return;
    if (ev.key === "ArrowLeft") {
      state.selectedDial = (state.selectedDial - 1 + level.dials) % level.dials;
      playClick();
      ev.preventDefault();
    } else if (ev.key === "ArrowRight") {
      state.selectedDial = (state.selectedDial + 1) % level.dials;
      playClick();
      ev.preventDefault();
    } else if (ev.key === "ArrowUp") {
      state.dials[state.selectedDial] = (state.dials[state.selectedDial] + 1) % 10;
      playClick();
      ev.preventDefault();
    } else if (ev.key === "ArrowDown") {
      state.dials[state.selectedDial] = (state.dials[state.selectedDial] + 9) % 10;
      playClick();
      ev.preventDefault();
    } else if (ev.key === "Enter") {
      submitAttempt();
      ev.preventDefault();
    } else if (ev.key === " " || ev.key === "Spacebar") {
      // Toggle audio
      toggleAudio();
      ev.preventDefault();
    } else if (ev.key === "h" || ev.key === "H") {
      state.showHint = !state.showHint;
      liveRegion.textContent = state.showHint ? getHint() : "Hint hidden";
      playClick();
      ev.preventDefault();
    } else if (/^[0-9]$/.test(ev.key)) {
      // number key to set selected dial
      const v = parseInt(ev.key, 10);
      state.dials[state.selectedDial] = v;
      playClick();
      ev.preventDefault();
    }
  });

  // Buttons
  startButton.addEventListener("click", () => {
    safeCreateAudioContextOnGesture();
    if (!state.running) {
      startGame();
      startButton.textContent = "Restart";
      startButton.setAttribute("aria-label", "Restart the game");
      canvas.focus();
    } else {
      // Restart anyway
      startGame();
      canvas.focus();
    }
    playClick();
  });

  audioButton.addEventListener("click", () => {
    toggleAudio();
  });

  hintButton.addEventListener("click", () => {
    if (!state.running) return;
    state.showHint = !state.showHint;
    liveRegion.textContent = state.showHint ? getHint() : "Hint hidden";
    playClick();
  });

  function toggleAudio() {
    audioAllowed = !audioAllowed;
    if (audioAllowed) {
      audioButton.textContent = "Audio: On";
      audioButton.setAttribute("aria-pressed", "true");
      safeCreateAudioContextOnGesture();
    } else {
      audioButton.textContent = "Audio: Off";
      audioButton.setAttribute("aria-pressed", "false");
      if (audioCtx) {
        try {
          audioCtx.suspend();
        } catch (err) {
          console.warn("Error suspending audio context:", err);
        }
      }
    }
  }

  // --- Drawing Utilities ---
  function clear() {
    // Calm light background
    ctx.fillStyle = "#F4F7F8";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
  }

  function drawBackgroundDecor(t) {
    // Wavy pipes and dots - calming pastel colors
    ctx.save();
    // soft gradient
    const g = ctx.createLinearGradient(0, 0, WIDTH, HEIGHT);
    g.addColorStop(0, "#E8F4F8");
    g.addColorStop(1, "#F7FAFD");
    ctx.fillStyle = g;
    ctx.globalAlpha = 1;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Wacky calming clouds
    ctx.globalAlpha = 0.6;
    ctx.fillStyle = "#D6EFF7";
    drawCloud(120, 90, 80, t * 0.02);
    drawCloud(540, 70, 60, t * -0.015);
    drawCloud(400, 140, 70, t * 0.01);
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function drawCloud(cx, cy, r, phase) {
    ctx.beginPath();
    ctx.arc(cx - r * 0.6 + Math.sin(phase) * 3, cy, r * 0.6, 0, Math.PI * 2);
    ctx.arc(cx + Math.cos(phase) * 4, cy - 4, r * 0.7, 0, Math.PI * 2);
    ctx.arc(cx + r * 0.6 + Math.sin(phase * 1.1) * 3, cy + 2, r * 0.55, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawGears(x, y, radius, teeth, rotation, color) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rotation);
    // gear body
    ctx.fillStyle = color || "#C8E7F2";
    ctx.strokeStyle = "#A7D1DE";
    ctx.lineWidth = 2;
    // teeth
    for (let i = 0; i < teeth; i++) {
      const ang = (i / teeth) * Math.PI * 2;
      const innerR = radius * 0.86;
      const outerR = radius * 1.12;
      const x1 = Math.cos(ang) * innerR;
      const y1 = Math.sin(ang) * innerR;
      const x2 = Math.cos(ang) * outerR;
      const y2 = Math.sin(ang) * outerR;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }
    // center circle
    ctx.beginPath();
    ctx.arc(0, 0, radius * 0.72, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    // small center hole
    ctx.beginPath();
    ctx.fillStyle = "#F4F7F8";
    ctx.arc(0, 0, Math.max(6, radius * 0.12), 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawDials(t) {
    const level = LEVELS[state.levelIndex];
    if (!level) return;
    const count = level.dials;
    const dialSize = 64;
    const spacing = 18;
    const totalW = count * dialSize + (count - 1) * spacing;
    const startX = WIDTH / 2 - totalW / 2;
    const yTop = HEIGHT / 2 - 24;
    // Draw machine body behind dials
    ctx.save();
    // Apply shake for wrong attempts
    if (state.shakeAmount) {
      const s = state.shakeAmount;
      const dx = (Math.random() - 0.5) * s;
      const dy = (Math.random() - 0.5) * s;
      ctx.translate(dx, dy);
    }
    ctx.fillStyle = "#E6F7FF";
    roundRect(ctx, startX - 28, yTop - 40, totalW + 56, 180, 18);
    ctx.fill();
    ctx.strokeStyle = "#C6E9F7";
    ctx.lineWidth = 2;
    ctx.stroke();

    // dials themselves
    for (let i = 0; i < count; i++) {
      const dx = startX + i * (dialSize + spacing);
      const dy = yTop;
      // dial background
      ctx.save();
      ctx.fillStyle = "#FFFFFF";
      roundRect(ctx, dx, dy, dialSize, dialSize, 12);
      ctx.fill();
      ctx.strokeStyle = i === state.selectedDial ? "#FFB347" : "#C0D9E3";
      ctx.lineWidth = i === state.selectedDial ? 4 : 2;
      ctx.stroke();
      // little gear icon on dial
      drawGears(dx + dialSize - 22, dy + 22, 12, 8, t * 0.004 * (i + 1), "#E0F3FA");
      // number
      ctx.fillStyle = "#1B3A47";
      ctx.font = "bold 28px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(state.dials[i].toString(), dx + dialSize / 2, dy + dialSize / 2 - 6);
      // up arrow
      ctx.beginPath();
      ctx.fillStyle = "#90C7D8";
      ctx.moveTo(dx + dialSize / 2, dy - 6);
      ctx.lineTo(dx + dialSize / 2 - 10, dy + 8);
      ctx.lineTo(dx + dialSize / 2 + 10, dy + 8);
      ctx.closePath();
      ctx.fill();
      // down arrow
      ctx.beginPath();
      ctx.fillStyle = "#90C7D8";
      ctx.moveTo(dx + dialSize / 2, dy + dialSize + 6);
      ctx.lineTo(dx + dialSize / 2 - 10, dy + dialSize - 8);
      ctx.lineTo(dx + dialSize / 2 + 10, dy + dialSize - 8);
      ctx.closePath();
      ctx.fill();

      // Outline if selected
      if (i === state.selectedDial) {
        ctx.strokeStyle = "#FFB347";
        ctx.lineWidth = 2;
        ctx.strokeRect(dx - 6, dy - 6, dialSize + 12, dialSize + 12);
      }
      ctx.restore();
    }

    // Submit lever / big button
    const submitRect = getSubmitRect();
    ctx.save();
    // lever base
    ctx.fillStyle = "#B6E1F0";
    roundRect(ctx, submitRect.x - 12, submitRect.y - 6, submitRect.w + 24, submitRect.h + 12, 8);
    ctx.fill();
    ctx.strokeStyle = "#96C9DB";
    ctx.stroke();

    // lever knob (wacky)
    ctx.fillStyle = "#FFD29B";
    ctx.beginPath();
    ctx.ellipse(submitRect.x + submitRect.w / 2, submitRect.y + submitRect.h / 2, submitRect.w / 2 - 6, submitRect.h / 2 - 10, Math.sin(t * 0.01) * 0.02, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "#FFAB63";
    ctx.stroke();
    // label
    ctx.fillStyle = "#2B4B57";
    ctx.font = "bold 16px sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("Submit", submitRect.x + submitRect.w / 2, submitRect.y + submitRect.h / 2);
    ctx.restore();
    ctx.restore();
  }

  function getSubmitRect() {
    // place below dials
    const level = LEVELS[state.levelIndex];
    const count = level.dials;
    const dialSize = 64;
    const spacing = 18;
    const totalW = count * dialSize + (count - 1) * spacing;
    const startX = WIDTH / 2 - totalW / 2;
    const x = WIDTH / 2 - 64;
    const y = HEIGHT / 2 + 72;
    return { x: x, y: y, w: 128, h: 36 };
  }

  function drawTarget(t) {
    const level = LEVELS[state.levelIndex];
    if (!level) {
      ctx.fillStyle = "#333";
      ctx.font = "20px sans-serif";
      ctx.fillText("Press Start to play", WIDTH / 2 - 80, HEIGHT / 2);
      return;
    }
    // draw big target number at top-left of machine
    ctx.save();
    const tx = WIDTH / 2;
    const ty = HEIGHT / 2 - 120;
    // friendly little screen
    ctx.fillStyle = "#1B5165";
    ctx.beginPath();
    roundRect(ctx, tx - 160, ty - 28, 320, 44, 10);
    ctx.fill();
    ctx.fillStyle = "#E8FBFF";
    ctx.font = "bold 20px sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(`Goal: ${level.target}`, tx, ty - 6);
    // small helper text
    ctx.font = "13px sans-serif";
    ctx.fillStyle = "#CFF2FA";
    ctx.fillText("Make the dials add up to the Goal", tx, ty + 14);
    ctx.restore();
  }

  function drawMeter() {
    // attempts and progress
    ctx.save();
    ctx.fillStyle = "#2B5663";
    ctx.font = "14px sans-serif";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    const level = LEVELS[state.levelIndex];
    if (state.running && level) {
      ctx.fillText(`Level ${state.levelIndex + 1} of ${LEVELS.length}`, 12, 8);
      ctx.fillText(`Attempts: ${state.attempts}`, 12, 28);
    } else {
      ctx.fillText(`Machine Workshop`, 12, 8);
      ctx.fillText(`Click Start to begin`, 12, 28);
    }
    ctx.restore();
  }

  function drawAudioIndicator() {
    ctx.save();
    ctx.textAlign = "right";
    ctx.textBaseline = "top";
    ctx.fillStyle = "#2B5165";
    ctx.font = "13px sans-serif";
    ctx.fillText(`Audio: ${audioAllowed && !audioError ? "On" : "Off"}`, WIDTH - 12, 8);
    // visual speaker icon
    const x = WIDTH - 85;
    const y = 10;
    ctx.strokeStyle = "#2B5165";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x + 2, y + 8);
    ctx.lineTo(x + 8, y + 8);
    ctx.lineTo(x + 12, y + 4);
    ctx.lineTo(x + 12, y + 12);
    ctx.closePath();
    ctx.stroke();
    if (audioAllowed && !audioError) {
      ctx.beginPath();
      ctx.arc(x + 16, y + 8, 6, -0.6, 0.6);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawHintBox() {
    if (!state.showHint || !state.running) return;
    ctx.save();
    const w = 380;
    const h = 60;
    const x = WIDTH - w - 16;
    const y = HEIGHT - h - 16;
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    roundRect(ctx, x, y, w, h, 12);
    ctx.fill();
    ctx.strokeStyle = "#CDEFF7";
    ctx.stroke();
    ctx.fillStyle = "#075B6E";
    ctx.font = "14px sans-serif";
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    ctx.fillText("Hint: " + getHint(), x + 16, y + h / 2);
    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }

  // --- Game Loop ---
  let lastTime = performance.now();

  function updateAndDraw(now) {
    const dt = (now - lastTime) / 1000;
    lastTime = now;
    clear();
    state.animT += dt * 1000;

    drawBackgroundDecor(state.animT);

    if (!state.running) {
      // Idle screen - show machine silhouette and friendly invitation
      drawIdleScene(state.animT);
    } else {
      // Draw machine and dials
      drawTarget(state.animT);
      drawDials(state.animT);
      drawHintBox();
    }

    drawMeter();
    drawAudioIndicator();

    // Subtle bouncing bolts as decoration (wacky elements)
    drawBolts(state.animT);

    requestAnimationFrame(updateAndDraw);
  }

  function drawIdleScene(t) {
    ctx.save();
    // Big happy machine - wacky and calming
    const cx = WIDTH / 2;
    const cy = HEIGHT / 2;
    // main body
    ctx.fillStyle = "#EAF9FB";
    roundRect(ctx, cx - 210, cy - 100, 420, 200, 24);
    ctx.fill();
    ctx.strokeStyle = "#BFE8F2";
    ctx.stroke();

    // Central gear
    drawGears(cx, cy - 10, 72, 12, t * 0.0011, "#D6F1F6");
    // small displays
    ctx.fillStyle = "#1B5165";
    ctx.font = "bold 22px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("Machine Math", cx, cy + 110);
    ctx.fillStyle = "#2B5165";
    ctx.font = "14px sans-serif";
    ctx.fillText("Fix the machines by adding the dials. Click Start!", cx, cy + 136);
    ctx.restore();
  }

  function drawBolts(t) {
    // Decorative bolts that float down near left side - wacky friendly sparks
    ctx.save();
    for (let i = 0; i < 8; i++) {
      const x = 24 + ((i * 97) % 440);
      const y = ((t * 0.03 + i * 57) % HEIGHT) - 80;
      ctx.fillStyle = i % 2 === 0 ? "#FFD27F" : "#FAF2D2";
      ctx.beginPath();
      // simple bolt shape
      ctx.moveTo(x, y);
      ctx.lineTo(x + 8, y + 18);
      ctx.lineTo(x + 2, y + 18);
      ctx.lineTo(x + 12, y + 36);
      ctx.lineTo(x - 4, y + 24);
      ctx.lineTo(x + 4, y + 24);
      ctx.closePath();
      ctx.globalAlpha = 0.9 - i * 0.08;
      ctx.fill();
    }
    ctx.restore();
  }

  // Start animation loop
  requestAnimationFrame(updateAndDraw);

  // Accessibility: focus canvas for keyboard after clicking start
  canvas.addEventListener("focus", () => {
    // Announce current state
    if (!state.running) {
      liveRegion.textContent = "Press Start to begin the Machine Math game.";
    } else {
      liveRegion.textContent = `Level ${state.levelIndex + 1}. Goal ${LEVELS[state.levelIndex].target}. Use arrow keys to change dials.`;
    }
  });

  // Ensure Start button focuses canvas when starting
  startButton.addEventListener("keyup", (ev) => {
    if (ev.key === "Enter" || ev.key === " ") {
      canvas.focus();
    }
  });

  // Initialize start state text
  liveRegion.textContent = "Welcome to Machine Math. Click Start to begin. Use keyboard or mouse.";

  // Error handling for audio context creation upon user gesture if blocked
  window.addEventListener("unhandledrejection", (e) => {
    console.warn("Unhandled promise rejection:", e.reason);
  });

  // Ensure audio is initialized on first user interaction with control buttons
  function attachOneTimeAudioInit() {
    const handler = () => {
      safeCreateAudioContextOnGesture();
      document.removeEventListener("pointerdown", handler);
      document.removeEventListener("keydown", handler);
    };
    document.addEventListener("pointerdown", handler, { passive: true });
    document.addEventListener("keydown", handler, { passive: true });
  }
  attachOneTimeAudioInit();

  // Make sure to handle window blur/resume for audio if available
  window.addEventListener("blur", () => {
    if (audioCtx && audioCtx.state === "running") {
      try {
        audioCtx.suspend();
      } catch (err) {
        // ignore
      }
    }
  });
  window.addEventListener("focus", () => {
    if (audioAllowed && audioCtx && audioCtx.state === "suspended") {
      try {
        audioCtx.resume();
      } catch (err) {
        // ignore
      }
    }
  });

  // Provide a safe public API on the canvas element for testing / accessibility
  canvas.gameAPI = {
    startGame,
    toggleAudio,
    submitAttempt,
    getState: () => JSON.parse(JSON.stringify(state)),
    levels: LEVELS
  };

  // Final note in console for debugging (not required)
  console.log("Machine Math Game initialized inside #" + STAGE_ID);
})();
---

