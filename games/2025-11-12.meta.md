# Game of the Day - 2025-11-12

## Metadata
- **Generated Date:** 2025-11-12
- **Generated Time:** 2025-11-12T00:28:08.173533
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-11-12.js
- **File Size:** 30262 bytes
- **Tokens Used:** 10465

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-11-12.js` - The playable game
- `2025-11-12.meta.json` - Machine-readable metadata
- `2025-11-12.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 20101

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 21135

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function() {
  // Drone Math Game (for ages 7-9)
  // Renders inside element with ID 'game-of-the-day-stage'.
  // All visuals drawn on canvas (720x480). Sounds generated with Web Audio API.
  // Win: score reaches GOAL. Lose: lives <= 0.
  // Keyboard controls (arrows/WASD), number keys 1-3 to choose answers, M to mute, Enter to restart.

  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const GOAL = 10; // number of correct answers to win
  const MAX_WRONG = 3; // lives
  const TOP_PADDING = 12; // spacing for UI
  const UI_TEXT_MIN = 14; // minimum body text size
  const UI_IMPORTANT = 20; // important info size
  const FONT_FAMILY = 'Arial, sans-serif';

  // Find container
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error("Game container with ID 'game-of-the-day-stage' not found.");
    return;
  }

  // Clear and create canvas
  container.innerHTML = '';
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute('role', 'img');
  canvas.setAttribute('aria-label', 'Drone math game: move the drone to the bubble with the correct answer. Arrow keys or WASD move. Press M to mute. Press Enter to restart.');
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Audio setup with error handling
  let audioContext = null;
  let audioAllowed = true;
  try {
    // Some browsers require user gesture; creation may throw in older contexts
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    // create a low-volume ambient background oscillator
    const ambientGain = audioContext.createGain();
    ambientGain.gain.value = 0.03;
    ambientGain.connect(audioContext.destination);

    const ambientOsc = audioContext.createOscillator();
    ambientOsc.type = 'sine';
    ambientOsc.frequency.value = 110; // low hum
    const ambientFilter = audioContext.createBiquadFilter();
    ambientFilter.type = 'lowpass';
    ambientFilter.frequency.value = 300;
    ambientOsc.connect(ambientFilter);
    ambientFilter.connect(ambientGain);
    ambientOsc.start();
  } catch (err) {
    console.warn('Audio context could not be created or is blocked. Game will run without sound.', err);
    audioContext = null;
    audioAllowed = false;
  }

  // Helper to play a short tone for correct/incorrect/button. Uses AudioContext safely.
  function playTone({ type = 'click', duration = 0.25, freq = 440, volume = 0.15 } = {}) {
    if (!audioContext) return;
    try {
      const now = audioContext.currentTime;
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      const filter = audioContext.createBiquadFilter();

      // Configure by type
      if (type === 'correct') {
        osc.type = 'sine';
        freq = freq || 880;
        filter.type = 'highpass';
        filter.frequency.value = 300;
        gain.gain.value = volume;
      } else if (type === 'wrong') {
        osc.type = 'square';
        freq = freq || 220;
        filter.type = 'lowpass';
        filter.frequency.value = 800;
        gain.gain.value = volume * 0.9;
      } else if (type === 'click') {
        osc.type = 'triangle';
        freq = freq || 600;
        filter.type = 'bandpass';
        filter.frequency.value = 600;
        gain.gain.value = volume * 0.6;
      } else {
        osc.type = 'sine';
        filter.type = 'lowpass';
        filter.frequency.value = 1200;
        gain.gain.value = volume;
      }

      osc.frequency.setValueAtTime(freq, now);
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(gain.gain.value, now + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);

      osc.connect(filter);
      filter.connect(gain);
      gain.connect(audioContext.destination);

      osc.start(now);
      osc.stop(now + duration + 0.05);
    } catch (err) {
      console.warn('Error playing sound:', err);
    }
  }

  // Game state
  let state = {
    score: 0,
    wrong: 0,
    goal: GOAL,
    lives: MAX_WRONG,
    running: true, // false when paused on end screens
    currentQuestion: null,
    choices: [], // objects {value, x, y, r}
    drone: {
      x: WIDTH / 2,
      y: HEIGHT / 2 + 30,
      vx: 0,
      vy: 0,
      speed: 2.4,
      radius: 18,
      rotorPhase: 0
    },
    keys: {},
    hoverIndex: -1,
    muted: !audioAllowed, // if audio disabled at start, set muted true
    showMessage: '', // temporary instructional messages
    lastActionTime: 0,
    floating: [], // for decorative floating shapes
    gameOverReason: null // 'win' or 'lose'
  };

  // Utility: clamp
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  // Generate math question appropriate for ages 7-9
  function generateQuestion() {
    // Randomly pick op: +, -, sometimes * (small)
    const ops = ['+', '-', '*'];
    let op = Math.random() < 0.75 ? (Math.random() < 0.5 ? '+' : '-') : '*';
    if (Math.random() < 0.05) op = '*'; // keep multiplication rare

    let a, b;
    if (op === '+') {
      a = Math.floor(Math.random() * 20) + 1; // 1..20
      b = Math.floor(Math.random() * 20) + 1;
    } else if (op === '-') {
      a = Math.floor(Math.random() * 20) + 5; // ensure positive
      b = Math.floor(Math.random() * (a - 1)) + 1;
    } else {
      a = Math.floor(Math.random() * 6) + 1; // 1..6
      b = Math.floor(Math.random() * 6) + 1;
    }
    const correct = op === '+' ? a + b : op === '-' ? a - b : a * b;
    // generate two distractors not equal to correct
    const choices = new Set([correct]);
    while (choices.size < 3) {
      const variance = Math.max(1, Math.floor(Math.random() * 6));
      const sign = Math.random() < 0.5 ? -1 : 1;
      let candidate = correct + sign * variance;
      if (candidate < 0) candidate = Math.abs(candidate) + 1;
      choices.add(candidate);
    }
    const arr = Array.from(choices);
    // shuffle
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }

    return {
      a, b, op, correct, choices: arr
    };
  }

  // Initialize floating decorative shapes (wacky and calming)
  function initFloating() {
    state.floating = [];
    for (let i = 0; i < 8; i++) {
      state.floating.push({
        x: Math.random() * WIDTH,
        y: Math.random() * HEIGHT,
        radius: 20 + Math.random() * 40,
        dx: (Math.random() - 0.5) * 0.2,
        dy: (Math.random() - 0.5) * 0.2,
        hue: 180 + Math.random() * 80,
        alpha: 0.06 + Math.random() * 0.06
      });
    }
  }

  // Place choices as bubbles avoiding overlapping UI
  function layoutChoices(choices) {
    // Place bubbles in a lower region to avoid overlapping top UI (top 90px)
    const regionTop = 130;
    const regionBottom = HEIGHT - 70;
    const regionLeft = 40;
    const regionRight = WIDTH - 40;
    const positions = [];

    // We will try random non-overlapping placement for each bubble
    for (const val of choices) {
      let attempts = 0;
      let placed = false;
      while (!placed && attempts < 200) {
        attempts++;
        const r = 36 + Math.random() * 12;
        const x = regionLeft + r + Math.random() * (regionRight - regionLeft - 2 * r);
        const y = regionTop + r + Math.random() * (regionBottom - regionTop - 2 * r);
        // Ensure not overlapping with other bubbles and not overlapping the drone start position
        let ok = true;
        for (const p of positions) {
          const dx = p.x - x;
          const dy = p.y - y;
          if (Math.hypot(dx, dy) < p.r + r + 12) { ok = false; break; }
        }
        // avoid top question area center
        if (ok) {
          if (y < regionTop + 40) ok = false;
        }
        // avoid drone initial region
        const dx2 = state.drone.x - x;
        const dy2 = state.drone.y - y;
        if (Math.hypot(dx2, dy2) < r + 60) ok = false;
        if (ok) {
          positions.push({ value: val, x, y, r });
          placed = true;
        }
      }
      // Fallback simple placement if not found
      if (!placed) {
        const r = 40;
        const x = regionLeft + r + Math.random() * (regionRight - regionLeft - 2 * r);
        const y = regionTop + r + choices.indexOf(val) * (r * 2.1);
        positions.push({ value: val, x, y, r });
      }
    }
    return positions;
  }

  // Start a new round with a new question
  function startRound() {
    state.currentQuestion = generateQuestion();
    state.choices = layoutChoices(state.currentQuestion.choices);
    state.lastActionTime = performance.now();
    state.showMessage = 'Steer the drone to the correct bubble!';
  }

  // Restart entire game
  function restartGame() {
    state.score = 0;
    state.wrong = 0;
    state.lives = MAX_WRONG;
    state.running = true;
    state.gameOverReason = null;
    state.drone.x = WIDTH / 2;
    state.drone.y = HEIGHT / 2 + 30;
    state.drone.vx = 0;
    state.drone.vy = 0;
    state.showMessage = 'Ready? Use arrows or WASD to move.';
    startRound();
  }

  // Start initial
  initFloating();
  startRound();

  // Input handling
  window.addEventListener('keydown', (e) => {
    state.keys[e.key.toLowerCase()] = true;

    // Mute toggle
    if (e.key.toLowerCase() === 'm') {
      state.muted = !state.muted;
      if (!audioContext && !state.muted) {
        // Try to resume audio context on user gesture
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (err) {
          audioContext = null;
          console.warn('Could not create audio context on unmute', err);
        }
      }
      if (!state.muted) playTone({ type: 'click' });
    }

    // number keys to select an answer (1-3)
    if (['1', '2', '3'].includes(e.key) && state.running) {
      const idx = parseInt(e.key, 10) - 1;
      if (state.choices[idx]) {
        handleChoiceSelection(state.choices[idx]);
      }
    }

    // Enter to restart if not running
    if (!state.running && e.key === 'Enter') {
      restartGame();
      if (!state.muted) playTone({ type: 'click' });
    }

    // allow spacebar to make small boost upward
    if (e.key === ' ' && state.running) {
      state.drone.vy -= 0.6;
      if (!state.muted) playTone({ type: 'click', freq: 800, duration: 0.08, volume: 0.06 });
    }
  });

  window.addEventListener('keyup', (e) => {
    state.keys[e.key.toLowerCase()] = false;
  });

  // Mouse and touch handling for clicking bubbles and restart button
  canvas.addEventListener('pointerdown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);
    // If game running, check bubbles
    if (state.running) {
      for (const choice of state.choices) {
        const dx = x - choice.x;
        const dy = y - choice.y;
        if (Math.hypot(dx, dy) <= choice.r + 6) {
          handleChoiceSelection(choice);
          return;
        }
      }
    } else {
      // If game over, check restart "button" area center
      // We'll draw restart centered at bottom; detect clicks within rectangle
      const btn = getRestartButtonRect();
      if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
        restartGame();
        if (!state.muted) playTone({ type: 'click' });
      }
    }
  });

  // Provide alternative: clicking on canvas moves drone toward pointer for accessibility (optional)
  canvas.addEventListener('dblclick', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);
    state.drone.x = clamp(x, 20, WIDTH - 20);
    state.drone.y = clamp(y, 20, HEIGHT - 20);
  });

  // Handle when user chooses a bubble (by collision or click/keyboard)
  function handleChoiceSelection(choice) {
    if (!state.running) return;
    const isCorrect = choice.value === state.currentQuestion.correct;
    if (isCorrect) {
      state.score += 1;
      state.showMessage = 'Great! Correct!';
      if (!state.muted) playTone({ type: 'correct', freq: 940, duration: 0.28, volume: 0.2 });
    } else {
      state.wrong += 1;
      state.lives = Math.max(0, MAX_WRONG - state.wrong);
      state.showMessage = 'Oops — try again!';
      if (!state.muted) playTone({ type: 'wrong', freq: 180, duration: 0.35, volume: 0.18 });
    }

    // small visual "pop" on the chosen bubble by temporarily moving drone near it
    state.drone.x = choice.x - (choice.x - state.drone.x) * 0.2;
    state.drone.y = choice.y - (choice.y - state.drone.y) * 0.2;
    state.drone.vx *= 0.4;
    state.drone.vy *= 0.4;

    // Next round after short delay
    setTimeout(() => {
      if (state.score >= state.goal) {
        // Win
        endGame('win');
        return;
      }
      if (state.lives <= 0) {
        endGame('lose');
        return;
      }
      startRound();
    }, 700);
  }

  // End game: show victory or game over screen
  function endGame(reason) {
    state.running = false;
    state.gameOverReason = reason; // 'win' or 'lose'
    state.showMessage = reason === 'win' ? "You did it! Drone team wins!" : "Oh no — drone ran out of safety!";
    if (!state.muted) playTone({ type: reason === 'win' ? 'correct' : 'wrong', duration: 0.6, volume: 0.22 });
  }

  // Utility to measure text and draw a background rectangle for readability
  function drawTextWithBg(text, x, y, options = {}) {
    const {
      fontSize = UI_TEXT_MIN,
      fontWeight = 'normal',
      align = 'left',
      baseline = 'top',
      padding = 8,
      bgColor = 'rgba(255,255,255,0.75)',
      textColor = '#0b2d3a',
      radius = 8
    } = options;
    ctx.font = `${fontWeight} ${fontSize}px ${FONT_FAMILY}`;
    ctx.textAlign = align;
    ctx.textBaseline = baseline;

    const metrics = ctx.measureText(text);
    const textWidth = metrics.width;
    // Compute background rect coordinates depending on align
    let bx = x;
    if (align === 'center') bx = x - textWidth / 2 - padding;
    else if (align === 'right') bx = x - textWidth - padding * 2;

    const bw = textWidth + padding * 2;
    const bh = fontSize + padding;
    const by = y - (baseline === 'top' ? 0 : fontSize / 2);

    // simple rounded rect
    roundRect(ctx, bx, by, bw, bh, radius, bgColor);
    ctx.fillStyle = textColor;
    if (align === 'center') ctx.fillText(text, x, y);
    else if (align === 'left') ctx.fillText(text, x + padding, y);
    else if (align === 'right') ctx.fillText(text, x - padding, y);
    return { x: bx, y: by, w: bw, h: bh };
  }

  // Draw rounded rectangle filled with color
  function roundRect(ctx, x, y, w, h, r = 8, fillColor = '#fff') {
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fillStyle = fillColor;
    ctx.fill();
    ctx.restore();
  }

  // Draw background and floating decorations
  function drawBackground(delta) {
    // soothing gradient sky
    const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    grad.addColorStop(0, '#e6f7ff');
    grad.addColorStop(1, '#f3fbf8');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // floating blobs
    for (const f of state.floating) {
      f.x += f.dx;
      f.y += f.dy;
      if (f.x < -60) f.x = WIDTH + 60;
      if (f.x > WIDTH + 60) f.x = -60;
      if (f.y < -60) f.y = HEIGHT + 60;
      if (f.y > HEIGHT + 60) f.y = -60;

      ctx.beginPath();
      ctx.fillStyle = `hsla(${f.hue},60%,65%,${f.alpha})`;
      ctx.ellipse(f.x, f.y, f.radius * 1.6, f.radius, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    // soft wavy ground near bottom
    ctx.beginPath();
    ctx.fillStyle = 'rgba(200, 255, 230, 0.6)';
    ctx.ellipse(WIDTH * 0.3, HEIGHT + 40, 340, 80, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.fillStyle = 'rgba(220, 240, 255, 0.5)';
    ctx.ellipse(WIDTH * 0.75, HEIGHT + 20, 260, 60, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // Draw drone
  function drawDrone(timeDelta) {
    const d = state.drone;
    // Update rotor phase for animation
    d.rotorPhase += 0.12 + Math.hypot(d.vx, d.vy) * 0.02;
    // Drone body
    ctx.save();
    ctx.translate(d.x, d.y);
    // shadow
    ctx.beginPath();
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.ellipse(0, d.radius + 18, d.radius * 1.6, 10, 0, 0, Math.PI * 2);
    ctx.fill();

    // body
    roundRect(ctx, -d.radius, -d.radius * 0.6, d.radius * 2, d.radius * 1.2, 8, '#bfe9ff');
    ctx.beginPath();
    ctx.fillStyle = '#2a6f8a';
    ctx.ellipse(0, -4, d.radius * 0.7, d.radius * 0.48, 0, 0, Math.PI * 2);
    ctx.fill();

    // cockpit glass
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.ellipse(d.radius * 0.1, -6, d.radius * 0.35, d.radius * 0.2, -0.2, 0, Math.PI * 2);
    ctx.fill();

    // rotors (wacky soft)
    const rotorW = d.radius * 1.8;
    const rotorH = 6;
    const rp = Math.sin(d.rotorPhase) * 6;
    for (let i = -1; i <= 1; i += 2) {
      ctx.save();
      ctx.translate(i * (d.radius + 8), -8);
      ctx.rotate(rp * 0.02);
      ctx.beginPath();
      ctx.fillStyle = 'rgba(120,160,190,0.9)';
      ctx.ellipse(0, 0, rotorW * 0.4, rotorH, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // little face
    ctx.beginPath();
    ctx.fillStyle = '#083b4a';
    ctx.arc(-6, -2, 2, 0, Math.PI * 2);
    ctx.arc(8, -2, 2, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  // Draw answer bubbles
  function drawChoices() {
    state.hoverIndex = -1;
    for (let i = 0; i < state.choices.length; i++) {
      const ch = state.choices[i];
      // simple hover detection using mouse position from keys? We'll use pointer coords when pointerdown, but also mark close to drone
      const dx = state.drone.x - ch.x;
      const dy = state.drone.y - ch.y;
      const dist = Math.hypot(dx, dy);
      const isNear = dist < ch.r + state.drone.radius + 1;
      // scale slightly if near
      const scale = isNear ? 1.05 : 1.0;
      const r = ch.r * scale;

      // bubble background
      ctx.beginPath();
      const hue = 160 + (i * 40);
      ctx.fillStyle = `rgba(${200 - i * 20}, ${230 - i * 10}, ${255 - i * 30}, 0.95)`;
      ctx.ellipse(ch.x, ch.y, r, r * 0.9, 0, 0, Math.PI * 2);
      ctx.fill();

      // ring
      ctx.beginPath();
      ctx.lineWidth = 3;
      ctx.strokeStyle = isNear ? '#ffde7a' : 'rgba(0,0,0,0.06)';
      ctx.ellipse(ch.x, ch.y, r + 4, r * 0.9 + 4, 0, 0, Math.PI * 2);
      ctx.stroke();

      // number text
      ctx.font = `bold 22px ${FONT_FAMILY}`;
      ctx.fillStyle = '#073b46';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const text = String(ch.value);
      // measure text width and ensure it fits inside bubble - decrease font if necessary
      let fontSize = 22;
      let metrics = ctx.measureText(text);
      while ((metrics.width > r * 1.6) && fontSize > 14) {
        fontSize -= 1;
        ctx.font = `bold ${fontSize}px ${FONT_FAMILY}`;
        metrics = ctx.measureText(text);
      }
      ctx.fillText(text, ch.x, ch.y);

      // If drone is near, mark hover index (for keyboard visual)
      if (isNear) state.hoverIndex = i;
    }
  }

  // Draw top UI: score left, level/goal center, lives right, audio icon top-right corner
  function drawTopUI() {
    // Score top-left
    const scoreText = `Score: ${state.score}/${state.goal}`;
    drawTextWithBg(scoreText, 12, TOP_PADDING, {
      fontSize: UI_IMPORTANT,
      fontWeight: 'bold',
      align: 'left',
      baseline: 'top',
      padding: 10,
      bgColor: 'rgba(255,255,255,0.9)',
      textColor: '#064048',
      radius: 10
    });

    // Lives top-right
    const livesText = `Lives: ${state.lives}`;
    ctx.save();
    // measure to align right near edge with padding 12
    ctx.font = `bold ${UI_IMPORTANT}px ${FONT_FAMILY}`;
    const metrics = ctx.measureText(livesText);
    const textW = metrics.width;
    const x = WIDTH - 12 - textW;
    drawTextWithBg(livesText, WIDTH - 12, TOP_PADDING, {
      fontSize: UI_IMPORTANT,
      fontWeight: 'bold',
      align: 'right',
      baseline: 'top',
      padding: 10,
      bgColor: 'rgba(255,255,255,0.9)',
      textColor: '#670d0d',
      radius: 10
    });
    ctx.restore();

    // Goal center top
    const goalText = `Get ${state.goal} correct answers to win`;
    ctx.save();
    ctx.font = `${UI_TEXT_MIN + 6}px ${FONT_FAMILY}`;
    const centerY = TOP_PADDING + 6;
    drawTextWithBg(goalText, WIDTH / 2, TOP_PADDING, {
      fontSize: UI_TEXT_MIN + 6,
      fontWeight: '600',
      align: 'center',
      baseline: 'top',
      padding: 10,
      bgColor: 'rgba(255,255,255,0.88)',
      textColor: '#1b3b43',
      radius: 10
    });
    ctx.restore();

    // Audio mute icon right of lives
    const iconSize = 18;
    const iconX = WIDTH - 12 - iconSize - 12;
    const iconY = TOP_PADDING + 34;
    ctx.beginPath();
    ctx.fillStyle = state.muted ? '#bfbfbf' : '#2c6f7b';
    roundRect(ctx, iconX - 6, iconY - 6, iconSize + 12, iconSize + 12, 6, state.muted ? 'rgba(255,255,255,0.9)' : 'rgba(255,255,255,0.9)');
    // tiny speaker box
    ctx.fillStyle = state.muted ? '#bfbfbf' : '#2c6f7b';
    ctx.fillRect(iconX, iconY, iconSize - 6, iconSize);
    // cone
    ctx.beginPath();
    ctx.moveTo(iconX + iconSize - 6, iconY + 2);
    ctx.lineTo(iconX + iconSize + 4, iconY + 9);
    ctx.lineTo(iconX + iconSize - 6, iconY + iconSize - 2);
    ctx.closePath();
    ctx.fill();

    // muted cross
    if (state.muted) {
      ctx.strokeStyle = '#ff6b6b';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(iconX + 4, iconY + 4);
      ctx.lineTo(iconX + iconSize + 6, iconY + iconSize - 2);
      ctx.moveTo(iconX + iconSize + 6, iconY + 4);
      ctx.lineTo(iconX + 4, iconY + iconSize - 2);
      ctx.stroke();
    }

    // Text instruction at bottom-center (non-overlapping)
    const instr = "Move: Arrows or WASD  •  Select: fly into bubble or press 1-3  •  M: mute/unmute";
    drawTextWithBg(instr, WIDTH / 2, HEIGHT - 38, {
      fontSize: UI_TEXT_MIN,
      fontWeight: 'normal',
      align: 'center',
      baseline: 'top',
      padding: 10,
      bgColor: 'rgba(255,255,255,0.92)',
      textColor: '#0b3b44',
      radius: 10
    });
  }

  // Draw current question text below top UI (centered)
  function drawQuestionArea() {
    if (!state.currentQuestion) return;
    const q = state.currentQuestion;
    const text = `${q.a} ${q.op} ${q.b} = ?`;
    // Ensure it doesn't overlap with score or lives by placing at y ~ 78
    const y = 78;
    drawTextWithBg(text, WIDTH / 2, y, {
      fontSize: 26,
      fontWeight: 'bold',
      align: 'center',
      baseline: 'top',
      padding: 12,
      bgColor: 'rgba(255,255,255,0.95)',
      textColor: '#023047',
      radius: 12
    });
  }

  // Draw floating temporary messages
  function drawMessage() {
    if (!state.showMessage) return;
    const elapsed = performance.now() - state.lastActionTime;
    // fade out after 1800ms
    const alpha = elapsed < 1800 ? 1 : Math.max(0, 1 - (elapsed - 1800) / 800);
    if (alpha <= 0) {
      state.showMessage = '';
      return;
    }
    ctx.save();
    ctx.globalAlpha = alpha;
    drawTextWithBg(state.showMessage, WIDTH / 2, 110, {
      fontSize: 16,
      fontWeight: '600',
      align: 'center',
      baseline: 'top',
      padding: 8,
      bgColor: 'rgba(255,255,255,0.9)',
      textColor: '#0b3b44',
      radius: 10
    });
    ctx.restore();
  }

  // Restart button rectangle for end screens
  function getRestartButtonRect() {
    const w = 240;
    const h = 44;
    const x = WIDTH / 2 - w / 2;
    const y = HEIGHT / 2 + 60;
    return { x, y, w, h };
  }

  // Draw end-game overlay (win/lose) with restart instruction
  function drawEndScreen() {
    const overlayAlpha = 0.86;
    // semi-opaque overlay
    ctx.fillStyle = `rgba(8,12,20,${overlayAlpha})`;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // message
    if (state.gameOverReason === 'win') {
      drawTextWithBg('VICTORY!', WIDTH / 2, HEIGHT / 2 - 40, {
        fontSize: 36,
        fontWeight: 'bold',
        align: 'center',
        baseline: 'top',
        padding: 14,
        bgColor: '#eafff2',
        textColor: '#0a7a3d',
        radius: 14
      });
      const details = `You guided the drone crew and answered ${state.score} questions!`;
      drawTextWithBg(details, WIDTH / 2, HEIGHT / 2 + 6, {
        fontSize: 18,
        fontWeight: '600',
        align: 'center',
        baseline: 'top',
        padding: 12,
        bgColor: 'rgba(255,255,255,0.95)',
        textColor: '#073b4a',
        radius: 10
      });
    } else {
      drawTextWithBg('GAME OVER', WIDTH / 2, HEIGHT / 2 - 40, {
        fontSize: 34,
        fontWeight: 'bold',
        align: 'center',
        baseline: 'top',
        padding: 14,
        bgColor: '#ffefef',
        textColor: '#7a0b0b',
        radius: 14
      });
      const details = `You answered ${state.score} correctly. Try again to reach ${state.goal}!`;
      drawTextWithBg(details, WIDTH / 2, HEIGHT / 2 + 6, {
        fontSize: 18,
        fontWeight: '600',
        align: 'center',
        baseline: 'top',
        padding: 12,
        bgColor: 'rgba(255,255,255,0.95)',
        textColor: '#073b4a',
        radius: 10
      });
    }

    // restart button
    const btn = getRestartButtonRect();
    // draw rounded rect
    roundRect(ctx, btn.x, btn.y, btn.w, btn.h, 10, '#fffcf0');
    ctx.fillStyle = '#094b5f';
    ctx.font = `bold 18px ${FONT_FAMILY}`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Restart (Enter or Click)', btn.x + btn.w / 2, btn.y + btn.h / 2);
  }

  // Main update and draw loop
  let lastTime = performance.now();
  function loop(now) {
    const dt = Math.min(60, now - lastTime);
    lastTime = now;

    // Update floating decor a bit
    for (const f of state.floating) {
      f.x += f.dx * dt * 0.06;
      f.y += f.dy * dt * 0.06;
    }

    // Input: movement
    if (state.running) {
      const speed = state.drone.speed;
      const k = state.keys;
      let ax = 0, ay = 0;
      if (k['arrowleft'] || k['a']) ax -= 1;
      if (k['arrowright'] || k['d']) ax += 1;
      if (k['arrowup'] || k['w']) ay -= 1;
      if (k['arrowdown'] || k['s']) ay += 1;

      // Normalize diagonal
      if (ax !== 0 && ay !== 0) {
        ax *= 0.7071;
        ay *= 0.7071;
      }
      state.drone.vx += ax * 0.18 * speed;
      state.drone.vy += ay * 0.18 * speed;
      // friction
      state.drone.vx *= 0.96;
      state.drone.vy *= 0.96;
      // cap speed
      const spd = Math.hypot(state.drone.vx, state.drone.vy);
      const max = state.drone.speed;
      if (spd > max) {
        state.drone.vx = (state.drone.vx / spd) * max;
        state.drone.vy = (state.drone.vy / spd) * max;
      }
      state.drone.x += state.drone.vx;
      state.drone.y += state.drone.vy;

      // confine to play area margins to keep UI readable
      const margin = 22;
      state.drone.x = clamp(state.drone.x, margin, WIDTH - margin);
      state.drone.y = clamp(state.drone.y, 100, HEIGHT - 90);

      // check collisions with bubbles
      for (const choice of state.choices) {
        const dx = state.drone.x - choice.x;
        const dy = state.drone.y - choice.y;
        if (Math.hypot(dx, dy) <= state.drone.radius + choice.r - 4) {
          // collided with this bubble
          handleChoiceSelection(choice);
          break;
        }
      }
    }

    // Clear and draw
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    drawBackground(dt);
    drawTopUI();
    drawQuestionArea();
    drawChoices();
    drawDrone(dt);
    drawMessage();

    // If not running (end screen), draw overlay
    if (!state.running) {
      drawEndScreen();
    }

    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);

  // Accessibility: provide some text alternative live-updates for screen readers by updating container aria-label
  function updateAria() {
    const status = state.running ? `Score ${state.score} out of ${state.goal}. Lives ${state.lives}.` : (state.gameOverReason === 'win' ? 'Victory!' : 'Game over.');
    const question = state.currentQuestion ? `Question: ${state.currentQuestion.a} ${state.currentQuestion.op} ${state.currentQuestion.b}.` : '';
    container.setAttribute('aria-label', `Drone math game. ${status} ${question} Move with arrow keys or WASD. Press M to mute. Press Enter to restart.`);
  }

  // Periodically update aria label
  setInterval(updateAria, 1000);

  // Initialize on user gesture to resume audio if needed
  function resumeAudioOnGesture() {
    if (audioContext && audioContext.state === 'suspended') {
      audioContext.resume().catch((err) => {
        console.warn('Audio context resume failed:', err);
      });
    }
    window.removeEventListener('pointerdown', resumeAudioOnGesture);
    window.removeEventListener('keydown', resumeAudioOnGesture);
  }
  window.addEventListener('pointerdown', resumeAudioOnGesture);
  window.addEventListener('keydown', resumeAudioOnGesture);

  // Error handling for unexpected exceptions during runtime
  window.addEventListener('error', (evt) => {
    console.error('Unexpected error in game:', evt.error);
    // Display a friendly message inside canvas
    ctx.save();
    roundRect(ctx, 60, HEIGHT / 2 - 60, WIDTH - 120, 120, 12, '#fff7ed');
    ctx.fillStyle = '#3b1e00';
    ctx.font = `bold 18px ${FONT_FAMILY}`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('An unexpected error occurred. Please reload to try again.', WIDTH / 2, HEIGHT / 2);
    ctx.restore();
  });

  // Prevent tab navigation away from game area interfering with key controls
  canvas.setAttribute('tabindex', '0');
  canvas.addEventListener('blur', () => {
    // stop movement if focus lost
    state.keys = {};
  });

})();
---

