{
  "generated_date": "2025-09-08",
  "generated_timestamp": "2025-09-08T00:28:24.900569",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9895,
  "game_filename": "2025-09-08.js",
  "game_size_bytes": 29832,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Machine Math \u2014 JavaScript game for ages 7-9\n// Renders into the element with ID \"game-of-the-day-stage\"\n// All visuals drawn on canvas. Sounds generated with Web Audio API.\n// Accessible: keyboard controls, aria live text, audio on/off, instructions.\n// Author: educational game designer (example)\n\n(function () {\n  'use strict';\n\n  // ------- Configuration -------\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const BG_COLOR = '#E9F5F5'; // calming\n  const MACHINE_COLOR = '#D1E8E2';\n  const TILE_COLOR = '#F7E9E1';\n  const TILE_BORDER = '#C9B8A8';\n  const TEXT_COLOR = '#2B3A30';\n  const ACCENT = '#7FB069';\n  const LEVELS = 5;\n  const TILE_COUNT = 9;\n  const MACHINE_COUNT = 3;\n\n  // ------- DOM Setup -------\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Container element with id \"game-of-the-day-stage\" not found.');\n    return;\n  }\n  // Clear container\n  container.innerHTML = '';\n  container.style.userSelect = 'none';\n  container.style.position = 'relative';\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute('role', 'img');\n  canvas.setAttribute('aria-label', 'Machine Math game. Solve simple addition and subtraction to fix the machines.');\n  canvas.style.display = 'block';\n  canvas.style.background = BG_COLOR;\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Create hidden live region for screen reader messages\n  const liveRegion = document.createElement('div');\n  liveRegion.setAttribute('aria-live', 'polite');\n  liveRegion.style.position = 'absolute';\n  liveRegion.style.left = '-10000px';\n  liveRegion.style.width = '1px';\n  liveRegion.style.height = '1px';\n  liveRegion.style.overflow = 'hidden';\n  container.appendChild(liveRegion);\n\n  // ------- Audio Setup -------\n  let audioAllowed = true;\n  let audioContext = null;\n  let masterGain = null;\n  let backgroundOsc = null;\n  let backgroundLFO = null;\n  let audioEnabled = true;\n\n  function safeCreateAudioContext() {\n    if (!audioAllowed) return null;\n    try {\n      const AC = window.AudioContext || window.webkitAudioContext;\n      if (!AC) {\n        console.warn('Web Audio API not supported in this browser.');\n        audioAllowed = false;\n        return null;\n      }\n      const ctx = new AC();\n      masterGain = ctx.createGain();\n      masterGain.gain.value = 0.2;\n      masterGain.connect(ctx.destination);\n      // Background hum\n      backgroundOsc = ctx.createOscillator();\n      backgroundOsc.type = 'sine';\n      backgroundOsc.frequency.value = 110; // gentle\n      backgroundLFO = ctx.createOscillator();\n      backgroundLFO.type = 'sine';\n      backgroundLFO.frequency.value = 0.2;\n      const lfoGain = ctx.createGain();\n      lfoGain.gain.value = 10;\n      backgroundLFO.connect(lfoGain);\n      lfoGain.connect(backgroundOsc.frequency);\n      backgroundOsc.connect(masterGain);\n      backgroundOsc.start();\n      backgroundLFO.start();\n      return ctx;\n    } catch (e) {\n      console.error('Error creating AudioContext:', e);\n      audioAllowed = false;\n      return null;\n    }\n  }\n\n  // Create audio context on first user interaction (to satisfy browser autoplay policies)\n  function ensureAudioContext() {\n    if (audioContext) return;\n    audioContext = safeCreateAudioContext();\n    if (!audioContext) audioEnabled = false;\n  }\n\n  function stopBackground() {\n    if (!audioContext || !backgroundOsc || !backgroundLFO) return;\n    try {\n      backgroundOsc.stop();\n      backgroundLFO.stop();\n    } catch (e) {\n      // ignore already stopped\n    }\n    backgroundOsc.disconnect();\n    backgroundLFO.disconnect();\n    backgroundOsc = null;\n    backgroundLFO = null;\n  }\n\n  function toggleAudio() {\n    if (!audioAllowed) {\n      announce('Audio not available on this device.');\n      audioEnabled = false;\n      return;\n    }\n    if (!audioContext) ensureAudioContext();\n    audioEnabled = !audioEnabled;\n    if (audioEnabled) {\n      if (masterGain) masterGain.gain.value = 0.2;\n      announce('Audio on');\n    } else {\n      if (masterGain) masterGain.gain.value = 0.0;\n      announce('Audio off');\n    }\n  }\n\n  function playCorrectSound() {\n    if (!audioEnabled || !audioContext) return;\n    try {\n      const o = audioContext.createOscillator();\n      const g = audioContext.createGain();\n      o.type = 'triangle';\n      const now = audioContext.currentTime;\n      o.frequency.setValueAtTime(440, now);\n      o.frequency.exponentialRampToValueAtTime(880, now + 0.15);\n      g.gain.setValueAtTime(0, now);\n      g.gain.linearRampToValueAtTime(0.12, now + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.001, now + 0.3);\n      o.connect(g);\n      g.connect(masterGain);\n      o.start();\n      o.stop(now + 0.32);\n    } catch (e) {\n      console.error('Error playing correct sound', e);\n    }\n  }\n\n  function playIncorrectSound() {\n    if (!audioEnabled || !audioContext) return;\n    try {\n      const o = audioContext.createOscillator();\n      const g = audioContext.createGain();\n      o.type = 'sawtooth';\n      const now = audioContext.currentTime;\n      o.frequency.setValueAtTime(220, now);\n      o.frequency.exponentialRampToValueAtTime(110, now + 0.12);\n      g.gain.setValueAtTime(0, now);\n      g.gain.linearRampToValueAtTime(0.12, now + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.001, now + 0.25);\n      o.connect(g);\n      g.connect(masterGain);\n      o.start();\n      o.stop(now + 0.26);\n    } catch (e) {\n      console.error('Error playing incorrect sound', e);\n    }\n  }\n\n  // ------- Utility -------\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n  function shuffle(arr) {\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n  }\n\n  function announce(text) {\n    liveRegion.textContent = text;\n    // also console for debugging\n    console.log('ANNOUNCE:', text);\n  }\n\n  // ------- Game State -------\n  let level = 1;\n  let machines = [];\n  let tiles = [];\n  let selectedTiles = []; // indices of selected tiles\n  let solvedCount = 0;\n  let focusIndex = 0; // keyboard focus among interactive elements (tiles then machines then controls)\n  let focusList = []; // computed each frame\n  let confettiParticles = [];\n  let lastTick = performance.now();\n  let animations = []; // generic animations\n\n  // ------- Layout -------\n  const machineArea = { x: 40, y: 60, w: WIDTH - 80, h: 220 };\n  const conveyorArea = { x: 20, y: 320, w: WIDTH - 40, h: 140 };\n\n  // ------- Create Level Data -------\n  function buildLevel(lvl) {\n    // ensure audio context exists lazily\n    // We'll build MACHINE_COUNT machine requirements (operation and target)\n    machines = [];\n    tiles = [];\n    solvedCount = 0;\n    selectedTiles = [];\n    confettiParticles = [];\n    animations = [];\n\n    // pick operations: early levels only addition, later include subtraction\n    const ops = [];\n    for (let i = 0; i < MACHINE_COUNT; i++) {\n      if (lvl <= 2) ops.push('+');\n      else if (lvl === 3) ops.push(Math.random() < 0.5 ? '+' : '-');\n      else ops.push(Math.random() < 0.6 ? '+' : '-');\n    }\n\n    // For each machine, pick a valid pair (a,b) consistent with op and reasonable ranges\n    const pairs = [];\n    for (let i = 0; i < MACHINE_COUNT; i++) {\n      let a, b;\n      const op = ops[i];\n      if (op === '+') {\n        const maxSum = lvl < 3 ? 10 : 20;\n        const target = randInt(Math.max(2, lvl * 3 - 1), Math.min(maxSum, lvl * 5 + 5));\n        // pick a and b between 1 and 9 (or up to 12 in later levels) such that a + b = target\n        const minVal = 1;\n        const maxVal = lvl < 4 ? 9 : 12;\n        let attempts = 0;\n        while (attempts < 200) {\n          a = randInt(minVal, Math.min(maxVal, target - 1));\n          b = target - a;\n          if (b >= minVal && b <= maxVal) break;\n          attempts++;\n        }\n        pairs.push({ op, a, b, target });\n      } else {\n        // subtraction: a - b = target, ensure a> b >=1, keep within ranges\n        const maxA = lvl < 4 ? 15 : 19;\n        const bMax = Math.min(9, maxA - 1);\n        let attempts = 0;\n        while (attempts < 200) {\n          b = randInt(1, bMax);\n          const aMin = b + 1;\n          a = randInt(aMin, Math.min(maxA, b + (lvl * 4)));\n          const target = a - b;\n          if (target >= 1 && target <= (lvl < 3 ? 10 : 15)) {\n            pairs.push({ op, a, b, target });\n            break;\n          }\n          attempts++;\n        }\n      }\n    }\n\n    // Build the machines positions\n    const gap = machineArea.w / MACHINE_COUNT;\n    for (let i = 0; i < MACHINE_COUNT; i++) {\n      const mX = machineArea.x + i * gap + gap / 8;\n      const mY = machineArea.y;\n      const mW = gap - gap / 4;\n      const mH = machineArea.h;\n      const pair = pairs[i];\n      machines.push({\n        x: mX,\n        y: mY,\n        w: mW,\n        h: mH,\n        op: pair.op,\n        target: pair.target,\n        required: [pair.a, pair.b],\n        placed: [], // tile indices\n        solved: false,\n        rotate: 0 // for gear animation\n      });\n    }\n\n    // Build tiles: ensure tiles include required numbers for each machine, plus random numbers\n    const needed = [];\n    for (const p of pairs) {\n      needed.push(p.a);\n      needed.push(p.b);\n    }\n    // Fill remaining tile slots\n    const pool = needed.slice();\n    while (pool.length < TILE_COUNT) {\n      // numbers reasonable for level\n      const maxVal = level < 4 ? 12 : 15;\n      pool.push(randInt(1, Math.min(12, maxVal)));\n    }\n    shuffle(pool);\n    // create tile objects positioned on conveyor\n    const tileWidth = 80;\n    const tileHeight = 64;\n    const spacing = (conveyorArea.w - TILE_COUNT * tileWidth) / (TILE_COUNT + 1);\n    for (let i = 0; i < TILE_COUNT; i++) {\n      const x = conveyorArea.x + spacing + i * (tileWidth + spacing);\n      const y = conveyorArea.y + (conveyorArea.h - tileHeight) / 2;\n      tiles.push({\n        id: i,\n        value: pool[i],\n        x,\n        y,\n        w: tileWidth,\n        h: tileHeight,\n        taken: false,\n        grabbed: false,\n        original: { x, y }\n      });\n    }\n\n    announce(`Level ${lvl}. Fix all machines. Use math to make each machine's result equal to the number shown.`);\n    focusIndex = 0;\n  }\n\n  // ------- Input Handling -------\n  let mouse = { x: 0, y: 0, down: false };\n  canvas.tabIndex = 0; // make focusable\n  canvas.style.outline = 'none';\n\n  canvas.addEventListener('mousemove', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);\n    mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);\n  });\n\n  canvas.addEventListener('mousedown', (e) => {\n    ensureAudioContext(); // allow audio after user interaction\n    mouse.down = true;\n    // pick tile if clicked\n    const t = hitTestTile(mouse.x, mouse.y);\n    if (t && !t.taken) {\n      t.grabbed = true;\n      t.offsetX = mouse.x - t.x;\n      t.offsetY = mouse.y - t.y;\n      // select by pointer: add to selectedTiles but enforce up to 2 selections\n      if (!selectedTiles.includes(t.id)) {\n        if (selectedTiles.length < 2) selectedTiles.push(t.id);\n        else {\n          // rotate selections: drop first then add new\n          selectedTiles.shift();\n          selectedTiles.push(t.id);\n        }\n      }\n    } else {\n      // if click on a machine and have selected tiles, attempt place\n      const mIndex = hitTestMachine(mouse.x, mouse.y);\n      if (mIndex !== -1) {\n        attemptPlaceOnMachine(mIndex);\n      }\n    }\n  });\n\n  canvas.addEventListener('mouseup', (e) => {\n    mouse.down = false;\n    // drop grabbed tiles\n    for (const t of tiles) {\n      if (t.grabbed) {\n        // if dropped over a machine, attempt immediate place using this and any selected other tile\n        t.grabbed = false;\n        const mIndex = hitTestMachine(mouse.x, mouse.y);\n        if (mIndex !== -1) {\n          // ensure t.id in selectedTiles\n          if (!selectedTiles.includes(t.id)) {\n            if (selectedTiles.length < 2) selectedTiles.push(t.id);\n            else {\n              selectedTiles.shift();\n              selectedTiles.push(t.id);\n            }\n          }\n          attemptPlaceOnMachine(mIndex);\n        } else {\n          // return to original if not placed\n          t.x = t.original.x;\n          t.y = t.original.y;\n          t.taken = false;\n          // keep selection if clicked\n        }\n      }\n    }\n  });\n\n  // Keyboard Controls\n  window.addEventListener('keydown', (e) => {\n    if (e.key === 'm' || e.key === 'M') {\n      e.preventDefault();\n      toggleAudio();\n      return;\n    }\n    if (e.key === 'r' || e.key === 'R') {\n      e.preventDefault();\n      buildLevel(level);\n      return;\n    }\n    // Focus cycling: Tab custom behavior\n    if (e.key === 'Tab') {\n      e.preventDefault();\n      // compute focus list\n      computeFocusList();\n      focusIndex = (focusIndex + (e.shiftKey ? -1 : 1) + focusList.length) % focusList.length;\n      announceFocus();\n      return;\n    }\n    // Activation\n    if (e.key === 'Enter' || e.key === ' ') {\n      e.preventDefault();\n      activateFocused();\n      return;\n    }\n    // Arrow navigation: move focus among tiles/machines\n    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {\n      computeFocusList();\n      const dir = e.key;\n      if (focusList.length === 0) return;\n      // Try to move focus near elements spatially\n      const current = focusList[focusIndex];\n      let bestIndex = focusIndex;\n      let bestScore = Infinity;\n      for (let i = 0; i < focusList.length; i++) {\n        if (i === focusIndex) continue;\n        const a = current.rect;\n        const b = focusList[i].rect;\n        // score based on direction and distance\n        const dx = b.cx - a.cx;\n        const dy = b.cy - a.cy;\n        let score = Math.hypot(dx, dy);\n        if (dir === 'ArrowLeft' && dx >= 0) score += 1000;\n        if (dir === 'ArrowRight' && dx <= 0) score += 1000;\n        if (dir === 'ArrowUp' && dy >= 0) score += 1000;\n        if (dir === 'ArrowDown' && dy <= 0) score += 1000;\n        if (score < bestScore) {\n          bestScore = score;\n          bestIndex = i;\n        }\n      }\n      focusIndex = bestIndex;\n      announceFocus();\n    }\n  });\n\n  function computeFocusList() {\n    focusList = [];\n    // Add tiles not taken, then machines, then audio control\n    for (const t of tiles) {\n      focusList.push({\n        kind: 'tile',\n        id: t.id,\n        rect: { cx: t.x + t.w / 2, cy: t.y + t.h / 2 }\n      });\n    }\n    machines.forEach((m, idx) => {\n      focusList.push({\n        kind: 'machine',\n        id: idx,\n        rect: { cx: m.x + m.w / 2, cy: m.y + m.h / 2 }\n      });\n    });\n    focusList.push({\n      kind: 'audio',\n      id: 0,\n      rect: { cx: WIDTH - 60, cy: 28 }\n    });\n  }\n\n  function announceFocus() {\n    if (!focusList.length) return;\n    const f = focusList[focusIndex];\n    if (f.kind === 'tile') {\n      const t = tiles.find((x) => x.id === f.id);\n      announce(`Tile ${t.value}. Press Enter to select.`);\n    } else if (f.kind === 'machine') {\n      const m = machines[f.id];\n      announce(`Machine ${f.id + 1}. Operation ${m.op} target ${m.target}. Press Enter to place selected tiles.`);\n    } else if (f.kind === 'audio') {\n      announce(`Audio control. Press Enter to toggle audio.`);\n    }\n  }\n\n  function activateFocused() {\n    if (!focusList.length) computeFocusList();\n    const f = focusList[focusIndex];\n    if (!f) return;\n    if (f.kind === 'tile') {\n      // toggle selection\n      const tileId = f.id;\n      const idx = selectedTiles.indexOf(tileId);\n      if (idx === -1) {\n        if (selectedTiles.length < 2) selectedTiles.push(tileId);\n        else {\n          selectedTiles.shift();\n          selectedTiles.push(tileId);\n        }\n      } else {\n        selectedTiles.splice(idx, 1);\n      }\n      const t = tiles.find((x) => x.id === tileId);\n      announce(`Tile ${t.value} ${selectedTiles.includes(tileId) ? 'selected' : 'deselected'}.`);\n    } else if (f.kind === 'machine') {\n      attemptPlaceOnMachine(f.id);\n    } else if (f.kind === 'audio') {\n      toggleAudio();\n    }\n  }\n\n  // ------- Hit Testing -------\n  function hitTestTile(x, y) {\n    for (let i = tiles.length - 1; i >= 0; i--) {\n      const t = tiles[i];\n      if (\n        x >= t.x &&\n        x <= t.x + t.w &&\n        y >= t.y &&\n        y <= t.y + t.h\n      ) {\n        return t;\n      }\n    }\n    return null;\n  }\n\n  function hitTestMachine(x, y) {\n    for (let i = 0; i < machines.length; i++) {\n      const m = machines[i];\n      if (\n        x >= m.x &&\n        x <= m.x + m.w &&\n        y >= m.y &&\n        y <= m.y + m.h\n      ) return i;\n    }\n    return -1;\n  }\n\n  // ------- Game Logic -------\n  function attemptPlaceOnMachine(mIndex) {\n    const m = machines[mIndex];\n    if (m.solved) {\n      announce('This machine is already fixed.');\n      return;\n    }\n    if (selectedTiles.length < 2) {\n      announce('Select two tiles to place in the machine.');\n      playIncorrectSound();\n      return;\n    }\n    const t1 = tiles.find((t) => t.id === selectedTiles[0]);\n    const t2 = tiles.find((t) => t.id === selectedTiles[1]);\n    if (!t1 || !t2) {\n      announce('Selected tiles not available.');\n      selectedTiles = [];\n      playIncorrectSound();\n      return;\n    }\n    const a = t1.value;\n    const b = t2.value;\n    let result = 0;\n    if (m.op === '+') result = a + b;\n    else result = a - b;\n    if (result === m.target) {\n      // success\n      m.solved = true;\n      m.placed = [t1.id, t2.id];\n      t1.taken = true;\n      t2.taken = true;\n      selectedTiles = [];\n      solvedCount++;\n      announce('Great! Machine fixed.');\n      playCorrectSound();\n      spawnConfetti(m.x + m.w / 2, m.y + m.h / 2);\n      animations.push({ type: 'gear-spin', machineIndex: mIndex, time: performance.now(), duration: 1200 });\n      // if solved all, next level or win\n      if (solvedCount >= machines.length) {\n        // Win animation and advance after short pause\n        announce(`All machines fixed! Level ${level} complete.`);\n        setTimeout(() => {\n          level++;\n          if (level > LEVELS) {\n            announce('You completed all levels. Well done!');\n            // reset to level 1 optionally\n            setTimeout(() => {\n              level = 1;\n              buildLevel(level);\n            }, 3000);\n          } else {\n            buildLevel(level);\n          }\n        }, 1000);\n      }\n    } else {\n      // incorrect - return tiles to originals and allow retry\n      announce('That did not fix the machine. Try different tiles.');\n      playIncorrectSound();\n      // small shake animation on machine\n      animations.push({ type: 'shake', machineIndex: mIndex, time: performance.now(), duration: 600 });\n      // return tiles visually to conveyors\n      t1.x = t1.original.x;\n      t1.y = t1.original.y;\n      t2.x = t2.original.x;\n      t2.y = t2.original.y;\n      selectedTiles = [];\n    }\n  }\n\n  // ------- Visual Effects -------\n  function spawnConfetti(cx, cy) {\n    for (let i = 0; i < 16; i++) {\n      confettiParticles.push({\n        x: cx,\n        y: cy,\n        vx: (Math.random() - 0.5) * 3,\n        vy: -Math.random() * 3 - 1,\n        r: randInt(3, 7),\n        color: ['#FFB6B9', '#FAE3D9', '#BBDED6', '#8AC6D1', '#FDE2E4'][Math.floor(Math.random() * 5)],\n        life: 0,\n        ttl: randInt(800, 1400)\n      });\n    }\n  }\n\n  // ------- Drawing -------\n  function draw() {\n    // Clear\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    // Background with gentle pattern\n    ctx.fillStyle = BG_COLOR;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Title and header\n    ctx.fillStyle = TEXT_COLOR;\n    ctx.font = '20px \"Segoe UI\", Arial';\n    ctx.textAlign = 'left';\n    ctx.fillText('Machine Math', 18, 28);\n    ctx.font = '12px \"Segoe UI\", Arial';\n    ctx.fillStyle = '#53725B';\n    ctx.fillText(`Level ${level} \u2014 Fix ${machines.length} machines`, 18, 48);\n    ctx.fillStyle = ACCENT;\n    ctx.fillRect(WIDTH - 120, 12, 96, 28);\n    ctx.fillStyle = '#fff';\n    ctx.font = '12px \"Segoe UI\", Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText(audioEnabled ? 'Audio: On (M)' : 'Audio: Off (M)', WIDTH - 72, 32);\n    ctx.textAlign = 'left';\n\n    // Instructions area\n    ctx.fillStyle = '#DDEDEA';\n    roundRect(ctx, 18, 52, WIDTH - 36, 36, 8);\n    ctx.fillStyle = '#2F4F4F';\n    ctx.font = '13px \"Segoe UI\", Arial';\n    ctx.fillText('Select two tiles (click or use keyboard) and place them into a machine. Match the machine\\'s target number to fix it. R to restart level.', 26, 77);\n\n    // Draw machines\n    machines.forEach((m, idx) => {\n      // compute shake or spin modifications from animations\n      let dx = 0;\n      let dy = 0;\n      let spin = 0;\n      for (const a of animations) {\n        if (a.machineIndex !== idx) continue;\n        const t = performance.now() - a.time;\n        if (t > a.duration) continue;\n        if (a.type === 'shake') {\n          const intensity = Math.sin((t / a.duration) * Math.PI * 6) * 6 * (1 - t / a.duration);\n          dx += intensity;\n        } else if (a.type === 'gear-spin') {\n          spin += (t / a.duration) * Math.PI * 6;\n        }\n      }\n\n      // Machine casing\n      ctx.save();\n      ctx.translate(m.x + dx, m.y + dy);\n      roundRect(ctx, 0, 0, m.w, m.h, 16);\n      ctx.fillStyle = MACHINE_COLOR;\n      ctx.fill();\n      ctx.strokeStyle = '#C3D7D3';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n\n      // Wacky elements: a pair of googly eyes on top-left\n      ctx.fillStyle = '#FFF';\n      ctx.beginPath();\n      ctx.ellipse(26, 30, 12, 16, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.beginPath();\n      ctx.ellipse(54, 30, 12, 16, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.fillStyle = '#333';\n      ctx.beginPath();\n      ctx.arc(32 + Math.sin((Date.now() / 600) + idx) * 2, 32, 5, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.beginPath();\n      ctx.arc(60 + Math.sin((Date.now() / 700) + idx) * 2, 32, 5, 0, Math.PI * 2);\n      ctx.fill();\n\n      // Machine display for target and operation\n      ctx.fillStyle = '#FFF';\n      roundRect(ctx, m.w - 120, 18, 92, 42, 8);\n      ctx.fillStyle = '#F6F9F8';\n      ctx.fill();\n      ctx.strokeStyle = '#BFD0CB';\n      ctx.stroke();\n      ctx.fillStyle = '#2E4D44';\n      ctx.font = 'bold 22px \"Segoe UI\", Arial';\n      ctx.textAlign = 'center';\n      ctx.fillText(`${m.op} ${m.target}`, m.w - 120 + 46, 48);\n      ctx.textAlign = 'left';\n\n      // Gears area showing required slots\n      const slotX = 40;\n      const slotY = 90;\n      // draw two gear circles\n      for (let i = 0; i < 2; i++) {\n        const gx = slotX + i * 120;\n        const gy = slotY;\n        ctx.save();\n        ctx.translate(gx + 24, gy + 24);\n        ctx.rotate((m.rotate + spin / 8) + (idx * 0.2));\n        drawGear(ctx, 24, i === 0 ? '#F7E9E1' : '#EDE7F6', i === 0 ? '#C9B8A8' : '#CBB4E6');\n        ctx.restore();\n        // slot background for tile number (if placed)\n        ctx.fillStyle = '#FFF';\n        roundRect(ctx, gx + 10, gy + 50, 88, 46, 9);\n        ctx.fillStyle = '#FAFAFA';\n        ctx.fill();\n        ctx.strokeStyle = '#D8E7E3';\n        ctx.stroke();\n        // if tile placed, show its value\n        const placedId = m.placed[i];\n        if (placedId !== undefined) {\n          const tile = tiles.find((t) => t.id === placedId);\n          ctx.fillStyle = TEXT_COLOR;\n          ctx.font = '20px \"Segoe UI\", Arial';\n          ctx.textAlign = 'center';\n          ctx.fillText(tile.value, gx + 54, gy + 82);\n          ctx.textAlign = 'left';\n        } else {\n          ctx.fillStyle = '#AABBB6';\n          ctx.font = '14px \"Segoe UI\", Arial';\n          ctx.fillText('place tile', gx + 28, gy + 82);\n        }\n      }\n\n      // If solved, show green glow and small \"fixed\" label\n      if (m.solved) {\n        ctx.fillStyle = 'rgba(127,176,105,0.18)';\n        roundRect(ctx, 6, 6, m.w - 12, m.h - 12, 14);\n        ctx.fill();\n        ctx.fillStyle = '#2F7B48';\n        ctx.font = 'bold 18px \"Segoe UI\", Arial';\n        ctx.fillText('FIXED', m.w - 80, m.h - 18);\n      }\n\n      ctx.restore();\n\n      // update rotate\n      m.rotate += 0.01 + (m.solved ? 0.15 : 0.01);\n    });\n\n    // Conveyor and tiles\n    roundRect(ctx, conveyorArea.x, conveyorArea.y, conveyorArea.w, conveyorArea.h, 14);\n    ctx.fillStyle = '#EFF8F6';\n    ctx.fill();\n    ctx.strokeStyle = '#D1E6E3';\n    ctx.stroke();\n\n    // Draw a playful robot arm at left\n    ctx.save();\n    ctx.translate(20, conveyorArea.y - 30);\n    drawRobotArm(ctx, 0, 0);\n    ctx.restore();\n\n    // Tiles drawing (dragged ones drawn last)\n    const drawn = [];\n    for (const t of tiles) {\n      if (t.grabbed) continue;\n      drawTile(t);\n      drawn.push(t.id);\n    }\n    // grabbed tiles follow mouse\n    for (const t of tiles) {\n      if (!t.grabbed) continue;\n      t.x = mouse.x - t.offsetX;\n      t.y = mouse.y - t.offsetY;\n      drawTile(t, true);\n    }\n\n    // Highlight selections\n    for (const tid of selectedTiles) {\n      const t = tiles.find((x) => x.id === tid);\n      if (!t) continue;\n      ctx.save();\n      ctx.strokeStyle = '#6FAF86';\n      ctx.lineWidth = 3;\n      roundRect(ctx, t.x - 4, t.y - 4, t.w + 8, t.h + 8, 10);\n      ctx.stroke();\n      ctx.restore();\n    }\n\n    // Confetti\n    confettiParticles = confettiParticles.filter((p) => p.life < p.ttl);\n    for (const p of confettiParticles) {\n      p.life += (performance.now() - lastTick);\n      p.vy += 0.05;\n      p.x += p.vx;\n      p.y += p.vy;\n      ctx.fillStyle = p.color;\n      ctx.beginPath();\n      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // small footer controls text for accessibility and keyboard\n    ctx.fillStyle = '#3A4C44';\n    ctx.font = '12px \"Segoe UI\", Arial';\n    ctx.fillText('Keyboard: Tab to move, Enter to select/place, M to toggle audio, R to restart.', 18, HEIGHT - 14);\n\n    lastTick = performance.now();\n  }\n\n  function drawTile(t, floating = false) {\n    // rect with rounded corners\n    ctx.save();\n    // subtle shadow if floating\n    if (floating) {\n      ctx.shadowColor = 'rgba(0,0,0,0.15)';\n      ctx.shadowBlur = 8;\n      ctx.shadowOffsetY = 4;\n    } else {\n      ctx.shadowColor = 'transparent';\n      ctx.shadowBlur = 0;\n    }\n    ctx.fillStyle = TILE_COLOR;\n    roundRect(ctx, t.x, t.y, t.w, t.h, 10);\n    ctx.fill();\n    ctx.strokeStyle = TILE_BORDER;\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    ctx.fillStyle = TEXT_COLOR;\n    ctx.font = '22px \"Segoe UI\", Arial';\n    ctx.textAlign = 'center';\n    ctx.fillText(String(t.value), t.x + t.w / 2, t.y + t.h / 2 + 8);\n    ctx.restore();\n  }\n\n  function roundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n  }\n\n  function drawGear(ctx, radius, fill, stroke) {\n    // simple gear-like circle with teeth\n    ctx.beginPath();\n    for (let i = 0; i < 12; i++) {\n      const a = (i / 12) * Math.PI * 2;\n      const r = i % 2 === 0 ? radius : radius * 0.78;\n      const x = Math.cos(a) * r;\n      const y = Math.sin(a) * r;\n      if (i === 0) ctx.moveTo(x, y);\n      else ctx.lineTo(x, y);\n    }\n    ctx.closePath();\n    ctx.fillStyle = fill;\n    ctx.fill();\n    ctx.strokeStyle = stroke;\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    // center hole\n    ctx.beginPath();\n    ctx.arc(0, 0, radius * 0.35, 0, Math.PI * 2);\n    ctx.fillStyle = '#FFFFFF';\n    ctx.fill();\n    ctx.strokeStyle = '#C9D9CF';\n    ctx.stroke();\n  }\n\n  function drawRobotArm(ctx, x, y) {\n    ctx.save();\n    ctx.translate(x, y);\n    // base\n    ctx.fillStyle = '#E6EEF0';\n    roundRect(ctx, 0, 24, 58, 40, 8);\n    ctx.fill();\n    ctx.strokeStyle = '#C9D6D6';\n    ctx.stroke();\n    // arm segments\n    ctx.fillStyle = '#C9E3DE';\n    roundRect(ctx, 20, -10, 18, 50, 6);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.moveTo(38, 10);\n    ctx.lineTo(60, -8);\n    ctx.lineTo(72, 4);\n    ctx.lineTo(50, 22);\n    ctx.closePath();\n    ctx.fill();\n    ctx.fillStyle = '#8DB6AB';\n    ctx.beginPath();\n    ctx.arc(74, 6, 8, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  // ------- Animation Loop -------\n  function gameLoop() {\n    // update any animations\n    const now = performance.now();\n    // remove expired animations\n    animations = animations.filter((a) => (now - a.time) < a.duration + 200);\n    draw();\n    requestAnimationFrame(gameLoop);\n  }\n\n  // ------- Initialization -------\n  function init() {\n    try {\n      // attempt to create audio context now (may be blocked until user gesture)\n      audioContext = null; // delay until gesture\n      if (audioEnabled) {\n        // try but will be created on first interaction\n      }\n      buildLevel(level);\n      computeFocusList();\n      gameLoop();\n    } catch (e) {\n      console.error('Initialization error', e);\n      announce('An error occurred while starting the game.');\n    }\n  }\n\n  // Start on user interaction to enable audio according to browsers\n  function resumeOnUserGesture() {\n    if (!audioContext && audioAllowed) {\n      try {\n        ensureAudioContext();\n        // lower gain until user explicitly toggles\n        if (!audioEnabled && masterGain) masterGain.gain.value = 0.0;\n      } catch (e) {\n        console.warn('Audio resume failed', e);\n        audioEnabled = false;\n      }\n    }\n    // remove this listener\n    window.removeEventListener('pointerdown', resumeOnUserGesture);\n    window.removeEventListener('keydown', resumeOnUserGesture);\n  }\n  window.addEventListener('pointerdown', resumeOnUserGesture);\n  window.addEventListener('keydown', resumeOnUserGesture);\n\n  // Start game\n  init();\n})();\n---\n",
  "improve_response_tokens": 19463,
  "formatted_code": true,
  "formatting_response_tokens": 20500,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}