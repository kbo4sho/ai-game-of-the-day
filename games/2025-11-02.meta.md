# Game of the Day - 2025-11-02

## Metadata
- **Generated Date:** 2025-11-02
- **Generated Time:** 2025-11-02T00:29:30.489054
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-11-02.js
- **File Size:** 29883 bytes
- **Tokens Used:** 10088

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-11-02.js` - The playable game
- `2025-11-02.meta.json` - Machine-readable metadata
- `2025-11-02.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 21171

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 22980

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Drone Math Dash
  // Educational game for ages 7-9. Canvas + Web Audio only.
  // Renders inside element with ID "game-of-the-day-stage".
  // Strictly uses canvas drawing, Web Audio API oscillators for sound.
  //
  // Clear rules:
  // - Goal: Answer 10 questions correctly to WIN.
  // - Failure: 3 wrong answers = GAME OVER.
  // - Victory and Game Over screens show restart instructions/button.
  //
  // Accessibility & Controls:
  // - Mouse/touch to pick answers.
  // - Keyboard: keys 1-4 select answers; Enter confirms; Arrow keys move selection; M toggles sound; R restarts.
  // - Visual cues for sound status and selected answer.
  //
  // Note: All sizes and positions are computed to avoid overlapping text using ctx.measureText.
  // Proper padding for readable UI elements is respected.

  // Configuration constants
  const CANVAS_WIDTH = 720;
  const CANVAS_HEIGHT = 480;
  const UI_PADDING = 12; // minimum padding between UI elements
  const TARGET_CORRECT = 10;
  const MAX_WRONG = 3;
  const MIN_BODY_FONT = 14;
  const IMPORTANT_FONT = 20;

  // Utility for safe query
  const container = document.getElementById("game-of-the-day-stage");
  if (!container) {
    console.error("Container element with ID 'game-of-the-day-stage' not found.");
    return;
  }

  // Clear container and append canvas
  container.innerHTML = "";
  container.style.position = "relative";
  const canvas = document.createElement("canvas");
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;
  canvas.setAttribute("role", "img");
  canvas.setAttribute("aria-label", "Drone Math Dash game canvas");
  container.appendChild(canvas);
  const ctx = canvas.getContext("2d");

  // Audio setup with error handling
  let audioEnabled = true;
  let audioContext = null;
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (!AudioContext) throw new Error("Web Audio API is not supported in this browser.");
    audioContext = new AudioContext();
  } catch (e) {
    console.warn("AudioContext could not be created:", e);
    audioEnabled = false;
    audioContext = null;
  }

  // Create a subtle background ambient (gentle whoosh) if audio enabled
  let ambientGain = null;
  if (audioEnabled && audioContext) {
    try {
      ambientGain = audioContext.createGain();
      ambientGain.gain.value = 0.02; // very gentle
      ambientGain.connect(audioContext.destination);

      // low oscillator for subtle hum
      const osc = audioContext.createOscillator();
      const lfo = audioContext.createOscillator();
      const lfoGain = audioContext.createGain();

      osc.type = "sine";
      osc.frequency.value = 120; // low gentle tone
      lfo.frequency.value = 0.2; // slow wobble
      lfoGain.gain.value = 20; // modulates freq

      lfo.connect(lfoGain);
      lfoGain.connect(osc.frequency);
      osc.connect(ambientGain);

      osc.start();
      lfo.start();
      // retain references to stop on restart if needed
      audioContext._ambientNodes = { osc, lfo, lfoGain };
    } catch (e) {
      console.warn("Ambient audio could not be started:", e);
    }
  }

  function playTone(freq = 440, type = "sine", duration = 0.2, volume = 0.15) {
    if (!audioEnabled || !audioContext) return;
    try {
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();

      osc.type = type;
      osc.frequency.value = freq;
      gain.gain.value = volume;

      const filter = audioContext.createBiquadFilter();
      filter.type = "lowpass";
      filter.frequency.value = 5000;

      osc.connect(filter);
      filter.connect(gain);
      gain.connect(audioContext.destination);

      const now = audioContext.currentTime;
      gain.gain.setValueAtTime(volume, now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);

      osc.start(now);
      osc.stop(now + duration + 0.02);
    } catch (e) {
      console.warn("playTone error:", e);
    }
  }

  function playCorrectSound() {
    // Pleasant rising arpeggio
    playTone(880, "sine", 0.12, 0.08);
    setTimeout(() => playTone(1320, "sine", 0.12, 0.07), 120);
    setTimeout(() => playTone(1760, "sine", 0.14, 0.06), 250);
  }

  function playWrongSound() {
    // Short buzz
    playTone(240, "square", 0.18, 0.16);
    setTimeout(() => playTone(180, "sawtooth", 0.12, 0.12), 120);
  }

  // Game state
  const state = {
    running: false,
    correctCount: 0,
    wrongCount: 0,
    lives: MAX_WRONG,
    goal: TARGET_CORRECT,
    question: null,
    answers: [],
    selectedIndex: 0,
    message: "Welcome! Press Start to play.",
    phase: "menu", // 'menu', 'playing', 'victory', 'gameover'
    lastActionTime: 0,
    drone: {
      x: 120,
      y: 160,
      angle: 0,
      bob: 0,
      targetX: 360,
      targetY: 200,
      speed: 80, // pixels per second
      collected: 0
    },
    clouds: [],
    soundOn: audioEnabled,
    keyboardBuffer: null
  };

  // Generate some clouds for background with calming palette
  function initClouds() {
    state.clouds = [];
    for (let i = 0; i < 6; i++) {
      state.clouds.push({
        x: Math.random() * CANVAS_WIDTH,
        y: 20 + Math.random() * 120,
        size: 60 + Math.random() * 120,
        speed: 8 + Math.random() * 15,
        offset: Math.random() * 1000
      });
    }
  }

  initClouds();

  // Helpers for math questions
  function generateQuestion() {
    // Focus on addition within 20 and number bonds
    // Randomly choose addition or subtraction but ensure simple
    const a = Math.floor(Math.random() * 11) + 1; // 1..11
    const b = Math.floor(Math.random() * 9) + 1; // 1..9
    const op = Math.random() < 0.7 ? "+" : "-";
    let q, answer;
    if (op === "+") {
      q = `${a} + ${b}`;
      answer = a + b;
    } else {
      // ensure non-negative
      const big = Math.max(a, b);
      const small = Math.min(a, b);
      q = `${big} - ${small}`;
      answer = big - small;
    }
    // Create 4 answers including correct one
    const answers = new Set();
    answers.add(answer);
    while (answers.size < 4) {
      const perturb = Math.floor((Math.random() * 9) - 4); // -4..4
      const candidate = answer + perturb;
      if (candidate >= 0 && !answers.has(candidate)) answers.add(candidate);
    }
    const arr = Array.from(answers);
    // Shuffle
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return { q, answer, choices: arr };
  }

  // Start or restart the game
  function startGame() {
    state.running = true;
    state.correctCount = 0;
    state.wrongCount = 0;
    state.lives = MAX_WRONG;
    state.phase = "playing";
    state.selectedIndex = 0;
    state.drone = {
      x: 120,
      y: 160,
      angle: 0,
      bob: 0,
      targetX: 360 + Math.random() * 200 - 100,
      targetY: 140 + Math.random() * 60,
      speed: 120,
      collected: 0
    };
    initClouds();
    nextQuestion();
    if (audioContext && audioContext.state === "suspended" && state.soundOn) {
      // Try to resume audio on user interaction
      audioContext.resume().catch(() => {});
    }
  }

  function nextQuestion() {
    const generated = generateQuestion();
    state.question = generated.q;
    state.answers = generated.choices;
    state.correctAnswer = generated.answer;
    state.selectedIndex = 0;
    state.message = "Choose the correct answer!";
    // Move drone to a new random target so visual collects differently
    state.drone.targetX = 220 + Math.random() * 280;
    state.drone.targetY = 100 + Math.random() * 160;
  }

  // Interaction handlers
  function getAnswerButtonRects() {
    // Layout four circular buttons neatly in the lower half; ensure spacing
    const btns = [];
    const radius = 42;
    // positions: two left two right in two columns with vertical spacing
    const cxLeft = CANVAS_WIDTH * 0.28;
    const cxRight = CANVAS_WIDTH * 0.72;
    const cyTop = CANVAS_HEIGHT * 0.55;
    const cyGap = 92;
    btns.push({ x: cxLeft, y: cyTop, r: radius });
    btns.push({ x: cxRight, y: cyTop, r: radius });
    btns.push({ x: cxLeft, y: cyTop + cyGap, r: radius });
    btns.push({ x: cxRight, y: cyTop + cyGap, r: radius });
    return btns;
  }

  function pointerToCanvas(e) {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX || (e.touches && e.touches[0].clientX)) - rect.left;
    const y = (e.clientY || (e.touches && e.touches[0].clientY)) - rect.top;
    return { x: x * (canvas.width / rect.width), y: y * (canvas.height / rect.height) };
  }

  function handleClick(e) {
    if (!state.running && state.phase === "menu") {
      // If menu and clicked in start button area, start
      const pos = pointerToCanvas(e);
      if (isInsideStartButton(pos)) {
        startGame();
      }
      return;
    }
    const pos = pointerToCanvas(e);
    if (state.phase === "playing") {
      // check answer buttons
      const rects = getAnswerButtonRects();
      for (let i = 0; i < rects.length; i++) {
        const dx = pos.x - rects[i].x;
        const dy = pos.y - rects[i].y;
        if (dx * dx + dy * dy <= rects[i].r * rects[i].r) {
          selectAnswer(i, true);
          return;
        }
      }
    } else if (state.phase === "victory" || state.phase === "gameover") {
      // restart button
      if (isInsideRestartButton(pos)) {
        startGame();
        return;
      }
    }
  }

  function isInsideStartButton(pos) {
    // Start button centered in menu
    const w = 220;
    const h = 56;
    const x = (CANVAS_WIDTH - w) / 2;
    const y = CANVAS_HEIGHT * 0.62;
    return pos.x >= x && pos.x <= x + w && pos.y >= y && pos.y <= y + h;
  }

  function isInsideRestartButton(pos) {
    const w = 220;
    const h = 56;
    const x = (CANVAS_WIDTH - w) / 2;
    const y = CANVAS_HEIGHT * 0.66;
    return pos.x >= x && pos.x <= x + w && pos.y >= y && pos.y <= y + h;
  }

  function selectAnswer(index, submitImmediately = false) {
    state.selectedIndex = index;
    if (submitImmediately) {
      submitAnswer();
    }
  }

  function submitAnswer() {
    const chosen = state.answers[state.selectedIndex];
    if (chosen === undefined) return;
    if (chosen === state.correctAnswer) {
      // Correct
      state.correctCount += 1;
      state.drone.collected += 1;
      state.message = "Great! +1";
      if (state.soundOn) playCorrectSound();
      if (state.correctCount >= state.goal) {
        state.phase = "victory";
        state.running = false;
        state.message = "You reached the goal!";
      } else {
        // small delay before next question to show drone animation
        setTimeout(() => {
          nextQuestion();
        }, 550);
      }
    } else {
      // Wrong
      state.wrongCount += 1;
      state.lives = Math.max(0, MAX_WRONG - state.wrongCount);
      state.message = "Oops! That's not right.";
      if (state.soundOn) playWrongSound();
      // Flash or small shake effect by moving drone away
      state.drone.targetX = 80 + Math.random() * 560;
      state.drone.targetY = 100 + Math.random() * 180;
      if (state.wrongCount >= MAX_WRONG) {
        state.phase = "gameover";
        state.running = false;
      } else {
        // next question after short delay
        setTimeout(() => {
          nextQuestion();
        }, 600);
      }
    }
  }

  // Keyboard controls
  function handleKeyDown(e) {
    if (e.key === "m" || e.key === "M") {
      e.preventDefault();
      state.soundOn = !state.soundOn;
      // mute/unmute audio by adjusting ambient gain if available
      if (audioContext && audioContext._ambientNodes && ambientGain) {
        ambientGain.gain.value = state.soundOn ? 0.02 : 0;
      }
      return;
    }
    if (e.key === "r" || e.key === "R") {
      // Restart
      e.preventDefault();
      startGame();
      return;
    }
    if (state.phase === "menu") {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        startGame();
      }
      return;
    }
    if (state.phase === "victory" || state.phase === "gameover") {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        startGame();
      }
      return;
    }
    if (state.phase === "playing") {
      if (["1", "2", "3", "4"].includes(e.key)) {
        const idx = parseInt(e.key, 10) - 1;
        selectAnswer(idx, true);
        e.preventDefault();
        return;
      }
      if (e.key === "ArrowLeft" || e.key === "ArrowUp") {
        // move selection left/up
        e.preventDefault();
        state.selectedIndex = (state.selectedIndex + 4 - 1) % 4;
      } else if (e.key === "ArrowRight" || e.key === "ArrowDown") {
        e.preventDefault();
        state.selectedIndex = (state.selectedIndex + 1) % 4;
      } else if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        submitAnswer();
      }
    }
  }

  // Draw helpers: text measurement and wrapped text to ensure no overlaps
  function drawRoundedRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  function wrapText(text, maxWidth, font) {
    ctx.font = font;
    const words = text.split(" ");
    const lines = [];
    let current = "";
    for (let w of words) {
      const test = current ? current + " " + w : w;
      const metrics = ctx.measureText(test);
      if (metrics.width > maxWidth && current) {
        lines.push(current);
        current = w;
      } else {
        current = test;
      }
    }
    if (current) lines.push(current);
    return lines;
  }

  // Drone drawing
  function drawDrone(x, y, bob, angle) {
    // Draw a whimsical drone using arcs and rects
    ctx.save();
    ctx.translate(x, y + Math.sin(bob) * 6);
    ctx.rotate(angle);

    // body shadow
    ctx.fillStyle = "rgba(0,0,0,0.06)";
    ctx.beginPath();
    ctx.ellipse(0, 38, 54, 12, 0, 0, Math.PI * 2);
    ctx.fill();

    // main body
    ctx.fillStyle = "#A7D3FF"; // pastel blue
    ctx.beginPath();
    ctx.ellipse(0, 0, 70, 36, 0, 0, Math.PI * 2);
    ctx.fill();

    // goggle
    ctx.fillStyle = "#2C3E50";
    ctx.fillRect(-28, -10, 56, 18);
    ctx.fillStyle = "#FFFFFF";
    ctx.fillRect(-22, -7, 44, 12);

    // propellers: four arms with little discs
    const armColor = "#F8B195";
    for (let i = 0; i < 4; i++) {
      const a = (i * Math.PI) / 2;
      const ax = Math.cos(a) * 50;
      const ay = Math.sin(a) * 18;
      ctx.strokeStyle = armColor;
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(18 * Math.cos(a), 10 * Math.sin(a));
      ctx.lineTo(ax, ay - 8);
      ctx.stroke();

      // prop disc
      ctx.fillStyle = "#FFE9C7";
      ctx.beginPath();
      ctx.arc(ax, ay - 16, 14, 0, Math.PI * 2);
      ctx.fill();

      // small rotating blade, wacky
      ctx.fillStyle = "rgba(0,0,0,0.08)";
      ctx.beginPath();
      ctx.ellipse(ax, ay - 16, 20, 6, Math.sin(bob + i) * 0.6, 0, Math.PI * 2);
      ctx.fill();
    }

    // smiley decal
    ctx.fillStyle = "#F67280";
    ctx.beginPath();
    ctx.arc(0, 12, 6, 0, Math.PI);
    ctx.strokeStyle = "#F67280";
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.restore();
  }

  // Draw cloud
  function drawCloud(c) {
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.beginPath();
    ctx.ellipse(c.x, c.y, c.size * 0.6, c.size * 0.35, 0, 0, Math.PI * 2);
    ctx.ellipse(c.x + c.size * 0.25, c.y - c.size * 0.08, c.size * 0.45, c.size * 0.25, 0, 0, Math.PI * 2);
    ctx.ellipse(c.x - c.size * 0.2, c.y - c.size * 0.08, c.size * 0.45, c.size * 0.25, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  // Main render loop
  let lastTimestamp = 0;
  function update(dt) {
    // Move clouds
    for (let c of state.clouds) {
      c.x += (c.speed * dt) / 1000;
      if (c.x - c.size * 0.8 > CANVAS_WIDTH) {
        c.x = -c.size * 0.8;
        c.y = 10 + Math.random() * 140;
      }
    }
    if (state.phase === "playing") {
      // Drone movement toward target
      const d = state.drone;
      const dx = d.targetX - d.x;
      const dy = d.targetY - d.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist > 2) {
        const step = (d.speed * dt) / 1000;
        d.x += (dx / dist) * Math.min(step, dist);
        d.y += (dy / dist) * Math.min(step, dist);
      }
      d.bob += dt / 250;
      d.angle = Math.sin(d.bob) * 0.06;
    } else {
      // Idle bob
      state.drone.bob += dt / 500;
      state.drone.angle = Math.sin(state.drone.bob) * 0.03;
    }
  }

  function draw() {
    // Background gradient
    const g = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
    g.addColorStop(0, "#C9F0FF"); // light sky
    g.addColorStop(1, "#F8FFF4"); // soft bottom
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // Draw clouds
    for (let c of state.clouds) {
      drawCloud(c);
    }

    // Ground silhouette - whimsical rounded hills
    ctx.fillStyle = "#D6F2D6";
    ctx.beginPath();
    ctx.moveTo(0, CANVAS_HEIGHT);
    ctx.quadraticCurveTo(120, 360, 240, 400);
    ctx.quadraticCurveTo(420, 460, 720, 380);
    ctx.lineTo(CANVAS_WIDTH, CANVAS_HEIGHT);
    ctx.closePath();
    ctx.fill();

    // Score UI top-left
    ctx.font = `${MIN_BODY_FONT}px sans-serif`;
    const scoreText = `Stars: ${state.correctCount}/${state.goal}`;
    const scoreMetrics = ctx.measureText(scoreText);
    const scoreW = scoreMetrics.width + UI_PADDING * 2;
    const scoreH = 34;
    const scoreX = UI_PADDING;
    const scoreY = UI_PADDING;
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    drawRoundedRect(scoreX, scoreY, scoreW, scoreH, 8);
    ctx.fillStyle = "#2C3E50";
    ctx.font = `${MIN_BODY_FONT}px sans-serif`;
    ctx.fillText(scoreText, scoreX + UI_PADDING, scoreY + scoreH / 2 + 5);

    // Lives UI top-right
    const livesText = `Lives: ${Math.max(0, state.lives)}`;
    ctx.font = `${MIN_BODY_FONT}px sans-serif`;
    const livesMetrics = ctx.measureText(livesText);
    const livesW = livesMetrics.width + UI_PADDING * 2 + 28;
    const livesH = 34;
    const livesX = CANVAS_WIDTH - livesW - UI_PADDING;
    const livesY = UI_PADDING;
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    drawRoundedRect(livesX, livesY, livesW, livesH, 8);
    ctx.fillStyle = "#2C3E50";
    ctx.fillText(livesText, livesX + UI_PADDING, livesY + livesH / 2 + 5);

    // Sound indicator (small speaker icon) inside lives area, to the right
    ctx.fillStyle = state.soundOn ? "#4CAF50" : "#D32F2F";
    const spX = livesX + livesW - UI_PADDING - 18;
    const spY = livesY + livesH / 2 - 6;
    ctx.beginPath();
    ctx.moveTo(spX, spY);
    ctx.lineTo(spX + 6, spY);
    ctx.lineTo(spX + 12, spY - 8);
    ctx.lineTo(spX + 12, spY + 8);
    ctx.lineTo(spX + 6, spY);
    ctx.fill();

    // Question box centered top, ensure spacing from score and lives
    ctx.font = `${IMPORTANT_FONT}px sans-serif`;
    const questionText = state.phase === "playing" ? state.question : "Drone Math Dash";
    const qMetrics = ctx.measureText(questionText);
    const qW = qMetrics.width + UI_PADDING * 2;
    const qH = 44;
    const qX = (CANVAS_WIDTH - qW) / 2;
    const qY = UI_PADDING + 6;
    // Ensure top elements don't overlap: maintain at least UI_PADDING distance from top boxes
    const topOccupiedY = Math.max(scoreY + scoreH, livesY + livesH);
    const minQY = topOccupiedY + UI_PADDING;
    const questionY = Math.max(qY, minQY);
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    drawRoundedRect(qX, questionY, qW, qH, 8);
    ctx.fillStyle = "#0A3D62";
    ctx.fillText(questionText, qX + UI_PADDING, questionY + qH / 2 + 6);

    // Drone
    drawDrone(state.drone.x, state.drone.y, state.drone.bob, state.drone.angle);

    // Target star the drone collects (visual)
    for (let i = 0; i < state.drone.collected; i++) {
      ctx.save();
      const sx = 16 + i * 22;
      const sy = CANVAS_HEIGHT - 12;
      ctx.fillStyle = "#FFD166";
      ctx.beginPath();
      ctx.arc(sx, sy, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // Answer buttons
    const rects = getAnswerButtonRects();
    ctx.font = `${MIN_BODY_FONT + 2}px sans-serif`;
    for (let i = 0; i < rects.length; i++) {
      const r = rects[i];
      // background circle
      ctx.beginPath();
      ctx.fillStyle = i === state.selectedIndex ? "rgba(126,214,223,0.95)" : "rgba(255,255,255,0.95)";
      ctx.shadowColor = "rgba(0,0,0,0.08)";
      ctx.shadowBlur = 8;
      ctx.arc(r.x, r.y, r.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      // number label top-left inside circle
      ctx.fillStyle = "#2C3E50";
      ctx.font = `${MIN_BODY_FONT}px sans-serif`;
      const label = `${i + 1}.`;
      ctx.fillText(label, r.x - r.r + 12, r.y - r.r + 20);
      // answer text centered
      const ansText = state.answers[i] !== undefined ? String(state.answers[i]) : "";
      ctx.font = `${IMPORTANT_FONT - 2}px sans-serif`;
      const metrics = ctx.measureText(ansText);
      ctx.fillText(ansText, r.x - metrics.width / 2, r.y + 8);
      // visual focus ring if selected
      if (i === state.selectedIndex) {
        ctx.strokeStyle = "#1098F7";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.r + 4, 0, Math.PI * 2);
        ctx.stroke();
      }
    }

    // Instruction area bottom center - ensure not overlapping with answer buttons
    const instructions = [
      "Controls: Click answers or use keys 1-4, Arrow keys to move, Enter to submit.",
      "M to toggle sound. R to restart.",
      state.message
    ];
    ctx.font = `${MIN_BODY_FONT}px sans-serif`;
    const maxInstrW = CANVAS_WIDTH * 0.88;
    const lines = [];
    for (let line of instructions) {
      const wrapped = wrapText(line, maxInstrW, `${MIN_BODY_FONT}px sans-serif`);
      wrapped.forEach(l => lines.push(l));
    }
    // compute instruction box height
    const lineHeight = 18;
    const instrH = lines.length * lineHeight + UI_PADDING * 2;
    const instrW = Math.min(maxInstrW, 640);
    const instrX = (CANVAS_WIDTH - instrW) / 2;
    const instrY = CANVAS_HEIGHT - instrH - UI_PADDING;
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    drawRoundedRect(instrX, instrY, instrW, instrH, 8);
    ctx.fillStyle = "#1B262C";
    for (let i = 0; i < lines.length; i++) {
      ctx.fillText(lines[i], instrX + UI_PADDING, instrY + UI_PADDING + (i + 1) * lineHeight - 6);
    }

    // If paused or in menu, draw overlay
    if (state.phase === "menu") {
      drawMenu();
    } else if (state.phase === "victory") {
      drawVictory();
    } else if (state.phase === "gameover") {
      drawGameOver();
    }
  }

  // Menu screen
  function drawMenu() {
    // Soft translucent overlay
    ctx.fillStyle = "rgba(6, 30, 50, 0.18)";
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    const title = "Drone Math Dash";
    ctx.font = `30px sans-serif`;
    ctx.fillStyle = "#FFFFFF";
    const tm = ctx.measureText(title);
    const titleX = (CANVAS_WIDTH - tm.width) / 2;
    const titleY = CANVAS_HEIGHT * 0.28;
    // shadow box behind title for readability
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    const boxW = tm.width + UI_PADDING * 2;
    const boxH = 54;
    const boxX = titleX - UI_PADDING;
    const boxY = titleY - 36;
    drawRoundedRect(boxX, boxY, boxW, boxH, 10);
    ctx.fillStyle = "#083D77";
    ctx.fillText(title, titleX, titleY);

    // Description text
    ctx.font = `${MIN_BODY_FONT + 2}px sans-serif`;
    const desc = "Help the drone gather " + state.goal + " stars by solving math problems. You can make up to " + MAX_WRONG + " mistakes.";
    const lines = wrapText(desc, CANVAS_WIDTH * 0.8, `${MIN_BODY_FONT + 2}px sans-serif`);
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    const descW = CANVAS_WIDTH * 0.75;
    const descH = lines.length * 18 + UI_PADDING * 2;
    const descX = (CANVAS_WIDTH - descW) / 2;
    const descY = titleY + 20;
    drawRoundedRect(descX, descY, descW, descH, 8);
    ctx.fillStyle = "#083D77";
    for (let i = 0; i < lines.length; i++) {
      ctx.fillText(lines[i], descX + UI_PADDING, descY + UI_PADDING + (i + 1) * 18 - 6);
    }

    // Start button
    const w = 220;
    const h = 56;
    const x = (CANVAS_WIDTH - w) / 2;
    const y = CANVAS_HEIGHT * 0.62;
    ctx.fillStyle = "#5EEAD4";
    drawRoundedRect(x, y, w, h, 12);
    ctx.fillStyle = "#05386B";
    ctx.font = `22px sans-serif`;
    const startText = "Start Adventure";
    const m = ctx.measureText(startText);
    ctx.fillText(startText, x + (w - m.width) / 2, y + h / 2 + 8);

    // Small accessibility note
    ctx.font = `${MIN_BODY_FONT}px sans-serif`;
    const note = "Tip: Press Enter to start. Use keys 1-4 to pick answers.";
    const nm = ctx.measureText(note);
    ctx.fillStyle = "#FFFFFF";
    ctx.fillText(note, (CANVAS_WIDTH - nm.width) / 2, y + h + 32);
  }

  function drawVictory() {
    // translucent overlay
    ctx.fillStyle = "rgba(0, 0, 0, 0.35)";
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    const title = "You Win!";
    ctx.font = `36px sans-serif`;
    ctx.fillStyle = "#FFF7B2";
    const m = ctx.measureText(title);
    const x = (CANVAS_WIDTH - m.width) / 2;
    const y = CANVAS_HEIGHT * 0.26;
    ctx.fillText(title, x, y);

    ctx.font = `${MIN_BODY_FONT + 2}px sans-serif`;
    const lines = wrapText(`Hooray! The drone collected ${state.correctCount} stars. Great job solving the problems!`, CANVAS_WIDTH * 0.8, `${MIN_BODY_FONT + 2}px sans-serif`);
    const boxW = CANVAS_WIDTH * 0.8;
    const boxH = lines.length * 18 + UI_PADDING * 2;
    const boxX = (CANVAS_WIDTH - boxW) / 2;
    const boxY = y + 12;
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    drawRoundedRect(boxX, boxY, boxW, boxH, 10);
    ctx.fillStyle = "#0A3D62";
    for (let i = 0; i < lines.length; i++) {
      ctx.fillText(lines[i], boxX + UI_PADDING, boxY + UI_PADDING + (i + 1) * 18 - 6);
    }

    // Restart button
    const bw = 220;
    const bh = 56;
    const bx = (CANVAS_WIDTH - bw) / 2;
    const by = boxY + boxH + 24;
    ctx.fillStyle = "#B2F7EF";
    drawRoundedRect(bx, by, bw, bh, 10);
    ctx.fillStyle = "#05386B";
    ctx.font = `20px sans-serif`;
    const bt = "Play Again";
    const bm = ctx.measureText(bt);
    ctx.fillText(bt, bx + (bw - bm.width) / 2, by + bh / 2 + 8);

    // Instruction note for keyboard restart
    ctx.font = `${MIN_BODY_FONT}px sans-serif`;
    const note = "Press 'R' or Enter to play again.";
    const nm = ctx.measureText(note);
    ctx.fillStyle = "#FFFFFF";
    ctx.fillText(note, (CANVAS_WIDTH - nm.width) / 2, by + bh + 28);
  }

  function drawGameOver() {
    ctx.fillStyle = "rgba(0, 0, 0, 0.45)";
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    const title = "Game Over";
    ctx.font = `36px sans-serif`;
    ctx.fillStyle = "#FFD6D6";
    const m = ctx.measureText(title);
    const x = (CANVAS_WIDTH - m.width) / 2;
    const y = CANVAS_HEIGHT * 0.26;
    ctx.fillText(title, x, y);

    ctx.font = `${MIN_BODY_FONT + 2}px sans-serif`;
    const lines = wrapText(`Oh no! The drone ran out of lives. You answered ${state.correctCount} correctly. Try again to reach ${state.goal}!`, CANVAS_WIDTH * 0.8, `${MIN_BODY_FONT + 2}px sans-serif`);
    const boxW = CANVAS_WIDTH * 0.8;
    const boxH = lines.length * 18 + UI_PADDING * 2;
    const boxX = (CANVAS_WIDTH - boxW) / 2;
    const boxY = y + 12;
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    drawRoundedRect(boxX, boxY, boxW, boxH, 10);
    ctx.fillStyle = "#0A3D62";
    for (let i = 0; i < lines.length; i++) {
      ctx.fillText(lines[i], boxX + UI_PADDING, boxY + UI_PADDING + (i + 1) * 18 - 6);
    }

    // Restart button
    const bw = 220;
    const bh = 56;
    const bx = (CANVAS_WIDTH - bw) / 2;
    const by = boxY + boxH + 24;
    ctx.fillStyle = "#FFD1E6";
    drawRoundedRect(bx, by, bw, bh, 10);
    ctx.fillStyle = "#05386B";
    ctx.font = `20px sans-serif`;
    const bt = "Try Again";
    const bm = ctx.measureText(bt);
    ctx.fillText(bt, bx + (bw - bm.width) / 2, by + bh / 2 + 8);

    ctx.font = `${MIN_BODY_FONT}px sans-serif`;
    const note = "Press 'R' or Enter to try again.";
    const nm = ctx.measureText(note);
    ctx.fillStyle = "#FFFFFF";
    ctx.fillText(note, (CANVAS_WIDTH - nm.width) / 2, by + bh + 28);
  }

  // Main loop with requestAnimationFrame
  function loop(ts) {
    if (!lastTimestamp) lastTimestamp = ts;
    const dt = ts - lastTimestamp;
    lastTimestamp = ts;

    try {
      update(dt);
      draw();
    } catch (e) {
      console.error("Render error:", e);
    }

    requestAnimationFrame(loop);
  }

  // Event listeners
  canvas.addEventListener("click", handleClick);
  canvas.addEventListener("touchstart", function (e) {
    handleClick(e);
    e.preventDefault();
  }, { passive: false });

  window.addEventListener("keydown", handleKeyDown);

  // Start with menu
  state.phase = "menu";
  state.running = false;
  state.message = "Press Start or Enter to begin!";
  // Begin render loop
  requestAnimationFrame(loop);

  // Accessibility: expose simple API on container to restart programmatically
  container.restartGame = () => {
    startGame();
  };

  // Clean up audio nodes on unload to avoid console warnings
  window.addEventListener("beforeunload", () => {
    try {
      if (audioContext) {
        if (audioContext._ambientNodes) {
          audioContext._ambientNodes.osc.disconnect();
          audioContext._ambientNodes.lfo.disconnect();
          audioContext._ambientNodes.lfoGain.disconnect();
        }
        audioContext.close && audioContext.close();
      }
    } catch (e) {
      // ignore
    }
  });
})();
---

