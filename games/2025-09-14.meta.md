# Game of the Day - 2025-09-14

## Metadata
- **Generated Date:** 2025-09-14
- **Generated Time:** 2025-09-14T00:28:08.715401
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-14.js
- **File Size:** 25894 bytes
- **Tokens Used:** 9253

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-14.js` - The playable game
- `2025-09-14.meta.json` - Machine-readable metadata
- `2025-09-14.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 20095

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 22935

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Educational Math Game: Machine Mash
  // Renders a 720x480 canvas into #game-of-the-day-stage
  // Uses Web Audio API (oscillators) for sounds, full keyboard accessibility,
  // and canvas-only visuals. Designed for kids ages 7-9.

  // Ensure the target container exists
  const container = document.getElementById("game-of-the-day-stage");
  if (!container) {
    console.error("Game container '#game-of-the-day-stage' not found.");
    return;
  }

  // Clear container and create canvas
  container.innerHTML = "";
  const canvas = document.createElement("canvas");
  canvas.width = 720;
  canvas.height = 480;
  canvas.style.width = "720px";
  canvas.style.height = "480px";
  canvas.setAttribute("role", "img");
  canvas.setAttribute(
    "aria-label",
    "Machine Mash math game. Use left and right arrows or keys 1,2,3 to pick a machine. Press Space to catch a number. Press A to toggle audio."
  );
  canvas.tabIndex = 0; // focusable for keyboard
  container.appendChild(canvas);

  const ctx = canvas.getContext("2d");
  if (!ctx) {
    console.error("Canvas context not available.");
    return;
  }

  // Game area constants
  const W = 720;
  const H = 480;

  // Audio setup
  let audioEnabled = true;
  let audioAllowedByUser = false;
  let AudioCtx = window.AudioContext || window.webkitAudioContext || null;
  let audioCtx = null;
  let masterGain = null;
  let bgOsc = null;
  let bgFilter = null;

  function initAudioOnUserGesture() {
    if (!AudioCtx) {
      audioEnabled = false;
      return;
    }
    if (audioCtx) return;
    try {
      audioCtx = new AudioCtx();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.12; // overall volume
      masterGain.connect(audioCtx.destination);

      // Gentle background hum: low oscillator + filter
      bgOsc = audioCtx.createOscillator();
      bgOsc.type = "sine";
      bgOsc.frequency.value = 110; // low hum
      bgFilter = audioCtx.createBiquadFilter();
      bgFilter.type = "lowpass";
      bgFilter.frequency.value = 700;
      const bgGain = audioCtx.createGain();
      bgGain.gain.value = 0.06;
      bgOsc.connect(bgFilter);
      bgFilter.connect(bgGain);
      bgGain.connect(masterGain);
      bgOsc.start(0);
      audioAllowedByUser = true;
    } catch (e) {
      console.warn("AudioContext failed to initialize:", e);
      audioEnabled = false;
      audioCtx = null;
    }
  }

  function toggleAudio() {
    if (!AudioCtx) {
      audioEnabled = false;
      return;
    }
    if (!audioCtx) {
      initAudioOnUserGesture();
      return;
    }
    if (audioCtx.state === "suspended") {
      audioCtx.resume().catch((e) => {
        console.warn("AudioContext resume failed:", e);
        audioEnabled = false;
      });
    }
    audioEnabled = !audioEnabled;
    if (masterGain) {
      masterGain.gain.value = audioEnabled ? 0.12 : 0.0;
    }
  }

  function safeCreateOscillator() {
    if (!audioCtx) return null;
    try {
      const osc = audioCtx.createOscillator();
      return osc;
    } catch (e) {
      console.warn("Oscillator creation failed:", e);
      return null;
    }
  }

  function playClickTone() {
    if (!audioEnabled || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const o = safeCreateOscillator();
      const g = audioCtx.createGain();
      if (!o) return;
      o.type = "triangle";
      o.frequency.value = 880;
      g.gain.value = 0.001;
      o.connect(g);
      g.connect(masterGain);
      g.gain.setValueAtTime(0.001, now);
      g.gain.linearRampToValueAtTime(0.08, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
      o.start(now);
      o.stop(now + 0.2);
    } catch (e) {
      console.warn("playClickTone error:", e);
    }
  }

  function playCorrectSequence() {
    if (!audioEnabled || !audioCtx) return;
    try {
      const notes = [880, 990, 1176]; // triad ascending
      let t = audioCtx.currentTime;
      notes.forEach((f, i) => {
        const o = safeCreateOscillator();
        if (!o) return;
        const g = audioCtx.createGain();
        o.type = i === notes.length - 1 ? "sine" : "triangle";
        o.frequency.value = f;
        o.connect(g);
        g.connect(masterGain);
        g.gain.setValueAtTime(0.0001, t);
        g.gain.exponentialRampToValueAtTime(0.08, t + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, t + 0.12);
        o.start(t);
        o.stop(t + 0.12);
        t += 0.08;
      });
    } catch (e) {
      console.warn("playCorrectSequence error:", e);
    }
  }

  function playWrongBuzz() {
    if (!audioEnabled || !audioCtx) return;
    try {
      const o = safeCreateOscillator();
      if (!o) return;
      const g = audioCtx.createGain();
      const f = audioCtx.createBiquadFilter();
      f.type = "lowpass";
      f.frequency.value = 1200;
      o.type = "sawtooth";
      o.frequency.value = 220;
      o.connect(f);
      f.connect(g);
      g.connect(masterGain);
      const now = audioCtx.currentTime;
      g.gain.setValueAtTime(0.001, now);
      g.gain.linearRampToValueAtTime(0.09, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
      o.start(now);
      o.stop(now + 0.35);
    } catch (e) {
      console.warn("playWrongBuzz error:", e);
    }
  }

  // Game state
  let lastTime = performance.now();
  let spawnTimer = 0;
  let spawnInterval = 1400; // ms between numbers
  let balls = [];
  let selectorIndex = 1; // between 0 and 2 (three machines)
  let catching = false;
  let catchCooldown = 0;
  let level = 0;
  let paused = false;
  let showHints = true;
  let speakerVisible = true;

  const levels = [
    // Each level: machines ops, target, goal correctness, allowed misses
    {
      label: "Starter Sparks",
      machines: [
        { op: (n) => n + 1, label: "+1", color: "#FFD166" },
        { op: (n) => n + 2, label: "+2", color: "#06D6A0" },
        { op: (n) => n + 3, label: "+3", color: "#4CC9F0" },
      ],
      target: 7,
      goal: 4,
      allowedMisses: 5,
      spawnInterval: 1500,
    },
    {
      label: "Gear Shift",
      machines: [
        { op: (n) => n - 1, label: "-1", color: "#FF6B6B" },
        { op: (n) => n + 2, label: "+2", color: "#FFD166" },
        { op: (n) => n * 2, label: "×2", color: "#06D6A0" },
      ],
      target: 8,
      goal: 5,
      allowedMisses: 5,
      spawnInterval: 1300,
    },
    {
      label: "Turbo Mix",
      machines: [
        { op: (n) => Math.max(1, n - 2), label: "-2", color: "#FFB4A2" },
        { op: (n) => n * 2, label: "×2", color: "#CBF3F0" },
        { op: (n) => n + 4, label: "+4", color: "#90BE6D" },
      ],
      target: 10,
      goal: 6,
      allowedMisses: 6,
      spawnInterval: 1200,
    },
  ];

  // Score and counters
  let correctCount = 0;
  let missedCount = 0;
  let totalCaught = 0;

  // Conveyor / machine layout
  const beltY = 160;
  const chuteY = 220;
  const machineY = 260;
  const machinesX = [120, 360, 600];
  const machineWidth = 160;
  const machineHeight = 140;

  // For friendly visual animations
  let wiggle = 0;

  // Utility functions
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function resetLevel(lvlIndex = 0) {
    level = Math.max(0, Math.min(lvlIndex, levels.length - 1));
    balls = [];
    selectorIndex = 1;
    catching = false;
    catchCooldown = 0;
    correctCount = 0;
    missedCount = 0;
    totalCaught = 0;
    spawnTimer = 0;
    spawnInterval = levels[level].spawnInterval || 1400;
    paused = false;
  }

  resetLevel(0);

  // Ball object: moves along belt from left to right then drops into chute
  function spawnBall() {
    // spawn at left outside area
    const value = randInt(1, 9);
    const b = {
      x: -30,
      y: beltY,
      vx: 60 + Math.random() * 40, // pixels per second
      value: value,
      state: "rolling", // rolling -> dropping -> processed or fallen
      targetMachine: null,
      dropY: beltY,
      caught: false,
      processed: false,
      id: Math.random().toString(36).substr(2, 9),
    };
    balls.push(b);
  }

  // Process a ball into a machine index
  function processBall(ball, machineIndex) {
    const machine = levels[level].machines[machineIndex];
    let result;
    try {
      result = machine.op(ball.value);
    } catch (e) {
      console.warn("Machine operation failed:", e);
      result = NaN;
    }
    totalCaught++;
    ball.processed = true;
    // Check correctness against target
    const target = levels[level].target;
    if (result === target) {
      correctCount++;
      playCorrectSequence();
      flashFeedback("correct", machinesX[machineIndex], machineY);
    } else {
      missedCount++;
      playWrongBuzz();
      flashFeedback("wrong", machinesX[machineIndex], machineY);
    }
    // After processing, animate ball to little result bubble then remove
    setTimeout(() => {
      // safe removal later by marking processed
    }, 400);
  }

  // Visual feedback bubbles
  let feedbacks = [];
  function flashFeedback(kind, x, y) {
    feedbacks.push({
      kind,
      x,
      y,
      t: 0,
    });
  }

  // Input handling
  const keyState = {};
  function onKeyDown(e) {
    // ensure audio init on first gesture
    initAudioOnUserGesture();

    if (e.key === "ArrowLeft") {
      keyState.left = true;
      e.preventDefault();
    } else if (e.key === "ArrowRight") {
      keyState.right = true;
      e.preventDefault();
    } else if (e.key === " ") {
      keyState.space = true;
      e.preventDefault();
    } else if (e.key === "1") {
      selectorIndex = 0;
      playClickTone();
    } else if (e.key === "2") {
      selectorIndex = 1;
      playClickTone();
    } else if (e.key === "3") {
      selectorIndex = 2;
      playClickTone();
    } else if (e.key.toLowerCase() === "a") {
      toggleAudio();
      playClickTone();
    } else if (e.key.toLowerCase() === "h") {
      showHints = !showHints;
    } else if (e.key.toLowerCase() === "p") {
      paused = !paused;
    } else if (e.key === "Enter" && (correctCount >= levels[level].goal || missedCount >= levels[level].allowedMisses)) {
      // Advance or restart
      if (correctCount >= levels[level].goal) {
        resetLevel(Math.min(level + 1, levels.length - 1));
      } else {
        resetLevel(level);
      }
    }
  }

  function onKeyUp(e) {
    if (e.key === "ArrowLeft") {
      keyState.left = false;
    } else if (e.key === "ArrowRight") {
      keyState.right = false;
    } else if (e.key === " ") {
      keyState.space = false;
    }
  }

  // Mouse support for selecting machines & toggling audio
  function onMouseDown(e) {
    initAudioOnUserGesture();
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    const my = (e.clientY - rect.top) * (canvas.height / rect.height);
    // Check if clicked on machines
    for (let i = 0; i < machinesX.length; i++) {
      const mx0 = machinesX[i] - machineWidth / 2;
      const mx1 = machinesX[i] + machineWidth / 2;
      const my0 = machineY;
      const my1 = machineY + machineHeight;
      if (mx >= mx0 && mx <= mx1 && my >= my0 && my <= my1) {
        selectorIndex = i;
        playClickTone();
        return;
      }
    }
    // Check speaker icon area top-right
    if (mx > W - 58 && mx < W - 20 && my > 12 && my < 44) {
      toggleAudio();
      playClickTone();
    }
  }

  // Catch logic: player presses space to attempt to catch a ball that is dropping at the moment
  function tryCatch() {
    if (catchCooldown > 0) return;
    catchCooldown = 180; // ms cooldown
    playClickTone();
    // Find a ball that is dropping into the selected machine region OR is just at the drop point
    for (let b of balls) {
      if (b.state === "dropping" && b.targetMachine === selectorIndex && !b.caught && !b.processed) {
        b.caught = true;
        b.state = "caught";
        processBall(b, selectorIndex);
        return;
      }
    }
    // If nothing caught, small penalty
    missedCount++;
    playWrongBuzz();
  }

  // Focus management for accessibility
  canvas.addEventListener("focus", () => {
    // show focus outline by drawing; nothing else needed
  });

  // Register events
  window.addEventListener("keydown", onKeyDown);
  window.addEventListener("keyup", onKeyUp);
  canvas.addEventListener("mousedown", onMouseDown);
  // For mobile/touch: convert taps to clicks
  canvas.addEventListener("touchstart", function (e) {
    e.preventDefault();
    const touch = e.touches[0];
    onMouseDown({ clientX: touch.clientX, clientY: touch.clientY });
  }, { passive: false });

  // Main update and draw loop
  function update(dt) {
    if (paused) return;

    wiggle += dt * 0.002;

    // Spawn logic
    spawnTimer += dt;
    spawnInterval = levels[level].spawnInterval || spawnInterval;
    if (spawnTimer > spawnInterval) {
      spawnTimer = spawnTimer % spawnInterval;
      spawnBall();
    }

    // Update balls
    for (let b of balls) {
      if (b.state === "rolling") {
        b.x += (b.vx * dt) / 1000;
        // If approaching machine chute horizontally, start dropping
        for (let i = 0; i < machinesX.length; i++) {
          const mx = machinesX[i];
          if (b.x > mx - 22 && b.x < mx + 22) {
            b.state = "dropping";
            b.targetMachine = i;
            b.dropY = b.y;
            break;
          }
        }
        if (b.x > W + 30) {
          // missed entirely (fell off conveyor)
          b.state = "gone";
          missedCount++;
        }
      } else if (b.state === "dropping") {
        // vertical drop with easing
        b.y += (dt / 1000) * 160;
        if (b.y >= chuteY + 28) {
          // ball reached the machine entrance
          // If not caught, it falls into bin (processed by machine but player didn't catch)
          if (!b.caught && !b.processed) {
            // automatic processing as a miss (player didn't catch)
            b.processed = true;
            missedCount++;
            playWrongBuzz();
            flashFeedback("wrong", machinesX[b.targetMachine], machineY);
          }
          b.state = "landed";
        }
      } else if (b.state === "caught" || b.state === "landed" || b.state === "processed") {
        // gently float away before removal
        b.y += (dt / 1000) * 20;
      }
    }

    // Cull old balls
    balls = balls.filter((b) => !(b.x > W + 200 || b.y > H + 200 || b.state === "gone" || (b.processed && b.y > H + 80)));

    // Handle catching input
    if (keyState.space) {
      tryCatch();
      // make a small delay so key holding doesn't spam
      keyState.space = false;
    }

    // keyboard left/right control selector
    if (keyState.left) {
      selectorIndex = Math.max(0, selectorIndex - 1);
      keyState.left = false;
    } else if (keyState.right) {
      selectorIndex = Math.min(2, selectorIndex + 1);
      keyState.right = false;
    }

    // cooldown timer
    catchCooldown = Math.max(0, catchCooldown - dt);

    // Update feedback animations
    for (let f of feedbacks) {
      f.t += dt;
    }
    feedbacks = feedbacks.filter((f) => f.t < 900);
  }

  function drawRoundedRect(c, x, y, w, h, r) {
    c.beginPath();
    c.moveTo(x + r, y);
    c.arcTo(x + w, y, x + w, y + h, r);
    c.arcTo(x + w, y + h, x, y + h, r);
    c.arcTo(x, y + h, x, y, r);
    c.arcTo(x, y, x + w, y, r);
    c.closePath();
  }

  function draw() {
    // background soft gradient
    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, "#f7fbff");
    g.addColorStop(1, "#eaf6ff");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, W, H);

    // gentle wacky mechanical background shapes (gears as circles, purely drawn)
    for (let i = 0; i < 8; i++) {
      const gx = (i / 7) * W;
      const gy = 40 + (i % 2) * 40;
      const radius = 18 + (i % 3) * 4;
      ctx.save();
      ctx.globalAlpha = 0.06;
      ctx.translate(gx + (Math.sin(wiggle + i) * 6), gy + (Math.cos(wiggle + i) * 6));
      // draw simple gear-ish ring
      ctx.beginPath();
      for (let j = 0; j < 10; j++) {
        const a = (j / 10) * Math.PI * 2;
        const r = radius + (j % 2 === 0 ? 6 : -2);
        const x = Math.cos(a) * r;
        const y = Math.sin(a) * r;
        if (j === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fillStyle = "#44566f";
      ctx.fill();
      ctx.restore();
    }

    // Header: Level name and target
    ctx.fillStyle = "#393E46";
    ctx.font = "700 20px 'Segoe UI', Roboto, Arial";
    ctx.textAlign = "left";
    ctx.fillText("Level: " + levels[level].label, 12, 28);

    // Target display
    ctx.textAlign = "center";
    ctx.font = "800 34px 'Segoe UI', Roboto, Arial";
    ctx.fillStyle = "#222831";
    ctx.fillText("Target: " + levels[level].target, W / 2, 44);

    // Speaker icon and audio status (top-right)
    ctx.save();
    ctx.translate(W - 60, 12);
    // Box
    ctx.fillStyle = audioEnabled ? "#07c160" : "#d9534f";
    drawRoundedRect(ctx, 0, 0, 44, 32, 6);
    ctx.fill();
    ctx.fillStyle = "#fff";
    ctx.font = "600 14px 'Segoe UI'";
    ctx.textAlign = "center";
    ctx.fillText(audioEnabled ? "Audio ON" : "Audio OFF", 22, 20);
    ctx.restore();

    // Conveyor belt drawing
    ctx.fillStyle = "#c4d7eb";
    drawRoundedRect(ctx, 20, beltY - 20, W - 40, 60, 12);
    ctx.fill();

    // Decorative belt lines
    ctx.strokeStyle = "rgba(0,0,0,0.06)";
    ctx.lineWidth = 2;
    for (let i = 0; i < 10; i++) {
      ctx.beginPath();
      ctx.moveTo(24 + i * 72 + (wiggle * 2) % 72, beltY + 10);
      ctx.lineTo(24 + i * 72 + (wiggle * 2) % 72, beltY + 30);
      ctx.stroke();
    }

    // Draw machines
    for (let i = 0; i < machinesX.length; i++) {
      const mx = machinesX[i];
      // base body
      ctx.save();
      ctx.translate(mx, machineY);
      const m = levels[level].machines[i];
      // body
      ctx.fillStyle = m.color;
      drawRoundedRect(ctx, -machineWidth / 2, 0, machineWidth, machineHeight, 18);
      ctx.fill();
      // face / window
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      drawRoundedRect(ctx, -machineWidth / 2 + 14, 12, machineWidth - 28, 64, 10);
      ctx.fill();
      // operation label
      ctx.fillStyle = "#222";
      ctx.font = "700 20px 'Segoe UI'";
      ctx.textAlign = "center";
      ctx.fillText(m.label, 0, 42);
      // chutes
      ctx.fillStyle = "#2b2d42";
      drawRoundedRect(ctx, -36, 78, 72, 28, 8);
      ctx.fill();
      // little lever
      ctx.fillStyle = "#2f4858";
      ctx.fillRect(-12, 106, 24, 8);
      // machine legs
      ctx.fillStyle = "#2f4858";
      ctx.fillRect(-machineWidth / 2 + 16, machineHeight - 16, 28, 12);
      ctx.fillRect(machineWidth / 2 - 44, machineHeight - 16, 28, 12);
      // highlight selected machine
      if (selectorIndex === i) {
        ctx.strokeStyle = "#ffda79";
        ctx.lineWidth = 4;
        drawRoundedRect(ctx, -machineWidth / 2 + 6, 6, machineWidth - 12, machineHeight - 12, 18);
        ctx.stroke();
      }
      // show goal check progress on machine
      ctx.restore();
    }

    // Draw selector pointer above machines
    const sx = machinesX[selectorIndex];
    ctx.beginPath();
    ctx.moveTo(sx, beltY - 44);
    ctx.lineTo(sx - 14, beltY - 20);
    ctx.lineTo(sx + 14, beltY - 20);
    ctx.closePath();
    ctx.fillStyle = "#ff7f50";
    ctx.fill();
    // pointer label
    ctx.fillStyle = "#fff";
    ctx.font = "700 12px 'Segoe UI'";
    ctx.textAlign = "center";
    ctx.fillText("YOU", sx, beltY - 26);

    // Draw balls
    for (let b of balls) {
      ctx.save();
      ctx.translate(b.x, b.y);
      // shadow
      ctx.beginPath();
      ctx.ellipse(0, 18, 20, 8, 0, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(0,0,0,0.08)";
      ctx.fill();
      // body
      ctx.beginPath();
      ctx.arc(0, 0, 18, 0, Math.PI * 2);
      ctx.fillStyle = "#fff";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#b8c6d8";
      ctx.stroke();
      // number text
      ctx.fillStyle = "#223";
      ctx.font = "700 16px 'Segoe UI'";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(b.value.toString(), 0, 0);
      ctx.restore();
    }

    // Draw floating small counters and UI
    ctx.fillStyle = "#222";
    ctx.font = "700 18px 'Segoe UI'";
    ctx.textAlign = "left";
    ctx.fillText("Correct: " + correctCount + " / " + levels[level].goal, 12, H - 56);
    ctx.fillText("Misses: " + missedCount + " / " + levels[level].allowedMisses, 12, H - 28);

    // Draw friendly hints area
    if (showHints) {
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = "#ffffff";
      drawRoundedRect(ctx, W - 260, H - 110, 248, 98, 10);
      ctx.fill();
      ctx.fillStyle = "#222";
      ctx.font = "600 12px 'Segoe UI'";
      ctx.textAlign = "left";
      ctx.fillText("How to play:", W - 246, H - 88);
      ctx.font = "500 12px 'Segoe UI'";
      ctx.fillText("1) Use ← → or keys 1/2/3 to pick a machine", W - 246, H - 68);
      ctx.fillText("2) Press Space when a number drops into the machine", W - 246, H - 52);
      ctx.fillText("3) Aim to get numbers that make the target", W - 246, H - 36);
      ctx.fillText("A: Toggle audio  •  P: Pause  •  H: Toggle hints", W - 246, H - 18);
      ctx.restore();
    } else {
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.5)";
      drawRoundedRect(ctx, W - 180, H - 76, 160, 56, 8);
      ctx.fill();
      ctx.fillStyle = "#111";
      ctx.font = "500 12px 'Segoe UI'";
      ctx.fillText("Press H for help", W - 100, H - 40);
      ctx.restore();
    }

    // Draw feedback animations
    for (let f of feedbacks) {
      const p = f.t / 900;
      ctx.globalAlpha = 1 - p;
      if (f.kind === "correct") {
        ctx.fillStyle = "#07c160";
        ctx.beginPath();
        ctx.arc(f.x, f.y - p * 40, 22 * (1 - p * 0.6), 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#fff";
        ctx.font = "700 16px 'Segoe UI'";
        ctx.textAlign = "center";
        ctx.fillText("+1", f.x, f.y - p * 40 + 4);
      } else {
        ctx.fillStyle = "#ff6b6b";
        ctx.beginPath();
        ctx.arc(f.x, f.y - p * 40, 22 * (1 - p * 0.6), 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#fff";
        ctx.font = "700 16px 'Segoe UI'";
        ctx.textAlign = "center";
        ctx.fillText("-1", f.x, f.y - p * 40 + 4);
      }
      ctx.globalAlpha = 1;
    }

    // Draw end-level panel if won or lost
    if (correctCount >= levels[level].goal || missedCount >= levels[level].allowedMisses) {
      ctx.save();
      ctx.fillStyle = "rgba(10,10,20,0.6)";
      ctx.fillRect(0, 0, W, H);
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.font = "800 36px 'Segoe UI'";
      if (correctCount >= levels[level].goal) {
        ctx.fillText("Level Complete!", W / 2, H / 2 - 12);
        ctx.font = "600 20px 'Segoe UI'";
        ctx.fillText("Press Enter to go to the next level", W / 2, H / 2 + 24);
      } else {
        ctx.fillText("Out of Chances", W / 2, H / 2 - 12);
        ctx.font = "600 20px 'Segoe UI'";
        ctx.fillText("Press Enter to try again", W / 2, H / 2 + 24);
      }
      ctx.restore();
    }

    // Footer: accessibility instruction
    ctx.fillStyle = "#2b2d42";
    ctx.font = "500 12px 'Segoe UI'";
    ctx.textAlign = "left";
    ctx.fillText("Controls: ← → or 1/2/3 to select, Space to catch, A audio, H help", 12, H - 8);
  }

  // Game loop
  function loop(now) {
    const dt = now - lastTime;
    lastTime = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Periodic cleanup on unload
  window.addEventListener("beforeunload", () => {
    try {
      if (bgOsc) bgOsc.stop();
      if (audioCtx && typeof audioCtx.close === "function") audioCtx.close();
    } catch (e) {
      // ignore
    }
  });

  // Provide an initial friendly prompt and try to create AudioContext on first click anywhere
  const startPrompt = {
    shown: false,
  };

  // Draw a subtle overlay for first interaction
  function drawStartOverlay() {
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.86)";
    drawRoundedRect(ctx, W / 2 - 200, H / 2 - 84, 400, 168, 14);
    ctx.fill();
    ctx.fillStyle = "#223";
    ctx.font = "700 20px 'Segoe UI'";
    ctx.textAlign = "center";
    ctx.fillText("Welcome to Machine Mash!", W / 2, H / 2 - 36);
    ctx.font = "500 14px 'Segoe UI'";
    ctx.fillText("Move machines with ← →, press Space to catch a number.", W / 2, H / 2 - 8);
    ctx.fillText("Press A to toggle audio. Click or press any key to begin.", W / 2, H / 2 + 16);
    ctx.restore();
  }

  // On first user interaction, init audio if possible and remove overlay
  function firstUserGesture() {
    if (!startPrompt.shown) {
      startPrompt.shown = true;
      initAudioOnUserGesture();
    }
  }

  // Hook first gestures
  function onFirstGestureEvent() {
    firstUserGesture();
    canvas.removeEventListener("click", onFirstGestureEvent);
    window.removeEventListener("keydown", onFirstGestureEvent);
  }
  canvas.addEventListener("click", onFirstGestureEvent);
  window.addEventListener("keydown", onFirstGestureEvent);

  // Keep drawing overlay until touched
  (function overlayLoop() {
    if (!startPrompt.shown) {
      draw();
      drawStartOverlay();
      requestAnimationFrame(overlayLoop);
    }
  })();

  // Expose restart function on the element for testing or manual control (accessible)
  container.restartGame = function () {
    resetLevel(0);
  };

  // Error handling examples: warn when audio cannot be used
  if (!AudioCtx) {
    console.warn("Web Audio API not supported in this browser. Sounds disabled.");
    audioEnabled = false;
  }
})();
---

