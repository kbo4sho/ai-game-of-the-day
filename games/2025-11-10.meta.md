# Game of the Day - 2025-11-10

## Metadata
- **Generated Date:** 2025-11-10
- **Generated Time:** 2025-11-10T00:29:54.897504
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-11-10.js
- **File Size:** 30103 bytes
- **Tokens Used:** 10397

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-11-10.js` - The playable game
- `2025-11-10.meta.json` - Machine-readable metadata
- `2025-11-10.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 20190

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 21107

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Drone Math Adventure
  // For ages 7-9. All visuals drawn on canvas inside element #game-of-the-day-stage.
  // Single-file JS. No external resources.

  // ---------- Setup and Safety ----------
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Missing container element with ID "game-of-the-day-stage".');
    return;
  }

  // Clear container and create canvas sized exactly 720x480
  container.innerHTML = '';
  const canvas = document.createElement('canvas');
  canvas.width = 720;
  canvas.height = 480;
  canvas.setAttribute('role', 'application');
  canvas.setAttribute('aria-label', 'Drone Math Adventure. Press number keys or arrow keys and Enter to answer. Press R to restart.');
  canvas.setAttribute('tabindex', '0'); // allow keyboard focus
  canvas.style.outline = 'none';
  container.appendChild(canvas);

  const ctx = canvas.getContext('2d');
  if (!ctx) {
    console.error('Canvas 2D context not available.');
    return;
  }

  // Ensure crisp text rendering
  ctx.imageSmoothingEnabled = true;

  // ---------- Audio Setup ----------
  let audioEnabled = true;
  let audioContext = null;
  let masterGain = null;
  let ambientOsc = null;
  let ambientGain = null;

  function tryCreateAudioContext() {
    if (audioContext) return;
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) {
        audioEnabled = false;
        console.warn('Web Audio API not supported in this browser.');
        return;
      }
      audioContext = new AC();
      masterGain = audioContext.createGain();
      masterGain.gain.value = 0.9;
      masterGain.connect(audioContext.destination);

      // gentle ambient hum as background effect
      try {
        ambientOsc = audioContext.createOscillator();
        ambientGain = audioContext.createGain();
        ambientOsc.type = 'sine';
        ambientOsc.frequency.value = 80; // low hum
        ambientGain.gain.value = 0.0015; // very gentle
        ambientOsc.connect(ambientGain);
        ambientGain.connect(masterGain);
        ambientOsc.start();
      } catch (e) {
        console.warn('Ambient sound failed to start:', e);
      }
    } catch (err) {
      audioEnabled = false;
      console.warn('Failed to create AudioContext:', err);
    }
  }

  // Play simple sounds: correct (pleasant chime), incorrect (buzz), click
  function playSound(type) {
    if (!audioEnabled) return;
    try {
      if (!audioContext) tryCreateAudioContext();
      if (!audioContext) return;

      const now = audioContext.currentTime;
      if (type === 'correct') {
        // rising chord-like beep
        const freqs = [880, 1100, 1320];
        freqs.forEach((f, i) => {
          const o = audioContext.createOscillator();
          const g = audioContext.createGain();
          o.type = 'sine';
          o.frequency.value = f;
          g.gain.value = 0;
          o.connect(g);
          g.connect(masterGain);
          o.start(now + i * 0.02);
          g.gain.setValueAtTime(0.0001, now + i * 0.02);
          g.gain.exponentialRampToValueAtTime(0.06, now + i * 0.02 + 0.06);
          g.gain.exponentialRampToValueAtTime(0.0001, now + i * 0.02 + 0.35);
          o.stop(now + i * 0.02 + 0.36);
        });
      } else if (type === 'incorrect') {
        const o = audioContext.createOscillator();
        const g = audioContext.createGain();
        o.type = 'sawtooth';
        o.frequency.value = 200;
        g.gain.value = 0.0001;
        o.connect(g);
        g.connect(masterGain);
        o.start(now);
        g.gain.exponentialRampToValueAtTime(0.06, now + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.32);
        o.frequency.exponentialRampToValueAtTime(60, now + 0.32);
        o.stop(now + 0.34);
      } else if (type === 'click') {
        const o = audioContext.createOscillator();
        const g = audioContext.createGain();
        o.type = 'square';
        o.frequency.value = 1200;
        g.gain.value = 0.01;
        o.connect(g);
        g.connect(masterGain);
        o.start(now);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.09);
        o.stop(now + 0.1);
      }
    } catch (e) {
      console.warn('Error playing sound:', e);
      audioEnabled = false;
    }
  }

  // ---------- Game Variables ----------
  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;

  const UI_PADDING = 10; // minimum padding between UI elements

  const GOAL = 10; // collect 10 correct batteries
  const MAX_WRONG = 3; // 3 wrong answers => game over

  let score = 0;
  let wrongCount = 0;
  let gameState = 'playing'; // 'playing', 'victory', 'gameover', 'title'
  let soundVisualTimer = 0; // visual indicator when sound plays
  let lastInteractionTime = 0;

  // Current question
  let question = null; // {text, choices:[...], answerIndex}
  let selectedChoice = 0; // 0..2
  let anims = []; // animations for drone, explosions etc.

  // Drone state for animation
  const drone = {
    x: 100,
    y: 200,
    targetX: 100,
    targetY: 200,
    speed: 220, // pixels per second
    propellerAngle: 0,
    size: 40,
  };

  // Batteries positions (collected) -- but will spawn for each success
  let battery = null; // {x,y,active,progress}

  // Clouds array for background animation
  const clouds = createClouds();

  // UI positions - compute using measureText to ensure no overlapping
  const ui = {
    scorePos: { x: 18, y: 24 },
    livesPos: { x: WIDTH - 18, y: 24 }, // measureText to right align
    centerTopPos: { x: WIDTH / 2, y: 24 },
    choicesArea: { y: 350, height: 110 }, // bottom area for choices
    instructionPos: { x: WIDTH / 2, y: HEIGHT - 20 },
  };

  // ---------- Utilities ----------
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function clamp(v, a, b) {
    return Math.max(a, Math.min(b, v));
  }

  function formatTextWidth(text, font) {
    ctx.save();
    ctx.font = font;
    const m = ctx.measureText(text);
    ctx.restore();
    return m.width;
  }

  // ---------- Question Generation ----------
  function generateQuestion() {
    // Basic addition/subtraction within suitable ranges for ages 7-9
    const type = Math.random() < 0.6 ? 'add' : 'sub';
    let a, b;
    if (type === 'add') {
      a = randInt(1, 12);
      b = randInt(1, 12);
    } else {
      a = randInt(5, 18);
      b = randInt(1, Math.min(8, a - 1));
    }
    const text = type === 'add' ? `${a} + ${b} = ?` : `${a} - ${b} = ?`;
    const answer = type === 'add' ? a + b : a - b;

    // Create 3 choices, one correct, others plausible
    const choices = [];
    const correctIndex = randInt(0, 2);
    for (let i = 0; i < 3; i++) {
      if (i === correctIndex) {
        choices.push(answer);
      } else {
        // plausible distractor within +/-3 but not equal
        let candidate;
        let tries = 0;
        do {
          const delta = randInt(-3, 3);
          candidate = answer + delta;
          tries++;
        } while ((candidate === answer || candidate < 0) && tries < 10);
        if (candidate === answer || candidate < 0) candidate = answer + (i === 0 ? 2 : -2);
        choices.push(candidate);
      }
    }

    return {
      text,
      choices,
      answerIndex: correctIndex,
    };
  }

  // ---------- Cloud Generation ----------
  function createClouds() {
    const arr = [];
    const count = 6;
    for (let i = 0; i < count; i++) {
      arr.push({
        x: Math.random() * WIDTH,
        y: Math.random() * 120 + 10,
        w: 80 + Math.random() * 120,
        h: 36 + Math.random() * 28,
        speed: 8 + Math.random() * 30,
        puff: Math.random() * 8 + 8,
      });
    }
    return arr;
  }

  // ---------- Input Handling ----------
  // Keyboard and mouse events
  canvas.addEventListener('keydown', (e) => {
    lastInteractionTime = Date.now();
    if (!audioContext && audioEnabled) tryCreateAudioContext();
    if (gameState === 'title') {
      if (e.key.toLowerCase() === 's' || e.key === 'Enter') {
        e.preventDefault();
        startGame();
        return;
      }
    }
    if (gameState === 'victory' || gameState === 'gameover') {
      if (e.key.toLowerCase() === 'r') {
        e.preventDefault();
        restartGame();
        playSound('click');
      }
      return;
    }
    if (gameState !== 'playing') return;

    if (e.key === 'ArrowLeft') {
      selectedChoice = (selectedChoice + 3 - 1) % 3;
      playSound('click');
    } else if (e.key === 'ArrowRight') {
      selectedChoice = (selectedChoice + 1) % 3;
      playSound('click');
    } else if (e.key === 'Enter') {
      e.preventDefault();
      submitAnswer(selectedChoice);
    } else if (e.key >= '1' && e.key <= '3') {
      const idx = parseInt(e.key, 10) - 1;
      selectedChoice = idx;
      submitAnswer(idx);
    } else if (e.key.toLowerCase() === 'm') {
      // toggle audio
      audioEnabled = !audioEnabled;
      if (!audioEnabled && ambientGain) ambientGain.gain.value = 0;
      playSound('click');
    }
  });

  canvas.addEventListener('click', (e) => {
    lastInteractionTime = Date.now();
    if (!audioContext && audioEnabled) tryCreateAudioContext();
    const r = canvas.getBoundingClientRect();
    const mx = (e.clientX - r.left) * (canvas.width / r.width);
    const my = (e.clientY - r.top) * (canvas.height / r.height);
    if (gameState === 'title') {
      startGame();
      playSound('click');
      return;
    }
    if (gameState === 'victory' || gameState === 'gameover') {
      // detect click on restart button
      if (isPointInRect(mx, my, restartButtonRect)) {
        restartGame();
        playSound('click');
      }
      return;
    }
    if (gameState !== 'playing') return;

    // Check clicks on choice rectangles
    for (let i = 0; i < 3; i++) {
      const rect = getChoiceRect(i);
      if (isPointInRect(mx, my, rect)) {
        selectedChoice = i;
        submitAnswer(i);
        return;
      }
    }
  });

  function isPointInRect(x, y, rect) {
    return x >= rect.x && x <= rect.x + rect.w && y >= rect.y && y <= rect.y + rect.h;
  }

  // ---------- Game Logic ----------
  function startGame() {
    score = 0;
    wrongCount = 0;
    gameState = 'playing';
    selectedChoice = 0;
    question = generateQuestion();
    battery = null;
    drone.x = 100;
    drone.y = 200;
    drone.targetX = drone.x;
    drone.targetY = drone.y;
    anims.length = 0;
  }

  function restartGame() {
    gameState = 'playing';
    lastInteractionTime = Date.now();
    startGame();
  }

  function submitAnswer(idx) {
    if (gameState !== 'playing' || !question) return;
    // Confirm selection
    const correct = idx === question.answerIndex;
    if (correct) {
      score += 1;
      playSound('correct');
      soundVisualTimer = 0.6;
      // spawn a battery somewhere mildly random but reachable
      battery = {
        x: clamp(randInt(160, WIDTH - 120), 120, WIDTH - 120),
        y: clamp(randInt(100, 300), 80, 320),
        active: true,
        progress: 0,
      };
      // set drone target to battery
      drone.targetX = battery.x;
      drone.targetY = battery.y - 40;
      // add a friendly twinkle animation
      anims.push(createTwinkle(battery.x, battery.y));
      // next question will be generated after drone reaches battery and collects
    } else {
      wrongCount += 1;
      playSound('incorrect');
      soundVisualTimer = 0.4;
      // small explosion animation
      anims.push(createExplosion(drone.x, drone.y));
      // nudge drone back
      drone.targetX = clamp(drone.x - 60, 60, WIDTH - 60);
      drone.targetY = clamp(drone.y + 20, 80, HEIGHT - 120);
    }
    // lock selection briefly: generate next question after short delay or after drone collects
    selectedChoice = 0;
    question = null; // wait until after animations to show next question

    // Check immediate game end on wrongCount exceeding
    if (wrongCount >= MAX_WRONG) {
      setTimeout(() => {
        gameState = 'gameover';
      }, 700);
    }
  }

  // ---------- Animations Helpers ----------
  function createExplosion(x, y) {
    return {
      type: 'explosion',
      x,
      y,
      t: 0,
      duration: 0.7,
    };
  }

  function createTwinkle(x, y) {
    return {
      type: 'twinkle',
      x,
      y,
      t: 0,
      duration: 0.9,
    };
  }

  // ---------- Rendering Helpers ----------
  function drawRoundedRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  function drawSky() {
    // calm gradient sky
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#BFE9FF');
    g.addColorStop(1, '#DFF6FF');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
  }

  function drawClouds(dt) {
    ctx.save();
    ctx.globalAlpha = 0.9;
    for (const c of clouds) {
      c.x += (c.speed * dt) / 60;
      if (c.x - c.w > WIDTH + 50) c.x = -c.w - 50;
      // draw layered puffs
      ctx.fillStyle = '#F1FBFF';
      ctx.beginPath();
      const puffCount = Math.max(3, Math.floor(c.puff));
      for (let i = 0; i < puffCount; i++) {
        const px = c.x + (i / (puffCount - 1 || 1)) * c.w;
        const py = c.y + Math.sin((i / puffCount) * Math.PI) * 6;
        ctx.moveTo(px, py);
        ctx.arc(px, py, c.h * (0.6 + Math.random() * 0.2), 0, Math.PI * 2);
      }
      ctx.fill();
      // subtle underside
      ctx.fillStyle = 'rgba(180,220,240,0.25)';
      ctx.fillRect(c.x, c.y + c.h * 0.2, c.w, c.h * 0.3);
    }
    ctx.restore();
  }

  function drawDrone(dt) {
    // propeller rotation
    drone.propellerAngle += dt * 12; // speed
    // move toward target
    const dx = drone.targetX - drone.x;
    const dy = drone.targetY - drone.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist > 1) {
      const move = Math.min((drone.speed * dt) / 1000, dist);
      drone.x += (dx / dist) * move;
      drone.y += (dy / dist) * move;
    }

    // body
    ctx.save();
    ctx.translate(drone.x, drone.y);
    // body shadow
    ctx.fillStyle = 'rgba(0,0,0,0.08)';
    ctx.beginPath();
    ctx.ellipse(0, drone.size * 0.6, drone.size * 0.8, drone.size * 0.28, 0, 0, Math.PI * 2);
    ctx.fill();

    // main hull
    ctx.fillStyle = '#FFD838';
    ctx.strokeStyle = '#6C4A00';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(0, 0, drone.size * 1.2, drone.size * 0.7, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // windows
    ctx.fillStyle = '#9EE7FF';
    ctx.beginPath();
    ctx.arc(-10, -2, 10, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(10, -2, 6, 0, Math.PI * 2);
    ctx.fill();

    // legs
    ctx.strokeStyle = '#6C4A00';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-18, drone.size * 0.3);
    ctx.lineTo(-26, drone.size * 0.9);
    ctx.moveTo(18, drone.size * 0.3);
    ctx.lineTo(26, drone.size * 0.9);
    ctx.stroke();

    // propellers
    ctx.save();
    ctx.rotate(drone.propellerAngle);
    for (let i = -1; i <= 1; i += 2) {
      ctx.save();
      ctx.translate(i * 26, -18);
      ctx.fillStyle = 'rgba(100,100,120,0.7)';
      ctx.beginPath();
      ctx.ellipse(0, 0, 28, 6, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.12)';
      ctx.stroke();
      ctx.restore();
    }
    ctx.restore();

    ctx.restore();
  }

  function drawBattery(bat, dt) {
    if (!bat) return;
    // twinkle if active
    ctx.save();
    const shine = 0.3 + 0.7 * Math.sin(Date.now() / 250);
    ctx.translate(bat.x, bat.y);
    ctx.fillStyle = `rgba(255,220,60,${0.95 + 0.05 * shine})`;
    ctx.strokeStyle = '#8B6A00';
    ctx.lineWidth = 2;
    drawRoundedRect(ctx, -18, -12, 36, 24, 6);
    ctx.fillStyle = '#FFF8D7';
    ctx.fillRect(-6, -8, 12, 16);
    ctx.restore();
  }

  // choice rectangles computed based on text widths
  function getChoiceRect(i) {
    // layout three columns within choices area with spacing, use measureText to ensure text fits
    const area = ui.choicesArea;
    const y = area.y + 14;
    const heights = 52;
    // compute column widths: balance space
    const gap = 18;
    const totalGap = gap * 2;
    const available = WIDTH - UI_PADDING * 2 - totalGap;
    const colW = Math.floor(available / 3);
    const x = UI_PADDING + i * (colW + gap);
    return { x, y, w: colW, h: heights };
  }

  // ---------- Main Update & Draw Loop ----------
  let lastTime = performance.now();
  let restartButtonRect = { x: 0, y: 0, w: 0, h: 0 };

  function update(now) {
    const dtMs = Math.min(now - lastTime, 40);
    const dt = dtMs;
    lastTime = now;

    // update sound visual timer
    if (soundVisualTimer > 0) soundVisualTimer = Math.max(0, soundVisualTimer - dt / 1000);

    // update anims
    for (let i = anims.length - 1; i >= 0; i--) {
      const a = anims[i];
      a.t += dt / 1000;
      if (a.t >= a.duration) anims.splice(i, 1);
    }

    // robot auto-behaviors: if battery exists and drone near battery, collect it
    if (battery && battery.active) {
      const dx = battery.x - drone.x;
      const dy = battery.y - 40 - drone.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 8) {
        // collect
        battery.active = false;
        anims.push({
          type: 'collect',
          x: battery.x,
          y: battery.y,
          t: 0,
          duration: 0.8,
        });
        // after short delay, spawn next question or victory
        setTimeout(() => {
          if (score >= GOAL) {
            gameState = 'victory';
          } else if (wrongCount >= MAX_WRONG) {
            gameState = 'gameover';
          } else {
            question = generateQuestion();
          }
          battery = null;
        }, 600);
      }
    }

    // draw everything
    drawFrame(dtMs / 1000);

    requestAnimationFrame(update);
  }

  // ---------- Drawing Frame ----------
  function drawFrame(dt) {
    // background
    drawSky();
    drawClouds(dt);

    // draw playground ground
    ctx.fillStyle = '#E8FFF2';
    ctx.fillRect(0, HEIGHT - 90, WIDTH, 90);

    // draw anims behind drone
    for (const a of anims) {
      if (a.type === 'explosion') drawExplosion(a);
    }

    // battery (maybe behind drone)
    drawBattery(battery, dt);

    // drone
    drawDrone(dt);

    // draw anims above drone (twinkles, collect)
    for (const a of anims) {
      if (a.type === 'twinkle' || a.type === 'collect') {
        drawTwinkle(a);
      }
    }

    // top UI: score, progress, lives
    drawTopUI();

    // bottom: choices area
    drawChoicesArea();

    // instructions bottom center
    drawInstructions();

    // sound visual indicator
    if (soundVisualTimer > 0 || !audioEnabled) drawSoundIcon();

    // if title or end screens
    if (gameState === 'title') drawTitleScreen();
    if (gameState === 'victory') drawVictoryScreen();
    if (gameState === 'gameover') drawGameOverScreen();
  }

  // ---------- UI Drawing ----------
  function drawTopUI() {
    // Score top-left
    const scoreText = `Batteries: ${score} / ${GOAL}`;
    ctx.font = 'bold 20px sans-serif';
    const sw = ctx.measureText(scoreText).width;
    const pad = 12;
    const x = ui.scorePos.x;
    const y = ui.scorePos.y - 18;
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    drawRoundedRect(ctx, x - pad / 2, 6, sw + pad * 1.2, 36, 8);
    ctx.fillStyle = '#004466';
    ctx.fillText(scoreText, x + 6, ui.scorePos.y + 2);

    // Lives top-right
    const livesText = `Errors: ${wrongCount} / ${MAX_WRONG}`;
    ctx.font = 'bold 20px sans-serif';
    const lw = ctx.measureText(livesText).width;
    const rx = ui.livesPos.x;
    const ry = ui.livesPos.y - 18;
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    drawRoundedRect(ctx, rx - lw - 18, 6, lw + 14, 36, 8);
    ctx.fillStyle = '#660000';
    ctx.fillText(livesText, rx - lw - 4, ui.livesPos.y + 2);

    // center top: if question exists show small hint
    ctx.font = '18px sans-serif';
    const hintText = `Drone Pilot: Collect ${GOAL} batteries by answering correctly.`;
    const hw = ctx.measureText(hintText).width;
    const hx = ui.centerTopPos.x - hw / 2;
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    drawRoundedRect(ctx, hx - 10, 6, hw + 20, 36, 8);
    ctx.fillStyle = '#003344';
    ctx.fillText(hintText, hx + 6, ui.centerTopPos.y + 2);
  }

  function drawChoicesArea() {
    // background container
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    drawRoundedRect(ctx, UI_PADDING - 6, ui.choicesArea.y + 2, WIDTH - (UI_PADDING - 6) * 2, ui.choicesArea.height, 12);

    // question box (centered above choices)
    ctx.font = '22px sans-serif';
    const qText = question ? question.text : '...';
    const qw = ctx.measureText(qText).width;
    const qx = WIDTH / 2 - qw / 2;
    const qy = ui.choicesArea.y - 24;
    ctx.fillStyle = 'rgba(0,0,0,0.06)';
    drawRoundedRect(ctx, qx - 10, qy - 6, qw + 20, 36, 8);
    ctx.fillStyle = '#002233';
    ctx.fillText(qText, qx, qy + 22);

    // draw three choice rectangles
    for (let i = 0; i < 3; i++) {
      const rect = getChoiceRect(i);
      // measure text width
      ctx.font = '20px sans-serif';
      const text = question ? String(question.choices[i]) : '—';
      const tw = ctx.measureText(`${i + 1}. ${text}`).width;
      const padding = 12;
      // choose style depending on selection
      const isSelected = i === selectedChoice && gameState === 'playing';
      ctx.fillStyle = isSelected ? 'rgba(61, 128, 255, 0.95)' : 'rgba(245, 255, 250, 0.95)';
      // ensure rect width at least fits text
      const w = Math.max(rect.w, tw + padding * 2);
      // center within rect area
      const rx = rect.x + (rect.w - w) / 2;
      const ry = rect.y;
      const rh = rect.h;
      ctx.fillStyle = isSelected ? '#2B6FE8' : '#FFFFFF';
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.lineWidth = 2;
      drawRoundedRect(ctx, rx, ry, w, rh, 10);
      // text
      ctx.fillStyle = isSelected ? '#FFFFFF' : '#003344';
      ctx.font = isSelected ? 'bold 20px sans-serif' : '20px sans-serif';
      const label = `${i + 1}. ${text}`;
      // measure to center vertically/horizontally
      const twreal = ctx.measureText(label).width;
      const tx = rx + (w - twreal) / 2;
      const ty = ry + rh / 2 + 8;
      ctx.fillText(label, tx, ty);

      // small border icon showing correct/incorrect after selection processed
      if (!question) {
        // during animation/no question, show nothing
      } else {
        // draw small hint dot to left
        ctx.beginPath();
        ctx.fillStyle = '#F0F8FF';
        ctx.arc(rx + 14, ry + rh / 2, 10, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // accessibility: show key controls
    ctx.font = '14px sans-serif';
    ctx.fillStyle = '#003344';
    ctx.fillText('Use ← → to choose, Enter to confirm, or press 1-3. Press M to mute/unmute.', UI_PADDING + 4, ui.choicesArea.y + ui.choicesArea.height - 8);
  }

  function drawInstructions() {
    ctx.save();
    ctx.font = '16px sans-serif';
    const instr = gameState === 'playing' ? 'Answer correctly to guide your drone to batteries. 3 mistakes and the game ends.' : '';
    const w = ctx.measureText(instr).width;
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    drawRoundedRect(ctx, ui.instructionPos.x - w / 2 - 12, ui.instructionPos.y - 22, w + 24, 36, 8);
    ctx.fillStyle = '#002244';
    ctx.fillText(instr, ui.instructionPos.x - w / 2, ui.instructionPos.y - 6);
    ctx.restore();
  }

  function drawSoundIcon() {
    // top-left near score show a small speaker icon and animation if sound just played or muted
    const x = ui.scorePos.x + 6;
    const y = ui.scorePos.y + 40;
    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = audioEnabled ? '#2B6FE8' : '#777';
    // small rectangle background
    drawRoundedRect(ctx, x - 6, y - 18, 110, 30, 8);
    ctx.fillStyle = audioEnabled ? '#2B6FE8' : '#777';
    // speaker triangle
    ctx.beginPath();
    ctx.moveTo(x + 8, y - 2);
    ctx.lineTo(x + 18, y + 8);
    ctx.lineTo(x + 18, y - 12);
    ctx.closePath();
    ctx.fillStyle = '#FFF';
    ctx.fill();

    // sound wave visual if playing recently
    if (soundVisualTimer > 0 && audioEnabled) {
      ctx.strokeStyle = '#FFFB';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x + 36, y - 2, 8 + soundVisualTimer * 18, -0.6, 0.6);
      ctx.stroke();
    } else {
      ctx.fillStyle = '#FFFFFF';
      ctx.font = '12px sans-serif';
      ctx.fillText(audioEnabled ? 'Sound: On (M)' : 'Sound: Off (M)', x + 48, y + 4);
    }
    ctx.restore();
  }

  // ---------- Anim Drawings ----------
  function drawExplosion(a) {
    const p = a.t / a.duration;
    if (p > 1) return;
    const alpha = 1 - p;
    ctx.save();
    ctx.globalAlpha = alpha;
    for (let i = 0; i < 8; i++) {
      const ang = (i / 8) * Math.PI * 2 + p * 6;
      const r = 6 + p * 40;
      ctx.fillStyle = `rgba(255, ${120 + i * 10}, 64, ${0.9 - p * 0.9})`;
      ctx.beginPath();
      ctx.ellipse(a.x + Math.cos(ang) * r, a.y + Math.sin(ang) * r, 8 * (1 - p * 0.8), 6 * (1 - p * 0.8), 0, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawTwinkle(a) {
    const p = a.t / a.duration;
    if (p > 1) return;
    const size = 6 + Math.sin(p * Math.PI) * 18;
    ctx.save();
    ctx.globalAlpha = 0.9 * (1 - p);
    ctx.fillStyle = '#FFFFFF';
    for (let i = 0; i < 6; i++) {
      const rot = (i / 6) * Math.PI * 2;
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(a.x + Math.cos(rot) * size, a.y + Math.sin(rot) * size);
      ctx.strokeStyle = `rgba(255,255,255,${0.9 - p})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    ctx.restore();
  }

  // ---------- Title and End Screens ----------
  function drawTitleScreen() {
    ctx.save();
    const title = 'Drone Math Adventure';
    ctx.font = 'bold 36px sans-serif';
    ctx.fillStyle = '#003344';
    const tw = ctx.measureText(title).width;
    ctx.fillText(title, WIDTH / 2 - tw / 2, HEIGHT / 2 - 40);

    ctx.font = '18px sans-serif';
    const desc = 'Help your friendly drone collect batteries by answering math problems!';
    const dw = ctx.measureText(desc).width;
    ctx.fillStyle = '#002233';
    ctx.fillText(desc, WIDTH / 2 - dw / 2, HEIGHT / 2 - 8);

    ctx.font = '16px sans-serif';
    const hint = 'Press S or Enter to Start. Use 1-3, arrow keys, or click choices. R to restart after game over.';
    const hw = ctx.measureText(hint).width;
    ctx.fillText(hint, WIDTH / 2 - hw / 2, HEIGHT / 2 + 18);
    ctx.restore();
  }

  function drawVictoryScreen() {
    ctx.save();
    // translucent overlay
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    const title = 'Victory! Batteries Collected.';
    ctx.font = 'bold 36px sans-serif';
    ctx.fillStyle = '#FFF8E6';
    const tw = ctx.measureText(title).width;
    ctx.fillText(title, WIDTH / 2 - tw / 2, HEIGHT / 2 - 40);

    ctx.font = '20px sans-serif';
    ctx.fillStyle = '#FFF';
    const msg = `You collected ${score} batteries and guided the drone safely!`;
    const mw = ctx.measureText(msg).width;
    ctx.fillText(msg, WIDTH / 2 - mw / 2, HEIGHT / 2 - 4);

    // restart button
    const btnText = 'Restart (R)';
    ctx.font = '18px sans-serif';
    const bw = ctx.measureText(btnText).width;
    const btnW = bw + 30;
    const btnH = 44;
    const bx = WIDTH / 2 - btnW / 2;
    const by = HEIGHT / 2 + 20;
    restartButtonRect = { x: bx, y: by, w: btnW, h: btnH };
    ctx.fillStyle = '#2B6FE8';
    drawRoundedRect(ctx, bx, by, btnW, btnH, 10);
    ctx.fillStyle = '#FFF';
    ctx.fillText(btnText, bx + (btnW - bw) / 2, by + 28);

    ctx.restore();
  }

  function drawGameOverScreen() {
    ctx.save();
    ctx.fillStyle = 'rgba(60, 0, 0, 0.6)';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    ctx.font = 'bold 36px sans-serif';
    ctx.fillStyle = '#FFDDD6';
    const title = 'Game Over';
    const tw = ctx.measureText(title).width;
    ctx.fillText(title, WIDTH / 2 - tw / 2, HEIGHT / 2 - 40);

    ctx.font = '20px sans-serif';
    const msg = `You made ${wrongCount} mistakes. You collected ${score} batteries.`;
    const mw = ctx.measureText(msg).width;
    ctx.fillText(msg, WIDTH / 2 - mw / 2, HEIGHT / 2 - 4);

    const btnText = 'Try Again (R)';
    ctx.font = '18px sans-serif';
    const bw = ctx.measureText(btnText).width;
    const btnW = bw + 30;
    const btnH = 44;
    const bx = WIDTH / 2 - btnW / 2;
    const by = HEIGHT / 2 + 20;
    restartButtonRect = { x: bx, y: by, w: btnW, h: btnH };
    ctx.fillStyle = '#F2584B';
    drawRoundedRect(ctx, bx, by, btnW, btnH, 10);
    ctx.fillStyle = '#FFF';
    ctx.fillText(btnText, bx + (btnW - bw) / 2, by + 28);

    ctx.restore();
  }

  // ---------- Init and Start ----------
  function init() {
    // show title
    gameState = 'title';
    question = null;
    selectedChoice = 0;
    // start loop
    lastTime = performance.now();
    requestAnimationFrame(update);
  }

  // start on first user interaction because Chrome requires gesture to start audio
  let firstInteractionSet = false;
  function onFirstInteraction() {
    if (firstInteractionSet) return;
    firstInteractionSet = true;
    tryCreateAudioContext();
    // resume context if suspended
    if (audioContext && audioContext.state === 'suspended') {
      audioContext.resume().catch(() => {});
    }
  }

  ['click', 'keydown', 'touchstart'].forEach((ev) => {
    canvas.addEventListener(ev, onFirstInteraction, { once: true, passive: true });
    window.addEventListener(ev, onFirstInteraction, { once: true, passive: true });
  });

  // initialize fonts and draw initial frame
  try {
    ctx.font = '16px sans-serif';
  } catch (e) {
    console.warn('Font setting failed:', e);
  }

  // Accessibility note drawn textually on canvas and aria-label set earlier
  init();
})();
---

