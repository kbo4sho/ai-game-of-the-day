{
  "generated_date": "2025-10-07",
  "generated_timestamp": "2025-10-07T00:27:22.439352",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 10456,
  "game_filename": "2025-10-07.js",
  "game_size_bytes": 30776,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function() {\n  // Robo-Assembly: a calming, wacky math game for ages 7-9\n  // Renders into the element with id \"game-of-the-day-stage\"\n  // Uses Canvas for graphics and Web Audio API for sounds.\n  // Accessible: keyboard controls, textual status for screen readers.\n\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const TARGET_MACHINES = 5; // number of machines to assemble to win\n  const PART_COUNT = 9; // number of parts visible on the belt at once\n  const BELT_Y = 300;\n  const BELT_HEIGHT = 110;\n  const PART_SPEED = 0.5; // base speed in px per frame - will be multiplied by dt\n  const PALETTE = {\n    bg: '#e8f0ef',\n    belt: '#d0e1dc',\n    beltShadow: '#b8c9c4',\n    gear: '#9fb6c3',\n    partFill: ['#F9C784', '#C7E7B9', '#C8E6F5', '#F6D1E1', '#E7D3FF', '#FFE5B4'],\n    text: '#13323e',\n    selector: '#ff6b6b'\n  };\n\n  // Grab parent element\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Game container with id \"game-of-the-day-stage\" not found.');\n    return;\n  }\n  // Clear container children and set styles\n  container.innerHTML = '';\n  container.style.position = 'relative';\n  container.style.width = `${WIDTH}px`;\n  container.style.height = `${HEIGHT}px`;\n  container.style.maxWidth = `${WIDTH}px`;\n  container.style.maxHeight = `${HEIGHT}px`;\n  container.style.userSelect = 'none';\n  container.style.fontFamily = 'sans-serif';\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.width = `${WIDTH}px`;\n  canvas.style.height = `${HEIGHT}px`;\n  canvas.style.display = 'block';\n  canvas.setAttribute('role', 'img');\n  canvas.setAttribute('aria-label', 'Robo assembly machine math game');\n  canvas.tabIndex = 0; // focusable for keyboard events\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Create hidden live region for screen readers\n  const statusRegion = document.createElement('div');\n  statusRegion.setAttribute('role', 'status');\n  statusRegion.setAttribute('aria-live', 'polite');\n  statusRegion.style.position = 'absolute';\n  statusRegion.style.left = '-9999px';\n  statusRegion.style.top = 'auto';\n  statusRegion.style.width = '1px';\n  statusRegion.style.height = '1px';\n  statusRegion.style.overflow = 'hidden';\n  container.appendChild(statusRegion);\n\n  // Utility functions\n  function clamp(n, a, b) {\n    return Math.max(a, Math.min(b, n));\n  }\n  function randInt(a, b) {\n    return Math.floor(Math.random() * (b - a + 1)) + a;\n  }\n  function pick(array) {\n    return array[Math.floor(Math.random() * array.length)];\n  }\n\n  // Audio Manager\n  class AudioManager {\n    constructor() {\n      this.ctx = null;\n      this.ambientGain = null;\n      this.ambientOsc = null;\n      this.ambientOn = false;\n      this.enabled = false;\n      this.muted = false;\n    }\n\n    async initFromUserGesture() {\n      if (this.enabled) return true;\n      try {\n        const AudioCtx = window.AudioContext || window.webkitAudioContext;\n        if (!AudioCtx) throw new Error('Web Audio API not supported.');\n        this.ctx = new AudioCtx();\n        // create master gain -> destination with gentle ramp\n        this.masterGain = this.ctx.createGain();\n        this.masterGain.gain.value = 0.9;\n        this.masterGain.connect(this.ctx.destination);\n\n        // smooth resume in case of suspended context that needs user gesture\n        if (this.ctx.state === 'suspended') {\n          await this.ctx.resume();\n        }\n\n        this.enabled = true;\n        this.startAmbient();\n        return true;\n      } catch (err) {\n        console.warn('Audio initialization failed:', err);\n        this.enabled = false;\n        this.ctx = null;\n        return false;\n      }\n    }\n\n    toggleMute() {\n      this.muted = !this.muted;\n      if (this.masterGain) {\n        this.masterGain.gain.setValueAtTime(this.muted ? 0 : 0.9, this.ctx.currentTime);\n      }\n    }\n\n    startAmbient() {\n      if (!this.enabled || this.ambientOn) return;\n      try {\n        const ctx = this.ctx;\n        const g = ctx.createGain();\n        g.gain.value = 0.06; // subtle\n        g.connect(this.masterGain);\n\n        // create a slowly detuned pair to make gentle pad\n        const osc1 = ctx.createOscillator();\n        osc1.type = 'sine';\n        osc1.frequency.value = 110;\n        const osc2 = ctx.createOscillator();\n        osc2.type = 'triangle';\n        osc2.frequency.value = 138.5;\n\n        // subtle amplitude modulation\n        const lfo = ctx.createOscillator();\n        lfo.type = 'sine';\n        lfo.frequency.value = 0.05; // very slow\n        const lfoGain = ctx.createGain();\n        lfoGain.gain.value = 0.03;\n\n        lfo.connect(lfoGain);\n        lfoGain.connect(g.gain);\n\n        osc1.connect(g);\n        osc2.connect(g);\n\n        osc1.start();\n        osc2.start();\n        lfo.start();\n\n        this.ambientOsc = [osc1, osc2, lfo];\n        this.ambientGain = g;\n        this.ambientOn = true;\n      } catch (err) {\n        console.warn('Ambient sound failed to start:', err);\n      }\n    }\n\n    stopAmbient() {\n      if (!this.enabled || !this.ambientOn) return;\n      try {\n        this.ambientOsc.forEach(o => {\n          try { o.stop(); } catch (e) {}\n          try { o.disconnect(); } catch (e) {}\n        });\n        try { this.ambientGain.disconnect(); } catch (e) {}\n      } catch (err) {\n        console.warn('Failed to stop ambient:', err);\n      } finally {\n        this.ambientOn = false;\n        this.ambientOsc = null;\n        this.ambientGain = null;\n      }\n    }\n\n    playClick() {\n      if (!this.enabled || !this.ctx) return;\n      try {\n        const ctx = this.ctx;\n        const o = ctx.createOscillator();\n        o.type = 'square';\n        o.frequency.value = 880;\n        const g = ctx.createGain();\n        g.gain.value = 0;\n        o.connect(g);\n        g.connect(this.masterGain);\n        const now = ctx.currentTime;\n        g.gain.cancelScheduledValues(now);\n        g.gain.setValueAtTime(0, now);\n        g.gain.linearRampToValueAtTime(0.06, now + 0.01);\n        g.gain.exponentialRampToValueAtTime(0.001, now + 0.2);\n        o.start(now);\n        o.stop(now + 0.25);\n      } catch (err) {\n        console.warn('playClick failed', err);\n      }\n    }\n\n    playCorrect() {\n      if (!this.enabled || !this.ctx) return;\n      try {\n        const ctx = this.ctx;\n        const o = ctx.createOscillator();\n        o.type = 'sine';\n        o.frequency.setValueAtTime(660, ctx.currentTime);\n        const o2 = ctx.createOscillator();\n        o2.type = 'sine';\n        o2.frequency.setValueAtTime(880, ctx.currentTime);\n        const g = ctx.createGain();\n        g.gain.value = 0;\n        const filter = ctx.createBiquadFilter();\n        filter.type = 'lowpass';\n        filter.frequency.value = 1200;\n        o.connect(filter);\n        o2.connect(filter);\n        filter.connect(g);\n        g.connect(this.masterGain);\n        const now = ctx.currentTime;\n        g.gain.setValueAtTime(0.0001, now);\n        g.gain.exponentialRampToValueAtTime(0.15, now + 0.03);\n        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.7);\n        o.start(now);\n        o2.start(now);\n        o.stop(now + 0.8);\n        o2.stop(now + 0.8);\n      } catch (err) {\n        console.warn('playCorrect failed', err);\n      }\n    }\n\n    playWrong() {\n      if (!this.enabled || !this.ctx) return;\n      try {\n        const ctx = this.ctx;\n        const o = ctx.createOscillator();\n        o.type = 'sawtooth';\n        o.frequency.value = 220;\n        const g = ctx.createGain();\n        g.gain.value = 0;\n        const now = ctx.currentTime;\n        o.connect(g);\n        g.connect(this.masterGain);\n        g.gain.setValueAtTime(0.0001, now);\n        g.gain.exponentialRampToValueAtTime(0.12, now + 0.01);\n        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);\n        o.start(now);\n        o.stop(now + 0.45);\n      } catch (err) {\n        console.warn('playWrong failed', err);\n      }\n    }\n\n    showUnavailable() {\n      // Called when audio cannot be created; no-op except for logging\n      console.warn('Audio is unavailable.');\n    }\n  }\n\n  const audio = new AudioManager();\n\n  // Game objects\n  class Part {\n    constructor(id, x, y, number, shapeIdx = 0, color = null) {\n      this.id = id;\n      this.x = x;\n      this.y = y;\n      this.number = number;\n      this.shapeIdx = shapeIdx;\n      this.color = color || pick(PALETTE.partFill);\n      this.radius = 28;\n      this.selected = false;\n      this.hover = false;\n    }\n\n    draw(ctx, angle = 0) {\n      // Draw a wacky machine part shape\n      ctx.save();\n      ctx.translate(this.x, this.y);\n      ctx.rotate(angle);\n      // outline blob\n      ctx.beginPath();\n      const r = this.radius;\n      ctx.fillStyle = this.selected ? '#fff1b6' : this.color;\n      ctx.strokeStyle = this.selected ? '#ff9b9b' : '#9aa9a6';\n      ctx.lineWidth = this.selected ? 4 : 2;\n      // Use a rounded rect with funny knobs\n      ctx.moveTo(-r, -r * 0.6);\n      ctx.quadraticCurveTo(-r * 1.4, 0, -r, r * 0.6);\n      ctx.quadraticCurveTo(-r * 0.6, r * 1.4, 0, r);\n      ctx.quadraticCurveTo(r * 0.6, r * 1.4, r, r * 0.6);\n      ctx.quadraticCurveTo(r * 1.4, 0, r, -r * 0.6);\n      ctx.quadraticCurveTo(r * 0.6, -r * 1.2, 0, -r * 1.05);\n      ctx.quadraticCurveTo(-r * 0.6, -r * 1.2, -r, -r * 0.6);\n      ctx.closePath();\n      ctx.fill();\n      ctx.stroke();\n\n      // little bolts\n      for (let i = -1; i <= 1; i++) {\n        ctx.beginPath();\n        ctx.fillStyle = 'rgba(0,0,0,0.08)';\n        ctx.arc(i * r * 0.6, -r * 0.2, 3, 0, Math.PI * 2);\n        ctx.fill();\n      }\n\n      // number\n      ctx.fillStyle = PALETTE.text;\n      ctx.font = 'bold 18px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(String(this.number), 0, 0);\n\n      // hover glow\n      if (this.hover) {\n        ctx.beginPath();\n        ctx.strokeStyle = 'rgba(255,255,255,0.6)';\n        ctx.lineWidth = 2;\n        ctx.arc(0, 0, r + 6, 0, Math.PI * 2);\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    }\n\n    contains(px, py) {\n      const dx = px - this.x;\n      const dy = py - this.y;\n      return Math.sqrt(dx * dx + dy * dy) <= this.radius + 6;\n    }\n  }\n\n  class Game {\n    constructor() {\n      this.parts = [];\n      this.lastPartId = 0;\n      this.running = true;\n      this.assembled = 0;\n      this.machineIndex = 0;\n      this.target = 0;\n      this.requiredParts = []; // numbers that compose target\n      this.currentSum = 0;\n      this.selectedIds = new Set();\n      this.time = 0;\n      this.lastTime = performance.now();\n      this.speed = PART_SPEED;\n      this.selectorIndex = 0; // for keyboard navigation\n      this.hoverPart = null;\n      this.message = '';\n      this.messageTimer = 0;\n      this.won = false;\n      this.showInstructions = true;\n      this.speakerAnimating = 0;\n      this.init();\n    }\n\n    init() {\n      // generate an initial conveyor layout\n      this.parts = [];\n      this.lastPartId = 0;\n      this.assembled = 0;\n      this.machineIndex = 0;\n      this.won = false;\n      this.selectedIds.clear();\n      this.selectorIndex = 0;\n      this.createNextMachine();\n      for (let i = 0; i < PART_COUNT; i++) {\n        this.spawnPart(WIDTH + i * 80 + randInt(0, 80));\n      }\n      this.updateStatus(`Welcome! Target: ${this.target}. Use arrow keys and Enter to pick parts.`);\n    }\n\n    updateStatus(text) {\n      statusRegion.textContent = text;\n    }\n\n    createNextMachine() {\n      // create a target by choosing 2 or 3 numbers between 1 and 12 (age-appropriate)\n      this.machineIndex++;\n      const count = clamp(2 + Math.floor(this.machineIndex / 3), 2, 4); // slowly increase components\n      const nums = [];\n      let sum = 0;\n      for (let i = 0; i < count; i++) {\n        const n = randInt(1, Math.min(12, 6 + this.machineIndex)); // numbers slightly larger with level\n        nums.push(n);\n        sum += n;\n      }\n      // sometimes create simpler target if too large for young players\n      if (sum > 20) {\n        while (sum > 20) {\n          const idx = randInt(0, nums.length - 1);\n          nums[idx] = Math.max(1, nums[idx] - 1);\n          sum = nums.reduce((a, b) => a + b, 0);\n        }\n      }\n      this.requiredParts = nums.slice();\n      this.target = nums.reduce((a, b) => a + b, 0);\n      this.currentSum = 0;\n      this.selectedIds.clear();\n      // ensure required parts are on the belt soon: spawn them in next few positions\n      this.spawnRequiredPartsOnBelt(nums);\n      this.updateStatus(`Assemble machine ${this.machineIndex}. Target power: ${this.target}.`);\n    }\n\n    spawnRequiredPartsOnBelt(nums) {\n      // place required numbers at various future x positions so player can catch them\n      const baseX = WIDTH + 60;\n      const spacing = 110;\n      for (let i = 0; i < nums.length; i++) {\n        const x = baseX + i * spacing + randInt(-10, 10);\n        const y = BELT_Y + BELT_HEIGHT / 2 + randInt(-15, 15);\n        const p = new Part(++this.lastPartId, x, y, nums[i]);\n        p.color = pick(PALETTE.partFill);\n        this.parts.push(p);\n      }\n    }\n\n    spawnPart(x) {\n      const y = BELT_Y + BELT_HEIGHT / 2 + randInt(-18, 18);\n      const number = randInt(1, 12);\n      const p = new Part(++this.lastPartId, x, y, number);\n      this.parts.push(p);\n    }\n\n    handlePick(part) {\n      if (this.won) return;\n      if (!part) return;\n      // toggle selection\n      if (this.selectedIds.has(part.id)) {\n        this.selectedIds.delete(part.id);\n        part.selected = false;\n        this.recalcSum();\n        audio.playClick();\n        this.updateStatus(`Removed ${part.number}. Current sum ${this.currentSum} / ${this.target}.`);\n        return;\n      }\n\n      // select\n      this.selectedIds.add(part.id);\n      part.selected = true;\n      this.recalcSum();\n      audio.playClick();\n      if (this.currentSum === this.target) {\n        // success\n        audio.playCorrect();\n        this.assembled++;\n        this.message = 'Machine assembled! Great job!';\n        this.messageTimer = 1500;\n        this.updateStatus(`Correct! Machine assembled. ${this.assembled} / ${TARGET_MACHINES}`);\n        // clear selected parts (they get consumed)\n        this.parts = this.parts.filter(p => !this.selectedIds.has(p.id));\n        this.selectedIds.clear();\n        this.currentSum = 0;\n        // step to next machine or win\n        if (this.assembled >= TARGET_MACHINES) {\n          this.win();\n          return;\n        }\n        // create next machine\n        setTimeout(() => {\n          this.createNextMachine();\n        }, 900);\n      } else if (this.currentSum > this.target) {\n        // wrong\n        audio.playWrong();\n        this.message = 'Oh no \u2014 too much power! Try again.';\n        this.messageTimer = 1500;\n        this.updateStatus(`Too much. Current sum ${this.currentSum}. Resetting selections.`);\n        // deselect all\n        this.parts.forEach(p => (p.selected = false));\n        this.selectedIds.clear();\n        this.currentSum = 0;\n      } else {\n        this.updateStatus(`Selected ${part.number}. Current sum ${this.currentSum} / ${this.target}.`);\n      }\n    }\n\n    recalcSum() {\n      let sum = 0;\n      for (const id of this.selectedIds) {\n        const p = this.parts.find(x => x.id === id);\n        if (p) sum += p.number;\n      }\n      this.currentSum = sum;\n    }\n\n    win() {\n      this.won = true;\n      this.message = 'You assembled all machines! You win!';\n      this.messageTimer = 4000;\n      audio.playCorrect();\n      this.updateStatus('Victory! You assembled all machines. Press R to play again.');\n    }\n\n    restart() {\n      this.init();\n      this.message = '';\n      this.messageTimer = 0;\n      this.won = false;\n    }\n\n    update(dt) {\n      // move parts\n      for (const p of this.parts) {\n        p.x -= this.speed * dt;\n      }\n      // remove parts that have moved far left\n      this.parts = this.parts.filter(p => p.x > -80);\n\n      // spawn new parts if needed\n      while (this.parts.length < PART_COUNT) {\n        const lastX = this.parts.length ? Math.max(...this.parts.map(p => p.x)) : WIDTH;\n        this.spawnPart(lastX + randInt(80, 140));\n      }\n\n      // update selector index to clamp\n      if (this.selectorIndex >= this.parts.length) this.selectorIndex = Math.max(0, this.parts.length - 1);\n\n      // manage message timer\n      if (this.messageTimer > 0) {\n        this.messageTimer -= dt;\n        if (this.messageTimer <= 0) this.message = '';\n      }\n    }\n\n    draw() {\n      // background\n      ctx.fillStyle = PALETTE.bg;\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n      // soft patterned top\n      for (let i = -20; i < WIDTH; i += 80) {\n        ctx.fillStyle = 'rgba(255,255,255,0.06)';\n        ctx.beginPath();\n        ctx.ellipse(i + 40, 60, 60, 20, 0, 0, Math.PI * 2);\n        ctx.fill();\n      }\n\n      // factory gears (calming, slow rotation)\n      this.drawGears();\n\n      // conveyer belt\n      this.drawBelt();\n\n      // parts (floating)\n      const angleBase = (performance.now() % 6000) / 6000 * Math.PI * 2;\n      for (let i = 0; i < this.parts.length; i++) {\n        const p = this.parts[i];\n        const a = angleBase * (0.2 + (p.id % 5) * 0.05);\n        p.draw(ctx, a);\n      }\n\n      // selector (robotic claw) - highlight selected index or hovered\n      this.drawSelector();\n\n      // HUD: target, assembled count, instructions toggle, speaker icon\n      this.drawHUD();\n\n      // message\n      if (this.message) {\n        ctx.save();\n        ctx.fillStyle = 'rgba(20,20,30,0.9)';\n        ctx.fillRect(80, 40, 560, 36);\n        ctx.fillStyle = '#fff';\n        ctx.font = '18px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(this.message, WIDTH / 2, 58);\n        ctx.restore();\n      }\n\n      // if won show celebration\n      if (this.won) {\n        this.drawCelebration();\n      }\n\n      // instructions overlay (toggle)\n      if (this.showInstructions) {\n        this.drawInstructions();\n      }\n    }\n\n    drawGears() {\n      // three calm gears with subtle motion\n      const now = performance.now() / 1000;\n      const gearPositions = [{x: 120, y: 110, r: 40, s: 0.02}, {x: 220, y: 150, r: 28, s: -0.03}, {x: 80, y: 180, r: 22, s: 0.015}];\n      for (const g of gearPositions) {\n        this.drawGear(g.x, g.y, g.r, now * g.s);\n      }\n    }\n\n    drawGear(cx, cy, radius, angle) {\n      ctx.save();\n      ctx.translate(cx, cy);\n      ctx.rotate(angle);\n      ctx.fillStyle = PALETTE.gear;\n      ctx.strokeStyle = 'rgba(18,32,36,0.12)';\n      ctx.lineWidth = 2;\n      // gear teeth\n      const teeth = 10;\n      const inner = radius * 0.6;\n      ctx.beginPath();\n      for (let i = 0; i < teeth; i++) {\n        const a = (i / teeth) * Math.PI * 2;\n        const x = Math.cos(a) * (radius + (i % 2 ? 6 : 0));\n        const y = Math.sin(a) * (radius + (i % 2 ? 6 : 0));\n        if (i === 0) ctx.moveTo(x, y);\n        else ctx.lineTo(x, y);\n      }\n      ctx.closePath();\n      ctx.fill();\n      ctx.stroke();\n      // center\n      ctx.beginPath();\n      ctx.fillStyle = '#dfeff2';\n      ctx.arc(0, 0, inner, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n    }\n\n    drawBelt() {\n      // belt base\n      ctx.save();\n      ctx.fillStyle = PALETTE.belt;\n      roundRect(ctx, 0, BELT_Y, WIDTH, BELT_HEIGHT, 8);\n      ctx.fill();\n      // belt shadow\n      ctx.fillStyle = PALETTE.beltShadow;\n      ctx.fillRect(0, BELT_Y + BELT_HEIGHT - 14, WIDTH, 14);\n\n      // dashed lines to show motion\n      ctx.strokeStyle = 'rgba(20,30,30,0.06)';\n      ctx.lineWidth = 12;\n      ctx.lineCap = 'round';\n      const dashOffset = (performance.now() / 40) % 40;\n      ctx.setLineDash([30, 30]);\n      ctx.lineDashOffset = -dashOffset;\n      ctx.beginPath();\n      ctx.moveTo(10, BELT_Y + BELT_HEIGHT - 28);\n      ctx.lineTo(WIDTH - 10, BELT_Y + BELT_HEIGHT - 28);\n      ctx.stroke();\n      ctx.setLineDash([]);\n      ctx.restore();\n    }\n\n    drawSelector() {\n      // choose either hovered part or selectorIndex\n      let p = null;\n      if (this.hoverPart) p = this.hoverPart;\n      else if (this.parts.length) p = this.parts[clamp(this.selectorIndex, 0, this.parts.length - 1)];\n      if (!p) return;\n      // robotic claw drawn near the part\n      ctx.save();\n      const cx = p.x;\n      const cy = p.y - 70;\n      // arm\n      ctx.strokeStyle = '#6b6f72';\n      ctx.lineWidth = 6;\n      ctx.beginPath();\n      ctx.moveTo(cx, cy);\n      ctx.lineTo(cx, p.y - 30);\n      ctx.stroke();\n      // claw\n      ctx.translate(cx, p.y - 18);\n      ctx.fillStyle = PALETTE.selector;\n      ctx.beginPath();\n      ctx.arc(-8, 0, 10, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.beginPath();\n      ctx.arc(8, 0, 10, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n\n      // highlight ring\n      ctx.save();\n      ctx.beginPath();\n      ctx.strokeStyle = 'rgba(255,107,107,0.9)';\n      ctx.lineWidth = 3;\n      ctx.arc(p.x, p.y, p.radius + 10, 0, Math.PI * 2);\n      ctx.stroke();\n      ctx.restore();\n    }\n\n    drawHUD() {\n      // top bar\n      ctx.save();\n      ctx.fillStyle = 'rgba(255,255,255,0.6)';\n      roundRect(ctx, 10, 8, WIDTH - 20, 78, 10);\n      ctx.fill();\n\n      // target display\n      ctx.fillStyle = PALETTE.text;\n      ctx.font = '24px sans-serif';\n      ctx.textAlign = 'left';\n      ctx.fillText('Machine Power:', 28, 30);\n      ctx.font = 'bold 28px monospace';\n      ctx.fillText(String(this.target), 28, 62);\n\n      // current sum badge\n      ctx.save();\n      ctx.fillStyle = '#fff';\n      ctx.strokeStyle = '#e6e6e6';\n      roundRect(ctx, 220, 20, 150, 56, 8);\n      ctx.fill();\n      ctx.stroke();\n      ctx.font = '18px sans-serif';\n      ctx.fillStyle = PALETTE.text;\n      ctx.textAlign = 'center';\n      ctx.fillText('Selected Power', 295, 36);\n      ctx.font = 'bold 22px monospace';\n      ctx.fillText(String(this.currentSum), 295, 62);\n      ctx.restore();\n\n      // assembled count\n      ctx.font = '18px sans-serif';\n      ctx.textAlign = 'right';\n      ctx.fillStyle = PALETTE.text;\n      ctx.fillText(`Assembled: ${this.assembled} / ${TARGET_MACHINES}`, WIDTH - 22, 36);\n\n      // Speaker icon\n      const spX = WIDTH - 46;\n      const spY = 62;\n      ctx.save();\n      ctx.beginPath();\n      ctx.fillStyle = audio.enabled && !audio.muted ? '#2ea3a3' : '#c9c9c9';\n      ctx.rect(spX - 18, spY - 10, 36, 20);\n      ctx.fill();\n      // speaker symbol\n      ctx.fillStyle = '#fff';\n      ctx.beginPath();\n      ctx.moveTo(spX - 24, spY);\n      ctx.lineTo(spX - 10, spY - 12);\n      ctx.lineTo(spX - 10, spY + 12);\n      ctx.closePath();\n      ctx.fill();\n      // bars\n      if (audio.enabled && !audio.muted) {\n        ctx.strokeStyle = 'rgba(255,255,255,0.9)';\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.moveTo(spX - 2, spY - 6);\n        ctx.lineTo(spX + 8, spY - 12 + Math.sin(performance.now() / 300) * 3);\n        ctx.moveTo(spX - 2, spY);\n        ctx.lineTo(spX + 10, spY);\n        ctx.moveTo(spX - 2, spY + 6);\n        ctx.lineTo(spX + 8, spY + 10 + Math.cos(performance.now() / 400) * 3);\n        ctx.stroke();\n      } else {\n        ctx.fillStyle = 'rgba(255,255,255,0.6)';\n        ctx.fillRect(spX - 6, spY - 8, 6, 16);\n      }\n      ctx.restore();\n\n      // small help text\n      ctx.font = '12px sans-serif';\n      ctx.fillStyle = 'rgba(17,40,43,0.6)';\n      ctx.textAlign = 'left';\n      ctx.fillText('Keys: \u2190 \u2192 select, Enter pick, S enable sound, M mute, R restart, H toggle help', 28, HEIGHT - 14);\n      ctx.restore();\n    }\n\n    drawInstructions() {\n      ctx.save();\n      ctx.fillStyle = 'rgba(255,255,255,0.85)';\n      roundRect(ctx, 120, 120, 480, 200, 12);\n      ctx.fill();\n      ctx.strokeStyle = 'rgba(0,0,0,0.06)';\n      ctx.stroke();\n\n      ctx.fillStyle = PALETTE.text;\n      ctx.font = '20px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText('Robo-Assembly Instructions', WIDTH / 2, 150);\n\n      ctx.font = '14px sans-serif';\n      ctx.textAlign = 'left';\n      const lines = [\n        'Assemble each machine by selecting parts whose numbers add',\n        'exactly to the target power shown at the top left.',\n        '',\n        'Use the arrow keys to move the robotic claw and Enter or Space to pick.',\n        'You can also click or tap parts. If the sum is too large, selections reset.',\n        '',\n        'Assemble 5 machines to win. Press S to enable sound (required on some browsers).',\n        'Press H to hide these instructions.'\n      ];\n      let y = 180;\n      for (const line of lines) {\n        ctx.fillText(line, 150, y);\n        y += 22;\n      }\n      ctx.restore();\n    }\n\n    drawCelebration() {\n      // confetti\n      for (let i = 0; i < 25; i++) {\n        const t = (performance.now() / 2000 + i * 0.3) % 1;\n        const x = 100 + (i * 27) % 600;\n        const y = 120 + t * 220;\n        ctx.fillStyle = pick(['#FF6B6B', '#FFD166', '#06D6A0', '#4D96FF', '#C77DFF']);\n        ctx.fillRect(x, y, 6, 12);\n      }\n      // big victory text\n      ctx.save();\n      ctx.fillStyle = '#20323a';\n      ctx.font = '48px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText('Victory! All machines assembled!', WIDTH / 2, 220);\n      ctx.font = '18px sans-serif';\n      ctx.fillText('Press R to play again.', WIDTH / 2, 250);\n      ctx.restore();\n    }\n  }\n\n  // helper to draw rounded rect\n  function roundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n  }\n\n  // Instantiate game\n  const game = new Game();\n\n  // Mouse and touch handling\n  let isPointerDown = false;\n  canvas.addEventListener('mousemove', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);\n    const my = (e.clientY - rect.top) * (canvas.height / rect.height);\n    let found = null;\n    for (const p of game.parts) {\n      if (p.contains(mx, my)) {\n        found = p;\n        p.hover = true;\n      } else {\n        p.hover = false;\n      }\n    }\n    game.hoverPart = found;\n    // update selector to hovered if any\n    if (found) {\n      const idx = game.parts.indexOf(found);\n      if (idx >= 0) game.selectorIndex = idx;\n    }\n  });\n\n  canvas.addEventListener('mouseleave', () => {\n    for (const p of game.parts) p.hover = false;\n    game.hoverPart = null;\n  });\n\n  canvas.addEventListener('click', async (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);\n    const my = (e.clientY - rect.top) * (canvas.height / rect.height);\n    // Check if clicked on speaker icon area (top-right)\n    const spX = WIDTH - 46;\n    const spY = 62;\n    if (mx >= spX - 30 && mx <= spX + 30 && my >= spY - 20 && my <= spY + 20) {\n      // toggle audio enable/mute\n      if (!audio.enabled) {\n        const ok = await audio.initFromUserGesture();\n        if (!ok) {\n          game.updateStatus('Audio not available on this device or blocked by browser.');\n          audio.showUnavailable();\n        } else {\n          game.updateStatus('Audio enabled.');\n        }\n      } else {\n        audio.toggleMute();\n        game.updateStatus(audio.muted ? 'Audio muted.' : 'Audio unmuted.');\n      }\n      return;\n    }\n\n    // if instructions overlay visible and click inside it, hide\n    if (game.showInstructions) {\n      // hide if clicking anywhere inside overlay\n      const ix = 120, iy = 120, iw = 480, ih = 200;\n      if (mx >= ix && mx <= ix + iw && my >= iy && my <= iy + ih) {\n        game.showInstructions = false;\n        game.updateStatus('Instructions hidden. Good luck!');\n        return;\n      }\n    }\n\n    // check parts\n    for (const p of game.parts) {\n      if (p.contains(mx, my)) {\n        // ensure audio context is resumed if suspended (user gesture)\n        if (audio.ctx && audio.ctx.state === 'suspended') {\n          audio.ctx.resume().catch(() => {});\n        }\n        game.handlePick(p);\n        return;\n      }\n    }\n  });\n\n  // Keyboard handling\n  canvas.addEventListener('keydown', async (e) => {\n    if (e.key === 'ArrowRight') {\n      game.selectorIndex = clamp(game.selectorIndex + 1, 0, Math.max(0, game.parts.length - 1));\n      audio.playClick();\n      e.preventDefault();\n      game.updateStatus('Moved right.');\n    } else if (e.key === 'ArrowLeft') {\n      game.selectorIndex = clamp(game.selectorIndex - 1, 0, Math.max(0, game.parts.length - 1));\n      audio.playClick();\n      e.preventDefault();\n      game.updateStatus('Moved left.');\n    } else if (e.key === 'Enter' || e.key === ' ' || e.key === 'Spacebar') {\n      const p = game.parts[game.selectorIndex];\n      if (p) game.handlePick(p);\n      e.preventDefault();\n    } else if (e.key.toLowerCase() === 's') {\n      // enable audio\n      const ok = await audio.initFromUserGesture();\n      if (!ok) {\n        game.updateStatus('Audio unavailable on this device or blocked by browser.');\n      } else {\n        game.updateStatus('Audio enabled.');\n      }\n    } else if (e.key.toLowerCase() === 'm') {\n      if (!audio.enabled) {\n        game.updateStatus('Audio is not enabled. Press S to enable sound.');\n      } else {\n        audio.toggleMute();\n        game.updateStatus(audio.muted ? 'Audio muted.' : 'Audio unmuted.');\n      }\n    } else if (e.key.toLowerCase() === 'r') {\n      game.restart();\n      game.updateStatus('Game restarted.');\n    } else if (e.key.toLowerCase() === 'h') {\n      game.showInstructions = !game.showInstructions;\n      game.updateStatus(game.showInstructions ? 'Showing instructions.' : 'Hiding instructions.');\n    }\n  });\n\n  // Bring focus to canvas for keyboard control\n  canvas.addEventListener('focus', () => {\n    // hint\n  });\n  canvas.focus();\n\n  // Resize handling: keep canvas size fixed; no-op but ensure style\n  function onResize() {\n    // Intentionally empty; canvas fixed size to meet requirement\n  }\n  window.addEventListener('resize', onResize);\n\n  // Main loop\n  let last = performance.now();\n  function loop(now) {\n    const dt = Math.min(60, now - last);\n    last = now;\n\n    game.update(dt);\n    game.draw();\n\n    requestAnimationFrame(loop);\n  }\n  requestAnimationFrame(loop);\n\n  // Initial status text for screen readers\n  game.updateStatus('Welcome to Robo-Assembly! Press H for instructions. Use arrow keys and Enter to play.');\n\n  // Error / Resource handling demonstration: audio creation errors already handled in AudioManager.\n  // Expose minimal debug for console\n  window.RoboAssemblyGame = {\n    restart: () => game.restart(),\n    enableAudio: async () => {\n      const ok = await audio.initFromUserGesture();\n      return ok;\n    }\n  };\n})();\n---\n",
  "improve_response_tokens": 20041,
  "formatted_code": true,
  "formatting_response_tokens": 21268,
  "final_functionality": {
    "score": 7,
    "max_score": 8,
    "percentage": 87.5,
    "passing": true,
    "issues": [],
    "warnings": [
      "No game state management found"
    ]
  }
}