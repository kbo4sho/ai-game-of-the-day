{
  "generated_date": "2025-10-02",
  "generated_timestamp": "2025-10-02T00:26:06.237975",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8360,
  "game_filename": "2025-10-02.js",
  "game_size_bytes": 24730,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Math Machine Game for ages 7-9\n  // Renders inside element with ID 'game-of-the-day-stage'\n  // All visuals drawn on canvas. Audio via Web Audio API oscillators.\n  // Accessible: keyboard controls, aria-live updates, visual cues, instructions.\n\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const LEVEL_COUNT = 6; // number of puzzles to beat the game\n  const CHOICES = 3;\n\n  // Utility: clamp\n  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));\n\n  // Find container\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Game container with ID \"game-of-the-day-stage\" not found.');\n    return;\n  }\n\n  // Clear container\n  container.innerHTML = '';\n  container.style.position = 'relative';\n  container.setAttribute('aria-hidden', 'false');\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.width = WIDTH + 'px';\n  canvas.style.height = HEIGHT + 'px';\n  canvas.setAttribute('role', 'img');\n  canvas.setAttribute('aria-label', 'Math Machine game area');\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Accessibility: a live region for announcements\n  const live = document.createElement('div');\n  live.setAttribute('aria-live', 'polite');\n  live.style.position = 'absolute';\n  live.style.left = '-9999px';\n  live.style.width = '1px';\n  live.style.height = '1px';\n  live.style.overflow = 'hidden';\n  container.appendChild(live);\n\n  // Visual status for audio (drawn on canvas too)\n  let audioEnabled = true;\n  let audioAvailable = true;\n\n  // Audio setup with error handling\n  const AudioCtx = window.AudioContext || window.webkitAudioContext;\n  let audioCtx = null;\n  let ambientNodes = null;\n  try {\n    if (!AudioCtx) throw new Error('Web Audio API not supported in this browser.');\n    audioCtx = new AudioCtx();\n    // Resume on user gesture if needed\n    if (audioCtx.state === 'suspended') {\n      // Some browsers require a user gesture; we'll resume when user interacts.\n      audioCtx.resume().catch(() => {\n        // We'll handle resume later on interaction\n      });\n    }\n  } catch (e) {\n    console.warn('Audio unavailable:', e);\n    audioAvailable = false;\n    audioEnabled = false;\n  }\n\n  // Create ambient sound (gentle machine hum)\n  function startAmbient() {\n    if (!audioAvailable || !audioEnabled || !audioCtx) return;\n    stopAmbient();\n    try {\n      const master = audioCtx.createGain();\n      master.gain.value = 0.06;\n      master.connect(audioCtx.destination);\n\n      // Low slow oscillator for hum\n      const osc = audioCtx.createOscillator();\n      osc.type = 'sine';\n      osc.frequency.value = 110; // low hum\n\n      // Tremolo via LFO\n      const lfo = audioCtx.createOscillator();\n      lfo.type = 'triangle';\n      lfo.frequency.value = 0.15;\n\n      const lfoGain = audioCtx.createGain();\n      lfoGain.gain.value = 0.4;\n\n      lfo.connect(lfoGain);\n      lfoGain.connect(master.gain);\n\n      osc.connect(master);\n\n      osc.start();\n      lfo.start();\n\n      ambientNodes = { osc, lfo, master };\n    } catch (err) {\n      console.warn('Ambient sound error:', err);\n    }\n  }\n\n  function stopAmbient() {\n    if (!ambientNodes) return;\n    try {\n      ambientNodes.osc.stop();\n      ambientNodes.lfo.stop();\n      ambientNodes.osc.disconnect();\n      ambientNodes.lfo.disconnect();\n      ambientNodes.master.disconnect();\n    } catch (e) {\n      // ignore\n    }\n    ambientNodes = null;\n  }\n\n  // Play a short chime for correct answers\n  function playCorrect() {\n    if (!audioAvailable || !audioEnabled || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const master = audioCtx.createGain();\n      master.gain.value = 0.0001;\n      master.connect(audioCtx.destination);\n\n      // Two-tone arpeggio\n      const freqs = [880, 1320]; // A5 and E6ish\n      freqs.forEach((f, i) => {\n        const o = audioCtx.createOscillator();\n        o.type = 'sine';\n        o.frequency.value = f;\n        const g = audioCtx.createGain();\n        g.gain.value = 0.0;\n        o.connect(g);\n        g.connect(master);\n        o.start(now + i * 0.08);\n        g.gain.linearRampToValueAtTime(0.12, now + i * 0.02);\n        g.gain.exponentialRampToValueAtTime(0.0001, now + i * 0.4);\n        o.stop(now + i * 0.5);\n      });\n\n      // swell\n      master.gain.linearRampToValueAtTime(0.12, now + 0.01);\n      master.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);\n      setTimeout(() => master.disconnect(), 800);\n    } catch (e) {\n      console.warn('playCorrect error', e);\n    }\n  }\n\n  // Play a short buzzer for incorrect answers\n  function playIncorrect() {\n    if (!audioAvailable || !audioEnabled || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const o = audioCtx.createOscillator();\n      o.type = 'square';\n      o.frequency.value = 220;\n      const g = audioCtx.createGain();\n      g.gain.value = 0.0001;\n      const filter = audioCtx.createBiquadFilter();\n      filter.type = 'lowpass';\n      filter.frequency.value = 1200;\n      o.connect(filter);\n      filter.connect(g);\n      g.connect(audioCtx.destination);\n      o.start(now);\n      g.gain.exponentialRampToValueAtTime(0.15, now + 0.02);\n      o.frequency.setValueAtTime(220, now);\n      o.frequency.exponentialRampToValueAtTime(80, now + 0.35);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);\n      o.stop(now + 0.45);\n    } catch (e) {\n      console.warn('playIncorrect error', e);\n    }\n  }\n\n  // Click sound for interactions\n  function playClick() {\n    if (!audioAvailable || !audioEnabled || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const o = audioCtx.createOscillator();\n      o.type = 'triangle';\n      o.frequency.value = 660;\n      const g = audioCtx.createGain();\n      g.gain.value = 0.0001;\n      o.connect(g);\n      g.connect(audioCtx.destination);\n      o.start(now);\n      g.gain.exponentialRampToValueAtTime(0.09, now + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);\n      o.stop(now + 0.2);\n    } catch (e) {\n      console.warn('playClick error', e);\n    }\n  }\n\n  // Ensure audio resumes on first interaction if suspended\n  function tryResumeAudio() {\n    if (!audioCtx) return;\n    if (audioCtx.state === 'suspended') {\n      audioCtx.resume().then(() => {\n        if (audioEnabled) startAmbient();\n      }).catch(() => {\n        // ignore\n      });\n    }\n  }\n\n  // Game utilities for generating problems\n  function randomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  function generateProblem(levelIndex) {\n    // Gradually increase difficulty: sum up to 10 then up to 20\n    const maxSum = levelIndex < 2 ? 10 : levelIndex < 4 ? 15 : 20;\n    const isAddition = Math.random() > 0.3; // mostly addition\n    if (isAddition) {\n      const a = randomInt(0, Math.min(12, maxSum));\n      const b = randomInt(0, Math.min(maxSum - a, 12));\n      return { type: 'add', a, b, answer: a + b };\n    } else {\n      const a = randomInt(0, Math.min(maxSum, 18));\n      const b = randomInt(0, a); // ensure non-negative result\n      return { type: 'sub', a, b, answer: a - b };\n    }\n  }\n\n  function makeChoices(correct, levelIndex) {\n    const choices = new Set([correct]);\n    while (choices.size < CHOICES) {\n      const spread = Math.max(3, Math.floor(5 + levelIndex * 1.2));\n      const candidate = correct + randomInt(-spread, spread);\n      if (candidate >= 0 && candidate <= 30) choices.add(candidate);\n    }\n    const arr = Array.from(choices);\n    // shuffle\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    return arr;\n  }\n\n  // Game state\n  const game = {\n    levelIndex: 0,\n    problems: [],\n    currentProblem: null,\n    choices: [],\n    selectedChoiceIndex: 0,\n    score: 0,\n    completed: false,\n    lastFeedback: '', // message for aria\n    audioMutedManually: false,\n    paused: false\n  };\n\n  // Prepare levels\n  for (let i = 0; i < LEVEL_COUNT; i++) {\n    const p = generateProblem(i);\n    game.problems.push(p);\n  }\n\n  function startLevel(index) {\n    game.levelIndex = clamp(index, 0, LEVEL_COUNT - 1);\n    game.currentProblem = game.problems[game.levelIndex];\n    game.choices = makeChoices(game.currentProblem.answer, game.levelIndex);\n    game.selectedChoiceIndex = 0;\n    game.lastFeedback = `Level ${game.levelIndex + 1} of ${LEVEL_COUNT}: Solve the machine puzzle.`;\n    announce(game.lastFeedback);\n  }\n\n  // Announce text to aria-live region\n  function announce(text) {\n    live.textContent = text;\n  }\n\n  // Geometry for UI elements\n  const machineArea = { x: 40, y: 80, w: 420, h: 300 };\n  const choicesArea = { x: 480, y: 120, w: 200, h: 260 };\n\n  function drawRoundedRect(ctx, x, y, w, h, r) {\n    const radius = r || 8;\n    ctx.beginPath();\n    ctx.moveTo(x + radius, y);\n    ctx.arcTo(x + w, y, x + w, y + h, radius);\n    ctx.arcTo(x + w, y + h, x, y + h, radius);\n    ctx.arcTo(x, y + h, x, y, radius);\n    ctx.arcTo(x, y, x + w, y, radius);\n    ctx.closePath();\n  }\n\n  // Draw gear-like wacky elements\n  function drawGear(ctx, cx, cy, radius, teeth, color, angle) {\n    ctx.save();\n    ctx.translate(cx, cy);\n    ctx.rotate(angle || 0);\n    ctx.beginPath();\n    for (let i = 0; i < teeth * 2; i++) {\n      const r = i % 2 === 0 ? radius : radius * 0.7;\n      const a = (i / (teeth * 2)) * Math.PI * 2;\n      const x = Math.cos(a) * r;\n      const y = Math.sin(a) * r;\n      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);\n    }\n    ctx.closePath();\n    ctx.fillStyle = color;\n    ctx.fill();\n    // center hole\n    ctx.beginPath();\n    ctx.arc(0, 0, radius * 0.35, 0, Math.PI * 2);\n    ctx.fillStyle = '#ffee';\n    ctx.fill();\n    ctx.restore();\n  }\n\n  // Simple confetti celebration\n  let confettiParticles = [];\n  function spawnConfetti() {\n    confettiParticles = [];\n    for (let i = 0; i < 80; i++) {\n      confettiParticles.push({\n        x: randomInt(100, WIDTH - 100),\n        y: randomInt(-80, 0),\n        vx: (Math.random() - 0.5) * 2,\n        vy: Math.random() * 2 + 1,\n        size: randomInt(6, 12),\n        color: `hsl(${Math.floor(Math.random() * 360)}, 70%, 60%)`,\n        rot: Math.random() * Math.PI * 2\n      });\n    }\n  }\n\n  // Draw everything\n  let lastTime = 0;\n  let gearAngle = 0;\n  let celebrationTime = 0;\n\n  function draw(time) {\n    const dt = Math.min(0.04, (time - lastTime) / 1000 || 0);\n    lastTime = time;\n    // background\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    // soft gradient sky\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, '#f6f9ff');\n    g.addColorStop(1, '#eaf2f8');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // title and instructions\n    ctx.fillStyle = '#334';\n    ctx.font = 'bold 20px \"Segoe UI\", Roboto, Arial';\n    ctx.fillText('Math Machines: Fix the Wacky Robot!', 18, 28);\n    ctx.font = '13px \"Segoe UI\", Roboto, Arial';\n    ctx.fillStyle = '#345';\n    ctx.fillText('Solve the math to fit parts into the machine. Use 1-3 keys or arrows + Enter. M to mute.', 18, 48);\n\n    // machine background panel\n    ctx.save();\n    drawRoundedRect(ctx, machineArea.x, machineArea.y, machineArea.w, machineArea.h, 16);\n    ctx.fillStyle = '#f0f7fa';\n    ctx.fill();\n    ctx.strokeStyle = '#cfe6ee';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    ctx.restore();\n\n    // draw gears on the left machine\n    gearAngle += dt * 0.8;\n    drawGear(ctx, machineArea.x + 80, machineArea.y + 80, 44, 12, '#c8dbe1', gearAngle);\n    drawGear(ctx, machineArea.x + 160, machineArea.y + 220, 32, 10, '#dceff4', -gearAngle * 1.4);\n    drawGear(ctx, machineArea.x + 260, machineArea.y + 120, 22, 8, '#d0e6ec', gearAngle * 0.6);\n\n    // draw the \"robot\" machine: wacky shapes that fill in when correct\n    const robotX = machineArea.x + 230;\n    const robotY = machineArea.y + 180;\n    // base body\n    ctx.save();\n    ctx.translate(robotX, robotY);\n    // body color changes slightly with progress\n    const progress = game.score / LEVEL_COUNT;\n    const bodyR = 200 - progress * 40;\n    const bodyG = 230 - progress * 60;\n    const bodyB = 250 - progress * 80;\n    ctx.fillStyle = `rgb(${bodyR}, ${bodyG}, ${bodyB})`;\n    drawRoundedRect(ctx, -90, -70, 140, 120, 18);\n    ctx.fill();\n    ctx.strokeStyle = '#bcd6e0';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n\n    // face area\n    ctx.fillStyle = '#fff';\n    ctx.beginPath();\n    ctx.ellipse(-20, -30, 54, 36, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n\n    // eyes: add if progress >= levels\n    ctx.fillStyle = '#334';\n    ctx.beginPath();\n    ctx.arc(-36, -34, 6 + progress * 4, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(-4, -34, 6 + progress * 4, 0, Math.PI * 2);\n    ctx.fill();\n\n    // mouth: changes when correct\n    ctx.strokeStyle = '#334';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    const mouthY = -12 + (1 - progress) * 6;\n    ctx.arc(-20, mouthY, 16, 0, Math.PI, false);\n    ctx.stroke();\n\n    // arms: draw little pistons\n    ctx.fillStyle = '#dbeef7';\n    ctx.fillRect(50, -10, 12, 10);\n    ctx.fillRect(-102, -10, 12, 10);\n\n    ctx.restore();\n\n    // Draw current problem text on machine\n    ctx.fillStyle = '#133';\n    ctx.font = '18px \"Segoe UI\", Roboto, Arial';\n    if (game.currentProblem) {\n      const p = game.currentProblem;\n      const eq = p.type === 'add' ? `${p.a} + ${p.b} = ?` : `${p.a} - ${p.b} = ?`;\n      ctx.fillText('Machine Puzzle: ' + eq, machineArea.x + 16, machineArea.y + 40);\n    } else {\n      ctx.fillText('Loading puzzle...', machineArea.x + 16, machineArea.y + 40);\n    }\n\n    // Draw choices panel\n    ctx.save();\n    drawRoundedRect(ctx, choicesArea.x, choicesArea.y, choicesArea.w, choicesArea.h, 12);\n    ctx.fillStyle = '#fff';\n    ctx.fill();\n    ctx.strokeStyle = '#cfe6ee';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    ctx.fillStyle = '#234';\n    ctx.font = '16px \"Segoe UI\", Roboto, Arial';\n    ctx.fillText('Parts (choices):', choicesArea.x + 12, choicesArea.y + 28);\n\n    // draw each choice button\n    const buttonH = 54;\n    const gap = 16;\n    for (let i = 0; i < CHOICES; i++) {\n      const bx = choicesArea.x + 12;\n      const by = choicesArea.y + 48 + i * (buttonH + gap);\n      const bw = choicesArea.w - 24;\n      // button background\n      const isSelected = game.selectedChoiceIndex === i;\n      drawRoundedRect(ctx, bx, by, bw, buttonH, 10);\n      ctx.fillStyle = isSelected ? '#d9f3ff' : '#f8fdff';\n      ctx.fill();\n      ctx.strokeStyle = isSelected ? '#77c6dc' : '#dceff4';\n      ctx.lineWidth = isSelected ? 3 : 2;\n      ctx.stroke();\n\n      // number text\n      ctx.fillStyle = '#123';\n      ctx.font = '22px \"Segoe UI\", Roboto, Arial';\n      const text = game.choices[i] !== undefined ? String(game.choices[i]) : '-';\n      ctx.fillText(text, bx + 18, by + 34);\n\n      // label 1/2/3 for keyboard\n      ctx.fillStyle = '#6aa';\n      ctx.font = '12px \"Segoe UI\", Roboto, Arial';\n      ctx.fillText(`(${i + 1})`, bx + bw - 34, by + 20);\n\n      // visual hint for correct last answer when incorrect chosen recently\n      // (we store feedback)\n      if (game.lastFeedback && game.lastFeedback.includes('Correct') && game.choices[i] === game.currentProblem.answer) {\n        // gentle glow\n        ctx.save();\n        ctx.globalAlpha = 0.12;\n        ctx.fillStyle = '#8ee6b7';\n        drawRoundedRect(ctx, bx - 2, by - 2, bw + 4, buttonH + 4, 12);\n        ctx.fill();\n        ctx.restore();\n      }\n    }\n    ctx.restore();\n\n    // Draw score/progress and audio indicator\n    // progress bar\n    const barX = 18;\n    const barY = HEIGHT - 50;\n    const barW = WIDTH - 36;\n    ctx.fillStyle = '#eef7fb';\n    drawRoundedRect(ctx, barX, barY, barW, 36, 8);\n    ctx.fill();\n    ctx.strokeStyle = '#cfe6ee';\n    ctx.stroke();\n\n    // filled progress\n    const filledW = (game.score / LEVEL_COUNT) * (barW - 8);\n    ctx.fillStyle = '#bfe8ff';\n    drawRoundedRect(ctx, barX + 4, barY + 4, filledW, 28, 6);\n    ctx.fill();\n\n    ctx.fillStyle = '#224';\n    ctx.font = '14px \"Segoe UI\", Roboto, Arial';\n    ctx.fillText(`Progress: ${game.score} / ${LEVEL_COUNT}`, barX + 12, barY + 24);\n\n    // audio icon\n    ctx.save();\n    const audioX = WIDTH - 58;\n    const audioY = 18;\n    ctx.fillStyle = audioEnabled ? '#4a9' : '#bbb';\n    ctx.beginPath();\n    ctx.moveTo(audioX, audioY + 6);\n    ctx.lineTo(audioX + 10, audioY + 6);\n    ctx.lineTo(audioX + 18, audioY);\n    ctx.lineTo(audioX + 18, audioY + 24);\n    ctx.lineTo(audioX + 10, audioY + 18);\n    ctx.lineTo(audioX, audioY + 18);\n    ctx.closePath();\n    ctx.fill();\n    if (!audioEnabled) {\n      ctx.strokeStyle = '#fff';\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(audioX + 2, audioY + 2);\n      ctx.lineTo(audioX + 22, audioY + 22);\n      ctx.stroke();\n    } else {\n      // small wave lines\n      ctx.strokeStyle = '#fff';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.moveTo(audioX + 22, audioY + 6);\n      ctx.quadraticCurveTo(audioX + 28, audioY + 12, audioX + 22, audioY + 18);\n      ctx.stroke();\n    }\n    ctx.restore();\n\n    // Feedback text\n    ctx.fillStyle = '#145';\n    ctx.font = '14px \"Segoe UI\", Roboto, Arial';\n    if (game.lastFeedback) {\n      ctx.fillText(game.lastFeedback, 18, HEIGHT - 76);\n    }\n\n    // Victory celebration\n    if (game.completed) {\n      celebrationTime += dt;\n      ctx.save();\n      ctx.fillStyle = 'rgba(255,255,255,0.6)';\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n      ctx.restore();\n\n      // animate confetti\n      confettiParticles.forEach(p => {\n        p.x += p.vx;\n        p.y += p.vy;\n        p.rot += 0.1;\n        ctx.save();\n        ctx.translate(p.x, p.y);\n        ctx.rotate(p.rot);\n        ctx.fillStyle = p.color;\n        ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size * 0.6);\n        ctx.restore();\n      });\n\n      // show message\n      ctx.fillStyle = '#134';\n      ctx.font = '28px \"Segoe UI\", Roboto, Arial';\n      ctx.fillText('Machine Fixed! Great Job!', WIDTH / 2 - 180, HEIGHT / 2 - 10);\n      ctx.font = '16px \"Segoe UI\", Roboto, Arial';\n      ctx.fillText('Play again? Press R or click the glowing robot.', WIDTH / 2 - 170, HEIGHT / 2 + 20);\n    }\n\n    // animate confetti gravity and remove\n    confettiParticles = confettiParticles.filter(p => p.y < HEIGHT + 40);\n\n    requestAnimationFrame(draw);\n  }\n\n  // Interaction handling\n  canvas.addEventListener('click', (e) => {\n    tryResumeAudio();\n    playClick();\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    // if completed: click on robot area restarts\n    if (game.completed) {\n      const robotX = machineArea.x + 230;\n      const robotY = machineArea.y + 180;\n      const dx = x - robotX;\n      const dy = y - robotY;\n      if (dx > -120 && dx < 120 && dy > -120 && dy < 120) {\n        restartGame();\n        return;\n      }\n    }\n\n    // check choices\n    for (let i = 0; i < CHOICES; i++) {\n      const bx = choicesArea.x + 12;\n      const by = choicesArea.y + 48 + i * (54 + 16);\n      const bw = choicesArea.w - 24;\n      const bh = 54;\n      if (x >= bx && x <= bx + bw && y >= by && y <= by + bh) {\n        game.selectedChoiceIndex = i;\n        handleSubmitChoice();\n        return;\n      }\n    }\n\n    // check audio icon click area\n    const audioX = WIDTH - 58;\n    const audioY = 18;\n    if (x >= audioX - 4 && x <= audioX + 28 && y >= audioY - 4 && y <= audioY + 28) {\n      toggleAudio();\n      return;\n    }\n  });\n\n  // Keyboard controls\n  window.addEventListener('keydown', (e) => {\n    // prevent page scroll for arrow keys when focused inside game\n    const allowedKeys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Enter', ' ', 'm', 'M', 'r', 'R'];\n    if (allowedKeys.includes(e.key)) e.preventDefault();\n\n    tryResumeAudio();\n\n    // Number keys 1-3 directly select\n    if (/^[1-3]$/.test(e.key)) {\n      const idx = parseInt(e.key, 10) - 1;\n      if (idx >= 0 && idx < CHOICES && !game.completed) {\n        game.selectedChoiceIndex = idx;\n        playClick();\n        handleSubmitChoice();\n      }\n      return;\n    }\n\n    switch (e.key) {\n      case 'ArrowUp':\n      case 'ArrowLeft':\n        if (!game.completed) {\n          game.selectedChoiceIndex = (game.selectedChoiceIndex + CHOICES - 1) % CHOICES;\n          playClick();\n        }\n        break;\n      case 'ArrowDown':\n      case 'ArrowRight':\n        if (!game.completed) {\n          game.selectedChoiceIndex = (game.selectedChoiceIndex + 1) % CHOICES;\n          playClick();\n        }\n        break;\n      case 'Enter':\n      case ' ':\n        if (game.completed) {\n          restartGame();\n        } else {\n          handleSubmitChoice();\n        }\n        break;\n      case 'm':\n      case 'M':\n        toggleAudio();\n        break;\n      case 'r':\n      case 'R':\n        restartGame();\n        break;\n      default:\n        break;\n    }\n  });\n\n  function toggleAudio() {\n    game.audioMutedManually = !game.audioMutedManually;\n    audioEnabled = !game.audioMutedManually && audioAvailable;\n    if (audioEnabled) {\n      startAmbient();\n      announce('Audio on');\n    } else {\n      stopAmbient();\n      announce('Audio muted');\n    }\n    playClick();\n  }\n\n  // Handle submit choice (selecting the currently highlighted option)\n  function handleSubmitChoice() {\n    if (!game.currentProblem || game.completed) return;\n    const idx = game.selectedChoiceIndex;\n    const chosen = game.choices[idx];\n    if (chosen === undefined) return;\n    if (chosen === game.currentProblem.answer) {\n      // correct\n      playCorrect();\n      game.score += 1;\n      game.lastFeedback = `Correct! ${game.currentProblem.answer} fits perfectly.`;\n      announce(game.lastFeedback);\n      // animate or mark progression: advance to next level after small delay\n      setTimeout(() => {\n        if (game.score >= LEVEL_COUNT) {\n          // won\n          completeGame();\n        } else {\n          startLevel(game.levelIndex + 1);\n        }\n      }, 700);\n    } else {\n      // incorrect\n      playIncorrect();\n      game.lastFeedback = `Not quite. ${chosen} doesn't fit. Try again.`;\n      announce(game.lastFeedback);\n      // small shake or hint: nothing else\n    }\n  }\n\n  function completeGame() {\n    game.completed = true;\n    game.lastFeedback = 'Correct! Machine fixed.';\n    announce('Machine fixed! You win!');\n    spawnConfetti();\n    playCorrect();\n    // stop ambient to highlight celebration then restart ambient after delay\n    stopAmbient();\n    setTimeout(() => {\n      if (!game.audioMutedManually) startAmbient();\n    }, 2000);\n  }\n\n  function restartGame() {\n    // reset game\n    game.levelIndex = 0;\n    game.score = 0;\n    game.completed = false;\n    game.lastFeedback = 'New game started. Fix all machines!';\n    // regenerate problems to keep it fresh\n    game.problems = [];\n    for (let i = 0; i < LEVEL_COUNT; i++) game.problems.push(generateProblem(i));\n    startLevel(0);\n    announce('Game restarted. Use keys 1-3 or arrow keys and Enter to select a part.');\n    playClick();\n    // start ambient if audio available\n    tryResumeAudio();\n    if (audioEnabled) startAmbient();\n  }\n\n  // Initialize\n  function init() {\n    // If audio available and not muted, start ambient\n    if (audioAvailable && audioEnabled) startAmbient();\n\n    // Start first level\n    startLevel(0);\n\n    // initial draw loop\n    requestAnimationFrame(draw);\n\n    // initial announcement\n    announce('Welcome to Math Machines. Press 1, 2, or 3 to choose a part. Press M to toggle audio.');\n  }\n\n  // Error handling for unexpected exceptions\n  window.addEventListener('error', function (ev) {\n    console.error('Unexpected error', ev.error || ev.message);\n    announce('An unexpected error occurred in the game. Please reload the page.');\n  });\n\n  // Provide a small help button drawn as overlay (keyboard accessible via 'H' or 'h')\n  window.addEventListener('keydown', (e) => {\n    if (e.key.toLowerCase() === 'h') {\n      announce('Help: Solve the math shown using the numbered parts on the right. Use 1-3 or arrows + Enter. Press M to mute.');\n    }\n  });\n\n  // Start game on user gesture as well to ensure audio resume\n  function ensureUserGestureListener() {\n    function resumeOnInteraction() {\n      tryResumeAudio();\n      if (audioEnabled) startAmbient();\n      window.removeEventListener('pointerdown', resumeOnInteraction);\n      window.removeEventListener('keydown', resumeOnInteraction);\n    }\n    window.addEventListener('pointerdown', resumeOnInteraction);\n    window.addEventListener('keydown', resumeOnInteraction);\n  }\n  ensureUserGestureListener();\n\n  // Kick off\n  init();\n\n})();\n---\n",
  "improve_response_tokens": 18293,
  "formatted_code": true,
  "formatting_response_tokens": 20950,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}