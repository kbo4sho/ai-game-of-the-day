# Game of the Day - 2025-11-09

## Metadata
- **Generated Date:** 2025-11-09
- **Generated Time:** 2025-11-09T00:30:31.508328
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-11-09.js
- **File Size:** 28101 bytes
- **Tokens Used:** 10038

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-11-09.js` - The playable game
- `2025-11-09.meta.json` - Machine-readable metadata
- `2025-11-09.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 21611

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 24143

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Drone Math Quest - JavaScript game
// Renders inside element with id "game-of-the-day-stage"
// Creates a 720x480 canvas and runs the game

(function () {
  // Ensure stage element exists
  const stage = document.getElementById("game-of-the-day-stage");
  if (!stage) {
    console.error("Missing container element with id 'game-of-the-day-stage'.");
    return;
  }

  // Clear stage and create canvas
  stage.innerHTML = "";
  stage.style.position = stage.style.position || "relative";

  const canvas = document.createElement("canvas");
  canvas.width = 720;
  canvas.height = 480;
  canvas.style.width = "720px";
  canvas.style.height = "480px";
  canvas.setAttribute("role", "img");
  canvas.setAttribute("aria-label", "Drone Math Quest game canvas");
  stage.appendChild(canvas);

  // Create an offscreen accessible status region for screen readers
  const a11yStatus = document.createElement("div");
  a11yStatus.setAttribute("role", "status");
  a11yStatus.setAttribute("aria-live", "polite");
  // visually hide but keep in DOM
  Object.assign(a11yStatus.style, {
    position: "absolute",
    left: "-9999px",
    width: "1px",
    height: "1px",
    overflow: "hidden",
  });
  stage.appendChild(a11yStatus);

  const ctx = canvas.getContext("2d");
  if (!ctx) {
    console.error("2D context not available.");
    return;
  }

  // Audio setup with error handling
  let audioCtx = null;
  let audioEnabled = false;
  let bgGain = null;
  let bgOsc = null;
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (AudioContext) {
      audioCtx = new AudioContext();
      // start suspended to respect autoplay policies; resume on user gesture
      if (audioCtx.state === "running") {
        audioEnabled = true;
      } else {
        audioEnabled = false;
      }
    } else {
      console.warn("Web Audio API not supported in this browser.");
      audioCtx = null;
    }
  } catch (err) {
    console.warn("Error creating AudioContext:", err);
    audioCtx = null;
  }

  // Helper to safely resume audio context on user interaction
  async function ensureAudioRunning() {
    if (!audioCtx) return false;
    try {
      if (audioCtx.state !== "running") {
        await audioCtx.resume();
      }
      audioEnabled = true;
      // start gentle background hum if not present
      startBackgroundHum();
      return true;
    } catch (err) {
      console.warn("Audio context resume failed:", err);
      audioEnabled = false;
      return false;
    }
  }

  // Create gentle background hum using oscillator + slow LFO on gain
  function startBackgroundHum() {
    if (!audioCtx) return;
    try {
      stopBackgroundHum();
      bgOsc = audioCtx.createOscillator();
      bgOsc.type = "sine";
      bgOsc.frequency.value = 120; // base frequency (hum-ish)

      bgGain = audioCtx.createGain();
      bgGain.gain.value = 0.01; // very gentle

      // Create LFO to modulate gain slowly
      const lfo = audioCtx.createOscillator();
      lfo.frequency.value = 0.2; // slow pulse
      const lfoGain = audioCtx.createGain();
      lfoGain.gain.value = 0.008;

      lfo.connect(lfoGain).connect(bgGain.gain);

      bgOsc.connect(bgGain).connect(audioCtx.destination);

      bgOsc.start();
      lfo.start();

      // Keep references so we can stop them later
      bgOsc._lfo = lfo;
      bgOsc._lfoGain = lfoGain;
    } catch (err) {
      console.warn("Error starting background hum:", err);
    }
  }

  function stopBackgroundHum() {
    if (!bgOsc) return;
    try {
      if (bgOsc._lfo) {
        try {
          bgOsc._lfo.stop();
          bgOsc._lfo.disconnect();
        } catch (e) {}
      }
      try {
        bgOsc.stop();
      } catch (e) {}
      bgOsc.disconnect();
    } catch (err) {
      // ignore
    }
    bgOsc = null;
    bgGain = null;
  }

  // Play short beep for correct/incorrect using oscillators, plus filter for timbre
  function playBeep({ pitch = 800, duration = 0.12, type = "sine", volume = 0.08 }) {
    if (!audioCtx || !audioEnabled) return;
    try {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      filter.type = "lowpass";
      filter.frequency.value = 3000;

      osc.type = type;
      osc.frequency.value = pitch;

      gain.gain.value = volume;

      osc.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);

      const now = audioCtx.currentTime;
      gain.gain.setValueAtTime(volume, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + duration);

      osc.start(now);
      osc.stop(now + duration + 0.02);
    } catch (err) {
      console.warn("playBeep error:", err);
    }
  }

  function playCorrectSound() {
    // Triad quick arpeggio
    playBeep({ pitch: 900, duration: 0.12, type: "triangle", volume: 0.08 });
    setTimeout(() => playBeep({ pitch: 1200, duration: 0.09, type: "sine", volume: 0.07 }), 120);
    setTimeout(() => playBeep({ pitch: 1500, duration: 0.08, type: "sine", volume: 0.06 }), 220);
  }

  function playWrongSound() {
    playBeep({ pitch: 220, duration: 0.2, type: "square", volume: 0.09 });
  }

  // Game constants and state
  const WIDTH = 720;
  const HEIGHT = 480;
  const UI_PADDING = 10;
  const SCORE_GOAL = 10;
  const ALLOWED_WRONG = 3;
  const FONT_BODY = "16px sans-serif"; // >=14
  const FONT_IMPORTANT = "20px sans-serif"; // >=18

  let score = 0;
  let wrongCount = 0;
  let currentQuestion = null;
  let choices = [];
  let selectedIndex = 0;
  let gameState = "intro"; // intro, playing, victory, gameover
  let drone = {
    x: WIDTH / 2,
    y: 150,
    w: 120,
    h: 50,
    bobPhase: 0,
    targetX: WIDTH / 2,
    wobble: 0,
  };
  let stars = []; // animated collected stars
  let lastTime = performance.now();

  // UI elements detection (buttons)
  const restartButton = {
    x: WIDTH / 2 - 90,
    y: HEIGHT / 2 + 60,
    w: 180,
    h: 44,
  };
  const soundButton = {
    x: WIDTH - 10 - 36,
    y: 10,
    w: 36,
    h: 36,
  };

  // Generate a new arithmetic question appropriate for ages 7-9
  function generateQuestion() {
    // Mix of addition and subtraction, numbers 0..20 appropriate
    const ops = ["+"];
    // Include subtraction sometimes to vary
    if (Math.random() < 0.4) ops.push("-");
    const op = ops[Math.floor(Math.random() * ops.length)];
    let a, b, answer;
    if (op === "+") {
      a = Math.floor(Math.random() * 12) + 1; // 1..12
      b = Math.floor(Math.random() * 9) + 0; // 0..8
      answer = a + b;
    } else {
      a = Math.floor(Math.random() * 12) + 5; // ensure positive result
      b = Math.floor(Math.random() * 5); // 0..4
      answer = a - b;
    }

    // Build 4 choices including answer and three distractors
    const optionSet = new Set();
    optionSet.add(answer);
    while (optionSet.size < 4) {
      const delta = Math.floor(Math.random() * 7) - 3; // -3..3
      let candidate = answer + delta;
      if (candidate < 0) candidate = Math.abs(candidate + 2);
      // Avoid duplicate
      if (optionSet.has(candidate)) {
        candidate = answer + (Math.floor(Math.random() * 7) + 2);
      }
      optionSet.add(candidate);
    }
    const optionList = Array.from(optionSet);
    // Shuffle options
    for (let i = optionList.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [optionList[i], optionList[j]] = [optionList[j], optionList[i]];
    }

    currentQuestion = {
      a,
      b,
      op,
      answer,
      text: `${a} ${op} ${b} = ?`,
    };
    choices = optionList;
    selectedIndex = 0;
    a11yStatus.textContent = `New question: ${currentQuestion.text}. Options: ${choices.join(", ")}. Press 1 to 4 to choose.`;
  }

  // UI helpers: draw rounded rect
  function drawRoundedRect(x, y, w, h, r, fillStyle) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fillStyle = fillStyle;
    ctx.fill();
  }

  // Draw drone using canvas shapes
  function drawDrone(dt) {
    // bobbing motion
    drone.bobPhase += dt * 0.005;
    const bob = Math.sin(drone.bobPhase * 2) * 6;
    drone.wobble = Math.sin(drone.bobPhase * 4) * 6;

    // slide toward targetX a bit
    drone.x += (drone.targetX - drone.x) * 0.02;

    const cx = drone.x;
    const cy = drone.y + bob;

    // body
    ctx.save();
    ctx.translate(cx, cy);
    // shadow
    ctx.beginPath();
    ctx.ellipse(0, drone.h / 2 + 22, 56, 10, 0, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(0,0,0,0.12)";
    ctx.fill();

    // main body
    ctx.fillStyle = "#88C0D0"; // calm teal
    ctx.beginPath();
    ctx.ellipse(0, 0, drone.w / 2, drone.h / 2, 0, 0, Math.PI * 2);
    ctx.fill();

    // canopy
    ctx.fillStyle = "#5E81AC";
    ctx.beginPath();
    ctx.ellipse(-12, -6, 44, 26, -0.2, 0, Math.PI * 2);
    ctx.fill();

    // propellers - four small circles with little blades
    const props = [
      [-drone.w / 2 + 12, -drone.h / 2 - 8],
      [drone.w / 2 - 12, -drone.h / 2 - 8],
      [-drone.w / 2 + 12, drone.h / 2 + 4],
      [drone.w / 2 - 12, drone.h / 2 + 4],
    ];
    for (let i = 0; i < props.length; i++) {
      const [px, py] = props[i];
      ctx.save();
      ctx.translate(px, py);
      ctx.rotate((drone.bobPhase * (i % 2 ? -1 : 1)) * 6);
      // blades
      ctx.fillStyle = "rgba(0,0,0,0.12)";
      for (let b = 0; b < 3; b++) {
        ctx.rotate((Math.PI * 2) / 3);
        ctx.fillRect(0, -2, 28, 4);
      }
      // center
      ctx.beginPath();
      ctx.arc(0, 0, 6, 0, Math.PI * 2);
      ctx.fillStyle = "#2E3440";
      ctx.fill();
      ctx.restore();
    }

    // package under the drone (math crate)
    ctx.fillStyle = "#D08770";
    ctx.fillRect(-22, 22, 44, 28);
    // math symbol on box
    ctx.fillStyle = "#2E3440";
    ctx.font = "bold 18px sans-serif";
    const symbol = "?";
    const w = ctx.measureText(symbol).width;
    ctx.fillText(symbol, -w / 2, 22 + 18);

    // speech bubble with question
    const bubbleText = currentQuestion ? currentQuestion.text : "Click to start";
    ctx.font = FONT_IMPORTANT;
    const metrics = ctx.measureText(bubbleText);
    const bw = metrics.width + 20;
    const bh = 36;
    const bx = -bw / 2;
    const by = -drone.h / 2 - bh - 12;
    // bubble background
    drawRoundedRect(cx + bx, cy + by, bw, bh, 8, "rgba(255,255,255,0.95)");
    // outline
    ctx.strokeStyle = "rgba(0,0,0,0.06)";
    ctx.lineWidth = 1;
    ctx.strokeRect(cx + bx, cy + by, bw, bh);
    // text
    ctx.fillStyle = "#2E3440";
    ctx.fillText(bubbleText, cx + bx + 10, cy + by + 24);

    ctx.restore();
  }

  // Draw choices as round power-cells at bottom
  function drawChoices() {
    const bottomY = HEIGHT - 100;
    const cellRadius = 36;
    const spacing = 18;
    const totalWidth = choices.length * (cellRadius * 2) + (choices.length - 1) * spacing;
    let startX = (WIDTH - totalWidth) / 2 + cellRadius;

    ctx.font = "16px sans-serif";
    for (let i = 0; i < choices.length; i++) {
      const x = startX + i * (2 * cellRadius + spacing);
      const y = bottomY;
      // background circle
      ctx.beginPath();
      ctx.arc(x, y, cellRadius + 6, 0, Math.PI * 2);
      ctx.fillStyle = selectedIndex === i ? "rgba(232, 145, 85, 0.12)" : "rgba(255,255,255,0.0)";
      ctx.fill();

      // ring
      ctx.beginPath();
      ctx.arc(x, y, cellRadius, 0, Math.PI * 2);
      ctx.fillStyle = "#ECEFF4";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#D8DEE9";
      ctx.stroke();

      // number label (1..4) small
      ctx.fillStyle = "#4C566A";
      ctx.font = "12px sans-serif";
      const idxLabel = `${i + 1}`;
      ctx.fillText(idxLabel, x - cellRadius + 6, y - cellRadius + 14);

      // actual choice value
      ctx.fillStyle = "#2E3440";
      ctx.font = "18px sans-serif";
      const text = String(choices[i]);
      const tw = ctx.measureText(text).width;
      ctx.fillText(text, x - tw / 2, y + 6);
    }
  }

  // Draw top UI (score, goal) ensuring no overlap with padding and using measureText
  function drawTopUI() {
    // Score top-left
    ctx.font = FONT_IMPORTANT;
    const scoreText = `Score: ${score}/${SCORE_GOAL}`;
    const scoreMetrics = ctx.measureText(scoreText);
    const scoreW = scoreMetrics.width + 20;
    const scoreH = 36;
    const scoreX = UI_PADDING;
    const scoreY = UI_PADDING;
    drawRoundedRect(scoreX, scoreY, scoreW, scoreH, 8, "rgba(255,255,255,0.92)");
    ctx.fillStyle = "#2E3440";
    ctx.fillText(scoreText, scoreX + 10, scoreY + 24);

    // Lives top-right
    ctx.font = FONT_IMPORTANT;
    const livesText = `X ${ALLOWED_WRONG - wrongCount} lives`;
    const livesMetrics = ctx.measureText(livesText);
    const livesW = livesMetrics.width + 20;
    const livesH = 36;
    const livesX = WIDTH - UI_PADDING - livesW - soundButton.w - 12; // leave space for sound button
    const livesY = UI_PADDING;
    drawRoundedRect(livesX, livesY, livesW, livesH, 8, "rgba(255,255,255,0.92)");
    ctx.fillStyle = "#2E3440";
    ctx.fillText(livesText, livesX + 10, livesY + 24);

    // Goal text center-top
    ctx.font = "18px sans-serif";
    const goalText = `Collect ${SCORE_GOAL} stars to win`;
    const goalMetrics = ctx.measureText(goalText);
    const goalW = goalMetrics.width + 20;
    const goalH = 32;
    const goalX = (WIDTH - goalW) / 2;
    const goalY = UI_PADDING + 2;
    drawRoundedRect(goalX, goalY, goalW, goalH, 8, "rgba(255,255,255,0.92)");
    ctx.fillStyle = "#2E3440";
    ctx.fillText(goalText, goalX + 10, goalY + 22);

    // Sound button top-right
    ctx.save();
    const sb = soundButton;
    // draw background circle
    drawRoundedRect(sb.x, sb.y, sb.w, sb.h, 8, "rgba(255,255,255,0.92)");
    // speaker icon
    ctx.fillStyle = audioEnabled ? "#88C0D0" : "#D08770";
    ctx.translate(sb.x + sb.w / 2, sb.y + sb.h / 2);
    // speaker box
    ctx.beginPath();
    ctx.moveTo(-8, -6);
    ctx.lineTo(-2, -6);
    ctx.lineTo(6, -12);
    ctx.lineTo(6, 12);
    ctx.lineTo(-2, 6);
    ctx.lineTo(-8, 6);
    ctx.closePath();
    ctx.fill();
    // waves if enabled
    if (audioEnabled) {
      ctx.beginPath();
      ctx.arc(10, -2, 5, -0.8, 0.8);
      ctx.strokeStyle = "#88C0D0";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(12, -2, 9, -0.8, 0.8);
      ctx.stroke();
    } else {
      // draw small X
      ctx.strokeStyle = "#D08770";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(8, -8);
      ctx.lineTo(14, -2);
      ctx.moveTo(8, -2);
      ctx.lineTo(14, -8);
      ctx.stroke();
    }
    ctx.restore();
  }

  // Draw instructions bottom center with background and spacing
  function drawInstructions() {
    ctx.font = FONT_BODY;
    const lines = [
      "How to play: Solve the math shown on the drone. Choose the correct power-cell.",
      "Keyboard: 1-4 select, Left/Right to change, Enter to confirm, R to restart, M to toggle audio.",
      "Goal: Get 10 correct answers. Lose after 3 wrong answers.",
      audioCtx ? "Click anywhere to enable audio if sound is off." : "Audio unavailable in this browser.",
    ];
    const padding = 10;
    // compute width of the longest line
    let maxW = 0;
    ctx.font = FONT_BODY;
    for (const line of lines) {
      const w = ctx.measureText(line).width;
      if (w > maxW) maxW = w;
    }
    const boxW = maxW + padding * 2;
    const boxH = lines.length * 20 + padding * 2;
    const boxX = (WIDTH - boxW) / 2;
    const boxY = HEIGHT - boxH - 10;
    drawRoundedRect(boxX, boxY, boxW, boxH, 8, "rgba(255,255,255,0.92)");
    ctx.fillStyle = "#4C566A";
    ctx.font = FONT_BODY;
    for (let i = 0; i < lines.length; i++) {
      ctx.fillText(lines[i], boxX + padding, boxY + padding + 16 + i * 20);
    }
  }

  // Draw animated stars that fly to score area upon correct answer
  function updateAndDrawStars(dt) {
    for (let i = stars.length - 1; i >= 0; i--) {
      const s = stars[i];
      // simple physics toward target
      s.vx += (s.tx - s.x) * 0.004 * dt;
      s.vy += (s.ty - s.y) * 0.004 * dt + 0.001 * dt;
      s.x += s.vx * dt * 0.001;
      s.y += s.vy * dt * 0.001;
      s.angle += 0.06 * dt * 0.001;

      // draw star shape
      ctx.save();
      ctx.translate(s.x, s.y);
      ctx.rotate(s.angle);
      ctx.fillStyle = s.color;
      ctx.beginPath();
      const rOut = 10;
      const rIn = 4;
      for (let k = 0; k < 10; k++) {
        const r = k % 2 === 0 ? rOut : rIn;
        const a = (k * Math.PI) / 5;
        ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
      }
      ctx.closePath();
      ctx.fill();
      ctx.restore();

      // remove if near target
      if (Math.hypot(s.x - s.tx, s.y - s.ty) < 8) {
        stars.splice(i, 1);
      }
    }
  }

  // Handle correct answer event
  function handleCorrect(xy) {
    score++;
    a11yStatus.textContent = `Correct! Score ${score} of ${SCORE_GOAL}.`;
    // spawn a star at xy that moves to score UI
    const scorePosX = UI_PADDING + 40;
    const scorePosY = UI_PADDING + 18;
    const s = {
      x: xy ? xy.x : drone.x,
      y: xy ? xy.y : drone.y + 40,
      tx: scorePosX,
      ty: scorePosY,
      vx: (Math.random() - 0.5) * 0.5,
      vy: -Math.random() * 0.5 - 0.2,
      angle: Math.random() * Math.PI,
      color: "#EBCB8B",
    };
    stars.push(s);
    try {
      playCorrectSound();
    } catch (err) {
      console.warn("Error playing correct sound:", err);
    }

    // Small drone bounce animation
    drone.targetX = Math.random() * (WIDTH - 200) + 100;

    // Check victory
    if (score >= SCORE_GOAL) {
      gameState = "victory";
      stopBackgroundHum();
      a11yStatus.textContent = `Victory! You collected ${score} stars. Press R to restart.`;
    } else {
      // new question after a brief delay
      setTimeout(() => {
        generateQuestion();
      }, 700);
    }
  }

  // Handle wrong answer event
  function handleWrong() {
    wrongCount++;
    a11yStatus.textContent = `Oops! Wrong answer. ${ALLOWED_WRONG - wrongCount} lives remaining.`;
    try {
      playWrongSound();
    } catch (err) {
      console.warn("Error playing wrong sound:", err);
    }
    // shake drone
    drone.wobble += 12;

    if (wrongCount >= ALLOWED_WRONG) {
      gameState = "gameover";
      stopBackgroundHum();
      a11yStatus.textContent = `Game over. You made ${wrongCount} wrong answers. Press R to restart.`;
    } else {
      // new question soon
      setTimeout(() => {
        generateQuestion();
      }, 700);
    }
  }

  // Validate and process a chosen index
  function chooseIndex(i, clickPos) {
    if (gameState !== "playing") return;
    if (i < 0 || i >= choices.length) return;
    if (!currentQuestion) return;
    const chosen = choices[i];
    if (chosen === currentQuestion.answer) {
      handleCorrect(clickPos || { x: drone.x, y: drone.y });
    } else {
      handleWrong();
    }
  }

  // Draw overlay screens: intro, victory, game over
  function drawOverlay() {
    ctx.save();
    ctx.fillStyle = "rgba(20, 20, 24, 0.62)";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    ctx.fillStyle = "#ECEFF4";
    ctx.font = "28px sans-serif";
    ctx.textAlign = "center";
    if (gameState === "intro") {
      ctx.fillText("Drone Math Quest", WIDTH / 2, HEIGHT / 2 - 80);
      ctx.font = "18px sans-serif";
      ctx.fillText("Help the friendly drone collect power stars by solving math!", WIDTH / 2, HEIGHT / 2 - 40);
      ctx.fillText("Click or press any key to begin (and enable sound if desired).", WIDTH / 2, HEIGHT / 2 - 10);
      // draw start button visual
      drawRoundedRect(restartButton.x, restartButton.y, restartButton.w, restartButton.h, 8, "#88C0D0");
      ctx.fillStyle = "#2E3440";
      ctx.font = "18px sans-serif";
      ctx.fillText("Start Game", WIDTH / 2, restartButton.y + 28);
    } else if (gameState === "victory") {
      ctx.fillText("Victory!", WIDTH / 2, HEIGHT / 2 - 80);
      ctx.font = "18px sans-serif";
      ctx.fillText(`You collected ${score} stars! Great job flying with the drone.`, WIDTH / 2, HEIGHT / 2 - 40);
      // stats
      ctx.fillText(`Wrong answers: ${wrongCount}`, WIDTH / 2, HEIGHT / 2 - 10);
      // restart button
      drawRoundedRect(restartButton.x, restartButton.y, restartButton.w, restartButton.h, 8, "#A3BE8C");
      ctx.fillStyle = "#2E3440";
      ctx.fillText("Play Again (R)", WIDTH / 2, restartButton.y + 28);
    } else if (gameState === "gameover") {
      ctx.fillText("Game Over", WIDTH / 2, HEIGHT / 2 - 80);
      ctx.font = "18px sans-serif";
      ctx.fillText(`You made ${wrongCount} wrong answers. Try again to beat ${SCORE_GOAL} stars.`, WIDTH / 2, HEIGHT / 2 - 40);
      drawRoundedRect(restartButton.x, restartButton.y, restartButton.w, restartButton.h, 8, "#D08770");
      ctx.fillStyle = "#2E3440";
      ctx.fillText("Restart (R)", WIDTH / 2, restartButton.y + 28);
    }
    ctx.restore();
    ctx.textAlign = "left";
  }

  // Main render loop
  function render(now) {
    const dt = now - lastTime;
    lastTime = now;
    // clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // background - calming sky gradient
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, "#E5F6FA");
    g.addColorStop(1, "#F7FBFF");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // playful clouds (wacky elements)
    drawClouds(now);

    // Draw drone and question
    drawDrone(dt);

    // Draw choices and UI
    drawChoices();

    // Update and draw stars
    updateAndDrawStars(dt);

    // Draw top UI
    drawTopUI();

    // Draw instructions bottom
    drawInstructions();

    // Draw subtle ground lines or landing pads
    drawLandingPad();

    // If in overlay states, draw overlay
    if (gameState !== "playing") {
      drawOverlay();
    }

    // Draw any remaining UI, like a small help text or audio indicator
    // Use requestAnimationFrame
    requestAnimationFrame(render);
  }

  // Clouds: wacky but calming
  let cloudPhases = [0, 3000, 6000];
  function drawClouds(now) {
    ctx.save();
    ctx.globalAlpha = 0.9;
    for (let i = 0; i < cloudPhases.length; i++) {
      const cp = cloudPhases[i];
      const x = ((now + cp) * 0.02) % (WIDTH + 200) - 100;
      const y = 40 + i * 30;
      drawCloud(x, y, 80 + i * 10);
    }
    ctx.restore();
  }

  function drawCloud(cx, cy, size) {
    ctx.fillStyle = "#FFFFFF";
    ctx.beginPath();
    ctx.ellipse(cx, cy, size * 0.6, size * 0.36, 0, 0, Math.PI * 2);
    ctx.ellipse(cx + size * 0.5, cy + 4, size * 0.4, size * 0.28, 0, 0, Math.PI * 2);
    ctx.ellipse(cx - size * 0.5, cy + 4, size * 0.4, size * 0.28, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // Landing pad under drone for visual interest
  function drawLandingPad() {
    const padX = WIDTH / 2 - 120;
    const padY = HEIGHT - 170;
    ctx.fillStyle = "#ECEFF4";
    drawRoundedRect(padX, padY, 240, 12, 6, "#E5E9F0");
    ctx.fillStyle = "#D8DEE9";
    ctx.fillRect(padX + 20, padY - 6, 200, 6);
  }

  // Pointer utilities
  function getCanvasPos(evt) {
    const rect = canvas.getBoundingClientRect();
    const x = (evt.clientX - rect.left) * (canvas.width / rect.width);
    const y = (evt.clientY - rect.top) * (canvas.height / rect.height);
    return { x, y };
  }

  // Input handling
  canvas.addEventListener("click", async (evt) => {
    const pos = getCanvasPos(evt);

    // If audio not enabled, user gesture enables audio
    if (audioCtx && !audioEnabled) {
      const ok = await ensureAudioRunning();
      if (ok) {
        a11yStatus.textContent = "Audio enabled.";
      } else {
        a11yStatus.textContent = "Audio could not be enabled.";
      }
    }

    // If overlay intro and click inside start button, begin
    if (gameState === "intro") {
      if (pointInRect(pos, restartButton)) {
        startGame();
      } else {
        startGame();
      }
      return;
    }

    // If overlay (victory/gameover), check restart
    if (gameState === "victory" || gameState === "gameover") {
      if (pointInRect(pos, restartButton)) {
        restartGame();
      }
      return;
    }

    // Sound button click
    if (pointInRect(pos, soundButton)) {
      if (!audioEnabled) {
        // attempt to enable
        const ok = await ensureAudioRunning();
        if (!ok) {
          a11yStatus.textContent = "Audio not available.";
        }
      } else {
        // toggle off
        audioEnabled = false;
        stopBackgroundHum();
        a11yStatus.textContent = "Audio muted.";
      }
      return;
    }

    // Check choices click
    const bottomY = HEIGHT - 100;
    const cellRadius = 36;
    const spacing = 18;
    const totalWidth = choices.length * (cellRadius * 2) + (choices.length - 1) * spacing;
    let startX = (WIDTH - totalWidth) / 2 + cellRadius;
    for (let i = 0; i < choices.length; i++) {
      const x = startX + i * (2 * cellRadius + spacing);
      const y = bottomY;
      if (Math.hypot(pos.x - x, pos.y - y) <= cellRadius + 6) {
        selectedIndex = i;
        chooseIndex(i, pos);
        return;
      }
    }
  });

  function pointInRect(p, r) {
    return p.x >= r.x && p.x <= r.x + r.w && p.y >= r.y && p.y <= r.y + r.h;
  }

  // Keyboard controls
  window.addEventListener("keydown", async (evt) => {
    if (evt.repeat) return;
    const key = evt.key.toLowerCase();
    if (gameState === "intro") {
      // start on any key
      if (key) startGame();
      return;
    }
    // Toggle audio
    if (key === "m") {
      if (!audioEnabled) {
        const ok = await ensureAudioRunning();
        if (!ok) a11yStatus.textContent = "Audio not available.";
      } else {
        audioEnabled = false;
        stopBackgroundHum();
        a11yStatus.textContent = "Audio muted.";
      }
      return;
    }
    if (key === "r") {
      restartGame();
      return;
    }
    if (gameState !== "playing") return;

    if (["1", "2", "3", "4"].includes(key)) {
      const idx = parseInt(key, 10) - 1;
      selectedIndex = idx;
      chooseIndex(idx);
      return;
    }
    if (key === "arrowleft") {
      selectedIndex = (selectedIndex - 1 + choices.length) % choices.length;
      a11yStatus.textContent = `Selected option ${selectedIndex + 1}.`;
      return;
    }
    if (key === "arrowright") {
      selectedIndex = (selectedIndex + 1) % choices.length;
      a11yStatus.textContent = `Selected option ${selectedIndex + 1}.`;
      return;
    }
    if (key === "enter") {
      chooseIndex(selectedIndex);
      return;
    }
  });

  // Restart game
  function restartGame() {
    score = 0;
    wrongCount = 0;
    stars = [];
    currentQuestion = null;
    choices = [];
    selectedIndex = 0;
    gameState = "intro";
    a11yStatus.textContent = "Game reset. Press any key or click to start.";
  }

  // Start actual playing state
  function startGame() {
    if (gameState === "playing") return;
    score = 0;
    wrongCount = 0;
    stars = [];
    drone.targetX = WIDTH / 2;
    generateQuestion();
    gameState = "playing";
    lastTime = performance.now();
    // attempt to ensure audio if possible
    if (audioCtx && !audioEnabled) {
      ensureAudioRunning().then((ok) => {
        if (!ok) {
          // audio not enabled, but continue playing
          a11yStatus.textContent = "Audio not enabled. Press M to enable audio.";
        }
      });
    } else if (audioEnabled) {
      startBackgroundHum();
    }
    a11yStatus.textContent = "Game started. Solve the first question.";
  }

  // Kick off rendering
  lastTime = performance.now();
  requestAnimationFrame(render);

  // Initialize intro state message
  a11yStatus.textContent = "Welcome to Drone Math Quest. Press any key or click to start.";

  // Expose some functions to console for debugging (non-essential)
  window._droneMathQuest = {
    restart: restartGame,
    start: startGame,
    getState: () => ({ score, wrongCount, gameState }),
  };
})();
---

