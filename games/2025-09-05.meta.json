{
  "generated_date": "2025-09-05",
  "generated_timestamp": "2025-09-05T00:27:21.291083",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 10784,
  "game_filename": "2025-09-05.js",
  "game_size_bytes": 33376,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Machine Math: A calming, wacky math game for ages 7-9\n// Renders in the element with ID \"game-of-the-day-stage\"\n// All visuals are canvas-drawn. Sounds use Web Audio API oscillators and filters.\n// Accessible: keyboard controls, aria-live updates, clear instructions, audio on/off.\n\n// Immediately initialize when page loads\n(function () {\n  // Config\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const CONTAINER_ID = 'game-of-the-day-stage';\n  const MAX_LEVELS = 5; // game beatable in 5 levels\n  const PALETTE_SIZE = 6; // number of parts presented each level\n  const SLOT_COUNT_BASE = 3; // base number of slots, increases with level\n  const COLOR_BG = '#E9F3F0'; // calming background\n  const COLOR_ACCENT = '#5C6B8A';\n  const COLOR_GEAR = '#A3C6C2';\n  const COLOR_PART = '#F6C9C2';\n  const COLOR_TEXT = '#203040';\n  const FONT = '16px system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial';\n  const AUDIO_ICON_SIZE = 28;\n\n  // State and elements\n  let container, canvas, ctx;\n  let audioCtx = null;\n  let audioAllowed = true; // will be toggled if audio context creation fails or user mutes\n  let bgOsc = null;\n  let masterGain = null;\n  let lfo = null;\n  let level = 1;\n  let score = 0;\n  let parts = []; // palette parts\n  let slots = []; // machine slots\n  let target = 0;\n  let currentSum = 0;\n  let selectedPaletteIndex = 0;\n  let focusedSlotIndex = 0;\n  let dragging = null; // {type:'palette'|'slot', index, offsetX, offsetY}\n  let mouse = { x: 0, y: 0, down: false };\n  let finished = false;\n  let lastUpdateTime = 0;\n  let animationOffset = 0;\n  let ariaLive; // hidden element for screen reader updates\n  let showAudioDisabledMessage = false;\n\n  // Utility: safe text drawing for accessibility / high contrast\n  function drawText(ctx, text, x, y, size = 16, color = COLOR_TEXT, align = 'left') {\n    ctx.fillStyle = color;\n    ctx.font = `${size}px system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial`;\n    ctx.textAlign = align;\n    ctx.fillText(text, x, y);\n  }\n\n  // Initialize the game\n  function init() {\n    try {\n      container = document.getElementById(CONTAINER_ID);\n      if (!container) {\n        console.error('Game container not found:', CONTAINER_ID);\n        return;\n      }\n\n      // Clear container\n      container.innerHTML = '';\n      container.style.position = 'relative';\n      container.style.width = WIDTH + 'px';\n      container.style.height = HEIGHT + 'px';\n      container.setAttribute('role', 'application');\n      container.setAttribute('aria-label', 'Machine Math game area');\n\n      // Create canvas\n      canvas = document.createElement('canvas');\n      canvas.width = WIDTH;\n      canvas.height = HEIGHT;\n      canvas.style.width = WIDTH + 'px';\n      canvas.style.height = HEIGHT + 'px';\n      canvas.setAttribute('tabindex', '0'); // enable keyboard focus\n      container.appendChild(canvas);\n      ctx = canvas.getContext('2d', { alpha: false });\n\n      // Create offscreen/invisible live region for screen readers\n      ariaLive = document.createElement('div');\n      ariaLive.setAttribute('aria-live', 'polite');\n      ariaLive.setAttribute('aria-atomic', 'true');\n      // visually hide but remain accessible\n      Object.assign(ariaLive.style, {\n        position: 'absolute',\n        left: '0px',\n        top: (HEIGHT + 2) + 'px',\n        width: '1px',\n        height: '1px',\n        overflow: 'hidden',\n        clip: 'rect(1px, 1px, 1px, 1px)',\n        whiteSpace: 'nowrap'\n      });\n      container.appendChild(ariaLive);\n\n      // Setup audio\n      try {\n        const AudioContext = window.AudioContext || window.webkitAudioContext;\n        if (!AudioContext) throw new Error('Web Audio API not supported');\n        audioCtx = new AudioContext();\n        masterGain = audioCtx.createGain();\n        masterGain.gain.value = 0.18; // gentle background + effects\n        masterGain.connect(audioCtx.destination);\n\n        // gentle background hum using oscillator + lowpass\n        bgOsc = audioCtx.createOscillator();\n        bgOsc.type = 'sine';\n        bgOsc.frequency.value = 110; // low tone\n        const bgGain = audioCtx.createGain();\n        bgGain.gain.value = 0.03;\n        const bgFilter = audioCtx.createBiquadFilter();\n        bgFilter.type = 'lowpass';\n        bgFilter.frequency.value = 600;\n\n        lfo = audioCtx.createOscillator();\n        lfo.frequency.value = 0.12; // slow wobble\n        const lfoGain = audioCtx.createGain();\n        lfoGain.gain.value = 40;\n        lfo.connect(lfoGain);\n        lfoGain.connect(bgOsc.frequency);\n\n        bgOsc.connect(bgFilter);\n        bgFilter.connect(bgGain);\n        bgGain.connect(masterGain);\n\n        bgOsc.start();\n        lfo.start();\n      } catch (err) {\n        console.warn('Audio initialization failed:', err);\n        audioAllowed = false;\n        showAudioDisabledMessage = true;\n      }\n\n      // Event listeners\n      canvas.addEventListener('mousedown', onMouseDown);\n      canvas.addEventListener('mousemove', onMouseMove);\n      canvas.addEventListener('mouseup', onMouseUp);\n      canvas.addEventListener('mouseleave', onMouseUp);\n      canvas.addEventListener('touchstart', onTouchStart, { passive: false });\n      canvas.addEventListener('touchmove', onTouchMove, { passive: false });\n      canvas.addEventListener('touchend', onTouchEnd);\n      canvas.addEventListener('keydown', onKeyDown);\n      canvas.addEventListener('focus', () => {\n        // Provide instructions when focused\n        announce('Canvas focused. Use number keys to pick parts, arrow keys to move slots, Enter to place, M to mute.');\n      });\n\n      // Start\n      resetGame();\n      lastUpdateTime = performance.now();\n      requestAnimationFrame(loop);\n    } catch (err) {\n      console.error('Initialization error:', err);\n    }\n  }\n\n  // Reset game state for new playthrough\n  function resetGame() {\n    level = 1;\n    score = 0;\n    finished = false;\n    prepareLevel();\n  }\n\n  // Prepare parts and slots making sure level is solvable\n  function prepareLevel() {\n    // Determine slot count and target complexity\n    const slotCount = SLOT_COUNT_BASE + Math.floor((level - 1) / 1); // increase occasionally\n    const partCount = PALETTE_SIZE;\n    const minValue = 1 + Math.floor((level - 1) * 0.5);\n    const maxValue = 6 + level; // increase max\n    // Create a guaranteed solution: pick random numbers that sum to target\n    const solutionParts = [];\n    // We ensure the solution uses between 2 and slotCount parts\n    const solutionLen = Math.min(slotCount, 2 + (level % slotCount));\n    // Choose target by summing random ints\n    let chosenTarget = 0;\n    for (let i = 0; i < solutionLen; i++) {\n      const v = randInt(minValue, Math.max(minValue + 1, maxValue));\n      solutionParts.push(v);\n      chosenTarget += v;\n    }\n    // Now create palette parts: include solution parts plus decoys\n    const palette = [];\n    // Add solution parts as separate items\n    for (let v of solutionParts) {\n      palette.push({ value: v, id: uniqueId() });\n    }\n    // Add decoys ensuring not to accidentally provide extra solution combinations that break challenge\n    while (palette.length < partCount) {\n      let v = randInt(minValue, maxValue);\n      // avoid exact duplication too often: allow duplicates but ensure not too many\n      if (palette.filter(p => p.value === v).length < 3) {\n        palette.push({ value: v, id: uniqueId() });\n      } else {\n        // pick different\n        v = randInt(minValue, maxValue);\n        palette.push({ value: v, id: uniqueId() });\n      }\n    }\n    // Shuffle palette\n    shuffleArray(palette);\n    // Create parts with positions in palette area (left side)\n    parts = palette.map((p, i) => {\n      return {\n        id: p.id,\n        value: p.value,\n        x: 24,\n        y: 120 + i * 60,\n        w: 92,\n        h: 44,\n        placed: false\n      };\n    });\n    // Create slots on machine area (right side)\n    slots = [];\n    const slotStartX = 380;\n    const slotStartY = 140;\n    const slotGap = 74;\n    for (let i = 0; i < slotCount; i++) {\n      slots.push({\n        index: i,\n        x: slotStartX + (i % 3) * 110,\n        y: slotStartY + Math.floor(i / 3) * slotGap,\n        w: 96,\n        h: 56,\n        part: null // will hold part id\n      });\n    }\n    target = chosenTarget;\n    currentSum = 0;\n    selectedPaletteIndex = 0;\n    focusedSlotIndex = 0;\n    announce(`Level ${level}. Make the machine show ${target} by placing parts. Use numbers keys to pick parts and Enter to place.`);\n  }\n\n  // Unique ID generator\n  function uniqueId() {\n    return Math.random().toString(36).slice(2, 9);\n  }\n\n  // Random integer inclusive\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  // Shuffle array\n  function shuffleArray(a) {\n    for (let i = a.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [a[i], a[j]] = [a[j], a[i]];\n    }\n  }\n\n  // Main loop and render\n  function loop(ts) {\n    const dt = (ts - lastUpdateTime) / 1000;\n    lastUpdateTime = ts;\n    animationOffset += dt * 30;\n    draw();\n    requestAnimationFrame(loop);\n  }\n\n  // Draw entire scene\n  function draw() {\n    // Clear background\n    ctx.fillStyle = COLOR_BG;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // Gentle moving clouds / machine background shapes\n    drawBackgroundShapes();\n\n    // Draw title and instructions\n    drawHeader();\n\n    // Draw left palette of parts\n    drawPalette();\n\n    // Draw machine with slots and gears\n    drawMachine();\n\n    // Draw footer: level, score, target and sum\n    drawFooter();\n\n    // Draw audio icon\n    drawAudioIcon();\n\n    // Draw accessibility cues (outline if audio disabled)\n    if (showAudioDisabledMessage) {\n      // show small alert box\n      ctx.fillStyle = 'rgba(255, 240, 220, 0.9)';\n      ctx.fillRect(12, HEIGHT - 74, 320, 52);\n      ctx.strokeStyle = '#B35A4A';\n      ctx.strokeRect(12, HEIGHT - 74, 320, 52);\n      drawText(ctx, 'Audio is unavailable. Use M to toggle sound if your browser allows it.', 20, HEIGHT - 46, 14, '#442211');\n    }\n  }\n\n  // Draw decorative background shapes - wacky, calming machines\n  function drawBackgroundShapes() {\n    // Soft large rounded shapes\n    ctx.save();\n    const t = animationOffset;\n    ctx.globalAlpha = 0.65;\n    ctx.fillStyle = '#CFECE9';\n    roundRect(ctx, 40 + Math.sin(t * 0.2) * 6, 30 + Math.cos(t * 0.12) * 6, 260, 92, 16);\n    ctx.fill();\n    ctx.fillStyle = '#DDEBF3';\n    roundRect(ctx, 360 + Math.cos(t * 0.15) * 4, 24 + Math.sin(t * 0.08) * 6, 320, 116, 18);\n    ctx.fill();\n    ctx.globalAlpha = 1;\n    ctx.restore();\n\n    // Wacky little bolts and chips\n    for (let i = 0; i < 6; i++) {\n      drawBolt(520 + 40 * Math.cos(t * 0.2 + i), 80 + 18 * Math.sin(t * 0.15 + i), 10 + (i % 3));\n    }\n  }\n\n  function drawBolt(x, y, s) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.fillStyle = '#F7E6C3';\n    ctx.beginPath();\n    ctx.moveTo(0, -s * 1.2);\n    for (let j = 0; j < 8; j++) {\n      ctx.rotate(Math.PI / 4);\n      ctx.lineTo(0, -s * (j % 2 ? 0.75 : 1.12));\n    }\n    ctx.fill();\n    ctx.restore();\n  }\n\n  // Draw title and small instructions\n  function drawHeader() {\n    drawText(ctx, 'Machine Math', 24, 40, 26, COLOR_ACCENT);\n    drawText(ctx, 'Fix the friendly machine by placing number parts that add to the target.', 24, 64, 14, '#405063');\n    drawText(ctx, 'Controls: Number keys to pick parts, Enter to place, Click/drag allowed. M toggles sound.', 24, 84, 12, '#405063');\n  }\n\n  function drawFooter() {\n    // Panel with level, score, target and sum\n    ctx.save();\n    ctx.fillStyle = '#FFFFFFCC';\n    roundRect(ctx, 12, HEIGHT - 86, WIDTH - 24, 68, 10);\n    ctx.fill();\n\n    // Level and score\n    drawText(ctx, `Level: ${level} / ${MAX_LEVELS}`, 28, HEIGHT - 50, 16, COLOR_TEXT);\n    drawText(ctx, `Score: ${score}`, 168, HEIGHT - 50, 16, COLOR_TEXT);\n\n    // Target and sum in machine style\n    ctx.fillStyle = '#F0F6F5';\n    roundRect(ctx, 320, HEIGHT - 80, 380, 56, 8);\n    ctx.fill();\n\n    drawText(ctx, `Target: ${target}`, 340, HEIGHT - 50, 18, '#1F3B3A');\n    drawText(ctx, `Current sum: ${currentSum}`, 540, HEIGHT - 50, 18, '#1F3B3A');\n\n    ctx.restore();\n  }\n\n  // Draw palette list of parts\n  function drawPalette() {\n    drawText(ctx, 'Parts', 24, 108, 18, '#2F4A4A');\n\n    for (let i = 0; i < parts.length; i++) {\n      const p = parts[i];\n      // If part is placed, draw faded\n      ctx.save();\n      const isSelected = i === selectedPaletteIndex && !dragging;\n      ctx.globalAlpha = p.placed ? 0.3 : 1.0;\n      // palette background\n      ctx.fillStyle = isSelected ? '#FFF6EA' : COLOR_PART;\n      roundRect(ctx, p.x, p.y, p.w, p.h, 8);\n      ctx.fill();\n      // number circle\n      ctx.fillStyle = '#FFFBF6';\n      ctx.beginPath();\n      ctx.arc(p.x + 44, p.y + p.h / 2, 18, 0, Math.PI * 2);\n      ctx.fill();\n      // gear doodle behind number\n      drawSmallGear(p.x + 44, p.y + p.h / 2, 8, '#E3E3E3', animationOffset * 0.2 + i);\n      // number text\n      drawText(ctx, `${p.value}`, p.x + 44, p.y + p.h / 2 + 6, 18, '#3A3840', 'center');\n\n      // keyboard hint\n      drawText(ctx, `${i + 1}`, p.x + p.w - 18, p.y + p.h - 6, 12, '#6D6D6D', 'center');\n\n      ctx.restore();\n    }\n  }\n\n  // Draw small decorative gear\n  function drawSmallGear(cx, cy, r, color, rotation = 0) {\n    ctx.save();\n    ctx.translate(cx, cy);\n    ctx.rotate(rotation * 0.1);\n    ctx.fillStyle = color;\n    for (let i = 0; i < 8; i++) {\n      ctx.rotate(Math.PI / 4);\n      ctx.fillRect(r * 0.8, -r * 0.2, r * 0.5, r * 0.4);\n    }\n    ctx.beginPath();\n    ctx.arc(0, 0, r * 0.6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.fillStyle = '#AAB9B7';\n    ctx.arc(0, 0, r * 0.28, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  // Draw main machine area with slots\n  function drawMachine() {\n    // machine body\n    ctx.save();\n    ctx.fillStyle = '#F7FBFB';\n    roundRect(ctx, 340, 110, 360, 220, 18);\n    ctx.fill();\n\n    // wacky display showing target (big gear)\n    drawGearDisplay(480, 180, 70, target, '#9FC7C1');\n\n    // slots\n    for (let i = 0; i < slots.length; i++) {\n      const s = slots[i];\n      ctx.save();\n      // slot background\n      ctx.fillStyle = '#F2F6F6';\n      roundRect(ctx, s.x, s.y, s.w, s.h, 10);\n      ctx.fill();\n\n      // focus highlight\n      if (i === focusedSlotIndex) {\n        ctx.strokeStyle = '#7AA5A2';\n        ctx.lineWidth = 2;\n        ctx.strokeRect(s.x - 2, s.y - 2, s.w + 4, s.h + 4);\n      }\n\n      // if there's a placed part, draw it inside slot\n      if (s.part) {\n        const part = parts.find(p => p.id === s.part);\n        if (part) {\n          ctx.fillStyle = '#FFF8F2';\n          roundRect(ctx, s.x + 10, s.y + 6, s.w - 20, s.h - 12, 8);\n          ctx.fill();\n          drawText(ctx, `${part.value}`, s.x + s.w / 2, s.y + s.h / 2 + 6, 18, '#333333', 'center');\n          // little connector drawing\n          ctx.strokeStyle = '#D2E2E0';\n          ctx.beginPath();\n          ctx.moveTo(s.x + s.w / 2, s.y - 8);\n          ctx.lineTo(s.x + s.w / 2, s.y + s.h + 4);\n          ctx.stroke();\n        }\n      } else {\n        // placeholder text\n        drawText(ctx, 'slot', s.x + 12, s.y + s.h / 2 + 6, 12, '#B2B9B8');\n      }\n\n      ctx.restore();\n    }\n\n    // Wacky levers and pipes\n    drawPipe(420, 240, 540, 320);\n    ctx.restore();\n  }\n\n  // Gear display for the target\n  function drawGearDisplay(cx, cy, r, number, color) {\n    // big gear\n    ctx.save();\n    ctx.translate(cx, cy);\n    ctx.rotate(animationOffset * 0.03);\n    // teeth\n    ctx.fillStyle = color;\n    for (let i = 0; i < 12; i++) {\n      ctx.rotate((Math.PI * 2) / 12);\n      ctx.beginPath();\n      ctx.rect(r - 10, -6, 12, 12);\n      ctx.fill();\n    }\n    // center\n    ctx.beginPath();\n    ctx.arc(0, 0, r - 20, 0, Math.PI * 2);\n    ctx.fill();\n    // number\n    drawText(ctx, `${number}`, 0, 8, 26, COLOR_ACCENT, 'center');\n    ctx.restore();\n  }\n\n  // Draw a pipe between points with decoration\n  function drawPipe(x1, y1, x2, y2) {\n    ctx.save();\n    ctx.strokeStyle = '#D7E7E6';\n    ctx.lineWidth = 12;\n    ctx.lineCap = 'round';\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    const mx = (x1 + x2) / 2;\n    ctx.quadraticCurveTo(mx, y1 + 40, x2, y2);\n    ctx.stroke();\n\n    // small bolts along pipe\n    ctx.fillStyle = '#E8F2F1';\n    for (let t = 0; t < 1; t += 0.18) {\n      const px = x1 + (x2 - x1) * t;\n      const py = y1 + (y2 - y1) * t + Math.sin(animationOffset * 0.4 + t * 10) * 6;\n      ctx.beginPath();\n      ctx.arc(px, py, 4, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    ctx.restore();\n  }\n\n  // Drawing audio icon and state\n  function drawAudioIcon() {\n    const x = WIDTH - AUDIO_ICON_SIZE - 12;\n    const y = 12;\n    ctx.save();\n    ctx.fillStyle = audioAllowed ? '#7BA89E' : '#CBB0A6';\n    roundRect(ctx, x - 6, y - 6, AUDIO_ICON_SIZE + 12, AUDIO_ICON_SIZE + 12, 8);\n    ctx.fill();\n    // speaker icon\n    ctx.fillStyle = '#FFF';\n    ctx.beginPath();\n    ctx.moveTo(x + 6, y + 10);\n    ctx.lineTo(x + 16, y + 6);\n    ctx.lineTo(x + 16, y + 22);\n    ctx.closePath();\n    ctx.fill();\n    // waves or muted cross\n    if (audioAllowed) {\n      ctx.strokeStyle = '#FFF';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.arc(x + 18, y + 14, 8, -0.7, 0.7);\n      ctx.stroke();\n    } else {\n      ctx.strokeStyle = '#FFF';\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(x + 12, y + 8);\n      ctx.lineTo(x + 24, y + 20);\n      ctx.moveTo(x + 24, y + 8);\n      ctx.lineTo(x + 12, y + 20);\n      ctx.stroke();\n    }\n    ctx.restore();\n\n    // clickable area: provide accessible label for screen readers via ariaLive when toggled\n  }\n\n  // Rectangle helper\n  function roundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n  }\n\n  // Mouse and touch handling\n  function onMouseDown(e) {\n    const rect = canvas.getBoundingClientRect();\n    const x = (e.clientX - rect.left) * (canvas.width / rect.width);\n    const y = (e.clientY - rect.top) * (canvas.height / rect.height);\n    mouse.down = true;\n    mouse.x = x;\n    mouse.y = y;\n    // check palette parts hit\n    for (let i = 0; i < parts.length; i++) {\n      const p = parts[i];\n      if (!p.placed && hitTest(x, y, p.x, p.y, p.w, p.h)) {\n        dragging = { type: 'palette', index: i, offsetX: x - p.x, offsetY: y - p.y };\n        selectedPaletteIndex = i;\n        // visual immediate pick\n        playPlaceSound();\n        return;\n      }\n    }\n    // check placed parts to remove (click a slot)\n    for (let i = 0; i < slots.length; i++) {\n      const s = slots[i];\n      if (hitTest(x, y, s.x, s.y, s.w, s.h) && s.part) {\n        // remove\n        const part = parts.find(p => p.id === s.part);\n        if (part) {\n          part.placed = false;\n          // return to palette location\n          // find an available palette spot index for this part to place visually near original spot\n          const idx = parts.findIndex(p => p.id === part.id);\n          parts[idx].x = 24;\n          parts[idx].y = 120 + idx * 60;\n        }\n        s.part = null;\n        updateSum();\n        playIncorrectSound(); // gentle error / undo sound\n        announce(`Removed part. Current sum ${currentSum}.`);\n        return;\n      }\n    }\n    // check audio icon click\n    const ax = WIDTH - AUDIO_ICON_SIZE - 12;\n    const ay = 12;\n    if (hitTest(x, y, ax - 6, ay - 6, AUDIO_ICON_SIZE + 12, AUDIO_ICON_SIZE + 12)) {\n      toggleAudio();\n      return;\n    }\n  }\n\n  function onMouseMove(e) {\n    const rect = canvas.getBoundingClientRect();\n    const x = (e.clientX - rect.left) * (canvas.width / rect.width);\n    const y = (e.clientY - rect.top) * (canvas.height / rect.height);\n    mouse.x = x;\n    mouse.y = y;\n    if (dragging) {\n      // move part with mouse\n      const p = parts[dragging.index];\n      p.x = x - dragging.offsetX;\n      p.y = y - dragging.offsetY;\n    }\n  }\n\n  function onMouseUp(e) {\n    mouse.down = false;\n    if (dragging) {\n      placeDraggingPart(dragging);\n      dragging = null;\n    }\n  }\n\n  // Touch wrappers\n  function onTouchStart(e) {\n    e.preventDefault();\n    if (e.touches.length > 0) {\n      const t = e.touches[0];\n      const rect = canvas.getBoundingClientRect();\n      const x = (t.clientX - rect.left) * (canvas.width / rect.width);\n      const y = (t.clientY - rect.top) * (canvas.height / rect.height);\n      mouse.down = true;\n      mouse.x = x;\n      mouse.y = y;\n      // emulate mousedown\n      onMouseDown({ clientX: t.clientX, clientY: t.clientY });\n    }\n  }\n\n  function onTouchMove(e) {\n    e.preventDefault();\n    if (e.touches.length > 0) {\n      const t = e.touches[0];\n      const rect = canvas.getBoundingClientRect();\n      const x = (t.clientX - rect.left) * (canvas.width / rect.width);\n      const y = (t.clientY - rect.top) * (canvas.height / rect.height);\n      // emulate mousemove\n      onMouseMove({ clientX: t.clientX, clientY: t.clientY });\n    }\n  }\n\n  function onTouchEnd(e) {\n    e.preventDefault();\n    mouse.down = false;\n    if (dragging) {\n      placeDraggingPart(dragging);\n      dragging = null;\n    }\n  }\n\n  // Place a dragged part into nearest slot if valid\n  function placeDraggingPart(dragInfo) {\n    const p = parts[dragInfo.index];\n    // check collision with any slot\n    for (let i = 0; i < slots.length; i++) {\n      const s = slots[i];\n      if (hitTest(mouse.x, mouse.y, s.x, s.y, s.w, s.h)) {\n        if (s.part) {\n          // slot occupied: reject\n          playIncorrectSound();\n          announce(`That slot already has a part. Try another slot.`);\n          // return part to original palette position\n          resetPartPosition(dragInfo.index);\n          return;\n        } else {\n          // place part\n          p.placed = true;\n          s.part = p.id;\n          // snap part into slot\n          p.x = s.x + 10;\n          p.y = s.y + 6;\n          updateSum();\n          playPlaceSound();\n          announce(`Placed ${p.value}. Current sum ${currentSum}.`);\n          checkForLevelComplete();\n          return;\n        }\n      }\n    }\n    // if no slot, return to palette position\n    resetPartPosition(dragInfo.index);\n    playIncorrectSound();\n  }\n\n  function resetPartPosition(index) {\n    parts[index].x = 24;\n    parts[index].y = 120 + index * 60;\n  }\n\n  function hitTest(px, py, x, y, w, h) {\n    return px >= x && px <= x + w && py >= y && py <= y + h;\n  }\n\n  // Keyboard handling\n  function onKeyDown(e) {\n    // ensure the canvas is focused\n    // Number keys: choose part 1..n\n    if (e.key >= '1' && e.key <= String(parts.length)) {\n      const idx = parseInt(e.key, 10) - 1;\n      if (parts[idx] && !parts[idx].placed) {\n        selectedPaletteIndex = idx;\n        announce(`Selected part ${parts[idx].value}. Use Enter to place in the focused slot.`);\n        playPlaceSound();\n      } else {\n        announce('Part already used or not available.');\n        playIncorrectSound();\n      }\n      e.preventDefault();\n      return;\n    }\n\n    switch (e.key) {\n      case 'ArrowRight':\n        focusedSlotIndex = (focusedSlotIndex + 1) % slots.length;\n        announce(`Focused slot ${focusedSlotIndex + 1}.`);\n        e.preventDefault();\n        break;\n      case 'ArrowLeft':\n        focusedSlotIndex = (focusedSlotIndex - 1 + slots.length) % slots.length;\n        announce(`Focused slot ${focusedSlotIndex + 1}.`);\n        e.preventDefault();\n        break;\n      case 'ArrowDown':\n        // move focus roughly to next slot\n        focusedSlotIndex = Math.min(slots.length - 1, focusedSlotIndex + 1);\n        announce(`Focused slot ${focusedSlotIndex + 1}.`);\n        e.preventDefault();\n        break;\n      case 'ArrowUp':\n        focusedSlotIndex = Math.max(0, focusedSlotIndex - 1);\n        announce(`Focused slot ${focusedSlotIndex + 1}.`);\n        e.preventDefault();\n        break;\n      case 'Enter':\n        // try to place selected palette item into focused slot\n        const p = parts[selectedPaletteIndex];\n        if (!p) {\n          announce('No part selected.');\n          playIncorrectSound();\n        } else if (p.placed) {\n          announce('Selected part is already placed. Pick another part.');\n          playIncorrectSound();\n        } else {\n          const s = slots[focusedSlotIndex];\n          if (s.part) {\n            announce('Focused slot is already occupied.');\n            playIncorrectSound();\n          } else {\n            // place\n            p.placed = true;\n            s.part = p.id;\n            p.x = s.x + 10;\n            p.y = s.y + 6;\n            updateSum();\n            playPlaceSound();\n            announce(`Placed ${p.value}. Current sum ${currentSum}.`);\n            checkForLevelComplete();\n          }\n        }\n        e.preventDefault();\n        break;\n      case 'Backspace':\n      case 'Delete':\n        // remove from focused slot if any\n        const s = slots[focusedSlotIndex];\n        if (s.part) {\n          const part = parts.find(p => p.id === s.part);\n          if (part) {\n            part.placed = false;\n            part.x = 24;\n            part.y = 120 + parts.findIndex(pp => pp.id === part.id) * 60;\n          }\n          s.part = null;\n          updateSum();\n          announce(`Removed part from slot ${focusedSlotIndex + 1}. Current sum ${currentSum}.`);\n          playIncorrectSound();\n        } else {\n          announce('No part in the focused slot to remove.');\n        }\n        e.preventDefault();\n        break;\n      case 'm':\n      case 'M':\n        toggleAudio();\n        e.preventDefault();\n        break;\n      case 'h':\n      case 'H':\n        announce('Help: choose parts using number keys and place them using Enter. Remove with Delete. You can also click and drag parts.');\n        e.preventDefault();\n        break;\n      default:\n        break;\n    }\n  }\n\n  function toggleAudio() {\n    if (!audioCtx) {\n      // try to create audio context again (some browsers require user gesture)\n      try {\n        const AudioContext = window.AudioContext || window.webkitAudioContext;\n        if (!AudioContext) throw new Error('Web Audio API not supported');\n        audioCtx = new AudioContext();\n        masterGain = audioCtx.createGain();\n        masterGain.gain.value = 0.18;\n        masterGain.connect(audioCtx.destination);\n        bgOsc = audioCtx.createOscillator();\n        bgOsc.type = 'sine';\n        bgOsc.frequency.value = 110;\n        const bgGain = audioCtx.createGain();\n        bgGain.gain.value = 0.03;\n        const bgFilter = audioCtx.createBiquadFilter();\n        bgFilter.type = 'lowpass';\n        bgFilter.frequency.value = 600;\n        lfo = audioCtx.createOscillator();\n        lfo.frequency.value = 0.12;\n        const lfoGain = audioCtx.createGain();\n        lfoGain.gain.value = 40;\n        lfo.connect(lfoGain);\n        lfoGain.connect(bgOsc.frequency);\n        bgOsc.connect(bgFilter);\n        bgFilter.connect(bgGain);\n        bgGain.connect(masterGain);\n        bgOsc.start();\n        lfo.start();\n        audioAllowed = true;\n      } catch (err) {\n        audioAllowed = false;\n        showAudioDisabledMessage = true;\n        announce('Audio is not available in this browser.');\n        return;\n      }\n    } else {\n      audioAllowed = !audioAllowed;\n      if (!audioAllowed) {\n        // mute\n        if (masterGain) masterGain.gain.value = 0;\n      } else {\n        if (masterGain) masterGain.gain.value = 0.18;\n      }\n    }\n    announce(audioAllowed ? 'Audio on' : 'Audio muted');\n  }\n\n  // Update current sum based on placed parts\n  function updateSum() {\n    let sum = 0;\n    for (let s of slots) {\n      if (s.part) {\n        const p = parts.find(pp => pp.id === s.part);\n        if (p) sum += p.value;\n      }\n    }\n    currentSum = sum;\n  }\n\n  // Check if the level is complete or impossible\n  function checkForLevelComplete() {\n    if (currentSum === target) {\n      // success\n      score += 10 * level;\n      playCorrectSequence();\n      announce(`Great! Level ${level} complete. Score ${score}.`);\n      // proceed to next after short delay\n      setTimeout(() => {\n        level++;\n        if (level > MAX_LEVELS) {\n          finished = true;\n          announce(`You fixed all the machines! Final score ${score}. Press R to play again.`);\n          // Offer restart via keypress - attach temporary handler\n          window.addEventListener('keydown', onRestartKey);\n        } else {\n          prepareLevel();\n        }\n      }, 900);\n    } else if (currentSum > target) {\n      // too much\n      playIncorrectSound();\n      announce(`Oops! The machine is overloaded. Current sum ${currentSum}. Try removing or placing smaller parts.`);\n    } else {\n      // still less than target - encourage\n      playPlaceSound();\n    }\n  }\n\n  // Restart handler for final screen\n  function onRestartKey(e) {\n    if (e.key.toLowerCase() === 'r') {\n      window.removeEventListener('keydown', onRestartKey);\n      resetGame();\n    }\n  }\n\n  // Accessibility: announce text to screen readers\n  function announce(text) {\n    if (!ariaLive) return;\n    ariaLive.textContent = text;\n    // also console log for debugging\n    console.log('ANNOUNCE:', text);\n  }\n\n  // Audio: play short tone for placing parts\n  function playPlaceSound() {\n    if (!audioAllowed || !audioCtx) return;\n    try {\n      const o = audioCtx.createOscillator();\n      o.type = 'triangle';\n      o.frequency.value = 440 + Math.random() * 30;\n      const g = audioCtx.createGain();\n      g.gain.value = 0.0001;\n      o.connect(g);\n      g.connect(masterGain);\n      const now = audioCtx.currentTime;\n      g.gain.cancelScheduledValues(now);\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.linearRampToValueAtTime(0.06, now + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.26);\n      o.start(now);\n      o.stop(now + 0.27);\n    } catch (err) {\n      console.warn('Place sound failed', err);\n    }\n  }\n\n  // Correct sequence: small arpeggio\n  function playCorrectSequence() {\n    if (!audioAllowed || !audioCtx) return;\n    try {\n      const base = 440;\n      let t = audioCtx.currentTime;\n      [0, 3, 6].forEach((step, i) => {\n        const o = audioCtx.createOscillator();\n        o.type = 'sine';\n        o.frequency.value = base * Math.pow(2, step / 12);\n        const g = audioCtx.createGain();\n        g.gain.value = 0.0001;\n        o.connect(g);\n        g.connect(masterGain);\n        const start = t + i * 0.12;\n        g.gain.setValueAtTime(0.0001, start);\n        g.gain.linearRampToValueAtTime(0.09, start + 0.02);\n        g.gain.exponentialRampToValueAtTime(0.0001, start + 0.12);\n        o.start(start);\n        o.stop(start + 0.14);\n      });\n    } catch (err) {\n      console.warn('Correct sound failed', err);\n    }\n  }\n\n  // Incorrect short buzzer\n  function playIncorrectSound() {\n    if (!audioAllowed || !audioCtx) return;\n    try {\n      const o = audioCtx.createOscillator();\n      o.type = 'square';\n      o.frequency.value = 220;\n      const f = audioCtx.createBiquadFilter();\n      f.type = 'lowpass';\n      f.frequency.value = 1000;\n      const g = audioCtx.createGain();\n      g.gain.value = 0.0001;\n      o.connect(f);\n      f.connect(g);\n      g.connect(masterGain);\n      const now = audioCtx.currentTime;\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.linearRampToValueAtTime(0.08, now + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.28);\n      o.start(now);\n      o.frequency.exponentialRampToValueAtTime(80, now + 0.18);\n      o.stop(now + 0.32);\n    } catch (err) {\n      console.warn('Incorrect sound failed', err);\n    }\n  }\n\n  // General correct tone (short)\n  function playCorrectTone() {\n    if (!audioAllowed || !audioCtx) return;\n    try {\n      const o = audioCtx.createOscillator();\n      o.type = 'sine';\n      o.frequency.value = 660;\n      const g = audioCtx.createGain();\n      g.gain.value = 0.0001;\n      o.connect(g);\n      g.connect(masterGain);\n      const now = audioCtx.currentTime;\n      g.gain.linearRampToValueAtTime(0.08, now + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.2);\n      o.start(now);\n      o.stop(now + 0.22);\n    } catch (err) {\n      console.warn('Correct tone failed', err);\n    }\n  }\n\n  // small beep reused\n  function playBeep(freq = 440, duration = 0.12) {\n    if (!audioAllowed || !audioCtx) return;\n    try {\n      const o = audioCtx.createOscillator();\n      o.type = 'sine';\n      o.frequency.value = freq;\n      const g = audioCtx.createGain();\n      g.gain.value = 0.0001;\n      o.connect(g);\n      g.connect(masterGain);\n      const now = audioCtx.currentTime;\n      g.gain.linearRampToValueAtTime(0.06, now + 0.01);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);\n      o.start(now);\n      o.stop(now + duration + 0.02);\n    } catch (err) {\n      console.warn('Beep failed', err);\n    }\n  }\n\n  // small happy sound\n  function playPlaceHappy() {\n    if (!audioAllowed || !audioCtx) return;\n    playBeep(520, 0.08);\n    setTimeout(() => playBeep(620, 0.1), 100);\n  }\n\n  // Convenience to indicate place sound used earlier alias\n  function playPlaceSound() {\n    playBeep(480 + Math.random() * 80, 0.12);\n  }\n\n  // Window load safe init\n  if (document.readyState === 'loading') {\n    window.addEventListener('DOMContentLoaded', init);\n  } else {\n    init();\n  }\n})();\n---\n",
  "improve_response_tokens": 22415,
  "formatted_code": true,
  "formatting_response_tokens": 23706,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}