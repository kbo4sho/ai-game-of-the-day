# Game of the Day - 2025-10-19

## Metadata
- **Generated Date:** 2025-10-19
- **Generated Time:** 2025-10-19T00:29:44.047956
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-10-19.js
- **File Size:** 26497 bytes
- **Tokens Used:** 8772

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-10-19.js` - The playable game
- `2025-10-19.meta.json` - Machine-readable metadata
- `2025-10-19.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 17573

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 18840

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Drone Math Adventure
  // Designed for children 7-9. Renders inside element with id "game-of-the-day-stage".
  // Strict requirements: canvas sized 720x480, all visuals drawn with canvas, Web Audio API for generated sounds,
  // clear win/loss conditions: win = 10 correct answers, lose = 3 wrong answers,
  // accessible keyboard controls, visual audio cues, text alternatives, proper UI layout with no overlapping text.

  // -------------------------
  // Helper and constants
  // -------------------------
  const STAGE_ID = 'game-of-the-day-stage';
  const WIDTH = 720;
  const HEIGHT = 480;
  const PADDING = 12; // minimal spacing for UI elements
  const TARGET_CORRECT = 10;
  const MAX_WRONG = 3;
  const MIN_BODY_FONT = 14;
  const IMPORTANT_FONT = 20;

  // Colors and styles (calming + wacky)
  const COLORS = {
    bg: '#eaf6ff',
    panel: '#ffffffcc',
    text: '#103c58',
    accent: '#ff9f1c',
    good: '#2ecc71',
    bad: '#ff6b6b',
    pad: '#9ad3bc',
    drone: '#6c5ce7',
    padOutline: '#2b6f6f',
    shadow: '#00000033',
    audioIcon: '#333',
  };

  // -------------------------
  // Setup DOM and Canvas
  // -------------------------
  const container = document.getElementById(STAGE_ID);
  if (!container) {
    console.error('Game container not found:', STAGE_ID);
    return;
  }
  container.innerHTML = ''; // Clear any existing content

  // Create a live region for screen readers (text alternative)
  const liveRegion = document.createElement('div');
  liveRegion.setAttribute('aria-live', 'polite');
  liveRegion.setAttribute('role', 'status');
  liveRegion.style.position = 'absolute';
  liveRegion.style.left = '-9999px';
  container.appendChild(liveRegion);

  // Create canvas inside container
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute('role', 'img');
  canvas.setAttribute('aria-label', 'Drone Math Adventure. Answer math questions with the drone.');
  canvas.style.display = 'block';
  canvas.style.background = COLORS.bg;
  canvas.style.outline = 'none';
  container.appendChild(canvas);

  const ctx = canvas.getContext('2d');

  // Ensure focusable for keyboard controls
  canvas.tabIndex = 0;
  canvas.style.cursor = 'pointer';

  // -------------------------
  // Audio: Web Audio API
  // -------------------------
  let audioContext = null;
  let audioEnabled = true;
  let ambientGain = null;
  let ambientOsc1 = null;
  let ambientOsc2 = null;

  function initAudioContext() {
    if (audioContext) return;
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) throw new Error('Web Audio API not supported');
      audioContext = new AC();
    } catch (err) {
      console.warn('Audio context creation failed:', err);
      audioEnabled = false;
      audioContext = null;
      updateLiveRegion('Audio unavailable. The game will run without sound.');
      return;
    }
    // Create ambient sound (gentle hum)
    try {
      ambientGain = audioContext.createGain();
      ambientGain.gain.value = 0.02; // gentle
      ambientGain.connect(audioContext.destination);

      ambientOsc1 = audioContext.createOscillator();
      ambientOsc1.type = 'sine';
      ambientOsc1.frequency.value = 120;
      const gain1 = audioContext.createGain();
      gain1.gain.value = 0.02;
      ambientOsc1.connect(gain1);
      gain1.connect(ambientGain);

      ambientOsc2 = audioContext.createOscillator();
      ambientOsc2.type = 'sine';
      ambientOsc2.frequency.value = 180;
      const gain2 = audioContext.createGain();
      gain2.gain.value = 0.015;
      ambientOsc2.connect(gain2);
      gain2.connect(ambientGain);

      ambientOsc1.start();
      ambientOsc2.start();
    } catch (err) {
      console.warn('Ambient audio failed:', err);
      // Continue without ambient
      try {
        if (ambientOsc1) ambientOsc1.disconnect();
        if (ambientOsc2) ambientOsc2.disconnect();
      } catch (e) {}
    }
  }

  function safeResumeAudio() {
    if (!audioContext || typeof audioContext.resume !== 'function') return;
    audioContext.resume().catch((err) => {
      console.warn('Audio resume failed:', err);
    });
  }

  // Play a short feedback sound
  function playTone(type = 'correct') {
    if (!audioEnabled) return;
    try {
      if (!audioContext) initAudioContext();
      if (!audioContext) return;
      safeResumeAudio();

      const now = audioContext.currentTime;
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      const filter = audioContext.createBiquadFilter();

      osc.type = type === 'correct' ? 'sine' : 'sawtooth';
      if (type === 'correct') osc.frequency.value = 880;
      else if (type === 'wrong') osc.frequency.value = 120;
      else osc.frequency.value = 440;

      filter.type = 'lowpass';
      filter.frequency.value = type === 'correct' ? 2200 : 800;

      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime(type === 'correct' ? 0.08 : 0.09, now + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + (type === 'correct' ? 0.35 : 0.45));

      osc.connect(filter);
      filter.connect(gain);
      gain.connect(audioContext.destination);

      osc.start(now);
      osc.stop(now + (type === 'correct' ? 0.5 : 0.6));

      // Cleanup nodes when finished
      osc.onended = () => {
        try {
          osc.disconnect();
          filter.disconnect();
          gain.disconnect();
        } catch (e) {}
      };
    } catch (err) {
      console.warn('playTone error:', err);
    }
  }

  function toggleAudio() {
    audioEnabled = !audioEnabled;
    if (audioEnabled) {
      try {
        if (!audioContext) initAudioContext();
        if (ambientGain) ambientGain.gain.value = 0.02;
        updateLiveRegion('Audio on');
      } catch (err) {
        audioEnabled = false;
        updateLiveRegion('Audio unavailable.');
      }
    } else {
      try {
        if (ambientGain) ambientGain.gain.value = 0;
      } catch (err) {}
      updateLiveRegion('Audio muted');
    }
  }

  // -------------------------
  // Game State
  // -------------------------
  const state = {
    running: true,
    correctCount: 0,
    wrongCount: 0,
    question: null,
    options: [], // array of numbers
    selectedIndex: 0, // 0-3
    message: '',
    anim: {
      // drone animation
      x: WIDTH / 2,
      y: 120,
      targetX: WIDTH / 2,
      targetY: 120,
      vx: 0,
      vy: 0,
      wobble: 0,
    },
    phase: 'playing', // playing, win, lose
    lastInteractionTime: 0,
    hudSpacing: {
      score: { x: PADDING, y: PADDING },
      lives: { x: WIDTH - PADDING, y: PADDING },
      instructions: { x: WIDTH / 2, y: HEIGHT - PADDING - 10 },
    },
    audioAvailable: true,
    announced: '',
  };

  // -------------------------
  // Math question generator
  // -------------------------
  function generateQuestion() {
    // For ages 7-9: mainly addition/subtraction within 20, sometimes small multiplication
    const types = ['add', 'sub', 'add', 'add', 'mul']; // weighted
    const t = types[Math.floor(Math.random() * types.length)];
    let a, b, answer, text;
    if (t === 'add') {
      a = randInt(1, 12);
      b = randInt(1, 12);
      answer = a + b;
      text = `${a} + ${b} = ?`;
    } else if (t === 'sub') {
      a = randInt(2, 20);
      b = randInt(1, a - 1);
      answer = a - b;
      text = `${a} - ${b} = ?`;
    } else {
      a = randInt(2, 6);
      b = randInt(2, 6);
      answer = a * b;
      text = `${a} × ${b} = ?`;
    }
    // generate 4 options
    const options = new Set();
    options.add(answer);
    while (options.size < 4) {
      // generate plausible wrong answers
      let delta = randInt(-4, 6);
      if (delta === 0) delta = randInt(1, 3);
      let val = answer + delta;
      if (val < 0) val = Math.abs(val) + 1;
      // avoid duplicates
      if (options.has(val)) continue;
      options.add(val);
    }
    const optionsArr = shuffle(Array.from(options));
    return { text, answer, options: optionsArr };
  }

  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  // -------------------------
  // UI Layout helpers
  // -------------------------
  function drawRoundedRect(x, y, w, h, r = 8, fill = true, stroke = false) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // Measure text and draw background to avoid overlap
  function drawTextPanel(text, x, y, options = {}) {
    const lines = Array.isArray(text) ? text : String(text).split('\n');
    const fontSize = options.fontSize || MIN_BODY_FONT;
    const font = `${fontSize}px sans-serif`;
    ctx.font = font;
    let maxWidth = 0;
    for (const line of lines) {
      const m = ctx.measureText(line);
      if (m.width > maxWidth) maxWidth = m.width;
    }
    const pad = options.padding || 8;
    const h = fontSize * lines.length + pad * 2 + (lines.length - 1) * 6;
    let w = maxWidth + pad * 2;
    let drawX = x;
    let drawY = y;
    if (options.center) {
      drawX = x - w / 2;
    } else if (options.right) {
      drawX = x - w;
    }
    if (options.bottom) {
      drawY = y - h;
    }
    // Background
    ctx.fillStyle = options.bg || COLORS.panel;
    ctx.strokeStyle = options.border || 'transparent';
    ctx.lineWidth = options.borderWidth || 0;
    drawRoundedRect(drawX, drawY, w, h, 8, true, options.borderWidth > 0);
    // Text
    ctx.fillStyle = options.color || COLORS.text;
    ctx.textBaseline = 'top';
    let ty = drawY + pad;
    for (const line of lines) {
      ctx.fillText(line, drawX + pad, ty);
      ty += fontSize + 6;
    }
    return { x: drawX, y: drawY, w, h };
  }

  // -------------------------
  // Drawing: drone, pads, UI
  // -------------------------
  const padsY = 320;
  const padRadius = 44;
  const padSlots = 4;
  const padPositions = [];
  for (let i = 0; i < padSlots; i++) {
    const spacing = WIDTH / (padSlots + 1);
    padPositions.push({ x: spacing * (i + 1), y: padsY });
  }

  function drawScene() {
    // Background
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Soft clouds/wacky elements (draw some arcs)
    drawClouds();

    // Draw central play field (area where drone flies)
    ctx.fillStyle = '#dff3ff';
    ctx.fillRect(40, 70, WIDTH - 80, 210);

    // Draw pads
    for (let i = 0; i < padSlots; i++) {
      drawPad(padPositions[i].x, padPositions[i].y, state.options[i], i === state.selectedIndex);
    }

    // Draw drone
    drawDrone(state.anim.x, state.anim.y, state.anim.wobble);

    // UI: Score (top-left)
    ctx.textBaseline = 'top';
    ctx.font = `${IMPORTANT_FONT}px sans-serif`;
    const scoreText = `Stars: ${state.correctCount}/${TARGET_CORRECT}`;
    drawTextPanel(scoreText, PADDING, PADDING, {
      fontSize: IMPORTANT_FONT,
      padding: 10,
      bg: COLORS.panel,
      color: COLORS.text,
    });

    // UI: Lives (top-right)
    const livesText = `Lives: ${MAX_WRONG - state.wrongCount}`;
    drawTextPanel(livesText, WIDTH - PADDING, PADDING, {
      fontSize: IMPORTANT_FONT,
      padding: 10,
      bg: COLORS.panel,
      color: state.wrongCount >= MAX_WRONG ? COLORS.bad : COLORS.text,
      right: true,
    });

    // UI: Audio icon (top-center-right)
    drawAudioIcon();

    // Question panel at center-top (inside play field)
    ctx.font = `${IMPORTANT_FONT + 2}px sans-serif`;
    const qText = state.question ? state.question.text : '';
    drawTextPanel(qText, WIDTH / 2, 90, {
      fontSize: IMPORTANT_FONT + 2,
      padding: 12,
      bg: COLORS.panel,
      color: COLORS.text,
      center: true,
    });

    // Instructions bottom-center
    const instrLines = [
      'Select the correct answer pad.',
      'Keys: 1–4 to pick, ← → to move, Enter to confirm, M to mute, Space to restart after end.',
    ];
    drawTextPanel(instrLines, WIDTH / 2, HEIGHT - PADDING, {
      fontSize: MIN_BODY_FONT,
      padding: 10,
      bg: COLORS.panel,
      color: COLORS.text,
      center: true,
      bottom: true,
    });

    // Message near center (feedback)
    if (state.message) {
      ctx.font = `${IMPORTANT_FONT}px sans-serif`;
      drawTextPanel(state.message, WIDTH / 2, padsY - 60, {
        fontSize: IMPORTANT_FONT,
        padding: 10,
        bg: COLORS.panel,
        color: COLORS.accent,
        center: true,
      });
    }

    // If win/lose, show end screen overlay
    if (state.phase === 'win' || state.phase === 'lose') {
      drawEndScreen();
    }
  }

  function drawClouds() {
    // Draw a few soft ellipses / clouds for calming wacky effect
    ctx.save();
    ctx.globalAlpha = 0.4;
    ctx.fillStyle = '#ffffff';
    drawCloud(100, 40, 80, 30);
    drawCloud(200, 30, 120, 40);
    drawCloud(520, 50, 100, 35);
    drawCloud(620, 40, 70, 25);
    ctx.restore();
  }

  function drawCloud(cx, cy, w, h) {
    ctx.beginPath();
    ctx.ellipse(cx - w * 0.2, cy, w * 0.3, h * 0.5, 0, 0, Math.PI * 2);
    ctx.ellipse(cx + w * 0.1, cy - 6, w * 0.35, h * 0.5, 0, 0, Math.PI * 2);
    ctx.ellipse(cx + w * 0.45, cy + 2, w * 0.25, h * 0.45, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawPad(x, y, label, selected) {
    // draw shadow
    ctx.save();
    ctx.fillStyle = COLORS.shadow;
    ctx.beginPath();
    ctx.ellipse(x + 6, y + 18, padRadius + 8, padRadius / 2, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // pad base
    ctx.fillStyle = COLORS.pad;
    ctx.strokeStyle = COLORS.padOutline;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(x, y, padRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // highlight if selected
    if (selected) {
      ctx.beginPath();
      ctx.arc(x, y, padRadius + 6, 0, Math.PI * 2);
      ctx.strokeStyle = COLORS.accent;
      ctx.lineWidth = 4;
      ctx.stroke();
    }

    // label number inside
    const fontSize = 18;
    ctx.font = `${fontSize}px sans-serif`;
    ctx.fillStyle = COLORS.text;
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'center';
    ctx.fillText(String(label), x, y);
  }

  function drawDrone(cx, cy, wobble = 0) {
    // Draw a cute wacky drone using arcs and rectangles
    ctx.save();
    ctx.shadowColor = COLORS.shadow;
    ctx.shadowBlur = 6;
    ctx.translate(cx, cy);
    ctx.rotate(Math.sin(wobble) * 0.05);

    // body
    ctx.fillStyle = COLORS.drone;
    ctx.strokeStyle = '#2b1a6f';
    ctx.lineWidth = 3;
    drawRoundedRect(-48, -18, 96, 36, 18, true, true);

    // rotor arms and rotors
    const arms = [-40, 40];
    arms.forEach((ax) => {
      ctx.beginPath();
      ctx.moveTo(ax, -12);
      ctx.lineTo(ax * 1.5, -44);
      ctx.strokeStyle = '#2b1a6f';
      ctx.lineWidth = 4;
      ctx.stroke();

      // rotor circle
      ctx.beginPath();
      ctx.arc(ax * 1.5, -44, 14, 0, Math.PI * 2);
      ctx.fillStyle = '#ffffff';
      ctx.fill();
      ctx.stroke();
      // rotor blades (wacky)
      ctx.beginPath();
      ctx.fillStyle = '#222222';
      ctx.ellipse(ax * 1.5, -44, 18, 3 + Math.abs(Math.sin(wobble) * 2), Math.sin(wobble), 0, Math.PI * 2);
      ctx.fill();
    });

    // window
    ctx.beginPath();
    ctx.fillStyle = '#bfe9ff';
    ctx.arc(0, 0, 18, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // little star (if needed)
    if (state.correctCount > 0) {
      ctx.fillStyle = COLORS.accent;
      drawStar(-38, 0, 5, 6, 3);
    }

    ctx.restore();
  }

  function drawStar(cx, cy, spikes, outerRadius, innerRadius) {
    let rot = Math.PI / 2 * 3;
    let x = cx;
    let y = cy;
    ctx.beginPath();
    ctx.moveTo(cx, cy - outerRadius);
    for (let i = 0; i < spikes; i++) {
      x = cx + Math.cos(rot) * outerRadius;
      y = cy + Math.sin(rot) * outerRadius;
      ctx.lineTo(x, y);
      rot += Math.PI / spikes;
      x = cx + Math.cos(rot) * innerRadius;
      y = cy + Math.sin(rot) * innerRadius;
      ctx.lineTo(x, y);
      rot += Math.PI / spikes;
    }
    ctx.lineTo(cx, cy - outerRadius);
    ctx.closePath();
    ctx.fill();
  }

  function drawAudioIcon() {
    const x = WIDTH - 120;
    const y = PADDING + 6;
    const iconText = audioEnabled ? '🔊' : '🔈';
    ctx.font = `${20}px sans-serif`;
    ctx.fillStyle = COLORS.audioIcon;
    ctx.textBaseline = 'top';
    const m = ctx.measureText(iconText);
    // background
    drawTextPanel(iconText, x + 10, y, {
      fontSize: 20,
      padding: 8,
      bg: COLORS.panel,
      color: COLORS.audioIcon,
    });
    // small label
    ctx.font = `${12}px sans-serif`;
    ctx.fillStyle = COLORS.text;
    ctx.fillText('Press M to toggle sound', x - 50, y + 40);
  }

  function drawEndScreen() {
    // semi-transparent overlay
    ctx.save();
    ctx.fillStyle = '#00000080';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    ctx.restore();

    const title = state.phase === 'win' ? 'Mission Complete!' : 'Drone Grounded';
    const message =
      state.phase === 'win'
        ? `You delivered ${state.correctCount} stars! Great piloting!`
        : `Too many oops. You got ${state.correctCount} correct. Try again!`;

    ctx.font = `${28}px sans-serif`;
    drawTextPanel(title, WIDTH / 2, HEIGHT / 2 - 60, {
      fontSize: 28,
      padding: 14,
      bg: COLORS.panel,
      color: state.phase === 'win' ? COLORS.good : COLORS.bad,
      center: true,
    });

    ctx.font = `${16}px sans-serif`;
    drawTextPanel(message, WIDTH / 2, HEIGHT / 2 - 10, {
      fontSize: 16,
      padding: 12,
      bg: COLORS.panel,
      color: COLORS.text,
      center: true,
    });

    const restartMsg = ['Press Space or click to restart'];
    drawTextPanel(restartMsg, WIDTH / 2, HEIGHT / 2 + 50, {
      fontSize: 16,
      padding: 10,
      bg: COLORS.panel,
      color: COLORS.text,
      center: true,
    });
  }

  // -------------------------
  // Game Logic
  // -------------------------
  function newQuestion() {
    state.question = generateQuestion();
    state.options = state.question.options;
    state.selectedIndex = 0;
    state.message = '';
    // position drone to center
    state.anim.targetX = WIDTH / 2;
    state.anim.targetY = 120;
    updateLiveRegion(`New question: ${state.question.text}`);
  }

  function selectIndex(index) {
    if (state.phase !== 'playing') return;
    state.selectedIndex = Math.max(0, Math.min(padSlots - 1, index));
    updateLiveRegion(`Selected option ${index + 1}: ${state.options[state.selectedIndex]}`);
  }

  function confirmSelection() {
    if (state.phase !== 'playing') return;
    const chosen = state.options[state.selectedIndex];
    const correct = state.question.answer;
    state.lastInteractionTime = Date.now();
    if (chosen === correct) {
      // correct
      state.correctCount++;
      state.message = 'Nice! Correct!';
      playTone('correct');
      moveDroneToPad(state.selectedIndex, true);
      updateLiveRegion('Correct! Good job.');
    } else {
      // wrong
      state.wrongCount++;
      state.message = 'Oops! Try again!';
      playTone('wrong');
      wobbleDrone();
      updateLiveRegion('Incorrect answer.');
    }
    // Check win/lose
    if (state.correctCount >= TARGET_CORRECT) {
      state.phase = 'win';
      state.message = '';
      updateLiveRegion('You win! Mission complete!');
      playTone('correct');
    } else if (state.wrongCount >= MAX_WRONG) {
      state.phase = 'lose';
      state.message = '';
      updateLiveRegion('Game over. Drone grounded.');
      playTone('wrong');
    } else {
      // schedule next question after short animation
      setTimeout(() => {
        if (state.phase === 'playing') newQuestion();
      }, 800);
    }
  }

  function moveDroneToPad(index, collect = false) {
    const target = padPositions[index];
    // Set drone target to above the pad
    state.anim.targetX = target.x;
    state.anim.targetY = target.y - padRadius - 20;
    // Slight vertical drop if collect
    if (collect) {
      // animate: go down and up, then back to center
      const originalY = state.anim.y;
      const dropY = target.y - padRadius - 6;
      // Using simple timed tween
      const start = performance.now();
      const duration = 500;
      const startX = state.anim.x;
      const startY = state.anim.y;

      // We'll still use the global animation loop but mark vx/vy
      // Directly set target values; animate via update loop smoothing
    }
  }

  function wobbleDrone() {
    state.anim.wobble = 6;
  }

  // -------------------------
  // Animation loop
  // -------------------------
  let lastTime = performance.now();
  function update(dt) {
    // Simple smoothing towards target for drone
    const ax = state.anim.targetX - state.anim.x;
    const ay = state.anim.targetY - state.anim.y;
    state.anim.vx = state.anim.vx * 0.85 + ax * 0.08;
    state.anim.vy = state.anim.vy * 0.85 + ay * 0.06;
    state.anim.x += state.anim.vx * dt * 0.06;
    state.anim.y += state.anim.vy * dt * 0.06;

    // wobble decay
    state.anim.wobble *= 0.92;
    if (Math.abs(state.anim.wobble) < 0.01) state.anim.wobble = 0;
  }

  function loop(now) {
    const dt = (now - lastTime) / 16.67; // roughly 60fps units
    lastTime = now;
    update(dt);
    drawScene();
    requestAnimationFrame(loop);
  }

  // -------------------------
  // Input: keyboard and mouse
  // -------------------------
  function onKeyDown(e) {
    // Ensure audio context starts on first user interaction
    if (!audioContext && audioEnabled) {
      try {
        initAudioContext();
        safeResumeAudio();
      } catch (err) {
        console.warn('Audio init on interaction failed', err);
      }
    }
    if (state.phase === 'playing') {
      if (e.key >= '1' && e.key <= '4') {
        const idx = parseInt(e.key, 10) - 1;
        selectIndex(idx);
        e.preventDefault();
      } else if (e.key === 'ArrowLeft') {
        selectIndex(state.selectedIndex - 1);
        e.preventDefault();
      } else if (e.key === 'ArrowRight') {
        selectIndex(state.selectedIndex + 1);
        e.preventDefault();
      } else if (e.key === 'Enter' || e.key === ' ') {
        // Space/Enter confirm when playing
        confirmSelection();
        e.preventDefault();
      }
    } else {
      // End screens: Space or Enter to restart
      if (e.key === ' ' || e.key === 'Spacebar' || e.key === 'Enter') {
        restartGame();
        e.preventDefault();
      }
    }
    if (e.key.toLowerCase() === 'm') {
      toggleAudio();
      e.preventDefault();
    }
  }

  function onClick(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    // If in end screen, restart
    if (state.phase !== 'playing') {
      restartGame();
      return;
    }
    // Click on pads?
    for (let i = 0; i < padSlots; i++) {
      const p = padPositions[i];
      const dx = x - p.x;
      const dy = y - p.y;
      if (dx * dx + dy * dy <= (padRadius + 8) * (padRadius + 8)) {
        selectIndex(i);
        confirmSelection();
        return;
      }
    }
    // click audio icon region roughly
    // (we can toggle audio if clicked near top-right area)
    if (x > WIDTH - 160 && x < WIDTH - 40 && y < 80) {
      toggleAudio();
    }
  }

  // -------------------------
  // Restart and helpers
  // -------------------------
  function restartGame() {
    state.phase = 'playing';
    state.correctCount = 0;
    state.wrongCount = 0;
    state.message = '';
    state.selectedIndex = 0;
    state.anim.x = WIDTH / 2;
    state.anim.y = 120;
    state.anim.targetX = WIDTH / 2;
    state.anim.targetY = 120;
    newQuestion();
    updateLiveRegion('Game restarted. Good luck!');
    // Ensure audio resumed if enabled
    if (audioEnabled) {
      try {
        initAudioContext();
        safeResumeAudio();
      } catch (err) {}
    }
  }

  function updateLiveRegion(text) {
    liveRegion.textContent = text;
    state.announced = text;
  }

  // -------------------------
  // Initialization
  // -------------------------
  function start() {
    // Fonts and initial measurement check
    ctx.textBaseline = 'top';
    ctx.font = `${MIN_BODY_FONT}px sans-serif`;

    // Create initial question
    newQuestion();

    // Attach events
    canvas.addEventListener('keydown', onKeyDown);
    canvas.addEventListener('click', onClick);
    // Also allow container to receive clicks for accessibility
    container.addEventListener('click', () => {
      canvas.focus();
    });

    // Try to init audio, but handle failures gracefully
    try {
      initAudioContext();
    } catch (err) {
      console.warn('Audio init error on start', err);
    }

    // Kick off render loop
    lastTime = performance.now();
    requestAnimationFrame(loop);
    // Focus canvas to allow keyboard immediately
    setTimeout(() => {
      try {
        canvas.focus();
      } catch (e) {}
    }, 50);

    updateLiveRegion('Welcome to Drone Math Adventure! Use keys 1 to 4 to answer.');
  }

  // Error handling for audio context creation on user gesture
  function resumeAudioOnFirstGesture() {
    function resume() {
      if (audioEnabled && audioContext) {
        audioContext.resume().catch(() => {});
      }
      window.removeEventListener('pointerdown', resume);
      window.removeEventListener('keydown', resume);
    }
    window.addEventListener('pointerdown', resume, { once: true });
    window.addEventListener('keydown', resume, { once: true });
  }

  // Start the game
  try {
    start();
    resumeAudioOnFirstGesture();
  } catch (err) {
    console.error('Game initialization error', err);
    // Draw an error message on canvas
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    drawTextPanel('An error occurred initializing the game.', WIDTH / 2, HEIGHT / 2, {
      fontSize: 18,
      padding: 12,
      bg: '#fff4f4',
      color: COLORS.bad,
      center: true,
    });
    updateLiveRegion('An error occurred initializing the game. Please try reloading the page.');
  }
})();
---

