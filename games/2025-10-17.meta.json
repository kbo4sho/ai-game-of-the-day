{
  "generated_date": "2025-10-17",
  "generated_timestamp": "2025-10-17T00:27:24.871060",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8686,
  "game_filename": "2025-10-17.js",
  "game_size_bytes": 25571,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n// Drone Math Delivery \u2014 Canvas Game\n// Designed for children ages 7-9. Render into element with ID \"game-of-the-day-stage\"\n// IMPORTANT: This file is standalone JavaScript. It creates a canvas inside the given container.\n\n(() => {\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const PADDING = 10; // minimum padding between UI elements\n  const TARGET_CORRECT = 10; // win condition: collect this many correct parcels\n  const MAX_LIVES = 3; // lose condition: this many wrong collections ends the game\n  const PARCEL_SPAWN_INTERVAL = 1000; // ms between parcel spawns (changes with difficulty)\n  const PARCEL_SPEED_MIN = 0.6;\n  const PARCEL_SPEED_MAX = 1.6;\n\n  // Get container and create canvas\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Container element with id \"game-of-the-day-stage\" not found.');\n    return;\n  }\n  container.style.position = 'relative';\n  container.style.width = `${WIDTH}px`;\n  container.style.height = `${HEIGHT}px`;\n  container.tabIndex = 0; // make focusable for keyboard events\n\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.display = 'block';\n  canvas.style.outline = 'none';\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext('2d');\n\n  // Fonts and sizes\n  const BODY_FONT = '16px sans-serif';\n  const IMPORTANT_FONT = '20px sans-serif';\n  const TITLE_FONT = '28px sans-serif';\n  const SMALL_FONT = '14px sans-serif'; // for small labels; ensure it's readable per requirements\n\n  // Game state\n  let state = 'menu'; // 'menu' | 'playing' | 'win' | 'gameover'\n  let score = 0;\n  let lives = MAX_LIVES;\n  let targetQuestion = null; // {a,b,op,answer}\n  let parcels = []; // falling items\n  let lastSpawn = 0;\n  let spawnInterval = PARCEL_SPAWN_INTERVAL;\n  let keys = {};\n  let lastTime = performance.now();\n  let drone = {\n    x: WIDTH / 2,\n    y: HEIGHT - 70,\n    width: 80,\n    height: 36,\n    speed: 240 // pixels per second\n  };\n  let audioEnabled = true;\n  let audioContext = null;\n  let backgroundNode = null;\n  let masterGain = null;\n\n  // Accessibility: show if audio available\n  let audioAvailable = false;\n\n  // Error handling wrapper for audio creation\n  function createAudioContextSafely() {\n    try {\n      const AC = window.AudioContext || window.webkitAudioContext;\n      if (!AC) throw new Error('Web Audio API not supported.');\n      const ctx = new AC();\n      audioAvailable = true;\n      return ctx;\n    } catch (err) {\n      console.warn('AudioContext creation failed:', err);\n      audioAvailable = false;\n      return null;\n    }\n  }\n\n  // Initialize Audio\n  function initAudio() {\n    if (audioContext) return;\n    audioContext = createAudioContextSafely();\n    if (!audioContext) return;\n    try {\n      masterGain = audioContext.createGain();\n      masterGain.gain.value = 0.12; // gentle volume\n      masterGain.connect(audioContext.destination);\n\n      // background gentle hum: low frequency sawtooth with slow LFO filter\n      const osc = audioContext.createOscillator();\n      osc.type = 'sine';\n      osc.frequency.value = 120;\n      const bgGain = audioContext.createGain();\n      bgGain.gain.value = 0.03;\n\n      // gentle tremolo using a low-frequency oscillator controlling bgGain.gain\n      const lfo = audioContext.createOscillator();\n      lfo.type = 'sine';\n      lfo.frequency.value = 0.15;\n      const lfoGain = audioContext.createGain();\n      lfoGain.gain.value = 0.02;\n      lfo.connect(lfoGain);\n      lfoGain.connect(bgGain.gain);\n\n      osc.connect(bgGain);\n      bgGain.connect(masterGain);\n\n      osc.start();\n      lfo.start();\n\n      backgroundNode = { osc, bgGain, lfo, lfoGain };\n    } catch (err) {\n      console.warn('Error initializing audio nodes:', err);\n      audioAvailable = false;\n    }\n  }\n\n  // Play feedback sound: 'correct' or 'wrong' or 'pick'\n  function playSound(type = 'pick') {\n    if (!audioContext || !audioAvailable || !audioEnabled) return;\n    try {\n      const now = audioContext.currentTime;\n      const o = audioContext.createOscillator();\n      const g = audioContext.createGain();\n      const filter = audioContext.createBiquadFilter();\n      filter.type = 'lowpass';\n      filter.frequency.value = 1200;\n      o.connect(filter);\n      filter.connect(g);\n      g.connect(masterGain);\n\n      if (type === 'correct') {\n        o.type = 'sine';\n        o.frequency.setValueAtTime(880, now);\n        o.frequency.exponentialRampToValueAtTime(440, now + 0.2);\n        g.gain.setValueAtTime(0.12, now);\n        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);\n      } else if (type === 'wrong') {\n        o.type = 'sawtooth';\n        o.frequency.setValueAtTime(220, now);\n        o.frequency.exponentialRampToValueAtTime(110, now + 0.25);\n        g.gain.setValueAtTime(0.14, now);\n        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);\n      } else {\n        // pick / hover\n        o.type = 'triangle';\n        o.frequency.setValueAtTime(660, now);\n        g.gain.setValueAtTime(0.04, now);\n        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);\n      }\n      o.start(now);\n      o.stop(now + 1);\n    } catch (err) {\n      console.warn('Error creating sound:', err);\n    }\n  }\n\n  // Utility: generate a simple addition or subtraction question suitable for ages 7-9\n  function generateQuestion() {\n    const op = Math.random() < 0.6 ? '+' : '-';\n    let a, b, answer;\n    if (op === '+') {\n      a = Math.floor(Math.random() * 10) + 1; // 1-10\n      b = Math.floor(Math.random() * 10) + 1;\n      answer = a + b;\n    } else {\n      a = Math.floor(Math.random() * 15) + 1; // 1-15\n      b = Math.floor(Math.random() * a) + 0; // ensure non-negative result\n      answer = a - b;\n    }\n    return { a, b, op, answer };\n  }\n\n  // Parcel object creation\n  function spawnParcel() {\n    const q = targetQuestion;\n    // Make numbers around typical ranges: include some equal to the answer\n    // Probability that a spawned parcel equals the answer: ~35%\n    const isCorrect = Math.random() < 0.35;\n    let value;\n    if (isCorrect) {\n      value = q.answer;\n    } else {\n      // create plausible distractors: near answer or random within 0-20\n      const offset = Math.floor(Math.random() * 7) - 3; // -3..3\n      value = Math.max(0, q.answer + offset);\n      if (value === q.answer) {\n        value = (value + 2) % 21;\n      }\n    }\n    const x = Math.random() * (WIDTH - 40) + 20;\n    const speed = PARCEL_SPEED_MIN + Math.random() * (PARCEL_SPEED_MAX - PARCEL_SPEED_MIN);\n    const color = pastelColor();\n    const shape = Math.random() < 0.5 ? 'box' : 'circle';\n    parcels.push({ x, y: -20, vy: 40 * speed, value, color, shape, r: 18 });\n  }\n\n  // Pastel color generator\n  function pastelColor() {\n    const hue = Math.floor(Math.random() * 360);\n    const sat = 60 + Math.floor(Math.random() * 20);\n    const light = 70 + Math.floor(Math.random() * 10);\n    return `hsl(${hue}deg ${sat}% ${light}%)`;\n  }\n\n  // Draw helpers with measureText background rectangles ensuring no overlap\n  function drawTextWithBackground(text, font, x, y, options = {}) {\n    const padding = options.padding ?? 8;\n    ctx.font = font;\n    const metrics = ctx.measureText(text);\n    const textWidth = metrics.width;\n    const textHeight = parseInt(font) || 16;\n    let rectX = x;\n    let rectY = y - textHeight;\n    // If center option, center rect\n    if (options.center) rectX = x - textWidth / 2 - padding;\n    if (options.right) rectX = x - textWidth - padding * 2;\n    const rectW = textWidth + padding * 2;\n    const rectH = textHeight + padding * 1.6;\n    ctx.fillStyle = options.bgColor ?? 'rgba(255,255,255,0.75)';\n    roundRect(ctx, rectX, rectY, rectW, rectH, 6, true, false);\n    ctx.fillStyle = options.color ?? '#111';\n    ctx.font = font;\n    ctx.textBaseline = 'top';\n    if (options.center) ctx.fillText(text, x - textWidth / 2, rectY + padding * 0.6);\n    else if (options.right) ctx.fillText(text, rectX + padding, rectY + padding * 0.6);\n    else ctx.fillText(text, rectX + padding, rectY + padding * 0.6);\n    return { rectX, rectY, rectW, rectH };\n  }\n\n  // Rounded rectangle utility\n  function roundRect(ctx, x, y, w, h, r, fill, stroke) {\n    if (typeof stroke === 'undefined') stroke = true;\n    if (typeof r === 'undefined') r = 5;\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  // Draw scene background with wacky clouds and calm colors\n  function drawBackground(t) {\n    // gentle gradient sky\n    const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    grad.addColorStop(0, 'hsl(210deg 60% 95%)');\n    grad.addColorStop(1, 'hsl(210deg 60% 85%)');\n    ctx.fillStyle = grad;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // sun / light\n    ctx.beginPath();\n    ctx.fillStyle = 'rgba(255, 245, 200, 0.6)';\n    ctx.arc(620, 80, 45, 0, Math.PI * 2);\n    ctx.fill();\n\n    // wacky clouds\n    for (let i = 0; i < 4; i++) {\n      drawCloud(80 + i * 150 + ((t / 500) % 60), 60 + (i % 2) * 20, 1 + (i % 2) * 0.2, i);\n    }\n\n    // distant grid/hills like a landing zone\n    ctx.fillStyle = 'hsl(120deg 40% 94%)';\n    ctx.fillRect(0, HEIGHT - 110, WIDTH, 110);\n    ctx.fillStyle = 'hsl(120deg 35% 86%)';\n    ctx.fillRect(0, HEIGHT - 110, WIDTH, 14);\n  }\n\n  function drawCloud(cx, cy, scale = 1, odd = 0) {\n    ctx.save();\n    ctx.translate(cx, cy);\n    ctx.scale(scale, scale);\n    ctx.beginPath();\n    ctx.fillStyle = 'rgba(255,255,255,0.88)';\n    ctx.strokeStyle = 'rgba(220,220,255,0.6)';\n    ctx.lineWidth = 2;\n    const wobble = Math.sin((cx + cy) / 60 + odd) * 4;\n    ctx.ellipse(-10 + wobble, 0, 28, 18, 0, 0, Math.PI * 2);\n    ctx.ellipse(10 + wobble, 0, 34, 22, 0, 0, Math.PI * 2);\n    ctx.ellipse(28 + wobble, 0, 22, 14, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  // Draw drone\n  function drawDrone(dt, t) {\n    // drone body\n    ctx.save();\n    ctx.translate(drone.x, drone.y);\n    // shadow\n    ctx.beginPath();\n    ctx.ellipse(0, drone.height / 2 + 20, 38, 12, 0, 0, Math.PI * 2);\n    ctx.fillStyle = 'rgba(0,0,0,0.12)';\n    ctx.fill();\n\n    ctx.fillStyle = 'hsl(210deg 70% 86%)';\n    roundRect(ctx, -drone.width / 2, -drone.height / 2, drone.width, drone.height, 10, true, false);\n\n    // propellers (wacky arms)\n    ctx.fillStyle = 'hsl(200deg 60% 60%)';\n    for (let i = -1; i <= 1; i += 2) {\n      ctx.save();\n      ctx.translate(i * (drone.width / 2 - 6), -drone.height / 2 - 8);\n      ctx.beginPath();\n      const spin = (t / 100) * (i > 0 ? 1 : -1);\n      ctx.rotate(spin);\n      ctx.fillRect(-20, -4, 40, 8);\n      ctx.restore();\n      // small rotor circle\n      ctx.beginPath();\n      ctx.arc(i * (drone.width / 2 - 6), -drone.height / 2 - 8, 6, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // face\n    ctx.fillStyle = '#333';\n    ctx.beginPath();\n    ctx.arc(-18, 0, 6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(6, 0, 10, 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  // Draw parcels\n  function drawParcels() {\n    parcels.forEach(p => {\n      ctx.save();\n      ctx.translate(p.x, p.y);\n      ctx.fillStyle = p.color;\n      ctx.strokeStyle = 'rgba(0,0,0,0.08)';\n      ctx.lineWidth = 2;\n      if (p.shape === 'circle') {\n        ctx.beginPath();\n        ctx.arc(0, 0, p.r, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.stroke();\n      } else {\n        roundRect(ctx, -p.r, -p.r, p.r * 2, p.r * 2, 8, true, true);\n      }\n      // text value\n      ctx.fillStyle = '#123';\n      ctx.font = IMPORTANT_FONT;\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(String(p.value), 0, 0);\n      ctx.restore();\n    });\n  }\n\n  // Collision detection between drone rect and parcel circle/box\n  function checkCollision(p) {\n    // drone bounding box\n    const dx = Math.abs(p.x - drone.x);\n    const dy = Math.abs(p.y - drone.y);\n    const halfW = drone.width / 2;\n    const halfH = drone.height / 2;\n    // approximate: if parcel circle intersects rect\n    const closestX = Math.max(drone.x - halfW, Math.min(p.x, drone.x + halfW));\n    const closestY = Math.max(drone.y - halfH, Math.min(p.y, drone.y + halfH));\n    const distX = p.x - closestX;\n    const distY = p.y - closestY;\n    return distX * distX + distY * distY < (p.r + 4) * (p.r + 4);\n  }\n\n  // Start new game\n  function startGame() {\n    score = 0;\n    lives = MAX_LIVES;\n    parcels = [];\n    spawnInterval = PARCEL_SPAWN_INTERVAL;\n    lastSpawn = 0;\n    targetQuestion = generateQuestion();\n    state = 'playing';\n    lastTime = performance.now();\n    // ensure audio context created on user interaction\n    if (!audioContext && audioAvailable) {\n      initAudio();\n    }\n  }\n\n  // End game with win or lose\n  function endGame(outcome) {\n    state = outcome === 'win' ? 'win' : 'gameover';\n    // stop background audio gentle hum if present\n    if (backgroundNode && audioContext) {\n      // reduce background gracefully\n      try {\n        backgroundNode.bgGain.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.8);\n      } catch (err) {\n        console.warn('Error fading background:', err);\n      }\n    }\n  }\n\n  // Restart game from end screens\n  function restart() {\n    // restart background if audio enabled\n    if (audioAvailable && audioEnabled && audioContext == null) {\n      initAudio();\n    }\n    startGame();\n  }\n\n  // Main update loop\n  function update(now) {\n    const dt = (now - lastTime) / 1000;\n    lastTime = now;\n    // update based on state\n    if (state === 'playing') {\n      // move drone with keyboard\n      let move = 0;\n      if (keys.ArrowLeft || keys.a || keys.A) move -= 1;\n      if (keys.ArrowRight || keys.d || keys.D) move += 1;\n      if (move !== 0) drone.x += move * drone.speed * dt;\n      // clamp\n      drone.x = Math.max(drone.width / 2 + 6, Math.min(WIDTH - drone.width / 2 - 6, drone.x));\n\n      // spawn parcels\n      lastSpawn += dt * 1000;\n      if (lastSpawn > spawnInterval) {\n        spawnParcel();\n        lastSpawn = 0;\n        // gradual difficulty increase\n        if (spawnInterval > 500) spawnInterval -= 6;\n      }\n\n      // update parcels\n      for (let i = parcels.length - 1; i >= 0; i--) {\n        const p = parcels[i];\n        p.y += p.vy * dt;\n        // check collision\n        if (checkCollision(p)) {\n          // handle pick up\n          const correct = p.value === targetQuestion.answer;\n          if (correct) {\n            score++;\n            playSound('correct');\n            // cheerful sparkle effect: quick visual flash (we can just add a short life in parcel)\n            // update target every few corrects for variety\n            if (score % 3 === 0) {\n              targetQuestion = generateQuestion();\n            }\n            // win?\n            if (score >= TARGET_CORRECT) {\n              endGame('win');\n            }\n          } else {\n            lives--;\n            playSound('wrong');\n            // slightly change the target question to avoid repetition\n            if (Math.random() < 0.5) targetQuestion = generateQuestion();\n            if (lives <= 0) {\n              endGame('lose');\n            }\n          }\n          parcels.splice(i, 1);\n          continue;\n        }\n        // remove if off bottom\n        if (p.y - p.r > HEIGHT) {\n          parcels.splice(i, 1);\n        }\n      }\n    }\n\n    draw(now);\n    if (state === 'playing' || state === 'menu') {\n      requestAnimationFrame(update);\n    } else {\n      // draw end screen once; still listen for restart\n      draw(now);\n    }\n  }\n\n  // Drawing everything\n  function draw(t) {\n    // background\n    drawBackground(t);\n\n    // parcels\n    drawParcels();\n\n    // drone\n    drawDrone(0, t);\n\n    // UI: score top-left, lives top-right, target top-center, instructions bottom-center\n    // Score\n    ctx.save();\n    ctx.strokeStyle = 'rgba(20,20,20,0.06)';\n    drawTextWithBackground(`Score: ${score}`, IMPORTANT_FONT, PADDING, PADDING + 22, {\n      bgColor: 'rgba(255,255,255,0.85)',\n      color: '#0b3d91',\n      padding: 12\n    });\n    ctx.restore();\n\n    // Lives top-right\n    ctx.save();\n    const livesText = `Lives: ${lives}`;\n    ctx.font = IMPORTANT_FONT;\n    const metrics = ctx.measureText(livesText);\n    const rightX = WIDTH - PADDING;\n    drawTextWithBackground(livesText, IMPORTANT_FONT, rightX, PADDING + 22, {\n      right: true,\n      bgColor: 'rgba(255,255,255,0.85)',\n      color: '#a11',\n      padding: 12\n    });\n    ctx.restore();\n\n    // Audio indicator near top-left below score\n    ctx.save();\n    const audioText = audioAvailable ? (audioEnabled ? 'Audio: On' : 'Audio: Off') : 'Audio: Unavailable';\n    ctx.font = SMALL_FONT;\n    drawTextWithBackground(audioText, SMALL_FONT, PADDING, PADDING + 64, {\n      bgColor: 'rgba(255,255,255,0.8)',\n      color: '#333',\n      padding: 8\n    });\n    ctx.restore();\n\n    // Target question top-center\n    ctx.save();\n    const qText = state === 'playing' ? `Deliver parcels that equal: ${targetQuestion.a} ${targetQuestion.op} ${targetQuestion.b} = ?` : '';\n    if (qText) {\n      ctx.font = TITLE_FONT;\n      const centerX = WIDTH / 2;\n      drawTextWithBackground(qText, TITLE_FONT, centerX, PADDING + 30, {\n        center: true,\n        bgColor: 'rgba(255,255,255,0.9)',\n        color: '#053',\n        padding: 12\n      });\n    }\n    ctx.restore();\n\n    // bottom-center instructions (non overlapping)\n    ctx.save();\n    ctx.font = BODY_FONT;\n    const instrLines = [];\n    if (state === 'menu') {\n      instrLines.push('Welcome! Help the drone collect correct parcels.');\n      instrLines.push('Use \u2190 \u2192 or A/D to move. Click or press Enter to start (enables audio).');\n    } else if (state === 'playing') {\n      instrLines.push('Move the drone to collect parcels with the correct number.');\n      instrLines.push(`Goal: Collect ${TARGET_CORRECT} correct parcels. Wrong parcels: lose a life. Lives: ${MAX_LIVES}`);\n      instrLines.push('Controls: \u2190 \u2192 (or A/D). Press M to toggle audio. Press R to restart anytime.');\n    } else if (state === 'win') {\n      instrLines.push('Victory! You delivered all parcels!');\n      instrLines.push('Click Restart or press R to play again.');\n    } else if (state === 'gameover') {\n      instrLines.push('Game Over. The drone ran out of lives.');\n      instrLines.push('Click Restart or press R to try again.');\n    }\n    // compute combined width of multi-line block using measureText longest line\n    let maxWidth = 0;\n    ctx.font = BODY_FONT;\n    instrLines.forEach(line => {\n      const w = ctx.measureText(line).width;\n      if (w > maxWidth) maxWidth = w;\n    });\n    const blockW = maxWidth + 24;\n    const lineHeight = 20;\n    const blockH = instrLines.length * lineHeight + 18;\n    const bx = WIDTH / 2 - blockW / 2;\n    const by = HEIGHT - blockH - 14;\n    ctx.fillStyle = 'rgba(255,255,255,0.9)';\n    roundRect(ctx, bx, by, blockW, blockH, 8, true, false);\n    ctx.fillStyle = '#112';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'top';\n    let ty = by + 9;\n    ctx.font = BODY_FONT;\n    instrLines.forEach(line => {\n      ctx.fillText(line, WIDTH / 2, ty);\n      ty += lineHeight;\n    });\n    ctx.restore();\n\n    // If menu screen, show big instructions and start button area\n    if (state === 'menu') {\n      ctx.save();\n      const title = 'Drone Math Delivery';\n      ctx.font = '34px sans-serif';\n      const centerX = WIDTH / 2;\n      const centerY = HEIGHT / 2 - 30;\n      drawTextWithBackground(title, '34px sans-serif', centerX, centerY, {\n        center: true,\n        bgColor: 'rgba(255,255,255,0.92)',\n        color: '#006',\n        padding: 14\n      });\n\n      // start button\n      const startText = 'Click or Press Enter to Start';\n      ctx.font = IMPORTANT_FONT;\n      const res = drawTextWithBackground(startText, IMPORTANT_FONT, centerX, centerY + 70, {\n        center: true,\n        bgColor: 'rgba(10,120,180,0.12)',\n        color: '#005',\n        padding: 14\n      });\n      // store start button area for pointer detection\n      menuStartButtonRect = { x: res.rectX, y: res.rectY, w: res.rectW, h: res.rectH };\n      ctx.restore();\n    }\n\n    // End screens\n    if (state === 'win' || state === 'gameover') {\n      ctx.save();\n      ctx.globalAlpha = 0.96;\n      // overlay dim\n      ctx.fillStyle = 'rgba(10, 10, 20, 0.08)';\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n      ctx.globalAlpha = 1;\n\n      const title = state === 'win' ? 'You Win!' : 'Game Over';\n      const subtitle = state === 'win'\n        ? `You collected ${score} correct parcels.`\n        : `You collected ${score} correct parcels.`;\n\n      ctx.font = '36px sans-serif';\n      drawTextWithBackground(title, '36px sans-serif', WIDTH / 2, HEIGHT / 2 - 40, {\n        center: true,\n        bgColor: 'rgba(255,255,255,0.95)',\n        color: state === 'win' ? '#0a7' : '#a00',\n        padding: 16\n      });\n      ctx.font = IMPORTANT_FONT;\n      drawTextWithBackground(subtitle, IMPORTANT_FONT, WIDTH / 2, HEIGHT / 2 + 10, {\n        center: true,\n        bgColor: 'rgba(255,255,255,0.95)',\n        color: '#123',\n        padding: 12\n      });\n      // restart button area\n      ctx.font = IMPORTANT_FONT;\n      const restartText = 'Restart (Click or press R)';\n      const res = drawTextWithBackground(restartText, IMPORTANT_FONT, WIDTH / 2, HEIGHT / 2 + 70, {\n        center: true,\n        bgColor: 'rgba(255,255,255,0.95)',\n        color: '#035',\n        padding: 12\n      });\n      menuStartButtonRect = { x: res.rectX, y: res.rectY, w: res.rectW, h: res.rectH, isRestart: true };\n      ctx.restore();\n    }\n  }\n\n  // Pointer/click handling: to start or restart\n  let menuStartButtonRect = null;\n  canvas.addEventListener('pointerdown', e => {\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    // enable audio context upon user interaction\n    if (!audioContext && audioAvailable) {\n      try {\n        initAudio();\n        // resume context if suspended (necessary in some browsers)\n        if (audioContext && audioContext.state === 'suspended') audioContext.resume();\n      } catch (err) {\n        console.warn('Error resuming audioContext on pointerdown:', err);\n      }\n    }\n    if (state === 'menu') {\n      // start if clicked on start button or anywhere\n      if (!menuStartButtonRect || pointInRect(x, y, menuStartButtonRect)) {\n        startGame();\n      }\n    } else if (state === 'playing') {\n      // allow clicking to toggle audio indicator when clicking audio box near top-left\n      // determine audio box rectangle by re-drawing measurement (approx)\n      // for simplicity, check if click was within top-left PADDING area\n      if (x < 180 && y < 110) {\n        toggleAudio();\n      }\n    } else if (state === 'win' || state === 'gameover') {\n      if (menuStartButtonRect && pointInRect(x, y, menuStartButtonRect)) {\n        restart();\n        requestAnimationFrame(update);\n      }\n    }\n  });\n\n  function pointInRect(x, y, r) {\n    return x >= r.x && x <= r.x + r.w && y >= r.y && y <= r.y + r.h;\n  }\n\n  // Keyboard controls\n  window.addEventListener('keydown', e => {\n    if (!keys[e.key]) keys[e.key] = true;\n    // start game with Enter from menu\n    if (state === 'menu' && (e.key === 'Enter' || e.key === ' ')) {\n      // initialize audio on keypress\n      if (!audioContext && audioAvailable) {\n        initAudio();\n        if (audioContext && audioContext.state === 'suspended') audioContext.resume().catch(()=>{});\n      }\n      startGame();\n      requestAnimationFrame(update);\n    }\n    // restart with R\n    if ((state === 'gameover' || state === 'win') && (e.key === 'r' || e.key === 'R')) {\n      restart();\n      requestAnimationFrame(update);\n    }\n    // toggle audio with M\n    if (e.key === 'm' || e.key === 'M') {\n      toggleAudio();\n    }\n    // accessibility: space toggles audio on menu maybe\n  });\n\n  window.addEventListener('keyup', e => {\n    keys[e.key] = false;\n  });\n\n  // Toggle audio on/off\n  function toggleAudio() {\n    if (!audioAvailable) return;\n    audioEnabled = !audioEnabled;\n    if (!audioEnabled && masterGain) {\n      masterGain.gain.setValueAtTime(0.0001, audioContext.currentTime);\n    } else if (audioEnabled && masterGain) {\n      masterGain.gain.setValueAtTime(0.12, audioContext.currentTime);\n    }\n    playSound('pick');\n  }\n\n  // Start with menu drawing and instructions\n  function init() {\n    // Try to create audio context lazily but not required\n    try {\n      // Some browsers may restrict creation; we only test support here\n      const AC = window.AudioContext || window.webkitAudioContext;\n      if (AC) {\n        audioAvailable = true;\n      } else {\n        audioAvailable = false;\n      }\n    } catch (err) {\n      audioAvailable = false;\n    }\n    // initial question for menu display\n    targetQuestion = generateQuestion();\n    // focus container for keyboard events\n    container.focus();\n    lastTime = performance.now();\n    // initial draw and update loop\n    requestAnimationFrame(update);\n  }\n\n  // Kick off\n  init();\n\n  // Error resilience for audio context visibility change\n  document.addEventListener('visibilitychange', () => {\n    if (document.visibilityState === 'visible' && audioContext && audioEnabled) {\n      if (audioContext.state === 'suspended') {\n        audioContext.resume().catch(err => console.warn('Resume audio failed:', err));\n      }\n    }\n  });\n\n})();\n---\n",
  "improve_response_tokens": 19271,
  "formatted_code": true,
  "formatting_response_tokens": 22219,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}