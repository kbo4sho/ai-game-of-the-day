# Game of the Day - 2025-09-04

## Metadata
- **Generated Date:** 2025-09-04
- **Generated Time:** 2025-09-04T00:25:21.121442
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-04.js
- **File Size:** 25214 bytes
- **Tokens Used:** 8517

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-04.js` - The playable game
- `2025-09-04.meta.json` - Machine-readable metadata
- `2025-09-04.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 16528

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 17374

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function() {
  // Machine Math — Canvas game for ages 7-9
  // Renders inside element with id "game-of-the-day-stage"
  // All visuals drawn on canvas. All sounds via Web Audio API.
  // Accessible: keyboard controls, aria live updates, speaker toggle, clear instructions.

  // ---- Config ----
  const WIDTH = 720;
  const HEIGHT = 480;
  const TOTAL_ROUNDS = 8;
  const MAX_TRIES_PER_ROUND = 4;

  // Calming palette, with a few wacky accent colors
  const COLORS = {
    bg: '#E9F3F6',
    machine: '#D1E8E2',
    accent: '#6A8AA6',
    bolt: '#F2B134',
    text: '#16324F',
    panel: '#8FC1A9',
    shadow: 'rgba(0,0,0,0.12)',
    wrong: '#FF6B6B',
    correct: '#4CAF50'
  };

  // Utility: clamp value
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  // DOM references and canvas
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Container element #game-of-the-day-stage not found.');
    return;
  }

  // Clear container and set up canvas
  container.innerHTML = '';
  container.style.position = 'relative';
  container.style.userSelect = 'none';

  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute('role', 'img');
  canvas.setAttribute('aria-label', 'Math machine game canvas');
  canvas.style.width = WIDTH + 'px';
  canvas.style.height = HEIGHT + 'px';
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d', { alpha: false });

  // Accessibility: live region for screen readers
  const live = document.createElement('div');
  live.setAttribute('aria-live', 'polite');
  live.setAttribute('role', 'status');
  live.style.position = 'absolute';
  live.style.left = '-9999px';
  live.style.width = '1px';
  live.style.height = '1px';
  live.style.overflow = 'hidden';
  container.appendChild(live);

  // Audio: Web Audio API setup with error handling
  let audioCtx = null;
  let audioAllowed = false; // user must enable to start sound
  let bgGain = null;
  let bgOsc = null;

  function initAudioContext() {
    if (audioCtx) return;
    try {
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtx) throw new Error('Web Audio API not supported on this browser.');
      audioCtx = new AudioCtx();
      // Create gentle background hum
      bgOsc = audioCtx.createOscillator();
      const lowLFO = audioCtx.createOscillator();
      const lfoGain = audioCtx.createGain();
      bgGain = audioCtx.createGain();

      bgOsc.type = 'sine';
      bgOsc.frequency.value = 80; // base hum
      lowLFO.type = 'sine';
      lowLFO.frequency.value = 0.25; // slow wobble
      lfoGain.gain.value = 8;
      bgGain.gain.value = 0; // start muted until enabled

      lowLFO.connect(lfoGain);
      lfoGain.connect(bgOsc.frequency);
      bgOsc.connect(bgGain);
      bgGain.connect(audioCtx.destination);

      lowLFO.start();
      bgOsc.start();
    } catch (e) {
      console.error('Audio context init failed:', e);
      audioCtx = null;
    }
  }

  function tryEnableAudio() {
    try {
      initAudioContext();
      if (!audioCtx) return false;
      // Many browsers require a user interaction to resume
      if (audioCtx.state === 'suspended') {
        audioCtx.resume().catch(err => {
          console.warn('Could not resume audio context:', err);
        });
      }
      audioAllowed = true;
      if (bgGain) {
        // ramp up gently
        try {
          bgGain.gain.cancelScheduledValues(audioCtx.currentTime);
          bgGain.gain.setValueAtTime(bgGain.gain.value, audioCtx.currentTime);
          bgGain.gain.linearRampToValueAtTime(0.06, audioCtx.currentTime + 0.8);
        } catch (e) {
          // ignore scheduling errors
          bgGain.gain.value = 0.06;
        }
      }
      announceForA11y('Sound enabled.');
      return true;
    } catch (e) {
      console.error('Error enabling audio:', e);
      return false;
    }
  }

  function toggleAudio() {
    if (!audioCtx) {
      tryEnableAudio();
      return;
    }
    if (!audioAllowed) {
      tryEnableAudio();
      return;
    }
    // Toggle off
    if (bgGain && audioAllowed) {
      try {
        bgGain.gain.cancelScheduledValues(audioCtx.currentTime);
        bgGain.gain.setValueAtTime(bgGain.gain.value, audioCtx.currentTime);
        const newVal = bgGain.gain.value > 0.01 ? 0 : 0.06;
        bgGain.gain.linearRampToValueAtTime(newVal, audioCtx.currentTime + 0.5);
        audioAllowed = newVal > 0.01;
        announceForA11y(audioAllowed ? 'Sound enabled.' : 'Sound muted.');
      } catch (e) {
        console.warn('Error toggling audio:', e);
      }
    }
  }

  // Play success chime: sequence of notes
  function playSuccess() {
    if (!audioCtx || !audioAllowed) return;
    try {
      const now = audioCtx.currentTime;
      const g = audioCtx.createGain();
      g.connect(audioCtx.destination);
      g.gain.setValueAtTime(0.001, now);
      g.gain.exponentialRampToValueAtTime(0.06, now + 0.02);

      const notes = [880, 1100, 1320]; // happy ascending
      notes.forEach((freq, i) => {
        const o = audioCtx.createOscillator();
        o.type = 'sine';
        o.frequency.value = freq;
        o.connect(g);
        o.start(now + i * 0.08);
        o.stop(now + i * 0.08 + 0.18);
      });

      // fade out
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
      setTimeout(() => {
        g.disconnect();
      }, 700);
    } catch (e) {
      console.warn('playSuccess error', e);
    }
  }

  // Play wrong buzz
  function playWrong() {
    if (!audioCtx || !audioAllowed) return;
    try {
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const f = audioCtx.createBiquadFilter();
      o.type = 'sawtooth';
      o.frequency.value = 180;
      f.type = 'lowpass';
      f.frequency.value = 900;
      g.gain.setValueAtTime(0.001, now);
      g.gain.exponentialRampToValueAtTime(0.08, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
      o.connect(f);
      f.connect(g);
      g.connect(audioCtx.destination);
      o.start(now);
      o.frequency.setValueAtTime(180, now);
      o.frequency.exponentialRampToValueAtTime(60, now + 0.18);
      o.stop(now + 0.28);
      setTimeout(() => {
        g.disconnect();
        f.disconnect();
      }, 400);
    } catch (e) {
      console.warn('playWrong error', e);
    }
  }

  // Announce messages to live region for screen readers
  function announceForA11y(text) {
    if (!live) return;
    live.textContent = '';
    setTimeout(() => (live.textContent = text), 50);
  }

  // Game logic
  class Round {
    constructor(index) {
      this.index = index;
      const problem = Round.generateProblem(index);
      this.a = problem.a;
      this.b = problem.b;
      this.op = problem.op; // '+' or '-'
      this.answer = problem.a + (this.op === '+' ? problem.b : -problem.b);
      this.maxTries = MAX_TRIES_PER_ROUND;
    }

    static generateProblem(index) {
      // Progressive difficulty: start simple, then larger numbers
      // index: 0..TOTAL_ROUNDS-1
      const difficulty = 1 + Math.floor(index / 3); // 1..3
      const max = 5 + difficulty * 3; // increases
      const a = Math.floor(Math.random() * (max - 1)) + 1;
      const op = Math.random() < 0.6 || index < 2 ? '+' : '-';
      let b = Math.floor(Math.random() * (Math.min(9, max))) + 1;
      if (op === '-' && b > a) {
        // ensure non-negative result to be kid-friendly
        b = Math.floor(Math.random() * a) + 1;
      }
      return { a, b, op };
    }
  }

  class Game {
    constructor() {
      this.roundIndex = 0;
      this.round = new Round(0);
      this.currentInput = 0;
      this.score = 0;
      this.triesUsed = 0;
      this.isAnimating = false;
      this.finish = false;
      this.speakerVisible = true;
      this.audioAllowed = audioAllowed;
      this.lastOutcome = null; // 'correct' or 'wrong' or null
      this.animationTimer = 0;
      this.gearAngle = 0;
      this.goalBoltCount = Math.abs(this.round.answer);
      this.boltsEjected = 0;
      this.hintsUsed = 0;
      this.maxHints = 2;
      this.flashTimer = 0;
      this.updateRoundText();
    }

    updateRoundText() {
      announceForA11y(
        `Round ${this.roundIndex + 1}. Problem: ${this.round.a} ${this.round.op} ${
          this.round.b
        }. Use left and right arrows to change your answer. Press Enter to submit.`
      );
    }

    nextRound() {
      this.roundIndex++;
      if (this.roundIndex >= TOTAL_ROUNDS) {
        this.finish = true;
        announceForA11y('All rounds complete. Well done!');
        return;
      }
      this.round = new Round(this.roundIndex);
      this.currentInput = 0;
      this.triesUsed = 0;
      this.lastOutcome = null;
      this.goalBoltCount = Math.abs(this.round.answer);
      this.boltsEjected = 0;
      this.hintsUsed = 0;
      this.flashTimer = 0;
      this.isAnimating = false;
      this.updateRoundText();
    }

    submitAnswer() {
      if (this.isAnimating || this.finish) return;
      this.triesUsed++;
      const correct = this.currentInput === this.round.answer;
      if (correct) {
        this.score++;
        this.lastOutcome = 'correct';
        this.isAnimating = true;
        this.animationTimer = 0;
        playSuccess();
        announceForA11y('Correct! Great job!');
      } else {
        playWrong();
        this.lastOutcome = 'wrong';
        this.flashTimer = 18;
        if (this.triesUsed >= this.round.maxTries) {
          // reveal answer and move on after short pause
          announceForA11y(
            `That's not right. The correct answer was ${this.round.answer}. Moving to next round.`
          );
          this.isAnimating = true;
          this.animationTimer = 0;
          // mark as incorrect but still proceed so game stays beatable
          setTimeout(() => {
            this.nextRound();
          }, 1200);
        } else {
          announceForA11y('Try again.');
        }
      }
    }

    useHint() {
      if (this.hintsUsed >= this.maxHints || this.isAnimating) return;
      this.hintsUsed++;
      // simple hint: show one addend or say result range
      let hintText = '';
      if (this.round.op === '+') {
        hintText = `Hint: ${this.round.a} plus ${this.round.b} equals ${this.round.a + this.round.b}.`;
      } else {
        hintText = `Hint: ${this.round.a} minus ${this.round.b} equals ${this.round.a - this.round.b}.`;
      }
      announceForA11y(hintText);
      // subtle sound feedback
      if (audioAllowed) {
        try {
          const now = audioCtx.currentTime;
          const o = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          o.type = 'triangle';
          o.frequency.value = 300;
          g.gain.setValueAtTime(0.001, now);
          g.gain.exponentialRampToValueAtTime(0.02, now + 0.02);
          g.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
          o.connect(g);
          g.connect(audioCtx.destination);
          o.start(now);
          o.stop(now + 0.33);
          setTimeout(() => {
            g.disconnect();
          }, 400);
        } catch (e) {
          // ignore
        }
      }
    }
  }

  const game = new Game();

  // Input handling
  function adjustInput(delta) {
    if (game.isAnimating || game.finish) return;
    // allow negative answers for subtraction but clamp reasonable range
    const min = -20;
    const max = 20;
    game.currentInput = clamp(game.currentInput + delta, min, max);
    announceForA11y(`Answer now ${game.currentInput}`);
  }

  // Pointer (mouse/touch) handling - map clicks to +/- and submit/hint/sound
  canvas.addEventListener('pointerdown', e => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);
    handlePointer(x, y);
    // ensure audio can be enabled on first user gesture
    if (!audioAllowed) {
      tryEnableAudio();
    }
  });

  function handlePointer(x, y) {
    // Define regions by drawing layout knowledge. Left side +/-, center machine, right panel buttons.
    // +/- area:
    if (x < 160 && y > 220 && y < 420) {
      // up/down style areas
      if (y < 320) adjustInput(1);
      else adjustInput(-1);
      return;
    }
    // Submit button region (right panel)
    if (x > 520 && x < 700 && y > 320 && y < 372) {
      game.submitAnswer();
      return;
    }
    // Hint button
    if (x > 520 && x < 700 && y > 200 && y < 250) {
      game.useHint();
      return;
    }
    // Speaker icon toggle top-right
    if (x > 660 && y < 40) {
      toggleAudio();
      return;
    }
    // Clicking on bolt loader increases or decreases by 1 depending left/right
    if (x > 200 && x < 520 && y > 150 && y < 330) {
      // left half decrease, right half increase
      if (x < (200 + 520) / 2) adjustInput(-1);
      else adjustInput(1);
      return;
    }
  }

  // Keyboard controls
  window.addEventListener('keydown', e => {
    if (e.altKey || e.metaKey) return;
    if (game.finish && e.key === 'Enter') {
      // restart game
      restartGame();
      return;
    }
    switch (e.key) {
      case 'ArrowLeft':
        adjustInput(-1);
        e.preventDefault();
        break;
      case 'ArrowRight':
        adjustInput(1);
        e.preventDefault();
        break;
      case 'Enter':
        game.submitAnswer();
        e.preventDefault();
        break;
      case 'h':
      case 'H':
        game.useHint();
        e.preventDefault();
        break;
      case 'm':
      case 'M':
        toggleAudio();
        e.preventDefault();
        break;
      default:
        // Accept number keys to set input directly (including minus)
        if (/^[0-9]$/.test(e.key)) {
          const digit = Number(e.key);
          // Replace input with typed digit, or append if quick press?
          // For simplicity, set input to digit
          game.currentInput = digit;
          announceForA11y(`Answer set to ${game.currentInput}`);
        } else if (e.key === '-') {
          game.currentInput = -Math.abs(game.currentInput || 0);
          announceForA11y(`Answer set to ${game.currentInput}`);
        }
    }
    // allow enabling audio with any keyboard gesture
    if (!audioAllowed) {
      tryEnableAudio();
    }
  });

  function restartGame() {
    // Reset game state
    Object.assign(game, new Game());
  }

  // Drawing utilities
  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  function drawGear(ctx, cx, cy, radius, teeth, angle, color, innerRadius = null) {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(angle);
    ctx.fillStyle = color;
    ctx.beginPath();
    const spikes = teeth * 2;
    const r0 = innerRadius || radius * 0.6;
    for (let i = 0; i < spikes; i++) {
      const a = (i / spikes) * Math.PI * 2;
      const r = i % 2 === 0 ? radius : r0;
      const x = Math.cos(a) * r;
      const y = Math.sin(a) * r;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fill();
    // center hole
    ctx.fillStyle = COLORS.shadow;
    ctx.beginPath();
    ctx.arc(0, 0, radius * 0.25, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  // Draw everything
  function render() {
    // background
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // top panel with title and speaker
    ctx.fillStyle = COLORS.panel;
    roundRect(ctx, 12, 12, WIDTH - 24, 72, 14);
    ctx.fillStyle = COLORS.text;
    ctx.font = 'bold 22px sans-serif';
    ctx.fillText('Machine Math: Fix the Wacky Machines!', 32, 46);
    ctx.font = '14px sans-serif';
    ctx.fillStyle = '#2B4B56';
    ctx.fillText('Theme: Machines — Solve the problem, feed the machine correct bolts!', 32, 66);

    // speaker icon visual
    drawSpeaker(660, 26);

    // left control panel: plus/minus big buttons
    ctx.fillStyle = COLORS.machine;
    roundRect(ctx, 16, 220, 144, 198, 12);
    ctx.fillStyle = '#123';
    ctx.font = 'bold 20px sans-serif';
    ctx.fillText('Adjust', 36, 252);
    // plus area
    ctx.fillStyle = '#F8FBFB';
    roundRect(ctx, 28, 280, 120, 60, 10);
    ctx.fillStyle = COLORS.accent;
    ctx.fillRect(32, 290, 44, 40);
    ctx.fillStyle = COLORS.panel;
    ctx.fillRect(84, 290, 44, 40);
    // plus/minus text
    ctx.fillStyle = '#fff';
    ctx.font = '28px sans-serif';
    ctx.fillText('+', 46, 320);
    ctx.fillText('-', 98, 320);
    ctx.font = '14px sans-serif';
    ctx.fillStyle = '#123';
    ctx.fillText('Top area adds, bottom subtracts', 26, 365);

    // machine body center
    drawMachineBody();

    // right control panel
    ctx.fillStyle = COLORS.machine;
    roundRect(ctx, 520, 120, 184, 280, 12);
    ctx.fillStyle = '#123';
    ctx.font = 'bold 18px sans-serif';
    ctx.fillText('Controls', 548, 150);

    // Hint button
    ctx.fillStyle = '#F0F6F6';
    roundRect(ctx, 538, 185, 150, 42, 8);
    ctx.fillStyle = COLORS.accent;
    ctx.font = '16px sans-serif';
    ctx.fillText('Hint (H key)', 572, 212);
    // hint availability
    ctx.font = '12px sans-serif';
    ctx.fillStyle = '#345';
    ctx.fillText(`Hints used: ${game.hintsUsed}/${game.maxHints}`, 548, 235);

    // Submit button
    ctx.fillStyle = game.isAnimating ? '#DDD' : '#FFF';
    roundRect(ctx, 538, 320, 150, 42, 8);
    ctx.fillStyle = game.isAnimating ? '#9AA' : COLORS.bolt;
    ctx.fillRect(568, 330, 90, 24);
    ctx.fillStyle = '#123';
    ctx.font = '16px sans-serif';
    ctx.fillText('Submit (Enter)', 568, 347);

    // Score and round
    ctx.fillStyle = COLORS.text;
    ctx.font = 'bold 16px sans-serif';
    ctx.fillText(`Round ${game.roundIndex + 1}/${TOTAL_ROUNDS}`, 548, 270);
    ctx.fillText(`Score: ${game.score}`, 548, 292);

    // bottom instructions
    ctx.font = '12px sans-serif';
    ctx.fillStyle = '#2B4B56';
    ctx.fillText('Keys: ← → adjust  Enter submit  H hint  M mute', 22, HEIGHT - 14);

    // small visualizer for audio near speaker
    drawAudioVisualizer(620, 8);

    // outcome flash
    if (game.flashTimer > 0) {
      const t = game.flashTimer / 18;
      ctx.fillStyle = `rgba(255,100,100,${0.12 * t})`;
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
    }

    // If finished, show final screen overlay
    if (game.finish) {
      ctx.fillStyle = 'rgba(10,10,10,0.45)';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 30px sans-serif';
      ctx.fillText('Machine Master!', 240, 210);
      ctx.font = '18px sans-serif';
      ctx.fillText(`You scored ${game.score} out of ${TOTAL_ROUNDS}`, 230, 245);
      ctx.font = '14px sans-serif';
      ctx.fillText('Press Enter to play again', 270, 285);
      return;
    }
  }

  function drawSpeaker(x, y) {
    ctx.save();
    ctx.translate(x, y);
    // speaker box
    ctx.fillStyle = '#fff';
    ctx.strokeStyle = COLORS.shadow;
    ctx.lineWidth = 1;
    roundRect(ctx, -20, -12, 36, 24, 4);
    // cone
    ctx.beginPath();
    ctx.moveTo(-22, 6);
    ctx.lineTo(-8, 0);
    ctx.lineTo(-8, -6);
    ctx.closePath();
    ctx.fillStyle = COLORS.accent;
    ctx.fill();
    // sound waves if audioAllowed
    ctx.strokeStyle = audioAllowed ? COLORS.bolt : '#AAA';
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.arc(6, 0, 8 + i * 6, -0.3, 0.3);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawAudioVisualizer(x, y) {
    // small bars that respond to background hum amplitude
    ctx.save();
    ctx.translate(x, y + 30);
    const bars = 4;
    for (let i = 0; i < bars; i++) {
      const h = audioAllowed ? 6 + Math.abs(Math.sin((Date.now() / 400) + i)) * 20 : 6;
      ctx.fillStyle = audioAllowed ? COLORS.accent : '#CCC';
      roundRect(ctx, i * 6, -h, 4, h, 1);
    }
    ctx.restore();
  }

  function drawMachineBody() {
    // machine chassis
    ctx.fillStyle = COLORS.machine;
    roundRect(ctx, 180, 120, 340, 300, 18);
    // intake window
    ctx.fillStyle = '#F7FFFF';
    roundRect(ctx, 200, 150, 300, 140, 12);
    // show problem big
    ctx.fillStyle = COLORS.text;
    ctx.font = 'bold 34px sans-serif';
    const problemText = `${game.round.a} ${game.round.op} ${game.round.b} = ?`;
    const measure = ctx.measureText(problemText);
    ctx.fillText(problemText, 200 + (300 - measure.width) / 2, 190);

    // display current input with box
    ctx.fillStyle = '#EAF6F3';
    roundRect(ctx, 260, 200, 180, 70, 10);
    ctx.fillStyle = COLORS.text;
    ctx.font = 'bold 36px monospace';
    const inputStr = String(game.currentInput);
    const txtw = ctx.measureText(inputStr).width;
    ctx.fillText(inputStr, 260 + (180 - txtw) / 2, 245);

    // small info about tries
    ctx.font = '12px sans-serif';
    ctx.fillStyle = '#2B4B56';
    ctx.fillText(`Tries: ${game.triesUsed}/${game.round.maxTries}`, 260, 275);

    // draw gears with rotation
    const gearX = 240;
    const gearY = 320;
    game.gearAngle += 0.02 + (game.lastOutcome === 'correct' ? 0.08 : 0);
    drawGear(ctx, gearX, gearY, 36, 10, game.gearAngle, '#B6D0D3');
    drawGear(ctx, gearX + 140, gearY - 10, 26, 8, -game.gearAngle * 1.4, '#AECBD2');

    // conveyor belt showing bolts equal to absolute(answer) as small circles
    const boltCount = clamp(Math.abs(game.round.answer), 0, 12);
    drawConveyor(ctx, 230, 360, 260, 48, boltCount);

    // animation: if correct, bolts eject confetti
    if (game.lastOutcome === 'correct') {
      // animate bolts being ejected — simple expanding rings
      if (game.animationTimer < 60) {
        // show expanding bolt flashes
        for (let i = 0; i < 8; i++) {
          const t = (game.animationTimer / 60) + (i / 8);
          const alpha = Math.max(0, 1 - t);
          ctx.beginPath();
          ctx.fillStyle = `rgba(242,177,52,${alpha})`;
          const rx = 360 + Math.cos(i / 8 * Math.PI * 2) * (40 * t);
          const ry = 310 + Math.sin(i / 8 * Math.PI * 2) * (20 * t);
          ctx.arc(rx, ry, 6 + 8 * t, 0, Math.PI * 2);
          ctx.fill();
        }
      } else {
        // after animation, progress to next round
        game.boltsEjected = boltCount;
        setTimeout(() => {
          game.isAnimating = false;
          game.lastOutcome = null;
          game.nextRound();
        }, 300);
      }
    }
  }

  function drawConveyor(ctx, x, y, w, h, boltCount) {
    // belt background
    ctx.fillStyle = '#E3EEF1';
    roundRect(ctx, x, y, w, h, 12);
    // belt pattern
    ctx.fillStyle = '#D6E9EA';
    for (let i = 0; i < 10; i++) {
      ctx.fillRect(x + i * (w / 10), y + h / 2 - 3, w / 15, 6);
    }
    // bolts placed evenly
    const c = boltCount;
    const spacing = c > 0 ? w / c : w;
    for (let i = 0; i < c; i++) {
      const cx = x + spacing * (i + 0.5);
      const cy = y + h / 2;
      ctx.beginPath();
      ctx.fillStyle = COLORS.bolt;
      ctx.arc(cx, cy, 12, 0, Math.PI * 2);
      ctx.fill();
      // shine
      ctx.beginPath();
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.arc(cx - 4, cy - 4, 3, 0, Math.PI * 2);
      ctx.fill();
      // small nut hole
      ctx.beginPath();
      ctx.fillStyle = COLORS.shadow;
      ctx.arc(cx, cy, 4, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Game update loop
  let lastTs = 0;
  function loop(ts) {
    const dt = ts - lastTs;
    lastTs = ts;
    // update timers
    if (game.flashTimer > 0) game.flashTimer = Math.max(0, game.flashTimer - 1);
    if (game.isAnimating) game.animationTimer += dt / 16;
    // draw everything
    render();
    requestAnimationFrame(loop);
  }

  // Kick off loop
  requestAnimationFrame(loop);

  // Informational announce
  announceForA11y(
    'Welcome to Machine Math. Use left and right arrow keys to change your answer, Enter to submit, H for hint, M to toggle sound.'
  );

  // Error handling: ensure audio context setup on user gesture attempts to start
  // Also show a subtle tooltip if audio not available
  function showAudioStatus() {
    // Draw a small note on canvas if audio not available
    if (!audioCtx) {
      // add a subtle instruction
      ctx.save();
      ctx.fillStyle = 'rgba(20,20,20,0.06)';
      ctx.fillRect(12, HEIGHT - 68, 260, 48);
      ctx.fillStyle = '#123';
      ctx.font = '12px sans-serif';
      ctx.fillText('Audio not yet enabled. Click the speaker or press M to enable sounds.', 24, HEIGHT - 42);
      ctx.restore();
    }
  }

  // Periodically check audio state to update visualization and messages
  setInterval(() => {
    if (!audioCtx && audioAllowed) {
      // try init again
      initAudioContext();
    }
    // small status
    showAudioStatus();
  }, 1000);

  // Initial draw call to ensure canvas isn't blank
  render();

  // Final note to console
  console.log('Machine Math game initialized. Controls: Arrow keys, Enter, H, M.');

})();
---

