{
  "generated_date": "2025-08-27",
  "generated_timestamp": "2025-08-27T21:27:28.070547",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 10565,
  "game_filename": "2025-08-27.js",
  "game_size_bytes": 34379,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function() {\n  // Machine Match - A calming, wacky, educational math game for ages 7-9\n  // Renders inside the element with ID \"game-of-the-day-stage\"\n  // All visuals drawn on a 720x480 canvas. Sounds generated via Web Audio API.\n  // Accessible controls: mouse/touch/keyboard. Includes audio toggle and text instructions.\n\n  // ------------------------------\n  // Initialization & Setup\n  // ------------------------------\n  const STAGE_ID = 'game-of-the-day-stage';\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const SLOT_COUNT = 3; // number of slots to fill each round\n  const TOTAL_LEVELS = 5;\n\n  const stage = document.getElementById(STAGE_ID);\n  if (!stage) {\n    console.error('Game stage element not found:', STAGE_ID);\n    return;\n  }\n  // Clear stage and create canvas\n  stage.innerHTML = '';\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.tabIndex = 0; // make focusable for keyboard\n  canvas.setAttribute('role', 'application');\n  canvas.setAttribute('aria-label', 'Machine Match math game. Use mouse or keyboard to play.');\n  stage.appendChild(canvas);\n\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    console.error('Unable to get 2D context');\n    return;\n  }\n\n  // Accessibility text fallback: if canvas isn't available, show message\n  if (!canvas.getContext) {\n    stage.textContent = 'Your browser does not support canvas. Please use a modern browser to play this game.';\n    return;\n  }\n\n  // ------------------------------\n  // Audio setup with error handling\n  // ------------------------------\n  let audioCtx = null;\n  let audioAllowed = false; // toggled by user\n  let backgroundGain = null;\n  let backgroundOsc = null;\n\n  function safeCreateAudioContext() {\n    if (audioCtx) return audioCtx;\n    try {\n      const AC = window.AudioContext || window.webkitAudioContext;\n      if (!AC) {\n        console.warn('Web Audio API not supported in this browser.');\n        return null;\n      }\n      audioCtx = new AC();\n      return audioCtx;\n    } catch (e) {\n      console.warn('Error creating AudioContext:', e);\n      audioCtx = null;\n      return null;\n    }\n  }\n\n  // Called after a user gesture to initialize audio\n  function initAudioOnGesture() {\n    if (audioAllowed) return;\n    const ac = safeCreateAudioContext();\n    if (!ac) return;\n    try {\n      // create a soft ambient hum\n      backgroundOsc = ac.createOscillator();\n      backgroundGain = ac.createGain();\n      backgroundOsc.type = 'sine';\n      backgroundOsc.frequency.value = 80; // low rumble\n      backgroundGain.gain.value = 0; // start muted until toggled\n      backgroundOsc.connect(backgroundGain);\n      backgroundGain.connect(ac.destination);\n      backgroundOsc.start(0);\n      audioAllowed = true;\n    } catch (e) {\n      console.warn('Error initializing background audio:', e);\n      audioAllowed = false;\n    }\n  }\n\n  // Sound helpers\n  function playTone({ frequency = 440, duration = 0.25, type = 'sine', volume = 0.08, attack = 0.01, decay = 0.2 }) {\n    const ac = audioCtx;\n    if (!ac || !audioAllowed) return;\n    try {\n      const o = ac.createOscillator();\n      const g = ac.createGain();\n      const filt = ac.createBiquadFilter();\n      o.type = type;\n      o.frequency.value = frequency;\n      filt.type = 'lowpass';\n      filt.frequency.value = Math.max(800, frequency * 2);\n      g.gain.value = 0;\n      o.connect(filt);\n      filt.connect(g);\n      g.connect(ac.destination);\n      const now = ac.currentTime;\n      g.gain.cancelScheduledValues(now);\n      g.gain.setValueAtTime(0, now);\n      g.gain.linearRampToValueAtTime(volume, now + attack);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);\n      o.start(now);\n      o.stop(now + duration + 0.05);\n    } catch (e) {\n      console.warn('Error playing tone:', e);\n    }\n  }\n\n  function playCorrectTone() {\n    playTone({ frequency: 880, duration: 0.35, type: 'triangle', volume: 0.12, attack: 0.01 });\n    // small celebratory arpeggio\n    setTimeout(() => playTone({ frequency: 1320, duration: 0.18, type: 'sine', volume: 0.09 }), 120);\n    setTimeout(() => playTone({ frequency: 1760, duration: 0.14, type: 'sine', volume: 0.08 }), 260);\n  }\n  function playIncorrectTone() {\n    playTone({ frequency: 220, duration: 0.35, type: 'sawtooth', volume: 0.08, attack: 0.01 });\n    setTimeout(() => playTone({ frequency: 180, duration: 0.24, type: 'sawtooth', volume: 0.06 }), 120);\n  }\n  function playClick() {\n    playTone({ frequency: 600, duration: 0.08, type: 'square', volume: 0.05, attack: 0.005 });\n  }\n\n  // Toggle ambient background on/off (visual cue drawn on canvas)\n  let backgroundOn = false;\n  function setBackgroundOn(on) {\n    const ac = audioCtx;\n    backgroundOn = !!on;\n    if (!ac || !backgroundGain) return;\n    try {\n      if (backgroundOn) {\n        // fade in very gently\n        backgroundGain.gain.cancelScheduledValues(ac.currentTime);\n        backgroundGain.gain.setValueAtTime(0, ac.currentTime);\n        backgroundGain.gain.linearRampToValueAtTime(0.02, ac.currentTime + 1.2);\n      } else {\n        backgroundGain.gain.cancelScheduledValues(ac.currentTime);\n        backgroundGain.gain.linearRampToValueAtTime(0, ac.currentTime + 0.6);\n      }\n    } catch (e) {\n      console.warn('Error toggling background:', e);\n    }\n  }\n\n  // ------------------------------\n  // Game state & logic\n  // ------------------------------\n  let level = 1;\n  let targetSum = 0;\n  let parts = []; // moving parts on conveyor\n  let slots = new Array(SLOT_COUNT).fill(null); // placed parts or null\n  let conveyorOffset = 0; // animation offset\n  let selectedPartIndex = 0; // index of currently highlighted part\n  let dragging = null; // {partIndex, offsetX, offsetY} or null\n  let animationId = null;\n  let message = 'Welcome! Press SPACE or click parts to place them in the machine.';\n  let successFlash = 0;\n  let attemptsThisLevel = 0;\n  let finished = false;\n\n  // Colors (calming palette)\n  const palette = {\n    bg: '#eaf2f1',\n    panel: '#ffffff',\n    accent: '#6aa6a7',\n    accent2: '#f7b267',\n    gear: '#c7e9e6',\n    text: '#163b36',\n    part: '#f2d8b6',\n    wrong: '#ff9b9b',\n    slotBg: '#f6f8f8'\n  };\n\n  // Utility: random integer\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  // Generate parts for level\n  function generatePartsForLevel(lv) {\n    const count = 6; // number of moving parts visible\n    let maxValue = 8 + lv * 2;\n    maxValue = Math.min(maxValue, 12);\n    const arr = [];\n    for (let i = 0; i < count; i++) {\n      arr.push({\n        value: randInt(1, maxValue),\n        wobble: Math.random() * Math.PI * 2,\n        id: Math.random().toString(36).slice(2),\n      });\n    }\n    return arr;\n  }\n\n  function computeTargetForLevel(lv) {\n    // target increases per level and is achievable by combination of SLOT_COUNT numbers from parts pool\n    // We'll craft a target between SLOT_COUNT*2 and SLOT_COUNT*10 influenced by level\n    const base = SLOT_COUNT * 2 + (lv - 1) * 3;\n    return Math.max(base, SLOT_COUNT * 3);\n  }\n\n  // Initialize a new level\n  function startLevel(lv) {\n    level = lv;\n    finished = false;\n    attemptsThisLevel = 0;\n    targetSum = computeTargetForLevel(level);\n    parts = generatePartsForLevel(level);\n    // Ensure at least one valid combination exists: adjust one part\n    // Create combination that sums to target using SLOT_COUNT random parts and set their values accordingly\n    const combo = [];\n    let remaining = targetSum;\n    for (let i = 0; i < SLOT_COUNT; i++) {\n      const remainingSlots = SLOT_COUNT - i;\n      const maxForSlot = Math.max(1, Math.min(12, Math.floor(remaining / remainingSlots * 1.3)));\n      const minForSlot = Math.max(1, Math.floor(remaining / remainingSlots * 0.6));\n      const val = i === SLOT_COUNT - 1 ? remaining : randInt(minForSlot, maxForSlot);\n      combo.push(val);\n      remaining -= val;\n    }\n    // Place combo values into some parts indices to ensure solvable\n    for (let i = 0; i < combo.length; i++) {\n      parts[i].value = combo[i];\n    }\n    // Shuffle parts a bit\n    for (let i = parts.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [parts[i], parts[j]] = [parts[j], parts[i]];\n    }\n    // Reset slots and state\n    slots = new Array(SLOT_COUNT).fill(null);\n    conveyorOffset = 0;\n    selectedPartIndex = 0;\n    message = 'Place ' + SLOT_COUNT + ' parts whose numbers add up to ' + targetSum + '. Use mouse or keyboard.';\n  }\n\n  // Check whether the placed slots are correct\n  function checkSlots() {\n    const filled = slots.every(s => s !== null);\n    if (!filled) {\n      message = `Fill all ${SLOT_COUNT} slots, then press Check (Enter) or it will auto-check.`;\n      return false;\n    }\n    const sum = slots.reduce((acc, s) => acc + s.value, 0);\n    attemptsThisLevel++;\n    if (sum === targetSum) {\n      playCorrectTone();\n      successFlash = 40;\n      message = 'Nice! The machine hums happily. Press Next to continue.';\n      return true;\n    } else {\n      playIncorrectTone();\n      message = `That totals ${sum}. Try again to reach ${targetSum}.`;\n      return false;\n    }\n  }\n\n  // Place a part into the next empty slot (by index)\n  function placePartToSlot(partIndex) {\n    if (finished) return;\n    if (!parts[partIndex]) return;\n    const nextSlot = slots.findIndex(s => s === null);\n    if (nextSlot === -1) {\n      message = 'All slots are full. Press Enter to check or remove a part.';\n      playClick();\n      return;\n    }\n    // Move part value into slot and mark part as used\n    slots[nextSlot] = { ...parts[partIndex] }; // copy\n    parts.splice(partIndex, 1); // remove from conveyor\n    // Ensure selectedPartIndex stays in bounds\n    if (selectedPartIndex >= parts.length) selectedPartIndex = Math.max(0, parts.length - 1);\n    playClick();\n    message = 'Placed a part. Press Enter to check or continue placing.';\n    // Auto-check if all slots filled\n    if (slots.every(s => s !== null)) {\n      const ok = checkSlots();\n      if (ok) {\n        // progress to next or finish after a short delay\n        setTimeout(() => {\n          if (level >= TOTAL_LEVELS) {\n            finished = true;\n            message = 'You repaired all machines! You WIN! Press R to play again.';\n          } else {\n            startLevel(level + 1);\n          }\n        }, 900);\n      } else {\n        // allow retry: return parts from slots into conveyor with slight shuffle\n        setTimeout(() => {\n          // return slot parts to end of parts array (but only if parts array isn't huge)\n          const returned = slots.map(s => s && { value: s.value, wobble: Math.random() * Math.PI * 2, id: Math.random().toString(36).slice(2) }).filter(Boolean);\n          parts = parts.concat(returned);\n          slots = new Array(SLOT_COUNT).fill(null);\n        }, 700);\n      }\n    }\n  }\n\n  // Remove a slot (like undo) by index\n  function removeSlot(slotIndex) {\n    if (slotIndex < 0 || slotIndex >= slots.length || !slots[slotIndex]) {\n      message = 'That slot is empty.';\n      return;\n    }\n    // return the part to the end of parts array\n    parts.push({ value: slots[slotIndex].value, wobble: Math.random() * Math.PI * 2, id: Math.random().toString(36).slice(2) });\n    slots[slotIndex] = null;\n    playClick();\n    message = 'Removed a part from the machine.';\n  }\n\n  // Restart game\n  function restartGame() {\n    level = 1;\n    startLevel(1);\n    finished = false;\n    playClick();\n  }\n\n  // ------------------------------\n  // Input handling (mouse, touch, keyboard)\n  // ------------------------------\n  // Convert client coordinates to canvas coordinates\n  function toCanvasCoord(clientX, clientY) {\n    const rect = canvas.getBoundingClientRect();\n    const x = (clientX - rect.left) * (canvas.width / rect.width);\n    const y = (clientY - rect.top) * (canvas.height / rect.height);\n    return { x, y };\n  }\n\n  // Hit testing for parts drawn on conveyor\n  function hitTestPart(x, y) {\n    // parts drawn along a conveyor at y ~ 360 and spaced horizontally\n    const conveyorY = 360;\n    const spacing = 92;\n    const startX = 100;\n    for (let i = 0; i < parts.length; i++) {\n      const px = startX + i * spacing - conveyorOffset % (spacing * parts.length);\n      const py = conveyorY + Math.sin(parts[i].wobble + Date.now() / 800) * 6;\n      const dx = x - px;\n      const dy = y - py;\n      if (Math.sqrt(dx * dx + dy * dy) < 36) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  // Hit testing for slots\n  function hitTestSlot(x, y) {\n    const slotY = 200;\n    const slotWidth = 84;\n    const slotSpacing = 112;\n    const startX = (WIDTH - ((SLOT_COUNT - 1) * slotSpacing + slotWidth)) / 2;\n    for (let i = 0; i < SLOT_COUNT; i++) {\n      const sx = startX + i * slotSpacing;\n      const sy = slotY;\n      if (x >= sx && x <= sx + slotWidth && y >= sy && y <= sy + 68) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  canvas.addEventListener('mousedown', (ev) => {\n    canvas.focus();\n    initAudioOnGesture(); // ensure audio context created after gesture\n    const pos = toCanvasCoord(ev.clientX, ev.clientY);\n    const pi = hitTestPart(pos.x, pos.y);\n    if (pi >= 0) {\n      // start dragging\n      const conveyorY = 360;\n      const spacing = 92;\n      const startX = 100;\n      const px = startX + pi * spacing - conveyorOffset % (spacing * parts.length);\n      const py = conveyorY + Math.sin(parts[pi].wobble + Date.now() / 800) * 6;\n      dragging = {\n        partIndex: pi,\n        offsetX: pos.x - px,\n        offsetY: pos.y - py\n      };\n      selectedPartIndex = pi;\n      playClick();\n    } else {\n      // check if clicked on audio toggle or next button area or retry area\n      handleUIClick(pos.x, pos.y);\n    }\n  });\n\n  canvas.addEventListener('mousemove', (ev) => {\n    if (!dragging) return;\n    const pos = toCanvasCoord(ev.clientX, ev.clientY);\n    // update dragging visuals by setting a temporary \"drag position\" on a virtual copy of part\n    // We'll store dragPos inside dragging for rendering\n    dragging.dragPos = { x: pos.x - dragging.offsetX + 0, y: pos.y - dragging.offsetY + 0 };\n  });\n\n  window.addEventListener('mouseup', (ev) => {\n    if (!dragging) return;\n    const pos = toCanvasCoord(ev.clientX, ev.clientY);\n    const slotIndex = hitTestSlot(pos.x, pos.y);\n    const originalIndex = dragging.partIndex;\n    // Because parts array might have shifted due to clicks, we find target part by ID if possible\n    const draggedId = parts[originalIndex] ? parts[originalIndex].id : null;\n    const actualIndex = parts.findIndex(p => p.id === draggedId);\n    if (slotIndex >= 0 && actualIndex >= 0) {\n      // place into slot\n      // remove from parts and place into slots\n      slots[slotIndex] = { ...parts[actualIndex] };\n      parts.splice(actualIndex, 1);\n      selectedPartIndex = Math.max(0, Math.min(parts.length - 1, actualIndex));\n      playClick();\n      message = 'Placed a part into slot ' + (slotIndex + 1) + '.';\n      // auto-check if full\n      if (slots.every(s => s !== null)) {\n        const ok = checkSlots();\n        if (ok) {\n          setTimeout(() => {\n            if (level >= TOTAL_LEVELS) {\n              finished = true;\n              message = 'You repaired all machines! You WIN! Press R to play again.';\n            } else {\n              startLevel(level + 1);\n            }\n          }, 900);\n        } else {\n          setTimeout(() => {\n            const returned = slots.map(s => s && { value: s.value, wobble: Math.random() * Math.PI * 2, id: Math.random().toString(36).slice(2) }).filter(Boolean);\n            parts = parts.concat(returned);\n            slots = new Array(SLOT_COUNT).fill(null);\n          }, 700);\n        }\n      }\n    } else {\n      // not dropped on slot: just cancel drag\n      message = 'Dropped the part. Click or press SPACE on a part to place it into the next slot.';\n    }\n    dragging = null;\n  });\n\n  // Touch support\n  canvas.addEventListener('touchstart', (ev) => {\n    ev.preventDefault();\n    canvas.focus();\n    initAudioOnGesture();\n    const touch = ev.changedTouches[0];\n    const pos = toCanvasCoord(touch.clientX, touch.clientY);\n    const pi = hitTestPart(pos.x, pos.y);\n    if (pi >= 0) {\n      dragging = {\n        partIndex: pi,\n        offsetX: 0,\n        offsetY: 0\n      };\n      selectedPartIndex = pi;\n      playClick();\n    } else {\n      handleUIClick(pos.x, pos.y);\n    }\n  }, { passive: false });\n\n  canvas.addEventListener('touchmove', (ev) => {\n    ev.preventDefault();\n    if (!dragging) return;\n    const touch = ev.changedTouches[0];\n    const pos = toCanvasCoord(touch.clientX, touch.clientY);\n    dragging.dragPos = { x: pos.x - dragging.offsetX, y: pos.y - dragging.offsetY };\n  }, { passive: false });\n\n  canvas.addEventListener('touchend', (ev) => {\n    ev.preventDefault();\n    if (!dragging) return;\n    const touch = ev.changedTouches[0];\n    const pos = toCanvasCoord(touch.clientX, touch.clientY);\n    const slotIndex = hitTestSlot(pos.x, pos.y);\n    const originalIndex = dragging.partIndex;\n    const draggedId = parts[originalIndex] ? parts[originalIndex].id : null;\n    const actualIndex = parts.findIndex(p => p.id === draggedId);\n    if (slotIndex >= 0 && actualIndex >= 0) {\n      slots[slotIndex] = { ...parts[actualIndex] };\n      parts.splice(actualIndex, 1);\n      playClick();\n      message = 'Placed a part into slot ' + (slotIndex + 1) + '.';\n      if (slots.every(s => s !== null)) {\n        const ok = checkSlots();\n        if (ok) {\n          setTimeout(() => {\n            if (level >= TOTAL_LEVELS) {\n              finished = true;\n              message = 'You repaired all machines! You WIN! Press R to play again.';\n            } else {\n              startLevel(level + 1);\n            }\n          }, 900);\n        } else {\n          setTimeout(() => {\n            const returned = slots.map(s => s && { value: s.value, wobble: Math.random() * Math.PI * 2, id: Math.random().toString(36).slice(2) }).filter(Boolean);\n            parts = parts.concat(returned);\n            slots = new Array(SLOT_COUNT).fill(null);\n          }, 700);\n        }\n      }\n    } else {\n      message = 'Dropped the part.';\n    }\n    dragging = null;\n  }, { passive: false });\n\n  // Keyboard controls\n  canvas.addEventListener('keydown', (ev) => {\n    initAudioOnGesture();\n    if (ev.key === 'ArrowRight') {\n      selectedPartIndex = Math.min(parts.length - 1, selectedPartIndex + 1);\n      playClick();\n      ev.preventDefault();\n    } else if (ev.key === 'ArrowLeft') {\n      selectedPartIndex = Math.max(0, selectedPartIndex - 1);\n      playClick();\n      ev.preventDefault();\n    } else if (ev.key === ' ' || ev.key === 'Enter') {\n      // Place selected part into next slot, or check if Enter used for checking when all slots filled\n      if (ev.key === 'Enter' && slots.every(s => s !== null)) {\n        // Check slots\n        const ok = checkSlots();\n        if (ok) {\n          setTimeout(() => {\n            if (level >= TOTAL_LEVELS) {\n              finished = true;\n              message = 'You repaired all machines! You WIN! Press R to play again.';\n            } else {\n              startLevel(level + 1);\n            }\n          }, 900);\n        } else {\n          setTimeout(() => {\n            const returned = slots.map(s => s && { value: s.value, wobble: Math.random() * Math.PI * 2, id: Math.random().toString(36).slice(2) }).filter(Boolean);\n            parts = parts.concat(returned);\n            slots = new Array(SLOT_COUNT).fill(null);\n          }, 700);\n        }\n      } else {\n        // place\n        if (parts[selectedPartIndex]) {\n          placePartToSlot(selectedPartIndex);\n        } else {\n          message = 'No part selected.';\n        }\n      }\n      ev.preventDefault();\n    } else if (ev.key === 'Backspace' || ev.key === 'Delete') {\n      // remove last filled slot\n      const lastFilled = slots.map((s, i) => s ? i : -1).filter(i => i >= 0).pop();\n      if (lastFilled !== undefined && lastFilled >= 0) {\n        removeSlot(lastFilled);\n      } else {\n        message = 'No parts to remove.';\n      }\n      ev.preventDefault();\n    } else if (ev.key.toLowerCase() === 'r') {\n      restartGame();\n      ev.preventDefault();\n    } else if (ev.key.toLowerCase() === 'm') {\n      // toggle background\n      setBackgroundOn(!backgroundOn);\n      playClick();\n      ev.preventDefault();\n    } else if (ev.key === 'Tab') {\n      // cycle selection\n      selectedPartIndex = (selectedPartIndex + 1) % Math.max(1, parts.length);\n      ev.preventDefault();\n    }\n  });\n\n  // Clicking UI controls like audio toggle area\n  function handleUIClick(x, y) {\n    // audio toggle is top-right small box\n    const audioBox = { x: WIDTH - 72, y: 12, w: 60, h: 28 };\n    if (x >= audioBox.x && x <= audioBox.x + audioBox.w && y >= audioBox.y && y <= audioBox.y + audioBox.h) {\n      // Toggle audio: if audio not yet created, create it (user gesture)\n      initAudioOnGesture();\n      if (!audioCtx) {\n        message = 'Audio unavailable in this browser.';\n        return;\n      }\n      // If background oscillator hasn't started or audioAllowed false, set on\n      if (!audioAllowed) {\n        audioAllowed = true;\n      }\n      setBackgroundOn(!backgroundOn);\n      playClick();\n      return;\n    }\n    // Next/Restart area near bottom right\n    const actionBox = { x: WIDTH - 140, y: HEIGHT - 62, w: 120, h: 44 };\n    if (x >= actionBox.x && x <= actionBox.x + actionBox.w && y >= actionBox.y && y <= actionBox.y + actionBox.h) {\n      if (finished) {\n        restartGame();\n      } else {\n        // If current round is complete (all slots filled and correct) progress; else check\n        if (slots.every(s => s !== null) && slots.reduce((a, b) => a + b.value, 0) === targetSum) {\n          if (level >= TOTAL_LEVELS) {\n            finished = true;\n            message = 'You repaired all machines! You WIN! Press R to play again.';\n          } else {\n            startLevel(level + 1);\n          }\n        } else {\n          const ok = checkSlots();\n          if (ok) {\n            if (level >= TOTAL_LEVELS) {\n              finished = true;\n              message = 'You repaired all machines! You WIN! Press R to play again.';\n            } else {\n              startLevel(level + 1);\n            }\n          } else {\n            // return parts\n            setTimeout(() => {\n              const returned = slots.map(s => s && { value: s.value, wobble: Math.random() * Math.PI * 2, id: Math.random().toString(36).slice(2) }).filter(Boolean);\n              parts = parts.concat(returned);\n              slots = new Array(SLOT_COUNT).fill(null);\n            }, 700);\n          }\n        }\n      }\n      playClick();\n      return;\n    }\n    // If clicked on a slot, remove it\n    const slotIndex = hitTestSlot(x, y);\n    if (slotIndex >= 0 && slots[slotIndex]) {\n      removeSlot(slotIndex);\n      return;\n    }\n  }\n\n  // ------------------------------\n  // Rendering functions\n  // ------------------------------\n  function drawRoundedRect(x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function drawScene() {\n    // background\n    ctx.fillStyle = palette.bg;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // top panel with title\n    ctx.fillStyle = palette.panel;\n    drawRoundedRect(12, 12, WIDTH - 24, 68, 12);\n    ctx.fillStyle = palette.text;\n    ctx.font = '20px system-ui, Arial';\n    ctx.textBaseline = 'middle';\n    ctx.fillText('Machine Match \u2022 Fix the Wacky Machine', 28, 40);\n    ctx.font = '13px system-ui, Arial';\n    ctx.fillStyle = '#536b69';\n    ctx.fillText('Place parts so their numbers add to the target. Use mouse/touch or keyboard.', 28, 58);\n\n    // audio toggle button (visual cue)\n    const audioBox = { x: WIDTH - 72, y: 12, w: 60, h: 28 };\n    ctx.fillStyle = audioAllowed ? (backgroundOn ? palette.accent : '#a7d3d2') : '#dfecec';\n    drawRoundedRect(audioBox.x, audioBox.y, audioBox.w, audioBox.h, 8);\n    ctx.fillStyle = palette.text;\n    ctx.font = '12px system-ui, Arial';\n    ctx.fillText(backgroundOn ? 'Sound: ON' : 'Sound: Off', audioBox.x + 8, audioBox.y + 17);\n\n    // left panel with whimsical machine illustration\n    const panelX = 24;\n    const panelY = 96;\n    const panelW = WIDTH - 48;\n    const panelH = 280;\n    ctx.fillStyle = palette.panel;\n    drawRoundedRect(panelX, panelY, panelW, panelH, 14);\n\n    // Draw wacky machine elements: big gear, pipes, screen\n    drawMachine(panelX + 16, panelY + 20, panelW - 32, panelH - 40);\n\n    // Draw slots (machine input slots) above conveyor\n    drawSlots();\n\n    // Draw conveyor with parts\n    drawConveyor();\n\n    // Draw UI box bottom-right (Next/Check or Restart)\n    drawActionBox();\n\n    // Draw info overlay with target, level, message\n    ctx.fillStyle = 'rgba(255,255,255,0.8)';\n    ctx.font = '16px system-ui, Arial';\n    ctx.fillStyle = palette.text;\n    ctx.fillText('Level ' + level + ' / ' + TOTAL_LEVELS + '   Target: ' + targetSum, 28, HEIGHT - 36);\n    ctx.font = '13px system-ui, Arial';\n    ctx.fillStyle = '#395b59';\n    ctx.fillText(message, 28, HEIGHT - 18);\n\n    // subtle success flash\n    if (successFlash > 0) {\n      ctx.fillStyle = 'rgba(120,220,180,' + (successFlash / 60) + ')';\n      ctx.fillRect(0, 0, WIDTH, HEIGHT);\n      successFlash--;\n    }\n\n    // draw keyboard help\n    ctx.font = '11px system-ui, Arial';\n    ctx.fillStyle = '#567574';\n    ctx.fillText('Keys: \u2190 \u2192 select part \u2022 Space/Enter place \u2022 Delete remove \u2022 M toggle sound \u2022 R restart', WIDTH - 520, HEIGHT - 6);\n\n    // Visual indicator showing whether audio exists (for accessibility)\n    ctx.font = '11px system-ui, Arial';\n    ctx.fillStyle = '#3c6a65';\n    ctx.fillText('Audio: ' + (audioCtx ? 'Available' : 'Unavailable until you click'), WIDTH - 200, 30);\n  }\n\n  function drawMachine(x, y, w, h) {\n    // panel background inside machine\n    ctx.save();\n    ctx.translate(x, y);\n    // backdrop\n    ctx.fillStyle = '#f8fffe';\n    drawRoundedRect(0, 0, w, h, 12);\n\n    // big gear (left)\n    drawGear(72, 90, 60, 14, palette.gear, '#d0f0ee');\n\n    // small gear (upper right)\n    drawGear(w - 96, 60, 30, 8, palette.accent2, '#ffd9b3');\n\n    // silly machine screen (center)\n    ctx.fillStyle = '#164a46';\n    drawRoundedRect(150, 22, w - 320, 84, 10);\n    ctx.fillStyle = '#bfe6e2';\n    ctx.font = '20px system-ui, Arial';\n    ctx.fillText('Machine Monitor', 170, 46);\n    ctx.font = '28px system-ui, Arial';\n    ctx.fillStyle = '#08322f';\n    ctx.fillText('Target: ' + targetSum, 170, 76);\n\n    // connecting pipes\n    ctx.strokeStyle = '#cfe8e4';\n    ctx.lineWidth = 12;\n    ctx.lineCap = 'round';\n    ctx.beginPath();\n    ctx.moveTo(68, 150);\n    ctx.lineTo(68, 200);\n    ctx.lineTo(220, 200);\n    ctx.stroke();\n\n    ctx.beginPath();\n    ctx.moveTo(w - 60, 120);\n    ctx.quadraticCurveTo(w - 180, 180, w - 220, 230);\n    ctx.stroke();\n\n    // friendly face on one gear\n    ctx.fillStyle = '#08322f';\n    // eyes\n    ctx.beginPath();\n    ctx.arc(72, 90, 6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(92, 90, 6, 0, Math.PI * 2);\n    ctx.fill();\n    // smile\n    ctx.beginPath();\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = '#08322f';\n    ctx.arc(82, 100, 10, 0, Math.PI, false);\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  function drawGear(cx, cy, radius, teeth, color, innerColor) {\n    ctx.save();\n    ctx.translate(cx, cy);\n    // gear body\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    for (let i = 0; i < 40; i++) {\n      const theta = (i / 40) * Math.PI * 2;\n      const r = radius + (i % 4 === 0 ? 8 : 0);\n      const x = Math.cos(theta) * r;\n      const y = Math.sin(theta) * r;\n      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);\n    }\n    ctx.closePath();\n    ctx.fill();\n    // inner circle\n    ctx.fillStyle = innerColor;\n    ctx.beginPath();\n    ctx.arc(0, 0, radius * 0.5, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  function drawSlots() {\n    const slotY = 200;\n    const slotWidth = 84;\n    const slotHeight = 68;\n    const slotSpacing = 112;\n    const startX = (WIDTH - ((SLOT_COUNT - 1) * slotSpacing + slotWidth)) / 2;\n    // label\n    ctx.font = '14px system-ui, Arial';\n    ctx.fillStyle = '#2a5a57';\n    ctx.fillText('Machine Input Slots', startX, slotY - 22);\n\n    for (let i = 0; i < SLOT_COUNT; i++) {\n      const sx = startX + i * slotSpacing;\n      // slot background\n      ctx.fillStyle = slots[i] ? palette.accent : palette.slotBg;\n      drawRoundedRect(sx, slotY, slotWidth, slotHeight, 10);\n      // slot number\n      ctx.fillStyle = '#06403d';\n      ctx.font = '14px system-ui, Arial';\n      ctx.fillText('Slot ' + (i + 1), sx + 10, slotY + 20);\n      // display value if present\n      if (slots[i]) {\n        ctx.fillStyle = '#08322f';\n        ctx.font = '28px system-ui, Arial';\n        ctx.fillText(slots[i].value, sx + slotWidth / 2 - 8, slotY + slotHeight / 2 + 10);\n        // small remove hint\n        ctx.font = '11px system-ui, Arial';\n        ctx.fillStyle = '#144a47';\n        ctx.fillText('Click to remove', sx + 8, slotY + slotHeight - 8);\n      } else {\n        ctx.font = '12px system-ui, Arial';\n        ctx.fillStyle = '#2b6b68';\n        ctx.fillText('Empty', sx + 10, slotY + 40);\n      }\n    }\n  }\n\n  function drawConveyor() {\n    // conveyor belt\n    const convY = 360;\n    ctx.fillStyle = '#e6f6f4';\n    drawRoundedRect(40, convY - 36, WIDTH - 80, 80, 18);\n\n    // draw a subtle moving texture\n    ctx.save();\n    ctx.globalAlpha = 0.08;\n    ctx.fillStyle = '#9ad4cf';\n    for (let i = 0; i < 12; i++) {\n      ctx.beginPath();\n      ctx.arc(80 + i * 60 + (conveyorOffset / 6) % 60, convY, 24, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    ctx.restore();\n\n    // draw parts moving on conveyor\n    const spacing = 92;\n    const startX = 100;\n    for (let i = 0; i < parts.length; i++) {\n      const p = parts[i];\n      p.wobble += 0.005; // gentle motion\n      const px = startX + i * spacing - (conveyorOffset % (spacing * parts.length));\n      const py = convY + Math.sin(p.wobble + Date.now() / 800) * 6;\n      const isSelected = i === selectedPartIndex;\n      // if dragging and this is dragged part, skip drawing here (draw later)\n      if (dragging && dragging.partIndex === i) {\n        // skip here\n        continue;\n      }\n      drawPart(px, py, p, isSelected);\n    }\n\n    // if dragging, draw the dragged part under cursor\n    if (dragging && dragging.dragPos) {\n      const originalIndex = dragging.partIndex;\n      const draggedId = parts[originalIndex] ? parts[originalIndex].id : null;\n      const actualIndex = parts.findIndex(p => p.id === draggedId);\n      if (actualIndex >= 0) {\n        const p = parts[actualIndex];\n        drawPart(dragging.dragPos.x, dragging.dragPos.y, p, true, true);\n      }\n    }\n\n    // subtle label\n    ctx.fillStyle = '#2a5a57';\n    ctx.font = '13px system-ui, Arial';\n    ctx.fillText('Conveyor: Click or drag a part to the machine slots.', 44, convY - 44);\n  }\n\n  function drawPart(x, y, part, highlighted = false, translucent = false) {\n    ctx.save();\n    ctx.translate(x, y);\n    // shadow\n    ctx.fillStyle = 'rgba(20, 30, 28, 0.08)';\n    ctx.beginPath();\n    ctx.ellipse(0, 28, 38, 12, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // body\n    ctx.globalAlpha = translucent ? 0.9 : 1.0;\n    ctx.fillStyle = palette.part;\n    drawRoundedRect(-36, -20, 72, 48, 10);\n    // bolts and shapes\n    ctx.fillStyle = '#caa86d';\n    ctx.beginPath();\n    ctx.arc(-18, -6, 6, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(18, -6, 6, 0, Math.PI * 2);\n    ctx.fill();\n    // number\n    ctx.fillStyle = '#08322f';\n    ctx.font = highlighted ? '24px system-ui, Arial' : '20px system-ui, Arial';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(part.value, 0, 6);\n    // small wobble lines for wacky feeling\n    ctx.strokeStyle = 'rgba(4,95,90,0.06)';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(-30, 12);\n    ctx.quadraticCurveTo(0, 22, 30, 12);\n    ctx.stroke();\n    // selection glow\n    if (highlighted) {\n      ctx.strokeStyle = palette.accent;\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.rect(-38, -22, 76, 52);\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  function drawActionBox() {\n    const boxW = 120;\n    const boxH = 44;\n    const boxX = WIDTH - 140;\n    const boxY = HEIGHT - 62;\n    ctx.fillStyle = palette.accent;\n    drawRoundedRect(boxX, boxY, boxW, boxH, 10);\n    ctx.fillStyle = '#042d2a';\n    ctx.font = '16px system-ui, Arial';\n    ctx.fillText(finished ? 'Restart' : 'Check/Next', boxX + 12, boxY + boxH / 2 + 6);\n  }\n\n  // ------------------------------\n  // Animation loop\n  // ------------------------------\n  function step() {\n    // update conveyor offset\n    conveyorOffset += 0.5 + Math.sin(Date.now() / 1200) * 0.3;\n    drawScene();\n    animationId = requestAnimationFrame(step);\n  }\n\n  // ------------------------------\n  // Boot sequence\n  // ------------------------------\n  // Create audio context after a user gesture; but create attempt now too (may be blocked)\n  safeCreateAudioContext();\n\n  // Start first level\n  startLevel(1);\n  // Kick off animation\n  step();\n\n  // Start background engine only after user toggles sound or interacts (gesture)\n  // We'll show instructions to press M to toggle sound. But also ensure clicking canvas initializes audio.\n\n  // Expose minimal controls for accessibility: focusing canvas and pressing keys works\n  // Also, listen for window blur/unload to stop audio\n  window.addEventListener('blur', () => {\n    // gently stop background when leaving\n    if (audioCtx && backgroundGain) {\n      try {\n        backgroundGain.gain.cancelScheduledValues(audioCtx.currentTime);\n        backgroundGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.4);\n      } catch (e) {\n        // ignore\n      }\n    }\n  });\n\n  window.addEventListener('beforeunload', () => {\n    if (audioCtx) {\n      try {\n        audioCtx.close();\n      } catch (e) {}\n    }\n  });\n\n  // Final note: ensure that if audio context becomes available later we can start background with M or clicking audio toggle\n  // That is already handled by initAudioOnGesture() calls in input handlers.\n\n})();\n---\n",
  "improve_response_tokens": 22144,
  "formatted_code": true,
  "formatting_response_tokens": 23196,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}