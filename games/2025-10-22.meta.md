# Game of the Day - 2025-10-22

## Metadata
- **Generated Date:** 2025-10-22
- **Generated Time:** 2025-10-22T00:27:53.078981
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-10-22.js
- **File Size:** 26128 bytes
- **Tokens Used:** 9035

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-10-22.js` - The playable game
- `2025-10-22.meta.json` - Machine-readable metadata
- `2025-10-22.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 20488

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 23547

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Educational Drone Math Game
  // Renders inside element with id "game-of-the-day-stage"
  // All drawing done on a canvas sized exactly 720x480
  // Uses Web Audio API for sounds (with error handling)
  // Accessible keyboard controls: left/right (arrow or A/D), space to select, 1-4 to choose pad, R to restart, M to mute/unmute
  // Win: reach targetCorrect (default 10). Lose: mistakes reach maxLives (default 3).
  // Author: Generated for ages 7-9, focuses on addition/subtraction within 20.

  // --- Configuration ---
  const WIDTH = 720;
  const HEIGHT = 480;
  const TARGET_CORRECT = 10;
  const MAX_LIVES = 3;
  const PADDING = 12; // minimum padding between UI elements

  // --- Utility functions ---
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

  // --- Setup canvas inside container ---
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Container element #game-of-the-day-stage not found.');
    return;
  }
  container.innerHTML = ''; // clear any content
  container.style.position = 'relative';
  container.style.width = WIDTH + 'px';
  container.style.height = HEIGHT + 'px';
  container.style.outline = 'none';

  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute('role', 'img');
  canvas.setAttribute('aria-label', 'Drone math game. Use arrow keys to move, space to select, 1-4 to choose a pad, R to restart, M to mute.');
  canvas.tabIndex = 0; // focusable for keyboard
  canvas.style.display = 'block';
  container.appendChild(canvas);

  const ctx = canvas.getContext('2d');

  // --- Audio setup with error handling ---
  let audioEnabled = true;
  let audioCtx = null;
  let bgGain = null;
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (AudioContext) {
      audioCtx = new AudioContext();
      bgGain = audioCtx.createGain();
      bgGain.gain.value = 0.06; // gentle background volume
      bgGain.connect(audioCtx.destination);

      // create a gentle background drone using low-frequency oscillator + filter
      const bgOsc = audioCtx.createOscillator();
      bgOsc.type = 'sine';
      bgOsc.frequency.value = 60; // low hum
      const bgFilter = audioCtx.createBiquadFilter();
      bgFilter.type = 'lowpass';
      bgFilter.frequency.value = 400;
      bgOsc.connect(bgFilter);
      bgFilter.connect(bgGain);
      bgOsc.start();

      // subtle movement with periodic LFO
      const lfo = audioCtx.createOscillator();
      lfo.frequency.value = 0.12;
      const lfoGain = audioCtx.createGain();
      lfoGain.gain.value = 50;
      lfo.connect(lfoGain);
      // use WebAudio automation to change filter frequency
      lfoGain.connect(bgFilter.frequency);
      lfo.start();
    } else {
      audioEnabled = false;
      console.warn('Web Audio API not supported in this browser.');
    }
  } catch (e) {
    audioEnabled = false;
    console.warn('Audio context creation failed:', e);
  }

  function resumeAudioOnGesture() {
    if (!audioCtx) return;
    if (audioCtx.state === 'suspended' || audioCtx.state === 'interrupted') {
      audioCtx.resume().catch((e) => {
        console.warn('Audio resume failed:', e);
      });
    }
  }

  // Sound effects generator functions
  function playCorrectSound() {
    if (!audioEnabled || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const o1 = audioCtx.createOscillator();
      const o2 = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      g.gain.value = 0.001;
      o1.type = 'sine';
      o2.type = 'triangle';
      o1.frequency.setValueAtTime(880, now);
      o2.frequency.setValueAtTime(660, now);
      o1.frequency.exponentialRampToValueAtTime(1320, now + 0.25);
      o2.frequency.exponentialRampToValueAtTime(990, now + 0.25);
      g.gain.setValueAtTime(0.001, now);
      g.gain.exponentialRampToValueAtTime(0.25, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.8);
      o1.connect(g);
      o2.connect(g);
      g.connect(audioCtx.destination);
      o1.start(now);
      o2.start(now);
      o1.stop(now + 0.9);
      o2.stop(now + 0.9);
    } catch (e) {
      console.warn('Error playing correct sound:', e);
    }
  }

  function playIncorrectSound() {
    if (!audioEnabled || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'sawtooth';
      o.frequency.setValueAtTime(220, now);
      o.frequency.exponentialRampToValueAtTime(90, now + 0.4);
      g.gain.setValueAtTime(0.001, now);
      g.gain.exponentialRampToValueAtTime(0.3, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.7);
      o.connect(g);
      g.connect(audioCtx.destination);
      o.start(now);
      o.stop(now + 0.8);
    } catch (e) {
      console.warn('Error playing incorrect sound:', e);
    }
  }

  // --- Game State ---
  let score = 0;
  let lives = MAX_LIVES;
  let roundActive = true;
  let currentProblem = null;
  let choices = [];
  let drone = {
    x: WIDTH / 2,
    y: 120,
    vx: 0,
    width: 60,
    height: 30,
    descending: false,
    targetPadIndex: null,
    descendProgress: 0
  };
  let pads = []; // will hold pad objects with x,y,width,height and value
  let messageTimer = 0;
  let messageText = '';
  let paused = false;
  let gameOverState = null; // null | 'win' | 'loss'
  let highlightAudio = audioEnabled;
  let lastAnswerCorrect = null;

  // Prepare pad positions (4 pads across lower third)
  function layoutPads() {
    pads = [];
    const padCount = 4;
    const padY = HEIGHT - 110;
    const padW = 120;
    const padH = 60;
    const gap = (WIDTH - padCount * padW) / (padCount + 1);
    for (let i = 0; i < padCount; i++) {
      const x = gap + i * (padW + gap);
      pads.push({
        x,
        y: padY,
        w: padW,
        h: padH,
        value: 0,
        idx: i
      });
    }
  }

  layoutPads();

  // --- Problem generation (age 7-9): simple addition or subtraction within 20 ---
  function generateProblem() {
    const op = Math.random() < 0.6 ? '+' : '-';
    let a, b;
    if (op === '+') {
      a = randInt(1, 12);
      b = randInt(1, 10);
      if (a + b > 20) {
        a = Math.max(1, 20 - b);
      }
    } else {
      a = randInt(5, 20);
      b = randInt(1, Math.min(9, a - 1));
    }
    const question = `${a} ${op} ${b}`;
    const answer = op === '+' ? a + b : a - b;
    currentProblem = { a, b, op, question, answer };
    // Build choices array (correct + 3 distractors)
    const set = new Set();
    set.add(answer);
    while (set.size < 4) {
      let delta = randInt(-5, 5);
      if (delta === 0) delta = randInt(1, 3);
      let candidate = answer + delta;
      if (candidate < 0) candidate = Math.abs(candidate) + 1;
      if (candidate > 30) candidate = 30 - (candidate % 5);
      set.add(candidate);
    }
    choices = shuffle(Array.from(set));
    // assign to pads
    for (let i = 0; i < pads.length; i++) {
      pads[i].value = choices[i];
    }
  }

  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  // --- Input Handling ---
  const keys = {};
  canvas.addEventListener('keydown', (e) => {
    keys[e.key.toLowerCase()] = true;
    // resume audio on first meaningful interaction
    resumeAudioOnGesture();
    if (e.key === ' ' || e.key === 'Spacebar') {
      e.preventDefault();
    }
    // handle quick keyboard commands
    if (e.key.toLowerCase() === 'r') {
      restartGame();
    } else if (e.key.toLowerCase() === 'm') {
      toggleMute();
    } else if (['1','2','3','4'].includes(e.key)) {
      // map to pad selection
      const idx = parseInt(e.key) - 1;
      attemptSelectPad(idx);
    }
  });
  canvas.addEventListener('keyup', (e) => {
    keys[e.key.toLowerCase()] = false;
  });

  // Mouse interactions: clicking a pad selects it; clicking restart while on end screens restarts
  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    // If game over/win, detect restart button area
    if (gameOverState) {
      const btn = getRestartButtonBounds();
      if (mx >= btn.x && mx <= btn.x + btn.w && my >= btn.y && my <= btn.y + btn.h) {
        restartGame();
        return;
      }
      return;
    }
    // If clicked on a pad:
    for (let i = 0; i < pads.length; i++) {
      const p = pads[i];
      if (mx >= p.x && mx <= p.x + p.w && my >= p.y && my <= p.y + p.h) {
        attemptSelectPad(i);
        return;
      }
    }
    // Click toggles audio icon area
    const audioRect = getAudioIconBounds();
    if (mx >= audioRect.x && mx <= audioRect.x + audioRect.w && my >= audioRect.y && my <= audioRect.y + audioRect.h) {
      toggleMute();
    }
  });

  function attemptSelectPad(index) {
    if (gameOverState || !roundActive) return;
    if (index < 0 || index >= pads.length) return;
    // start drone descending animation toward pad
    drone.descending = true;
    drone.targetPadIndex = index;
    drone.descendProgress = 0;
    resumeAudioOnGesture();
  }

  function getAudioIconBounds() {
    const w = 36;
    const h = 28;
    return { x: WIDTH - w - PADDING, y: PADDING + 30, w, h };
  }

  function toggleMute() {
    if (!audioCtx) {
      audioEnabled = false;
      highlightAudio = false;
      return;
    }
    if (!audioEnabled) {
      audioEnabled = true;
      resumeAudioOnGesture();
    } else {
      audioEnabled = false;
    }
    highlightAudio = audioEnabled;
  }

  // --- Game Logic: process selection result when drone reaches pad ---
  function processSelection(padIndex) {
    const selectedValue = pads[padIndex].value;
    const correct = selectedValue === currentProblem.answer;
    lastAnswerCorrect = correct;
    if (correct) {
      score += 1;
      messageText = 'Nice! Package delivered!';
      messageTimer = 90;
      playCorrectSound();
    } else {
      lives -= 1;
      messageText = 'Oops! Wrong building!';
      messageTimer = 90;
      playIncorrectSound();
    }
    // mini animation feedback
    roundActive = false;
    setTimeout(() => {
      // determine win/loss
      if (score >= TARGET_CORRECT) {
        gameOverState = 'win';
      } else if (lives <= 0) {
        gameOverState = 'loss';
      } else {
        // next round
        generateProblem();
        roundActive = true;
      }
      // reset drone
      drone.descending = false;
      drone.targetPadIndex = null;
      drone.descendProgress = 0;
      drone.x = WIDTH / 2;
      drone.y = 120;
    }, 700);
  }

  // --- Restart game ---
  function restartGame() {
    score = 0;
    lives = MAX_LIVES;
    roundActive = true;
    gameOverState = null;
    messageText = '';
    messageTimer = 0;
    lastAnswerCorrect = null;
    generateProblem();
    drone.x = WIDTH / 2;
    drone.y = 120;
    drone.descending = false;
    drone.targetPadIndex = null;
    drone.descendProgress = 0;
    resumeAudioOnGesture();
  }

  // --- Drawing helpers with layout rules (non-overlapping, measuring) ---
  function drawBackground() {
    // calming gradient sky
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#e8f7ff');
    g.addColorStop(1, '#f7fbff');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // whimsical soft clouds and drones background elements (non-interactive)
    for (let i = 0; i < 7; i++) {
      const cx = (i * 123) % WIDTH + (i % 3) * 20;
      const cy = 40 + ((i * 77) % 100);
      ctx.globalAlpha = 0.3;
      drawCloud(cx, cy, 36 + (i % 3) * 12, '#ffffff');
      ctx.globalAlpha = 1;
    }

    // grass / city silhouette at bottom
    ctx.fillStyle = '#e6f4ea';
    ctx.fillRect(0, HEIGHT - 80, WIDTH, 80);
    // wacky building shapes for landing visual
    const buildingColors = ['#d7ebff', '#e7ffe6', '#fff6d7'];
    for (let i = 0; i < 8; i++) {
      const bw = 60 + (i % 3) * 20;
      const bh = 40 + (i % 4) * 18;
      const bx = i * 90 + 10;
      const by = HEIGHT - 80 - bh;
      ctx.fillStyle = buildingColors[i % buildingColors.length];
      roundRect(ctx, bx, by, bw, bh, 6, true, false);
      ctx.strokeStyle = '#d0d0d0';
      ctx.strokeRect(bx + 6, by + 6, bw - 12, bh - 12);
    }
  }

  function drawCloud(x, y, r, color) {
    ctx.fillStyle = color;
    arcFill(x, y, r);
    arcFill(x + r * 0.8, y - r * 0.2, r * 0.85);
    arcFill(x - r * 0.8, y - r * 0.2, r * 0.85);
    ctx.fillRect(x - r, y, r * 2, r * 0.9);
  }

  function arcFill(x, y, r) {
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    if (r < 0) r = 0;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // --- Draw UI elements with measureText-based backgrounds to avoid overlap ---
  function drawTopUI() {
    // Score top-left
    ctx.font = 'bold 20px sans-serif';
    const scoreText = `Score: ${score}`;
    const scoreMetrics = ctx.measureText(scoreText);
    const scoreW = scoreMetrics.width + 16;
    const scoreH = 28;
    const scoreX = PADDING;
    const scoreY = PADDING;
    roundRectFillStroke(scoreX, scoreY, scoreW, scoreH, 8, '#ffffffcc', '#a6d1ff');

    ctx.fillStyle = '#154360';
    ctx.font = 'bold 20px sans-serif';
    ctx.fillText(scoreText, scoreX + 8, scoreY + 20);

    // Center top: Problem progress
    ctx.font = 'bold 22px sans-serif';
    const progressText = `Delivery ${score + 1} of ${TARGET_CORRECT}`;
    const progMetrics = ctx.measureText(progressText);
    const progW = progMetrics.width + 20;
    const progX = (WIDTH - progW) / 2;
    const progY = PADDING;
    roundRectFillStroke(progX, progY, progW, scoreH, 8, '#ffffffcc', '#c9f6d3');
    ctx.fillStyle = '#0b5345';
    ctx.fillText(progressText, progX + 10, progY + 20);

    // Lives top-right
    ctx.font = 'bold 20px sans-serif';
    const livesText = `Mistakes: ${MAX_LIVES - lives}/${MAX_LIVES}`;
    const livesMetrics = ctx.measureText(livesText);
    const livesW = livesMetrics.width + 16;
    const livesX = WIDTH - livesW - PADDING;
    const livesY = PADDING;
    roundRectFillStroke(livesX, livesY, livesW, scoreH, 8, '#fff0f0cc', '#ffc9c9');
    ctx.fillStyle = '#6b0b0b';
    ctx.fillText(livesText, livesX + 8, livesY + 20);

    // Audio icon below lives
    const audioRect = getAudioIconBounds();
    ctx.fillStyle = '#ffffffcc';
    roundRectFillStroke(audioRect.x - 2, audioRect.y - 2, audioRect.w + 4, audioRect.h + 4, 6, '#ffffffcc', '#cccccc');
    // draw speaker
    ctx.fillStyle = highlightAudio ? '#0b6b6b' : '#888';
    ctx.beginPath();
    ctx.moveTo(audioRect.x + 6, audioRect.y + 8);
    ctx.lineTo(audioRect.x + 16, audioRect.y + 8);
    ctx.lineTo(audioRect.x + 24, audioRect.y + 4);
    ctx.lineTo(audioRect.x + 24, audioRect.y + audioRect.h - 4);
    ctx.lineTo(audioRect.x + 16, audioRect.y + audioRect.h - 8);
    ctx.lineTo(audioRect.x + 6, audioRect.y + audioRect.h - 8);
    ctx.closePath();
    ctx.fill();
    // sound waves or mute cross
    if (highlightAudio) {
      ctx.beginPath();
      ctx.strokeStyle = '#0b6b6b';
      ctx.lineWidth = 2;
      ctx.arc(audioRect.x + 26, audioRect.y + audioRect.h / 2 - 2, 8, -0.6, 0.6);
      ctx.stroke();
    } else {
      ctx.strokeStyle = '#aa0000';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(audioRect.x + 26, audioRect.y + 6);
      ctx.lineTo(audioRect.x + 34, audioRect.y + audioRect.h - 6);
      ctx.stroke();
    }
  }

  function roundRectFillStroke(x, y, w, h, r, fillColor, strokeColor) {
    ctx.fillStyle = fillColor;
    ctx.strokeStyle = strokeColor || '#999';
    ctx.lineWidth = 1.5;
    roundRect(ctx, x, y, w, h, r, true, true);
  }

  // --- Draw drone ---
  function drawDrone() {
    const d = drone;
    // body
    ctx.save();
    ctx.translate(d.x, d.y);
    ctx.fillStyle = '#fff';
    ctx.strokeStyle = '#5a8190';
    ctx.lineWidth = 2;
    roundRect(ctx, -d.width/2, -d.height/2, d.width, d.height, 8, true, true);
    // windows
    ctx.fillStyle = '#aee3ff';
    ctx.fillRect(-d.width/2 + 6, -d.height/2 + 6, d.width - 12, d.height/2 - 2);
    // propellers (wacky)
    ctx.fillStyle = '#f9d976';
    for (let i=0;i<4;i++){
      const px = (i - 1.5) * (d.width/3);
      const py = -d.height/2 - 10;
      ctx.beginPath();
      ctx.ellipse(px, py, 12, 4, (i%2?0.6:0.2), 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
    // little package trail
    if (d.descending) {
      ctx.fillStyle = lastAnswerCorrect ? '#bfffbf' : '#ffd6d6';
      ctx.fillRect(d.x - 6, d.y + 20, 12, 14);
    } else {
      ctx.fillStyle = '#f0e6c8';
      ctx.fillRect(d.x - 8, d.y + 20, 16, 10);
    }
  }

  // --- Draw pads and their values ---
  function drawPads() {
    for (let i = 0; i < pads.length; i++) {
      const p = pads[i];
      // highlight if hovered by mouse or targeted by drone
      // determine if selected
      const isTarget = drone.targetPadIndex === i && drone.descending;
      // pad shadow
      ctx.fillStyle = '#00000010';
      ctx.fillRect(p.x + 6, p.y + 8, p.w, p.h);
      // pad body
      ctx.fillStyle = isTarget ? '#ffe6a6' : '#ffffff';
      ctx.strokeStyle = '#b3cfe0';
      ctx.lineWidth = 2;
      roundRect(ctx, p.x, p.y, p.w, p.h, 12, true, true);

      // pad rooftop drawing
      ctx.fillStyle = '#e8f7ff';
      ctx.fillRect(p.x + 10, p.y - 18, p.w - 20, 16);
      // value text centered
      ctx.font = 'bold 28px sans-serif';
      ctx.fillStyle = '#1a3b4d';
      const text = String(p.value);
      const metrics = ctx.measureText(text);
      const tx = p.x + (p.w - metrics.width) / 2;
      const ty = p.y + p.h / 2 + 10;
      // background rectangle behind the text for readability
      const tbw = metrics.width + 12;
      const tbh = 36;
      const tbx = tx - 6;
      const tby = ty - 28;
      ctx.fillStyle = isTarget ? '#d6ffd6' : '#f9f9f9';
      roundRectFillStroke(tbx, tby, tbw, tbh, 8, ctx.fillStyle, '#d0d0d0');
      ctx.fillStyle = '#1a3b4d';
      ctx.fillText(text, tx, ty);
      // pad number label (1-4) bottom-left of pad
      ctx.font = '14px sans-serif';
      ctx.fillStyle = '#5e5e5e';
      ctx.fillText(`(${i+1})`, p.x + 8, p.y + p.h - 12);
    }
  }

  // --- Instruction area bottom-center ---
  function drawInstructions() {
    const lines = [
      'Controls: ← / → or A/D to move drone  •  Space to drop  •  1-4 to choose a pad',
      'Goal: Deliver ' + TARGET_CORRECT + ' packages. 3 wrong deliveries = game over.',
      'Click a pad or press its number. Press M to mute/unmute audio. Press R to restart.'
    ];
    ctx.font = 'bold 16px sans-serif';
    ctx.fillStyle = '#08303b';
    // compute text block width (max of lines)
    let maxW = 0;
    for (const l of lines) {
      const m = ctx.measureText(l).width;
      if (m > maxW) maxW = m;
    }
    const boxW = maxW + 20;
    const boxH = lines.length * 22 + 14;
    const bx = (WIDTH - boxW) / 2;
    const by = HEIGHT - boxH - PADDING;
    roundRectFillStroke(bx, by, boxW, boxH, 8, '#ffffffcc', '#cfe9ff');
    ctx.fillStyle = '#03313a';
    for (let i = 0; i < lines.length; i++) {
      ctx.fillText(lines[i], bx + 10, by + 20 + i * 22);
    }
  }

  // --- Message display (short-lived) ---
  function drawMessage() {
    if (!messageText || messageTimer <= 0) return;
    ctx.font = '18px sans-serif';
    const text = messageText;
    const metrics = ctx.measureText(text);
    const w = metrics.width + 24;
    const h = 36;
    const x = (WIDTH - w) / 2;
    const y = 120;
    roundRectFillStroke(x, y, w, h, 10, lastAnswerCorrect ? '#eaffea' : '#ffecec', '#c3c3c3');
    ctx.fillStyle = lastAnswerCorrect ? '#0a6b18' : '#a60404';
    ctx.fillText(text, x + 12, y + 23);
  }

  // --- End screens ---
  function getRestartButtonBounds() {
    const bw = 160;
    const bh = 44;
    const bx = (WIDTH - bw) / 2;
    const by = HEIGHT / 2 + 80;
    return { x: bx, y: by, w: bw, h: bh };
  }

  function drawEndScreen() {
    // dim background
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    ctx.font = 'bold 30px sans-serif';
    ctx.fillStyle = '#fff';
    let title = gameOverState === 'win' ? 'Victory!' : 'Game Over';
    // background box for title
    const titleMetrics = ctx.measureText(title);
    const titleW = titleMetrics.width + 40;
    const titleH = 60;
    const tx = (WIDTH - titleW) / 2;
    const ty = HEIGHT / 2 - 80;
    roundRectFillStroke(tx, ty, titleW, titleH, 12, '#2b7a7a', '#0b3940');
    ctx.fillStyle = '#fff';
    ctx.fillText(title, tx + 20, ty + 40);

    // message
    ctx.font = '18px sans-serif';
    ctx.fillStyle = '#ffffff';
    const msg = gameOverState === 'win'
      ? `Your drone delivered ${score} packages! You're a master pilot.`
      : `You made ${MAX_LIVES - lives} mistakes. Try again!`;
    const metrics = ctx.measureText(msg);
    const mw = metrics.width;
    ctx.fillText(msg, (WIDTH - mw) / 2, HEIGHT / 2 - 20);

    // restart button
    const btn = getRestartButtonBounds();
    roundRectFillStroke(btn.x, btn.y, btn.w, btn.h, 10, '#ffffff', '#377b56');
    ctx.fillStyle = '#083a2b';
    ctx.font = 'bold 20px sans-serif';
    const btnText = 'Restart (R)';
    const bm = ctx.measureText(btnText).width;
    ctx.fillText(btnText, btn.x + (btn.w - bm) / 2, btn.y + 28);
    // also accessibility hint
    ctx.font = '14px sans-serif';
    ctx.fillStyle = '#f0f0f0';
    const hint = 'Press R to restart or click the button';
    const hm = ctx.measureText(hint).width;
    ctx.fillText(hint, (WIDTH - hm) / 2, btn.y + btn.h + 26);
  }

  // --- Game loop and animation ---
  function update() {
    if (gameOverState) {
      // nothing to update when ended except maybe hover or audio toggles
      return;
    }
    // keyboard drone movement when not descending
    if (!drone.descending) {
      let move = 0;
      if (keys['arrowleft'] || keys['a']) move = -1;
      if (keys['arrowright'] || keys['d']) move = 1;
      drone.vx = move * 3.2;
      drone.x += drone.vx;
      drone.x = clamp(drone.x, 40, WIDTH - 40);
      // space to drop: attempt to drop on nearest pad
      if (keys[' '] || keys['spacebar']) {
        // find nearest pad horizontally
        let nearest = 0;
        let minDist = Infinity;
        for (let i = 0; i < pads.length; i++) {
          const center = pads[i].x + pads[i].w / 2;
          const dist = Math.abs(center - drone.x);
          if (dist < minDist) {
            minDist = dist;
            nearest = i;
          }
        }
        attemptSelectPad(nearest);
        // prevent repeated dropping by clearing space key (simple debounce)
        keys[' '] = false;
        keys['spacebar'] = false;
      }
    } else {
      // handle descending animation toward target pad
      const targetPad = pads[drone.targetPadIndex];
      if (!targetPad) {
        drone.descending = false;
        return;
      }
      // move drone horizontally toward pad center
      const targetX = targetPad.x + targetPad.w / 2;
      const dx = targetX - drone.x;
      drone.x += dx * 0.18; // smooth horizontal easing
      // increase descend progress
      drone.descendProgress += 0.08;
      drone.y = 120 + (targetPad.y - 120) * Math.min(1, drone.descendProgress);
      // when close to pad, trigger landing
      if (drone.descendProgress >= 0.98 || Math.abs(targetPad.x + targetPad.w/2 - drone.x) < 2) {
        // land
        processSelection(drone.targetPadIndex);
      }
    }

    if (messageTimer > 0) messageTimer--;
  }

  function draw() {
    // clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    drawBackground();
    drawTopUI();
    drawPads();
    drawDrone();
    drawMessage();
    drawInstructions();
    // draw problem box center top area below top UI
    drawProblemBox();
    if (gameOverState) drawEndScreen();
  }

  function drawProblemBox() {
    if (!currentProblem) return;
    ctx.font = 'bold 26px sans-serif';
    const q = 'Solve: ' + currentProblem.question;
    const metrics = ctx.measureText(q);
    const boxW = metrics.width + 28;
    const boxH = 44;
    const bx = (WIDTH - boxW) / 2;
    const by = 70;
    roundRectFillStroke(bx, by, boxW, boxH, 10, '#ffffffee', '#bfe8ff');
    ctx.fillStyle = '#09414f';
    ctx.fillText(q, bx + 14, by + 30);
  }

  // --- Main loop ---
  generateProblem();
  let last = performance.now();
  function loop(ts) {
    const dt = ts - last;
    last = ts;
    update();
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // --- Initial focus and instructions for accessibility ---
  setTimeout(() => {
    try {
      canvas.focus();
    } catch (e) {
      // ignore
    }
  }, 100);

  // --- Error handling: check audio later, show a small message if audio disabled ---
  if (!audioEnabled) {
    // draw small text on canvas after UI is ready
    setTimeout(() => {
      ctx.font = '14px sans-serif';
      const msg = 'Audio unavailable. Press M to toggle (if supported).';
      const mW = ctx.measureText(msg).width;
      ctx.fillStyle = '#5a5a5a';
      ctx.fillText(msg, WIDTH - mW - PADDING, HEIGHT - PADDING - 10);
    }, 500);
  }

  // Expose some functions for debugging (optional)
  window.__droneMathGame = {
    restart: restartGame,
    mute: toggleMute
  };

  // --- Helper: initial draw for any errors in resource load ---
  try {
    // ensure fonts exist - not strictly necessary
  } catch (e) {
    console.warn('Initialization minor error:', e);
  }

  // --- End of IIFE ---
})();
---

