{
  "generated_date": "2025-10-26",
  "generated_timestamp": "2025-10-26T00:29:17.795927",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8541,
  "game_filename": "2025-10-26.js",
  "game_size_bytes": 24812,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Drone Math Adventure\n  // Renders into existing element with id \"game-of-the-day-stage\"\n  // All visuals drawn on a canvas 720x480\n  // Sounds generated with Web Audio API oscillators and filters\n  // Controls: Mouse click answers, Number keys 1-4, Arrow keys to change selection, Enter to confirm,\n  // M to toggle audio, R to restart.\n\n  // CONFIG\n  const GAME_WIDTH = 720;\n  const GAME_HEIGHT = 480;\n  const GOAL_CORRECT = 10;\n  const MAX_WRONG = 3;\n  const PADDING = 12; // min spacing for UI\n  const BODY_FONT = '16px sans-serif'; // >=14\n  const IMPORTANT_FONT = '22px sans-serif'; // >=18\n  const TITLE_FONT = '28px sans-serif';\n  const CHOICE_FONT = '20px sans-serif';\n\n  // Locate stage element\n  const stage = document.getElementById('game-of-the-day-stage');\n  if (!stage) {\n    console.error('Stage element with id \"game-of-the-day-stage\" not found.');\n    return;\n  }\n\n  // Clear stage and create canvas\n  stage.innerHTML = '';\n  stage.style.position = 'relative';\n  stage.style.width = GAME_WIDTH + 'px';\n  stage.style.height = GAME_HEIGHT + 'px';\n  const canvas = document.createElement('canvas');\n  canvas.width = GAME_WIDTH;\n  canvas.height = GAME_HEIGHT;\n  canvas.setAttribute('role', 'img');\n  canvas.setAttribute('aria-label', 'Drone Math Adventure: a math game for kids with keyboard and mouse controls.');\n  stage.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Audio setup\n  let audioCtx = null;\n  let audioEnabled = true;\n  try {\n    const AudioContext = window.AudioContext || window.webkitAudioContext;\n    if (AudioContext) {\n      audioCtx = new AudioContext();\n    } else {\n      audioEnabled = false;\n      console.warn('Web Audio API not supported in this browser.');\n    }\n  } catch (e) {\n    audioEnabled = false;\n    console.warn('AudioContext creation failed:', e);\n  }\n\n  // Resuming audio on first user gesture (some browsers require)\n  function tryResumeAudio() {\n    if (audioCtx && audioCtx.state === 'suspended') {\n      audioCtx.resume().catch((e) => {\n        console.warn('Audio resume failed:', e);\n      });\n    }\n  }\n\n  // Create background gentle sound (sustained, low volume atmospheric hum)\n  let bgOsc = null;\n  let bgGain = null;\n  function startBackgroundSound() {\n    if (!audioCtx || !audioEnabled) return;\n    stopBackgroundSound();\n    try {\n      bgOsc = audioCtx.createOscillator();\n      bgGain = audioCtx.createGain();\n      const lfo = audioCtx.createOscillator();\n      const lfoGain = audioCtx.createGain();\n\n      bgOsc.type = 'sine';\n      bgOsc.frequency.value = 110; // low hum\n      bgGain.gain.value = 0.01; // very gentle\n\n      lfo.type = 'sine';\n      lfo.frequency.value = 0.15; // slow pulsing\n      lfoGain.gain.value = 0.007;\n\n      lfo.connect(lfoGain);\n      lfoGain.connect(bgGain.gain);\n\n      bgOsc.connect(bgGain);\n      bgGain.connect(audioCtx.destination);\n\n      lfo.start();\n      bgOsc.start();\n    } catch (e) {\n      console.warn('Background sound error:', e);\n    }\n  }\n\n  function stopBackgroundSound() {\n    try {\n      if (bgOsc) {\n        bgOsc.stop();\n        bgOsc.disconnect();\n        bgOsc = null;\n      }\n      if (bgGain) {\n        bgGain.disconnect();\n        bgGain = null;\n      }\n    } catch (e) {\n      console.warn('Error stopping background sound:', e);\n    }\n  }\n\n  function playBeep(options = {}) {\n    // options: freq, duration, type, volume\n    if (!audioCtx || !audioEnabled) return;\n    try {\n      const now = audioCtx.currentTime;\n      const osc = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n      osc.type = options.type || 'sine';\n      osc.frequency.setValueAtTime(options.freq || 880, now);\n      gain.gain.setValueAtTime(options.volume || 0.12, now);\n      const env = options.duration || 0.18;\n      // Simple envelope\n      gain.gain.exponentialRampToValueAtTime(0.001, now + env);\n      osc.connect(gain);\n      gain.connect(audioCtx.destination);\n      osc.start(now);\n      osc.stop(now + env + 0.02);\n    } catch (e) {\n      console.warn('playBeep error:', e);\n    }\n  }\n\n  function playCorrectSound() {\n    if (!audioCtx || !audioEnabled) return;\n    tryResumeAudio();\n    // Pleasant multi-tone\n    const now = audioCtx.currentTime;\n    const freqs = [880, 1100, 1320];\n    freqs.forEach((f, i) => {\n      const osc = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n      osc.type = i === 1 ? 'triangle' : 'sine';\n      osc.frequency.setValueAtTime(f, now + i * 0.05);\n      gain.gain.setValueAtTime(0.08, now + i * 0.05);\n      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.35 + i * 0.05);\n      osc.connect(gain);\n      gain.connect(audioCtx.destination);\n      osc.start(now + i * 0.05);\n      osc.stop(now + 0.45 + i * 0.05);\n    });\n  }\n\n  function playIncorrectSound() {\n    if (!audioCtx || !audioEnabled) return;\n    tryResumeAudio();\n    const now = audioCtx.currentTime;\n    const osc = audioCtx.createOscillator();\n    const gain = audioCtx.createGain();\n    osc.type = 'square';\n    osc.frequency.setValueAtTime(220, now);\n    gain.gain.setValueAtTime(0.12, now);\n    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);\n    osc.connect(gain);\n    gain.connect(audioCtx.destination);\n    osc.start(now);\n    osc.stop(now + 0.28);\n  }\n\n  // Game state\n  let state = {\n    correct: 0,\n    wrong: 0,\n    selectionIndex: 0,\n    currentQuestion: null,\n    answered: false,\n    droneX: GAME_WIDTH / 2,\n    droneY: GAME_HEIGHT / 2 + 40,\n    droneTargetX: GAME_WIDTH / 2,\n    droneTargetY: GAME_HEIGHT / 2 + 40,\n    wobble: 0,\n    showVictory: false,\n    showGameOver: false,\n    audioOn: audioEnabled,\n    animTime: 0,\n  };\n\n  // Utility: random integer inclusive\n  function randInt(a, b) {\n    return Math.floor(Math.random() * (b - a + 1)) + a;\n  }\n\n  // Generate math question appropriate for ages 7-9\n  function generateQuestion(difficultyLevel) {\n    // difficultyLevel 0..n influences numbers size\n    const ops = ['+','-','\u00d7'];\n    const op = ops[randInt(0, difficultyLevel < 2 ? 1 : 2)];\n    let a, b;\n    if (op === '+') {\n      a = randInt(1, 10 + difficultyLevel * 5);\n      b = randInt(1, 10 + difficultyLevel * 5);\n    } else if (op === '-') {\n      a = randInt(1, 10 + difficultyLevel * 5);\n      b = randInt(1, a); // ensure non-negative result\n    } else { // multiplication\n      a = randInt(2, 5 + difficultyLevel); \n      b = randInt(2, 5 + difficultyLevel);\n    }\n    let questionText = `${a} ${op} ${b} = ?`;\n    let correct;\n    if (op === '+') correct = a + b;\n    else if (op === '-') correct = a - b;\n    else correct = a * b;\n\n    // Generate choices: one correct and three distractors\n    const choices = new Set();\n    choices.add(correct);\n    while (choices.size < 4) {\n      const variance = Math.max(1, Math.round(Math.abs(correct) * 0.4));\n      let cand = correct + randInt(-variance - 3, variance + 3);\n      if (cand === correct) cand += randInt(1, 3);\n      if (cand < 0) cand = Math.abs(cand) + randInt(0, 2);\n      choices.add(cand);\n    }\n    const choiceArr = Array.from(choices);\n    // Shuffle\n    for (let i = choiceArr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [choiceArr[i], choiceArr[j]] = [choiceArr[j], choiceArr[i]];\n    }\n    const correctIndex = choiceArr.indexOf(correct);\n    return {\n      text: questionText,\n      choices: choiceArr,\n      correctIndex: correctIndex\n    };\n  }\n\n  // Start or restart game\n  function startGame() {\n    state.correct = 0;\n    state.wrong = 0;\n    state.selectionIndex = 0;\n    state.answered = false;\n    state.droneX = GAME_WIDTH / 2;\n    state.droneY = GAME_HEIGHT / 2 + 40;\n    state.droneTargetX = GAME_WIDTH / 2;\n    state.droneTargetY = GAME_HEIGHT / 2 + 40;\n    state.showVictory = false;\n    state.showGameOver = false;\n    state.animTime = 0;\n    state.currentQuestion = generateQuestion(0);\n    if (state.audioOn) {\n      tryResumeAudio();\n      startBackgroundSound();\n    } else {\n      stopBackgroundSound();\n    }\n  }\n\n  // UI layout computations: place elements ensuring no overlap\n  // Regions:\n  // - Score top-left\n  // - Lives top-right\n  // - Drone and question center area\n  // - Choices lower center\n  // - Instructions bottom center\n  const layout = {\n    score: { x: PADDING, y: PADDING },\n    lives: { x: GAME_WIDTH - PADDING, y: PADDING },\n    questionBox: { x: 60, y: 60, w: GAME_WIDTH - 120, h: 110 },\n    droneArea: { x: GAME_WIDTH / 2, y: GAME_HEIGHT / 2 - 10 },\n    choicesBox: { x: 60, y: 190, w: GAME_WIDTH - 120, h: 170 },\n    instructions: { x: GAME_WIDTH / 2, y: GAME_HEIGHT - 40 }\n  };\n\n  // Helper to draw text with background rectangle ensuring readability and padding\n  function drawTextBox(text, font, x, y, align = 'left', padding = 8, bgColor = 'rgba(255,255,255,0.75)', textColor = '#111') {\n    ctx.font = font;\n    const metrics = ctx.measureText(text);\n    const textWidth = metrics.width;\n    const textHeight = parseInt(font, 10) || 16;\n    let boxX = x;\n    if (align === 'center') boxX = x - textWidth / 2 - padding;\n    else if (align === 'right') boxX = x - textWidth - padding * 2;\n    const boxY = y - textHeight - padding / 2;\n    const boxW = textWidth + padding * 2;\n    const boxH = textHeight + padding;\n    // Ensure inside canvas\n    let bx = Math.max(4, boxX);\n    let by = Math.max(4, boxY);\n    ctx.fillStyle = bgColor;\n    roundRect(ctx, bx, by, boxW, boxH, 6, true, false);\n    ctx.fillStyle = textColor;\n    ctx.textBaseline = 'top';\n    ctx.textAlign = align;\n    ctx.font = font;\n    ctx.fillText(text, x, by + padding / 4);\n    return { boxX: bx, boxY: by, boxW, boxH };\n  }\n\n  // Rounded rectangle helper\n  function roundRect(ctx, x, y, w, h, r, fill, stroke) {\n    if (w < 2 * r) r = w / 2;\n    if (h < 2 * r) r = h / 2;\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  // Choice boxes computed for mouse hit testing\n  function computeChoiceBoxes(question) {\n    const boxes = [];\n    const boxWidth = layout.choicesBox.w / 2 - 14;\n    const boxHeight = 56;\n    const startX = layout.choicesBox.x;\n    const startY = layout.choicesBox.y;\n    for (let i = 0; i < 4; i++) {\n      const col = i % 2;\n      const row = Math.floor(i / 2);\n      const x = startX + col * (boxWidth + 20);\n      const y = startY + row * (boxHeight + 16);\n      boxes.push({ x, y, w: boxWidth, h: boxHeight });\n    }\n    return boxes;\n  }\n\n  // Drawing drone (whimsical)\n  function drawDrone(x, y, tilt = 0, propSpeed = 0) {\n    // body\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(tilt * 0.05);\n    // shadow\n    ctx.fillStyle = 'rgba(0,0,0,0.12)';\n    ctx.beginPath();\n    ctx.ellipse(0, 46, 60, 18, 0, 0, Math.PI * 2);\n    ctx.fill();\n    // body main\n    ctx.fillStyle = '#88c0d0';\n    roundRect(ctx, -42, -18, 84, 36, 10, true, false);\n    // cockpit\n    ctx.fillStyle = '#5e9fb0';\n    ctx.beginPath();\n    ctx.ellipse(0, -6, 28, 18, 0, 0, Math.PI * 2);\n    ctx.fill();\n    // skids\n    ctx.strokeStyle = '#3b4b51';\n    ctx.lineWidth = 4;\n    ctx.beginPath();\n    ctx.moveTo(-36, 22);\n    ctx.lineTo(36, 22);\n    ctx.stroke();\n    // arms + props\n    ctx.lineWidth = 6;\n    ctx.strokeStyle = '#3b4b51';\n    // left arm\n    ctx.beginPath();\n    ctx.moveTo(-30, -8);\n    ctx.lineTo(-68, -36);\n    ctx.stroke();\n    // right arm\n    ctx.beginPath();\n    ctx.moveTo(30, -8);\n    ctx.lineTo(68, -36);\n    ctx.stroke();\n    // props (rotating)\n    drawProp(-68, -36, propSpeed);\n    drawProp(68, -36, propSpeed);\n    ctx.restore();\n  }\n\n  function drawProp(cx, cy, speed) {\n    ctx.save();\n    ctx.translate(cx, cy);\n    const blades = 3;\n    for (let i = 0; i < blades; i++) {\n      ctx.rotate((Math.PI * 2 / blades) * i + speed);\n      ctx.fillStyle = 'rgba(0,0,0,0.18)';\n      ctx.beginPath();\n      ctx.ellipse(18, 0, 22, 6, 0, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    ctx.restore();\n  }\n\n  // Draw the entire scene\n  function draw() {\n    ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);\n\n    // soft sky background with wacky clouds\n    const grd = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);\n    grd.addColorStop(0, '#e8f6ff');\n    grd.addColorStop(1, '#f9fdff');\n    ctx.fillStyle = grd;\n    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);\n\n    // floating geometric clouds (wacky)\n    for (let i = 0; i < 6; i++) {\n      ctx.fillStyle = `rgba(255,255,255,${0.7 - i * 0.08})`;\n      const cx = (i * 160 + (state.animTime * 15) % 160) % GAME_WIDTH;\n      const cy = 40 + (i % 3) * 18;\n      for (let j = 0; j < 4; j++) {\n        ctx.beginPath();\n        ctx.ellipse(cx + j * 22, cy + (j % 2) * 6, 28, 18, j * 0.2, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n\n    // Score top-left\n    ctx.textBaseline = 'top';\n    ctx.textAlign = 'left';\n    drawTextBox(`Score: ${state.correct}/${GOAL_CORRECT}`, IMPORTANT_FONT, layout.score.x, layout.score.y + 6, 'left', 10, 'rgba(255,255,255,0.85)', '#084');\n    // Lives top-right\n    ctx.textAlign = 'right';\n    drawTextBox(`Lives: ${Math.max(0, MAX_WRONG - state.wrong)}`, IMPORTANT_FONT, layout.lives.x, layout.lives.y + 6, 'right', 10, 'rgba(255,255,255,0.85)', '#840');\n\n    // Audio status small icon left of lives\n    ctx.textAlign = 'left';\n    const audioText = state.audioOn ? 'Sound: On (M to mute)' : 'Sound: Off (M to unmute)';\n    drawTextBox(audioText, BODY_FONT, 12, GAME_HEIGHT - 12, 'left', 8, 'rgba(255,255,255,0.7)', '#333');\n\n    // Question area background\n    ctx.fillStyle = 'rgba(255,255,255,0.85)';\n    roundRect(ctx, layout.questionBox.x, layout.questionBox.y, layout.questionBox.w, layout.questionBox.h, 12, true, false);\n\n    // Drone area draw drone and animated elements\n    const droneTargetX = state.droneTargetX;\n    const droneTargetY = state.droneTargetY;\n    // Move drone smoothly toward target\n    state.droneX += (droneTargetX - state.droneX) * 0.08;\n    state.droneY += (droneTargetY - state.droneY) * 0.06;\n    const tilt = (state.droneTargetX - state.droneX) * 0.02;\n    const propSpeed = state.animTime * 0.3;\n    drawDrone(state.droneX, state.droneY, tilt, propSpeed);\n\n    // Render question text centered in question box\n    ctx.fillStyle = '#102027';\n    ctx.font = TITLE_FONT;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'top';\n    const qx = layout.questionBox.x + layout.questionBox.w / 2;\n    const qy = layout.questionBox.y + 14;\n    // Use measureText and wrap if necessary\n    drawMultilineWrappedText(state.currentQuestion.text, ctx, qx, qy, layout.questionBox.w - 20, TITLE_FONT, 'center', '#032');\n\n    // Choices area background\n    ctx.fillStyle = 'rgba(245,255,250,0.85)';\n    roundRect(ctx, layout.choicesBox.x, layout.choicesBox.y, layout.choicesBox.w, layout.choicesBox.h, 12, true, false);\n\n    // Draw choices\n    ctx.font = CHOICE_FONT;\n    const boxes = computeChoiceBoxes(state.currentQuestion);\n    for (let i = 0; i < 4; i++) {\n      const box = boxes[i];\n      const isSelected = i === state.selectionIndex;\n      const answered = state.answered;\n      // color states: default, selected, correct/incorrect after answer\n      ctx.fillStyle = 'rgba(255,255,255,0.95)';\n      roundRect(ctx, box.x, box.y, box.w, box.h, 8, true, false);\n      // border\n      if (isSelected && !answered) {\n        ctx.strokeStyle = '#3070a0';\n        ctx.lineWidth = 3;\n        roundRect(ctx, box.x, box.y, box.w, box.h, 8, false, true);\n      } else if (answered) {\n        if (i === state.currentQuestion.correctIndex) {\n          ctx.strokeStyle = '#2a7a3a';\n          ctx.lineWidth = 4;\n          roundRect(ctx, box.x, box.y, box.w, box.h, 8, false, true);\n        } else if (i === state.selectionIndex && state.selectionIndex !== state.currentQuestion.correctIndex) {\n          ctx.strokeStyle = '#a02a2a';\n          ctx.lineWidth = 4;\n          roundRect(ctx, box.x, box.y, box.w, box.h, 8, false, true);\n        } else {\n          ctx.strokeStyle = 'rgba(0,0,0,0.06)';\n          ctx.lineWidth = 1;\n          roundRect(ctx, box.x, box.y, box.w, box.h, 8, false, true);\n        }\n      } else {\n        ctx.strokeStyle = 'rgba(0,0,0,0.06)';\n        ctx.lineWidth = 1;\n        roundRect(ctx, box.x, box.y, box.w, box.h, 8, false, true);\n      }\n\n      // Choice label number at left\n      ctx.fillStyle = '#123';\n      ctx.textAlign = 'left';\n      ctx.textBaseline = 'middle';\n      ctx.font = 'bold 16px sans-serif';\n      const labelX = box.x + 10;\n      const labelY = box.y + box.h / 2;\n      ctx.fillText(`${i + 1}.`, labelX, labelY);\n\n      // Choice value\n      ctx.font = CHOICE_FONT;\n      ctx.fillStyle = '#033';\n      ctx.textAlign = 'center';\n      ctx.fillText(String(state.currentQuestion.choices[i]), box.x + box.w / 2 + 10, box.y + box.h / 2);\n    }\n\n    // Instructions bottom center (non overlapping)\n    ctx.textAlign = 'center';\n    ctx.font = BODY_FONT;\n    ctx.fillStyle = '#033';\n    const instructions = 'Use 1-4 or arrow keys + Enter to pick. Click choice to answer. Press M to toggle sound. R to restart.';\n    drawMultilineWrappedText(instructions, ctx, layout.instructions.x, layout.instructions.y - 6, GAME_WIDTH - 40, BODY_FONT, 'center', '#033');\n\n    // Victory or game over overlays\n    if (state.showVictory || state.showGameOver) {\n      ctx.fillStyle = 'rgba(0,0,0,0.5)';\n      ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);\n      const title = state.showVictory ? 'Victory! Drone Delivered All Batteries!' : 'Game Over';\n      const subtitle = state.showVictory ? `You answered ${state.correct} correctly!` : `You answered ${state.correct} correctly. Try again!`;\n      ctx.font = TITLE_FONT;\n      ctx.fillStyle = '#fff';\n      ctx.textAlign = 'center';\n      ctx.fillText(title, GAME_WIDTH / 2, GAME_HEIGHT / 2 - 40);\n      ctx.font = IMPORTANT_FONT;\n      ctx.fillText(subtitle, GAME_WIDTH / 2, GAME_HEIGHT / 2 + 4);\n      ctx.font = BODY_FONT;\n      ctx.fillText('Press R or click anywhere to restart.', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 48);\n    }\n\n    // Accessibility text alternatives: small label bottom-left\n    ctx.font = '14px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillStyle = 'rgba(0,0,0,0.5)';\n    ctx.fillText('Accessible controls: keyboard and mouse supported.', 8, GAME_HEIGHT - 18);\n  }\n\n  function drawMultilineWrappedText(text, ctx, x, y, maxWidth, font, align = 'left', color = '#000') {\n    ctx.font = font;\n    ctx.fillStyle = color;\n    ctx.textAlign = align;\n    ctx.textBaseline = 'top';\n    const words = text.split(' ');\n    let line = '';\n    const lineHeight = Math.max(18, parseInt(font, 10) + 6);\n    let drawY = y;\n    for (let n = 0; n < words.length; n++) {\n      const testLine = line + words[n] + ' ';\n      const metrics = ctx.measureText(testLine);\n      const testWidth = metrics.width;\n      if (testWidth > maxWidth && n > 0) {\n        // draw current line\n        let drawX = x;\n        if (align === 'center') drawX = x;\n        else if (align === 'left') drawX = x;\n        else if (align === 'right') drawX = x;\n        ctx.fillText(line.trim(), drawX, drawY);\n        line = words[n] + ' ';\n        drawY += lineHeight;\n      } else {\n        line = testLine;\n      }\n    }\n    if (line) {\n      ctx.fillText(line.trim(), x, drawY);\n    }\n  }\n\n  // Handle answer selection\n  function submitAnswer(index) {\n    if (state.showVictory || state.showGameOver) return;\n    if (state.answered) return; // ignore double submit\n    state.selectionIndex = index;\n    state.answered = true;\n    if (index === state.currentQuestion.correctIndex) {\n      state.correct += 1;\n      playCorrectSound();\n      // Drone flies to top-right and back (collect battery)\n      state.droneTargetX = randInt(GAME_WIDTH - 140, GAME_WIDTH - 80);\n      state.droneTargetY = randInt(90, 140);\n      // After short time, bring new question unless win\n      setTimeout(() => {\n        if (state.correct >= GOAL_CORRECT) {\n          handleVictory();\n        } else {\n          state.currentQuestion = generateQuestion(Math.floor(state.correct / 3));\n          state.selectionIndex = 0;\n          state.answered = false;\n          // drone returns to center-ish\n          state.droneTargetX = GAME_WIDTH / 2 + randInt(-30, 30);\n          state.droneTargetY = GAME_HEIGHT / 2 + randInt(10, 60);\n        }\n      }, 900);\n    } else {\n      state.wrong += 1;\n      playIncorrectSound();\n      // Drone recoils and wobbles\n      state.droneTargetX = Math.max(80, Math.min(GAME_WIDTH - 80, state.droneX - 90));\n      state.droneTargetY = state.droneY + 30;\n      // After short time, either game over or continue\n      setTimeout(() => {\n        if (state.wrong >= MAX_WRONG) handleGameOver();\n        else {\n          state.currentQuestion = generateQuestion(Math.floor(state.correct / 3));\n          state.selectionIndex = 0;\n          state.answered = false;\n          state.droneTargetX = GAME_WIDTH / 2 + randInt(-30, 30);\n          state.droneTargetY = GAME_HEIGHT / 2 + randInt(10, 60);\n        }\n      }, 900);\n    }\n  }\n\n  function handleVictory() {\n    state.showVictory = true;\n    state.answered = false;\n    stopBackgroundSound();\n    // Triumphant fanfare\n    if (audioCtx && state.audioOn) {\n      playBeep({freq:560, duration:0.18, volume:0.08, type:'sine'});\n      setTimeout(()=> playBeep({freq:740, duration:0.28, volume:0.08}), 150);\n      setTimeout(()=> playBeep({freq:980, duration:0.35, volume:0.08}), 320);\n    }\n  }\n\n  function handleGameOver() {\n    state.showGameOver = true;\n    state.answered = false;\n    stopBackgroundSound();\n    if (audioCtx && state.audioOn) playIncorrectSound();\n  }\n\n  // Input handling\n  canvas.addEventListener('click', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    if (state.showVictory || state.showGameOver) {\n      startGame();\n      return;\n    }\n    // Check choices\n    const boxes = computeChoiceBoxes(state.currentQuestion);\n    for (let i = 0; i < boxes.length; i++) {\n      const b = boxes[i];\n      if (mx >= b.x && mx <= b.x + b.w && my >= b.y && my <= b.y + b.h) {\n        submitAnswer(i);\n        return;\n      }\n    }\n  });\n\n  canvas.addEventListener('mousemove', (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const mx = e.clientX - rect.left;\n    const my = e.clientY - rect.top;\n    // highlight selection on hover when not answered\n    if (!state.answered && !state.showVictory && !state.showGameOver) {\n      const boxes = computeChoiceBoxes(state.currentQuestion);\n      for (let i = 0; i < boxes.length; i++) {\n        const b = boxes[i];\n        if (mx >= b.x && mx <= b.x + b.w && my >= b.y && my <= b.y + b.h) {\n          state.selectionIndex = i;\n          break;\n        }\n      }\n    }\n  });\n\n  window.addEventListener('keydown', (e) => {\n    // Avoid interfering with text inputs elsewhere\n    if (document.activeElement && document.activeElement.tagName === 'INPUT') return;\n    if (e.key >= '1' && e.key <= '4') {\n      const idx = Number(e.key) - 1;\n      submitAnswer(idx);\n    } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {\n      // cycle selection\n      if (!state.showVictory && !state.showGameOver) {\n        state.selectionIndex = (state.selectionIndex + 1) % 4;\n      }\n    } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {\n      if (!state.showVictory && !state.showGameOver) {\n        state.selectionIndex = (state.selectionIndex + 3) % 4;\n      }\n    } else if (e.key === 'Enter') {\n      if (state.showVictory || state.showGameOver) {\n        startGame();\n      } else {\n        submitAnswer(state.selectionIndex);\n      }\n    } else if (e.key.toLowerCase() === 'm') {\n      // toggle audio\n      state.audioOn = !state.audioOn;\n      if (state.audioOn) {\n        audioEnabled = true;\n        tryResumeAudio();\n        startBackgroundSound();\n      } else {\n        stopBackgroundSound();\n      }\n    } else if (e.key.toLowerCase() === 'r') {\n      startGame();\n    }\n  });\n\n  // Animation loop\n  let lastTime = 0;\n  function loop(t) {\n    const dt = (t - lastTime) / 1000 || 0;\n    lastTime = t;\n    state.animTime += dt;\n    // gentle improvements: slowly oscillate drone wobble when wrong\n    if (state.answered && state.wrong > 0) {\n      state.wobble += dt * 8;\n    } else {\n      state.wobble += dt * 2;\n    }\n    draw();\n    requestAnimationFrame(loop);\n  }\n\n  // Start initial\n  startGame();\n  requestAnimationFrame(loop);\n\n  // Error handling for audio operations globally\n  window.addEventListener('unhandledrejection', (e) => {\n    console.warn('Unhandled promise rejection:', e.reason);\n  });\n  window.addEventListener('error', (e) => {\n    console.warn('Window error:', e.message, 'at', e.filename, ':', e.lineno);\n  });\n})();\n---\n",
  "improve_response_tokens": 20109,
  "formatted_code": true,
  "formatting_response_tokens": 23806,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}