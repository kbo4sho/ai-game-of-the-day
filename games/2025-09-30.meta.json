{
  "generated_date": "2025-09-30",
  "generated_timestamp": "2025-09-30T00:27:15.394800",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 8780,
  "game_filename": "2025-09-30.js",
  "game_size_bytes": 25972,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Machine Math Catcher\n  // Game for ages 7-9: catch falling number gears that solve shown problems.\n  // Renders inside #game-of-the-day-stage and uses Web Audio API for sounds.\n  // All visuals drawn on canvas. Keyboard + mouse controls. Accessible messages.\n\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const CONTAINER_ID = \"game-of-the-day-stage\";\n  const MAX_LEVEL = 6;\n\n  // Utility functions\n  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));\n  const rand = (a, b) => a + Math.random() * (b - a);\n  const choose = (arr) => arr[Math.floor(Math.random() * arr.length)];\n  const deepCopy = (o) => JSON.parse(JSON.stringify(o));\n\n  // Find container\n  const container = document.getElementById(CONTAINER_ID);\n  if (!container) {\n    console.error(\"Game container not found:\", CONTAINER_ID);\n    return;\n  }\n\n  // Create canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.width = WIDTH + \"px\";\n  canvas.style.height = HEIGHT + \"px\";\n  canvas.setAttribute(\"role\", \"img\");\n  canvas.setAttribute(\"aria-label\", \"Machine Math Catcher. Use arrow keys to move, space to catch. Press Enter to start.\");\n  canvas.tabIndex = 0; // make focusable\n  container.innerHTML = \"\";\n  container.appendChild(canvas);\n\n  // Create hidden live region for accessibility updates\n  const live = document.createElement(\"div\");\n  live.setAttribute(\"aria-live\", \"polite\");\n  live.style.position = \"absolute\";\n  live.style.left = \"-9999px\";\n  container.appendChild(live);\n\n  const ctx = canvas.getContext(\"2d\");\n\n  // Colors and style\n  const bgColor = \"#e7f0f7\";\n  const pastel = [\"#F6C1D9\", \"#CFE8D8\", \"#FFE9A8\", \"#CDE7FF\", \"#E7D9FF\"];\n  const machineColor = \"#A0B2C9\";\n  const accent = \"#6E8CA8\";\n  const textColor = \"#24323F\";\n\n  // Audio setup with error handling\n  let audioEnabled = true;\n  let audioContext = null;\n  let masterGain = null;\n  let ambientGain = null;\n  let ambientOsc = null;\n\n  function initAudio() {\n    if (!audioEnabled || audioContext) return;\n    try {\n      const AudioCtx = window.AudioContext || window.webkitAudioContext;\n      audioContext = new AudioCtx();\n      masterGain = audioContext.createGain();\n      masterGain.gain.value = 0.9;\n      masterGain.connect(audioContext.destination);\n\n      ambientGain = audioContext.createGain();\n      ambientGain.gain.value = 0.06;\n      ambientGain.connect(masterGain);\n\n      // Gentle ambient oscillator (wobbling sine)\n      ambientOsc = audioContext.createOscillator();\n      const ambientFilter = audioContext.createBiquadFilter();\n      ambientFilter.type = \"lowpass\";\n      ambientFilter.frequency.value = 600;\n      ambientOsc.type = \"sine\";\n      ambientOsc.frequency.value = 220;\n      ambientOsc.connect(ambientFilter);\n      ambientFilter.connect(ambientGain);\n      ambientOsc.start();\n\n      // LFO to modulate ambient frequency for a breathing effect\n      const lfo = audioContext.createOscillator();\n      lfo.frequency.value = 0.1;\n      const lfoGain = audioContext.createGain();\n      lfoGain.gain.value = 40;\n      lfo.connect(lfoGain);\n      lfoGain.connect(ambientOsc.frequency);\n      lfo.start();\n\n    } catch (e) {\n      console.warn(\"Audio initialization failed:\", e);\n      audioEnabled = false;\n      audioContext = null;\n      masterGain = null;\n      ambientGain = null;\n      ambientOsc = null;\n    }\n  }\n\n  // Sound helper: short beep with envelope\n  function playBeep({freq = 880, type = \"sine\", duration = 0.18, gain = 0.15, detune = 0} = {}) {\n    if (!audioEnabled || !audioContext) return;\n    try {\n      const now = audioContext.currentTime;\n      const o = audioContext.createOscillator();\n      const g = audioContext.createGain();\n      o.type = type;\n      o.frequency.value = freq;\n      if (detune) o.detune.value = detune;\n      g.gain.value = 0.0001;\n      o.connect(g);\n      g.connect(masterGain);\n      o.start(now);\n      // envelope\n      g.gain.linearRampToValueAtTime(gain, now + 0.02);\n      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);\n      o.stop(now + duration + 0.05);\n    } catch (e) {\n      console.warn(\"playBeep error:\", e);\n    }\n  }\n\n  function playCorrectSound() {\n    // joyful chord\n    playBeep({freq: 880, type: \"sine\", duration: 0.12, gain: 0.12});\n    setTimeout(() => playBeep({freq: 1320, type: \"triangle\", duration: 0.18, gain: 0.08}), 60);\n    setTimeout(() => playBeep({freq: 660, type: \"sine\", duration: 0.16, gain: 0.07}), 120);\n  }\n\n  function playIncorrectSound() {\n    // descending buzz\n    playBeep({freq: 360, type: \"sawtooth\", duration: 0.2, gain: 0.14, detune: -10});\n    setTimeout(() => playBeep({freq: 240, type: \"sawtooth\", duration: 0.24, gain: 0.10}), 130);\n  }\n\n  function playPickupSound() {\n    playBeep({freq: 720, type: \"triangle\", duration: 0.12, gain: 0.09});\n  }\n\n  function toggleAudio() {\n    if (!audioContext) {\n      initAudio();\n    }\n    if (!audioEnabled) return;\n    if (audioContext && audioContext.state === \"suspended\") {\n      audioContext.resume().catch(() => {});\n    }\n    // Toggle ambient\n    if (ambientGain) {\n      ambientGain.gain.value = ambientGain.gain.value > 0.03 ? 0 : 0.06;\n    }\n  }\n\n  // Game objects and state\n  let keys = {};\n  let mouseX = WIDTH / 2;\n\n  class FallingItem {\n    constructor(x, y, vy, value, color, id) {\n      this.x = x;\n      this.y = y;\n      this.vy = vy;\n      this.value = value;\n      this.color = color;\n      this.radius = 26;\n      this.id = id;\n      this.rotation = 0;\n      this.spin = rand(-0.06, 0.06);\n    }\n    update(dt) {\n      this.y += this.vy * dt;\n      this.rotation += this.spin * dt * 60;\n    }\n    draw(ctx) {\n      // gear-like circle with teeth\n      ctx.save();\n      ctx.translate(this.x, this.y);\n      ctx.rotate(this.rotation);\n      // main circle\n      ctx.beginPath();\n      ctx.fillStyle = this.color;\n      ctx.strokeStyle = shade(this.color, -20);\n      ctx.lineWidth = 2;\n      ctx.arc(0, 0, this.radius, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n      // teeth\n      for (let i = 0; i < 10; i++) {\n        const angle = (Math.PI * 2 * i) / 10;\n        const tx = Math.cos(angle) * (this.radius + 6);\n        const ty = Math.sin(angle) * (this.radius + 6);\n        ctx.beginPath();\n        ctx.fillStyle = shade(this.color, -8);\n        ctx.rect(tx - 4, ty - 3, 8, 6);\n        ctx.fill();\n      }\n      // value text\n      ctx.fillStyle = textColor;\n      ctx.font = \"bold 18px Verdana, Arial\";\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillText(String(this.value), 0, 2);\n      ctx.restore();\n    }\n  }\n\n  // Robot basket controlled by player\n  const basket = {\n    x: WIDTH / 2,\n    y: HEIGHT - 70,\n    width: 140,\n    height: 36,\n    speed: 380,\n    color: \"#FFFBF0\",\n    handleOffset: 28,\n    draw(ctx) {\n      ctx.save();\n      // base\n      ctx.fillStyle = this.color;\n      ctx.strokeStyle = \"#c0c7d0\";\n      roundRect(ctx, this.x - this.width / 2, this.y - this.height / 2, this.width, this.height, 10, true, true);\n\n      // mechanical handle/arm\n      ctx.beginPath();\n      ctx.strokeStyle = \"#7a8896\";\n      ctx.lineWidth = 6;\n      ctx.lineCap = \"round\";\n      ctx.moveTo(this.x - this.width / 2 + this.handleOffset, this.y - this.height / 2);\n      ctx.lineTo(this.x - this.width / 2 + this.handleOffset, this.y - this.height / 2 - 36);\n      ctx.stroke();\n\n      // little gears & bolts\n      ctx.fillStyle = \"#b7c3d1\";\n      ctx.beginPath();\n      ctx.arc(this.x + this.width / 2 - 20, this.y - 4, 8, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n    }\n  };\n\n  // Game state\n  let state = {\n    mode: \"menu\", // menu | playing | levelComplete | win\n    level: 1,\n    score: 0,\n    items: [],\n    spawnTimer: 0,\n    requiredCorrect: 5,\n    caughtCorrect: 0,\n    timeLeft: 30,\n    targetProblem: null,\n    targetAnswer: null,\n    spawnInterval: 1200, // ms\n    gravity: 80, // pixels per second\n    paused: false,\n    soundOn: true,\n    touchedAudioPermission: false\n  };\n\n  // Level parameter generator\n  function setupLevel(level) {\n    state.items = [];\n    state.caughtCorrect = 0;\n    state.score = state.score; // preserve\n    state.level = level;\n    state.spawnTimer = 0;\n    state.timeLeft = 30 + Math.max(0, 6 - level) * 5;\n    // Define operations by level\n    const levelConfig = [\n      {op: \"add\", maxA: 5, maxB: 5, required: 4, spawn: 1400, gravity: 70},\n      {op: \"add\", maxA: 10, maxB: 10, required: 5, spawn: 1200, gravity: 90},\n      {op: \"sub\", maxA: 10, maxB: 9, required: 5, spawn: 1200, gravity: 100},\n      {op: \"sub\", maxA: 15, maxB: 10, required: 6, spawn: 1000, gravity: 120},\n      {op: \"mult\", maxA: 5, maxB: 5, required: 6, spawn: 900, gravity: 130},\n      {op: \"mix\", maxA: 10, maxB: 6, required: 7, spawn: 800, gravity: 150},\n    ];\n    const cfg = levelConfig[Math.min(level - 1, levelConfig.length - 1)];\n    state.requiredCorrect = cfg.required;\n    state.spawnInterval = cfg.spawn;\n    state.gravity = cfg.gravity;\n    // choose a problem to display (mix encourages choosing an operation each time)\n    const op = cfg.op === \"mix\" ? choose([\"add\", \"sub\", \"mult\"]) : cfg.op;\n    let a, b, ans;\n    if (op === \"add\") {\n      a = Math.floor(rand(1, cfg.maxA + 1));\n      b = Math.floor(rand(1, cfg.maxB + 1));\n      ans = a + b;\n      state.targetProblem = `${a} + ${b}`;\n    } else if (op === \"sub\") {\n      a = Math.floor(rand(2, cfg.maxA + 1));\n      b = Math.floor(rand(1, Math.min(a - 1, cfg.maxB) + 1));\n      ans = a - b;\n      state.targetProblem = `${a} - ${b}`;\n    } else if (op === \"mult\") {\n      a = Math.floor(rand(2, cfg.maxA + 1));\n      b = Math.floor(rand(1, cfg.maxB + 1));\n      ans = a * b;\n      state.targetProblem = `${a} \u00d7 ${b}`;\n    } else {\n      // fallback\n      a = 1; b = 1; ans = 2;\n      state.targetProblem = \"1 + 1\";\n    }\n    state.targetAnswer = ans;\n    announce(`Level ${level}. Solve: ${state.targetProblem}. Catch ${state.requiredCorrect} matching gears.`);\n  }\n\n  // Accessibility announcement\n  function announce(msg) {\n    if (!live) return;\n    live.textContent = msg;\n  }\n\n  // Helpers for drawing\n  function roundRect(ctx, x, y, w, h, r, fill, stroke) {\n    r = Math.min(r, w / 2, h / 2);\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  function shade(hex, percent) {\n    // simple hex shading: hex: #RRGGBB\n    try {\n      const num = parseInt(hex.slice(1), 16);\n      let r = (num >> 16) + percent;\n      let g = ((num >> 8) & 0x00FF) + percent;\n      let b = (num & 0x0000FF) + percent;\n      r = clamp(Math.round(r), 0, 255);\n      g = clamp(Math.round(g), 0, 255);\n      b = clamp(Math.round(b), 0, 255);\n      return \"#\" + (r << 16 | g << 8 | b).toString(16).padStart(6, \"0\");\n    } catch (e) {\n      return hex;\n    }\n  }\n\n  // Spawn items periodically\n  let nextItemId = 1;\n  function spawnItem() {\n    const x = rand(60, WIDTH - 60);\n    const y = -40;\n    const vy = state.gravity * (0.007 + Math.random() * 0.015) + state.gravity * 0.3;\n    let value;\n    // We will spawn a mix of values including the correct answer among others\n    const chanceCorrect = 0.28 + Math.min(0.4, state.level * 0.05);\n    if (Math.random() < chanceCorrect) {\n      value = state.targetAnswer;\n    } else {\n      // generate a plausible distractor\n      const spread = Math.max(3, Math.floor(state.level * 2));\n      value = state.targetAnswer + Math.floor(rand(-spread, spread + 1));\n      if (value < 0) value = Math.abs(value) + 1;\n      if (value === state.targetAnswer) value += 2;\n    }\n    const color = choose(pastel);\n    const item = new FallingItem(x, y, vy, value, color, nextItemId++);\n    state.items.push(item);\n  }\n\n  // Collision detection\n  function checkCatch(item) {\n    const left = basket.x - basket.width / 2;\n    const right = basket.x + basket.width / 2;\n    const top = basket.y - basket.height / 2;\n    // treat catch zone as top of basket\n    return item.y + item.radius > top - 6 && item.y < basket.y + basket.height && item.x > left && item.x < right;\n  }\n\n  // Input handling\n  canvas.addEventListener(\"keydown\", (e) => {\n    keys[e.key] = true;\n    // Start on Enter\n    if (state.mode === \"menu\" && (e.key === \"Enter\" || e.key === \" \")) {\n      startGame();\n    }\n    if (e.key === \"m\" || e.key === \"M\") {\n      // toggle ambient audio\n      if (audioContext && audioContext.state === \"suspended\") audioContext.resume().catch(()=>{});\n      if (audioEnabled && ambientGain) {\n        ambientGain.gain.value = ambientGain.gain.value > 0.03 ? 0 : 0.06;\n      }\n    }\n    if (e.key === \"p\" || e.key === \"P\") {\n      state.paused = !state.paused;\n      if (state.paused) announce(\"Game paused\");\n      else announce(\"Game resumed\");\n    }\n  });\n  canvas.addEventListener(\"keyup\", (e) => {\n    keys[e.key] = false;\n  });\n  window.addEventListener(\"keydown\", (e) => {\n    // allow arrow keys even if canvas not focused\n    if ([\"ArrowLeft\", \"ArrowRight\", \" \", \"Spacebar\"].includes(e.key)) {\n      // prevent page scroll\n      e.preventDefault();\n    }\n    keys[e.key] = true;\n  });\n  window.addEventListener(\"keyup\", (e) => {\n    keys[e.key] = false;\n  });\n\n  // Mouse movement for control\n  canvas.addEventListener(\"mousemove\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);\n  });\n\n  canvas.addEventListener(\"mousedown\", (e) => {\n    // On first user interaction, unlock audio\n    if (!state.touchedAudioPermission) {\n      try {\n        initAudio();\n        if (audioContext && audioContext.state === \"suspended\") audioContext.resume().catch(()=>{});\n      } catch (err) {}\n      state.touchedAudioPermission = true;\n    }\n    // If in menu, start\n    if (state.mode === \"menu\") startGame();\n  });\n\n  // Game controls: move basket\n  function updateInput(dt) {\n    const left = keys[\"ArrowLeft\"] || keys[\"a\"] || keys[\"A\"];\n    const right = keys[\"ArrowRight\"] || keys[\"d\"] || keys[\"D\"];\n    const useMouse = keys[\"Mouse\"] ? false : true; // mouse movement always used when moved\n    let targetX = basket.x;\n    if (left) targetX -= basket.speed * dt;\n    if (right) targetX += basket.speed * dt;\n    // mouse control: if no keyboard pressed and mouse active, follow mouseX\n    if (!left && !right) {\n      targetX = mouseX;\n    }\n    basket.x = clamp(targetX, basket.width / 2 + 6, WIDTH - basket.width / 2 - 6);\n  }\n\n  // Main update loop\n  let lastTime = performance.now();\n  function loop(now) {\n    const dt = Math.min(60, now - lastTime) / 1000;\n    lastTime = now;\n    // update\n    if (state.mode === \"playing\" && !state.paused) {\n      // spawn\n      state.spawnTimer += (dt * 1000);\n      if (state.spawnTimer >= state.spawnInterval) {\n        state.spawnTimer = 0;\n        spawnItem();\n      }\n      // update items\n      for (let it of state.items) {\n        it.update(dt);\n      }\n      // check catches\n      for (let i = state.items.length - 1; i >= 0; i--) {\n        const it = state.items[i];\n        if (checkCatch(it)) {\n          // caught\n          const correct = it.value === state.targetAnswer;\n          if (correct) {\n            state.caughtCorrect++;\n            state.score += 10;\n            playCorrectSound();\n            announce(`Correct! Caught ${it.value}. ${state.caughtCorrect} of ${state.requiredCorrect}`);\n          } else {\n            state.score = Math.max(0, state.score - 2);\n            playIncorrectSound();\n            announce(`Oops! ${it.value} is not ${state.targetAnswer}`);\n          }\n          state.items.splice(i, 1);\n        } else if (it.y - it.radius > HEIGHT + 40) {\n          // dropped beyond bottom\n          // penalize only if correct item missed\n          if (it.value === state.targetAnswer) {\n            state.score = Math.max(0, state.score - 3);\n            announce(\"A correct gear fell! Try to catch them.\");\n          }\n          state.items.splice(i, 1);\n        }\n      }\n\n      // time left\n      state.timeLeft -= dt;\n      if (state.timeLeft <= 0) {\n        // level failed? allow replay or treat as level over\n        if (state.caughtCorrect >= state.requiredCorrect) {\n          advanceLevel();\n        } else {\n          // allow retry same level\n          state.mode = \"levelComplete\";\n          announce(`Time's up. You caught ${state.caughtCorrect} of ${state.requiredCorrect}. Press Enter to retry.`);\n        }\n      } else if (state.caughtCorrect >= state.requiredCorrect) {\n        advanceLevel();\n      }\n\n      updateInput(dt);\n    }\n\n    // render\n    render();\n\n    requestAnimationFrame(loop);\n  }\n\n  // Advance level / Win\n  function advanceLevel() {\n    state.mode = \"levelComplete\";\n    if (state.level >= MAX_LEVEL) {\n      state.mode = \"win\";\n      announce(`Amazing! You beat all levels and scored ${state.score} points. Press Enter to play again.`);\n    } else {\n      announce(`Level ${state.level} complete! Catch ${state.requiredCorrect} solved. Press Enter for next level.`);\n    }\n  }\n\n  // Start or restart game\n  function startGame() {\n    // unlock audio on user gesture\n    if (!state.touchedAudioPermission) {\n      try {\n        initAudio();\n        if (audioContext && audioContext.state === \"suspended\") audioContext.resume().catch(()=>{});\n      } catch (e) {}\n      state.touchedAudioPermission = true;\n    }\n    state.mode = \"playing\";\n    state.score = 0;\n    state.level = 1;\n    setupLevel(1);\n    announce(`Starting level ${state.level}. Solve ${state.targetProblem}`);\n  }\n\n  function nextOrRetry() {\n    if (state.mode === \"levelComplete\") {\n      if (state.caughtCorrect >= state.requiredCorrect) {\n        // go to next\n        state.level = Math.min(MAX_LEVEL, state.level + 1);\n        setupLevel(state.level);\n        state.mode = \"playing\";\n      } else {\n        // retry\n        setupLevel(state.level);\n        state.mode = \"playing\";\n      }\n    } else if (state.mode === \"win\") {\n      // restart\n      state.score = 0;\n      state.level = 1;\n      setupLevel(1);\n      state.mode = \"playing\";\n    }\n  }\n\n  // Keyboard Enter to proceed\n  window.addEventListener(\"keydown\", (e) => {\n    if (e.key === \"Enter\") {\n      if (state.mode === \"menu\") {\n        startGame();\n      } else if (state.mode === \"levelComplete\" || state.mode === \"win\") {\n        nextOrRetry();\n      }\n    }\n  });\n\n  // Drawing everything\n  function render() {\n    // background\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    // soft gradient sky\n    const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    grad.addColorStop(0, shade(bgColor, -6));\n    grad.addColorStop(1, bgColor);\n    ctx.fillStyle = grad;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    drawWackyMachines(ctx);\n\n    // belt\n    drawConveyor(ctx);\n\n    // falling items\n    for (let it of state.items) {\n      it.draw(ctx);\n    }\n\n    // basket\n    basket.draw(ctx);\n\n    // HUD / overlay\n    drawHUD(ctx);\n\n    // menu overlay\n    if (state.mode === \"menu\") {\n      drawMenu(ctx);\n    } else if (state.mode === \"levelComplete\") {\n      drawLevelComplete(ctx);\n    } else if (state.mode === \"win\") {\n      drawWin(ctx);\n    }\n  }\n\n  function drawWackyMachines(ctx) {\n    ctx.save();\n    // big rounded machine silhouette at left\n    ctx.fillStyle = machineColor;\n    ctx.strokeStyle = shade(machineColor, -20);\n    ctx.lineWidth = 2;\n    roundRect(ctx, 20, 40, 240, 220, 18, true, true);\n\n    // pipes\n    ctx.strokeStyle = \"#9fb0c9\";\n    ctx.lineWidth = 10;\n    ctx.beginPath();\n    ctx.moveTo(260, 100);\n    ctx.lineTo(360, 110);\n    ctx.lineTo(420, 90);\n    ctx.stroke();\n\n    // whimsical gear cluster on right\n    drawGear(ctx, 580, 110, 34, \"#FFD5B8\");\n    drawGear(ctx, 640, 140, 26, \"#D6E9F8\");\n    drawGear(ctx, 600, 170, 18, \"#E6D6FF\");\n\n    // glass tubes\n    ctx.fillStyle = \"rgba(255,255,255,0.14)\";\n    roundRect(ctx, 500, 200, 140, 200, 12, true, false);\n    ctx.strokeStyle = \"#cfe1ef\";\n    ctx.strokeRect(500, 200, 140, 200);\n\n    ctx.restore();\n  }\n\n  function drawGear(ctx, x, y, r, color) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.fillStyle = color;\n    ctx.strokeStyle = shade(color, -25);\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.arc(0, 0, r, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n    for (let i = 0; i < 8; i++) {\n      const angle = (Math.PI * 2 * i) / 8;\n      const tx = Math.cos(angle) * (r + 6);\n      const ty = Math.sin(angle) * (r + 6);\n      ctx.fillStyle = shade(color, -8);\n      ctx.fillRect(tx - 4, ty - 4, 8, 8);\n    }\n    ctx.restore();\n  }\n\n  function drawConveyor(ctx) {\n    ctx.save();\n    const beltY = HEIGHT - 120;\n    // base platform\n    ctx.fillStyle = \"#dfeaf3\";\n    roundRect(ctx, 0, beltY, WIDTH, 80, 8, true, false);\n\n    // moving stripes for conveyor illusion\n    const t = performance.now() * 0.02;\n    for (let i = -1; i < WIDTH / 40 + 3; i++) {\n      const x = (i * 40 + (t % 40));\n      ctx.fillStyle = \"#cbd6e4\";\n      ctx.fillRect(x, beltY + 46, 20, 14);\n      ctx.fillStyle = \"#e9f0f8\";\n      ctx.fillRect(x + 20, beltY + 46, 20, 14);\n    }\n\n    // little machine pipe above conveyor\n    ctx.fillStyle = \"#b6c7d8\";\n    ctx.fillRect(40, beltY - 10, 140, 12);\n    ctx.fillRect(220, beltY - 16, 120, 18);\n    ctx.restore();\n  }\n\n  function drawHUD(ctx) {\n    ctx.save();\n    // info panel\n    ctx.fillStyle = \"rgba(255,255,255,0.85)\";\n    roundRect(ctx, 12, 12, 260, 74, 10, true, true);\n\n    ctx.fillStyle = textColor;\n    ctx.font = \"bold 16px Verdana, Arial\";\n    ctx.fillText(`Level: ${state.level}`, 28, 34);\n    ctx.fillText(`Score: ${state.score}`, 28, 58);\n\n    ctx.font = \"14px Verdana, Arial\";\n    ctx.fillText(`Problem: ${state.targetProblem || \"-\"}`, 140, 34);\n    ctx.fillText(`Catch: ${state.requiredCorrect}  Got: ${state.caughtCorrect}`, 140, 58);\n\n    // time bar\n    const barX = 300;\n    const barY = 22;\n    const barW = 400;\n    const barH = 18;\n    ctx.fillStyle = \"#e6eef8\";\n    roundRect(ctx, barX, barY, barW, barH, 8, true, true);\n    const pct = clamp(state.timeLeft / (30 + Math.max(0, 6 - state.level) * 5), 0, 1);\n    ctx.fillStyle = pct > 0.5 ? \"#B6E3A8\" : (pct > 0.2 ? \"#FFF3A6\" : \"#F6B5B0\");\n    roundRect(ctx, barX, barY, barW * pct, barH, 8, true, false);\n    ctx.fillStyle = textColor;\n    ctx.font = \"13px Verdana, Arial\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(`Time: ${Math.ceil(state.timeLeft)}s`, barX + barW / 2, barY + barH - 4);\n\n    // audio icon\n    ctx.textAlign = \"left\";\n    ctx.font = \"12px Verdana, Arial\";\n    ctx.fillStyle = textColor;\n    ctx.fillText(`Keyboard: \u2190 \u2192 or A/D. Press Enter to start. Press M to mute.`, 18, HEIGHT - 12);\n\n    // audio visual cue\n    ctx.fillStyle = audioContext && ambientGain && ambientGain.gain.value > 0.03 ? \"#7ACBF2\" : \"#C4C9CE\";\n    ctx.beginPath();\n    ctx.arc(WIDTH - 28, 36, 10, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = \"#fff\";\n    ctx.font = \"10px Verdana, Arial\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"\u266a\", WIDTH - 28, 40);\n\n    ctx.restore();\n  }\n\n  function drawMenu(ctx) {\n    ctx.save();\n    // translucent overlay\n    ctx.fillStyle = \"rgba(10,20,30,0.28)\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // title card\n    ctx.fillStyle = \"#fff\";\n    roundRect(ctx, WIDTH / 2 - 260, HEIGHT / 2 - 110, 520, 220, 14, true, true);\n    ctx.fillStyle = textColor;\n    ctx.font = \"bold 32px Verdana, Arial\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"Machine Math Catcher\", WIDTH / 2, HEIGHT / 2 - 50);\n\n    ctx.font = \"18px Verdana, Arial\";\n    ctx.fillText(\"Catch gears that show the answer to the problem\", WIDTH / 2, HEIGHT / 2 - 12);\n\n    ctx.font = \"16px Verdana, Arial\";\n    ctx.fillText(\"Use \u2190 \u2192 or A/D (or move mouse). Press Enter to start.\", WIDTH / 2, HEIGHT / 2 + 18);\n\n    ctx.font = \"14px Verdana, Arial\";\n    ctx.fillText(\"Press M to toggle audio, P to pause during play. Space or click to begin.\", WIDTH / 2, HEIGHT / 2 + 52);\n\n    ctx.restore();\n  }\n\n  function drawLevelComplete(ctx) {\n    ctx.save();\n    ctx.fillStyle = \"rgba(10,20,30,0.32)\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    ctx.fillStyle = \"#fff\";\n    roundRect(ctx, WIDTH / 2 - 240, HEIGHT / 2 - 90, 480, 160, 12, true, true);\n\n    ctx.fillStyle = textColor;\n    ctx.font = \"bold 28px Verdana, Arial\";\n    ctx.textAlign = \"center\";\n    if (state.caughtCorrect >= state.requiredCorrect) {\n      ctx.fillText(\"Level Complete!\", WIDTH / 2, HEIGHT / 2 - 20);\n      ctx.font = \"18px Verdana, Arial\";\n      ctx.fillText(`Great job! Score: ${state.score}`, WIDTH / 2, HEIGHT / 2 + 10);\n      ctx.fillText(\"Press Enter for next level\", WIDTH / 2, HEIGHT / 2 + 44);\n    } else {\n      ctx.fillText(\"Level Over\", WIDTH / 2, HEIGHT / 2 - 20);\n      ctx.font = \"18px Verdana, Arial\";\n      ctx.fillText(`You caught ${state.caughtCorrect} of ${state.requiredCorrect}`, WIDTH / 2, HEIGHT / 2 + 10);\n      ctx.fillText(\"Press Enter to try again\", WIDTH / 2, HEIGHT / 2 + 44);\n    }\n    ctx.restore();\n  }\n\n  function drawWin(ctx) {\n    ctx.save();\n    ctx.fillStyle = \"rgba(255,255,255,0.96)\";\n    roundRect(ctx, WIDTH / 2 - 260, HEIGHT / 2 - 120, 520, 200, 14, true, true);\n\n    ctx.fillStyle = \"#2a3b45\";\n    ctx.font = \"bold 30px Verdana, Arial\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"You did it! Machine Master!\", WIDTH / 2, HEIGHT / 2 - 20);\n\n    ctx.font = \"18px Verdana, Arial\";\n    ctx.fillText(`Final Score: ${state.score}`, WIDTH / 2, HEIGHT / 2 + 12);\n    ctx.fillText(\"Press Enter to play again\", WIDTH / 2, HEIGHT / 2 + 46);\n\n    ctx.restore();\n  }\n\n  // Start the animation loop\n  lastTime = performance.now();\n  requestAnimationFrame(loop);\n\n  // Initialize menu text\n  announce(\"Welcome to Machine Math Catcher. Press Enter to start. Use arrow keys or mouse to move. Press M to toggle audio.\");\n\n  // Expose some debugging in window for safety (not necessary but helpful)\n  window.machineMathState = state;\n\n})();\n---\n",
  "improve_response_tokens": 19620,
  "formatted_code": true,
  "formatting_response_tokens": 22635,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}