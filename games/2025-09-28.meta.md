# Game of the Day - 2025-09-28

## Metadata
- **Generated Date:** 2025-09-28
- **Generated Time:** 2025-09-28T00:30:00.515506
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-28.js
- **File Size:** 27500 bytes
- **Tokens Used:** 9290

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-28.js` - The playable game
- `2025-09-28.meta.json` - Machine-readable metadata
- `2025-09-28.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 19971

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 22440

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Machine Math - Canvas Game for ages 7-9
  // Renders inside element with ID 'game-of-the-day-stage'
  // All visuals drawn on canvas. Sounds generated with Web Audio API.
  // Accessible: keyboard controls, aria-live text, clear instructions.
  'use strict';

  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const BG_COLOR = '#F6FBFF';
  const MAX_LEVEL = 5;

  // Utility helpers
  function clamp(v, a, b) {
    return Math.max(a, Math.min(b, v));
  }

  // Find container
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Game container element with ID "game-of-the-day-stage" not found.');
    return;
  }
  // Clear container
  container.innerHTML = '';
  container.style.position = 'relative';
  container.style.width = WIDTH + 'px';
  container.style.height = HEIGHT + 'px';
  container.style.outline = 'none';

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.width = WIDTH + 'px';
  canvas.style.height = HEIGHT + 'px';
  canvas.setAttribute('role', 'application');
  canvas.setAttribute('aria-label', 'Machine Math game. Use mouse or keyboard to place gears to make the target number.');
  canvas.tabIndex = 0; // focusable for keyboard
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Create invisible live region for screen readers
  const liveRegion = document.createElement('div');
  liveRegion.setAttribute('aria-live', 'assertive');
  liveRegion.style.position = 'absolute';
  liveRegion.style.left = '-9999px';
  liveRegion.style.width = '1px';
  liveRegion.style.height = '1px';
  container.appendChild(liveRegion);

  // Audio setup with error handling
  let audioCtx = null;
  let audioEnabled = false;
  let bgGain = null;
  let bgOsc = null;

  function initAudio() {
    if (audioCtx) return true;
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) throw new Error('Web Audio API not supported');
      audioCtx = new AC();
      // Create gentle background hum
      bgOsc = audioCtx.createOscillator();
      const bgFilter = audioCtx.createBiquadFilter();
      bgFilter.type = 'lowpass';
      bgFilter.frequency.value = 600;
      bgOsc.type = 'sine';
      bgOsc.frequency.value = 110;
      bgGain = audioCtx.createGain();
      bgGain.gain.value = 0; // start silent; ramp when enabled
      bgOsc.connect(bgFilter);
      bgFilter.connect(bgGain);
      bgGain.connect(audioCtx.destination);
      bgOsc.start(0);
      audioEnabled = true;
      console.log('Audio initialized');
      return true;
    } catch (e) {
      console.warn('Audio unavailable:', e);
      audioEnabled = false;
      audioCtx = null;
      return false;
    }
  }

  function resumeAudioOnGesture() {
    // Try to create/resume on user gesture
    if (!initAudio()) return false;
    if (audioCtx.state === 'suspended' && typeof audioCtx.resume === 'function') {
      audioCtx.resume().then(() => {
        startBackgroundHum();
      }).catch(err => {
        console.warn('Audio resume error', err);
      });
    } else {
      startBackgroundHum();
    }
    return true;
  }

  function startBackgroundHum() {
    if (!audioEnabled) return;
    if (!bgGain) return;
    // gentle pulsing
    bgGain.gain.cancelScheduledValues(audioCtx.currentTime);
    bgGain.gain.setValueAtTime(0, audioCtx.currentTime);
    bgGain.gain.linearRampToValueAtTime(0.05, audioCtx.currentTime + 1.2);
  }

  function stopBackgroundHum() {
    if (!audioEnabled || !bgGain) return;
    bgGain.gain.cancelScheduledValues(audioCtx.currentTime);
    bgGain.gain.setValueAtTime(bgGain.gain.value, audioCtx.currentTime);
    bgGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.8);
  }

  // Sound effects using oscillators and envelopes
  function playTone({ frequency = 440, duration = 0.2, type = 'sine', volume = 0.12, attack = 0.01, release = 0.06, filterFreq = 1200 } = {}) {
    if (!audioEnabled || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      osc.type = type;
      osc.frequency.value = frequency;
      filter.type = 'lowpass';
      filter.frequency.value = filterFreq;
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(volume, now + attack);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + duration + release);
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + duration + release + 0.02);
    } catch (e) {
      console.warn('playTone error', e);
    }
  }

  function playCorrectSound() {
    if (!audioEnabled) return;
    // Pleasant little arpeggio
    playTone({ frequency: 660, duration: 0.12, type: 'sine', volume: 0.06 });
    setTimeout(() => playTone({ frequency: 880, duration: 0.16, type: 'sine', volume: 0.08 }), 120);
    setTimeout(() => playTone({ frequency: 1320, duration: 0.24, type: 'sine', volume: 0.1 }), 260);
  }

  function playIncorrectSound() {
    if (!audioEnabled) return;
    // Soft buzz
    playTone({ frequency: 120, duration: 0.28, type: 'sawtooth', volume: 0.12, filterFreq: 500 });
  }

  function playClickSound() {
    if (!audioEnabled) return;
    playTone({ frequency: 1200, duration: 0.06, type: 'square', volume: 0.05, filterFreq: 3000 });
  }

  // Game state
  let levelIndex = 0;
  const levels = [
    // Simple two-slot sums
    { target: 7, slots: 2, cogs: [2, 5, 3, 1] },
    { target: 10, slots: 2, cogs: [4, 6, 3, 2] },
    { target: 12, slots: 3, cogs: [5, 4, 3, 2, 1] },
    { target: 15, slots: 3, cogs: [7, 5, 3, 2] },
    { target: 9, slots: 2, cogs: [1, 8, 4, 2] }
  ];

  // Game objects: Cogs and Slots
  class Cog {
    constructor(id, value, x, y) {
      this.id = id;
      this.value = value;
      this.x = x;
      this.y = y;
      this.radius = 34;
      this.rotation = Math.random() * Math.PI * 2;
      this.isDragging = false;
      this.placedSlot = null;
      this.offset = { x: 0, y: 0 };
      this.hover = false;
    }
  }

  class Slot {
    constructor(id, x, y) {
      this.id = id;
      this.x = x;
      this.y = y;
      this.radius = 40;
      this.filledBy = null;
    }
  }

  let cogs = [];
  let slots = [];
  let selectedCog = null;
  let hoveredCog = null;
  let isPointerDown = false;
  let pointerIdDown = null;
  let pointerPos = { x: 0, y: 0 };
  let message = 'Click or press S to enable sound. Drag gears into machine slots to reach the target. Use keyboard: Tab to select, arrows to move, Enter to pick/place, Space to test.';
  updateLiveRegion(message);

  // Initialize level
  function setupLevel(index) {
    levelIndex = clamp(index, 0, levels.length - 1);
    const level = levels[levelIndex];
    cogs = [];
    slots = [];
    selectedCog = null;
    hoveredCog = null;
    // Place slots on machine area (right side)
    const slotAreaX = WIDTH * 0.65;
    const slotYStart = HEIGHT * 0.35;
    const slotSpacing = 90;
    for (let i = 0; i < level.slots; i++) {
      const sx = slotAreaX;
      const sy = slotYStart + i * slotSpacing;
      slots.push(new Slot(i, sx, sy));
    }
    // Shuffle cog positions on left
    const startX = WIDTH * 0.15;
    const startY = HEIGHT * 0.22;
    const gapX = 120;
    const gapY = 120;
    for (let i = 0; i < level.cogs.length; i++) {
      const v = level.cogs[i];
      const row = Math.floor(i / 3);
      const col = i % 3;
      const x = startX + col * gapX + (Math.random() * 18 - 9);
      const y = startY + row * gapY + (Math.random() * 14 - 7);
      cogs.push(new Cog('c' + i, v, x, y));
    }
    message = `Level ${levelIndex + 1} - Make ${level.target}. Place ${level.slots} gears into slots.`;
    updateLiveRegion(message);
    render();
  }

  // Check win condition
  function checkSolution() {
    const level = levels[levelIndex];
    let sum = 0;
    for (let s of slots) {
      if (!s.filledBy) {
        // slot empty -> not correct yet
        return false;
      }
      sum += s.filledBy.value;
    }
    if (sum === level.target) {
      playCorrectSound();
      message = `Nice! You made ${level.target}.`;
      updateLiveRegion(message);
      // animate success and advance after short delay
      setTimeout(() => {
        levelIndex++;
        if (levelIndex >= levels.length) {
          // victory
          message = 'You fixed all the wacky machines! Great job!';
          updateLiveRegion(message);
          stopBackgroundHum();
          renderVictory();
        } else {
          setupLevel(levelIndex);
        }
      }, 900);
      return true;
    } else {
      // wrong sum
      playIncorrectSound();
      message = `That makes ${sum}. Try again to make ${level.target}.`;
      updateLiveRegion(message);
      return false;
    }
  }

  // Place/Remove logic
  function tryPlaceCogInSlot(cog, slot) {
    if (!cog || !slot) return false;
    if (slot.filledBy && slot.filledBy !== cog) {
      // can't place; slot already filled
      return false;
    }
    // If cog currently placed elsewhere, clear old slot
    for (const s of slots) {
      if (s.filledBy === cog) s.filledBy = null;
    }
    // Snap cog to slot
    cog.x = slot.x;
    cog.y = slot.y;
    cog.placedSlot = slot;
    slot.filledBy = cog;
    playClickSound();
    return true;
  }

  function removeCogFromSlot(cog) {
    if (!cog) return;
    if (cog.placedSlot) {
      cog.placedSlot.filledBy = null;
      cog.placedSlot = null;
    }
  }

  // Input handling: pointer events
  function getPointerPos(e) {
    const rect = canvas.getBoundingClientRect();
    let clientX, clientY;
    if (e.touches && e.touches.length > 0) {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = e.clientX;
      clientY = e.clientY;
    }
    const x = (clientX - rect.left) * (canvas.width / rect.width);
    const y = (clientY - rect.top) * (canvas.height / rect.height);
    return { x, y };
  }

  function pointerDown(e) {
    try {
      // Ensure audio resume on first gesture
      resumeAudioOnGesture();
    } catch (err) {
      console.warn('Audio resume on gesture error', err);
    }
    e.preventDefault();
    isPointerDown = true;
    const p = getPointerPos(e);
    pointerPos = p;
    // find topmost cog under pointer
    let hit = null;
    for (let i = cogs.length - 1; i >= 0; i--) {
      const c = cogs[i];
      const dx = p.x - c.x;
      const dy = p.y - c.y;
      if (Math.hypot(dx, dy) <= c.radius + 6) {
        hit = c;
        break;
      }
    }
    if (hit) {
      // Bring to top
      const idx = cogs.indexOf(hit);
      if (idx >= 0) {
        cogs.splice(idx, 1);
        cogs.push(hit);
      }
      selectedCog = hit;
      hit.isDragging = true;
      hit.offset.x = p.x - hit.x;
      hit.offset.y = p.y - hit.y;
      removeCogFromSlot(hit);
      playClickSound();
      updateLiveRegion(`Picked up gear ${hit.value}. Use mouse or arrow keys to move it, press Enter to place in a slot.`);
    } else {
      // If clicked on slot, try to pick up its cog
      for (const s of slots) {
        const dx = p.x - s.x;
        const dy = p.y - s.y;
        if (Math.hypot(dx, dy) <= s.radius + 6) {
          if (s.filledBy) {
            selectedCog = s.filledBy;
            removeCogFromSlot(selectedCog);
            selectedCog.isDragging = true;
            selectedCog.offset.x = 0;
            selectedCog.offset.y = 0;
            playClickSound();
            updateLiveRegion(`Removed gear ${selectedCog.value} from slot.`);
            break;
          }
        }
      }
    }
    render();
  }

  function pointerMove(e) {
    if (!isPointerDown) {
      // highlight hovered cog
      const p = getPointerPos(e);
      let hover = null;
      for (let i = cogs.length - 1; i >= 0; i--) {
        const c = cogs[i];
        const dx = p.x - c.x;
        const dy = p.y - c.y;
        if (Math.hypot(dx, dy) <= c.radius + 6) {
          hover = c;
          break;
        }
      }
      hoveredCog = hover;
      render();
      return;
    }
    const p = getPointerPos(e);
    pointerPos = p;
    if (selectedCog && selectedCog.isDragging) {
      selectedCog.x = p.x - selectedCog.offset.x;
      selectedCog.y = p.y - selectedCog.offset.y;
      render();
    }
  }

  function pointerUp(e) {
    isPointerDown = false;
    const p = getPointerPos(e);
    // If dragging a cog, try to drop into slot if near
    if (selectedCog && selectedCog.isDragging) {
      let placed = false;
      for (const s of slots) {
        const dx = p.x - s.x;
        const dy = p.y - s.y;
        if (Math.hypot(dx, dy) <= s.radius + 16) {
          // place in this slot, if free or occupied by same cog
          if (!s.filledBy || s.filledBy === selectedCog) {
            tryPlaceCogInSlot(selectedCog, s);
            placed = true;
            break;
          }
        }
      }
      if (!placed) {
        // leave at dropped position
        selectedCog.isDragging = false;
        selectedCog.placedSlot = null;
      } else {
        selectedCog.isDragging = false;
      }
      playClickSound();
    }
    selectedCog = null;
    render();
  }

  // Keyboard controls: Tab to cycle cogs, arrows to move selected, Enter to pick/place, Space to test, S to enable sound, R to reset
  function keyDown(e) {
    if (e.key === 's' || e.key === 'S') {
      // enable audio
      const ok = resumeAudioOnGesture();
      if (ok) {
        message = 'Sound enabled.';
        updateLiveRegion(message);
      } else {
        message = 'Sound unavailable in this browser.';
        updateLiveRegion(message);
      }
      render();
      e.preventDefault();
      return;
    }
    if (e.key === 'Tab') {
      // cycle selection among cogs
      e.preventDefault();
      if (cogs.length === 0) return;
      const idx = selectedCog ? cogs.indexOf(selectedCog) : -1;
      const next = (idx + 1) % cogs.length;
      selectedCog = cogs[next];
      // bring to top visually
      const sc = cogs.splice(next, 1)[0];
      cogs.push(sc);
      sc.isDragging = false;
      message = `Selected gear ${sc.value}. Use arrow keys to move. Enter to pick/place.`;
      updateLiveRegion(message);
      render();
      return;
    }
    if (!selectedCog) return;
    let moved = false;
    if (e.key === 'ArrowLeft') {
      selectedCog.x -= 8;
      moved = true;
    } else if (e.key === 'ArrowRight') {
      selectedCog.x += 8;
      moved = true;
    } else if (e.key === 'ArrowUp') {
      selectedCog.y -= 8;
      moved = true;
    } else if (e.key === 'ArrowDown') {
      selectedCog.y += 8;
      moved = true;
    } else if (e.key === 'Enter') {
      // If near a slot, place. If already placed, remove.
      let placed = false;
      for (const s of slots) {
        const dx = selectedCog.x - s.x;
        const dy = selectedCog.y - s.y;
        if (Math.hypot(dx, dy) <= s.radius + 12) {
          tryPlaceCogInSlot(selectedCog, s);
          placed = true;
          break;
        }
      }
      if (!placed) {
        removeCogFromSlot(selectedCog);
      }
      playClickSound();
      message = `Gear ${selectedCog.value} placed/adjusted.`;
      updateLiveRegion(message);
      render();
    } else if (e.key === ' ') {
      // test machine
      e.preventDefault();
      checkSolution();
      render();
    } else if (e.key === 'r' || e.key === 'R') {
      // reset level
      setupLevel(levelIndex);
      message = 'Level reset.';
      updateLiveRegion(message);
    }
    if (moved) {
      // keep selectedCog within bounds
      selectedCog.x = clamp(selectedCog.x, 20, WIDTH - 20);
      selectedCog.y = clamp(selectedCog.y, 20, HEIGHT - 20);
      render();
    }
  }

  // Rendering functions
  function drawRoundedRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  function drawMachineBackground() {
    // calming gradient sky
    const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    grad.addColorStop(0, '#F9FEFF');
    grad.addColorStop(1, '#E9F8FF');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Wacky pipes
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = '#D1EFFF';
    for (let i = 0; i < 6; i++) {
      const y = 40 + i * 70;
      ctx.fillRect(40 + (i % 2) * 20, y, WIDTH - 80 - (i % 2) * 40, 14);
    }
    ctx.restore();

    // Control panel
    ctx.fillStyle = '#F0F5FF';
    drawRoundedRect(420, 40, 260, 120, 12);
    ctx.fillStyle = '#CFE6FF';
    ctx.fillRect(432, 60, 120, 16);
    ctx.fillStyle = '#BEE0FF';
    ctx.fillRect(432, 86, 80, 10);

    // Decorative nuts and bolts
    for (let i = 0; i < 8; i++) {
      const x = 480 + i * 28;
      const y = 160;
      drawBolt(x, y, 6, '#D0D7E6', '#A8B4C8');
    }
  }

  function drawBolt(cx, cy, radius, fill, stroke) {
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
      const angle = (i / 6) * Math.PI * 2;
      const rx = cx + Math.cos(angle) * radius;
      const ry = cy + Math.sin(angle) * radius;
      if (i === 0) ctx.moveTo(rx, ry); else ctx.lineTo(rx, ry);
    }
    ctx.closePath();
    ctx.fillStyle = fill;
    ctx.fill();
    ctx.strokeStyle = stroke;
    ctx.lineWidth = 1;
    ctx.stroke();

    // center screw
    ctx.beginPath();
    ctx.arc(cx, cy, radius * 0.5, 0, Math.PI * 2);
    ctx.fillStyle = '#EEF4FF';
    ctx.fill();
  }

  function drawSlots() {
    for (const s of slots) {
      // soft glowing slot background
      ctx.save();
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.radius + 6, 0, Math.PI * 2);
      ctx.fillStyle = '#FFF8E1';
      ctx.globalAlpha = 0.6;
      ctx.fill();
      ctx.restore();

      // actual slot ring
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);
      ctx.fillStyle = '#FFF';
      ctx.fill();
      ctx.lineWidth = 4;
      ctx.strokeStyle = '#C9DFF5';
      ctx.stroke();

      // label area for placeholder
      ctx.fillStyle = '#A8C8FF';
      ctx.font = '14px Verdana, Arial';
      ctx.textAlign = 'center';
      ctx.fillText(' slot ', s.x, s.y - s.radius - 10);

      // highlight when filled
      if (s.filledBy) {
        // draw connecting bolts
        ctx.beginPath();
        ctx.moveTo(s.x - s.radius - 8, s.y + s.radius + 4);
        ctx.lineTo(s.x + s.radius + 8, s.y + s.radius + 4);
        ctx.strokeStyle = '#E0F0FF';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }
  }

  function drawCog(cog) {
    // Gear body
    const cx = cog.x;
    const cy = cog.y;
    const r = cog.radius;
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(cog.rotation);
    // Draw gear teeth
    const teeth = 12;
    for (let i = 0; i < teeth; i++) {
      const angle = (i / teeth) * Math.PI * 2;
      const tx = Math.cos(angle);
      const ty = Math.sin(angle);
      ctx.beginPath();
      ctx.fillStyle = '#FDEBD3';
      const toothWidth = 8;
      const ToothOuter = r + 8;
      ctx.moveTo(tx * (r + 2), ty * (r + 2));
      ctx.lineTo(tx * (ToothOuter), ty * (ToothOuter));
      ctx.lineTo(Math.cos(angle + 0.08) * (r + 2), Math.sin(angle + 0.08) * (r + 2));
      ctx.closePath();
      ctx.fill();
    }
    // gear circle
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fillStyle = '#FFFBF1';
    ctx.fill();
    ctx.lineWidth = 4;
    ctx.strokeStyle = '#F2D6A8';
    ctx.stroke();

    // center hole
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.42, 0, Math.PI * 2);
    ctx.fillStyle = '#FFEFC9';
    ctx.fill();

    // number
    ctx.fillStyle = '#6B4F23';
    ctx.font = 'bold 22px Verdana, Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(String(cog.value), 0, 0);

    // subtle highlight
    ctx.beginPath();
    ctx.arc(-r * 0.3, -r * 0.4, r * 0.18, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.fill();

    // hover/focus ring
    if (cog === selectedCog) {
      ctx.beginPath();
      ctx.arc(0, 0, r + 6, 0, Math.PI * 2);
      ctx.strokeStyle = '#77C0FF';
      ctx.lineWidth = 3;
      ctx.stroke();
    } else if (cog.hover) {
      ctx.beginPath();
      ctx.arc(0, 0, r + 4, 0, Math.PI * 2);
      ctx.strokeStyle = '#BDE6FF';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawPanelInfo() {
    // Target display and instructions
    const level = levels[levelIndex];
    // target box
    ctx.fillStyle = '#FFF7E8';
    drawRoundedRect(36, 18, 300, 84, 10);
    ctx.fillStyle = '#FFEDD8';
    drawRoundedRect(42, 24, 288, 72, 8);

    ctx.fillStyle = '#5B6C80';
    ctx.font = '18px Verdana, Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Machine Math Lab', 60, 46);

    ctx.font = '32px Verdana, Arial';
    ctx.fillStyle = '#4A4A4A';
    ctx.textAlign = 'left';
    ctx.fillText('Target: ' + level.target, 60, 82);

    // Buttons drawn for sound on/off
    ctx.fillStyle = '#FFFFFF';
    drawRoundedRect(560, 18, 140, 36, 8);
    ctx.fillStyle = audioEnabled ? '#DFF7E6' : '#FFF1F1';
    drawRoundedRect(564, 22, 132, 28, 6);
    ctx.fillStyle = audioEnabled ? '#197A3A' : '#9F2B2B';
    ctx.font = '14px Verdana, Arial';
    ctx.textAlign = 'center';
    ctx.fillText(audioEnabled ? 'Sound: ON (S to toggle)' : 'Sound: OFF (S to enable)', 640, 44);

    // Mini instructions
    ctx.fillStyle = '#63707B';
    ctx.font = '12px Verdana, Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Controls: Drag gears or use keyboard. Space to test. R to reset.', 60, 106);
  }

  function render() {
    // Clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    drawMachineBackground();
    drawPanelInfo();
    drawSlots();

    // Draw machine slider/pipe connection
    ctx.beginPath();
    ctx.moveTo(420, 220);
    ctx.quadraticCurveTo(480, 260, 540, 240);
    ctx.strokeStyle = '#DCEEFF';
    ctx.lineWidth = 22;
    ctx.lineCap = 'round';
    ctx.stroke();

    // Draw cogs
    // update hover flags
    for (const c of cogs) c.hover = (c === hoveredCog);
    for (const c of cogs) {
      drawCog(c);
    }

    // Draw message panel bottom
    ctx.fillStyle = '#F6FAFF';
    drawRoundedRect(28, 360, 664, 96, 10);
    ctx.fillStyle = '#EAF4FF';
    drawRoundedRect(34, 366, 652, 84, 8);
    ctx.fillStyle = '#4C5E71';
    ctx.font = '14px Verdana, Arial';
    ctx.textAlign = 'left';
    wrapText(ctx, message, 50, 398, 620, 18);

    // Visual cue for audio state
    ctx.save();
    ctx.fillStyle = audioEnabled ? '#5DE08A' : '#FF9A9A';
    ctx.beginPath();
    ctx.arc(680, 428, 10, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // If hovered or selected, draw hint arrow
    if (hoveredCog || selectedCog) {
      const c = hoveredCog || selectedCog;
      ctx.beginPath();
      ctx.moveTo(c.x + c.radius + 12, c.y - c.radius - 8);
      ctx.lineTo(c.x + c.radius + 36, c.y - c.radius - 26);
      ctx.strokeStyle = '#9FCBFF';
      ctx.lineWidth = 3;
      ctx.stroke();
    }
  }

  function renderVictory() {
    // celebration screen
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    const grad = ctx.createLinearGradient(0, 0, WIDTH, HEIGHT);
    grad.addColorStop(0, '#FFF7E9');
    grad.addColorStop(1, '#E9FFF3');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    ctx.fillStyle = '#2E5D6E';
    ctx.font = 'bold 36px Verdana, Arial';
    ctx.textAlign = 'center';
    ctx.fillText('You fixed all the machines!', WIDTH / 2, HEIGHT / 2 - 30);
    ctx.font = '20px Verdana, Arial';
    ctx.fillText('Thanks for playing — Great job!', WIDTH / 2, HEIGHT / 2 + 8);

    // Draw confetti gears
    for (let i = 0; i < 12; i++) {
      const x = 80 + i * 55;
      const y = 320 + (i % 3) * 18;
      drawTinyGear(x, y, (i % 4) + 3, ['#FFCC66', '#C8F2FF', '#FFECF0'][i % 3]);
    }
    // Stop background hum gradually
    stopBackgroundHum();
    updateLiveRegion('Victory! You fixed all the machines. Refresh to play again.');
  }

  function drawTinyGear(cx, cy, r, color) {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate((cx + cy) * 0.02);
    ctx.fillStyle = color;
    ctx.beginPath();
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2;
      ctx.lineTo(Math.cos(angle) * (r + 1.8), Math.sin(angle) * (r + 1.8));
      ctx.lineTo(Math.cos(angle + 0.1) * r, Math.sin(angle + 0.1) * r);
    }
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.arc(0, 0, r - 1, 0, Math.PI * 2);
    ctx.fillStyle = '#FFF';
    ctx.fill();
    ctx.restore();
  }

  function wrapText(context, text, x, y, maxWidth, lineHeight) {
    const words = text.split(' ');
    let line = '';
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + ' ';
      const metrics = context.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        context.fillText(line, x, y);
        line = words[n] + ' ';
        y += lineHeight;
      } else {
        line = testLine;
      }
    }
    context.fillText(line, x, y);
  }

  // Accessibility live region update
  function updateLiveRegion(text) {
    if (!liveRegion) return;
    liveRegion.textContent = text;
  }

  // Animation loop for gentle cog rotation
  let lastTime = performance.now();
  function animate(t) {
    const dt = (t - lastTime) / 1000;
    lastTime = t;
    for (const c of cogs) {
      // rotate slightly
      c.rotation += dt * 0.6 * (c.value % 3 + 1) * 0.02;
      // settle back if not dragging
      if (!c.isDragging && !c.placedSlot) {
        // subtle bob
        c.y += Math.sin(t / 800 + c.value) * 0.02;
      }
    }
    // update hover/selected visuals
    render();
    requestAnimationFrame(animate);
  }

  // Event listeners
  canvas.addEventListener('pointerdown', pointerDown, { passive: false });
  canvas.addEventListener('pointermove', pointerMove, { passive: false });
  window.addEventListener('pointerup', pointerUp, { passive: false });

  canvas.addEventListener('mousemove', (e) => {
    // update hoveredCog
    const p = getPointerPos(e);
    let hover = null;
    for (let i = cogs.length - 1; i >= 0; i--) {
      const c = cogs[i];
      const dx = p.x - c.x;
      const dy = p.y - c.y;
      if (Math.hypot(dx, dy) <= c.radius + 6) {
        hover = c;
        break;
      }
    }
    hoveredCog = hover;
    render();
  });

  canvas.addEventListener('keydown', keyDown, false);
  // Also allow keyboard interaction on container
  container.addEventListener('keydown', keyDown, false);

  // Make sure audio toggles on click too (for mobile)
  canvas.addEventListener('click', () => {
    try {
      resumeAudioOnGesture();
    } catch (e) {
      console.warn('Audio resume click error', e);
    }
  });

  // Setup initial level and start
  setupLevel(0);
  requestAnimationFrame(animate);

  // Provide some public error handling if audio unavailable
  if (!initAudio()) {
    // draw a small notice on canvas and update live region
    message = 'Audio unavailable. The game will still work without sound. Click to attempt enabling sound.';
    updateLiveRegion(message);
    render();
  }
})();
---

