# Game of the Day - 2025-09-15

## Metadata
- **Generated Date:** 2025-09-15
- **Generated Time:** 2025-09-15T00:29:06.635003
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-15.js
- **File Size:** 32078 bytes
- **Tokens Used:** 10767

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-15.js` - The playable game
- `2025-09-15.meta.json` - Machine-readable metadata
- `2025-09-15.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 21881

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 23076

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Machine Math Workshop - JavaScript game
// Renders inside element with id "game-of-the-day-stage"
// Canvas size: 720 x 480
// Uses Web Audio API (oscillators) for sounds
// Accessible: keyboard, screen-reader live region, visual audio cue
// No external assets. All drawing with canvas API.

// Immediately invoked function to avoid global leakage
(function () {
  // Constants
  const WIDTH = 720;
  const HEIGHT = 480;
  const STAGE_ID = "game-of-the-day-stage";
  const MAX_LEVELS = 6;
  const GEAR_COUNT = 7; // gears shown per level
  const FONT = "16px system-ui, -apple-system, 'Segoe UI', Roboto";
  const LARGE_FONT = "20px system-ui, -apple-system, 'Segoe UI', Roboto";

  // Stage and DOM setup
  const stageElem = document.getElementById(STAGE_ID);
  if (!stageElem) {
    console.error(`Element with id "${STAGE_ID}" not found. Game cannot start.`);
    return;
  }

  // Create a live region for screen reader feedback and instructions
  const liveRegion = document.createElement("div");
  liveRegion.setAttribute("aria-live", "polite");
  liveRegion.setAttribute("aria-atomic", "true");
  liveRegion.style.position = "absolute";
  liveRegion.style.left = "-9999px";
  liveRegion.style.width = "1px";
  liveRegion.style.height = "1px";
  liveRegion.style.overflow = "hidden";
  stageElem.appendChild(liveRegion);

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.width = WIDTH + "px";
  canvas.style.height = HEIGHT + "px";
  canvas.setAttribute("role", "application");
  canvas.setAttribute("aria-label", "Machine Math Workshop. Use arrow keys to pick gears and press Enter to add them to the machine. Press P to process.");
  canvas.tabIndex = 0; // focusable for keyboard
  stageElem.appendChild(canvas);

  const ctx = canvas.getContext("2d", { alpha: false });

  // Scale for crisp text on high DPI
  function setPixelRatio() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = WIDTH * dpr;
    canvas.height = HEIGHT * dpr;
    canvas.style.width = WIDTH + "px";
    canvas.style.height = HEIGHT + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  setPixelRatio();
  window.addEventListener("resize", setPixelRatio);

  // Audio setup
  let audioCtx = null;
  let masterGain = null;
  let bgGain = null;
  let bgOsc = null;
  let audioEnabled = true;
  let audioInitError = null;

  function initAudio(onUserGesture = false) {
    if (audioCtx) return;
    try {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AudioContext();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.9;
      masterGain.connect(audioCtx.destination);

      // Background hum
      bgOsc = audioCtx.createOscillator();
      bgOsc.type = "sine";
      bgOsc.frequency.value = 120; // gentle base
      const bgFilter = audioCtx.createBiquadFilter();
      bgFilter.type = "lowpass";
      bgFilter.frequency.value = 600;
      bgGain = audioCtx.createGain();
      bgGain.gain.value = 0.02; // subtle
      bgOsc.connect(bgFilter);
      bgFilter.connect(bgGain);
      bgGain.connect(masterGain);
      bgOsc.start();

      // Smoothly ramp down if audio should be muted
      if (!audioEnabled) {
        masterGain.gain.value = 0;
      }

      // Announce readiness
      updateLiveRegion("Audio initialized.");
    } catch (e) {
      audioInitError = e;
      console.error("Audio initialization error:", e);
      updateLiveRegion("Audio unavailable in this browser.");
      audioEnabled = false;
    }
  }

  // Play a short tone (for clicks)
  function playTone(freq = 440, duration = 0.12, type = "sine", volume = 0.12) {
    if (audioInitError || !audioEnabled) return;
    try {
      if (!audioCtx) initAudio();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = volume;
      o.connect(g);
      g.connect(masterGain);
      const t = audioCtx.currentTime;
      g.gain.setValueAtTime(volume, t);
      g.gain.exponentialRampToValueAtTime(0.0001, t + duration);
      o.start(t);
      o.stop(t + duration + 0.02);
    } catch (e) {
      console.error("playTone error:", e);
    }
  }

  // Positive chime sequence
  function playPositive() {
    if (audioInitError || !audioEnabled) return;
    try {
      if (!audioCtx) initAudio();
      const now = audioCtx.currentTime;
      const freqs = [660, 880, 990];
      freqs.forEach((f, i) => {
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = "sine";
        o.frequency.value = f;
        g.gain.value = 0.0001;
        o.connect(g);
        g.connect(masterGain);
        const start = now + i * 0.09;
        g.gain.setValueAtTime(0.0001, start);
        g.gain.linearRampToValueAtTime(0.12, start + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, start + 0.28);
        o.start(start);
        o.stop(start + 0.32);
      });
      updateLiveRegion("Correct! Target reached.");
    } catch (e) {
      console.error("playPositive error:", e);
    }
  }

  // Negative thud
  function playNegative() {
    if (audioInitError || !audioEnabled) return;
    try {
      if (!audioCtx) initAudio();
      const o1 = audioCtx.createOscillator();
      const o2 = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const fNoise = audioCtx.createBiquadFilter();
      o1.type = "sawtooth";
      o1.frequency.value = 120;
      o2.type = "sine";
      o2.frequency.value = 80;
      g.gain.value = 0.0001;
      const t = audioCtx.currentTime;
      o1.connect(g);
      o2.connect(g);
      g.connect(masterGain);
      g.gain.setValueAtTime(0.0001, t);
      g.gain.linearRampToValueAtTime(0.18, t + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.25);
      o1.start(t);
      o2.start(t);
      o1.stop(t + 0.3);
      o2.stop(t + 0.3);
      updateLiveRegion("That went over the target. Try again.");
    } catch (e) {
      console.error("playNegative error:", e);
    }
  }

  // Gentle click
  function playClick() {
    playTone(880, 0.06, "square", 0.06);
  }

  // Toggle audio on/off
  function toggleAudio() {
    audioEnabled = !audioEnabled;
    if (!audioCtx) {
      // require gesture to create audio; will initialize on next user gesture
      if (audioEnabled) {
        updateLiveRegion("Audio enabled. Tap to start sounds.");
      } else {
        updateLiveRegion("Audio disabled.");
      }
    } else {
      try {
        if (audioEnabled) {
          masterGain.gain.setTargetAtTime(0.9, audioCtx.currentTime, 0.05);
          bgGain.gain.setTargetAtTime(0.02, audioCtx.currentTime, 0.05);
          updateLiveRegion("Audio on.");
        } else {
          masterGain.gain.setTargetAtTime(0.0001, audioCtx.currentTime, 0.05);
          updateLiveRegion("Audio off.");
        }
      } catch (e) {
        console.error("toggleAudio error:", e);
      }
    }
  }

  // Game state
  let levels = [];
  let currentLevelIndex = 0;
  let gears = []; // gear objects for current level
  let selectedIDs = []; // ids of gears currently placed in machine slot
  let takenIDs = new Set(); // gears that have been moved into slot
  let processing = false;
  let focusIndex = 0; // keyboard focus for gear selection or control
  let attempts = 0;
  let showHint = false;
  let animationTime = 0;

  // Layout locations
  const conveyorY = HEIGHT - 110;
  const conveyorLeft = 24;
  const conveyorRight = WIDTH - 240;
  const machineX = WIDTH - 200;
  const machineY = 60;

  // Create levels algorithmically to ensure solvable puzzle
  function generateLevels(num) {
    const arr = [];
    for (let i = 0; i < num; i++) {
      // difficulty increases: target grows
      const difficulty = 1 + i;
      const targetMin = 6 + difficulty * 3;
      const targetMax = 12 + difficulty * 4;
      const target = randInt(targetMin, targetMax);
      // create a subset that sums to target
      // We'll pick k numbers that sum to target, where each is 1..9
      let subset = [];
      let remaining = target;
      let k = randInt(2, Math.min(5, Math.max(2, Math.floor(target / 2))));
      // Fill subset with random numbers but ensure total equals target
      for (let s = 0; s < k - 1; s++) {
        const maxVal = Math.min(9, remaining - (k - s - 1) * 1);
        const val = randInt(1, Math.max(1, maxVal));
        subset.push(val);
        remaining -= val;
      }
      subset.push(Math.max(1, remaining));
      // If any >9, break into pieces
      let fixed = [];
      subset.forEach((v) => {
        if (v <= 9) fixed.push(v);
        else {
          let r = v;
          while (r > 9) {
            fixed.push(9);
            r -= 9;
          }
          if (r > 0) fixed.push(r);
        }
      });
      // create gears including subset and distractors
      const gearVals = fixed.slice();
      while (gearVals.length < GEAR_COUNT - 1) {
        gearVals.push(randInt(1, 9));
      }
      // Shuffle and ensure at least one solution: the fixed subset is within the set
      // Add an extra random gear for challenge
      gearVals.push(randInt(1, 9));
      shuffleArray(gearVals);
      arr.push({ target: target, gearValues: gearVals });
    }
    return arr;
  }

  // Utility helpers
  function randInt(a, b) {
    return Math.floor(Math.random() * (b - a + 1)) + a;
  }
  function shuffleArray(a) {
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
  }

  // Initialize first levels
  levels = generateLevels(MAX_LEVELS);

  // Create gear objects for a level
  function setupLevel(index) {
    gears = [];
    selectedIDs = [];
    takenIDs = new Set();
    attempts = 0;
    processing = false;
    focusIndex = 0;
    showHint = false;
    const data = levels[index];
    const values = data.gearValues.slice();
    // Place gears evenly on conveyor
    const spacing = (conveyorRight - conveyorLeft) / (values.length);
    for (let i = 0; i < values.length; i++) {
      const x = conveyorLeft + spacing * i + spacing / 2;
      const y = conveyorY + randInt(-6, 6);
      const id = `L${index}G${i}`;
      gears.push({
        id,
        value: values[i],
        x,
        y,
        radius: 30 + (i % 2 ? 2 : 0),
        angle: 0,
        wobble: Math.random() * Math.PI * 2,
        taken: false,
        visible: true,
      });
    }
    // Announce level
    updateLiveRegion(
      `Level ${index + 1}. Build total ${data.target} using the gears below. Use arrow keys to pick and Enter to move a gear to the machine.`
    );
  }

  // Start first level
  setupLevel(currentLevelIndex);

  // Drawing helpers
  function clearCanvas() {
    // calming gradient background
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, "#eaf6ff");
    g.addColorStop(1, "#f7fbf5");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
  }

  function drawTitle() {
    ctx.save();
    ctx.font = "bold 24px system-ui, -apple-system, 'Segoe UI', Roboto";
    ctx.fillStyle = "#244";
    ctx.fillText("Machine Math Workshop", 20, 34);
    ctx.restore();
  }

  function drawInstructions() {
    ctx.save();
    ctx.font = FONT;
    ctx.fillStyle = "#233";
    ctx.globalAlpha = 0.9;
    const instructions = [
      "Pick gears and put them into the machine so their sum equals the target number.",
      "Keyboard: Left/Right to move, Enter/Space to pick/unpick, P to process, R to reset, S to toggle sound.",
      "Click a gear to pick it, click a gear in the slot to return it.",
    ];
    for (let i = 0; i < instructions.length; i++) {
      ctx.fillText(instructions[i], 20, 62 + i * 18);
    }
    ctx.restore();
  }

  function drawMachineOutline() {
    // Machine body
    ctx.save();
    ctx.fillStyle = "#dde8f0";
    ctx.fillRect(machineX, machineY, 180, 320);
    // Screen
    ctx.fillStyle = "#122";
    ctx.fillRect(machineX + 16, machineY + 18, 148, 58);
    // Display window border
    ctx.strokeStyle = "#9ad";
    ctx.lineWidth = 2;
    ctx.strokeRect(machineX + 16, machineY + 18, 148, 58);
    // Slots area
    ctx.fillStyle = "#cfe3e8";
    ctx.fillRect(machineX + 16, machineY + 92, 148, 150);
    ctx.strokeStyle = "#b4cbd3";
    ctx.strokeRect(machineX + 16, machineY + 92, 148, 150);
    // Base
    ctx.fillStyle = "#d4dbe2";
    ctx.fillRect(machineX + 16, machineY + 256, 148, 24);
    ctx.restore();
  }

  function drawMachineDisplay(target, currentSum, processingAnim) {
    // Dark screen
    ctx.save();
    ctx.font = "bold 22px system-ui, -apple-system, 'Segoe UI', Roboto";
    // screen background
    const sx = machineX + 16;
    const sy = machineY + 18;
    const sw = 148;
    const sh = 58;
    // glow effect if processing
    if (processingAnim) {
      const g = ctx.createLinearGradient(sx, sy, sx + sw, sy + sh);
      g.addColorStop(0, "#dfffdc");
      g.addColorStop(1, "#bde6ff");
      ctx.fillStyle = g;
    } else {
      ctx.fillStyle = "#0c2a2d";
    }
    ctx.fillRect(sx, sy, sw, sh);
    // text
    ctx.fillStyle = processingAnim ? "#135" : "#8fe3ff";
    ctx.fillText(`Target: ${target}`, sx + 10, sy + 30);
    ctx.font = "bold 20px system-ui, -apple-system, 'Segoe UI', Roboto";
    ctx.fillText(`Sum: ${currentSum}`, sx + 10, sy + 52);
    ctx.restore();
  }

  function drawGears() {
    gears.forEach((g, i) => {
      if (!g.visible) return;
      // subtle rotation
      g.angle += 0.004 + (i % 3) * 0.001;
      drawGear(g.x, g.y, g.radius, g.value, g.angle, g.taken, i === focusIndex && !g.taken);
    });
    // conveyor
    ctx.save();
    ctx.fillStyle = "#e6f1f4";
    ctx.fillRect(conveyorLeft - 10, conveyorY - 12, conveyorRight - conveyorLeft + 20, 70);
    ctx.strokeStyle = "#bcd";
    ctx.strokeRect(conveyorLeft - 10, conveyorY - 12, conveyorRight - conveyorLeft + 20, 70);
    ctx.restore();
  }

  function drawGear(x, y, r, label, angle = 0, taken = false, focused = false) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    // shadow
    ctx.fillStyle = "rgba(20,20,24,0.06)";
    ctx.beginPath();
    ctx.ellipse(6, 6, r + 6, r + 2, 0, 0, Math.PI * 2);
    ctx.fill();

    // gear teeth
    const teeth = 10;
    for (let t = 0; t < teeth; t++) {
      const theta = (t / teeth) * Math.PI * 2;
      const tx = Math.cos(theta) * (r + 6);
      const ty = Math.sin(theta) * (r + 6);
      ctx.fillStyle = "#cbe";
      ctx.fillRect(tx - 4, ty - 3, 8, 6);
    }

    // body
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fillStyle = taken ? "#f0efd6" : "#fff9f0";
    ctx.fill();
    ctx.lineWidth = 3;
    ctx.strokeStyle = focused ? "#2a6d8c" : "#d0cbc0";
    ctx.stroke();

    // inner circle
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.6, 0, Math.PI * 2);
    ctx.fillStyle = taken ? "#e7f2ff" : "#f3f8ff";
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#b7cbd4";
    ctx.stroke();

    // number
    ctx.fillStyle = "#153";
    ctx.font = "bold 18px system-ui, -apple-system, 'Segoe UI', Roboto";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(String(label), 0, 0);

    // focus ring
    if (focused) {
      ctx.lineWidth = 3;
      ctx.strokeStyle = "#ffda6b";
      ctx.beginPath();
      ctx.arc(0, 0, r + 8, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawSlotGears() {
    // Display selected gears in machine slot area
    const sx = machineX + 28;
    const sy = machineY + 106;
    const slotW = 124;
    const slotH = 132;
    const slotPadding = 12;
    const slotCols = 3;
    const slotRows = Math.ceil(selectedIDs.length / slotCols);
    const cellW = (slotW - slotPadding * 2) / slotCols;
    const cellH = 44;
    for (let i = 0; i < selectedIDs.length; i++) {
      const id = selectedIDs[i];
      const gear = gears.find((g) => g.id === id);
      if (!gear) continue;
      const col = i % slotCols;
      const row = Math.floor(i / slotCols);
      const gx = sx + slotPadding + col * cellW + cellW / 2;
      const gy = sy + slotPadding + row * (cellH + 6) + cellH / 2;
      drawGear(gx, gy, 20, gear.value, gear.angle + 0.2 * Math.sin(animationTime / 180 + i), true, false);
    }
  }

  function drawControls() {
    // Buttons: PROCESS, RESET, SOUND
    ctx.save();
    ctx.font = "bold 16px system-ui, -apple-system, 'Segoe UI', Roboto";

    // Process button
    const bx = machineX + 36;
    const by = machineY + 284;
    ctx.fillStyle = "#8ad2d8";
    ctx.fillRect(bx, by, 110, 28);
    ctx.strokeStyle = "#6bb0b6";
    ctx.strokeRect(bx, by, 110, 28);
    ctx.fillStyle = "#052";
    ctx.fillText("PROCESS (P)", bx + 6, by + 19);

    // Reset
    const rx = machineX + 36;
    const ry = machineY + 320;
    ctx.fillStyle = "#ffe5d9";
    ctx.fillRect(rx, ry, 110, 26);
    ctx.strokeStyle = "#f8c0ae";
    ctx.strokeRect(rx, ry, 110, 26);
    ctx.fillStyle = "#5a2313";
    ctx.fillText("RESET (R)", rx + 6, ry + 18);

    // Sound indicator
    const sxIcon = machineX + 36;
    const syIcon = machineY + 354;
    ctx.fillStyle = audioEnabled ? "#d2ffd8" : "#ffdede";
    ctx.fillRect(sxIcon, syIcon, 110, 26);
    ctx.strokeStyle = audioEnabled ? "#9fd89e" : "#f1a3a3";
    ctx.strokeRect(sxIcon, syIcon, 110, 26);
    ctx.fillStyle = audioEnabled ? "#063" : "#630";
    ctx.fillText((audioEnabled ? "SOUND ON (S)" : "SOUND OFF (S)"), sxIcon + 6, syIcon + 18);

    // Small visual audio pulse
    if (audioEnabled && audioCtx) {
      ctx.fillStyle = "rgba(30,120,140,0.12)";
      ctx.beginPath();
      const px = sxIcon + 92;
      const py = syIcon + 13;
      const pulse = 4 + 2 * Math.sin(animationTime / 90);
      ctx.arc(px, py, pulse + 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#0b5";
      ctx.beginPath();
      ctx.arc(px, py, pulse, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.restore();
  }

  function drawLevelIndicator() {
    ctx.save();
    ctx.font = "16px system-ui, -apple-system, 'Segoe UI', Roboto";
    ctx.fillStyle = "#234";
    ctx.fillText(`Level ${currentLevelIndex + 1} of ${MAX_LEVELS}`, WIDTH - 180, 34);
    ctx.restore();
  }

  function drawHint() {
    if (!showHint) return;
    const data = levels[currentLevelIndex];
    const hintText = `Hint: Try using these numbers: ${getHintSubset(data).join(", ")}`;
    ctx.save();
    ctx.font = "14px system-ui, -apple-system, 'Segoe UI', Roboto";
    ctx.fillStyle = "rgba(10,10,10,0.7)";
    ctx.fillRect(20, HEIGHT - 44, 540, 34);
    ctx.fillStyle = "#fff";
    ctx.fillText(hintText, 28, HEIGHT - 22);
    ctx.restore();
  }

  // Compute current sum of selected gears
  function currentSum() {
    return selectedIDs.reduce((s, id) => {
      const g = gears.find((gr) => gr.id === id);
      return s + (g ? g.value : 0);
    }, 0);
  }

  // Get hint subset (a useful subset that sums to target)
  function getHintSubset(levelData) {
    // We'll attempt to find small subset of gear values that sum to target using subset-sum DP
    const arr = levelData.gearValues;
    const target = levelData.target;
    const n = arr.length;
    // dp[i][s] = index of last element used or -1
    const dp = Array.from({ length: target + 1 }, () => -1);
    dp[0] = -2; // base
    const parent = Array(target + 1).fill(-1);
    for (let i = 0; i < n; i++) {
      const v = arr[i];
      for (let s = target; s >= v; s--) {
        if (dp[s - v] !== -1 && dp[s] === -1) {
          dp[s] = i;
          parent[s] = s - v;
        }
      }
    }
    if (dp[target] === -1) {
      return [Math.min(...arr)]; // fallback
    }
    // reconstruct subset
    let s = target;
    const chosen = [];
    while (s > 0 && dp[s] !== -1) {
      chosen.push(arr[dp[s]]);
      s = parent[s];
    }
    return chosen;
  }

  // Drawing main frame
  function render() {
    animationTime++;
    clearCanvas();
    drawTitle();
    drawInstructions();
    drawMachineOutline();
    const data = levels[currentLevelIndex];
    drawMachineDisplay(data.target, currentSum(), processing);
    drawGears();
    drawSlotGears();
    drawControls();
    drawLevelIndicator();
    drawHint();

    // small footer
    ctx.save();
    ctx.font = "12px system-ui, -apple-system, 'Segoe UI', Roboto";
    ctx.fillStyle = "#234";
    ctx.fillText("Tip: You can remove a gear from the slot by clicking it.", 20, HEIGHT - 8);
    ctx.restore();

    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);

  // Interaction handlers
  function pickGearById(id) {
    const gear = gears.find((g) => g.id === id);
    if (!gear || gear.taken) return;
    playClick();
    gear.taken = true;
    takenIDs.add(id);
    selectedIDs.push(id);
    updateLiveRegion(`Picked gear ${gear.value} and placed in machine.`);
  }

  function unpickGearById(id) {
    const idx = selectedIDs.indexOf(id);
    if (idx === -1) return;
    const gear = gears.find((g) => g.id === id);
    selectedIDs.splice(idx, 1);
    if (gear) gear.taken = false;
    takenIDs.delete(id);
    playClick();
    updateLiveRegion(`Returned gear ${gear.value} to the conveyor.`);
  }

  // Click position to id mapping
  function gearAtPos(px, py) {
    for (let i = gears.length - 1; i >= 0; i--) {
      const g = gears[i];
      if (!g.visible) continue;
      const dx = px - g.x;
      const dy = py - g.y;
      if (dx * dx + dy * dy <= (g.radius + 6) * (g.radius + 6)) return g.id;
    }
    // check slot area for selected gears
    const sx = machineX + 28;
    const sy = machineY + 106;
    const slotW = 124;
    const slotPadding = 12;
    const slotCols = 3;
    for (let i = 0; i < selectedIDs.length; i++) {
      const id = selectedIDs[i];
      const gear = gears.find((g) => g.id === id);
      const col = i % slotCols;
      const row = Math.floor(i / slotCols);
      const gx = sx + slotPadding + col * ((slotW - slotPadding * 2) / slotCols) + (slotW - slotPadding * 2) / (slotCols * 2);
      const gy = sy + slotPadding + row * (44 + 6) + 22;
      const dx = px - gx;
      const dy = py - gy;
      if (dx * dx + dy * dy <= 20 * 20) return id; // return slot gear id
    }
    // buttons
    const bx = machineX + 36;
    const by = machineY + 284;
    if (px >= bx && px <= bx + 110 && py >= by && py <= by + 28) return "BTN_PROCESS";
    const rx = machineX + 36;
    const ry = machineY + 320;
    if (px >= rx && px <= rx + 110 && py >= ry && py <= ry + 26) return "BTN_RESET";
    const sxIcon = machineX + 36;
    const syIcon = machineY + 354;
    if (px >= sxIcon && px <= sxIcon + 110 && py >= syIcon && py <= syIcon + 26) return "BTN_SOUND";
    return null;
  }

  canvas.addEventListener("mousedown", (ev) => {
    // initialize audio on first user gesture (some browsers require)
    if (!audioCtx && audioEnabled) {
      try {
        initAudio(true);
        if (audioCtx && audioCtx.state === "suspended") {
          audioCtx.resume().catch((e) => console.warn("Audio resume failed", e));
        }
      } catch (e) {
        console.warn("Audio init on mousedown failed", e);
      }
    }

    const rect = canvas.getBoundingClientRect();
    const px = ev.clientX - rect.left;
    const py = ev.clientY - rect.top;
    const hit = gearAtPos(px, py);
    if (!hit) {
      return;
    }
    if (hit === "BTN_PROCESS") {
      processMachine();
      return;
    }
    if (hit === "BTN_RESET") {
      resetLevel();
      return;
    }
    if (hit === "BTN_SOUND") {
      toggleAudio();
      return;
    }
    // If clicked a selected slot gear, return it
    if (selectedIDs.includes(hit)) {
      unpickGearById(hit);
      return;
    }
    // pick gear if on conveyor
    pickGearById(hit);
  });

  // Keyboard controls
  canvas.addEventListener("keydown", (ev) => {
    // initialize audio on first gesture
    if (!audioCtx && audioEnabled) {
      try {
        initAudio(true);
        if (audioCtx && audioCtx.state === "suspended") {
          audioCtx.resume().catch((e) => console.warn("Audio resume failed", e));
        }
      } catch (e) {
        console.warn("Audio init on keydown failed", e);
      }
    }

    const code = ev.key;
    if (code === "ArrowRight") {
      // move focus to next visible gear
      let i = focusIndex;
      for (let c = 0; c < gears.length; c++) {
        i = (i + 1) % gears.length;
        if (!gears[i].taken) {
          focusIndex = i;
          break;
        }
      }
      ev.preventDefault();
      playTone(660, 0.05, "sine", 0.04);
    } else if (code === "ArrowLeft") {
      let i = focusIndex;
      for (let c = 0; c < gears.length; c++) {
        i = (i - 1 + gears.length) % gears.length;
        if (!gears[i].taken) {
          focusIndex = i;
          break;
        }
      }
      ev.preventDefault();
      playTone(550, 0.05, "sine", 0.04);
    } else if (code === " " || code === "Enter") {
      // pick/unpick focused gear
      const g = gears[focusIndex];
      if (g) {
        if (selectedIDs.includes(g.id)) {
          unpickGearById(g.id);
        } else {
          pickGearById(g.id);
        }
      }
      ev.preventDefault();
    } else if (code.toLowerCase() === "p") {
      processMachine();
      ev.preventDefault();
    } else if (code.toLowerCase() === "r") {
      resetLevel();
      ev.preventDefault();
    } else if (code.toLowerCase() === "s") {
      toggleAudio();
      ev.preventDefault();
    } else if (code.toLowerCase() === "h") {
      showHint = !showHint;
      updateLiveRegion(showHint ? "Hint shown." : "Hint hidden.");
      ev.preventDefault();
    }
  });

  function processMachine() {
    if (processing) return;
    attempts++;
    const sum = currentSum();
    const target = levels[currentLevelIndex].target;
    processing = true;
    playTone(420, 0.06, "sine", 0.06);
    updateLiveRegion(`Processing... Current sum is ${sum}.`);
    // animate a short delay
    setTimeout(() => {
      if (sum === target) {
        // success
        playPositive();
        processing = false;
        // clear selected gears visually and proceed to next level after animation
        animateSuccess(() => {
          currentLevelIndex++;
          if (currentLevelIndex >= MAX_LEVELS) {
            announceVictory();
          } else {
            setupLevel(currentLevelIndex);
            playTone(720, 0.12, "sine", 0.08);
          }
        });
      } else if (sum > target) {
        // incorrect (over)
        playNegative();
        processing = false;
        updateLiveRegion("Sum is over the target. Try removing a gear.");
      } else {
        // sum < target: encourage more picks
        playTone(520, 0.08, "triangle", 0.06);
        processing = false;
        updateLiveRegion("Not enough yet. Pick more gears.");
      }
    }, 700);
  }

  function animateSuccess(callback) {
    // Simple animation: spin selected gears out and show confetti
    const confetti = [];
    for (let i = 0; i < 18; i++) {
      confetti.push({
        x: machineX + 50 + Math.random() * 80,
        y: machineY + 80 + Math.random() * 80,
        vx: (Math.random() - 0.5) * 6,
        vy: -Math.random() * 6 - 2,
        color: ["#ff7b7b", "#ffd47b", "#7be28a", "#7bd9ff"][i % 4],
        size: 4 + Math.random() * 6,
      });
    }
    let t = 0;
    const steps = 60;
    const anim = () => {
      t++;
      // draw confetti over canvas
      ctx.save();
      confetti.forEach((c) => {
        c.x += c.vx;
        c.y += c.vy;
        c.vy += 0.18;
        ctx.fillStyle = c.color;
        ctx.fillRect(c.x, c.y, c.size, c.size);
      });
      ctx.restore();
      if (t < steps) {
        requestAnimationFrame(anim);
      } else {
        // clear selection
        selectedIDs.forEach((id) => {
          const gear = gears.find((g) => g.id === id);
          if (gear) gear.visible = false;
        });
        selectedIDs = [];
        updateLiveRegion("Great job! Moving to the next level.");
        callback();
      }
    };
    anim();
  }

  function resetLevel() {
    // return all selected gears
    selectedIDs.forEach((id) => {
      const g = gears.find((gg) => gg.id === id);
      if (g) g.taken = false;
      takenIDs.delete(id);
    });
    selectedIDs = [];
    attempts = 0;
    playClick();
    updateLiveRegion("Level has been reset.");
  }

  function announceVictory() {
    updateLiveRegion("Congratulations! You completed all levels. You win!");
    playPositive();
    // Show big confetti in canvas
    const confetti = [];
    for (let i = 0; i < 120; i++) {
      confetti.push({
        x: Math.random() * WIDTH,
        y: -Math.random() * 200,
        vx: (Math.random() - 0.5) * 4,
        vy: Math.random() * 4 + 1,
        color: ["#ff7b7b", "#ffd47b", "#7be28a", "#7bd9ff", "#d9b3ff"][i % 5],
        size: 6 + Math.random() * 8,
        rot: Math.random() * Math.PI,
      });
    }
    let t = 0;
    const anim = () => {
      t++;
      clearCanvas();
      drawTitle();
      ctx.save();
      ctx.font = "28px system-ui, -apple-system, 'Segoe UI', Roboto";
      ctx.fillStyle = "#163";
      ctx.fillText("You Fixed the Machine! You Win!", 100, 220);
      ctx.restore();
      confetti.forEach((c) => {
        c.x += c.vx;
        c.y += c.vy;
        c.vy += 0.06;
        ctx.save();
        ctx.fillStyle = c.color;
        ctx.translate(c.x, c.y);
        ctx.rotate(c.rot);
        ctx.fillRect(-c.size / 2, -c.size / 2, c.size, c.size);
        ctx.restore();
      });
      if (t < 160) {
        requestAnimationFrame(anim);
      } else {
        // final state: allow restart
        const restartMsg = document.createElement("div");
        restartMsg.style.position = "absolute";
        restartMsg.style.left = "20px";
        restartMsg.style.top = "420px";
        restartMsg.style.background = "rgba(255,255,255,0.9)";
        restartMsg.style.padding = "8px 12px";
        restartMsg.style.borderRadius = "8px";
        restartMsg.style.boxShadow = "0 2px 6px rgba(0,0,0,0.12)";
        restartMsg.innerText = "Press R to play again.";
        stageElem.appendChild(restartMsg);
        // reset to first level for replay after user hits R
      }
    };
    anim();
  }

  // Update live region for screen readers
  let lastLive = "";
  function updateLiveRegion(msg) {
    lastLive = msg;
    liveRegion.textContent = msg;
  }

  // Utility: in case of audio resume errors
  function safeResumeAudio() {
    if (audioCtx) {
      audioCtx.resume().catch((e) => {
        console.warn("Audio resume failed:", e);
      });
    }
  }

  // On first focus by keyboard, announce
  canvas.addEventListener("focus", () => {
    updateLiveRegion("Game focused. Use the keyboard or click to interact.");
  });

  // Provide error handling for audio creation on user gesture (some browsers require)
  document.addEventListener("click", function onFirstClick() {
    if (!audioCtx && audioEnabled) {
      try {
        initAudio(true);
        if (audioCtx && audioCtx.state === "suspended") {
          audioCtx.resume().catch((e) => console.warn("Audio resume failed", e));
        }
      } catch (e) {
        console.warn("Error initializing audio on click:", e);
      }
    }
    document.removeEventListener("click", onFirstClick);
  });

  // Utility: regenerate all levels when pressing R after victory
  document.addEventListener("keydown", (ev) => {
    if (ev.key.toLowerCase() === "r") {
      // Restart if all levels done or always restart current level
      if (currentLevelIndex >= MAX_LEVELS - 1) {
        // restart whole game
        levels = generateLevels(MAX_LEVELS);
        currentLevelIndex = 0;
        setupLevel(currentLevelIndex);
        updateLiveRegion("Game restarted. New levels are ready.");
      }
    }
  });

  // Expose a minimal console command safe for debugging (not necessary)
  window._machineMath = {
    reset: () => {
      currentLevelIndex = 0;
      levels = generateLevels(MAX_LEVELS);
      setupLevel(0);
    },
  };
})();
---

