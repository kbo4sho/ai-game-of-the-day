# Game of the Day - 2025-10-03

## Metadata
- **Generated Date:** 2025-10-03
- **Generated Time:** 2025-10-03T00:25:39.577124
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-10-03.js
- **File Size:** 24453 bytes
- **Tokens Used:** 8472

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-10-03.js` - The playable game
- `2025-10-03.meta.json` - Machine-readable metadata
- `2025-10-03.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 17994

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 19906

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Machine Math — Canvas Game for ages 7-9
// Renders inside element with id "game-of-the-day-stage"
// Game area exactly 720x480.
// Uses Canvas and Web Audio API only. No external resources.
// Accessible: keyboard controls, aria-live updates, visual/audio cues.

// Immediately-invoked function to avoid polluting global scope
(function () {
  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const ROUNDS = 6;
  const MAX_TRIES_BEFORE_HINT = 3;

  // Find container
  const container = document.getElementById("game-of-the-day-stage");
  if (!container) {
    console.error("Container element with ID 'game-of-the-day-stage' not found.");
    return;
  }

  // Clear container
  container.innerHTML = "";
  container.style.position = "relative";
  container.style.width = WIDTH + "px";
  container.style.height = HEIGHT + "px";
  container.style.userSelect = "none";
  container.style.outline = "none";

  // Create accessible live region for screen readers (off-screen but available)
  const liveRegion = document.createElement("div");
  liveRegion.setAttribute("aria-live", "polite");
  liveRegion.setAttribute("role", "status");
  liveRegion.style.position = "absolute";
  liveRegion.style.left = "-9999px";
  container.appendChild(liveRegion);

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.tabIndex = 0; // make focusable
  canvas.style.display = "block";
  container.appendChild(canvas);
  const ctx = canvas.getContext("2d", { alpha: false });

  // Focus canvas for keyboard events
  canvas.focus();

  // Audio setup with error handling
  let audioEnabled = true;
  let audioContext = null;
  try {
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) throw new Error("Web Audio API not supported");
    audioContext = new AC();
    // Start suspended for autoplay policy; resume on user gesture
    if (audioContext.state === "suspended") {
      audioEnabled = false; // will become true after gesture
    }
  } catch (e) {
    console.warn("Audio unavailable:", e.message);
    audioEnabled = false;
    audioContext = null;
  }

  // Audio nodes (created once audio started)
  let masterGain = null;
  let bgGain = null;
  let bgOsc = null;
  let lfoOsc = null;

  function initAudioNodes() {
    if (!audioContext) return;
    try {
      masterGain = audioContext.createGain();
      masterGain.gain.value = 0.9;
      masterGain.connect(audioContext.destination);

      // Background hum: low-volume oscillator + slow LFO to modulate frequency
      bgGain = audioContext.createGain();
      bgGain.gain.value = 0.04;
      bgGain.connect(masterGain);

      bgOsc = audioContext.createOscillator();
      bgOsc.type = "sine";
      bgOsc.frequency.value = 110; // low hum
      bgOsc.connect(bgGain);

      lfoOsc = audioContext.createOscillator();
      const lfoGain = audioContext.createGain();
      lfoGain.gain.value = 10; // modulation depth
      lfoOsc.frequency.value = 0.08; // very slow LFO
      lfoOsc.connect(lfoGain);
      lfoGain.connect(bgOsc.frequency);

      bgOsc.start();
      lfoOsc.start();
    } catch (err) {
      console.warn("Error initAudioNodes:", err);
    }
  }

  // Helper for playing a tone
  function playTone({ freq = 440, duration = 0.18, type = "sine", volume = 0.12, attack = 0.01 } = {}) {
    if (!audioContext) return;
    try {
      const now = audioContext.currentTime;
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      const filter = audioContext.createBiquadFilter();

      osc.type = type;
      osc.frequency.value = freq;

      filter.type = "lowpass";
      filter.frequency.value = Math.max(800, freq * 2);

      gain.gain.value = 0;
      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime(volume, now + attack);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);

      osc.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain || audioContext.destination);

      osc.start(now);
      osc.stop(now + duration + 0.05);
    } catch (err) {
      console.warn("playTone error:", err);
    }
  }

  // Feedback sounds
  function playCorrectSound() {
    if (!audioContext) return;
    // small ascending arpeggio
    const base = 440;
    const intervals = [0, 3, 7]; // semitone intervals
    intervals.forEach((i, idx) => {
      setTimeout(() => playTone({ freq: base * Math.pow(2, i / 12), duration: 0.16, type: "triangle", volume: 0.12 }), idx * 120);
    });
  }

  function playIncorrectSound() {
    if (!audioContext) return;
    // short buzzer
    playTone({ freq: 220, duration: 0.28, type: "sawtooth", volume: 0.14 });
    setTimeout(() => playTone({ freq: 160, duration: 0.18, type: "sawtooth", volume: 0.08 }), 180);
  }

  function playClick() {
    if (!audioContext) return;
    playTone({ freq: 900, duration: 0.06, type: "square", volume: 0.06 });
  }

  // Utility random
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // Game state
  const state = {
    round: 0,
    score: 0,
    roundsCompleted: 0,
    current: null, // current puzzle
    selectedIndex: 0,
    triesThisRound: 0,
    started: false,
    audioOn: audioEnabled && audioContext && audioContext.state === "running",
  };

  // Generate puzzle: pick target between 6 and 20; present 4 candidate single numbers; exactly one is correct (when added to base makes target)
  // Puzzle uses a "machine" with a missing gear that must be a number to make sums correct.
  function makePuzzle() {
    // We'll provide a small equation: base + ? = target, base between 1 and 12, target between base+2 and base+9 (to keep small)
    const base = randInt(1, 12);
    const add = randInt(2, 9);
    const target = base + add;
    const correct = add;
    // generate three wrong options that are plausible (close numbers)
    const options = new Set([correct]);
    while (options.size < 4) {
      let candidate = correct + randInt(-4, 4);
      if (candidate < 1) candidate = Math.abs(candidate) + 1;
      if (candidate === correct) continue;
      options.add(candidate);
    }
    // shuffle
    const arr = Array.from(options);
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    const idx = arr.indexOf(correct);
    return { base, target, options: arr, correctIndex: idx };
  }

  function startNewRound() {
    state.current = makePuzzle();
    state.selectedIndex = 0;
    state.triesThisRound = 0;
    state.round++;
    state.started = true;
    updateLive(`Round ${state.round} of ${ROUNDS}. Choose the gear to make ${state.current.base} + ? = ${state.current.target}. Use arrows and Enter, or click.`);
  }

  // Draw helper: calming wacky background with floating blobs
  let startTime = performance.now();
  function drawBackground(t) {
    const time = (t - startTime) / 1000;
    // soft pastel gradient
    const g = ctx.createLinearGradient(0, 0, WIDTH, HEIGHT);
    g.addColorStop(0, "#e9f6f2");
    g.addColorStop(0.5, "#f3eefc");
    g.addColorStop(1, "#fff5e9");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // floating blobs
    const blobs = [
      { x: 0.15, y: 0.2, r: 80, c: "rgba(200,230,255,0.12)", tx: 0.5 },
      { x: 0.7, y: 0.18, r: 100, c: "rgba(255,220,240,0.10)", tx: -0.7 },
      { x: 0.45, y: 0.7, r: 120, c: "rgba(220,255,230,0.10)", tx: 1.0 },
    ];
    blobs.forEach((b, i) => {
      const bx = WIDTH * (b.x + 0.02 * Math.sin(time * (0.3 + i * 0.1) + i));
      const by = HEIGHT * (b.y + 0.02 * Math.cos(time * (0.2 + i * 0.12) - i));
      ctx.beginPath();
      ctx.fillStyle = b.c;
      ctx.ellipse(bx, by, b.r, b.r * 0.7, Math.sin(time + i), 0, Math.PI * 2);
      ctx.fill();
    });
  }

  // Draw a gear with teeth, number in center
  function drawGear(x, y, radius, teeth, color, number, highlight = false, wobble = 0) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(wobble * 0.05);
    // body
    ctx.beginPath();
    // gear teeth: draw as alternate radius
    const innerR = radius * 0.75;
    const outerR = radius;
    for (let i = 0; i < teeth; i++) {
      const angle = (i / teeth) * Math.PI * 2;
      const angleNext = ((i + 1) / teeth) * Math.PI * 2;
      const mid = angle + (angleNext - angle) / 2;
      // first half of tooth outer arc
      if (i === 0) ctx.moveTo(Math.cos(angle) * outerR, Math.sin(angle) * outerR);
      ctx.lineTo(Math.cos(angle) * outerR, Math.sin(angle) * outerR);
      ctx.lineTo(Math.cos(mid) * outerR, Math.sin(mid) * outerR);
      ctx.lineTo(Math.cos(angleNext) * innerR, Math.sin(angleNext) * innerR);
    }
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.shadowColor = "rgba(0,0,0,0.12)";
    ctx.shadowBlur = 6;
    ctx.fill();

    // center circle
    ctx.beginPath();
    ctx.arc(0, 0, innerR * 0.6, 0, Math.PI * 2);
    ctx.fillStyle = "#fffefc";
    ctx.shadowBlur = 0;
    ctx.fill();

    // number
    ctx.fillStyle = "#2b2b2b";
    ctx.font = `bold ${Math.max(16, radius * 0.5)}px sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(String(number), 0, 0);

    // highlight ring
    if (highlight) {
      ctx.beginPath();
      ctx.arc(0, 0, outerR + 6, 0, Math.PI * 2);
      ctx.strokeStyle = "rgba(80,160,255,0.55)";
      ctx.lineWidth = 6;
      ctx.stroke();
    }
    ctx.restore();
  }

  // Draw machine visualization on left: base gear and missing gear slot
  function drawMachine(puzzle, t) {
    const time = (t - startTime) / 1000;
    const machineX = 180;
    const machineY = HEIGHT / 2;
    // Machine body
    ctx.save();
    ctx.fillStyle = "rgba(30, 40, 60, 0.06)";
    ctx.fillRect(machineX - 160, machineY - 140, 320, 280);
    ctx.restore();

    // Big base gear (left)
    const baseX = machineX - 50;
    const baseY = machineY;
    drawGear(baseX, baseY, 64, 12, "#b2d8f7", puzzle.base, false, Math.sin(time) * 0.02);

    // Missing gear slot (right), we show a ring to indicate missing gear
    const slotX = machineX + 70;
    const slotY = machineY;
    ctx.beginPath();
    ctx.arc(slotX, slotY, 64, 0, Math.PI * 2);
    ctx.lineWidth = 6;
    ctx.strokeStyle = "rgba(120,120,120,0.18)";
    ctx.setLineDash([8, 10]);
    ctx.stroke();
    ctx.setLineDash([]);

    // small bolt and arrows to give machine feel
    ctx.fillStyle = "#f6e2b3";
    ctx.beginPath();
    ctx.ellipse(machineX + 70, machineY + 100, 36, 12, 0, 0, Math.PI * 2);
    ctx.fill();

    // Conveyor or pipe connecting gears
    ctx.strokeStyle = "rgba(90,120,150,0.12)";
    ctx.lineWidth = 18;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(baseX + 60, baseY + 20);
    ctx.quadraticCurveTo(machineX + 20, machineY + 40, slotX - 50, slotY + 40);
    ctx.stroke();

    // Instruction text inside machine
    ctx.fillStyle = "#2a2a2a";
    ctx.font = "20px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(`Make ${puzzle.base} + ? = ${puzzle.target}`, machineX, machineY - 110);
  }

  // Draw candidate gears row with selection highlight
  function drawCandidates(options, selectedIndex, t, triesThisRound) {
    const startX = 80;
    const startY = HEIGHT - 120;
    const gap = 150;
    options.forEach((n, i) => {
      const x = startX + i * gap;
      const y = startY;
      const wobble = Math.sin((t - startTime) / 300 + i) * 0.02;
      const colorPalette = ["#ffd7b5", "#cbe7c4", "#e8d7ff", "#cfe7ff"];
      const color = colorPalette[i % colorPalette.length];
      const highlight = i === selectedIndex;
      drawGear(x, y, 48, 10, color, n, highlight, wobble);
      // draw label beneath
      ctx.fillStyle = "#2b2b2b";
      ctx.font = "14px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("gear", x, y + 70);
      // subtle hint if many tries
      if (triesThisRound >= MAX_TRIES_BEFORE_HINT && i === state.current.correctIndex) {
        ctx.beginPath();
        ctx.arc(x, y - 40, 10 + Math.abs(Math.sin((t - startTime) / 450)) * 4, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(80,170,120,0.12)";
        ctx.fill();
      }
    });
  }

  // Draw UI: score, round, audio indicator, instructions
  function drawUI(t) {
    // top bar
    ctx.fillStyle = "rgba(255,255,255,0.5)";
    ctx.fillRect(0, 0, WIDTH, 48);
    ctx.fillStyle = "#2b2b2b";
    ctx.font = "16px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText(`Round ${Math.min(state.round, ROUNDS)} / ${ROUNDS}`, 12, 30);
    ctx.textAlign = "center";
    ctx.fillText(`Score: ${state.score}`, WIDTH / 2, 30);

    // audio visual cue
    ctx.textAlign = "right";
    const audioLabel = state.audioOn ? "🔊 audio on" : "🔈 audio off";
    ctx.fillText(audioLabel, WIDTH - 12, 30);

    // instructions small
    ctx.fillStyle = "#333";
    ctx.font = "13px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText("Use ← → to choose gear, Enter to place it. Click a gear to choose.", 12, 46);
  }

  // Render full scene
  function render(t) {
    // t is high-res timestamp
    drawBackground(t);
    if (!state.started) {
      // draw welcome / start overlay
      ctx.fillStyle = "rgba(255,255,255,0.82)";
      ctx.fillRect(60, 60, WIDTH - 120, HEIGHT - 120);
      ctx.fillStyle = "#2b2b2b";
      ctx.font = "28px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Machine Math!", WIDTH / 2, 140);
      ctx.font = "16px sans-serif";
      ctx.fillText("Welcome engineer! Help fix the friendly machine by choosing the correct number gears.", WIDTH / 2, 180);
      ctx.fillText("Solve simple addition: base + ? = target. Beat all rounds to win!", WIDTH / 2, 210);

      // little start button drawn
      ctx.beginPath();
      ctx.fillStyle = "#bfe6ff";
      ctx.roundRect = ctx.roundRect || function (x, y, w, h, r) {
        const minr = Math.min(w, h) * 0.2;
        r = Math.min(r, minr);
        this.beginPath();
        this.moveTo(x + r, y);
        this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r);
        this.arcTo(x, y + h, x, y, r);
        this.arcTo(x, y, x + w, y, r);
        this.closePath();
      };
      ctx.roundRect( WIDTH/2 - 80, HEIGHT/2 - 18, 160, 36, 12);
      ctx.fill();
      ctx.fillStyle = "#0b3b5a";
      ctx.font = "18px sans-serif";
      ctx.fillText("Press Enter or Click to Start", WIDTH/2, HEIGHT/2 + 6);

      // accessibility instructions
      ctx.font = "12px sans-serif";
      ctx.fillStyle = "#334";
      ctx.fillText("Toggle audio with the 'A' key. Press H for help.", WIDTH/2, HEIGHT/2 + 48);
    } else if (state.round > ROUNDS) {
      // victory screen
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.fillRect(40, 60, WIDTH - 80, HEIGHT - 120);
      ctx.fillStyle = "#2b2b2b";
      ctx.font = "30px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("All fixed! The machine hums happily!", WIDTH / 2, 150);
      ctx.font = "18px sans-serif";
      ctx.fillText(`You scored ${state.score} / ${ROUNDS}`, WIDTH / 2, 200);

      // confetti-ish gears floating
      for (let i = 0; i < 10; i++) {
        const x = 80 + ((t / 50 + i * 47) % (WIDTH - 160));
        const y = 260 + Math.sin((t / 200) + i) * 40;
        drawGear(x, y, 18 + (i % 3) * 3, 8 + (i % 4), ["#ffd7b5", "#cbe7c4", "#e8d7ff"][i % 3], i + 1, false, Math.sin((t / 200) + i) * 0.06);
      }

      ctx.font = "14px sans-serif";
      ctx.fillText("Press R to play again.", WIDTH / 2, 360);
    } else {
      // active round
      drawMachine(state.current, t);
      drawCandidates(state.current.options, state.selectedIndex, t, state.triesThisRound);
      drawUI(t);
      // if last action incorrect show gentle message
      if (state.lastMessage) {
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.fillRect(220, 32, 280, 34);
        ctx.fillStyle = "#1e1e1e";
        ctx.font = "14px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(state.lastMessage, 360, 54);
      }
    }

    // request next frame
    requestAnimationFrame(render);
  }

  // helper: update aria-live text
  function updateLive(text) {
    liveRegion.textContent = text;
  }

  // Handle selection attempts
  function attemptSelection(index) {
    state.selectedIndex = index;
    playClick();
    const puzzle = state.current;
    if (!puzzle) return;
    if (index === puzzle.correctIndex) {
      state.score += Math.max(1, 3 - state.triesThisRound); // more points for fewer tries
      state.roundsCompleted++;
      state.lastMessage = "Nice! That gear fits!";
      updateLive(`Correct! ${puzzle.base} + ${puzzle.options[index]} = ${puzzle.target}.`);
      if (audioContext && state.audioOn) playCorrectSound();
      // short delay then next round or win
      setTimeout(() => {
        if (state.round >= ROUNDS) {
          // finish game
          state.round++;
          updateLive("You've fixed all parts of the machine. Hooray!");
          if (audioContext && state.audioOn) {
            // celebratory melody
            const notes = [523.25, 659.25, 784, 1046.5];
            notes.forEach((f, i) => setTimeout(() => playTone({ freq: f, duration: 0.14, type: "sine", volume: 0.14 }), i * 140));
          }
        } else {
          startNewRound();
        }
      }, 700);
    } else {
      state.triesThisRound++;
      state.lastMessage = "Oops — try another gear.";
      updateLive(`Not quite. ${puzzle.base} plus ${puzzle.options[index]} equals ${puzzle.base + puzzle.options[index]}. Try again.`);
      if (audioContext && state.audioOn) playIncorrectSound();
      // after a few wrong tries, show hint visually and in aria
      if (state.triesThisRound >= MAX_TRIES_BEFORE_HINT) {
        updateLive(`Hint: the correct gear is highlighted.`);
      }
    }
  }

  // Prepare initial puzzle
  function resetGame() {
    state.round = 0;
    state.score = 0;
    state.roundsCompleted = 0;
    state.current = null;
    state.selectedIndex = 0;
    state.triesThisRound = 0;
    state.started = false;
    state.lastMessage = null;
    state.audioOn = audioEnabled && audioContext && audioContext.state === "running";
  }

  // Mouse handling
  canvas.addEventListener("click", (e) => {
    // resume audio on first interaction if needed
    ensureAudioStarted();
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    if (!state.started) {
      // start game if start button area clicked
      if (mx > WIDTH/2 - 80 && mx < WIDTH/2 + 80 && my > HEIGHT/2 - 18 && my < HEIGHT/2 + 18) {
        startNewRound();
      }
      return;
    }

    if (state.round > ROUNDS) {
      // check for R click
      // if click near center, reset
      const centerX = WIDTH/2;
      const centerY = HEIGHT/2;
      const dist = Math.hypot(mx - centerX, my - centerY);
      resetGame();
      return;
    }

    // Check candidate areas (we drew at startX with gap)
    const startX = 80;
    const gap = 150;
    const startY = HEIGHT - 120;
    for (let i = 0; i < state.current.options.length; i++) {
      const x = startX + i * gap;
      const y = startY;
      const dx = mx - x;
      const dy = my - y;
      if (dx * dx + dy * dy <= (48 + 8) * (48 + 8)) {
        attemptSelection(i);
        return;
      }
    }
  });

  // Keyboard controls
  canvas.addEventListener("keydown", (e) => {
    const key = e.key;
    if (!state.started) {
      // Enter or Space starts
      if (key === "Enter" || key === " " || key === "Spacebar") {
        // ensure audio init
        ensureAudioStarted();
        startNewRound();
        e.preventDefault();
      }
      // Toggle audio with 'a'
      if (key.toLowerCase() === "a") {
        toggleAudio();
      }
      if (key.toLowerCase() === "h") {
        showHelp();
      }
      return;
    }

    // If game finished
    if (state.round > ROUNDS) {
      if (key.toLowerCase() === "r") {
        ensureAudioStarted();
        resetGame();
        startNewRound();
      }
      return;
    }

    // In active round
    if (key === "ArrowLeft") {
      state.selectedIndex = (state.selectedIndex - 1 + state.current.options.length) % state.current.options.length;
      playClick();
      updateLive(`Selected gear ${state.current.options[state.selectedIndex]}`);
      e.preventDefault();
    } else if (key === "ArrowRight") {
      state.selectedIndex = (state.selectedIndex + 1) % state.current.options.length;
      playClick();
      updateLive(`Selected gear ${state.current.options[state.selectedIndex]}`);
      e.preventDefault();
    } else if (key === "Enter") {
      attemptSelection(state.selectedIndex);
      e.preventDefault();
    } else if (key.toLowerCase() === "a") {
      toggleAudio();
    } else if (key.toLowerCase() === "h") {
      showHelp();
    }
  });

  // Toggle audio on/off
  function toggleAudio() {
    if (!audioContext) {
      updateLive("Audio not available on this device.");
      return;
    }
    if (!state.audioOn) {
      ensureAudioStarted(true);
    } else {
      // turn off gently
      try {
        if (bgGain) bgGain.gain.setTargetAtTime(0, audioContext.currentTime, 0.03);
        if (masterGain) masterGain.gain.setTargetAtTime(0.0001, audioContext.currentTime, 0.03);
      } catch (e) {
        console.warn("Error toggling audio:", e);
      }
      state.audioOn = false;
      updateLive("Audio muted");
    }
  }

  // Ensure audio context started and nodes initialized (call on first user gesture)
  function ensureAudioStarted(forceOn = false) {
    if (!audioContext) return;
    if (audioContext.state === "suspended") {
      audioContext.resume().then(() => {
        audioEnabled = true;
        state.audioOn = true;
        initAudioNodes();
        updateLive("Audio enabled");
      }).catch((err) => {
        console.warn("Audio resume error:", err);
        updateLive("Audio could not be started.");
      });
    } else {
      if (!masterGain) {
        initAudioNodes();
      }
      if (forceOn) {
        // ramp up master gain
        try {
          masterGain.gain.setValueAtTime(0.0001, audioContext.currentTime);
          masterGain.gain.linearRampToValueAtTime(0.9, audioContext.currentTime + 0.15);
          if (bgGain) bgGain.gain.setValueAtTime(0.04, audioContext.currentTime + 0.15);
        } catch (err) {
          console.warn("Error ramping audio:", err);
        }
        audioEnabled = true;
        state.audioOn = true;
      }
    }
  }

  // Help overlay (simple live announcement and visual cue)
  function showHelp() {
    updateLive("Help: Choose the gear that completes the equation. Use left and right arrows to move and Enter to choose. Press A to toggle audio.");
    // temporary on-screen hint
    state.lastMessage = "Hint: Choose the gear so base + gear = target.";
    setTimeout(() => {
      state.lastMessage = null;
    }, 3000);
  }

  // Initialization
  resetGame();
  // Start render loop
  requestAnimationFrame(render);

  // Add initial live message for users
  updateLive("Ready. Focus is on the game canvas. Press Enter or click to start. Press A to toggle audio. H for help.");

  // Small polyfill for roundRect if not available
  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
      const minr = Math.min(w, h) * 0.2;
      if (Array.isArray(r)) {
        r = r.map(rr => Math.min(rr, minr));
      } else {
        r = Math.min(r, minr);
      }
      this.beginPath();
      this.moveTo(x + r, y);
      this.arcTo(x + w, y, x + w, y + h, r);
      this.arcTo(x + w, y + h, x, y + h, r);
      this.arcTo(x, y + h, x, y, r);
      this.arcTo(x, y, x + w, y, r);
      this.closePath();
    };
  }

  // Safety: catch global errors related to audio or canvas and report
  window.addEventListener("error", (ev) => {
    console.error("Game error:", ev.error || ev.message);
    updateLive("An unexpected error occurred. Please try reloading the page.");
  });

  // Ensure focus on canvas when container clicked
  container.addEventListener("click", () => {
    canvas.focus();
  });

  // Provide friendly keyboard reminder
  setTimeout(() => {
    updateLive("Tip: Use keyboard or click. Press H for help, A to toggle audio.");
  }, 2000);
})();
---

