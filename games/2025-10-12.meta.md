# Game of the Day - 2025-10-12

## Metadata
- **Generated Date:** 2025-10-12
- **Generated Time:** 2025-10-12T00:28:21.093672
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-10-12.js
- **File Size:** 27716 bytes
- **Tokens Used:** 9445

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-10-12.js` - The playable game
- `2025-10-12.meta.json` - Machine-readable metadata
- `2025-10-12.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 19380

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 21548

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Machine Math — a cheerful, calm math game for ages 7-9
  // Renders inside #game-of-the-day-stage and uses canvas + WebAudio API
  // Only canvas drawing, no external files. Keyboard accessible.

  // CONFIG
  const WIDTH = 720;
  const HEIGHT = 480;
  const ROUNDS_TO_WIN = 3;
  const MAX_GEARS = 4;
  const SLOT_COUNT = 3;

  // Get container
  const container = document.getElementById("game-of-the-day-stage");
  if (!container) {
    console.error("Container element #game-of-the-day-stage not found.");
    return;
  }
  // Clear container and prepare
  container.innerHTML = "";
  container.style.position = "relative";

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.width = WIDTH + "px";
  canvas.style.height = HEIGHT + "px";
  canvas.tabIndex = 0; // make focusable for keyboard controls
  canvas.setAttribute("role", "application");
  canvas.setAttribute(
    "aria-label",
    "Machine Math: drag or use keyboard to place gears to sum to the target number. Press Tab to cycle gears, Enter to pick/place, Space to restart."
  );
  container.appendChild(canvas);
  const ctx = canvas.getContext("2d");

  // Audio setup with error handling
  let audioContext = null;
  let masterGain = null;
  let bgOsc = null;
  let bgGain = null;
  let audioAvailable = false;
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (AudioContext) {
      audioContext = new AudioContext();
      masterGain = audioContext.createGain();
      masterGain.gain.value = 0.8;
      masterGain.connect(audioContext.destination);
      audioAvailable = true;
    } else {
      console.warn("Web Audio API not supported in this browser.");
    }
  } catch (e) {
    console.warn("AudioContext creation failed:", e);
    audioAvailable = false;
  }

  // In many browsers audio must be resumed within a user gesture
  async function ensureAudioStarted() {
    if (!audioAvailable || !audioContext) return false;
    try {
      if (audioContext.state === "suspended") {
        await audioContext.resume();
      }
      return true;
    } catch (e) {
      console.warn("AudioContext resume failed:", e);
      return false;
    }
  }

  // Background hum setup
  let soundEnabled = true;
  function startBackgroundHum() {
    if (!audioAvailable || !soundEnabled) return;
    try {
      stopBackgroundHum();
      bgOsc = audioContext.createOscillator();
      bgOsc.type = "sine";
      bgOsc.frequency.value = 80; // low hum
      const lfo = audioContext.createOscillator();
      lfo.frequency.value = 0.2; // slow wobble
      const lfoGain = audioContext.createGain();
      lfoGain.gain.value = 12;
      lfo.connect(lfoGain);
      lfoGain.connect(bgOsc.frequency);
      bgGain = audioContext.createGain();
      bgGain.gain.value = 0.035; // very gentle
      bgOsc.connect(bgGain);
      bgGain.connect(masterGain);
      lfo.start();
      bgOsc.start();
    } catch (e) {
      console.warn("Failed to start background hum:", e);
    }
  }
  function stopBackgroundHum() {
    try {
      if (bgOsc) {
        bgOsc.stop();
        bgOsc.disconnect();
        bgOsc = null;
      }
      if (bgGain) {
        bgGain.disconnect();
        bgGain = null;
      }
    } catch (e) {
      // ignore
    }
  }

  // Simple sound generator
  function playTone({ freq = 440, duration = 0.12, type = "sine", gain = 0.25, when = 0 } = {}) {
    if (!audioAvailable || !soundEnabled) return;
    try {
      const ctx = audioContext;
      const osc = ctx.createOscillator();
      const g = ctx.createGain();
      const filter = ctx.createBiquadFilter();
      filter.type = "lowpass";
      filter.frequency.value = Math.max(500, freq * 2);

      osc.type = type;
      osc.frequency.value = freq;
      g.gain.value = 0.0001;

      osc.connect(filter);
      filter.connect(g);
      g.connect(masterGain);

      const now = ctx.currentTime + when;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(gain, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);

      osc.start(now);
      osc.stop(now + duration + 0.02);
    } catch (e) {
      console.warn("playTone failed:", e);
    }
  }

  // Distinct feedback sounds
  function playPickSound() {
    playTone({ freq: 880, duration: 0.08, type: "triangle", gain: 0.08 });
  }
  function playPlaceSound() {
    playTone({ freq: 660, duration: 0.12, type: "sine", gain: 0.12 });
  }
  function playCorrectSound() {
    // cheerful arpeggio
    playTone({ freq: 660, duration: 0.12, type: "sine", gain: 0.12 });
    playTone({ freq: 880, duration: 0.12, type: "sine", gain: 0.12, when: 0.12 });
    playTone({ freq: 990, duration: 0.18, type: "sine", gain: 0.12, when: 0.26 });
  }
  function playIncorrectSound() {
    playTone({ freq: 220, duration: 0.18, type: "sawtooth", gain: 0.12 });
  }

  // Data structures
  let round = 1;
  let wins = 0;
  let targetNumber = 0;
  let gears = []; // gear objects
  let slots = []; // slot objects
  let dragging = null;
  let dragOffset = { x: 0, y: 0 };
  let selectedGearIndex = 0; // for keyboard selection
  let notification = ""; // small text feedback
  let notificationTimer = 0;
  let roundSolved = false;
  let gameOver = false;

  // Setup slots (positions in machine)
  function setupSlots() {
    slots = [];
    const startX = 160;
    const gap = 120;
    const y = 260;
    for (let i = 0; i < SLOT_COUNT; i++) {
      slots.push({
        x: startX + i * gap,
        y: y,
        r: 34,
        gearIndex: -1, // which gear is placed
      });
    }
  }

  // Utility: shuffle array
  function shuffleArr(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  // Start a round: create three numbers that sum to target, plus one decoy
  function startRound() {
    roundSolved = false;
    notification = "";
    notificationTimer = 0;
    // Create three small integers 1..9 that sum up to target between 6 and 20
    const a = Math.floor(Math.random() * 8) + 1; // 1..8
    const b = Math.floor(Math.random() * 8) + 1;
    // ensure c is within 1..9
    let c = Math.max(1, Math.min(9, Math.floor((a + b) / 2 + Math.random() * 8)));
    let sum = a + b + c;
    // Adjust target if out of desired range
    if (sum < 6 || sum > 20) {
      sum = Math.floor(6 + Math.random() * 15);
      // pick c to match target
      c = sum - a - b;
      if (c < 1) c = 1 + Math.floor(Math.random() * 6);
      if (c > 9) c = 9;
    }
    // Now ensure sum is updated
    const values = [a, b, c];
    // Recalculate target
    targetNumber = values.reduce((s, v) => s + v, 0);
    // Add decoy gear that is different or a duplicate sometimes
    let decoy = Math.floor(Math.random() * 9) + 1;
    // Ensure not trivial: decoy not equal to any if possible
    if (values.includes(decoy)) {
      decoy = (decoy % 9) + 1;
    }
    values.push(decoy);
    shuffleArr(values);

    // Construct gear objects positioned on left conveyor
    gears = [];
    const startX = 60;
    const baseY = 360;
    const gapX = 120;
    for (let i = 0; i < MAX_GEARS; i++) {
      const gx = startX + i * gapX;
      const gy = baseY + (i % 2 === 0 ? -6 : 6);
      const val = values[i];
      gears.push({
        value: val,
        x: gx,
        y: gy,
        r: 28,
        original: { x: gx, y: gy },
        placed: false,
        slotIndex: -1,
        wobble: Math.random() * Math.PI * 2,
      });
    }

    setupSlots();
    selectedGearIndex = 0;
    roundSolved = false;
  }

  function resetGame() {
    round = 1;
    wins = 0;
    gameOver = false;
    startRound();
  }

  // Detect gear index under coordinates
  function gearAtPoint(x, y) {
    for (let i = gears.length - 1; i >= 0; i--) {
      const g = gears[i];
      const dx = x - g.x;
      const dy = y - g.y;
      if (Math.sqrt(dx * dx + dy * dy) <= g.r + 6) {
        return i;
      }
    }
    return -1;
  }

  // Detect slot at point
  function slotAtPoint(x, y) {
    for (let i = 0; i < slots.length; i++) {
      const s = slots[i];
      const dx = x - s.x;
      const dy = y - s.y;
      if (Math.sqrt(dx * dx + dy * dy) <= s.r + 6) {
        return i;
      }
    }
    return -1;
  }

  // Place gear into slot
  function placeGearInSlot(gearIndex, slotIndex) {
    const gear = gears[gearIndex];
    const slot = slots[slotIndex];
    if (!gear || !slot) return false;
    if (slot.gearIndex !== -1) return false; // already filled
    // Snap gear to slot
    gear.x = slot.x;
    gear.y = slot.y;
    gear.placed = true;
    gear.slotIndex = slotIndex;
    slot.gearIndex = gearIndex;
    playPlaceSound();
    checkSolution();
    return true;
  }

  // Remove gear from slot back to original position
  function removeGearFromSlot(slotIndex) {
    const slot = slots[slotIndex];
    if (!slot) return;
    const gi = slot.gearIndex;
    if (gi === -1) return;
    const gear = gears[gi];
    slot.gearIndex = -1;
    gear.placed = false;
    gear.slotIndex = -1;
    // animate back to original spot
    gear.x = gear.original.x;
    gear.y = gear.original.y;
  }

  // Check if current slots sum equals target
  function checkSolution() {
    // Only check when all slots are filled
    for (let s of slots) {
      if (s.gearIndex === -1) return;
    }
    const sum = slots.reduce((acc, s) => acc + gears[s.gearIndex].value, 0);
    if (sum === targetNumber) {
      // success
      wins++;
      roundSolved = true;
      notification = "Perfect! Machine fixed.";
      notificationTimer = 160; // frames
      playCorrectSound();
      // celebrate animation: slightly pop gears
      for (let s of slots) {
        const g = gears[s.gearIndex];
        g.wobble = 0;
      }
      // Small delay then advance round or end
      setTimeout(() => {
        round++;
        if (wins >= ROUNDS_TO_WIN) {
          gameOver = true;
          notification = "You win! All machines humming!";
          notificationTimer = 9999;
        } else {
          startRound();
        }
      }, 900);
    } else {
      // incorrect
      notification = "Not quite — try again!";
      notificationTimer = 140;
      playIncorrectSound();
      // Un-snap after brief delay so children can see
      setTimeout(() => {
        for (let s = 0; s < slots.length; s++) {
          if (slots[s].gearIndex !== -1) {
            const gi = slots[s].gearIndex;
            gears[gi].x = gears[gi].original.x;
            gears[gi].y = gears[gi].original.y;
            gears[gi].placed = false;
            gears[gi].slotIndex = -1;
            slots[s].gearIndex = -1;
          }
        }
      }, 700);
    }
  }

  // Mouse/touch interactions
  canvas.addEventListener("mousedown", async (e) => {
    try {
      await ensureAudioStarted();
      if (audioAvailable && soundEnabled) startBackgroundHum();
    } catch (ex) {}
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    const my = (e.clientY - rect.top) * (canvas.height / rect.height);
    const gi = gearAtPoint(mx, my);
    if (gi !== -1) {
      dragging = gi;
      const g = gears[gi];
      dragOffset.x = mx - g.x;
      dragOffset.y = my - g.y;
      // If gear was in a slot, free slot
      if (g.placed) {
        const sidx = g.slotIndex;
        if (sidx !== -1) {
          slots[sidx].gearIndex = -1;
        }
        g.placed = false;
        g.slotIndex = -1;
      }
      selectedGearIndex = gi;
      playPickSound();
    } else {
      // Maybe click speaker icon - detect top-right area
      const speakerRect = { x: WIDTH - 72, y: 14, w: 56, h: 34 };
      if (
        e.clientX - rect.left >= speakerRect.x &&
        e.clientX - rect.left <= speakerRect.x + speakerRect.w &&
        e.clientY - rect.top >= speakerRect.y &&
        e.clientY - rect.top <= speakerRect.y + speakerRect.h
      ) {
        toggleSound();
      }
    }
  });

  canvas.addEventListener("mousemove", (e) => {
    if (dragging === null) return;
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    const my = (e.clientY - rect.top) * (canvas.height / rect.height);
    const g = gears[dragging];
    g.x = mx - dragOffset.x;
    g.y = my - dragOffset.y;
  });

  canvas.addEventListener("mouseup", (e) => {
    if (dragging === null) return;
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    const my = (e.clientY - rect.top) * (canvas.height / rect.height);
    const sidx = slotAtPoint(mx, my);
    if (sidx !== -1) {
      // attempt place
      const placed = placeGearInSlot(dragging, sidx);
      if (!placed) {
        // return to original
        const g = gears[dragging];
        g.x = g.original.x;
        g.y = g.original.y;
      }
    } else {
      // return to original
      const g = gears[dragging];
      g.x = g.original.x;
      g.y = g.original.y;
    }
    dragging = null;
  });

  // Touch support (translate to mouse)
  canvas.addEventListener("touchstart", (e) => {
    e.preventDefault();
    const touch = e.changedTouches[0];
    const rect = canvas.getBoundingClientRect();
    const fakeEvent = {
      clientX: touch.clientX,
      clientY: touch.clientY,
    };
    canvas.dispatchEvent(new MouseEvent("mousedown", fakeEvent));
  });
  canvas.addEventListener("touchmove", (e) => {
    e.preventDefault();
    const touch = e.changedTouches[0];
    const rect = canvas.getBoundingClientRect();
    const fakeEvent = {
      clientX: touch.clientX,
      clientY: touch.clientY,
    };
    canvas.dispatchEvent(new MouseEvent("mousemove", fakeEvent));
  });
  canvas.addEventListener("touchend", (e) => {
    e.preventDefault();
    const touch = e.changedTouches[0];
    const rect = canvas.getBoundingClientRect();
    const fakeEvent = {
      clientX: touch.clientX,
      clientY: touch.clientY,
    };
    canvas.dispatchEvent(new MouseEvent("mouseup", fakeEvent));
  });

  // Keyboard controls for accessibility
  canvas.addEventListener("keydown", async (e) => {
    const key = e.key;
    // Try to start audio on user gesture
    try {
      await ensureAudioStarted();
      if (audioAvailable && soundEnabled) startBackgroundHum();
    } catch (ex) {}

    if (gameOver) {
      if (key === " " || key === "Enter") {
        resetGame();
      }
      return;
    }

    // Tab cycles selection
    if (key === "Tab") {
      e.preventDefault();
      selectedGearIndex = (selectedGearIndex + 1) % gears.length;
      playPickSound();
      return;
    }

    const selectedGear = gears[selectedGearIndex];
    if (!selectedGear) return;

    if (key === "Enter" || key === " ") {
      // If picked up (simulate dragging) then place in first empty slot, else pick up
      if (!selectedGear.placed) {
        // pick up and place to first empty slot
        const emptySlot = slots.findIndex((s) => s.gearIndex === -1);
        if (emptySlot !== -1) {
          placeGearInSlot(selectedGearIndex, emptySlot);
        } else {
          // no slots free — quickly swap with first slot
          // swap with slot 0
          const s0 = slots[0];
          const oldGearIndex = s0.gearIndex;
          if (oldGearIndex !== -1) {
            // put old gear back to original
            gears[oldGearIndex].x = gears[oldGearIndex].original.x;
            gears[oldGearIndex].placed = false;
            gears[oldGearIndex].slotIndex = -1;
          }
          placeGearInSlot(selectedGearIndex, 0);
        }
      } else {
        // remove from its slot
        const sidx = selectedGear.slotIndex;
        if (sidx !== -1) {
          removeGearFromSlot(sidx);
        }
      }
      return;
    }

    // Arrow keys to move selection (change selectedGearIndex)
    if (key === "ArrowRight") {
      selectedGearIndex = (selectedGearIndex + 1) % gears.length;
      playPickSound();
      return;
    }
    if (key === "ArrowLeft") {
      selectedGearIndex = (selectedGearIndex - 1 + gears.length) % gears.length;
      playPickSound();
      return;
    }

    // Number keys to place into particular slots (1..3)
    if (/^[1-3]$/.test(key)) {
      const slotNumber = parseInt(key, 10) - 1;
      // If gear is already placed, remove; else place into that slot if empty
      if (!selectedGear.placed) {
        if (slots[slotNumber].gearIndex === -1) {
          placeGearInSlot(selectedGearIndex, slotNumber);
        } else {
          // swap
          const previousGearIndex = slots[slotNumber].gearIndex;
          removeGearFromSlot(slotNumber);
          placeGearInSlot(selectedGearIndex, slotNumber);
          // return swapped gear to its original spot
          if (previousGearIndex !== -1) {
            gears[previousGearIndex].x = gears[previousGearIndex].original.x;
          }
        }
      } else {
        // remove if selecting same slot
        if (selectedGear.slotIndex === slotNumber) {
          removeGearFromSlot(slotNumber);
        } else {
          // place to that slot if empty
          if (slots[slotNumber].gearIndex === -1) {
            const oldSlot = selectedGear.slotIndex;
            if (oldSlot !== -1) {
              slots[oldSlot].gearIndex = -1;
            }
            placeGearInSlot(selectedGearIndex, slotNumber);
          }
        }
      }
      return;
    }

    // Backspace/Delete resets selected gear
    if (key === "Backspace" || key === "Delete") {
      if (selectedGear.placed) {
        const sidx = selectedGear.slotIndex;
        if (sidx !== -1) removeGearFromSlot(sidx);
      } else {
        // return to original
        selectedGear.x = selectedGear.original.x;
        selectedGear.y = selectedGear.original.y;
        selectedGear.placed = false;
        selectedGear.slotIndex = -1;
      }
      return;
    }

    // H key toggles help tooltip
    if (key.toLowerCase() === "h") {
      notification = "Tip: You need to place three gears so their numbers add to the target.";
      notificationTimer = 180;
      return;
    }

    // S toggles sound
    if (key.toLowerCase() === "s") {
      toggleSound();
      return;
    }
  });

  // Toggle sound and background hum
  function toggleSound() {
    soundEnabled = !soundEnabled;
    if (!soundEnabled) {
      stopBackgroundHum();
    } else {
      ensureAudioStarted().then(() => {
        if (audioAvailable) startBackgroundHum();
      });
    }
    notification = soundEnabled ? "Sound on" : "Sound off";
    notificationTimer = 80;
  }

  // Drawing helpers
  function drawRoundedRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  // Draw cog (gear) shape with teeth
  function drawGear(ctx, x, y, radius, teeth, color, rotation = 0) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rotation);
    // body
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(0, 0, radius * 0.62, 0, Math.PI * 2);
    ctx.fill();
    // teeth
    for (let i = 0; i < teeth; i++) {
      const ang = (i / teeth) * Math.PI * 2;
      const tx = Math.cos(ang) * (radius * 0.9);
      const ty = Math.sin(ang) * (radius * 0.9);
      ctx.beginPath();
      ctx.moveTo(tx, ty);
      ctx.lineTo(Math.cos(ang) * radius, Math.sin(ang) * radius);
      ctx.lineWidth = 3;
      ctx.strokeStyle = color;
      ctx.stroke();
    }
    // center hole
    ctx.fillStyle = "#333";
    ctx.beginPath();
    ctx.arc(0, 0, radius * 0.22, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  // Main draw loop
  let frame = 0;
  function draw() {
    frame++;

    // background
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    // gentle sky gradient
    const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    grad.addColorStop(0, "#f7fbff");
    grad.addColorStop(1, "#e7f1f7");
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Top banner / machine header
    ctx.fillStyle = "#dfeef6";
    drawRoundedRect(ctx, 16, 12, WIDTH - 32, 88, 12);

    // Title
    ctx.fillStyle = "#1b3b5a";
    ctx.font = "bold 22px system-ui, Arial";
    ctx.textAlign = "left";
    ctx.fillText("Machine Math — Fix the Friendly Factory", 36, 42);

    // Round and instructions
    ctx.font = "14px system-ui, Arial";
    ctx.fillStyle = "#234d67";
    ctx.fillText(`Round ${round} of ${ROUNDS_TO_WIN}`, 36, 66);
    ctx.fillStyle = "#2d5d78";
    ctx.font = "13px system-ui, Arial";
    ctx.fillText("Drag gears into the slots so their numbers add to the target.", 36, 86);

    // Draw target panel (big number)
    ctx.fillStyle = "#fff";
    drawRoundedRect(ctx, WIDTH - 220, 24, 180, 72, 10);
    ctx.fillStyle = "#264a63";
    ctx.font = "14px system-ui, Arial";
    ctx.fillText("Target", WIDTH - 220 + 16, 46);
    ctx.font = "bold 36px system-ui, Arial";
    ctx.fillStyle = "#0a3a55";
    ctx.textAlign = "center";
    ctx.fillText(String(targetNumber), WIDTH - 220 + 90, 86);
    ctx.textAlign = "left";

    // Draw a wacky machine illustration in the center
    drawMachineBackground();

    // Draw slots
    for (let i = 0; i < slots.length; i++) {
      const s = slots[i];
      // slot base
      ctx.fillStyle = "#cde6f3";
      drawRoundedRect(ctx, s.x - 46, s.y - 46, 92, 92, 12);
      // hole
      ctx.fillStyle = "#eef8fb";
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r + 6, 0, Math.PI * 2);
      ctx.fill();
      // slot number
      ctx.fillStyle = "#2b5370";
      ctx.font = "bold 14px system-ui, Arial";
      ctx.fillText(`Slot ${i + 1}`, s.x - 24, s.y + 52);
    }

    // Conveyor belt for gears
    ctx.fillStyle = "#203748";
    drawRoundedRect(ctx, 18, 320, 420, 120, 18);
    // belt stripes
    for (let i = 0; i < 8; i++) {
      ctx.fillStyle = i % 2 === 0 ? "rgba(255,255,255,0.03)" : "rgba(0,0,0,0.03)";
      const bx = 36 + i * 50 + (frame % 50);
      ctx.fillRect(bx % 420 + 20, 348, 40, 6);
    }

    // Draw gears (draggable)
    for (let i = 0; i < gears.length; i++) {
      const g = gears[i];
      // wobble for life
      g.wobble += 0.04;
      const rot = Math.sin(frame * 0.02 + i) * 0.08 + (g.placed ? 0 : Math.sin(g.wobble) * 0.02);
      // highlight if selected
      if (i === selectedGearIndex) {
        ctx.save();
        ctx.shadowColor = "rgba(60,120,160,0.35)";
        ctx.shadowBlur = 12;
      }
      // draw gear
      drawGear(ctx, g.x, g.y, g.r, 10, i === selectedGearIndex ? "#78c0d6" : "#8bd1e8", rot);
      // number
      ctx.fillStyle = "#043748";
      ctx.font = "bold 16px system-ui, Arial";
      ctx.textAlign = "center";
      ctx.fillText(String(g.value), g.x, g.y + 6);
      if (i === selectedGearIndex) ctx.restore();
    }

    // Draw small animated gears in machine
    drawMachineGears(frame);

    // Draw UI: notification
    if (notificationTimer > 0) {
      notificationTimer--;
      ctx.globalAlpha = Math.min(1, notificationTimer / 80);
      ctx.fillStyle = "#ffd36b";
      drawRoundedRect(ctx, WIDTH / 2 - 180, 12 + 88, 360, 36, 10);
      ctx.fillStyle = "#2b3b4a";
      ctx.font = "bold 15px system-ui, Arial";
      ctx.textAlign = "center";
      ctx.fillText(notification, WIDTH / 2, 140);
      ctx.globalAlpha = 1;
      ctx.textAlign = "left";
    }

    // Draw speaker icon and sound status
    drawSpeakerIcon();

    // If game over, overlay messages
    if (gameOver) {
      ctx.fillStyle = "rgba(4,20,28,0.6)";
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = "#fffdf6";
      ctx.font = "bold 32px system-ui, Arial";
      ctx.textAlign = "center";
      ctx.fillText("Hooray! You fixed all the machines!", WIDTH / 2, HEIGHT / 2 - 12);
      ctx.font = "18px system-ui, Arial";
      ctx.fillText("Press Space or Enter to play again.", WIDTH / 2, HEIGHT / 2 + 24);
      ctx.textAlign = "left";
    }

    requestAnimationFrame(draw);
  }

  // Machine decoration
  function drawMachineBackground() {
    // central machine body
    ctx.fillStyle = "#cde6f6";
    drawRoundedRect(ctx, 120, 120, 480, 180, 16);
    // vents
    for (let i = 0; i < 10; i++) {
      ctx.fillStyle = i % 2 ? "#dff1fa" : "#bfe4ef";
      ctx.fillRect(140 + i * 44, 140, 28, 10);
    }
    // pipe
    ctx.fillStyle = "#9ec7d8";
    drawRoundedRect(ctx, 90, 170, 40, 60, 8);
    drawRoundedRect(ctx, 560, 170, 40, 60, 8);
    // label
    ctx.fillStyle = "#1b3b5a";
    ctx.font = "14px system-ui, Arial";
    ctx.fillText("Friendly Factory Machine", 320, 140);
  }

  // Animated small gears on machine to make it lively
  function drawMachineGears(frame) {
    const cx = 360;
    const cy = 200;
    const gearPositions = [
      { x: cx - 80, y: cy - 10, r: 18, speed: 0.02, color: "#f6a77a" },
      { x: cx - 10, y: cy + 20, r: 12, speed: -0.03, color: "#c9f0e1" },
      { x: cx + 60, y: cy - 6, r: 22, speed: 0.015, color: "#f3d36b" },
    ];
    for (let i = 0; i < gearPositions.length; i++) {
      const p = gearPositions[i];
      const rot = frame * p.speed;
      drawGear(ctx, p.x, p.y, p.r, 8 + i, p.color, rot);
    }
  }

  // Speaker icon
  function drawSpeakerIcon() {
    const x = WIDTH - 72;
    const y = 14;
    ctx.fillStyle = soundEnabled ? "#2b6f8f" : "#7a8c97";
    drawRoundedRect(ctx, x, y, 56, 34, 8);
    // speaker symbol
    ctx.save();
    ctx.translate(x + 14, y + 17);
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.moveTo(-6, -8);
    ctx.lineTo(0, -8);
    ctx.lineTo(8, -2);
    ctx.lineTo(8, 2);
    ctx.lineTo(0, 8);
    ctx.lineTo(-6, 8);
    ctx.closePath();
    ctx.fill();
    if (soundEnabled) {
      ctx.beginPath();
      ctx.arc(10, 0, 8, -0.6, 0.6);
      ctx.strokeStyle = "rgba(255,255,255,0.85)";
      ctx.lineWidth = 2;
      ctx.stroke();
    } else {
      ctx.strokeStyle = "rgba(255,255,255,0.85)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(2, -10);
      ctx.lineTo(14, 10);
      ctx.stroke();
    }
    ctx.restore();
  }

  // Start the game
  resetGame();
  requestAnimationFrame(draw);

  // Make sure audio starts after first user gesture
  function resumeAudioOnGesture() {
    if (!audioAvailable || !audioContext) return;
    const resume = async () => {
      try {
        await audioContext.resume();
        if (soundEnabled) startBackgroundHum();
      } catch (e) {
        // ignore
      } finally {
        window.removeEventListener("click", resume);
        window.removeEventListener("keydown", resume);
      }
    };
    window.addEventListener("click", resume);
    window.addEventListener("keydown", resume);
  }
  resumeAudioOnGesture();

  // Provide a small help text outside canvas for screen readers (hidden visually)
  const srHelp = document.createElement("div");
  srHelp.style.position = "absolute";
  srHelp.style.left = "-9999px";
  srHelp.style.width = "1px";
  srHelp.style.height = "1px";
  srHelp.style.overflow = "hidden";
  srHelp.setAttribute(
    "aria-hidden",
    "false"
  );
  srHelp.innerText =
    "Machine Math: Place three gears so the sum equals the target number. Use mouse or touch to drag. Use Tab to cycle gears, Enter to place/remove. Press S to toggle sound. Press H for a tip.";
  container.appendChild(srHelp);

  // Expose a small API for testing (non-intrusive)
  window._machineMath = {
    restart: resetGame,
    toggleSound: toggleSound,
    isSoundEnabled: () => soundEnabled,
    currentTarget: () => targetNumber,
  };
})();
---

