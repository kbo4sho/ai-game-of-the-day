# Game of the Day - 2025-10-27

## Metadata
- **Generated Date:** 2025-10-27
- **Generated Time:** 2025-10-27T00:30:14.720768
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-10-27.js
- **File Size:** 27921 bytes
- **Tokens Used:** 10035

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-10-27.js` - The playable game
- `2025-10-27.meta.json` - Machine-readable metadata
- `2025-10-27.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 21079

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 23159

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Drone Math Adventure - Canvas + Web Audio API
// Designed for ages 7-9. Renders inside element with ID "game-of-the-day-stage".
// All visuals drawn on canvas. Sounds generated using Web Audio API oscillators.
// Single JS file - self-contained. No external assets.

(function () {
  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const PADDING = 10;
  const GOAL_SCORE = 10;
  const MAX_WRONG = 3;
  const BALLOON_COUNT = 4; // number of answer targets on screen
  const BALLOON_MIN_Y = 120;
  const BALLOON_MAX_Y = 360;

  // Get container element
  const container = document.getElementById("game-of-the-day-stage");
  if (!container) {
    console.error('Container element with ID "game-of-the-day-stage" not found.');
    return;
  }

  // Clear container and create canvas
  container.innerHTML = "";
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.display = "block";
  canvas.style.background = "#eaf3ff"; // subtle sky
  container.appendChild(canvas);
  const ctx = canvas.getContext("2d", { alpha: false });

  // Audio context and sound utilities
  let audioCtx = null;
  let audioEnabled = false;
  let ambientOsc = null;
  let ambientGain = null;

  async function initAudio() {
    if (audioCtx) return;
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      // create gentle ambient oscillator and gain
      ambientOsc = audioCtx.createOscillator();
      ambientGain = audioCtx.createGain();
      ambientOsc.type = "sine";
      ambientOsc.frequency.setValueAtTime(220, audioCtx.currentTime);
      ambientGain.gain.setValueAtTime(0.02, audioCtx.currentTime);
      const lfo = audioCtx.createOscillator();
      lfo.type = "sine";
      lfo.frequency.setValueAtTime(0.05, audioCtx.currentTime);
      const lfoGain = audioCtx.createGain();
      lfoGain.gain.setValueAtTime(30, audioCtx.currentTime);
      lfo.connect(lfoGain);
      lfoGain.connect(ambientOsc.frequency);
      ambientOsc.connect(ambientGain);
      ambientGain.connect(audioCtx.destination);
      ambientOsc.start();
      lfo.start();
      audioEnabled = true;
    } catch (e) {
      console.warn("Audio unavailable:", e);
      audioEnabled = false;
      audioCtx = null;
    }
  }

  function playTone(type, frequency, duration = 0.25, volume = 0.12) {
    if (!audioEnabled || !audioCtx) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const f = audioCtx.createBiquadFilter();
      o.type = type;
      o.frequency.setValueAtTime(frequency, audioCtx.currentTime);
      g.gain.setValueAtTime(volume, audioCtx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
      f.type = "lowpass";
      f.frequency.setValueAtTime(1200, audioCtx.currentTime);
      o.connect(f);
      f.connect(g);
      g.connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime + duration + 0.02);
    } catch (e) {
      console.warn("Sound playback failed:", e);
    }
  }

  // UI and game state
  let state = "start"; // "start", "playing", "win", "lose"
  let score = 0;
  let wrong = 0;
  let drone = null;
  let balloons = [];
  let currentQuestion = null;
  let keys = {};
  let mouse = { x: 0, y: 0, down: false };
  let lastTime = 0;
  let animateAudioBars = 0;
  let shakeTimer = 0;

  // Fonts
  const bodyFont = "16px Arial";
  const importantFont = "22px Arial";
  const titleFont = "28px Arial";

  // Drone definition
  function resetDrone() {
    drone = {
      x: WIDTH / 2,
      y: HEIGHT - 140,
      vx: 0,
      vy: 0,
      speed: 200, // pixels per second
      radius: 28,
      propellerAngle: 0
    };
  }

  // Math question generation (appropriate for ages 7-9)
  function generateQuestion() {
    // Randomly choose addition or subtraction or simple multiplication occasionally
    const r = Math.random();
    let a, b, op, answer;
    if (r < 0.55) {
      // addition up to 20
      a = randInt(1, 15);
      b = randInt(1, 15);
      op = "+";
      answer = a + b;
    } else if (r < 0.9) {
      // subtraction but non-negative
      a = randInt(5, 20);
      b = randInt(1, Math.min(10, a));
      op = "-";
      answer = a - b;
    } else {
      // small multiplication
      a = randInt(2, 6);
      b = randInt(2, 6);
      op = "×";
      answer = a * b;
    }
    // Build alternatives
    const choices = new Set();
    choices.add(answer);
    while (choices.size < BALLOON_COUNT) {
      let alt = answer + randInt(-5, 6);
      if (Math.abs(alt - answer) <= 0) alt = answer + randInt(1, 6);
      if (alt < 0) alt = Math.abs(alt) + 1;
      choices.add(alt);
    }
    const choiceArray = shuffle(Array.from(choices));
    // Place balloons with values
    const balloonPositions = generateBalloonPositions(choiceArray.length);
    balloons = choiceArray.map((val, i) => ({
      x: balloonPositions[i].x,
      y: balloonPositions[i].y,
      targetY: balloonPositions[i].y + randInt(-20, 20),
      vx: randFloat(-20, 20),
      vy: randFloat(-8, 8),
      value: val,
      correct: val === answer,
      wobble: randFloat(0, Math.PI * 2),
      color: pastelColor(i)
    }));
    currentQuestion = { a, b, op, answer };
  }

  // Helpers for positions
  function generateBalloonPositions(count) {
    const positions = [];
    const margin = 90;
    const usableWidth = WIDTH - 2 * margin;
    for (let i = 0; i < count; i++) {
      const x = margin + (i + 0.5) * (usableWidth / count) + randInt(-20, 20);
      const y = randInt(BALLOON_MIN_Y, BALLOON_MAX_Y);
      positions.push({ x, y });
    }
    return positions;
  }

  // Random helpers
  function randInt(a, b) {
    return Math.floor(Math.random() * (b - a + 1)) + a;
  }
  function randFloat(a, b) {
    return Math.random() * (b - a) + a;
  }
  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }
  function pastelColor(i) {
    const hues = [200, 150, 300, 40, 260, 120];
    const h = hues[i % hues.length];
    return `hsl(${h} 80% 78%)`;
  }

  // Initialize game variables
  function resetGame() {
    score = 0;
    wrong = 0;
    shakeTimer = 0;
    resetDrone();
    generateQuestion();
    state = "playing";
  }

  // Collision detection
  function checkCollisions() {
    for (const b of balloons) {
      const dx = drone.x - b.x;
      const dy = drone.y - b.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const threshold = drone.radius + 28; // balloon radius approx 28
      if (dist < threshold) {
        // collision
        if (b.handled) continue;
        b.handled = true; // avoid multiple triggers
        if (b.correct) {
          score += 1;
          playTone("sine", 880, 0.18, 0.12);
          animateAudioBars = Math.min(1, animateAudioBars + 0.4);
          // small celebration: spawn stars (visual only)
          spawnStarsAt(b.x, b.y);
          // If goal reached: win
          if (score >= GOAL_SCORE) {
            state = "win";
            stopAmbientSmooth();
          } else {
            // Next question after short delay
            setTimeout(() => {
              generateQuestion();
            }, 700);
          }
        } else {
          wrong += 1;
          playTone("square", 180, 0.35, 0.14);
          shakeTimer = 400; // ms
          animateAudioBars = Math.min(1, animateAudioBars + 0.6);
          if (wrong >= MAX_WRONG) {
            state = "lose";
            stopAmbientSmooth();
          } else {
            // continue (regenerate after a short bounce)
            setTimeout(() => {
              generateQuestion();
            }, 800);
          }
        }
      }
    }
  }

  // Simple star particles
  let particles = [];
  function spawnStarsAt(x, y) {
    for (let i = 0; i < 12; i++) {
      particles.push({
        x,
        y,
        vx: randFloat(-80, 80),
        vy: randFloat(-220, -60),
        life: randFloat(500, 1200),
        t: 0,
        size: randFloat(6, 10),
        hue: randInt(40, 60)
      });
    }
  }

  // Stop ambient with gentle fade
  function stopAmbientSmooth() {
    if (!audioEnabled || !audioCtx || !ambientGain) return;
    try {
      ambientGain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.6);
      setTimeout(() => {
        try {
          ambientOsc && ambientOsc.stop && ambientOsc.stop();
          ambientOsc = null;
          ambientGain = null;
        } catch (e) {}
      }, 700);
    } catch (e) {
      console.warn("Ambient stop error", e);
    }
  }

  // Input handlers
  window.addEventListener("keydown", (e) => {
    if (e.key === " " || e.code === "Space") {
      e.preventDefault();
      if (state === "start") {
        // start game and initialize audio context on user gesture
        initAudio().then(() => {
          // small confirmation tone
          playTone("sine", 660, 0.12, 0.08);
          resetGame();
        }).catch(() => {
          resetGame();
        });
      } else if (state === "win" || state === "lose") {
        restartGame();
      }
    } else if (e.key.toLowerCase() === "r") {
      e.preventDefault();
      restartGame();
    } else if (e.key.toLowerCase() === "m") {
      // toggle ambient mute
      if (!audioCtx) return;
      if (audioEnabled) {
        // mute
        try {
          audioCtx.suspend();
        } catch (e) {}
        audioEnabled = false;
      } else {
        try {
          audioCtx.resume();
        } catch (e) {}
        audioEnabled = true;
      }
    }
    keys[e.key] = true;
  });
  window.addEventListener("keyup", (e) => {
    keys[e.key] = false;
  });
  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
    mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
  });
  canvas.addEventListener("mousedown", (e) => {
    mouse.down = true;
    // clicking on start screen starts and creates audio context
    if (state === "start") {
      initAudio().then(() => {
        playTone("sine", 660, 0.12, 0.08);
        resetGame();
      }).catch(() => resetGame());
    }
    // clicking restart on end screens
    if (state === "win" || state === "lose") {
      // Check if click inside restart button area (we will compute and store it)
      if (endButtonRect && pointInRect(mouse.x, mouse.y, endButtonRect)) {
        restartGame();
      }
    }
    // Clicking a balloon directly should trigger immediate pickup
    if (state === "playing") {
      for (const b of balloons) {
        if (distance(mouse.x, mouse.y, b.x, b.y) < 36 && !b.handled) {
          // simulate drone touching balloon by moving drone to it quickly
          drone.x = b.x;
          drone.y = b.y + 24;
          b.handled = false; // ensure collision check handles it
          checkCollisions();
        }
      }
    }
  });
  canvas.addEventListener("mouseup", () => {
    mouse.down = false;
  });

  // Utility functions
  function distance(x1, y1, x2, y2) {
    const dx = x1 - x2;
    const dy = y1 - y2;
    return Math.sqrt(dx * dx + dy * dy);
  }
  function pointInRect(x, y, rect) {
    return x >= rect.x && x <= rect.x + rect.w && y >= rect.y && y <= rect.y + rect.h;
  }

  // End screen button rect (global to detect clicks)
  let endButtonRect = null;

  // Restart game
  function restartGame() {
    try {
      if (audioEnabled && audioCtx && ambientOsc === null) {
        // attempt to recreate ambient if audio permitted
        initAudio().catch(() => {});
      }
    } catch (e) {}
    score = 0;
    wrong = 0;
    shakeTimer = 0;
    resetDrone();
    generateQuestion();
    state = "playing";
  }

  // Main update loop
  function update(dt) {
    if (state === "playing") {
      // Drone controls: arrow keys or WASD or mouse near pointer (accessible)
      const moveX = (keys["ArrowRight"] || keys["d"] || keys["D"]) - (keys["ArrowLeft"] || keys["a"] || keys["A"]);
      const moveY = (keys["ArrowDown"] || keys["s"] || keys["S"]) - (keys["ArrowUp"] || keys["w"] || keys["W"]);
      // keyboard values booleans; map to -1/0/1
      const kx = (keys["ArrowRight"] || keys["d"] || keys["D"]) ? 1 : (keys["ArrowLeft"] || keys["a"] || keys["A"]) ? -1 : 0;
      const ky = (keys["ArrowDown"] || keys["s"] || keys["S"]) ? 1 : (keys["ArrowUp"] || keys["w"] || keys["W"]) ? -1 : 0;
      // mouse influence when left button is down (drag to fly)
      let targetX = drone.x;
      let targetY = drone.y;
      if (mouse.down) {
        targetX = mouse.x;
        targetY = mouse.y;
      } else {
        // slight follow mouse if near
        if (Math.abs(mouse.x - drone.x) < 120) targetX = drone.x + (mouse.x - drone.x) * 0.02;
        if (Math.abs(mouse.y - drone.y) < 120) targetY = drone.y + (mouse.y - drone.y) * 0.02;
      }
      // combine keyboard and mouse targeting
      const speed = drone.speed;
      if (kx !== 0 || ky !== 0) {
        drone.vx = kx * speed;
        drone.vy = ky * speed;
      } else {
        // gentle move toward target
        drone.vx += (targetX - drone.x) * 2.5 * dt;
        drone.vy += (targetY - drone.y) * 2.5 * dt;
        // clamp
        const max = speed * 0.9;
        drone.vx = Math.max(-max, Math.min(max, drone.vx));
        drone.vy = Math.max(-max, Math.min(max, drone.vy));
      }
      drone.x += drone.vx * dt;
      drone.y += drone.vy * dt;
      // bounds
      drone.x = Math.max(40, Math.min(WIDTH - 40, drone.x));
      drone.y = Math.max(70, Math.min(HEIGHT - 60, drone.y));
      // propeller animation
      drone.propellerAngle += (Math.abs(drone.vx) + Math.abs(drone.vy)) * 0.01 + 0.1;

      // balloons float
      for (const b of balloons) {
        b.wobble += dt * 2;
        b.x += b.vx * dt;
        b.y += Math.sin(b.wobble) * 8 * dt;
        // keep within area
        if (b.x < 60) b.x = 60;
        if (b.x > WIDTH - 60) b.x = WIDTH - 60;
        // gentle horizontal drift
        if (Math.random() < 0.002) b.vx = randFloat(-40, 40);
      }

      // particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.t += dt * 1000;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += 320 * dt; // gravity
        if (p.t >= p.life) particles.splice(i, 1);
      }

      // check collisions
      checkCollisions();
    } else {
      // idle state animations (start/win/lose) slightly animate balloons if any
    }

    if (shakeTimer > 0) {
      shakeTimer = Math.max(0, shakeTimer - dt * 1000);
    }

    // audio bar decay
    animateAudioBars = Math.max(0, animateAudioBars - dt * 0.8);
  }

  // Drawing functions - ensure no overlapping text, use measureText
  function draw() {
    // clear
    ctx.save();
    // screen shake effect when wrong
    if (shakeTimer > 0) {
      const s = Math.sin(shakeTimer / 20) * 8;
      ctx.translate(s, 0);
    }
    ctx.fillStyle = "#eaf3ff";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // background: soft rolling clouds, wacky shapes
    drawClouds();

    // Ground strip
    ctx.fillStyle = "#d9f0e4";
    ctx.fillRect(0, HEIGHT - 60, WIDTH, 60);
    ctx.fillStyle = "#bfe8d6";
    ctx.fillRect(0, HEIGHT - 60, WIDTH, 10);

    // UI: Score top-left, Lives top-right, Question top-center, Instructions bottom-center
    drawTopUI();

    // Draw balloons (answer targets)
    for (const b of balloons) {
      drawBalloon(b);
    }

    // Draw drone
    drawDrone(drone);

    // Draw particles (stars)
    drawParticles();

    // If playing, show gentle hint text near bottom center
    if (state === "playing" && currentQuestion) {
      drawInstruction("Fly the drone to the balloon with the correct answer!", WIDTH / 2, HEIGHT - 24);
    }

    // Draw overlays for start/win/lose
    if (state === "start") {
      drawStartScreen();
    } else if (state === "win") {
      drawEndScreen(true);
    } else if (state === "lose") {
      drawEndScreen(false);
    }

    ctx.restore();
  }

  function drawClouds() {
    // draw several wacky pastel cloud blobs
    const clouds = [
      { x: 90, y: 60, s: 44, hue: 210 },
      { x: 260, y: 40, s: 56, hue: 194 },
      { x: 480, y: 70, s: 40, hue: 220 },
      { x: 620, y: 60, s: 50, hue: 200 }
    ];
    for (const c of clouds) {
      drawWackyCloud(c.x, c.y, c.s, c.hue);
    }
    // faint grid of stars/dots for calm atmosphere
    ctx.fillStyle = "rgba(255,255,255,0.04)";
    for (let i = 0; i < 18; i++) {
      ctx.beginPath();
      const x = 40 + i * 36;
      ctx.arc(x, 24 + Math.sin(i * 0.8) * 6, 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawWackyCloud(x, y, size, hue) {
    ctx.save();
    ctx.translate(x, y);
    for (let i = 0; i < 5; i++) {
      ctx.beginPath();
      ctx.fillStyle = `hsl(${hue + i * 3} 80% ${78 - i * 2}%)`;
      const rx = Math.cos(i * 1.7) * (size * 0.4);
      const ry = Math.sin(i * 1.2) * (size * 0.2);
      ctx.arc(rx, ry, size - i * 6, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawTopUI() {
    // Score top-left
    ctx.font = importantFont;
    ctx.textBaseline = "middle";
    const scoreText = `Score: ${score}/${GOAL_SCORE}`;
    const scoreW = ctx.measureText(scoreText).width;
    const scoreBoxW = scoreW + PADDING * 2;
    const scoreBoxH = 34;
    const scoreX = PADDING;
    const scoreY = PADDING;
    // background rectangle
    roundRect(ctx, scoreX, scoreY, scoreBoxW, scoreBoxH, 8, "#ffffff", "rgba(0,0,0,0.08)");
    // text
    ctx.fillStyle = "#253b4a";
    ctx.fillText(scoreText, scoreX + PADDING, scoreY + scoreBoxH / 2 + 1);

    // Audio visual cue (speaker) placed next to score with spacing
    const speakerX = scoreX + scoreBoxW + 12;
    const speakerY = scoreY + scoreBoxH / 2;
    drawSpeakerIcon(speakerX, speakerY, 18, animateAudioBars);

    // Lives top-right
    ctx.font = importantFont;
    const livesText = `Lives: ${Math.max(0, MAX_WRONG - wrong)}`;
    const livesW = ctx.measureText(livesText).width;
    const livesBoxW = livesW + PADDING * 2;
    const livesBoxH = 34;
    const livesX = WIDTH - livesBoxW - PADDING;
    const livesY = PADDING;
    roundRect(ctx, livesX, livesY, livesBoxW, livesBoxH, 8, "#fff6f6", "rgba(0,0,0,0.06)");
    ctx.fillStyle = "#5a2f2f";
    ctx.fillText(livesText, livesX + PADDING, livesY + livesBoxH / 2 + 1);

    // Question at top-center with background
    ctx.font = titleFont;
    const qText = currentQuestion ? `${currentQuestion.a} ${currentQuestion.op} ${currentQuestion.b} = ?` : "Ready?";
    const qW = ctx.measureText(qText).width;
    const qBoxW = qW + PADDING * 2;
    const qBoxH = 48;
    const qX = Math.round((WIDTH - qBoxW) / 2);
    const qY = PADDING;
    roundRect(ctx, qX, qY, qBoxW, qBoxH, 10, "#ffffff", "rgba(0,0,0,0.06)");
    ctx.fillStyle = "#14384f";
    ctx.fillText(qText, qX + PADDING, qY + qBoxH / 2 + 2);
  }

  function drawSpeakerIcon(x, y, size, level) {
    // Draw small speaker with animated bars indicating audio level
    ctx.save();
    ctx.translate(x, y);
    // speaker body
    ctx.fillStyle = "#2d4b5b";
    ctx.fillRect(-8, -8, 12, 16);
    // cone
    ctx.beginPath();
    ctx.moveTo(4, -8);
    ctx.lineTo(8, -4);
    ctx.lineTo(8, 4);
    ctx.lineTo(4, 8);
    ctx.closePath();
    ctx.fill();
    // bars
    const barCount = 3;
    for (let i = 0; i < barCount; i++) {
      const h = 6 + level * 18 * Math.random() * (i + 1);
      ctx.fillStyle = `rgba(40,120,160,${0.4 + i * 0.2})`;
      ctx.fillRect(12 + i * 6, -h / 2, 4, h);
    }
    ctx.restore();
  }

  function drawBalloon(b) {
    // balloon string
    ctx.save();
    // slight wobble effect
    const wob = Math.sin(b.wobble) * 6;
    // balloon body
    ctx.beginPath();
    ctx.fillStyle = b.color;
    ctx.strokeStyle = "rgba(0,0,0,0.06)";
    ctx.lineWidth = 1.5;
    ctx.ellipse(b.x + wob, b.y, 28, 34, Math.sin(b.wobble) * 0.15, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // highlight
    ctx.beginPath();
    ctx.fillStyle = "rgba(255,255,255,0.55)";
    ctx.ellipse(b.x - 8 + wob, b.y - 8, 8, 10, 0, 0, Math.PI * 2);
    ctx.fill();

    // string
    ctx.beginPath();
    ctx.strokeStyle = "rgba(80,80,80,0.18)";
    ctx.lineWidth = 2;
    ctx.moveTo(b.x + wob, b.y + 28);
    ctx.quadraticCurveTo(b.x + wob + 8, b.y + 44, b.x + wob - 6, b.y + 54);
    ctx.stroke();

    // label box behind value for readability
    ctx.font = bodyFont;
    ctx.textBaseline = "middle";
    const text = String(b.value);
    const tw = ctx.measureText(text).width;
    const bw = tw + 14;
    const bh = 26;
    const bx = b.x - bw / 2 + wob;
    const by = b.y + 44;
    roundRect(ctx, bx, by, bw, bh, 8, "#ffffff", "rgba(0,0,0,0.06)");
    ctx.fillStyle = "#17394a";
    ctx.fillText(text, bx + 7, by + bh / 2 + 1);

    ctx.restore();
  }

  function drawDrone(d) {
    if (!d) return;
    ctx.save();
    ctx.translate(d.x, d.y);
    // drone shadow
    ctx.beginPath();
    ctx.fillStyle = "rgba(0,0,0,0.12)";
    ctx.ellipse(0, 34, 40, 12, 0, 0, Math.PI * 2);
    ctx.fill();

    // body
    ctx.beginPath();
    ctx.fillStyle = "#ffc86b"; // wacky color
    ctx.strokeStyle = "#b37a2b";
    ctx.lineWidth = 2;
    ctx.ellipse(0, 0, 48, 28, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // window
    ctx.beginPath();
    ctx.fillStyle = "#cfefff";
    ctx.ellipse(-6, -4, 18, 12, 0.1, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "rgba(0,0,0,0.06)";
    ctx.stroke();

    // legs
    ctx.beginPath();
    ctx.strokeStyle = "#6a4b30";
    ctx.lineWidth = 3;
    ctx.moveTo(-26, 18);
    ctx.lineTo(-16, 30);
    ctx.moveTo(26, 18);
    ctx.lineTo(16, 30);
    ctx.stroke();

    // propellers (wacky)
    for (let i = -1; i <= 1; i += 2) {
      const px = i * 36;
      const py = -12;
      ctx.save();
      ctx.translate(px, py);
      ctx.rotate(d.propellerAngle * (i * -1));
      // hub
      ctx.beginPath();
      ctx.fillStyle = "#5a5a5a";
      ctx.arc(0, 0, 6, 0, Math.PI * 2);
      ctx.fill();
      // blades
      ctx.beginPath();
      ctx.fillStyle = "rgba(80,80,80,0.8)";
      ctx.ellipse(0, -14, 6, 22, 0.6, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(0, 14, 6, 22, -0.6, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // small smiley face on window (friendly)
    ctx.beginPath();
    ctx.fillStyle = "#2c5d6f";
    ctx.arc(-10, -6, 2.5, 0, Math.PI * 2);
    ctx.arc(-2, -6, 2.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.strokeStyle = "#2c5d6f";
    ctx.lineWidth = 1.5;
    ctx.arc(-6, -2, 4, 0, Math.PI);
    ctx.stroke();

    ctx.restore();
  }

  function drawParticles() {
    for (const p of particles) {
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.globalAlpha = 1 - p.t / p.life;
      ctx.fillStyle = `hsl(${p.hue} 80% 60%)`;
      // draw star-ish shape
      drawStar(ctx, 0, 0, 5, p.size * 0.4, p.size);
      ctx.restore();
    }
    ctx.globalAlpha = 1;
  }

  function drawInstruction(text, x, y) {
    ctx.font = bodyFont;
    ctx.textBaseline = "middle";
    const tw = ctx.measureText(text).width;
    const bw = tw + PADDING * 2;
    const bh = 32;
    const bx = x - bw / 2;
    const by = y - bh / 2;
    roundRect(ctx, bx, by, bw, bh, 8, "rgba(255,255,255,0.9)", "rgba(0,0,0,0.05)");
    ctx.fillStyle = "#1b3b4b";
    ctx.fillText(text, bx + PADDING, by + bh / 2 + 1);
  }

  function drawStartScreen() {
    // Big friendly title / instructions
    ctx.save();
    // dim background
    ctx.fillStyle = "rgba(8, 24, 40, 0.38)";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    const title = "Drone Math Adventure!";
    const subtitle = "Help your drone collect the correct answers.";
    const prompt = "Click or press Space to start and enable sound (optional).";
    ctx.font = titleFont;
    ctx.fillStyle = "#fff";
    const tw = ctx.measureText(title).width;
    ctx.fillText(title, (WIDTH - tw) / 2, HEIGHT / 2 - 40);
    ctx.font = importantFont;
    const tw2 = ctx.measureText(subtitle).width;
    ctx.fillText(subtitle, (WIDTH - tw2) / 2, HEIGHT / 2 - 6);
    ctx.font = bodyFont;
    const tw3 = ctx.measureText(prompt).width;
    ctx.fillText(prompt, (WIDTH - tw3) / 2, HEIGHT / 2 + 30);

    // small accessibility hints
    const hint = "Controls: Arrow keys or WASD to fly. Or drag with mouse. Press M to mute/unmute. Press R to restart.";
    ctx.font = "14px Arial";
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    const hintW = ctx.measureText(hint).width;
    ctx.fillText(hint, (WIDTH - hintW) / 2, HEIGHT / 2 + 62);
    ctx.restore();
  }

  function drawEndScreen(won) {
    // semi-transparent overlay
    ctx.fillStyle = "rgba(8, 24, 40, 0.35)";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    ctx.save();
    const title = won ? "You Win! Great Flying!" : "Game Over";
    const message = won
      ? `You collected ${score} correct answers!`
      : `You made ${wrong} wrong answers. Try again!`;
    ctx.font = titleFont;
    ctx.fillStyle = "#fff";
    const titleW = ctx.measureText(title).width;
    ctx.fillText(title, (WIDTH - titleW) / 2, HEIGHT / 2 - 40);

    ctx.font = importantFont;
    const msgW = ctx.measureText(message).width;
    ctx.fillText(message, (WIDTH - msgW) / 2, HEIGHT / 2 - 6);

    // Restart button (draw and store rect for click detection)
    const btnText = "Restart (R)";
    ctx.font = importantFont;
    const btnW = ctx.measureText(btnText).width + PADDING * 2;
    const btnH = 44;
    const bx = (WIDTH - btnW) / 2;
    const by = HEIGHT / 2 + 20;
    roundRect(ctx, bx, by, btnW, btnH, 10, "#fff", "rgba(0,0,0,0.12)");
    ctx.fillStyle = "#15384a";
    ctx.fillText(btnText, bx + PADDING, by + btnH / 2 + 2);

    // store button rect (for click)
    endButtonRect = { x: bx, y: by, w: btnW, h: btnH };

    // small extra instruction
    ctx.font = bodyFont;
    const extra = "Press Space or click Restart to play again.";
    const ew = ctx.measureText(extra).width;
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.fillText(extra, (WIDTH - ew) / 2, by + btnH + 30);

    ctx.restore();
  }

  // Drawing helpers
  function roundRect(ctx, x, y, w, h, r, fillColor = "#fff", strokeStyle = null) {
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fillColor) {
      ctx.fillStyle = fillColor;
      ctx.fill();
    }
    if (strokeStyle) {
      ctx.strokeStyle = strokeStyle;
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawStar(ctx, x, y, points, innerR, outerR) {
    ctx.beginPath();
    for (let i = 0; i < points * 2; i++) {
      const r = (i % 2 === 0) ? outerR : innerR;
      const a = (i / (points * 2)) * Math.PI * 2;
      const px = x + Math.cos(a) * r;
      const py = y + Math.sin(a) * r;
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fill();
  }

  // Main loop
  function loop(ts) {
    if (!lastTime) lastTime = ts;
    const dt = Math.min(35, ts - lastTime) / 1000; // clamp dt for stability
    lastTime = ts;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // Start the animation loop
  requestAnimationFrame(loop);

  // Error handling for audio creation is handled in initAudio and playTone with try/catch

  // Provide a small notify if audio not available
  setTimeout(() => {
    if (!audioEnabled && state === "start") {
      // show tiny hint on start screen - drawn by drawStartScreen, but log also
      console.info("Audio is disabled or blocked. You can still play the game without sound.");
    }
  }, 800);

})();
---

