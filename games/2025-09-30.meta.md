# Game of the Day - 2025-09-30

## Metadata
- **Generated Date:** 2025-09-30
- **Generated Time:** 2025-09-30T00:27:15.394800
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-30.js
- **File Size:** 25972 bytes
- **Tokens Used:** 8780

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-30.js` - The playable game
- `2025-09-30.meta.json` - Machine-readable metadata
- `2025-09-30.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 19620

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 22635

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Machine Math Catcher
  // Game for ages 7-9: catch falling number gears that solve shown problems.
  // Renders inside #game-of-the-day-stage and uses Web Audio API for sounds.
  // All visuals drawn on canvas. Keyboard + mouse controls. Accessible messages.

  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const CONTAINER_ID = "game-of-the-day-stage";
  const MAX_LEVEL = 6;

  // Utility functions
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a, b) => a + Math.random() * (b - a);
  const choose = (arr) => arr[Math.floor(Math.random() * arr.length)];
  const deepCopy = (o) => JSON.parse(JSON.stringify(o));

  // Find container
  const container = document.getElementById(CONTAINER_ID);
  if (!container) {
    console.error("Game container not found:", CONTAINER_ID);
    return;
  }

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.width = WIDTH + "px";
  canvas.style.height = HEIGHT + "px";
  canvas.setAttribute("role", "img");
  canvas.setAttribute("aria-label", "Machine Math Catcher. Use arrow keys to move, space to catch. Press Enter to start.");
  canvas.tabIndex = 0; // make focusable
  container.innerHTML = "";
  container.appendChild(canvas);

  // Create hidden live region for accessibility updates
  const live = document.createElement("div");
  live.setAttribute("aria-live", "polite");
  live.style.position = "absolute";
  live.style.left = "-9999px";
  container.appendChild(live);

  const ctx = canvas.getContext("2d");

  // Colors and style
  const bgColor = "#e7f0f7";
  const pastel = ["#F6C1D9", "#CFE8D8", "#FFE9A8", "#CDE7FF", "#E7D9FF"];
  const machineColor = "#A0B2C9";
  const accent = "#6E8CA8";
  const textColor = "#24323F";

  // Audio setup with error handling
  let audioEnabled = true;
  let audioContext = null;
  let masterGain = null;
  let ambientGain = null;
  let ambientOsc = null;

  function initAudio() {
    if (!audioEnabled || audioContext) return;
    try {
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      audioContext = new AudioCtx();
      masterGain = audioContext.createGain();
      masterGain.gain.value = 0.9;
      masterGain.connect(audioContext.destination);

      ambientGain = audioContext.createGain();
      ambientGain.gain.value = 0.06;
      ambientGain.connect(masterGain);

      // Gentle ambient oscillator (wobbling sine)
      ambientOsc = audioContext.createOscillator();
      const ambientFilter = audioContext.createBiquadFilter();
      ambientFilter.type = "lowpass";
      ambientFilter.frequency.value = 600;
      ambientOsc.type = "sine";
      ambientOsc.frequency.value = 220;
      ambientOsc.connect(ambientFilter);
      ambientFilter.connect(ambientGain);
      ambientOsc.start();

      // LFO to modulate ambient frequency for a breathing effect
      const lfo = audioContext.createOscillator();
      lfo.frequency.value = 0.1;
      const lfoGain = audioContext.createGain();
      lfoGain.gain.value = 40;
      lfo.connect(lfoGain);
      lfoGain.connect(ambientOsc.frequency);
      lfo.start();

    } catch (e) {
      console.warn("Audio initialization failed:", e);
      audioEnabled = false;
      audioContext = null;
      masterGain = null;
      ambientGain = null;
      ambientOsc = null;
    }
  }

  // Sound helper: short beep with envelope
  function playBeep({freq = 880, type = "sine", duration = 0.18, gain = 0.15, detune = 0} = {}) {
    if (!audioEnabled || !audioContext) return;
    try {
      const now = audioContext.currentTime;
      const o = audioContext.createOscillator();
      const g = audioContext.createGain();
      o.type = type;
      o.frequency.value = freq;
      if (detune) o.detune.value = detune;
      g.gain.value = 0.0001;
      o.connect(g);
      g.connect(masterGain);
      o.start(now);
      // envelope
      g.gain.linearRampToValueAtTime(gain, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);
      o.stop(now + duration + 0.05);
    } catch (e) {
      console.warn("playBeep error:", e);
    }
  }

  function playCorrectSound() {
    // joyful chord
    playBeep({freq: 880, type: "sine", duration: 0.12, gain: 0.12});
    setTimeout(() => playBeep({freq: 1320, type: "triangle", duration: 0.18, gain: 0.08}), 60);
    setTimeout(() => playBeep({freq: 660, type: "sine", duration: 0.16, gain: 0.07}), 120);
  }

  function playIncorrectSound() {
    // descending buzz
    playBeep({freq: 360, type: "sawtooth", duration: 0.2, gain: 0.14, detune: -10});
    setTimeout(() => playBeep({freq: 240, type: "sawtooth", duration: 0.24, gain: 0.10}), 130);
  }

  function playPickupSound() {
    playBeep({freq: 720, type: "triangle", duration: 0.12, gain: 0.09});
  }

  function toggleAudio() {
    if (!audioContext) {
      initAudio();
    }
    if (!audioEnabled) return;
    if (audioContext && audioContext.state === "suspended") {
      audioContext.resume().catch(() => {});
    }
    // Toggle ambient
    if (ambientGain) {
      ambientGain.gain.value = ambientGain.gain.value > 0.03 ? 0 : 0.06;
    }
  }

  // Game objects and state
  let keys = {};
  let mouseX = WIDTH / 2;

  class FallingItem {
    constructor(x, y, vy, value, color, id) {
      this.x = x;
      this.y = y;
      this.vy = vy;
      this.value = value;
      this.color = color;
      this.radius = 26;
      this.id = id;
      this.rotation = 0;
      this.spin = rand(-0.06, 0.06);
    }
    update(dt) {
      this.y += this.vy * dt;
      this.rotation += this.spin * dt * 60;
    }
    draw(ctx) {
      // gear-like circle with teeth
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.rotation);
      // main circle
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.strokeStyle = shade(this.color, -20);
      ctx.lineWidth = 2;
      ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      // teeth
      for (let i = 0; i < 10; i++) {
        const angle = (Math.PI * 2 * i) / 10;
        const tx = Math.cos(angle) * (this.radius + 6);
        const ty = Math.sin(angle) * (this.radius + 6);
        ctx.beginPath();
        ctx.fillStyle = shade(this.color, -8);
        ctx.rect(tx - 4, ty - 3, 8, 6);
        ctx.fill();
      }
      // value text
      ctx.fillStyle = textColor;
      ctx.font = "bold 18px Verdana, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(this.value), 0, 2);
      ctx.restore();
    }
  }

  // Robot basket controlled by player
  const basket = {
    x: WIDTH / 2,
    y: HEIGHT - 70,
    width: 140,
    height: 36,
    speed: 380,
    color: "#FFFBF0",
    handleOffset: 28,
    draw(ctx) {
      ctx.save();
      // base
      ctx.fillStyle = this.color;
      ctx.strokeStyle = "#c0c7d0";
      roundRect(ctx, this.x - this.width / 2, this.y - this.height / 2, this.width, this.height, 10, true, true);

      // mechanical handle/arm
      ctx.beginPath();
      ctx.strokeStyle = "#7a8896";
      ctx.lineWidth = 6;
      ctx.lineCap = "round";
      ctx.moveTo(this.x - this.width / 2 + this.handleOffset, this.y - this.height / 2);
      ctx.lineTo(this.x - this.width / 2 + this.handleOffset, this.y - this.height / 2 - 36);
      ctx.stroke();

      // little gears & bolts
      ctx.fillStyle = "#b7c3d1";
      ctx.beginPath();
      ctx.arc(this.x + this.width / 2 - 20, this.y - 4, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  };

  // Game state
  let state = {
    mode: "menu", // menu | playing | levelComplete | win
    level: 1,
    score: 0,
    items: [],
    spawnTimer: 0,
    requiredCorrect: 5,
    caughtCorrect: 0,
    timeLeft: 30,
    targetProblem: null,
    targetAnswer: null,
    spawnInterval: 1200, // ms
    gravity: 80, // pixels per second
    paused: false,
    soundOn: true,
    touchedAudioPermission: false
  };

  // Level parameter generator
  function setupLevel(level) {
    state.items = [];
    state.caughtCorrect = 0;
    state.score = state.score; // preserve
    state.level = level;
    state.spawnTimer = 0;
    state.timeLeft = 30 + Math.max(0, 6 - level) * 5;
    // Define operations by level
    const levelConfig = [
      {op: "add", maxA: 5, maxB: 5, required: 4, spawn: 1400, gravity: 70},
      {op: "add", maxA: 10, maxB: 10, required: 5, spawn: 1200, gravity: 90},
      {op: "sub", maxA: 10, maxB: 9, required: 5, spawn: 1200, gravity: 100},
      {op: "sub", maxA: 15, maxB: 10, required: 6, spawn: 1000, gravity: 120},
      {op: "mult", maxA: 5, maxB: 5, required: 6, spawn: 900, gravity: 130},
      {op: "mix", maxA: 10, maxB: 6, required: 7, spawn: 800, gravity: 150},
    ];
    const cfg = levelConfig[Math.min(level - 1, levelConfig.length - 1)];
    state.requiredCorrect = cfg.required;
    state.spawnInterval = cfg.spawn;
    state.gravity = cfg.gravity;
    // choose a problem to display (mix encourages choosing an operation each time)
    const op = cfg.op === "mix" ? choose(["add", "sub", "mult"]) : cfg.op;
    let a, b, ans;
    if (op === "add") {
      a = Math.floor(rand(1, cfg.maxA + 1));
      b = Math.floor(rand(1, cfg.maxB + 1));
      ans = a + b;
      state.targetProblem = `${a} + ${b}`;
    } else if (op === "sub") {
      a = Math.floor(rand(2, cfg.maxA + 1));
      b = Math.floor(rand(1, Math.min(a - 1, cfg.maxB) + 1));
      ans = a - b;
      state.targetProblem = `${a} - ${b}`;
    } else if (op === "mult") {
      a = Math.floor(rand(2, cfg.maxA + 1));
      b = Math.floor(rand(1, cfg.maxB + 1));
      ans = a * b;
      state.targetProblem = `${a} × ${b}`;
    } else {
      // fallback
      a = 1; b = 1; ans = 2;
      state.targetProblem = "1 + 1";
    }
    state.targetAnswer = ans;
    announce(`Level ${level}. Solve: ${state.targetProblem}. Catch ${state.requiredCorrect} matching gears.`);
  }

  // Accessibility announcement
  function announce(msg) {
    if (!live) return;
    live.textContent = msg;
  }

  // Helpers for drawing
  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    r = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  function shade(hex, percent) {
    // simple hex shading: hex: #RRGGBB
    try {
      const num = parseInt(hex.slice(1), 16);
      let r = (num >> 16) + percent;
      let g = ((num >> 8) & 0x00FF) + percent;
      let b = (num & 0x0000FF) + percent;
      r = clamp(Math.round(r), 0, 255);
      g = clamp(Math.round(g), 0, 255);
      b = clamp(Math.round(b), 0, 255);
      return "#" + (r << 16 | g << 8 | b).toString(16).padStart(6, "0");
    } catch (e) {
      return hex;
    }
  }

  // Spawn items periodically
  let nextItemId = 1;
  function spawnItem() {
    const x = rand(60, WIDTH - 60);
    const y = -40;
    const vy = state.gravity * (0.007 + Math.random() * 0.015) + state.gravity * 0.3;
    let value;
    // We will spawn a mix of values including the correct answer among others
    const chanceCorrect = 0.28 + Math.min(0.4, state.level * 0.05);
    if (Math.random() < chanceCorrect) {
      value = state.targetAnswer;
    } else {
      // generate a plausible distractor
      const spread = Math.max(3, Math.floor(state.level * 2));
      value = state.targetAnswer + Math.floor(rand(-spread, spread + 1));
      if (value < 0) value = Math.abs(value) + 1;
      if (value === state.targetAnswer) value += 2;
    }
    const color = choose(pastel);
    const item = new FallingItem(x, y, vy, value, color, nextItemId++);
    state.items.push(item);
  }

  // Collision detection
  function checkCatch(item) {
    const left = basket.x - basket.width / 2;
    const right = basket.x + basket.width / 2;
    const top = basket.y - basket.height / 2;
    // treat catch zone as top of basket
    return item.y + item.radius > top - 6 && item.y < basket.y + basket.height && item.x > left && item.x < right;
  }

  // Input handling
  canvas.addEventListener("keydown", (e) => {
    keys[e.key] = true;
    // Start on Enter
    if (state.mode === "menu" && (e.key === "Enter" || e.key === " ")) {
      startGame();
    }
    if (e.key === "m" || e.key === "M") {
      // toggle ambient audio
      if (audioContext && audioContext.state === "suspended") audioContext.resume().catch(()=>{});
      if (audioEnabled && ambientGain) {
        ambientGain.gain.value = ambientGain.gain.value > 0.03 ? 0 : 0.06;
      }
    }
    if (e.key === "p" || e.key === "P") {
      state.paused = !state.paused;
      if (state.paused) announce("Game paused");
      else announce("Game resumed");
    }
  });
  canvas.addEventListener("keyup", (e) => {
    keys[e.key] = false;
  });
  window.addEventListener("keydown", (e) => {
    // allow arrow keys even if canvas not focused
    if (["ArrowLeft", "ArrowRight", " ", "Spacebar"].includes(e.key)) {
      // prevent page scroll
      e.preventDefault();
    }
    keys[e.key] = true;
  });
  window.addEventListener("keyup", (e) => {
    keys[e.key] = false;
  });

  // Mouse movement for control
  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
  });

  canvas.addEventListener("mousedown", (e) => {
    // On first user interaction, unlock audio
    if (!state.touchedAudioPermission) {
      try {
        initAudio();
        if (audioContext && audioContext.state === "suspended") audioContext.resume().catch(()=>{});
      } catch (err) {}
      state.touchedAudioPermission = true;
    }
    // If in menu, start
    if (state.mode === "menu") startGame();
  });

  // Game controls: move basket
  function updateInput(dt) {
    const left = keys["ArrowLeft"] || keys["a"] || keys["A"];
    const right = keys["ArrowRight"] || keys["d"] || keys["D"];
    const useMouse = keys["Mouse"] ? false : true; // mouse movement always used when moved
    let targetX = basket.x;
    if (left) targetX -= basket.speed * dt;
    if (right) targetX += basket.speed * dt;
    // mouse control: if no keyboard pressed and mouse active, follow mouseX
    if (!left && !right) {
      targetX = mouseX;
    }
    basket.x = clamp(targetX, basket.width / 2 + 6, WIDTH - basket.width / 2 - 6);
  }

  // Main update loop
  let lastTime = performance.now();
  function loop(now) {
    const dt = Math.min(60, now - lastTime) / 1000;
    lastTime = now;
    // update
    if (state.mode === "playing" && !state.paused) {
      // spawn
      state.spawnTimer += (dt * 1000);
      if (state.spawnTimer >= state.spawnInterval) {
        state.spawnTimer = 0;
        spawnItem();
      }
      // update items
      for (let it of state.items) {
        it.update(dt);
      }
      // check catches
      for (let i = state.items.length - 1; i >= 0; i--) {
        const it = state.items[i];
        if (checkCatch(it)) {
          // caught
          const correct = it.value === state.targetAnswer;
          if (correct) {
            state.caughtCorrect++;
            state.score += 10;
            playCorrectSound();
            announce(`Correct! Caught ${it.value}. ${state.caughtCorrect} of ${state.requiredCorrect}`);
          } else {
            state.score = Math.max(0, state.score - 2);
            playIncorrectSound();
            announce(`Oops! ${it.value} is not ${state.targetAnswer}`);
          }
          state.items.splice(i, 1);
        } else if (it.y - it.radius > HEIGHT + 40) {
          // dropped beyond bottom
          // penalize only if correct item missed
          if (it.value === state.targetAnswer) {
            state.score = Math.max(0, state.score - 3);
            announce("A correct gear fell! Try to catch them.");
          }
          state.items.splice(i, 1);
        }
      }

      // time left
      state.timeLeft -= dt;
      if (state.timeLeft <= 0) {
        // level failed? allow replay or treat as level over
        if (state.caughtCorrect >= state.requiredCorrect) {
          advanceLevel();
        } else {
          // allow retry same level
          state.mode = "levelComplete";
          announce(`Time's up. You caught ${state.caughtCorrect} of ${state.requiredCorrect}. Press Enter to retry.`);
        }
      } else if (state.caughtCorrect >= state.requiredCorrect) {
        advanceLevel();
      }

      updateInput(dt);
    }

    // render
    render();

    requestAnimationFrame(loop);
  }

  // Advance level / Win
  function advanceLevel() {
    state.mode = "levelComplete";
    if (state.level >= MAX_LEVEL) {
      state.mode = "win";
      announce(`Amazing! You beat all levels and scored ${state.score} points. Press Enter to play again.`);
    } else {
      announce(`Level ${state.level} complete! Catch ${state.requiredCorrect} solved. Press Enter for next level.`);
    }
  }

  // Start or restart game
  function startGame() {
    // unlock audio on user gesture
    if (!state.touchedAudioPermission) {
      try {
        initAudio();
        if (audioContext && audioContext.state === "suspended") audioContext.resume().catch(()=>{});
      } catch (e) {}
      state.touchedAudioPermission = true;
    }
    state.mode = "playing";
    state.score = 0;
    state.level = 1;
    setupLevel(1);
    announce(`Starting level ${state.level}. Solve ${state.targetProblem}`);
  }

  function nextOrRetry() {
    if (state.mode === "levelComplete") {
      if (state.caughtCorrect >= state.requiredCorrect) {
        // go to next
        state.level = Math.min(MAX_LEVEL, state.level + 1);
        setupLevel(state.level);
        state.mode = "playing";
      } else {
        // retry
        setupLevel(state.level);
        state.mode = "playing";
      }
    } else if (state.mode === "win") {
      // restart
      state.score = 0;
      state.level = 1;
      setupLevel(1);
      state.mode = "playing";
    }
  }

  // Keyboard Enter to proceed
  window.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      if (state.mode === "menu") {
        startGame();
      } else if (state.mode === "levelComplete" || state.mode === "win") {
        nextOrRetry();
      }
    }
  });

  // Drawing everything
  function render() {
    // background
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    // soft gradient sky
    const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    grad.addColorStop(0, shade(bgColor, -6));
    grad.addColorStop(1, bgColor);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    drawWackyMachines(ctx);

    // belt
    drawConveyor(ctx);

    // falling items
    for (let it of state.items) {
      it.draw(ctx);
    }

    // basket
    basket.draw(ctx);

    // HUD / overlay
    drawHUD(ctx);

    // menu overlay
    if (state.mode === "menu") {
      drawMenu(ctx);
    } else if (state.mode === "levelComplete") {
      drawLevelComplete(ctx);
    } else if (state.mode === "win") {
      drawWin(ctx);
    }
  }

  function drawWackyMachines(ctx) {
    ctx.save();
    // big rounded machine silhouette at left
    ctx.fillStyle = machineColor;
    ctx.strokeStyle = shade(machineColor, -20);
    ctx.lineWidth = 2;
    roundRect(ctx, 20, 40, 240, 220, 18, true, true);

    // pipes
    ctx.strokeStyle = "#9fb0c9";
    ctx.lineWidth = 10;
    ctx.beginPath();
    ctx.moveTo(260, 100);
    ctx.lineTo(360, 110);
    ctx.lineTo(420, 90);
    ctx.stroke();

    // whimsical gear cluster on right
    drawGear(ctx, 580, 110, 34, "#FFD5B8");
    drawGear(ctx, 640, 140, 26, "#D6E9F8");
    drawGear(ctx, 600, 170, 18, "#E6D6FF");

    // glass tubes
    ctx.fillStyle = "rgba(255,255,255,0.14)";
    roundRect(ctx, 500, 200, 140, 200, 12, true, false);
    ctx.strokeStyle = "#cfe1ef";
    ctx.strokeRect(500, 200, 140, 200);

    ctx.restore();
  }

  function drawGear(ctx, x, y, r, color) {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = color;
    ctx.strokeStyle = shade(color, -25);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    for (let i = 0; i < 8; i++) {
      const angle = (Math.PI * 2 * i) / 8;
      const tx = Math.cos(angle) * (r + 6);
      const ty = Math.sin(angle) * (r + 6);
      ctx.fillStyle = shade(color, -8);
      ctx.fillRect(tx - 4, ty - 4, 8, 8);
    }
    ctx.restore();
  }

  function drawConveyor(ctx) {
    ctx.save();
    const beltY = HEIGHT - 120;
    // base platform
    ctx.fillStyle = "#dfeaf3";
    roundRect(ctx, 0, beltY, WIDTH, 80, 8, true, false);

    // moving stripes for conveyor illusion
    const t = performance.now() * 0.02;
    for (let i = -1; i < WIDTH / 40 + 3; i++) {
      const x = (i * 40 + (t % 40));
      ctx.fillStyle = "#cbd6e4";
      ctx.fillRect(x, beltY + 46, 20, 14);
      ctx.fillStyle = "#e9f0f8";
      ctx.fillRect(x + 20, beltY + 46, 20, 14);
    }

    // little machine pipe above conveyor
    ctx.fillStyle = "#b6c7d8";
    ctx.fillRect(40, beltY - 10, 140, 12);
    ctx.fillRect(220, beltY - 16, 120, 18);
    ctx.restore();
  }

  function drawHUD(ctx) {
    ctx.save();
    // info panel
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    roundRect(ctx, 12, 12, 260, 74, 10, true, true);

    ctx.fillStyle = textColor;
    ctx.font = "bold 16px Verdana, Arial";
    ctx.fillText(`Level: ${state.level}`, 28, 34);
    ctx.fillText(`Score: ${state.score}`, 28, 58);

    ctx.font = "14px Verdana, Arial";
    ctx.fillText(`Problem: ${state.targetProblem || "-"}`, 140, 34);
    ctx.fillText(`Catch: ${state.requiredCorrect}  Got: ${state.caughtCorrect}`, 140, 58);

    // time bar
    const barX = 300;
    const barY = 22;
    const barW = 400;
    const barH = 18;
    ctx.fillStyle = "#e6eef8";
    roundRect(ctx, barX, barY, barW, barH, 8, true, true);
    const pct = clamp(state.timeLeft / (30 + Math.max(0, 6 - state.level) * 5), 0, 1);
    ctx.fillStyle = pct > 0.5 ? "#B6E3A8" : (pct > 0.2 ? "#FFF3A6" : "#F6B5B0");
    roundRect(ctx, barX, barY, barW * pct, barH, 8, true, false);
    ctx.fillStyle = textColor;
    ctx.font = "13px Verdana, Arial";
    ctx.textAlign = "center";
    ctx.fillText(`Time: ${Math.ceil(state.timeLeft)}s`, barX + barW / 2, barY + barH - 4);

    // audio icon
    ctx.textAlign = "left";
    ctx.font = "12px Verdana, Arial";
    ctx.fillStyle = textColor;
    ctx.fillText(`Keyboard: ← → or A/D. Press Enter to start. Press M to mute.`, 18, HEIGHT - 12);

    // audio visual cue
    ctx.fillStyle = audioContext && ambientGain && ambientGain.gain.value > 0.03 ? "#7ACBF2" : "#C4C9CE";
    ctx.beginPath();
    ctx.arc(WIDTH - 28, 36, 10, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#fff";
    ctx.font = "10px Verdana, Arial";
    ctx.textAlign = "center";
    ctx.fillText("♪", WIDTH - 28, 40);

    ctx.restore();
  }

  function drawMenu(ctx) {
    ctx.save();
    // translucent overlay
    ctx.fillStyle = "rgba(10,20,30,0.28)";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // title card
    ctx.fillStyle = "#fff";
    roundRect(ctx, WIDTH / 2 - 260, HEIGHT / 2 - 110, 520, 220, 14, true, true);
    ctx.fillStyle = textColor;
    ctx.font = "bold 32px Verdana, Arial";
    ctx.textAlign = "center";
    ctx.fillText("Machine Math Catcher", WIDTH / 2, HEIGHT / 2 - 50);

    ctx.font = "18px Verdana, Arial";
    ctx.fillText("Catch gears that show the answer to the problem", WIDTH / 2, HEIGHT / 2 - 12);

    ctx.font = "16px Verdana, Arial";
    ctx.fillText("Use ← → or A/D (or move mouse). Press Enter to start.", WIDTH / 2, HEIGHT / 2 + 18);

    ctx.font = "14px Verdana, Arial";
    ctx.fillText("Press M to toggle audio, P to pause during play. Space or click to begin.", WIDTH / 2, HEIGHT / 2 + 52);

    ctx.restore();
  }

  function drawLevelComplete(ctx) {
    ctx.save();
    ctx.fillStyle = "rgba(10,20,30,0.32)";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    ctx.fillStyle = "#fff";
    roundRect(ctx, WIDTH / 2 - 240, HEIGHT / 2 - 90, 480, 160, 12, true, true);

    ctx.fillStyle = textColor;
    ctx.font = "bold 28px Verdana, Arial";
    ctx.textAlign = "center";
    if (state.caughtCorrect >= state.requiredCorrect) {
      ctx.fillText("Level Complete!", WIDTH / 2, HEIGHT / 2 - 20);
      ctx.font = "18px Verdana, Arial";
      ctx.fillText(`Great job! Score: ${state.score}`, WIDTH / 2, HEIGHT / 2 + 10);
      ctx.fillText("Press Enter for next level", WIDTH / 2, HEIGHT / 2 + 44);
    } else {
      ctx.fillText("Level Over", WIDTH / 2, HEIGHT / 2 - 20);
      ctx.font = "18px Verdana, Arial";
      ctx.fillText(`You caught ${state.caughtCorrect} of ${state.requiredCorrect}`, WIDTH / 2, HEIGHT / 2 + 10);
      ctx.fillText("Press Enter to try again", WIDTH / 2, HEIGHT / 2 + 44);
    }
    ctx.restore();
  }

  function drawWin(ctx) {
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.96)";
    roundRect(ctx, WIDTH / 2 - 260, HEIGHT / 2 - 120, 520, 200, 14, true, true);

    ctx.fillStyle = "#2a3b45";
    ctx.font = "bold 30px Verdana, Arial";
    ctx.textAlign = "center";
    ctx.fillText("You did it! Machine Master!", WIDTH / 2, HEIGHT / 2 - 20);

    ctx.font = "18px Verdana, Arial";
    ctx.fillText(`Final Score: ${state.score}`, WIDTH / 2, HEIGHT / 2 + 12);
    ctx.fillText("Press Enter to play again", WIDTH / 2, HEIGHT / 2 + 46);

    ctx.restore();
  }

  // Start the animation loop
  lastTime = performance.now();
  requestAnimationFrame(loop);

  // Initialize menu text
  announce("Welcome to Machine Math Catcher. Press Enter to start. Use arrow keys or mouse to move. Press M to toggle audio.");

  // Expose some debugging in window for safety (not necessary but helpful)
  window.machineMathState = state;

})();
---

