{
  "generated_date": "2025-11-02",
  "generated_timestamp": "2025-11-02T00:29:30.489054",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 10088,
  "game_filename": "2025-11-02.js",
  "game_size_bytes": 29883,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Drone Math Dash\n  // Educational game for ages 7-9. Canvas + Web Audio only.\n  // Renders inside element with ID \"game-of-the-day-stage\".\n  // Strictly uses canvas drawing, Web Audio API oscillators for sound.\n  //\n  // Clear rules:\n  // - Goal: Answer 10 questions correctly to WIN.\n  // - Failure: 3 wrong answers = GAME OVER.\n  // - Victory and Game Over screens show restart instructions/button.\n  //\n  // Accessibility & Controls:\n  // - Mouse/touch to pick answers.\n  // - Keyboard: keys 1-4 select answers; Enter confirms; Arrow keys move selection; M toggles sound; R restarts.\n  // - Visual cues for sound status and selected answer.\n  //\n  // Note: All sizes and positions are computed to avoid overlapping text using ctx.measureText.\n  // Proper padding for readable UI elements is respected.\n\n  // Configuration constants\n  const CANVAS_WIDTH = 720;\n  const CANVAS_HEIGHT = 480;\n  const UI_PADDING = 12; // minimum padding between UI elements\n  const TARGET_CORRECT = 10;\n  const MAX_WRONG = 3;\n  const MIN_BODY_FONT = 14;\n  const IMPORTANT_FONT = 20;\n\n  // Utility for safe query\n  const container = document.getElementById(\"game-of-the-day-stage\");\n  if (!container) {\n    console.error(\"Container element with ID 'game-of-the-day-stage' not found.\");\n    return;\n  }\n\n  // Clear container and append canvas\n  container.innerHTML = \"\";\n  container.style.position = \"relative\";\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = CANVAS_WIDTH;\n  canvas.height = CANVAS_HEIGHT;\n  canvas.setAttribute(\"role\", \"img\");\n  canvas.setAttribute(\"aria-label\", \"Drone Math Dash game canvas\");\n  container.appendChild(canvas);\n  const ctx = canvas.getContext(\"2d\");\n\n  // Audio setup with error handling\n  let audioEnabled = true;\n  let audioContext = null;\n  try {\n    const AudioContext = window.AudioContext || window.webkitAudioContext;\n    if (!AudioContext) throw new Error(\"Web Audio API is not supported in this browser.\");\n    audioContext = new AudioContext();\n  } catch (e) {\n    console.warn(\"AudioContext could not be created:\", e);\n    audioEnabled = false;\n    audioContext = null;\n  }\n\n  // Create a subtle background ambient (gentle whoosh) if audio enabled\n  let ambientGain = null;\n  if (audioEnabled && audioContext) {\n    try {\n      ambientGain = audioContext.createGain();\n      ambientGain.gain.value = 0.02; // very gentle\n      ambientGain.connect(audioContext.destination);\n\n      // low oscillator for subtle hum\n      const osc = audioContext.createOscillator();\n      const lfo = audioContext.createOscillator();\n      const lfoGain = audioContext.createGain();\n\n      osc.type = \"sine\";\n      osc.frequency.value = 120; // low gentle tone\n      lfo.frequency.value = 0.2; // slow wobble\n      lfoGain.gain.value = 20; // modulates freq\n\n      lfo.connect(lfoGain);\n      lfoGain.connect(osc.frequency);\n      osc.connect(ambientGain);\n\n      osc.start();\n      lfo.start();\n      // retain references to stop on restart if needed\n      audioContext._ambientNodes = { osc, lfo, lfoGain };\n    } catch (e) {\n      console.warn(\"Ambient audio could not be started:\", e);\n    }\n  }\n\n  function playTone(freq = 440, type = \"sine\", duration = 0.2, volume = 0.15) {\n    if (!audioEnabled || !audioContext) return;\n    try {\n      const osc = audioContext.createOscillator();\n      const gain = audioContext.createGain();\n\n      osc.type = type;\n      osc.frequency.value = freq;\n      gain.gain.value = volume;\n\n      const filter = audioContext.createBiquadFilter();\n      filter.type = \"lowpass\";\n      filter.frequency.value = 5000;\n\n      osc.connect(filter);\n      filter.connect(gain);\n      gain.connect(audioContext.destination);\n\n      const now = audioContext.currentTime;\n      gain.gain.setValueAtTime(volume, now);\n      gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);\n\n      osc.start(now);\n      osc.stop(now + duration + 0.02);\n    } catch (e) {\n      console.warn(\"playTone error:\", e);\n    }\n  }\n\n  function playCorrectSound() {\n    // Pleasant rising arpeggio\n    playTone(880, \"sine\", 0.12, 0.08);\n    setTimeout(() => playTone(1320, \"sine\", 0.12, 0.07), 120);\n    setTimeout(() => playTone(1760, \"sine\", 0.14, 0.06), 250);\n  }\n\n  function playWrongSound() {\n    // Short buzz\n    playTone(240, \"square\", 0.18, 0.16);\n    setTimeout(() => playTone(180, \"sawtooth\", 0.12, 0.12), 120);\n  }\n\n  // Game state\n  const state = {\n    running: false,\n    correctCount: 0,\n    wrongCount: 0,\n    lives: MAX_WRONG,\n    goal: TARGET_CORRECT,\n    question: null,\n    answers: [],\n    selectedIndex: 0,\n    message: \"Welcome! Press Start to play.\",\n    phase: \"menu\", // 'menu', 'playing', 'victory', 'gameover'\n    lastActionTime: 0,\n    drone: {\n      x: 120,\n      y: 160,\n      angle: 0,\n      bob: 0,\n      targetX: 360,\n      targetY: 200,\n      speed: 80, // pixels per second\n      collected: 0\n    },\n    clouds: [],\n    soundOn: audioEnabled,\n    keyboardBuffer: null\n  };\n\n  // Generate some clouds for background with calming palette\n  function initClouds() {\n    state.clouds = [];\n    for (let i = 0; i < 6; i++) {\n      state.clouds.push({\n        x: Math.random() * CANVAS_WIDTH,\n        y: 20 + Math.random() * 120,\n        size: 60 + Math.random() * 120,\n        speed: 8 + Math.random() * 15,\n        offset: Math.random() * 1000\n      });\n    }\n  }\n\n  initClouds();\n\n  // Helpers for math questions\n  function generateQuestion() {\n    // Focus on addition within 20 and number bonds\n    // Randomly choose addition or subtraction but ensure simple\n    const a = Math.floor(Math.random() * 11) + 1; // 1..11\n    const b = Math.floor(Math.random() * 9) + 1; // 1..9\n    const op = Math.random() < 0.7 ? \"+\" : \"-\";\n    let q, answer;\n    if (op === \"+\") {\n      q = `${a} + ${b}`;\n      answer = a + b;\n    } else {\n      // ensure non-negative\n      const big = Math.max(a, b);\n      const small = Math.min(a, b);\n      q = `${big} - ${small}`;\n      answer = big - small;\n    }\n    // Create 4 answers including correct one\n    const answers = new Set();\n    answers.add(answer);\n    while (answers.size < 4) {\n      const perturb = Math.floor((Math.random() * 9) - 4); // -4..4\n      const candidate = answer + perturb;\n      if (candidate >= 0 && !answers.has(candidate)) answers.add(candidate);\n    }\n    const arr = Array.from(answers);\n    // Shuffle\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    return { q, answer, choices: arr };\n  }\n\n  // Start or restart the game\n  function startGame() {\n    state.running = true;\n    state.correctCount = 0;\n    state.wrongCount = 0;\n    state.lives = MAX_WRONG;\n    state.phase = \"playing\";\n    state.selectedIndex = 0;\n    state.drone = {\n      x: 120,\n      y: 160,\n      angle: 0,\n      bob: 0,\n      targetX: 360 + Math.random() * 200 - 100,\n      targetY: 140 + Math.random() * 60,\n      speed: 120,\n      collected: 0\n    };\n    initClouds();\n    nextQuestion();\n    if (audioContext && audioContext.state === \"suspended\" && state.soundOn) {\n      // Try to resume audio on user interaction\n      audioContext.resume().catch(() => {});\n    }\n  }\n\n  function nextQuestion() {\n    const generated = generateQuestion();\n    state.question = generated.q;\n    state.answers = generated.choices;\n    state.correctAnswer = generated.answer;\n    state.selectedIndex = 0;\n    state.message = \"Choose the correct answer!\";\n    // Move drone to a new random target so visual collects differently\n    state.drone.targetX = 220 + Math.random() * 280;\n    state.drone.targetY = 100 + Math.random() * 160;\n  }\n\n  // Interaction handlers\n  function getAnswerButtonRects() {\n    // Layout four circular buttons neatly in the lower half; ensure spacing\n    const btns = [];\n    const radius = 42;\n    // positions: two left two right in two columns with vertical spacing\n    const cxLeft = CANVAS_WIDTH * 0.28;\n    const cxRight = CANVAS_WIDTH * 0.72;\n    const cyTop = CANVAS_HEIGHT * 0.55;\n    const cyGap = 92;\n    btns.push({ x: cxLeft, y: cyTop, r: radius });\n    btns.push({ x: cxRight, y: cyTop, r: radius });\n    btns.push({ x: cxLeft, y: cyTop + cyGap, r: radius });\n    btns.push({ x: cxRight, y: cyTop + cyGap, r: radius });\n    return btns;\n  }\n\n  function pointerToCanvas(e) {\n    const rect = canvas.getBoundingClientRect();\n    const x = (e.clientX || (e.touches && e.touches[0].clientX)) - rect.left;\n    const y = (e.clientY || (e.touches && e.touches[0].clientY)) - rect.top;\n    return { x: x * (canvas.width / rect.width), y: y * (canvas.height / rect.height) };\n  }\n\n  function handleClick(e) {\n    if (!state.running && state.phase === \"menu\") {\n      // If menu and clicked in start button area, start\n      const pos = pointerToCanvas(e);\n      if (isInsideStartButton(pos)) {\n        startGame();\n      }\n      return;\n    }\n    const pos = pointerToCanvas(e);\n    if (state.phase === \"playing\") {\n      // check answer buttons\n      const rects = getAnswerButtonRects();\n      for (let i = 0; i < rects.length; i++) {\n        const dx = pos.x - rects[i].x;\n        const dy = pos.y - rects[i].y;\n        if (dx * dx + dy * dy <= rects[i].r * rects[i].r) {\n          selectAnswer(i, true);\n          return;\n        }\n      }\n    } else if (state.phase === \"victory\" || state.phase === \"gameover\") {\n      // restart button\n      if (isInsideRestartButton(pos)) {\n        startGame();\n        return;\n      }\n    }\n  }\n\n  function isInsideStartButton(pos) {\n    // Start button centered in menu\n    const w = 220;\n    const h = 56;\n    const x = (CANVAS_WIDTH - w) / 2;\n    const y = CANVAS_HEIGHT * 0.62;\n    return pos.x >= x && pos.x <= x + w && pos.y >= y && pos.y <= y + h;\n  }\n\n  function isInsideRestartButton(pos) {\n    const w = 220;\n    const h = 56;\n    const x = (CANVAS_WIDTH - w) / 2;\n    const y = CANVAS_HEIGHT * 0.66;\n    return pos.x >= x && pos.x <= x + w && pos.y >= y && pos.y <= y + h;\n  }\n\n  function selectAnswer(index, submitImmediately = false) {\n    state.selectedIndex = index;\n    if (submitImmediately) {\n      submitAnswer();\n    }\n  }\n\n  function submitAnswer() {\n    const chosen = state.answers[state.selectedIndex];\n    if (chosen === undefined) return;\n    if (chosen === state.correctAnswer) {\n      // Correct\n      state.correctCount += 1;\n      state.drone.collected += 1;\n      state.message = \"Great! +1\";\n      if (state.soundOn) playCorrectSound();\n      if (state.correctCount >= state.goal) {\n        state.phase = \"victory\";\n        state.running = false;\n        state.message = \"You reached the goal!\";\n      } else {\n        // small delay before next question to show drone animation\n        setTimeout(() => {\n          nextQuestion();\n        }, 550);\n      }\n    } else {\n      // Wrong\n      state.wrongCount += 1;\n      state.lives = Math.max(0, MAX_WRONG - state.wrongCount);\n      state.message = \"Oops! That's not right.\";\n      if (state.soundOn) playWrongSound();\n      // Flash or small shake effect by moving drone away\n      state.drone.targetX = 80 + Math.random() * 560;\n      state.drone.targetY = 100 + Math.random() * 180;\n      if (state.wrongCount >= MAX_WRONG) {\n        state.phase = \"gameover\";\n        state.running = false;\n      } else {\n        // next question after short delay\n        setTimeout(() => {\n          nextQuestion();\n        }, 600);\n      }\n    }\n  }\n\n  // Keyboard controls\n  function handleKeyDown(e) {\n    if (e.key === \"m\" || e.key === \"M\") {\n      e.preventDefault();\n      state.soundOn = !state.soundOn;\n      // mute/unmute audio by adjusting ambient gain if available\n      if (audioContext && audioContext._ambientNodes && ambientGain) {\n        ambientGain.gain.value = state.soundOn ? 0.02 : 0;\n      }\n      return;\n    }\n    if (e.key === \"r\" || e.key === \"R\") {\n      // Restart\n      e.preventDefault();\n      startGame();\n      return;\n    }\n    if (state.phase === \"menu\") {\n      if (e.key === \"Enter\" || e.key === \" \") {\n        e.preventDefault();\n        startGame();\n      }\n      return;\n    }\n    if (state.phase === \"victory\" || state.phase === \"gameover\") {\n      if (e.key === \"Enter\" || e.key === \" \") {\n        e.preventDefault();\n        startGame();\n      }\n      return;\n    }\n    if (state.phase === \"playing\") {\n      if ([\"1\", \"2\", \"3\", \"4\"].includes(e.key)) {\n        const idx = parseInt(e.key, 10) - 1;\n        selectAnswer(idx, true);\n        e.preventDefault();\n        return;\n      }\n      if (e.key === \"ArrowLeft\" || e.key === \"ArrowUp\") {\n        // move selection left/up\n        e.preventDefault();\n        state.selectedIndex = (state.selectedIndex + 4 - 1) % 4;\n      } else if (e.key === \"ArrowRight\" || e.key === \"ArrowDown\") {\n        e.preventDefault();\n        state.selectedIndex = (state.selectedIndex + 1) % 4;\n      } else if (e.key === \"Enter\" || e.key === \" \") {\n        e.preventDefault();\n        submitAnswer();\n      }\n    }\n  }\n\n  // Draw helpers: text measurement and wrapped text to ensure no overlaps\n  function drawRoundedRect(x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function wrapText(text, maxWidth, font) {\n    ctx.font = font;\n    const words = text.split(\" \");\n    const lines = [];\n    let current = \"\";\n    for (let w of words) {\n      const test = current ? current + \" \" + w : w;\n      const metrics = ctx.measureText(test);\n      if (metrics.width > maxWidth && current) {\n        lines.push(current);\n        current = w;\n      } else {\n        current = test;\n      }\n    }\n    if (current) lines.push(current);\n    return lines;\n  }\n\n  // Drone drawing\n  function drawDrone(x, y, bob, angle) {\n    // Draw a whimsical drone using arcs and rects\n    ctx.save();\n    ctx.translate(x, y + Math.sin(bob) * 6);\n    ctx.rotate(angle);\n\n    // body shadow\n    ctx.fillStyle = \"rgba(0,0,0,0.06)\";\n    ctx.beginPath();\n    ctx.ellipse(0, 38, 54, 12, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // main body\n    ctx.fillStyle = \"#A7D3FF\"; // pastel blue\n    ctx.beginPath();\n    ctx.ellipse(0, 0, 70, 36, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // goggle\n    ctx.fillStyle = \"#2C3E50\";\n    ctx.fillRect(-28, -10, 56, 18);\n    ctx.fillStyle = \"#FFFFFF\";\n    ctx.fillRect(-22, -7, 44, 12);\n\n    // propellers: four arms with little discs\n    const armColor = \"#F8B195\";\n    for (let i = 0; i < 4; i++) {\n      const a = (i * Math.PI) / 2;\n      const ax = Math.cos(a) * 50;\n      const ay = Math.sin(a) * 18;\n      ctx.strokeStyle = armColor;\n      ctx.lineWidth = 6;\n      ctx.beginPath();\n      ctx.moveTo(18 * Math.cos(a), 10 * Math.sin(a));\n      ctx.lineTo(ax, ay - 8);\n      ctx.stroke();\n\n      // prop disc\n      ctx.fillStyle = \"#FFE9C7\";\n      ctx.beginPath();\n      ctx.arc(ax, ay - 16, 14, 0, Math.PI * 2);\n      ctx.fill();\n\n      // small rotating blade, wacky\n      ctx.fillStyle = \"rgba(0,0,0,0.08)\";\n      ctx.beginPath();\n      ctx.ellipse(ax, ay - 16, 20, 6, Math.sin(bob + i) * 0.6, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // smiley decal\n    ctx.fillStyle = \"#F67280\";\n    ctx.beginPath();\n    ctx.arc(0, 12, 6, 0, Math.PI);\n    ctx.strokeStyle = \"#F67280\";\n    ctx.lineWidth = 2;\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  // Draw cloud\n  function drawCloud(c) {\n    ctx.save();\n    ctx.fillStyle = \"rgba(255,255,255,0.9)\";\n    ctx.beginPath();\n    ctx.ellipse(c.x, c.y, c.size * 0.6, c.size * 0.35, 0, 0, Math.PI * 2);\n    ctx.ellipse(c.x + c.size * 0.25, c.y - c.size * 0.08, c.size * 0.45, c.size * 0.25, 0, 0, Math.PI * 2);\n    ctx.ellipse(c.x - c.size * 0.2, c.y - c.size * 0.08, c.size * 0.45, c.size * 0.25, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n  }\n\n  // Main render loop\n  let lastTimestamp = 0;\n  function update(dt) {\n    // Move clouds\n    for (let c of state.clouds) {\n      c.x += (c.speed * dt) / 1000;\n      if (c.x - c.size * 0.8 > CANVAS_WIDTH) {\n        c.x = -c.size * 0.8;\n        c.y = 10 + Math.random() * 140;\n      }\n    }\n    if (state.phase === \"playing\") {\n      // Drone movement toward target\n      const d = state.drone;\n      const dx = d.targetX - d.x;\n      const dy = d.targetY - d.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      if (dist > 2) {\n        const step = (d.speed * dt) / 1000;\n        d.x += (dx / dist) * Math.min(step, dist);\n        d.y += (dy / dist) * Math.min(step, dist);\n      }\n      d.bob += dt / 250;\n      d.angle = Math.sin(d.bob) * 0.06;\n    } else {\n      // Idle bob\n      state.drone.bob += dt / 500;\n      state.drone.angle = Math.sin(state.drone.bob) * 0.03;\n    }\n  }\n\n  function draw() {\n    // Background gradient\n    const g = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);\n    g.addColorStop(0, \"#C9F0FF\"); // light sky\n    g.addColorStop(1, \"#F8FFF4\"); // soft bottom\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n    // Draw clouds\n    for (let c of state.clouds) {\n      drawCloud(c);\n    }\n\n    // Ground silhouette - whimsical rounded hills\n    ctx.fillStyle = \"#D6F2D6\";\n    ctx.beginPath();\n    ctx.moveTo(0, CANVAS_HEIGHT);\n    ctx.quadraticCurveTo(120, 360, 240, 400);\n    ctx.quadraticCurveTo(420, 460, 720, 380);\n    ctx.lineTo(CANVAS_WIDTH, CANVAS_HEIGHT);\n    ctx.closePath();\n    ctx.fill();\n\n    // Score UI top-left\n    ctx.font = `${MIN_BODY_FONT}px sans-serif`;\n    const scoreText = `Stars: ${state.correctCount}/${state.goal}`;\n    const scoreMetrics = ctx.measureText(scoreText);\n    const scoreW = scoreMetrics.width + UI_PADDING * 2;\n    const scoreH = 34;\n    const scoreX = UI_PADDING;\n    const scoreY = UI_PADDING;\n    ctx.fillStyle = \"rgba(255,255,255,0.85)\";\n    drawRoundedRect(scoreX, scoreY, scoreW, scoreH, 8);\n    ctx.fillStyle = \"#2C3E50\";\n    ctx.font = `${MIN_BODY_FONT}px sans-serif`;\n    ctx.fillText(scoreText, scoreX + UI_PADDING, scoreY + scoreH / 2 + 5);\n\n    // Lives UI top-right\n    const livesText = `Lives: ${Math.max(0, state.lives)}`;\n    ctx.font = `${MIN_BODY_FONT}px sans-serif`;\n    const livesMetrics = ctx.measureText(livesText);\n    const livesW = livesMetrics.width + UI_PADDING * 2 + 28;\n    const livesH = 34;\n    const livesX = CANVAS_WIDTH - livesW - UI_PADDING;\n    const livesY = UI_PADDING;\n    ctx.fillStyle = \"rgba(255,255,255,0.85)\";\n    drawRoundedRect(livesX, livesY, livesW, livesH, 8);\n    ctx.fillStyle = \"#2C3E50\";\n    ctx.fillText(livesText, livesX + UI_PADDING, livesY + livesH / 2 + 5);\n\n    // Sound indicator (small speaker icon) inside lives area, to the right\n    ctx.fillStyle = state.soundOn ? \"#4CAF50\" : \"#D32F2F\";\n    const spX = livesX + livesW - UI_PADDING - 18;\n    const spY = livesY + livesH / 2 - 6;\n    ctx.beginPath();\n    ctx.moveTo(spX, spY);\n    ctx.lineTo(spX + 6, spY);\n    ctx.lineTo(spX + 12, spY - 8);\n    ctx.lineTo(spX + 12, spY + 8);\n    ctx.lineTo(spX + 6, spY);\n    ctx.fill();\n\n    // Question box centered top, ensure spacing from score and lives\n    ctx.font = `${IMPORTANT_FONT}px sans-serif`;\n    const questionText = state.phase === \"playing\" ? state.question : \"Drone Math Dash\";\n    const qMetrics = ctx.measureText(questionText);\n    const qW = qMetrics.width + UI_PADDING * 2;\n    const qH = 44;\n    const qX = (CANVAS_WIDTH - qW) / 2;\n    const qY = UI_PADDING + 6;\n    // Ensure top elements don't overlap: maintain at least UI_PADDING distance from top boxes\n    const topOccupiedY = Math.max(scoreY + scoreH, livesY + livesH);\n    const minQY = topOccupiedY + UI_PADDING;\n    const questionY = Math.max(qY, minQY);\n    ctx.fillStyle = \"rgba(255,255,255,0.95)\";\n    drawRoundedRect(qX, questionY, qW, qH, 8);\n    ctx.fillStyle = \"#0A3D62\";\n    ctx.fillText(questionText, qX + UI_PADDING, questionY + qH / 2 + 6);\n\n    // Drone\n    drawDrone(state.drone.x, state.drone.y, state.drone.bob, state.drone.angle);\n\n    // Target star the drone collects (visual)\n    for (let i = 0; i < state.drone.collected; i++) {\n      ctx.save();\n      const sx = 16 + i * 22;\n      const sy = CANVAS_HEIGHT - 12;\n      ctx.fillStyle = \"#FFD166\";\n      ctx.beginPath();\n      ctx.arc(sx, sy, 8, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n    }\n\n    // Answer buttons\n    const rects = getAnswerButtonRects();\n    ctx.font = `${MIN_BODY_FONT + 2}px sans-serif`;\n    for (let i = 0; i < rects.length; i++) {\n      const r = rects[i];\n      // background circle\n      ctx.beginPath();\n      ctx.fillStyle = i === state.selectedIndex ? \"rgba(126,214,223,0.95)\" : \"rgba(255,255,255,0.95)\";\n      ctx.shadowColor = \"rgba(0,0,0,0.08)\";\n      ctx.shadowBlur = 8;\n      ctx.arc(r.x, r.y, r.r, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.shadowBlur = 0;\n      // number label top-left inside circle\n      ctx.fillStyle = \"#2C3E50\";\n      ctx.font = `${MIN_BODY_FONT}px sans-serif`;\n      const label = `${i + 1}.`;\n      ctx.fillText(label, r.x - r.r + 12, r.y - r.r + 20);\n      // answer text centered\n      const ansText = state.answers[i] !== undefined ? String(state.answers[i]) : \"\";\n      ctx.font = `${IMPORTANT_FONT - 2}px sans-serif`;\n      const metrics = ctx.measureText(ansText);\n      ctx.fillText(ansText, r.x - metrics.width / 2, r.y + 8);\n      // visual focus ring if selected\n      if (i === state.selectedIndex) {\n        ctx.strokeStyle = \"#1098F7\";\n        ctx.lineWidth = 4;\n        ctx.beginPath();\n        ctx.arc(r.x, r.y, r.r + 4, 0, Math.PI * 2);\n        ctx.stroke();\n      }\n    }\n\n    // Instruction area bottom center - ensure not overlapping with answer buttons\n    const instructions = [\n      \"Controls: Click answers or use keys 1-4, Arrow keys to move, Enter to submit.\",\n      \"M to toggle sound. R to restart.\",\n      state.message\n    ];\n    ctx.font = `${MIN_BODY_FONT}px sans-serif`;\n    const maxInstrW = CANVAS_WIDTH * 0.88;\n    const lines = [];\n    for (let line of instructions) {\n      const wrapped = wrapText(line, maxInstrW, `${MIN_BODY_FONT}px sans-serif`);\n      wrapped.forEach(l => lines.push(l));\n    }\n    // compute instruction box height\n    const lineHeight = 18;\n    const instrH = lines.length * lineHeight + UI_PADDING * 2;\n    const instrW = Math.min(maxInstrW, 640);\n    const instrX = (CANVAS_WIDTH - instrW) / 2;\n    const instrY = CANVAS_HEIGHT - instrH - UI_PADDING;\n    ctx.fillStyle = \"rgba(255,255,255,0.92)\";\n    drawRoundedRect(instrX, instrY, instrW, instrH, 8);\n    ctx.fillStyle = \"#1B262C\";\n    for (let i = 0; i < lines.length; i++) {\n      ctx.fillText(lines[i], instrX + UI_PADDING, instrY + UI_PADDING + (i + 1) * lineHeight - 6);\n    }\n\n    // If paused or in menu, draw overlay\n    if (state.phase === \"menu\") {\n      drawMenu();\n    } else if (state.phase === \"victory\") {\n      drawVictory();\n    } else if (state.phase === \"gameover\") {\n      drawGameOver();\n    }\n  }\n\n  // Menu screen\n  function drawMenu() {\n    // Soft translucent overlay\n    ctx.fillStyle = \"rgba(6, 30, 50, 0.18)\";\n    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n    const title = \"Drone Math Dash\";\n    ctx.font = `30px sans-serif`;\n    ctx.fillStyle = \"#FFFFFF\";\n    const tm = ctx.measureText(title);\n    const titleX = (CANVAS_WIDTH - tm.width) / 2;\n    const titleY = CANVAS_HEIGHT * 0.28;\n    // shadow box behind title for readability\n    ctx.fillStyle = \"rgba(255,255,255,0.95)\";\n    const boxW = tm.width + UI_PADDING * 2;\n    const boxH = 54;\n    const boxX = titleX - UI_PADDING;\n    const boxY = titleY - 36;\n    drawRoundedRect(boxX, boxY, boxW, boxH, 10);\n    ctx.fillStyle = \"#083D77\";\n    ctx.fillText(title, titleX, titleY);\n\n    // Description text\n    ctx.font = `${MIN_BODY_FONT + 2}px sans-serif`;\n    const desc = \"Help the drone gather \" + state.goal + \" stars by solving math problems. You can make up to \" + MAX_WRONG + \" mistakes.\";\n    const lines = wrapText(desc, CANVAS_WIDTH * 0.8, `${MIN_BODY_FONT + 2}px sans-serif`);\n    ctx.fillStyle = \"rgba(255,255,255,0.95)\";\n    const descW = CANVAS_WIDTH * 0.75;\n    const descH = lines.length * 18 + UI_PADDING * 2;\n    const descX = (CANVAS_WIDTH - descW) / 2;\n    const descY = titleY + 20;\n    drawRoundedRect(descX, descY, descW, descH, 8);\n    ctx.fillStyle = \"#083D77\";\n    for (let i = 0; i < lines.length; i++) {\n      ctx.fillText(lines[i], descX + UI_PADDING, descY + UI_PADDING + (i + 1) * 18 - 6);\n    }\n\n    // Start button\n    const w = 220;\n    const h = 56;\n    const x = (CANVAS_WIDTH - w) / 2;\n    const y = CANVAS_HEIGHT * 0.62;\n    ctx.fillStyle = \"#5EEAD4\";\n    drawRoundedRect(x, y, w, h, 12);\n    ctx.fillStyle = \"#05386B\";\n    ctx.font = `22px sans-serif`;\n    const startText = \"Start Adventure\";\n    const m = ctx.measureText(startText);\n    ctx.fillText(startText, x + (w - m.width) / 2, y + h / 2 + 8);\n\n    // Small accessibility note\n    ctx.font = `${MIN_BODY_FONT}px sans-serif`;\n    const note = \"Tip: Press Enter to start. Use keys 1-4 to pick answers.\";\n    const nm = ctx.measureText(note);\n    ctx.fillStyle = \"#FFFFFF\";\n    ctx.fillText(note, (CANVAS_WIDTH - nm.width) / 2, y + h + 32);\n  }\n\n  function drawVictory() {\n    // translucent overlay\n    ctx.fillStyle = \"rgba(0, 0, 0, 0.35)\";\n    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n    const title = \"You Win!\";\n    ctx.font = `36px sans-serif`;\n    ctx.fillStyle = \"#FFF7B2\";\n    const m = ctx.measureText(title);\n    const x = (CANVAS_WIDTH - m.width) / 2;\n    const y = CANVAS_HEIGHT * 0.26;\n    ctx.fillText(title, x, y);\n\n    ctx.font = `${MIN_BODY_FONT + 2}px sans-serif`;\n    const lines = wrapText(`Hooray! The drone collected ${state.correctCount} stars. Great job solving the problems!`, CANVAS_WIDTH * 0.8, `${MIN_BODY_FONT + 2}px sans-serif`);\n    const boxW = CANVAS_WIDTH * 0.8;\n    const boxH = lines.length * 18 + UI_PADDING * 2;\n    const boxX = (CANVAS_WIDTH - boxW) / 2;\n    const boxY = y + 12;\n    ctx.fillStyle = \"rgba(255,255,255,0.95)\";\n    drawRoundedRect(boxX, boxY, boxW, boxH, 10);\n    ctx.fillStyle = \"#0A3D62\";\n    for (let i = 0; i < lines.length; i++) {\n      ctx.fillText(lines[i], boxX + UI_PADDING, boxY + UI_PADDING + (i + 1) * 18 - 6);\n    }\n\n    // Restart button\n    const bw = 220;\n    const bh = 56;\n    const bx = (CANVAS_WIDTH - bw) / 2;\n    const by = boxY + boxH + 24;\n    ctx.fillStyle = \"#B2F7EF\";\n    drawRoundedRect(bx, by, bw, bh, 10);\n    ctx.fillStyle = \"#05386B\";\n    ctx.font = `20px sans-serif`;\n    const bt = \"Play Again\";\n    const bm = ctx.measureText(bt);\n    ctx.fillText(bt, bx + (bw - bm.width) / 2, by + bh / 2 + 8);\n\n    // Instruction note for keyboard restart\n    ctx.font = `${MIN_BODY_FONT}px sans-serif`;\n    const note = \"Press 'R' or Enter to play again.\";\n    const nm = ctx.measureText(note);\n    ctx.fillStyle = \"#FFFFFF\";\n    ctx.fillText(note, (CANVAS_WIDTH - nm.width) / 2, by + bh + 28);\n  }\n\n  function drawGameOver() {\n    ctx.fillStyle = \"rgba(0, 0, 0, 0.45)\";\n    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n    const title = \"Game Over\";\n    ctx.font = `36px sans-serif`;\n    ctx.fillStyle = \"#FFD6D6\";\n    const m = ctx.measureText(title);\n    const x = (CANVAS_WIDTH - m.width) / 2;\n    const y = CANVAS_HEIGHT * 0.26;\n    ctx.fillText(title, x, y);\n\n    ctx.font = `${MIN_BODY_FONT + 2}px sans-serif`;\n    const lines = wrapText(`Oh no! The drone ran out of lives. You answered ${state.correctCount} correctly. Try again to reach ${state.goal}!`, CANVAS_WIDTH * 0.8, `${MIN_BODY_FONT + 2}px sans-serif`);\n    const boxW = CANVAS_WIDTH * 0.8;\n    const boxH = lines.length * 18 + UI_PADDING * 2;\n    const boxX = (CANVAS_WIDTH - boxW) / 2;\n    const boxY = y + 12;\n    ctx.fillStyle = \"rgba(255,255,255,0.95)\";\n    drawRoundedRect(boxX, boxY, boxW, boxH, 10);\n    ctx.fillStyle = \"#0A3D62\";\n    for (let i = 0; i < lines.length; i++) {\n      ctx.fillText(lines[i], boxX + UI_PADDING, boxY + UI_PADDING + (i + 1) * 18 - 6);\n    }\n\n    // Restart button\n    const bw = 220;\n    const bh = 56;\n    const bx = (CANVAS_WIDTH - bw) / 2;\n    const by = boxY + boxH + 24;\n    ctx.fillStyle = \"#FFD1E6\";\n    drawRoundedRect(bx, by, bw, bh, 10);\n    ctx.fillStyle = \"#05386B\";\n    ctx.font = `20px sans-serif`;\n    const bt = \"Try Again\";\n    const bm = ctx.measureText(bt);\n    ctx.fillText(bt, bx + (bw - bm.width) / 2, by + bh / 2 + 8);\n\n    ctx.font = `${MIN_BODY_FONT}px sans-serif`;\n    const note = \"Press 'R' or Enter to try again.\";\n    const nm = ctx.measureText(note);\n    ctx.fillStyle = \"#FFFFFF\";\n    ctx.fillText(note, (CANVAS_WIDTH - nm.width) / 2, by + bh + 28);\n  }\n\n  // Main loop with requestAnimationFrame\n  function loop(ts) {\n    if (!lastTimestamp) lastTimestamp = ts;\n    const dt = ts - lastTimestamp;\n    lastTimestamp = ts;\n\n    try {\n      update(dt);\n      draw();\n    } catch (e) {\n      console.error(\"Render error:\", e);\n    }\n\n    requestAnimationFrame(loop);\n  }\n\n  // Event listeners\n  canvas.addEventListener(\"click\", handleClick);\n  canvas.addEventListener(\"touchstart\", function (e) {\n    handleClick(e);\n    e.preventDefault();\n  }, { passive: false });\n\n  window.addEventListener(\"keydown\", handleKeyDown);\n\n  // Start with menu\n  state.phase = \"menu\";\n  state.running = false;\n  state.message = \"Press Start or Enter to begin!\";\n  // Begin render loop\n  requestAnimationFrame(loop);\n\n  // Accessibility: expose simple API on container to restart programmatically\n  container.restartGame = () => {\n    startGame();\n  };\n\n  // Clean up audio nodes on unload to avoid console warnings\n  window.addEventListener(\"beforeunload\", () => {\n    try {\n      if (audioContext) {\n        if (audioContext._ambientNodes) {\n          audioContext._ambientNodes.osc.disconnect();\n          audioContext._ambientNodes.lfo.disconnect();\n          audioContext._ambientNodes.lfoGain.disconnect();\n        }\n        audioContext.close && audioContext.close();\n      }\n    } catch (e) {\n      // ignore\n    }\n  });\n})();\n---\n",
  "improve_response_tokens": 21171,
  "formatted_code": true,
  "formatting_response_tokens": 22980,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}