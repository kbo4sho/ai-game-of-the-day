{
  "generated_date": "2025-10-08",
  "generated_timestamp": "2025-10-08T00:26:47.104647",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 10089,
  "game_filename": "2025-10-08.js",
  "game_size_bytes": 31041,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Math Machines \u2014 Canvas Game\n  // Renders into element with ID \"game-of-the-day-stage\"\n  // All assets drawn with canvas; all sounds are generated with Web Audio API oscillators.\n  // Accessible: keyboard controls, on-screen instructions, hidden aria-live text updates.\n\n  // ---------------------------\n  // Setup and Constants\n  // ---------------------------\n  const STAGE_ID = 'game-of-the-day-stage';\n  const WIDTH = 720;\n  const HEIGHT = 480;\n\n  // Ensure target container exists\n  const stage = document.getElementById(STAGE_ID);\n  if (!stage) {\n    console.error(`Missing container element with id=${STAGE_ID}`);\n    return;\n  }\n  // Clean stage\n  stage.innerHTML = '';\n  stage.style.position = 'relative';\n  stage.setAttribute('tabindex', '0'); // allow focus\n\n  // Create a canvas sized EXACTLY 720x480\n  const canvas = document.createElement('canvas');\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.style.width = WIDTH + 'px';\n  canvas.style.height = HEIGHT + 'px';\n  canvas.setAttribute('role', 'img');\n  canvas.setAttribute('aria-label', 'Math Machines game canvas');\n  stage.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Accessibility: hidden aria-live region for announcements\n  const aria = document.createElement('div');\n  aria.setAttribute('aria-live', 'polite');\n  aria.style.position = 'absolute';\n  aria.style.left = '-9999px';\n  aria.style.width = '1px';\n  aria.style.height = '1px';\n  aria.style.overflow = 'hidden';\n  stage.appendChild(aria);\n\n  // Create simple on-canvas button area for audio toggle (drawn in canvas, but clickable via overlay for keyboard)\n  const overlayControls = document.createElement('div');\n  overlayControls.style.position = 'absolute';\n  overlayControls.style.left = '0';\n  overlayControls.style.top = '0';\n  overlayControls.style.width = WIDTH + 'px';\n  overlayControls.style.height = HEIGHT + 'px';\n  overlayControls.style.pointerEvents = 'none'; // we'll use canvas click handling; maintain keyboard focus via stage\n  stage.appendChild(overlayControls);\n\n  // Game variables\n  let running = false;\n  let paused = false;\n  let lastTime = 0;\n  let animationFrame = null;\n\n  // Audio setup\n  let audioCtx = null;\n  let audioAllowed = false;\n  let backgroundGain = null;\n  let backgroundOsc = null;\n  let masterGain = null;\n\n  function tryCreateAudioContext() {\n    if (audioCtx) return audioCtx;\n    try {\n      const AudioContext = window.AudioContext || window.webkitAudioContext;\n      audioCtx = new AudioContext();\n      masterGain = audioCtx.createGain();\n      masterGain.gain.value = 0.7;\n      masterGain.connect(audioCtx.destination);\n\n      // gentle background hum via low-frequency oscillator + filter\n      backgroundGain = audioCtx.createGain();\n      backgroundGain.gain.value = 0.06;\n      backgroundGain.connect(masterGain);\n\n      backgroundOsc = audioCtx.createOscillator();\n      backgroundOsc.type = 'sine';\n      backgroundOsc.frequency.value = 100;\n      const bgFilter = audioCtx.createBiquadFilter();\n      bgFilter.type = 'lowpass';\n      bgFilter.frequency.value = 400;\n      backgroundOsc.connect(bgFilter);\n      bgFilter.connect(backgroundGain);\n      try {\n        backgroundOsc.start();\n      } catch (e) {\n        // Some browsers require user gesture to start audio; we'll handle resume on user interaction\n      }\n      audioAllowed = true;\n      return audioCtx;\n    } catch (err) {\n      console.warn('AudioContext creation failed:', err);\n      audioCtx = null;\n      audioAllowed = false;\n      return null;\n    }\n  }\n\n  // Call on first user gesture\n  function ensureAudioResume() {\n    if (!audioCtx) tryCreateAudioContext();\n    if (!audioCtx) return;\n    if (audioCtx.state === 'suspended') {\n      audioCtx.resume().catch((e) => {\n        console.warn('AudioContext resume failed', e);\n      });\n    }\n  }\n\n  // Sound utilities: generate short oscillator-based sounds\n  function playTone({ freq = 440, duration = 0.18, type = 'sine', attack = 0.01, decay = 0.12, volume = 0.15 }) {\n    if (!audioAllowed || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const o = audioCtx.createOscillator();\n      o.type = type;\n      o.frequency.setValueAtTime(freq, now);\n      const g = audioCtx.createGain();\n      g.gain.setValueAtTime(0.0001, now);\n      g.gain.linearRampToValueAtTime(volume, now + attack);\n      g.gain.linearRampToValueAtTime(0.0001, now + duration + decay);\n      o.connect(g);\n      g.connect(masterGain);\n      o.start(now);\n      o.stop(now + duration + decay + 0.02);\n      // Visual cue: flash small speaker meter (we'll draw)\n      lastAudioPulse = { at: performance.now(), strength: volume };\n    } catch (e) {\n      console.warn('Could not play tone', e);\n    }\n  }\n\n  // Specific game sounds\n  const soundCorrect = () => {\n    playTone({ freq: 880, duration: 0.22, type: 'triangle', attack: 0.005, decay: 0.15, volume: 0.18 });\n    // harmonic\n    setTimeout(() => playTone({ freq: 1320, duration: 0.15, type: 'sine', attack: 0.002, decay: 0.12, volume: 0.09 }), 80);\n  };\n  const soundIncorrect = () => {\n    playTone({ freq: 180, duration: 0.18, type: 'sawtooth', attack: 0.01, decay: 0.14, volume: 0.16 });\n  };\n  const soundPickup = () => {\n    playTone({ freq: 620, duration: 0.12, type: 'square', attack: 0.005, decay: 0.09, volume: 0.12 });\n  };\n  const soundPlace = () => {\n    playTone({ freq: 540, duration: 0.10, type: 'sine', attack: 0.002, decay: 0.08, volume: 0.12 });\n  };\n  const soundWin = () => {\n    playTone({ freq: 740, duration: 0.08, type: 'sine', attack: 0.001, decay: 0.07, volume: 0.14 });\n    setTimeout(() => playTone({ freq: 940, duration: 0.10, type: 'triangle', attack: 0.002, decay: 0.08, volume: 0.14 }), 90);\n    setTimeout(() => playTone({ freq: 1180, duration: 0.12, type: 'sine', attack: 0.002, decay: 0.08, volume: 0.12 }), 200);\n  };\n\n  // visual audio pulse\n  let lastAudioPulse = { at: 0, strength: 0 };\n\n  // ---------------------------\n  // Game Objects\n  // ---------------------------\n\n  // Utility random\n  const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\n  // Machines \u2014 top row\n  class Machine {\n    constructor(x, y, target) {\n      this.x = x;\n      this.y = y;\n      this.target = target;\n      this.current = 0;\n      this.width = 180;\n      this.height = 90;\n      this.active = true;\n      this.recent = 0; // for animation pulses\n    }\n    canAccept(value) {\n      return this.current + value <= this.target;\n    }\n    accept(value) {\n      if (!this.canAccept(value)) return false;\n      this.current += value;\n      this.recent = 1.0;\n      return true;\n    }\n    resetForLevel(target) {\n      this.target = target;\n      this.current = 0;\n      this.active = true;\n    }\n  }\n\n  // Gear objects \u2014 values that flow from right to left on conveyor\n  class Gear {\n    constructor(value, x, y, speed) {\n      this.value = value;\n      this.x = x;\n      this.y = y;\n      this.radius = 22;\n      this.speed = speed;\n      this.picked = false;\n    }\n    update(dt) {\n      if (!this.picked) {\n        this.x -= this.speed * dt;\n      }\n    }\n  }\n\n  // Player robotic arm\n  class PlayerArm {\n    constructor() {\n      this.x = WIDTH / 2;\n      this.y = HEIGHT - 70;\n      this.width = 84;\n      this.height = 48;\n      this.holding = null; // Gear object reference\n      this.speed = 320; // px per second\n      this.moveLeft = false;\n      this.moveRight = false;\n    }\n    update(dt) {\n      if (this.moveLeft) this.x -= this.speed * dt;\n      if (this.moveRight) this.x += this.speed * dt;\n      this.x = Math.max(40, Math.min(WIDTH - 40, this.x));\n      if (this.holding) {\n        // keep held gear relative to arm\n        this.holding.x = this.x;\n        this.holding.y = this.y - 30;\n      }\n    }\n    pickClosestGear(gears) {\n      if (this.holding) return false;\n      let closest = null;\n      let minDist = 9999;\n      for (const g of gears) {\n        if (g.picked) continue;\n        const dx = g.x - this.x;\n        const dy = g.y - (this.y - 30);\n        const d = Math.sqrt(dx * dx + dy * dy);\n        if (d < minDist && d < 48) {\n          minDist = d;\n          closest = g;\n        }\n      }\n      if (closest) {\n        closest.picked = true;\n        this.holding = closest;\n        soundPickup();\n        announce(`Picked gear ${closest.value}`);\n        return true;\n      } else {\n        // small negative sound\n        soundIncorrect();\n        announce('No gear nearby to pick');\n        return false;\n      }\n    }\n    placeIntoMachine(machines) {\n      if (!this.holding) {\n        soundIncorrect();\n        announce('Not holding a gear to place');\n        return false;\n      }\n      for (const m of machines) {\n        if (!m.active) continue;\n        // check horizontal overlap\n        if (Math.abs(this.x - m.x) < m.width / 2 + 20) {\n          const val = this.holding.value;\n          if (m.canAccept(val)) {\n            m.accept(val);\n            // remove held gear\n            const placed = this.holding;\n            this.holding = null;\n            placed.picked = true;\n            soundPlace();\n            announce(`Placed ${val} into machine (now ${m.current} of ${m.target})`);\n            if (m.current === m.target) {\n              m.active = false;\n              soundCorrect();\n              announce(`Machine completed!`);\n            }\n            return true;\n          } else {\n            // cannot accept \u2014 incorrect\n            soundIncorrect();\n            announce(`That would go over the target of ${m.target}`);\n            return false;\n          }\n        }\n      }\n      // not over any machine\n      // drop gear back onto conveyor (just release)\n      this.holding.picked = false;\n      this.holding = null;\n      soundIncorrect();\n      announce('Not close enough to a machine to place');\n      return false;\n    }\n    dropHeldToConveyor() {\n      if (this.holding) {\n        this.holding.picked = false;\n        // place slightly below arm\n        this.holding.x = this.x;\n        this.holding.y = this.y + 18;\n        this.holding = null;\n        soundPlace();\n        announce('Dropped gear back on belt');\n      }\n    }\n  }\n\n  // ---------------------------\n  // Level and Game Logic\n  // ---------------------------\n  const gameState = {\n    level: 0,\n    maxLevels: 6,\n    machines: [],\n    gears: [],\n    player: new PlayerArm(),\n    spawnTimer: 0,\n    spawnInterval: 1.2, // seconds\n    conveyorY: HEIGHT - 140,\n    timeLeft: 45,\n    levelTime: 45,\n    score: 0,\n    audioOn: true,\n    message: 'Press Enter or Click to Start',\n    lastAnnouncement: '',\n    awaitingUserGesture: true,\n  };\n\n  // Setup initial machines (three machines across top)\n  function initMachinesForLevel(level) {\n    gameState.machines = [];\n    const count = 3;\n    const margin = 40;\n    const spacing = (WIDTH - margin * 2) / (count);\n    for (let i = 0; i < count; i++) {\n      const x = margin + spacing * i + spacing / 2;\n      const y = 110;\n      // target grows with level: base 6 to 10\n      const base = 6 + level;\n      const target = randInt(base, base + 4);\n      const m = new Machine(x, y, target);\n      gameState.machines.push(m);\n    }\n  }\n\n  function startLevel(level) {\n    gameState.level = level;\n    gameState.gears = [];\n    gameState.spawnTimer = 0;\n    gameState.spawnInterval = Math.max(0.9, 1.4 - level * 0.12);\n    gameState.levelTime = Math.max(25, 45 - level * 3);\n    gameState.timeLeft = gameState.levelTime;\n    gameState.player = new PlayerArm();\n    initMachinesForLevel(level);\n    gameState.score = 0;\n    gameState.message = `Level ${level + 1} \u2014 Fill all machines to their targets! Use \u2190 \u2192 to move, Space to pick/place, Up to place into a machine.`;\n    announce(gameState.message);\n    running = true;\n    paused = false;\n    ensureAudioResume();\n  }\n\n  function allMachinesComplete() {\n    return gameState.machines.every((m) => m.current === m.target);\n  }\n\n  // Spawn gears flowing on conveyor\n  function spawnGear() {\n    // gear value 1-5\n    const value = randInt(1, 5);\n    const x = WIDTH + 30;\n    const y = gameState.conveyorY + randInt(-6, 16);\n    // speed depends on level\n    const speed = randInt(40 + gameState.level * 6, 90 + gameState.level * 8);\n    const g = new Gear(value, x, y, speed);\n    gameState.gears.push(g);\n  }\n\n  // ---------------------------\n  // Input Handling\n  // ---------------------------\n  // Keyboard controls:\n  // Left/Right arrows: move arm, Space: pick/place, Up: place into machine if holding, Down: drop gear to conveyor\n  const keys = {};\n  window.addEventListener('keydown', (e) => {\n    if (e.key === 'ArrowLeft' || e.key === 'Left') {\n      keys.left = true;\n      gameState.player.moveLeft = true;\n    } else if (e.key === 'ArrowRight' || e.key === 'Right') {\n      keys.right = true;\n      gameState.player.moveRight = true;\n    } else if (e.key === ' ' || e.key === 'Spacebar') {\n      e.preventDefault();\n      // space: pick if not holding else try place into machine\n      if (!running) {\n        // start game on Enter/Space\n        if (audioCtx === null) tryCreateAudioContext();\n        startLevel(0);\n        return;\n      }\n      if (!gameState.player.holding) {\n        gameState.player.pickClosestGear(gameState.gears);\n      } else {\n        // try to place into nearby machine\n        gameState.player.placeIntoMachine(gameState.machines);\n      }\n    } else if (e.key === 'ArrowUp' || e.key === 'Up') {\n      // explicit place into machine\n      if (running) {\n        gameState.player.placeIntoMachine(gameState.machines);\n      }\n    } else if (e.key === 'ArrowDown' || e.key === 'Down') {\n      // drop to conveyor\n      if (running) {\n        gameState.player.dropHeldToConveyor();\n      }\n    } else if (e.key === 'p' || e.key === 'P') {\n      // toggle pause\n      if (running) {\n        paused = !paused;\n        announce(paused ? 'Paused' : 'Resumed');\n      }\n    } else if (e.key === 'm' || e.key === 'M') {\n      // toggle audio mute\n      gameState.audioOn = !gameState.audioOn;\n      if (masterGain) masterGain.gain.value = gameState.audioOn ? 0.7 : 0.0;\n      announce(gameState.audioOn ? 'Audio on' : 'Audio off');\n    } else if ((e.key === 'Enter' || e.key === 'Return') && !running) {\n      if (audioCtx === null) tryCreateAudioContext();\n      startLevel(0);\n    } else if ((e.key === 'r' || e.key === 'R') && !running) {\n      // restart\n      startLevel(0);\n    }\n  });\n\n  window.addEventListener('keyup', (e) => {\n    if (e.key === 'ArrowLeft' || e.key === 'Left') {\n      keys.left = false;\n      gameState.player.moveLeft = false;\n    } else if (e.key === 'ArrowRight' || e.key === 'Right') {\n      keys.right = false;\n      gameState.player.moveRight = false;\n    }\n  });\n\n  // Mouse/touch: move arm horizontally by mouse; click on gear to pick/place etc.\n  function getCanvasPos(evt) {\n    const rect = canvas.getBoundingClientRect();\n    let clientX, clientY;\n    if (evt.touches && evt.touches[0]) {\n      clientX = evt.touches[0].clientX;\n      clientY = evt.touches[0].clientY;\n    } else {\n      clientX = evt.clientX;\n      clientY = evt.clientY;\n    }\n    return {\n      x: ((clientX - rect.left) / rect.width) * canvas.width,\n      y: ((clientY - rect.top) / rect.height) * canvas.height,\n    };\n  }\n\n  canvas.addEventListener('mousemove', (e) => {\n    const pos = getCanvasPos(e);\n    gameState.player.x = Math.max(40, Math.min(WIDTH - 40, pos.x));\n    // resume audio on first mouse\n    ensureAudioResume();\n  });\n  canvas.addEventListener('touchmove', (e) => {\n    e.preventDefault();\n    const pos = getCanvasPos(e);\n    gameState.player.x = Math.max(40, Math.min(WIDTH - 40, pos.x));\n    ensureAudioResume();\n  }, { passive: false });\n\n  canvas.addEventListener('click', (e) => {\n    // On click: if not running, start. If running: pick/place depending on proximity.\n    ensureAudioResume();\n    if (!running) {\n      startLevel(0);\n      return;\n    }\n    const pos = getCanvasPos(e);\n    // if click near a gear, pick that gear if possible\n    const dxToPlayer = Math.abs(pos.x - gameState.player.x);\n    const dyToPlayer = Math.abs(pos.y - (gameState.player.y - 30));\n    // If click is near player -> pick/place\n    if (dxToPlayer < 80 && dyToPlayer < 80) {\n      if (!gameState.player.holding) {\n        gameState.player.pickClosestGear(gameState.gears);\n      } else {\n        gameState.player.placeIntoMachine(gameState.machines);\n      }\n    } else {\n      // click near machine to place from player\n      for (const m of gameState.machines) {\n        if (Math.abs(pos.x - m.x) < m.width / 2 && Math.abs(pos.y - m.y) < m.height / 2) {\n          // move player beneath and place\n          gameState.player.x = m.x;\n          if (gameState.player.holding) {\n            gameState.player.placeIntoMachine(gameState.machines);\n          }\n          return;\n        }\n      }\n      // else click somewhere: maybe pick gear under click directly\n      let picked = false;\n      for (const g of gameState.gears) {\n        const d = Math.hypot(g.x - pos.x, g.y - pos.y);\n        if (d < 30 && !g.picked && !gameState.player.holding) {\n          // move arm to gear and pick\n          gameState.player.x = g.x;\n          gameState.player.pickClosestGear(gameState.gears);\n          picked = true;\n          break;\n        }\n      }\n      if (!picked && gameState.player.holding) {\n        // click background -> drop to conveyor near click\n        gameState.player.dropHeldToConveyor();\n      }\n    }\n  });\n\n  // ---------------------------\n  // Announcements for Accessibility\n  // ---------------------------\n  function announce(text) {\n    aria.textContent = text;\n    gameState.lastAnnouncement = text;\n  }\n\n  // ---------------------------\n  // Update Loop\n  // ---------------------------\n  function update(dt) {\n    if (!running || paused) return;\n    // spawn gears\n    gameState.spawnTimer -= dt;\n    if (gameState.spawnTimer <= 0) {\n      spawnGear();\n      gameState.spawnTimer = gameState.spawnInterval + (Math.random() * 0.6 - 0.3);\n    }\n\n    // update gears\n    for (const g of gameState.gears) {\n      if (!g.picked) {\n        g.update(dt);\n      }\n    }\n    // remove off-screen gears\n    gameState.gears = gameState.gears.filter((g) => g.x > -60 && !(g.picked && g === null));\n\n    // update player\n    gameState.player.update(dt);\n\n    // time countdown\n    gameState.timeLeft -= dt;\n    if (gameState.timeLeft <= 0) {\n      // time up -> level failed\n      running = false;\n      announce('Time\\'s up! Press Enter to try again.');\n      soundIncorrect();\n      gameState.message = 'Time\\'s up! Press Enter to try again.';\n      return;\n    }\n\n    // check machine completions\n    if (allMachinesComplete()) {\n      // win this level; proceed to next or finish\n      soundWin();\n      gameState.score += 100;\n      const nextLevel = gameState.level + 1;\n      if (nextLevel >= gameState.maxLevels) {\n        // game beaten\n        running = false;\n        announce('You finished all machines \u2014 great job! Press Enter to play again.');\n        gameState.message = `You beat the game! Score: ${gameState.score}. Press Enter to play again.`;\n      } else {\n        // proceed to next level after small delay \u2014 clear gears and setup next\n        running = false; // pause until player hits Enter\n        gameState.message = `Level ${gameState.level + 1} complete! Press Enter to continue.`;\n        announce(gameState.message);\n      }\n    }\n\n    // animate machine pulses\n    for (const m of gameState.machines) {\n      if (m.recent > 0) m.recent = Math.max(0, m.recent - dt * 1.5);\n    }\n  }\n\n  // ---------------------------\n  // Drawing\n  // ---------------------------\n  function draw() {\n    // clear with calming background gradient\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, '#eaf3ff');\n    g.addColorStop(1, '#f0fff6');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // wacky cloud shapes at top\n    drawClouds();\n\n    // Draw machines\n    for (const m of gameState.machines) {\n      drawMachine(m);\n    }\n\n    // Conveyor belt\n    drawConveyor();\n\n    // Draw gears\n    for (const g of gameState.gears) {\n      drawGear(g);\n    }\n\n    // Draw player arm\n    drawPlayer(gameState.player);\n\n    // HUD: level, time, score\n    drawHUD();\n\n    // Draw message area\n    ctx.fillStyle = 'rgba(20,20,30,0.06)';\n    ctx.fillRect(18, HEIGHT - 40, WIDTH - 36, 30);\n    ctx.fillStyle = '#18304e';\n    ctx.font = '14px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText(gameState.message, 26, HEIGHT - 18);\n\n    // audio visual meter pulse\n    drawAudioMeter();\n  }\n\n  function drawClouds() {\n    // wacky calming circles\n    ctx.save();\n    ctx.globalAlpha = 0.95;\n    for (let i = 0; i < 6; i++) {\n      const cx = 60 + i * 120 + Math.sin(performance.now() / 1300 + i) * 6;\n      const cy = 30 + Math.cos(performance.now() / 1500 + i) * 4;\n      const r = 34 + (i % 2) * 10;\n      ctx.beginPath();\n      ctx.fillStyle = i % 2 ? '#ffffff' : '#f8ffff';\n      ctx.arc(cx, cy, r, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    ctx.restore();\n  }\n\n  function drawMachine(m) {\n    // machine body\n    ctx.save();\n    ctx.translate(m.x, m.y);\n    // soft shadow and pulsing scale\n    const pulse = 1 + m.recent * 0.06;\n    ctx.scale(pulse, pulse);\n    ctx.fillStyle = '#f1f6ff';\n    roundRect(ctx, -m.width / 2, -m.height / 2, m.width, m.height, 12);\n    ctx.fill();\n    // decorative bolts\n    ctx.fillStyle = '#cde6ff';\n    for (let i = -1; i <= 1; i++) {\n      ctx.beginPath();\n      ctx.arc(i * 48, -m.height / 2 + 8, 5, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // display current / target\n    ctx.fillStyle = '#1b3b57';\n    ctx.font = '16px Comic Sans MS, sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText(`Machine`, 0, -4);\n    ctx.font = '20px monospace';\n    ctx.fillText(`${m.current} / ${m.target}`, 0, 22);\n\n    // little window with wacky eyes to indicate status\n    ctx.fillStyle = m.active ? '#ffe6a1' : '#c4ffd3';\n    roundRect(ctx, m.width / 2 - 34, -m.height / 2 + 12, 48, 28, 8);\n    ctx.fill();\n    // eyes\n    ctx.fillStyle = '#3b3b3b';\n    ctx.beginPath();\n    ctx.arc(m.width / 2 - 22, -m.height / 2 + 24, 3 + (m.active ? 0 : 1), 0, Math.PI * 2);\n    ctx.arc(m.width / 2 - 10, -m.height / 2 + 24, 3 + (m.active ? 0 : 1), 0, Math.PI * 2);\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  function drawConveyor() {\n    // base belt\n    const y = gameState.conveyorY;\n    ctx.fillStyle = '#d6e9ff';\n    ctx.fillRect(0, y - 16, WIDTH, 36);\n    // moving stripes\n    ctx.save();\n    ctx.translate((performance.now() / 20) % 40, 0);\n    for (let i = -40; i < WIDTH + 40; i += 40) {\n      ctx.fillStyle = 'rgba(20,50,80,0.06)';\n      ctx.fillRect(i, y - 16, 24, 36);\n    }\n    ctx.restore();\n    // some machine-like pipes at edges\n    ctx.fillStyle = '#bfe0ff';\n    roundRect(ctx, 14, y + 18, 110, 22, 8);\n    roundRect(ctx, WIDTH - 124, y + 18, 110, 22, 8);\n    ctx.fill();\n  }\n\n  function drawGear(g) {\n    ctx.save();\n    ctx.translate(g.x, g.y);\n    // gear body\n    ctx.beginPath();\n    ctx.fillStyle = g.picked ? '#ffe6d6' : '#ffd8ff';\n    ctx.arc(0, 0, g.radius, 0, Math.PI * 2);\n    ctx.fill();\n\n    // teeth\n    ctx.fillStyle = '#ffb4ff';\n    for (let i = 0; i < 8; i++) {\n      const ang = (i / 8) * Math.PI * 2;\n      const tx = Math.cos(ang) * (g.radius + 8);\n      const ty = Math.sin(ang) * (g.radius + 8);\n      ctx.beginPath();\n      ctx.rect(tx - 5, ty - 3, 10, 6);\n      ctx.save();\n      ctx.translate(tx, ty);\n      ctx.rotate(ang);\n      ctx.fillRect(-5, -3, 10, 6);\n      ctx.restore();\n    }\n\n    // center hole\n    ctx.fillStyle = '#fff';\n    ctx.beginPath();\n    ctx.arc(0, 0, 8, 0, Math.PI * 2);\n    ctx.fill();\n\n    // number value\n    ctx.fillStyle = '#3b3b3b';\n    ctx.font = 'bold 16px monospace';\n    ctx.textAlign = 'center';\n    ctx.fillText(g.value.toString(), 0, 6);\n\n    ctx.restore();\n  }\n\n  function drawPlayer(p) {\n    ctx.save();\n    // arm body\n    ctx.translate(p.x, p.y);\n    ctx.fillStyle = '#dbefff';\n    roundRect(ctx, -p.width / 2, -p.height / 2, p.width, p.height, 10);\n    ctx.fill();\n\n    // claw\n    ctx.fillStyle = '#a5d0ff';\n    ctx.beginPath();\n    ctx.moveTo(-10, -p.height / 2);\n    ctx.lineTo(0, -p.height / 2 - 20);\n    ctx.lineTo(10, -p.height / 2);\n    ctx.fill();\n\n    ctx.fillStyle = '#17364f';\n    ctx.font = '14px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('ROBO-ARM', 0, 10);\n\n    // held gear drawn over arm if present (gear draws with its own coords)\n    ctx.restore();\n  }\n\n  function drawHUD() {\n    // top-left: level and time\n    ctx.fillStyle = '#24445e';\n    ctx.font = '16px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText(`Level: ${gameState.level + 1}/${gameState.maxLevels}`, 18, 22);\n\n    // time bar\n    const timeX = 160;\n    const timeY = 12;\n    const timeW = 200;\n    const timeH = 18;\n    ctx.fillStyle = '#cfe8ff';\n    roundRect(ctx, timeX, timeY, timeW, timeH, 10);\n    ctx.fill();\n    const pct = Math.max(0, gameState.timeLeft / gameState.levelTime);\n    // gradient from green to orange\n    const tg = ctx.createLinearGradient(timeX, 0, timeX + timeW, 0);\n    tg.addColorStop(0, '#8bf59f');\n    tg.addColorStop(1, '#ffd08a');\n    ctx.fillStyle = tg;\n    roundRect(ctx, timeX + 2, timeY + 2, (timeW - 4) * pct, timeH - 4, 8);\n    ctx.fill();\n    ctx.fillStyle = '#083248';\n    ctx.font = '12px monospace';\n    ctx.fillText(`Time: ${Math.ceil(gameState.timeLeft)}s`, timeX + timeW + 8, timeY + 13);\n\n    // Score top-right\n    ctx.textAlign = 'right';\n    ctx.fillStyle = '#18304e';\n    ctx.fillText(`Score: ${gameState.score}`, WIDTH - 18, 22);\n  }\n\n  function drawAudioMeter() {\n    const meterX = WIDTH - 54;\n    const meterY = HEIGHT - 46;\n    // background speaker box\n    ctx.fillStyle = '#e9f7ff';\n    roundRect(ctx, meterX - 8, meterY - 8, 44, 36, 8);\n    ctx.fill();\n    // speaker icon\n    ctx.fillStyle = '#18304e';\n    ctx.beginPath();\n    ctx.moveTo(meterX, meterY + 8);\n    ctx.lineTo(meterX + 8, meterY - 6);\n    ctx.lineTo(meterX + 8, meterY + 28);\n    ctx.closePath();\n    ctx.fillRect(meterX - 10, meterY + 0, 10, 20);\n    // arc waves based on lastAudioPulse\n    const since = (performance.now() - lastAudioPulse.at);\n    const strength = lastAudioPulse.strength ? Math.min(1, lastAudioPulse.strength / 0.2) : 0;\n    ctx.strokeStyle = `rgba(24,48,78,${0.4 * strength})`;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.arc(meterX + 14, meterY + 8, 10 + since * 0.02, 0.6, 2.2);\n    ctx.stroke();\n  }\n\n  // small utility: rounded rectangle\n  function roundRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n  }\n\n  // ---------------------------\n  // Game Loop\n  // ---------------------------\n  function loop(timestamp) {\n    if (!lastTime) lastTime = timestamp;\n    const dt = Math.min(0.040, (timestamp - lastTime) / 1000); // clamp dt ~40ms\n    lastTime = timestamp;\n\n    if (running && !paused) update(dt);\n\n    draw();\n\n    animationFrame = requestAnimationFrame(loop);\n  }\n\n  // Start drawing static start screen first\n  function drawStartScreen() {\n    // initial welcome\n    ctx.clearRect(0, 0, WIDTH, HEIGHT);\n    // background\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, '#eef7ff');\n    g.addColorStop(1, '#f7fff4');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    ctx.fillStyle = '#17364f';\n    ctx.font = '36px Comic Sans MS, sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('Math Machines!', WIDTH / 2, 100);\n\n    ctx.font = '18px sans-serif';\n    ctx.fillText('Help the wacky machines by placing the right-number gears into them.', WIDTH / 2, 140);\n    ctx.fillText('Use \u2190 \u2192 to move, Space to pick/place, Up to place into a machine.', WIDTH / 2, 165);\n    ctx.fillText('Press Enter or click to start. Press M to toggle sound. Press P to pause.', WIDTH / 2, 190);\n\n    // small playful machine drawing\n    const m = new Machine(WIDTH / 2, 260, 10);\n    drawMachine(m);\n\n    // sample gears\n    const g1 = new Gear(3, WIDTH / 2 - 80, 350, 0);\n    const g2 = new Gear(5, WIDTH / 2, 350, 0);\n    const g3 = new Gear(2, WIDTH / 2 + 80, 350, 0);\n    drawGear(g1);\n    drawGear(g2);\n    drawGear(g3);\n\n    ctx.fillStyle = '#18304e';\n    ctx.font = '16px sans-serif';\n    ctx.fillText('Beating the game: finish all levels to win. Each machine must be exactly filled!', WIDTH / 2, 420);\n\n    // audio instructions\n    ctx.fillStyle = '#0e2b45';\n    ctx.font = '14px monospace';\n    ctx.fillText('Audio: press M to mute/unmute. Click to resume audio if disabled.', WIDTH / 2, 450);\n  }\n\n  drawStartScreen();\n  animationFrame = requestAnimationFrame(loop);\n\n  // Resume audio on any user interaction in stage\n  stage.addEventListener('pointerdown', () => {\n    ensureAudioResume();\n  });\n\n  // Start on click within canvas area (already handled), but also support on-screen keyboard focus to start game\n  stage.addEventListener('keydown', (e) => {\n    if ((e.key === 'Enter' || e.key === ' ') && !running) {\n      ensureAudioResume();\n      startLevel(0);\n    }\n  });\n\n  // Hook into Enter to progress to next level after completion\n  window.addEventListener('keydown', (e) => {\n    if ((e.key === 'Enter' || e.key === ' ') && !running) {\n      // if game ended because of level completion we can move to next\n      if (gameState.level + 1 < gameState.maxLevels && gameState.message && gameState.message.startsWith('Level')) {\n        // proceed to next\n        startLevel(gameState.level + 1);\n      } else if (gameState.message && gameState.message.startsWith('You beat')) {\n        // restart new playthrough\n        startLevel(0);\n      } else if (gameState.message && gameState.message.startsWith(\"Time's up\")) {\n        // restart\n        startLevel(0);\n      }\n    }\n  });\n\n  // Error handling for audio resume attempts\n  window.addEventListener('unhandledrejection', (ev) => {\n    console.warn('Unhandled promise rejection', ev.reason);\n  });\n\n  // Make sure canvas is keyboard focusable for accessibility\n  canvas.setAttribute('tabindex', '0');\n  canvas.addEventListener('focus', () => {\n    announce('Canvas focused. Use arrow keys and space to play.');\n  });\n\n  // Small periodic autosave of last game state to aria for screen reader\n  setInterval(() => {\n    if (!running) return;\n    const nextMachine = gameState.machines.find((m) => m.current < m.target);\n    if (nextMachine) {\n      aria.textContent = `Time ${Math.ceil(gameState.timeLeft)}s. Next machine needs ${nextMachine.target - nextMachine.current}.`;\n    } else {\n      aria.textContent = `All machines complete.`;\n    }\n  }, 4500);\n\n  // Clean up on window unload\n  window.addEventListener('beforeunload', () => {\n    if (audioCtx && audioCtx.close) {\n      try { audioCtx.close(); } catch (_) {}\n    }\n    if (animationFrame) cancelAnimationFrame(animationFrame);\n  });\n\n})();\n---\n",
  "improve_response_tokens": 21597,
  "formatted_code": true,
  "formatting_response_tokens": 24233,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}