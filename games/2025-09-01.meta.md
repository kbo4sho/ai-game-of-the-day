# Game of the Day - 2025-09-01

## Metadata
- **Generated Date:** 2025-09-01
- **Generated Time:** 2025-09-01T00:33:12.806784
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-01.js
- **File Size:** 30487 bytes
- **Tokens Used:** 9982

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-01.js` - The playable game
- `2025-09-01.meta.json` - Machine-readable metadata
- `2025-09-01.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 19953

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 21120

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Machine Math — Canvas Game for ages 7-9
// Renders into the element with id "game-of-the-day-stage"
// All visuals drawn with canvas; all sounds generated with Web Audio API oscillators/filters.
// Accessible keyboard controls and screen-reader text included.

// Immediately-invoked function to avoid polluting global scope
(function() {
  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const container = document.getElementById('game-of-the-day-stage');

  if (!container) {
    console.error('Game container element with id "game-of-the-day-stage" not found.');
    return;
  }

  // Clear any existing content inside the container
  container.innerHTML = '';

  // Create an offscreen but accessible instructions element for screen readers
  const srInstructions = document.createElement('div');
  srInstructions.setAttribute('role', 'status');
  srInstructions.setAttribute('aria-live', 'polite');
  srInstructions.style.position = 'absolute';
  srInstructions.style.left = '-9999px';
  srInstructions.style.width = '1px';
  srInstructions.style.height = '1px';
  srInstructions.style.overflow = 'hidden';
  srInstructions.textContent = 'Machine Math game loaded. Use mouse or keyboard. Arrow keys to navigate, Enter to place, Backspace to remove, M to toggle sound.';
  container.appendChild(srInstructions);

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.width = WIDTH + 'px';
  canvas.style.height = HEIGHT + 'px';
  canvas.setAttribute('role', 'application');
  canvas.setAttribute('aria-label', 'Machine Math game canvas. Visual math puzzles to power a machine.');
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Accessibility: show visible textual instructions below canvas inside container (not external)
  const visibleInstructions = document.createElement('div');
  visibleInstructions.style.fontFamily = 'Arial, sans-serif';
  visibleInstructions.style.fontSize = '13px';
  visibleInstructions.style.color = '#234';
  visibleInstructions.style.marginTop = '8px';
  visibleInstructions.textContent = 'Instructions: Solve the machine puzzles by placing the correct numbered gears into the slots. Use mouse drag or keyboard. Left/Right to pick a gear, Up/Down to pick a slot, Enter to place, Backspace to remove, M to mute.';
  container.appendChild(visibleInstructions);

  // Set up audio
  let audioCtx = null;
  let audioAllowed = false;
  let ambientGain = null;
  let masterGain = null;
  let ambientOsc = null;

  function initAudio() {
    try {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) {
        throw new Error('Web Audio API not supported.');
      }
      audioCtx = new Ctx();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.9;
      masterGain.connect(audioCtx.destination);

      ambientGain = audioCtx.createGain();
      ambientGain.gain.value = 0.03; // very gentle background
      ambientGain.connect(masterGain);

      // Ambient oscillator (gentle hum with slow LFO)
      ambientOsc = audioCtx.createOscillator();
      ambientOsc.type = 'sine';
      ambientOsc.frequency.value = 110; // low hum
      const ambientFilter = audioCtx.createBiquadFilter();
      ambientFilter.type = 'lowpass';
      ambientFilter.frequency.value = 600;
      ambientOsc.connect(ambientFilter);
      ambientFilter.connect(ambientGain);

      // Create slow LFO for slight volume wobble
      const lfo = audioCtx.createOscillator();
      lfo.type = 'sine';
      lfo.frequency.value = 0.08;
      const lfoGain = audioCtx.createGain();
      lfoGain.gain.value = 0.02;
      lfo.connect(lfoGain);
      lfoGain.connect(ambientGain.gain);

      ambientOsc.start();
      lfo.start();

      audioAllowed = true;
    } catch (e) {
      console.warn('Audio initialization failed:', e);
      audioCtx = null;
      audioAllowed = false;
    }
  }

  // Attempt to initialize audio immediately. Many browsers require user gesture to resume; we'll resume on first interaction.
  initAudio();

  // Utility: resume audio context on gesture
  function tryResumeAudio() {
    if (!audioCtx) return;
    if (audioCtx.state === 'suspended') {
      audioCtx.resume().then(() => {
        audioAllowed = true;
      }).catch((e) => {
        console.warn('Audio resume failed:', e);
        audioAllowed = false;
      });
    }
  }

  // Audio feedback functions
  function playCorrect() {
    if (!audioAllowed || !audioCtx) return;
    tryResumeAudio();
    try {
      const t = audioCtx.currentTime;
      const g = audioCtx.createGain();
      g.gain.value = 0.0001;
      g.connect(masterGain);
      // quick envelope
      g.gain.linearRampToValueAtTime(0.12, t + 0.01);
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.6);

      // small chord: three oscillators
      const freqs = [660, 880, 990];
      freqs.forEach((f, i) => {
        const o = audioCtx.createOscillator();
        o.type = i === 0 ? 'sine' : 'triangle';
        o.frequency.value = f;
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 1200;
        o.connect(filter);
        filter.connect(g);
        o.start(t);
        o.stop(t + 0.6);
      });
    } catch (e) {
      console.warn('playCorrect error:', e);
    }
  }

  function playIncorrect() {
    if (!audioAllowed || !audioCtx) return;
    tryResumeAudio();
    try {
      const t = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      o.type = 'sawtooth';
      o.frequency.setValueAtTime(160, t);
      const g = audioCtx.createGain();
      g.gain.value = 0.0001;
      g.connect(masterGain);
      o.connect(g);
      g.gain.linearRampToValueAtTime(0.13, t + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.35);
      o.start();
      o.stop(t + 0.35);
    } catch (e) {
      console.warn('playIncorrect error:', e);
    }
  }

  function playClick() {
    if (!audioAllowed || !audioCtx) return;
    tryResumeAudio();
    try {
      const t = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      o.type = 'square';
      o.frequency.value = 520;
      const g = audioCtx.createGain();
      g.gain.value = 0.0001;
      g.connect(masterGain);
      o.connect(g);
      g.gain.linearRampToValueAtTime(0.08, t + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.18);
      o.start();
      o.stop(t + 0.18);
    } catch (e) {
      console.warn('playClick error:', e);
    }
  }

  // Sound toggle
  let soundOn = audioAllowed;

  function toggleSound() {
    soundOn = !soundOn;
    if (!audioCtx) {
      // If audio was not created initially, try creating on toggle
      if (soundOn) initAudio();
      else soundOn = false;
    }
    if (ambientGain) ambientGain.gain.value = soundOn ? 0.03 : 0;
    if (masterGain) masterGain.gain.value = soundOn ? 0.9 : 0;
    srInstructions.textContent = soundOn ? 'Sound turned on.' : 'Sound muted.';
    playClick();
  }

  // Colors and visual theme
  const colors = {
    bg: '#E7F0F6',
    machineBody: '#cfe3f2',
    slot: '#e8f6ff',
    gear: '#f7b2a8',
    gearAlt: '#f7d7a8',
    text: '#13304a',
    highlight: '#9ee7c4',
    shadow: 'rgba(0,0,0,0.08)',
    ok: '#2a9d8f',
    bad: '#e76f51',
    speaker: '#234'
  };

  // Game state
  let levelIndex = 0;
  const MAX_LEVELS = 5;
  let levels = [];
  let running = true;
  let lastTime = 0;

  // Generate levels (beatable). Each level has 3 slots, with an operation and target answers.
  function generateLevels() {
    // For age 7-9: addition and subtraction early, then simple multiplication.
    const ops = [
      { type: 'add', range: [2, 10] },
      { type: 'sub', range: [1, 9] },
      { type: 'add', range: [5, 15] },
      { type: 'mul', range: [2, 6] },
      { type: 'mul', range: [2, 8] }
    ];
    levels = ops.slice(0, MAX_LEVELS).map((opDef, i) => {
      const slots = [];
      for (let s = 0; s < 3; s++) {
        let a, b, answer;
        if (opDef.type === 'add') {
          a = randInt(opDef.range[0], opDef.range[1]);
          b = randInt(0, opDef.range[1]);
          answer = a + b;
        } else if (opDef.type === 'sub') {
          a = randInt(opDef.range[0], opDef.range[1]);
          b = randInt(0, a);
          answer = a - b;
        } else if (opDef.type === 'mul') {
          a = randInt(opDef.range[0], opDef.range[1]);
          b = randInt(1, 5);
          answer = a * b;
        }
        const label = `${a} ${opSymbol(opDef.type)} ${b}`;
        slots.push({ label, answer, placed: null });
      }

      // Create candidate gears: include correct answers and distractors
      const correctAnswers = slots.map(s => s.answer);
      const candidates = [...correctAnswers];
      // Add distractors carefully near correct answers
      while (candidates.length < 6) {
        const base = correctAnswers[randInt(0, correctAnswers.length - 1)];
        let distractor = base + (Math.random() < 0.5 ? -1 : 1) * randInt(1, 4);
        if (distractor < 0) distractor = base + randInt(2, 4);
        if (!candidates.includes(distractor)) candidates.push(distractor);
      }
      // Shuffle candidates
      shuffleArray(candidates);

      return {
        type: opDef.type,
        slots,
        candidates
      };
    });
  }

  function opSymbol(type) {
    if (type === 'add') return '+';
    if (type === 'sub') return '−';
    if (type === 'mul') return '×';
    return '?';
  }

  // Utility functions
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  function shuffleArray(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  generateLevels();

  // UI elements positions
  const slotPositions = [
    { x: 180, y: 150 },
    { x: 360, y: 120 },
    { x: 540, y: 150 }
  ];

  const conveyorY = 360;
  const conveyorStartX = 80;
  const conveyorGap = 100;

  // Gear objects for current level
  let gears = []; // {value, x, y, radius, placedSlotIndex, homeX, homeY, dragging}
  let selection = { gearIndex: 0, slotIndex: 0 }; // keyboard selection

  // Load level into gears
  function loadLevel(index) {
    const lvl = levels[index];
    gears = [];
    const startX = conveyorStartX;
    lvl.candidates.forEach((val, i) => {
      const x = startX + i * conveyorGap;
      const y = conveyorY;
      gears.push({
        value: val,
        x,
        y,
        homeX: x,
        homeY: y,
        radius: 38,
        placedSlotIndex: null,
        dragging: false,
        wobble: Math.random() * Math.PI * 2
      });
    });
    // Reset slot placement
    lvl.slots.forEach(s => {
      s.placed = null;
    });

    selection.gearIndex = 0;
    selection.slotIndex = 0;
    srInstructions.textContent = `Level ${index + 1} loaded. Solve three puzzles on the machine.`;
  }

  loadLevel(0);

  // Event handling: mouse, touch, keyboard
  let pointerDown = false;
  let dragGear = null;
  let dragOffset = { x: 0, y: 0 };

  function getPointerPos(e) {
    const rect = canvas.getBoundingClientRect();
    if (e.touches && e.touches[0]) {
      return {
        x: (e.touches[0].clientX - rect.left) * (canvas.width / rect.width),
        y: (e.touches[0].clientY - rect.top) * (canvas.height / rect.height)
      };
    } else {
      return {
        x: (e.clientX - rect.left) * (canvas.width / rect.width),
        y: (e.clientY - rect.top) * (canvas.height / rect.height)
      };
    }
  }

  canvas.addEventListener('mousedown', onPointerDown);
  canvas.addEventListener('touchstart', onPointerDown, { passive: false });
  window.addEventListener('mousemove', onPointerMove);
  window.addEventListener('touchmove', onPointerMove, { passive: false });
  window.addEventListener('mouseup', onPointerUp);
  window.addEventListener('touchend', onPointerUp);

  function onPointerDown(e) {
    e.preventDefault();
    tryResumeAudio();
    pointerDown = true;
    const pos = getPointerPos(e);
    // check if clicked on a gear
    for (let i = gears.length - 1; i >= 0; i--) {
      const g = gears[i];
      const dx = pos.x - g.x;
      const dy = pos.y - g.y;
      if (Math.sqrt(dx * dx + dy * dy) <= g.radius + 6) {
        // start dragging this gear
        dragGear = g;
        g.dragging = true;
        dragOffset.x = dx;
        dragOffset.y = dy;
        selection.gearIndex = i;
        playClick();
        // resume audio on gesture
        if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
        return;
      }
    }
    // If clicked on a slot area (for quick keyboard-like placement)
    const lvl = levels[levelIndex];
    for (let si = 0; si < lvl.slots.length; si++) {
      const posSlot = slotPositions[si];
      const sx = posSlot.x;
      const sy = posSlot.y;
      if (Math.abs(pos.x - sx) < 60 && Math.abs(pos.y - sy) < 60) {
        // Place the currently selected gear into this slot if possible
        placeGearInSlot(selection.gearIndex, si);
        return;
      }
    }
  }

  function onPointerMove(e) {
    if (!pointerDown) return;
    const pos = getPointerPos(e);
    if (dragGear) {
      dragGear.x = pos.x - dragOffset.x;
      dragGear.y = pos.y - dragOffset.y;
    }
  }

  function onPointerUp(e) {
    if (!pointerDown) return;
    pointerDown = false;
    if (dragGear) {
      // detect nearest slot
      const gear = dragGear;
      dragGear.dragging = false;
      let nearest = null;
      let nearestDist = Infinity;
      levels[levelIndex].slots.forEach((slot, si) => {
        const sp = slotPositions[si];
        const dx = gear.x - sp.x;
        const dy = gear.y - sp.y;
        const d = Math.sqrt(dx * dx + dy * dy);
        if (d < nearestDist) {
          nearestDist = d;
          nearest = si;
        }
      });
      // if close enough, attempt to place
      if (nearest !== null && nearestDist < 80) {
        placeGearInSlot(gears.indexOf(gear), nearest);
      } else {
        // return home
        animateReturn(gear);
      }
      dragGear = null;
    }
  }

  function animateReturn(gear) {
    // Gentle animated return to home
    const sx = gear.x;
    const sy = gear.y;
    const dx = gear.homeX - sx;
    const dy = gear.homeY - sy;
    const duration = 300; // ms
    const start = performance.now();
    function step(ts) {
      const t = Math.min(1, (ts - start) / duration);
      const ease = easeOutCubic(t);
      gear.x = sx + dx * ease;
      gear.y = sy + dy * ease;
      if (t < 1) requestAnimationFrame(step);
      else {
        gear.x = gear.homeX;
        gear.y = gear.homeY;
      }
    }
    requestAnimationFrame(step);
  }

  function easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3);
  }

  // Place gear into slot with validation
  function placeGearInSlot(gearIndex, slotIndex) {
    if (gearIndex < 0 || gearIndex >= gears.length) return;
    const gear = gears[gearIndex];
    const lvl = levels[levelIndex];
    const slot = lvl.slots[slotIndex];

    // If slot already has a gear, prevent unless replacing
    if (slot.placed) {
      // If placing same gear that's already there, remove instead
      if (slot.placed === gear) {
        // remove
        slot.placed.placedSlotIndex = null;
        slot.placed = null;
        playClick();
        return;
      } else {
        // return existing gear to home first
        const existing = slot.placed;
        existing.placedSlotIndex = null;
        existing.homeX = existing.homeX;
        animateReturn(existing);
        slot.placed = null;
      }
    }

    // Check correctness
    if (gear.value === slot.answer) {
      // Snap into place
      gear.placedSlotIndex = slotIndex;
      gear.x = slotPositions[slotIndex].x;
      gear.y = slotPositions[slotIndex].y;
      slot.placed = gear;
      playCorrect();
      srInstructions.textContent = `Correct! ${slot.label} = ${slot.answer}.`;
      checkLevelComplete();
    } else {
      // Wrong — gentle shake and return to conveyor
      playIncorrect();
      srInstructions.textContent = `Try again. ${gear.value} does not match ${slot.label}.`;
      // Visual shake animation
      const startX = gear.x;
      const startY = gear.y;
      const duration = 420;
      const start = performance.now();
      function step(ts) {
        const t = (ts - start) / duration;
        if (t >= 1) {
          animateReturn(gear);
          return;
        }
        const shake = Math.sin(t * Math.PI * 8) * (1 - t) * 12;
        gear.x = startX + shake;
        gear.y = startY;
        requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    }
  }

  function checkLevelComplete() {
    const lvl = levels[levelIndex];
    const allPlaced = lvl.slots.every(s => s.placed !== null);
    if (allPlaced) {
      // Small celebration, then advance
      srInstructions.textContent = `Level ${levelIndex + 1} complete!`;
      playCorrect();
      setTimeout(() => {
        if (levelIndex < MAX_LEVELS - 1) {
          levelIndex++;
          loadLevel(levelIndex);
        } else {
          // game won
          showVictory();
        }
      }, 900);
    }
  }

  // Victory screen
  let victory = false;
  let confettiParticles = [];
  function showVictory() {
    victory = true;
    srInstructions.textContent = 'You fixed all the machines! Great job!';
    // Create confetti particles
    for (let i = 0; i < 80; i++) {
      confettiParticles.push({
        x: randInt(100, WIDTH - 100),
        y: randInt(-100, -10),
        vx: (Math.random() - 0.5) * 2,
        vy: randInt(1, 4),
        size: randInt(6, 12),
        color: [colors.highlight, colors.gear, colors.gearAlt, colors.ok][randInt(0, 3)],
        rot: Math.random() * Math.PI * 2,
        rotSpeed: (Math.random() - 0.5) * 0.2
      });
    }
    // Play a bright jingle
    if (audioAllowed) {
      tryResumeAudio();
      const t = audioCtx.currentTime;
      const g = audioCtx.createGain();
      g.gain.value = 0.0001;
      g.connect(masterGain);
      g.gain.linearRampToValueAtTime(0.18, t + 0.02);
      g.gain.exponentialRampToValueAtTime(0.001, t + 1.6);
      const freqs = [440, 660, 880, 1100];
      freqs.forEach((f, i) => {
        const o = audioCtx.createOscillator();
        o.type = i % 2 ? 'triangle' : 'sine';
        o.frequency.value = f;
        const delay = i * 0.05;
        o.connect(g);
        o.start(t + delay);
        o.stop(t + 1.2);
      });
    }
  }

  // Keyboard controls
  window.addEventListener('keydown', (e) => {
    // Allow keyboard to resume audio
    tryResumeAudio();
    if (!running) return;
    const lvl = levels[levelIndex];
    const gearCount = gears.length;
    switch (e.key) {
      case 'ArrowLeft':
        // pick previous gear
        selection.gearIndex = (selection.gearIndex - 1 + gearCount) % gearCount;
        playClick();
        e.preventDefault();
        break;
      case 'ArrowRight':
        selection.gearIndex = (selection.gearIndex + 1) % gearCount;
        playClick();
        e.preventDefault();
        break;
      case 'ArrowUp':
        selection.slotIndex = (selection.slotIndex - 1 + lvl.slots.length) % lvl.slots.length;
        playClick();
        e.preventDefault();
        break;
      case 'ArrowDown':
        selection.slotIndex = (selection.slotIndex + 1) % lvl.slots.length;
        playClick();
        e.preventDefault();
        break;
      case 'Enter':
      case ' ':
        // place selected gear into selected slot
        placeGearInSlot(selection.gearIndex, selection.slotIndex);
        e.preventDefault();
        break;
      case 'Backspace':
      case 'Delete':
        // remove gear from selected slot
        const s = lvl.slots[selection.slotIndex];
        if (s.placed) {
          s.placed.placedSlotIndex = null;
          s.placed = null;
          playClick();
        } else {
          playIncorrect();
        }
        e.preventDefault();
        break;
      case 'm':
      case 'M':
        toggleSound();
        e.preventDefault();
        break;
      default:
        // number keys 0-9 quick placement: attempt to place a gear with that number (if present)
        if (/^\d$/.test(e.key)) {
          const num = parseInt(e.key, 10);
          const gearIdx = gears.findIndex(g => g.value === num && !g.placedSlotIndex);
          if (gearIdx >= 0) {
            placeGearInSlot(gearIdx, selection.slotIndex);
          } else {
            playIncorrect();
          }
        }
        break;
    }
  });

  // Drawing functions
  function draw() {
    // Clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    // Background
    drawBackground();
    // Machine body
    drawMachineBody();
    // Slots with labels and gears
    drawSlotsAndGears();
    // Conveyor belt and gears
    drawConveyorAndGears();
    // UI overlays: level, sound icon, instructions
    drawUI();
    if (victory) drawConfetti();
  }

  function drawBackground() {
    // soft gradient with subtle shapes
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, '#F6FBFF');
    g.addColorStop(1, colors.bg);
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // gentle floating cogs as background decorative elements
    ctx.save();
    ctx.globalAlpha = 0.12;
    for (let i = 0; i < 6; i++) {
      const x = 80 + i * 110 + Math.sin(performance.now() * 0.0006 + i) * 8;
      const y = 60 + (i % 3) * 30;
      drawGearShape(ctx, x, y, 26, 8, '#d5eaf6', '#d5eaf6', 0.9);
    }
    ctx.restore();
  }

  function drawMachineBody() {
    // Main machine rectangle
    ctx.fillStyle = colors.machineBody;
    roundRect(ctx, 60, 80, WIDTH - 120, 200, 18);
    ctx.fill();

    // Shadow
    ctx.fillStyle = colors.shadow;
    roundRect(ctx, 62, 80 + 8, WIDTH - 124, 200, 18);
    ctx.fill();

    // Decorative pipes
    ctx.strokeStyle = '#b9d9f0';
    ctx.lineWidth = 8;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(80, 160);
    ctx.lineTo(160, 160);
    ctx.lineTo(160, 220);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(WIDTH - 80, 160);
    ctx.lineTo(WIDTH - 160, 160);
    ctx.lineTo(WIDTH - 160, 220);
    ctx.stroke();

    // Machine title text
    ctx.fillStyle = colors.text;
    ctx.font = 'bold 20px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('WHIMSY MACHINE WORKS', WIDTH / 2, 110);
  }

  function drawSlotsAndGears() {
    const lvl = levels[levelIndex];
    ctx.textAlign = 'center';
    ctx.font = 'bold 16px Arial';
    // Draw each slot
    lvl.slots.forEach((slot, si) => {
      const pos = slotPositions[si];
      // Slot base
      ctx.save();
      // highlight if keyboard selected
      if (selection.slotIndex === si) {
        ctx.shadowColor = colors.highlight;
        ctx.shadowBlur = 18;
      } else {
        ctx.shadowColor = 'transparent';
      }
      // slot background
      ctx.fillStyle = colors.slot;
      roundRect(ctx, pos.x - 56, pos.y - 56, 112, 112, 16);
      ctx.fill();

      // Label above slot
      ctx.fillStyle = colors.text;
      ctx.font = '14px Arial';
      ctx.fillText(slot.label, pos.x, pos.y - 70);

      // If there's a placed gear draw it there (otherwise draw empty gear placeholder)
      if (slot.placed) {
        drawGearWithNumber(ctx, slot.placed.x, slot.placed.y, slot.placed.radius, slot.placed.value, true);
      } else {
        // placeholder ghost gear
        ctx.globalAlpha = 0.22;
        drawGearShape(ctx, pos.x, pos.y, 46, 10, '#ffffff', '#e0f3ff', 1);
        ctx.globalAlpha = 1;
      }

      ctx.restore();
    });

    // Small hint: show operation type for the level
    ctx.font = '14px Arial';
    ctx.fillStyle = '#0f3345';
    ctx.fillText('Solve to power the machine', WIDTH / 2, 170);
  }

  function drawConveyorAndGears() {
    // Conveyor
    ctx.fillStyle = '#c9dff0';
    roundRect(ctx, 40, conveyorY - 56, WIDTH - 80, 140, 18);
    ctx.fill();

    // draw a dashed moving line to indicate motion
    ctx.strokeStyle = '#b6d1e8';
    ctx.lineWidth = 6;
    ctx.beginPath();
    const offset = (performance.now() * 0.02) % 40;
    for (let x = 60 - offset; x < WIDTH - 60; x += 40) {
      ctx.moveTo(x, conveyorY + 40);
      ctx.lineTo(x + 20, conveyorY + 40);
    }
    ctx.stroke();

    // Draw gear objects
    gears.forEach((g, i) => {
      // wobble animation for idle gears
      if (!g.dragging && g.placedSlotIndex === null) {
        g.wobble += 0.02;
        g.y = g.homeY + Math.sin(g.wobble) * 4;
      }
      // highlight if selected via keyboard
      const isSelected = selection.gearIndex === i;
      drawGearWithNumber(ctx, g.x, g.y, g.radius, g.value, isSelected);
    });
  }

  function drawGearWithNumber(ctx, x, y, r, value, highlight = false) {
    // base gear
    drawGearShape(ctx, x, y, r, 10, highlight ? colors.highlight : colors.gear, highlight ? '#fff7f2' : '#fff8f7', 1);
    // center circle
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(x, y, r * 0.5, 0, Math.PI * 2);
    ctx.fill();

    // number
    ctx.fillStyle = colors.text;
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(String(value), x, y);
    // small shadow
    ctx.globalAlpha = 0.06;
    ctx.fillStyle = '#000';
    ctx.fillRect(x - r, y + r + 6, r * 2, 4);
    ctx.globalAlpha = 1;
  }

  function drawGearShape(ctx, x, y, radius, teeth, fill, stroke, alpha) {
    ctx.save();
    ctx.globalAlpha = alpha !== undefined ? alpha : 1;
    // draw gear using arcs and rectangles for teeth
    ctx.translate(x, y);
    ctx.beginPath();
    const toothAngle = (Math.PI * 2) / (teeth * 2);
    for (let i = 0; i < teeth * 2; i++) {
      const angle = i * toothAngle;
      const r = (i % 2 === 0) ? radius : radius * 0.78;
      ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
    }
    ctx.closePath();
    ctx.fillStyle = fill;
    ctx.fill();
    ctx.strokeStyle = stroke;
    ctx.lineWidth = 3;
    ctx.stroke();

    // center hole
    ctx.beginPath();
    ctx.fillStyle = stroke;
    ctx.arc(0, 0, radius * 0.14, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  function drawUI() {
    // Level indicator
    ctx.fillStyle = colors.text;
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(`Level ${levelIndex + 1} / ${MAX_LEVELS}`, 24, 30);

    // Sound icon
    const sx = WIDTH - 60;
    const sy = 24;
    ctx.save();
    ctx.fillStyle = colors.speaker;
    if (!soundOn) ctx.globalAlpha = 0.28;
    // speaker box
    ctx.beginPath();
    ctx.moveTo(sx - 12, sy - 8);
    ctx.lineTo(sx - 12, sy + 8);
    ctx.lineTo(sx, sy + 8);
    ctx.lineTo(sx + 12, sy + 14);
    ctx.lineTo(sx + 12, sy - 14);
    ctx.lineTo(sx, sy - 8);
    ctx.closePath();
    ctx.fill();
    // waves when soundOn
    if (soundOn) {
      ctx.strokeStyle = colors.speaker;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(sx + 18, sy, 8, -0.5, 0.5);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(sx + 22, sy, 12, -0.6, 0.6);
      ctx.stroke();
    } else {
      // draw cross
      ctx.strokeStyle = '#f55';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(sx + 28, sy - 12);
      ctx.lineTo(sx + 12, sy + 8);
      ctx.moveTo(sx + 12, sy - 12);
      ctx.lineTo(sx + 28, sy + 8);
      ctx.stroke();
    }
    ctx.restore();

    // Text hint on keyboard controls (small)
    ctx.font = '12px Arial';
    ctx.fillStyle = '#0f3345';
    ctx.textAlign = 'right';
    ctx.fillText('Keys: ←→ gears  ↑↓ slots  Enter place  Backspace remove  M mute', WIDTH - 20, HEIGHT - 12);
  }

  function drawConfetti() {
    // update and draw particles
    confettiParticles.forEach(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.08;
      p.rot += p.rotSpeed;
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot);
      ctx.fillStyle = p.color;
      ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size * 0.6);
      ctx.restore();
    });
    // remove offscreen particles and let them loop
    if (confettiParticles.length === 0) return;
    confettiParticles = confettiParticles.filter(p => p.y < HEIGHT + 200);
  }

  // Main loop
  function loop(ts) {
    const dt = ts - lastTime;
    lastTime = ts;
    draw();
    if (running) requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);

  // Utility: rounded rect
  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  // Error handling: capture errors
  window.addEventListener('error', (ev) => {
    console.error('Game error:', ev.error || ev.message);
    srInstructions.textContent = 'An unexpected error occurred in the game. Please reload.';
  });

  // Expose a small debug API on container (non-intrusive)
  container.gameAPI = {
    restart: function() {
      levelIndex = 0;
      victory = false;
      confettiParticles = [];
      generateLevels();
      loadLevel(0);
      srInstructions.textContent = 'Game restarted.';
    },
    toggleSound
  };

  // Provide initial instruction spoken-like text for screen readers
  setTimeout(() => {
    srInstructions.textContent = 'Welcome to Machine Math! Click or press keys to begin. Solve the math puzzles to fix the machines.';
  }, 600);

  // Final: ensure first-click resumes audio for browsers that require gesture
  canvas.addEventListener('click', () => {
    if (audioCtx && audioCtx.state === 'suspended') {
      audioCtx.resume().then(() => {
        audioAllowed = true;
        soundOn = true;
        if (ambientGain) ambientGain.gain.value = 0.03;
        srInstructions.textContent = 'Audio enabled.';
      }).catch(() => {
        audioAllowed = false;
        srInstructions.textContent = 'Audio is not available.';
      });
    }
  });

  // Ensure focus for keyboard controls and positive UX
  canvas.tabIndex = 0;
  canvas.style.outline = 'none';
  canvas.addEventListener('focus', () => {
    srInstructions.textContent = 'Canvas focused. Use keyboard to play.';
  });
  canvas.addEventListener('blur', () => {
    srInstructions.textContent = 'Canvas lost focus. Click to regain control.';
  });

})();
---

