# Game of the Day - 2025-10-29

## Metadata
- **Generated Date:** 2025-10-29
- **Generated Time:** 2025-10-29T00:28:15.466733
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-10-29.js
- **File Size:** 24949 bytes
- **Tokens Used:** 8589

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-10-29.js` - The playable game
- `2025-10-29.meta.json` - Machine-readable metadata
- `2025-10-29.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 17668

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 19554

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Drone Math Adventure
  // Renders game inside element with ID 'game-of-the-day-stage'
  // Only canvas and Web Audio API used. No external assets.

  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const PADDING = 12; // minimum spacing for UI elements
  const TARGET_CORRECT = 10; // win condition
  const MAX_WRONG = 3; // lose condition
  const BG_COLOR = '#eaf3ff'; // calming sky-blue
  const DRONE_COLOR = '#7aa2ff';
  const DRONE_ACCENT = '#ffd166';
  const BUTTON_COLOR = '#ffffff';
  const BUTTON_BORDER = '#4d6fa9';
  const TEXT_COLOR = '#0b2d4a';
  const FONT_BODY = '16px "Segoe UI", Roboto, Arial, sans-serif';
  const FONT_BIG = '22px "Segoe UI", Roboto, Arial, sans-serif';
  const FONT_TITLE = '28px "Segoe UI", Roboto, Arial, sans-serif';
  const BUTTON_PADDING = 10;

  // State
  let container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Container with id "game-of-the-day-stage" not found.');
    return;
  }

  // Clear container
  container.innerHTML = '';
  container.style.position = 'relative';
  container.style.width = WIDTH + 'px';
  container.style.height = HEIGHT + 'px';

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute('role', 'img');
  canvas.setAttribute('aria-label', 'Drone Math Adventure for ages 7 to 9. Use number keys or click to answer. Press M to mute, R to restart.');
  canvas.style.display = 'block';
  canvas.style.outline = 'none';
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Accessibility: hidden description element for screen readers
  const desc = document.createElement('div');
  desc.style.position = 'absolute';
  desc.style.left = '-9999px';
  desc.style.top = '-9999px';
  desc.setAttribute('aria-hidden', 'false');
  desc.textContent = 'Drone Math Adventure. Answer 10 math questions correctly to win. Three wrong answers ends the game. Controls: number keys 1-3 to choose answers, Enter to confirm, arrow keys to navigate choices, M to mute, R to restart.';
  container.appendChild(desc);

  // Audio setup with error handling
  let audioCtx = null;
  let bgOsc = null;
  let bgGain = null;
  let soundOn = true;
  function tryCreateAudioContext() {
    if (audioCtx) return;
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AC();
      // create gentle background hum (but do not start until user gesture)
      bgOsc = audioCtx.createOscillator();
      bgOsc.type = 'sine';
      bgOsc.frequency.value = 120; // low humming
      bgGain = audioCtx.createGain();
      bgGain.gain.value = 0.02;
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 800;
      bgOsc.connect(filter);
      filter.connect(bgGain);
      bgGain.connect(audioCtx.destination);
      // don't start automatically; will start/resume on user gesture
    } catch (e) {
      console.warn('AudioContext unavailable:', e);
      audioCtx = null;
      soundOn = false;
    }
  }

  // Sound primitives
  function playTone(freq, duration = 0.2, type = 'sine', volume = 0.08) {
    if (!audioCtx || !soundOn) return;
    try {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      gain.gain.value = volume;
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      const t = audioCtx.currentTime;
      gain.gain.setValueAtTime(volume, t);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + duration);
      osc.start(t);
      osc.stop(t + duration + 0.01);
    } catch (e) {
      console.warn('playTone error', e);
    }
  }
  function playCorrect() {
    playTone(880, 0.12, 'triangle', 0.08);
    setTimeout(() => playTone(1320, 0.08, 'sine', 0.06), 120);
  }
  function playWrong() {
    playTone(220, 0.25, 'sawtooth', 0.12);
  }
  function startBackground() {
    if (!audioCtx || !soundOn || !bgOsc) return;
    try {
      // If suspended, resume
      if (audioCtx.state === 'suspended') {
        audioCtx.resume().catch((e) => console.warn('Audio resume failed', e));
      }
      // Start oscillator if not already started
      try {
        bgOsc.start();
      } catch (e) {
        // already started
      }
      // Fade in gently
      bgGain.gain.cancelScheduledValues(audioCtx.currentTime);
      bgGain.gain.setValueAtTime(0.0001, audioCtx.currentTime);
      bgGain.gain.linearRampToValueAtTime(0.02, audioCtx.currentTime + 1.0);
    } catch (e) {
      console.warn('startBackground error', e);
    }
  }
  function stopBackground() {
    if (!audioCtx || !bgGain) return;
    try {
      bgGain.gain.cancelScheduledValues(audioCtx.currentTime);
      bgGain.gain.linearRampToValueAtTime(0.0001, audioCtx.currentTime + 0.6);
    } catch (e) {
      console.warn('stopBackground error', e);
    }
  }

  // Game variables
  let correctCount = 0;
  let wrongCount = 0;
  let currentQuestion = null;
  let choices = [];
  let selectedIndex = 0;
  let gameState = 'playing'; // 'playing', 'won', 'lost', 'start' (start for first time)
  let shakeTimer = 0;
  let animationTick = 0;
  let awaitingFirstGesture = true; // audio policy: wait for gesture
  let lastActionMsg = ''; // for screen reader / small log

  // Utility functions
  function randInt(a, b) {
    return Math.floor(Math.random() * (b - a + 1)) + a;
  }

  function generateQuestion() {
    // For ages 7-9: addition/subtraction, simple multiplication maybe
    const typeRoll = Math.random();
    let a, b, op, answer, text;
    if (typeRoll < 0.5) {
      // addition
      a = randInt(1, 20);
      b = randInt(1, 20);
      op = '+';
      answer = a + b;
      text = `${a} + ${b} = ?`;
    } else if (typeRoll < 0.85) {
      // subtraction ensuring positive
      a = randInt(5, 25);
      b = randInt(1, a - 1);
      op = '−';
      answer = a - b;
      text = `${a} − ${b} = ?`;
    } else {
      // simple multiplication up to 5x7
      a = randInt(2, 7);
      b = randInt(2, 6);
      op = '×';
      answer = a * b;
      text = `${a} × ${b} = ?`;
    }

    // generate 3 choices including answer, within reasonable distractors
    const opts = new Set();
    opts.add(answer);
    while (opts.size < 3) {
      let delta = randInt(1, Math.max(3, Math.floor(answer * 0.5) + 1));
      if (Math.random() < 0.5) delta = -delta;
      const candidate = answer + delta;
      if (candidate >= 0 && !opts.has(candidate)) opts.add(candidate);
    }
    const optArray = Array.from(opts);
    // shuffle
    for (let i = optArray.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [optArray[i], optArray[j]] = [optArray[j], optArray[i]];
    }
    return { text, answer, choices: optArray };
  }

  function startNewQuestion() {
    const q = generateQuestion();
    currentQuestion = q.text;
    choices = q.choices;
    correctAnswer = q.answer;
    selectedIndex = 0;
  }

  // Initialize first question
  startNewQuestion();

  // Input handling
  function ensureAudioOnUserGesture() {
    if (!awaitingFirstGesture) return;
    tryCreateAudioContext();
    if (audioCtx) {
      // start or resume background
      if (audioCtx.state === 'suspended') {
        audioCtx.resume().catch((e) => console.warn('Audio resume failed', e));
      }
      startBackground();
    }
    awaitingFirstGesture = false;
  }

  canvas.tabIndex = 0;
  canvas.addEventListener('keydown', (e) => {
    // ensure audio created on gesture
    if (awaitingFirstGesture) ensureAudioOnUserGesture();
    if (gameState === 'won' || gameState === 'lost') {
      if (e.key.toLowerCase() === 'r') {
        restartGame();
      }
      return;
    }
    if (e.key === 'ArrowLeft') {
      selectedIndex = (selectedIndex + choices.length - 1) % choices.length;
      lastActionMsg = `Selected choice ${selectedIndex + 1}`;
    } else if (e.key === 'ArrowRight') {
      selectedIndex = (selectedIndex + 1) % choices.length;
      lastActionMsg = `Selected choice ${selectedIndex + 1}`;
    } else if (e.key === 'Enter') {
      submitAnswer(selectedIndex);
    } else if (['1', '2', '3'].includes(e.key)) {
      const idx = parseInt(e.key, 10) - 1;
      if (idx >= 0 && idx < choices.length) {
        selectedIndex = idx;
        submitAnswer(idx);
      }
    } else if (e.key.toLowerCase() === 'm') {
      toggleSound();
    } else if (e.key.toLowerCase() === 'r') {
      restartGame();
    }
  });

  // Mouse/touch interactions - clickable buttons drawn on canvas
  canvas.addEventListener('mousedown', (e) => {
    if (awaitingFirstGesture) ensureAudioOnUserGesture();
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (gameState === 'won' || gameState === 'lost') {
      // Check restart button area
      const restartRect = getRestartButtonRect();
      if (pointInRect(x, y, restartRect)) {
        restartGame();
        return;
      }
      return;
    }

    // Check sound toggle area
    const speakerRect = getSpeakerRect();
    if (pointInRect(x, y, speakerRect)) {
      toggleSound();
      return;
    }

    // Check choice buttons
    const btnRects = getChoiceButtonRects();
    for (let i = 0; i < btnRects.length; i++) {
      if (pointInRect(x, y, btnRects[i])) {
        selectedIndex = i;
        submitAnswer(i);
        return;
      }
    }
  });

  // Helpers for rects
  function pointInRect(px, py, r) {
    return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;
  }

  function getSpeakerRect() {
    const size = 34;
    return { x: WIDTH - PADDING - size, y: PADDING, w: size, h: size };
  }

  function getScoreRect() {
    // top-left
    return { x: PADDING, y: PADDING, w: 200, h: 38 };
  }
  function getLivesRect() {
    return { x: WIDTH - PADDING - 160, y: PADDING, w: 160, h: 38 };
  }
  function getQuestionRect() {
    // center top-ish
    const w = WIDTH - 2 * PADDING - 160;
    return { x: (WIDTH - w) / 2, y: 70, w, h: 70 };
  }
  function getChoiceButtonRects() {
    const btnW = (WIDTH - PADDING * 2 - 40) / 3;
    const btnH = 60;
    const y = 270;
    const rects = [];
    for (let i = 0; i < 3; i++) {
      rects.push({ x: PADDING + i * (btnW + 20), y, w: btnW, h: btnH });
    }
    return rects;
  }
  function getInstructionsRect() {
    const h = 60;
    return { x: PADDING, y: HEIGHT - PADDING - h, w: WIDTH - 2 * PADDING, h };
  }
  function getRestartButtonRect() {
    const w = 180;
    const h = 48;
    return { x: (WIDTH - w) / 2, y: HEIGHT / 2 + 60, w, h };
  }

  // Submission logic
  let correctAnswer = null;
  function submitAnswer(idx) {
    if (gameState !== 'playing') return;
    if (idx < 0 || idx >= choices.length) return;
    const chosen = choices[idx];
    if (chosen === correctAnswer) {
      correctCount++;
      lastActionMsg = `Correct! ${chosen}`;
      playCorrect();
      // small celebration
      shakeTimer = 12;
      if (correctCount >= TARGET_CORRECT) {
        gameState = 'won';
        stopBackground();
      } else {
        startNewQuestion();
      }
    } else {
      wrongCount++;
      lastActionMsg = `Wrong. You picked ${chosen}`;
      playWrong();
      shakeTimer = 18;
      if (wrongCount >= MAX_WRONG) {
        gameState = 'lost';
        stopBackground();
      } else {
        // make a new question but keep challenge increasing slightly
        startNewQuestion();
      }
    }
  }

  function restartGame() {
    correctCount = 0;
    wrongCount = 0;
    startNewQuestion();
    gameState = 'playing';
    shakeTimer = 0;
    awaitingFirstGesture = true;
    lastActionMsg = 'Game restarted';
    try {
      if (audioCtx && audioCtx.state === 'running' && soundOn) {
        startBackground();
      }
    } catch (e) {
      console.warn(e);
    }
  }

  function toggleSound() {
    tryCreateAudioContext();
    soundOn = !soundOn;
    if (soundOn) {
      startBackground();
    } else {
      stopBackground();
    }
  }

  // Drawing functions with layout constraints and measureText usage
  function clearScreen() {
    ctx.fillStyle = BG_COLOR;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
  }

  function drawRoundedRect(x, y, w, h, r = 8, fill = true, stroke = true) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  function drawUI() {
    // Score top-left
    ctx.font = FONT_BODY;
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#ffffff';
    ctx.strokeStyle = '#cfe4ff';
    ctx.lineWidth = 2;
    const scoreRect = getScoreRect();
    // Compute dynamic width based on text
    const scoreText = `Score: ${correctCount}/${TARGET_CORRECT}`;
    ctx.font = FONT_BIG;
    const scoreW = Math.max(scoreRect.w, ctx.measureText(scoreText).width + 2 * PADDING);
    const sr = { x: scoreRect.x, y: scoreRect.y, w: scoreW, h: scoreRect.h };
    ctx.fillStyle = '#ffffff';
    ctx.strokeStyle = '#b8d4ff';
    ctx.lineWidth = 2;
    ctx.fillStyle = '#ffffff';
    drawRoundedRect(sr.x, sr.y, sr.w, sr.h, 8, true, true);
    ctx.fillStyle = TEXT_COLOR;
    ctx.font = FONT_BIG;
    ctx.fillText(scoreText, sr.x + PADDING, sr.y + sr.h / 2);

    // Lives top-right
    const livesRect = getLivesRect();
    const livesText = `Lives: ${Math.max(0, MAX_WRONG - wrongCount)} / ${MAX_WRONG}`;
    ctx.font = FONT_BIG;
    const lw = Math.max(livesRect.w, ctx.measureText(livesText).width + 2 * PADDING);
    const lr = { x: WIDTH - PADDING - lw, y: livesRect.y, w: lw, h: livesRect.h };
    ctx.fillStyle = '#ffffff';
    ctx.strokeStyle = '#ffd6a5';
    ctx.lineWidth = 2;
    drawRoundedRect(lr.x, lr.y, lr.w, lr.h, 8, true, true);
    ctx.fillStyle = TEXT_COLOR;
    ctx.fillText(livesText, lr.x + PADDING, lr.y + lr.h / 2);

    // Speaker icon (sound toggle) top-right corner above lives area
    const sp = getSpeakerRect();
    ctx.fillStyle = '#ffffff';
    ctx.strokeStyle = '#cfe4ff';
    ctx.lineWidth = 2;
    drawRoundedRect(sp.x, sp.y, sp.w, sp.h, 6, true, true);
    // Draw speaker glyph
    ctx.fillStyle = TEXT_COLOR;
    const centerX = sp.x + sp.w * 0.35;
    const centerY = sp.y + sp.h / 2;
    // speaker box
    ctx.fillRect(centerX - 6, centerY - 8, 12, 16);
    // speaker cone
    ctx.beginPath();
    ctx.moveTo(centerX + 6, centerY - 10);
    ctx.lineTo(centerX + 18, centerY);
    ctx.lineTo(centerX + 6, centerY + 10);
    ctx.closePath();
    ctx.fill();
    // sound bars if on
    if (soundOn) {
      ctx.strokeStyle = '#2b6cb0';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(sp.x + sp.w - 10, sp.y + sp.h / 2 - 10);
      ctx.lineTo(sp.x + sp.w - 4, sp.y + sp.h / 2 - 4);
      ctx.moveTo(sp.x + sp.w - 10, sp.y + sp.h / 2 + 0);
      ctx.lineTo(sp.x + sp.w - 4, sp.y + sp.h / 2 + 6);
      ctx.stroke();
    } else {
      // draw muted X
      ctx.strokeStyle = '#a0a0a0';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(sp.x + 6, sp.y + 6);
      ctx.lineTo(sp.x + sp.w - 6, sp.y + sp.h - 6);
      ctx.moveTo(sp.x + sp.w - 6, sp.y + 6);
      ctx.lineTo(sp.x + 6, sp.y + sp.h - 6);
      ctx.stroke();
    }

    // Question box center
    const qRect = getQuestionRect();
    ctx.fillStyle = '#ffffff';
    ctx.strokeStyle = '#cfe4ff';
    ctx.lineWidth = 2;
    drawRoundedRect(qRect.x, qRect.y, qRect.w, qRect.h, 10, true, true);
    ctx.fillStyle = TEXT_COLOR;
    ctx.font = FONT_TITLE;

    // Word-wrap question if necessary: use ctx.measureText
    const qText = currentQuestion || '';
    let maxWidth = qRect.w - 2 * PADDING;
    // since question is short, single line likely fine
    const qWidth = ctx.measureText(qText).width;
    if (qWidth <= maxWidth) {
      ctx.fillText(qText, qRect.x + (qRect.w - qWidth) / 2, qRect.y + qRect.h / 2 + 4);
    } else {
      // wrap into two lines
      const words = qText.split(' ');
      let line = '';
      let lines = [];
      for (let w of words) {
        const test = line ? line + ' ' + w : w;
        if (ctx.measureText(test).width <= maxWidth) {
          line = test;
        } else {
          lines.push(line);
          line = w;
        }
      }
      if (line) lines.push(line);
      const lineHeight = 28;
      const startY = qRect.y + (qRect.h - lines.length * lineHeight) / 2;
      for (let i = 0; i < lines.length; i++) {
        ctx.fillText(lines[i], qRect.x + (qRect.w - ctx.measureText(lines[i]).width) / 2, startY + i * lineHeight + 20);
      }
    }

    // Draw drone graphic (wacky) left of question box center
    drawDrone(qRect.x - 140, qRect.y - 10, 120, 80);

    // Choice buttons
    const btnRects = getChoiceButtonRects();
    ctx.font = FONT_BODY;
    ctx.textBaseline = 'middle';
    for (let i = 0; i < btnRects.length; i++) {
      const r = btnRects[i];
      // background
      ctx.fillStyle = BUTTON_COLOR;
      ctx.strokeStyle = BUTTON_BORDER;
      ctx.lineWidth = selectedIndex === i ? 4 : 2;
      drawRoundedRect(r.x, r.y, r.w, r.h, 10, true, true);
      // label number (1/2/3)
      ctx.fillStyle = '#6b87b2';
      ctx.font = '18px "Segoe UI", Roboto, Arial, sans-serif';
      const prefix = `${i + 1}. `;
      ctx.fillText(prefix, r.x + BUTTON_PADDING, r.y + r.h / 2);
      // value
      ctx.fillStyle = TEXT_COLOR;
      ctx.font = FONT_BIG;
      const valueText = String(choices[i]);
      const valueWidth = ctx.measureText(valueText).width;
      // ensure no overlap between prefix and value: position value centered relative to button
      const valueX = r.x + (r.w - valueWidth) / 2 + 6;
      ctx.fillText(valueText, valueX, r.y + r.h / 2);
      // small visual cue for selected
      if (selectedIndex === i) {
        ctx.strokeStyle = '#ffd166';
        ctx.lineWidth = 3;
        ctx.strokeRect(r.x + 6, r.y + 6, r.w - 12, r.h - 12);
      }
    }

    // Instructions bottom-center
    const instrRect = getInstructionsRect();
    ctx.fillStyle = '#ffffff';
    ctx.strokeStyle = '#cfe4ff';
    ctx.lineWidth = 2;
    drawRoundedRect(instrRect.x, instrRect.y, instrRect.w, instrRect.h, 8, true, true);
    ctx.fillStyle = TEXT_COLOR;
    ctx.font = FONT_BODY;
    ctx.textBaseline = 'top';
    const instr = 'Controls: Click a choice or press 1-3. Use ← → to change selection. Enter to submit. M to toggle sound. R to restart.';
    // wrap instructions text across two lines if needed
    const maxInstrW = instrRect.w - 2 * PADDING;
    const instrWords = instr.split(' ');
    let lines = [];
    let cur = '';
    for (let w of instrWords) {
      const test = cur ? cur + ' ' + w : w;
      if (ctx.measureText(test).width <= maxInstrW) {
        cur = test;
      } else {
        lines.push(cur);
        cur = w;
      }
    }
    if (cur) lines.push(cur);
    // ensure spacing >=10px between bottom elements
    for (let i = 0; i < lines.length; i++) {
      ctx.fillText(lines[i], instrRect.x + PADDING, instrRect.y + PADDING + i * 20);
    }

    // tiny lastAction message for SR and feedback
    ctx.font = '14px "Segoe UI", Roboto, Arial, sans-serif';
    ctx.fillStyle = '#4a4a4a';
    const msg = lastActionMsg || '';
    ctx.fillText(msg, instrRect.x + PADDING, instrRect.y + PADDING + lines.length * 20 + 4);
  }

  function drawDrone(x, y, w, h) {
    // Wacky calming drone drawn with canvas primitives
    const cx = x + w / 2;
    const cy = y + h / 2;
    // body
    ctx.save();
    ctx.translate(cx, cy);
    if (shakeTimer > 0) {
      const shakeOffset = Math.sin(animationTick / 3) * 4;
      ctx.translate(shakeOffset, 0);
    }
    ctx.fillStyle = DRONE_COLOR;
    ctx.strokeStyle = '#33588a';
    ctx.lineWidth = 3;
    // main oval body
    ctx.beginPath();
    ctx.ellipse(0, 0, w * 0.45, h * 0.38, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    // face (windows)
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.ellipse(-w * 0.12, -4, w * 0.13, h * 0.12, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(w * 0.18, -2, w * 0.09, h * 0.09, 0, 0, Math.PI * 2);
    ctx.fill();
    // accent stripe
    ctx.fillStyle = DRONE_ACCENT;
    ctx.fillRect(-w * 0.45, h * 0.12, w * 0.9, h * 0.12);
    // propellers: three small circles connected with arcs (wacky)
    const pr = Math.min(w, h) * 0.12;
    const armLen = w * 0.65;
    for (let i = 0; i < 3; i++) {
      const angle = (i / 3) * Math.PI * 2 - Math.PI / 6;
      const ax = Math.cos(angle) * armLen / 2;
      const ay = Math.sin(angle) * armLen / 2 - 8;
      // arm
      ctx.strokeStyle = '#2a5578';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(ax, ay);
      ctx.stroke();
      // propeller disc
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(ax, ay, pr, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      // little blades - rotated animation
      ctx.save();
      ctx.translate(ax, ay);
      ctx.rotate(animationTick / 10 + i);
      ctx.fillStyle = '#a7c2e8';
      for (let b = 0; b < 3; b++) {
        ctx.beginPath();
        ctx.ellipse(0, -pr * 0.4 - b * 2, pr * 0.25, pr * 0.6, (Math.PI / 6) * b, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }
    // tiny smiley
    ctx.fillStyle = '#2a3b4d';
    ctx.beginPath();
    ctx.arc(-w * 0.12, -2, 2.6, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(w * 0.18, 0, 1.8, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.strokeStyle = '#2a3b4d';
    ctx.lineWidth = 1.5;
    ctx.arc(0, h * 0.02, 8, 0.1 * Math.PI, 0.9 * Math.PI);
    ctx.stroke();
    ctx.restore();
  }

  // End screens
  function drawEndScreen() {
    // overlay
    ctx.fillStyle = 'rgba(5,10,20,0.5)';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    ctx.font = FONT_TITLE;
    ctx.fillStyle = '#ffffff';
    ctx.textBaseline = 'middle';

    let title = '';
    if (gameState === 'won') {
      title = 'Victory! Drone Fleet Celebrates!';
    } else if (gameState === 'lost') {
      title = 'Game Over. Grounded for now.';
    } else {
      title = 'Time';
    }
    const titleW = ctx.measureText(title).width;
    ctx.fillText(title, (WIDTH - titleW) / 2, HEIGHT / 2 - 40);

    ctx.font = FONT_BIG;
    let message = '';
    if (gameState === 'won') {
      message = `You answered ${correctCount} questions correctly!`;
    } else {
      message = `You got ${wrongCount} wrong. Correct answers: ${correctCount}.`;
    }
    const msgW = ctx.measureText(message).width;
    ctx.fillText(message, (WIDTH - msgW) / 2, HEIGHT / 2);

    // Restart button
    const r = getRestartButtonRect();
    ctx.fillStyle = '#ffffff';
    ctx.strokeStyle = '#9ad1ff';
    ctx.lineWidth = 2;
    drawRoundedRect(r.x, r.y, r.w, r.h, 10, true, true);
    ctx.fillStyle = '#1b3f6b';
    ctx.font = '18px "Segoe UI", Roboto, Arial, sans-serif';
    const btnText = 'Restart (R)';
    const bw = ctx.measureText(btnText).width;
    ctx.fillText(btnText, r.x + (r.w - bw) / 2, r.y + r.h / 2);
    // small instruction for audio
    ctx.font = FONT_BODY;
    ctx.fillStyle = '#ffffff';
    const audioHint = 'Press M to toggle sound.';
    ctx.fillText(audioHint, (WIDTH - ctx.measureText(audioHint).width) / 2, r.y + r.h + 30);
  }

  // Main loop
  function update() {
    animationTick++;
    if (shakeTimer > 0) shakeTimer--;
    // gentle auto-selection bounce
    // re-render
    clearScreen();
    if (gameState === 'playing') {
      drawUI();
    } else {
      // still draw UI behind the overlay for context
      drawUI();
      drawEndScreen();
    }
    requestAnimationFrame(update);
  }

  // Start background on first user interaction for audio policies
  function onFirstInteraction() {
    if (!awaitingFirstGesture) return;
    ensureAudioOnUserGesture();
  }
  ['mousedown', 'touchstart', 'keydown'].forEach((ev) => {
    window.addEventListener(ev, onFirstInteraction, { once: true });
  });

  // Start update loop
  tryCreateAudioContext();
  if (audioCtx && !awaitingFirstGesture && soundOn) {
    startBackground();
  }
  canvas.focus();
  requestAnimationFrame(update);

  // Expose minimal debugging on container
  container.addEventListener('keydown', (e) => {
    // ensure canvas gets focus for keyboard control
    if (document.activeElement !== canvas) canvas.focus();
  });

  // Error handling for resource issues: wrap critical operations
  window.addEventListener('error', (ev) => {
    console.error('Error in Drone Math Adventure:', ev.message);
  });

  // Public reveal for tests (not necessary but harmless)
  window.__droneMathGame = {
    restart: restartGame,
    toggleSound,
    getState: () => ({ correctCount, wrongCount, gameState }),
  };
})();
---

