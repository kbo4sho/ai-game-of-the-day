{
  "generated_date": "2025-11-20",
  "generated_timestamp": "2025-11-20T00:28:22.495013",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9532,
  "game_filename": "2025-11-20.js",
  "game_size_bytes": 25859,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Drone Math Adventure\n  // Game renders inside #game-of-the-day-stage\n  // Canvas-based, Web Audio API generated sounds, accessible controls.\n  \"use strict\";\n\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const REQUIRED_CORRECT = 10;\n  const MAX_WRONG = 3;\n  const UI_PADDING = 10;\n  const BODY_FONT = \"16px sans-serif\"; // >=14px\n  const IMPORTANT_FONT = \"20px sans-serif\"; // >=18px\n  const TITLE_FONT = \"28px sans-serif\";\n  const OPTION_FONT = \"22px sans-serif\";\n\n  // Utility helpers\n  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }\n  function randInt(a, b) { return Math.floor(Math.random() * (b - a + 1)) + a; }\n  function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }\n\n  // Get container\n  const container = document.getElementById(\"game-of-the-day-stage\");\n  if (!container) {\n    console.error(\"Container #game-of-the-day-stage not found.\");\n    return;\n  }\n\n  // Clear container\n  container.innerHTML = \"\";\n\n  // Create canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute(\"role\", \"application\");\n  canvas.setAttribute(\"aria-label\", \"Drone Math Adventure game area. Use mouse or keyboard to play.\");\n  canvas.style.outline = \"none\";\n  container.appendChild(canvas);\n  const ctx = canvas.getContext(\"2d\");\n\n  // Accessibility: focus canvas to receive keyboard events\n  canvas.tabIndex = 0;\n  canvas.focus();\n\n  // Audio setup with error handling\n  let audioEnabled = true;\n  let audioCtx = null;\n  let masterGain = null;\n  let ambientGain = null;\n  let ambientOsc = null;\n  try {\n    const AC = window.AudioContext || window.webkitAudioContext;\n    if (!AC) throw new Error(\"Web Audio API not supported.\");\n    audioCtx = new AC();\n    masterGain = audioCtx.createGain();\n    masterGain.gain.value = 0.9;\n    masterGain.connect(audioCtx.destination);\n\n    // Ambient gentle hum\n    ambientGain = audioCtx.createGain();\n    ambientGain.gain.value = 0.08;\n    ambientGain.connect(masterGain);\n\n    ambientOsc = audioCtx.createOscillator();\n    ambientOsc.type = \"sine\";\n    ambientOsc.frequency.value = 110; // low hum\n    const ambientFilter = audioCtx.createBiquadFilter();\n    ambientFilter.type = \"lowpass\";\n    ambientFilter.frequency.value = 600;\n    ambientOsc.connect(ambientFilter);\n    ambientFilter.connect(ambientGain);\n    ambientOsc.start();\n  } catch (e) {\n    console.warn(\"Audio unavailable:\", e);\n    audioEnabled = false;\n    audioCtx = null;\n  }\n\n  function resumeAudioIfNeeded() {\n    if (!audioEnabled || !audioCtx) return;\n    if (audioCtx.state === \"suspended\") {\n      audioCtx.resume().catch((e) => console.warn(\"Audio resume failed:\", e));\n    }\n  }\n\n  // Sound effects\n  function playBeep(options = {}) {\n    if (!audioEnabled || !audioCtx) return;\n    try {\n      const now = audioCtx.currentTime;\n      const osc = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n      osc.type = options.type || \"sine\";\n      osc.frequency.value = options.freq || 440;\n      gain.gain.value = 0;\n      osc.connect(gain);\n      gain.connect(masterGain);\n      const dur = options.duration || 0.18;\n      const attack = 0.01;\n      gain.gain.setValueAtTime(0, now);\n      gain.gain.linearRampToValueAtTime((options.volume || 0.6), now + attack);\n      gain.gain.exponentialRampToValueAtTime(0.0001, now + dur);\n      osc.start(now);\n      osc.stop(now + dur + 0.02);\n      osc.onended = () => {\n        try { osc.disconnect(); gain.disconnect(); } catch (e) { /* ignore */ }\n      };\n    } catch (e) {\n      console.warn(\"playBeep error:\", e);\n    }\n  }\n\n  function playCorrectSound() {\n    // Pleasant ascending arpeggio\n    if (!audioEnabled || !audioCtx) return;\n    resumeAudioIfNeeded();\n    const base = 660;\n    playBeep({ freq: base, type: \"sine\", duration: 0.12, volume: 0.12 });\n    setTimeout(() => playBeep({ freq: base * 1.25, type: \"triangle\", duration: 0.12, volume: 0.12 }), 120);\n    setTimeout(() => playBeep({ freq: base * 1.5, type: \"sawtooth\", duration: 0.18, volume: 0.14 }), 240);\n  }\n\n  function playIncorrectSound() {\n    if (!audioEnabled || !audioCtx) return;\n    resumeAudioIfNeeded();\n    // Low \"buzz\" then small click\n    playBeep({ freq: 180, type: \"sawtooth\", duration: 0.22, volume: 0.12 });\n    setTimeout(() => playBeep({ freq: 120, type: \"square\", duration: 0.12, volume: 0.10 }), 210);\n  }\n\n  // Game state\n  let state = \"start\"; // start, playing, win, gameover\n  let score = 0;\n  let wrongCount = 0;\n  let question = null;\n  let options = [];\n  let selectedOption = -1; // index 0-3 for keyboard selection\n  let hoverOption = -1;\n  let questionStartTime = 0;\n  let droneX = WIDTH / 2;\n  let droneY = HEIGHT / 2 - 40;\n  let droneBob = 0;\n  let lastTime = performance.now();\n\n  // Layout positions\n  const scoreBox = { x: UI_PADDING, y: UI_PADDING, w: 0, h: 40 };\n  const livesBox = { x: 0, y: UI_PADDING, w: 0, h: 40 }; // x set later to top-right\n  const questionBox = { x: 0, y: 70, w: WIDTH, h: 60 };\n  const optionsArea = { x: 60, y: 150, w: WIDTH - 120, h: 260 };\n  const instructionsBox = { x: 0, y: HEIGHT - 80, w: WIDTH, h: 70 };\n\n  // Option hitboxes\n  const optionBoxes = []; // {x,y,w,h}\n\n  // Generate math question (age 7-9): addition/subtraction up to 20\n  function generateQuestion() {\n    const type = Math.random() < 0.6 ? \"add\" : \"sub\";\n    let a, b, correct;\n    if (type === \"add\") {\n      a = randInt(1, 12);\n      b = randInt(1, 12);\n      correct = a + b;\n    } else {\n      a = randInt(2, 18);\n      b = randInt(1, a - 1);\n      correct = a - b;\n    }\n    // Create three distractors reasonably close\n    const distractors = new Set();\n    while (distractors.size < 3) {\n      const delta = pick([-3, -2, -1, 1, 2, 3, 4]);\n      const val = correct + delta;\n      if (val >= 0 && val <= 30 && val !== correct) distractors.add(val);\n    }\n    const opts = [...distractors, correct];\n    // Shuffle\n    for (let i = opts.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [opts[i], opts[j]] = [opts[j], opts[i]];\n    }\n    question = { a, b, type, correct };\n    options = opts;\n    selectedOption = -1;\n    hoverOption = -1;\n    questionStartTime = performance.now();\n  }\n\n  // Drawing helpers\n  function safeFillText(text, x, y, font, color = \"#000\", align = \"left\", baseline = \"middle\") {\n    ctx.font = font;\n    ctx.fillStyle = color;\n    ctx.textAlign = align;\n    ctx.textBaseline = baseline;\n    ctx.fillText(text, x, y);\n  }\n\n  function drawRoundedRect(x, y, w, h, r = 8, fillStyle = \"#fff\", strokeStyle = null) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    if (fillStyle) {\n      ctx.fillStyle = fillStyle;\n      ctx.fill();\n    }\n    if (strokeStyle) {\n      ctx.strokeStyle = strokeStyle;\n      ctx.stroke();\n    }\n  }\n\n  // Draw a fun wacky drone at droneX, droneY\n  function drawDrone(t) {\n    const x = droneX;\n    const y = droneY + Math.sin(t / 300) * 6; // bob\n    // Body\n    ctx.save();\n    ctx.translate(x, y);\n    // shadow\n    ctx.beginPath();\n    ctx.ellipse(0, 42, 46, 16, 0, 0, Math.PI * 2);\n    ctx.fillStyle = \"rgba(0,0,0,0.12)\";\n    ctx.fill();\n    // body\n    drawRoundedRect(-48, -18, 96, 44, 14, \"#E3F6FF\", \"#1E90FF\");\n    // window\n    ctx.beginPath();\n    ctx.ellipse(0, -2, 26, 18, 0, 0, Math.PI * 2);\n    ctx.fillStyle = \"#BEEBFF\";\n    ctx.fill();\n    ctx.strokeStyle = \"rgba(0,0,0,0.08)\";\n    ctx.stroke();\n    // propellers with wacky arms\n    const armAngle = Math.sin(t / 150) * 0.12;\n    for (let i = -1; i <= 1; i += 2) {\n      ctx.save();\n      ctx.translate(i * 56, -8);\n      ctx.rotate(armAngle * i);\n      ctx.fillStyle = \"#D8F3FF\";\n      ctx.fillRect(-4, -4, 40, 8);\n      // propeller blades\n      ctx.beginPath();\n      ctx.ellipse(26, 0, 14, 4, 0, 0, Math.PI * 2);\n      ctx.fillStyle = \"rgba(0,0,0,0.06)\";\n      ctx.fill();\n      ctx.restore();\n    }\n    // silly antenna\n    ctx.beginPath();\n    ctx.moveTo(20, -22);\n    ctx.quadraticCurveTo(30, -36, 10, -44);\n    ctx.strokeStyle = \"#2b2b2b\";\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.arc(10, -44, 6, 0, Math.PI * 2);\n    ctx.fillStyle = \"#FFD166\";\n    ctx.fill();\n    ctx.restore();\n  }\n\n  // Draw calming sky background with clouds\n  function drawBackground(t) {\n    // gradient sky\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, \"#F0FBFF\");\n    g.addColorStop(1, \"#E6F7FF\");\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    // gentle hills\n    ctx.fillStyle = \"#EAFBF4\";\n    ctx.beginPath();\n    ctx.moveTo(0, HEIGHT);\n    ctx.quadraticCurveTo(WIDTH * 0.25, HEIGHT - 120 - Math.sin(t / 1200) * 8, WIDTH * 0.5, HEIGHT - 60);\n    ctx.quadraticCurveTo(WIDTH * 0.75, HEIGHT - 20 + Math.cos(t / 900) * 8, WIDTH, HEIGHT - 80);\n    ctx.lineTo(WIDTH, HEIGHT);\n    ctx.closePath();\n    ctx.fill();\n\n    // clouds\n    for (let i = 0; i < 5; i++) {\n      const cx = (i * 200 + (t / 6)) % (WIDTH + 160) - 80;\n      const cy = 60 + (i % 2) * 20 + Math.sin((t / 500) + i) * 6;\n      ctx.beginPath();\n      ctx.fillStyle = \"rgba(255,255,255,0.9)\";\n      ctx.ellipse(cx, cy, 40, 18, 0, 0, Math.PI * 2);\n      ctx.ellipse(cx - 28, cy + 6, 28, 12, 0, 0, Math.PI * 2);\n      ctx.ellipse(cx + 26, cy + 6, 30, 12, 0, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n\n  // Draw UI layout ensuring no overlapping using measureText\n  function drawUI(t) {\n    ctx.save();\n    // Score box top-left\n    ctx.font = IMPORTANT_FONT;\n    const scoreText = `Score: ${score}/${REQUIRED_CORRECT}`;\n    const scoreW = ctx.measureText(scoreText).width + UI_PADDING * 3;\n    scoreBox.w = clamp(scoreW, 80, 200);\n    scoreBox.h = 44;\n    drawRoundedRect(scoreBox.x, scoreBox.y, scoreBox.w, scoreBox.h, 8, \"#FFFFFFAA\", \"#1E90FF\");\n    safeFillText(scoreText, scoreBox.x + 12, scoreBox.y + scoreBox.h / 2, IMPORTANT_FONT, \"#1E2A78\");\n\n    // Lives top-right\n    ctx.font = IMPORTANT_FONT;\n    const livesText = `Lives: ${MAX_WRONG - wrongCount}`;\n    const livesW = ctx.measureText(livesText).width + UI_PADDING * 3;\n    livesBox.w = clamp(livesW, 100, 200);\n    livesBox.h = 44;\n    livesBox.x = WIDTH - livesBox.w - UI_PADDING;\n    drawRoundedRect(livesBox.x, livesBox.y, livesBox.w, livesBox.h, 8, \"#FFF2F2\", \"#D43F3F\");\n    safeFillText(livesText, livesBox.x + 12, livesBox.y + livesBox.h / 2, IMPORTANT_FONT, \"#8B0000\");\n\n    // Progress bar under top area\n    const progX = scoreBox.x + scoreBox.w + UI_PADDING;\n    const progW = livesBox.x - progX - UI_PADDING;\n    if (progW > 60) {\n      const progY = scoreBox.y + (scoreBox.h - 16) / 2;\n      ctx.fillStyle = \"#FFFFFFCC\";\n      ctx.fillRect(progX, progY, progW, 16);\n      ctx.fillStyle = \"#70C1B3\";\n      const fraction = score / REQUIRED_CORRECT;\n      ctx.fillRect(progX, progY, Math.max(6, progW * fraction), 16);\n      safeFillText(`Progress`, progX + 6, progY + 8, BODY_FONT, \"#133B2A\", \"left\", \"middle\");\n    }\n\n    // Question in center top\n    ctx.font = TITLE_FONT;\n    const qText = question ? (question.type === \"add\" ? `${question.a} + ${question.b} = ?` : `${question.a} - ${question.b} = ?`) : \"Ready?\";\n    const qW = ctx.measureText(qText).width;\n    const qBoxW = qW + 32;\n    questionBox.x = (WIDTH - qBoxW) / 2;\n    questionBox.w = qBoxW;\n    questionBox.h = 60;\n    drawRoundedRect(questionBox.x, questionBox.y, questionBox.w, questionBox.h, 10, \"#FFFFFFCC\", \"#0B5E6F\");\n    safeFillText(qText, questionBox.x + questionBox.w / 2, questionBox.y + questionBox.h / 2, TITLE_FONT, \"#003E4D\", \"center\");\n\n    // Options area background\n    drawRoundedRect(optionsArea.x - 10, optionsArea.y - 10, optionsArea.w + 20, optionsArea.h + 20, 14, \"#FFFFFFEE\", \"#91C7B1\");\n\n    // Draw options as landing pads in a grid 2x2\n    optionBoxes.length = 0;\n    const rows = 2, cols = 2;\n    const padW = (optionsArea.w - (cols - 1) * 20) / cols;\n    const padH = (optionsArea.h - (rows - 1) * 20) / rows;\n    ctx.font = OPTION_FONT;\n    for (let r = 0; r < rows; r++) {\n      for (let c = 0; c < cols; c++) {\n        const idx = r * cols + c;\n        const ox = optionsArea.x + c * (padW + 20);\n        const oy = optionsArea.y + r * (padH + 20);\n        const bx = ox;\n        const by = oy;\n        const bw = padW;\n        const bh = padH;\n        let fillColor = \"#F7FFF7\";\n        let strokeColor = \"#3A7D44\";\n        if (idx === hoverOption) {\n          fillColor = \"#FFF8E1\";\n          strokeColor = \"#E9A800\";\n        } else if (idx === selectedOption) {\n          fillColor = \"#E8F6FF\";\n          strokeColor = \"#146C94\";\n        }\n        drawRoundedRect(bx, by, bw, bh, 12, fillColor, strokeColor);\n        // Labeling option with number for keyboard (1-4)\n        const label = `${idx + 1}. ${options[idx] !== undefined ? options[idx] : \"\"}`;\n        // Ensure text fits\n        let fontToUse = OPTION_FONT;\n        ctx.font = fontToUse;\n        let textWidth = ctx.measureText(label).width;\n        if (textWidth > bw - 24) {\n          // reduce font\n          fontToUse = \"18px sans-serif\";\n          ctx.font = fontToUse;\n          textWidth = ctx.measureText(label).width;\n        }\n        // Draw number badge\n        const badgeW = 36;\n        drawRoundedRect(bx + 10, by + 10, badgeW, 28, 8, \"#1E90FF\", \"#0F4C81\");\n        safeFillText(`${idx + 1}`, bx + 10 + badgeW / 2, by + 10 + 14, \"18px sans-serif\", \"#FFF\", \"center\");\n        // Draw option number\n        safeFillText(label, bx + 10 + badgeW + 12, by + bh / 2, fontToUse, \"#05386B\", \"left\");\n        optionBoxes.push({ x: bx, y: by, w: bw, h: bh });\n      }\n    }\n\n    // Draw mini speaker audio indicator bottom-left\n    const audioText = audioEnabled ? \"Audio: ON (M)\" : \"Audio: OFF (M)\";\n    ctx.font = BODY_FONT;\n    const atW = ctx.measureText(audioText).width + 20;\n    const aBoxX = UI_PADDING;\n    const aBoxY = HEIGHT - 120;\n    drawRoundedRect(aBoxX, aBoxY, atW, 36, 8, \"#FFFFFFDD\", \"#666\");\n    safeFillText(audioText, aBoxX + 12, aBoxY + 18, BODY_FONT, \"#333\");\n\n    // Instructions bottom-center\n    ctx.font = BODY_FONT;\n    const instrLines = [\n      \"Controls: Click an option or press 1-4 to pick. Use \u2190 \u2192 to change selection, Enter or Space to confirm.\",\n      \"Goal: Answer 10 questions correctly. You can make 3 mistakes. Press R to restart at any time.\",\n    ];\n    const instrPadding = 12;\n    // Measure maximum width\n    let maxW = 0;\n    instrLines.forEach(line => {\n      const w = ctx.measureText(line).width;\n      if (w > maxW) maxW = w;\n    });\n    const instrW = maxW + instrPadding * 2;\n    instructionsBox.w = instrW;\n    instructionsBox.x = (WIDTH - instrW) / 2;\n    drawRoundedRect(instructionsBox.x, instructionsBox.y, instructionsBox.w, instructionsBox.h, 10, \"#FFFFFFCC\", \"#264653\");\n    ctx.fillStyle = \"#071B2F\";\n    for (let i = 0; i < instrLines.length; i++) {\n      safeFillText(instrLines[i], instructionsBox.x + instructionsBox.w / 2, instructionsBox.y + 16 + i * 20, BODY_FONT, \"#073B4C\", \"center\", \"top\");\n    }\n\n    ctx.restore();\n  }\n\n  // Draw overlay screens\n  function drawStartScreen() {\n    // translucent overlay\n    ctx.fillStyle = \"rgba(0,0,0,0.25)\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    // title\n    drawRoundedRect(80, 80, WIDTH - 160, HEIGHT - 160, 14, \"#FFFFFFEE\", \"#0B5E6F\");\n    safeFillText(\"Drone Math Adventure!\", WIDTH / 2, 130, TITLE_FONT, \"#083D77\", \"center\");\n    ctx.font = IMPORTANT_FONT;\n    const desc = \"Fly your friendly drone to pick the correct answers to math puzzles!\";\n    const w = ctx.measureText(desc).width;\n    safeFillText(desc, WIDTH / 2, 170, BODY_FONT, \"#0B5E6F\", \"center\");\n    // start button\n    const btnW = 220, btnH = 48;\n    const bx = WIDTH / 2 - btnW / 2, by = HEIGHT / 2 - 20;\n    drawRoundedRect(bx, by, btnW, btnH, 10, \"#70C1B3\", \"#167F6B\");\n    safeFillText(\"Start Game (Enter)\", bx + btnW / 2, by + btnH / 2, IMPORTANT_FONT, \"#052B2A\", \"center\");\n    // small help\n    ctx.font = BODY_FONT;\n    safeFillText(\"Hint: Use number keys 1-4 for quick answers. Press M to toggle audio.\", WIDTH / 2, by + btnH + 36, BODY_FONT, \"#083D77\", \"center\");\n  }\n\n  function drawWinScreen() {\n    ctx.fillStyle = \"rgba(255,255,255,0.9)\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    safeFillText(\"You did it!\", WIDTH / 2, 120, TITLE_FONT, \"#0B5E6F\", \"center\");\n    safeFillText(`Correct answers: ${score}`, WIDTH / 2, 160, IMPORTANT_FONT, \"#0B5E6F\", \"center\");\n    // confetti doodles\n    for (let i = 0; i < 28; i++) {\n      const x = Math.random() * WIDTH;\n      const y = 210 + Math.random() * 180;\n      ctx.fillStyle = `hsl(${Math.floor(Math.random() * 360)}, 80%, 60%)`;\n      ctx.fillRect(x, y, 6, 6);\n    }\n    // victory drone larger\n    ctx.save();\n    ctx.translate(WIDTH / 2, 250);\n    drawDrone(performance.now());\n    ctx.restore();\n    // Restart button\n    const btnW = 200, btnH = 46;\n    const bx = WIDTH / 2 - btnW / 2, by = HEIGHT - 120;\n    drawRoundedRect(bx, by, btnW, btnH, 10, \"#FDE68A\", \"#D97706\");\n    safeFillText(\"Play Again (R)\", bx + btnW / 2, by + btnH / 2, IMPORTANT_FONT, \"#5B3E02\", \"center\");\n  }\n\n  function drawGameOverScreen() {\n    // smoky overlay\n    ctx.fillStyle = \"rgba(0,0,0,0.55)\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    drawRoundedRect(80, 80, WIDTH - 160, HEIGHT - 160, 14, \"#FFF5F5\", \"#8B0000\");\n    safeFillText(\"Game Over\", WIDTH / 2, 130, TITLE_FONT, \"#8B0000\", \"center\");\n    safeFillText(`You answered ${score} correctly.`, WIDTH / 2, 170, IMPORTANT_FONT, \"#641E16\", \"center\");\n    // broken drone\n    ctx.save();\n    ctx.translate(WIDTH / 2, 260);\n    ctx.rotate(-0.05);\n    // broken body\n    drawRoundedRect(-60, -20, 120, 40, 10, \"#FFECEC\", \"#C53030\");\n    // cracked window\n    ctx.beginPath();\n    ctx.arc(10, -2, 20, 0, Math.PI * 2);\n    ctx.fillStyle = \"#FFFBF0\";\n    ctx.fill();\n    ctx.strokeStyle = \"#C53030\";\n    ctx.beginPath();\n    ctx.moveTo(0, -8);\n    ctx.lineTo(18, 2);\n    ctx.moveTo(6, -12);\n    ctx.lineTo(6, 8);\n    ctx.stroke();\n    ctx.restore();\n    // Restart button\n    const btnW = 200, btnH = 46;\n    const bx = WIDTH / 2 - btnW / 2, by = HEIGHT - 120;\n    drawRoundedRect(bx, by, btnW, btnH, 10, \"#FFB4B4\", \"#9B1C1C\");\n    safeFillText(\"Try Again (R)\", bx + btnW / 2, by + btnH / 2, IMPORTANT_FONT, \"#6E0F0F\", \"center\");\n  }\n\n  // Click/interaction handlers\n  function getOptionIndexAt(x, y) {\n    for (let i = 0; i < optionBoxes.length; i++) {\n      const b = optionBoxes[i];\n      if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) return i;\n    }\n    return -1;\n  }\n\n  function handleClick(x, y) {\n    if (state === \"start\") {\n      // Check start button area\n      const bx = WIDTH / 2 - 110, by = HEIGHT / 2 - 20, bw = 220, bh = 48;\n      if (x >= bx && x <= bx + bw && y >= by && y <= by + bh) {\n        startGame();\n      }\n    } else if (state === \"playing\") {\n      // Check options\n      const idx = getOptionIndexAt(x, y);\n      if (idx >= 0) {\n        selectedOption = idx;\n        confirmSelection();\n        return;\n      }\n      // Check audio toggle area\n      const aBoxX = UI_PADDING, aBoxY = HEIGHT - 120, aBoxW = ctx.measureText(audioEnabled ? \"Audio: ON (M)\" : \"Audio: OFF (M)\").width + 20, aBoxH = 36;\n      if (x >= aBoxX && x <= aBoxX + aBoxW && y >= aBoxY && y <= aBoxY + aBoxH) {\n        toggleAudio();\n        return;\n      }\n    } else if (state === \"win\" || state === \"gameover\") {\n      // Restart button\n      const bx = WIDTH / 2 - 100, by = HEIGHT - 120, bw = 200, bh = 46;\n      if (x >= bx && x <= bx + bw && y >= by && y <= by + bh) {\n        restartGame();\n      }\n    }\n  }\n\n  // Confirm selection (evaluation)\n  function confirmSelection() {\n    if (state !== \"playing\") return;\n    if (selectedOption < 0 || selectedOption >= options.length) return;\n    const chosen = options[selectedOption];\n    if (chosen === question.correct) {\n      score++;\n      playCorrectSound();\n      // small celebration: animate drone upward briefly\n      droneY -= 8;\n      if (score >= REQUIRED_CORRECT) {\n        state = \"win\";\n        // stop ambient if wanted but keep audio\n      } else {\n        // next question after short delay\n        setTimeout(() => {\n          generateQuestion();\n        }, 600);\n      }\n    } else {\n      wrongCount++;\n      playIncorrectSound();\n      // shake drone\n      droneX += (Math.random() - 0.5) * 12;\n      if (wrongCount >= MAX_WRONG) {\n        state = \"gameover\";\n      } else {\n        // show a hint bubble maybe\n        setTimeout(() => {\n          generateQuestion();\n        }, 600);\n      }\n    }\n  }\n\n  // Keyboard handling\n  canvas.addEventListener(\"keydown\", (e) => {\n    // Ensure audio resume first user gesture\n    resumeAudioIfNeeded();\n    if (e.key === \"r\" || e.key === \"R\") {\n      restartGame();\n      e.preventDefault();\n      return;\n    }\n    if (e.key === \"m\" || e.key === \"M\") {\n      toggleAudio();\n      e.preventDefault();\n      return;\n    }\n    if (state === \"start\") {\n      if (e.key === \"Enter\" || e.key === \" \") {\n        startGame();\n        e.preventDefault();\n      }\n      return;\n    }\n    if (state === \"playing\") {\n      if (e.key >= \"1\" && e.key <= \"4\") {\n        const idx = parseInt(e.key, 10) - 1;\n        if (idx < options.length) {\n          selectedOption = idx;\n          confirmSelection();\n        }\n        e.preventDefault();\n        return;\n      }\n      if (e.key === \"ArrowLeft\" || e.key === \"ArrowUp\") {\n        // move selection left/up\n        if (selectedOption === -1) selectedOption = 0;\n        else selectedOption = (selectedOption + options.length - 1) % options.length;\n        e.preventDefault();\n        return;\n      }\n      if (e.key === \"ArrowRight\" || e.key === \"ArrowDown\") {\n        if (selectedOption === -1) selectedOption = 0;\n        else selectedOption = (selectedOption + 1) % options.length;\n        e.preventDefault();\n        return;\n      }\n      if (e.key === \"Enter\" || e.key === \" \") {\n        if (selectedOption >= 0) confirmSelection();\n        e.preventDefault();\n        return;\n      }\n    }\n    if (state === \"win\" || state === \"gameover\") {\n      if (e.key === \"r\" || e.key === \"R\" || e.key === \"Enter\") {\n        restartGame();\n        e.preventDefault();\n      }\n    }\n  });\n\n  // Mouse events\n  canvas.addEventListener(\"mousedown\", (ev) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = (ev.clientX - rect.left) * (canvas.width / rect.width);\n    const y = (ev.clientY - rect.top) * (canvas.height / rect.height);\n    handleClick(x, y);\n  });\n\n  canvas.addEventListener(\"mousemove\", (ev) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = (ev.clientX - rect.left) * (canvas.width / rect.width);\n    const y = (ev.clientY - rect.top) * (canvas.height / rect.height);\n    // track hover\n    const idx = getOptionIndexAt(x, y);\n    if (idx !== hoverOption) {\n      hoverOption = idx;\n    }\n  });\n\n  // Toggle audio\n  function toggleAudio() {\n    if (!audioCtx) {\n      audioEnabled = false;\n      return;\n    }\n    audioEnabled = !audioEnabled;\n    if (!audioEnabled) {\n      try { masterGain.gain.setValueAtTime(0, audioCtx.currentTime); } catch (e) { /* ignore */ }\n    } else {\n      try { masterGain.gain.setValueAtTime(0.9, audioCtx.currentTime); resumeAudioIfNeeded(); } catch (e) { /* ignore */ }\n    }\n  }\n\n  // Start and restart\n  function startGame() {\n    score = 0;\n    wrongCount = 0;\n    state = \"playing\";\n    generateQuestion();\n    // set drone starting position\n    droneX = WIDTH / 2;\n    droneY = HEIGHT / 2 - 40;\n    lastTime = performance.now();\n    resumeAudioIfNeeded();\n  }\n\n  function restartGame() {\n    // Reset audio resume gesture\n    if (audioCtx && audioCtx.state === \"suspended\") resumeAudioIfNeeded();\n    score = 0;\n    wrongCount = 0;\n    selectedOption = -1;\n    hoverOption = -1;\n    state = \"start\";\n  }\n\n  // Initialize\n  restartGame();\n\n  // Main loop\n  function loop(now) {\n    const dt = now - lastTime;\n    lastTime = now;\n    // Update drone drift towards selected option visually for fun\n    if (state === \"playing\") {\n      // Slight aim towards hovered option to encourage clicking\n      if (hoverOption >= 0 && optionBoxes[hoverOption]) {\n        const b = optionBoxes[hoverOption];\n        const targetX = b.x + b.w / 2;\n        const targetY = b.y - 20;\n        droneX += (targetX - droneX) * 0.04;\n        droneY += (targetY - droneY) * 0.03;\n      } else {\n        // drift to center\n        droneX += (WIDTH / 2 - droneX) * 0.02;\n        droneY += ((HEIGHT / 2 - 40) - droneY) * 0.02;\n      }\n    } else {\n      // idle bob at center\n      droneX += (WIDTH / 2 - droneX) * 0.05;\n      droneY += ((HEIGHT / 2 - 40) - droneY) * 0.05;\n    }\n\n    // Draw frame\n    drawBackground(now);\n    drawUI(now);\n    // draw drone on top\n    drawDrone(now);\n\n    // State overlays\n    if (state === \"start\") {\n      drawStartScreen();\n    } else if (state === \"win\") {\n      drawWinScreen();\n    } else if (state === \"gameover\") {\n      drawGameOverScreen();\n    }\n\n    // Visual cues for audio state: small border change if audio disabled\n    ctx.save();\n    if (!audioEnabled) {\n      ctx.strokeStyle = \"#FF6B6B\";\n      ctx.lineWidth = 4;\n      ctx.strokeRect(6, 6, WIDTH - 12, HEIGHT - 12);\n      // small text\n      ctx.font = BODY_FONT;\n      safeFillText(\"Audio disabled\", WIDTH - 100, HEIGHT - 20, BODY_FONT, \"#FF6B6B\");\n    }\n    ctx.restore();\n\n    // Ensure text elements do not overlap: minimal checks\n    // (We placed elements with padding and used measureText to size boxes.)\n    // Next frame\n    requestAnimationFrame(loop);\n  }\n\n  requestAnimationFrame(loop);\n\n  // Expose some stuff to console for debugging (non-essential)\n  window.__droneMathGame = {\n    restartGame,\n    startGame,\n    toggleAudio,\n    getState: () => ({ state, score, wrongCount }),\n  };\n})();\n---\n",
  "improve_response_tokens": 19419,
  "formatted_code": true,
  "formatting_response_tokens": 21796,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}