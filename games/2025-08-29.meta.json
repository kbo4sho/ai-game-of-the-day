{
  "generated_date": "2025-08-29",
  "generated_timestamp": "2025-08-29T00:27:11.839064",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 9989,
  "game_filename": "2025-08-29.js",
  "game_size_bytes": 30229,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function() {\n  // Machine Math \u2014 a calming, wacky math game for ages 7-9\n  // Renders inside the element with ID \"game-of-the-day-stage\".\n  // All visuals drawn to canvas. All sounds generated with Web Audio API.\n  // Controls: Left/Right to move selection, Up/Down to change values, Enter to process,\n  // Space to toggle values/ops, M to mute/unmute. Click/tap also supported.\n  // Accessible live region included for screen readers.\n\n  // -----------------------\n  // Setup container & canvas\n  // -----------------------\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Error: container element with id \"game-of-the-day-stage\" not found.');\n    return;\n  }\n  container.style.position = 'relative';\n  container.style.userSelect = 'none';\n  container.setAttribute('tabindex', '0'); // make focusable for keyboard\n\n  // Clean container\n  container.innerHTML = '';\n\n  // Create an offscreen (visually hidden) live region for accessibility\n  const liveRegion = document.createElement('div');\n  liveRegion.setAttribute('role', 'status');\n  liveRegion.setAttribute('aria-live', 'polite');\n  liveRegion.style.position = 'absolute';\n  liveRegion.style.left = '-9999px';\n  liveRegion.style.width = '1px';\n  liveRegion.style.height = '1px';\n  liveRegion.style.overflow = 'hidden';\n  container.appendChild(liveRegion);\n\n  // Canvas creation\n  const canvas = document.createElement('canvas');\n  canvas.width = 720;\n  canvas.height = 480;\n  canvas.style.width = '720px';\n  canvas.style.height = '480px';\n  canvas.style.display = 'block';\n  canvas.style.outline = 'none';\n  canvas.setAttribute('aria-label', 'Machine Math game canvas');\n  container.appendChild(canvas);\n  const ctx = canvas.getContext('2d');\n\n  // Focus container for keyboard events\n  container.focus();\n\n  // -----------------------\n  // Utility functions\n  // -----------------------\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  function clamp(v, a, b) {\n    return Math.max(a, Math.min(b, v));\n  }\n\n  function safeText(s) {\n    return String(s);\n  }\n\n  // -----------------------\n  // Audio Manager\n  // -----------------------\n  class AudioManager {\n    constructor() {\n      this.enabled = true;\n      this.available = false;\n      this.ctx = null;\n      this.master = null;\n      this.bgGain = null;\n      this.bgOsc = null;\n      this.lfo = null;\n      this.lfoGain = null;\n      this.initPromise = this.init();\n    }\n\n    async init() {\n      try {\n        const AudioCtx = window.AudioContext || window.webkitAudioContext;\n        if (!AudioCtx) throw new Error('Web Audio API not supported');\n\n        this.ctx = new AudioCtx();\n        this.master = this.ctx.createGain();\n        this.master.gain.value = 0.9;\n        this.master.connect(this.ctx.destination);\n\n        // Background hum: gentle triangle/sine with lowpass\n        this.bgGain = this.ctx.createGain();\n        this.bgGain.gain.value = 0.02;\n        this.bgGain.connect(this.master);\n\n        this.bgOsc = this.ctx.createOscillator();\n        this.bgOsc.type = 'sine';\n        this.bgOsc.frequency.value = 110; // low hum\n        this.bgOsc.connect(this.bgGain);\n\n        // subtle movement with LFO\n        this.lfo = this.ctx.createOscillator();\n        this.lfo.type = 'sine';\n        this.lfo.frequency.value = 0.05;\n        this.lfoGain = this.ctx.createGain();\n        this.lfoGain.gain.value = 8; // modulate frequency slightly\n        this.lfo.connect(this.lfoGain);\n        this.lfoGain.connect(this.bgOsc.frequency);\n\n        // start if allowed; might require user gesture to resume later\n        try {\n          this.bgOsc.start();\n          this.lfo.start();\n        } catch (e) {\n          // Some browsers may throw if not allowed to start yet.\n        }\n\n        this.available = true;\n        return true;\n      } catch (err) {\n        console.warn('Audio init failed:', err);\n        this.available = false;\n        return false;\n      }\n    }\n\n    async ensureStarted() {\n      if (!this.available) return false;\n      try {\n        if (this.ctx.state === 'suspended') {\n          await this.ctx.resume();\n        }\n        if (this.bgOsc && this.bgGain) {\n          this.bgGain.gain.setTargetAtTime(0.02, this.ctx.currentTime, 0.05);\n        }\n        return true;\n      } catch (err) {\n        console.warn('Audio resume failed:', err);\n        return false;\n      }\n    }\n\n    setMuted(muted) {\n      this.enabled = !muted;\n      if (this.master) {\n        this.master.gain.value = this.enabled ? 0.9 : 0;\n      }\n    }\n\n    // simple click sound\n    playClick() {\n      if (!this.available || !this.enabled) return;\n      try {\n        const o = this.ctx.createOscillator();\n        const g = this.ctx.createGain();\n        o.type = 'square';\n        o.frequency.value = 600;\n        g.gain.value = 0.0001;\n        o.connect(g);\n        g.connect(this.master);\n        const t = this.ctx.currentTime;\n        g.gain.setValueAtTime(0.0001, t);\n        g.gain.exponentialRampToValueAtTime(0.07, t + 0.02);\n        g.gain.exponentialRampToValueAtTime(0.0001, t + 0.18);\n        o.start(t);\n        o.stop(t + 0.2);\n      } catch (e) {\n        console.warn('playClick error', e);\n      }\n    }\n\n    // correct chime: ascending arpeggio\n    playCorrect() {\n      if (!this.available || !this.enabled) return;\n      try {\n        const now = this.ctx.currentTime;\n        const freqs = [440, 660, 880];\n        freqs.forEach((f, i) => {\n          const o = this.ctx.createOscillator();\n          const g = this.ctx.createGain();\n          o.type = 'sine';\n          o.frequency.value = f;\n          g.gain.value = 0.0001;\n          o.connect(g);\n          g.connect(this.master);\n          const t0 = now + i * 0.09;\n          g.gain.setValueAtTime(0.0001, t0);\n          g.gain.exponentialRampToValueAtTime(0.12, t0 + 0.06);\n          g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.26);\n          o.start(t0);\n          o.stop(t0 + 0.28);\n        });\n      } catch (e) {\n        console.warn('playCorrect error', e);\n      }\n    }\n\n    // wrong buzzer\n    playWrong() {\n      if (!this.available || !this.enabled) return;\n      try {\n        const o = this.ctx.createOscillator();\n        const g = this.ctx.createGain();\n        const f = this.ctx.createBiquadFilter();\n        o.type = 'sawtooth';\n        o.frequency.value = 200;\n        f.type = 'lowpass';\n        f.frequency.value = 900;\n        g.gain.value = 0.0001;\n        o.connect(f);\n        f.connect(g);\n        g.connect(this.master);\n        const now = this.ctx.currentTime;\n        g.gain.setValueAtTime(0.0001, now);\n        g.gain.exponentialRampToValueAtTime(0.12, now + 0.02);\n        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.45);\n        o.frequency.setValueAtTime(200, now);\n        o.frequency.linearRampToValueAtTime(80, now + 0.45);\n        o.start(now);\n        o.stop(now + 0.5);\n      } catch (e) {\n        console.warn('playWrong error', e);\n      }\n    }\n\n    // gentle whoosh for machine processing\n    playProcess() {\n      if (!this.available || !this.enabled) return;\n      try {\n        const now = this.ctx.currentTime;\n        const o = this.ctx.createOscillator();\n        const g = this.ctx.createGain();\n        const f = this.ctx.createBiquadFilter();\n        o.type = 'triangle';\n        o.frequency.value = 300;\n        f.type = 'lowpass';\n        f.frequency.value = 800;\n        o.connect(f);\n        f.connect(g);\n        g.connect(this.master);\n        g.gain.setValueAtTime(0.0001, now);\n        g.gain.linearRampToValueAtTime(0.09, now + 0.06);\n        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.8);\n        o.frequency.setValueAtTime(300, now);\n        o.frequency.exponentialRampToValueAtTime(80, now + 0.8);\n        o.start(now);\n        o.stop(now + 0.9);\n      } catch (e) {\n        console.warn('playProcess error', e);\n      }\n    }\n  }\n\n  const audio = new AudioManager();\n\n  // -----------------------\n  // Game logic\n  // -----------------------\n  const OPS = ['+', '-', '\u00d7']; // multiplication shown as \u00d7\n  function applyOp(a, op, b) {\n    if (op === '+') return a + b;\n    if (op === '-') return a - b;\n    if (op === '\u00d7') return a * b;\n    return a;\n  }\n\n  class MachineGame {\n    constructor(ctx, canvas, audio, liveRegion) {\n      this.ctx = ctx;\n      this.canvas = canvas;\n      this.audio = audio;\n      this.liveRegion = liveRegion;\n\n      // game state\n      this.numbers = [1, 2, 3];\n      this.ops = ['+', '+'];\n      this.target = 0;\n      this.attempts = 0;\n      this.maxAttempts = 4;\n      this.round = 0;\n      this.totalRounds = 6;\n      this.solvedCount = 0;\n      this.selectionIndex = 0; // 0..4 mapping: 0 gear0,1 op0,2 gear1,3 op1,4 gear2\n      this.animationTime = 0;\n      this.running = true;\n      this.muted = false;\n\n      // visual elements\n      this.gearAngle = 0;\n      this.particles = [];\n      this.confetti = [];\n\n      // initialize first round\n      this.newRound();\n\n      // input handlers\n      this.setupInput();\n\n      // start animation loop\n      this.lastTime = performance.now();\n      this.rafId = requestAnimationFrame((t) => this.frame(t));\n    }\n\n    newRound() {\n      this.round++;\n      if (this.round > this.totalRounds) {\n        // done; show summary\n        this.endGame();\n        return;\n      }\n      // generate numbers 1..9 and a solution ops, then set target accordingly\n      // Keep numbers simple for ages 7-9 by using 1..9 small numbers\n      this.numbers = [randInt(1, 9), randInt(1, 9), randInt(1, 9)];\n\n      // pick a random pair of ops as the solution\n      const solutionOps = [OPS[randInt(0, OPS.length - 1)], OPS[randInt(0, OPS.length - 1)]];\n\n      // compute target by applying left-to-right\n      let value = applyOp(this.numbers[0], solutionOps[0], this.numbers[1]);\n      value = applyOp(value, solutionOps[1], this.numbers[2]);\n      this.target = value;\n\n      // display initial ops scrambled (random) so player must find solution\n      this.ops = [OPS[randInt(0, OPS.length - 1)], OPS[randInt(0, OPS.length - 1)]];\n\n      // reset attempts\n      this.attempts = 0;\n      this.selectionIndex = 0;\n      this.addLive(`Round ${this.round} of ${this.totalRounds}. Target ${this.target}. Use arrows or click to set operations and numbers. Press Enter to process.`);\n    }\n\n    endGame() {\n      this.running = false;\n      // stop animation and show final screen (but still allow restart)\n      this.addLive(`Game complete. You solved ${this.solvedCount} out of ${this.totalRounds} puzzles.`);\n    }\n\n    addLive(text) {\n      try {\n        this.liveRegion.textContent = text;\n      } catch (e) {\n        // ignore\n      }\n    }\n\n    setupInput() {\n      // keyboard\n      this.keyDownHandler = (e) => {\n        // ensure audio context is started on first user interaction\n        if (this.audio && this.audio.available) {\n          this.audio.ensureStarted().catch(() => {});\n        }\n        if (!this.running) {\n          // allow restart with Enter\n          if (e.key === 'Enter') {\n            this.restart();\n          }\n          return;\n        }\n\n        if (e.key === 'ArrowLeft') {\n          this.selectionIndex = clamp(this.selectionIndex - 1, 0, 4);\n          this.audio.playClick();\n          e.preventDefault();\n        } else if (e.key === 'ArrowRight') {\n          this.selectionIndex = clamp(this.selectionIndex + 1, 0, 4);\n          this.audio.playClick();\n          e.preventDefault();\n        } else if (e.key === 'ArrowUp') {\n          this.changeSelected(1);\n          e.preventDefault();\n        } else if (e.key === 'ArrowDown') {\n          this.changeSelected(-1);\n          e.preventDefault();\n        } else if (e.key === ' ' || e.key === 'Spacebar') {\n          // toggle or quick rotate (space)\n          this.toggleSelected();\n          e.preventDefault();\n        } else if (e.key === 'Enter') {\n          this.processMachine();\n          e.preventDefault();\n        } else if (e.key.toLowerCase() === 'm') {\n          this.toggleMute();\n          e.preventDefault();\n        }\n      };\n      container.addEventListener('keydown', this.keyDownHandler);\n\n      // mouse / touch\n      this.canvas.addEventListener('pointerdown', (e) => {\n        const rect = this.canvas.getBoundingClientRect();\n        const x = (e.clientX - rect.left) * (this.canvas.width / rect.width);\n        const y = (e.clientY - rect.top) * (this.canvas.height / rect.height);\n        this.handlePointer(x, y);\n        // start audio context on interaction\n        if (this.audio && this.audio.available) {\n          this.audio.ensureStarted().catch(() => {});\n        }\n      });\n    }\n\n    restart() {\n      // reset stats\n      this.round = 0;\n      this.solvedCount = 0;\n      this.running = true;\n      this.newRound();\n      this.lastTime = performance.now();\n      this.rafId = requestAnimationFrame((t) => this.frame(t));\n    }\n\n    toggleMute() {\n      this.muted = !this.muted;\n      this.audio.setMuted(this.muted);\n      this.addLive(this.muted ? 'Sound muted.' : 'Sound unmuted.');\n    }\n\n    changeSelected(delta) {\n      if (!this.running) return;\n      if (this.selectionIndex % 2 === 0) {\n        // gear selected: change number\n        const gearIndex = this.selectionIndex / 2;\n        this.numbers[gearIndex] = clamp(this.numbers[gearIndex] + delta, 1, 12);\n        this.audio.playClick();\n      } else {\n        // op selected: cycle through OPS\n        const opIndex = Math.floor(this.selectionIndex / 2);\n        const currentIndex = OPS.indexOf(this.ops[opIndex]);\n        const nextIndex = (currentIndex + (delta > 0 ? 1 : OPS.length - 1)) % OPS.length;\n        this.ops[opIndex] = OPS[nextIndex];\n        this.audio.playClick();\n      }\n      this.addLive(`Selected ${this.describeSelection()}. Numbers: ${this.numbers.join(', ')}. Operations: ${this.ops.join(', ')}.`);\n    }\n\n    toggleSelected() {\n      if (!this.running) return;\n      // a quick toggle for numbers and ops\n      if (this.selectionIndex % 2 === 0) {\n        // set to random number for fun\n        const gearIndex = this.selectionIndex / 2;\n        this.numbers[gearIndex] = randInt(1, 9);\n        this.audio.playClick();\n      } else {\n        const opIndex = Math.floor(this.selectionIndex / 2);\n        const i = OPS.indexOf(this.ops[opIndex]);\n        this.ops[opIndex] = OPS[(i + 1) % OPS.length];\n        this.audio.playClick();\n      }\n      this.addLive(`Selected ${this.describeSelection()}.`);\n    }\n\n    describeSelection() {\n      if (this.selectionIndex % 2 === 0) {\n        return `gear ${this.selectionIndex / 2 + 1}`;\n      } else {\n        return `lever ${Math.floor(this.selectionIndex / 2) + 1}`;\n      }\n    }\n\n    handlePointer(x, y) {\n      // detect clicked element\n      // Machine layout: central horizontal band where gears and levers are centered\n      const cx = this.canvas.width / 2;\n      const cy = this.canvas.height / 2;\n      // positions for three gears\n      const gearX = [cx - 200, cx, cx + 200];\n      const gearY = cy - 20;\n      const gearR = 60;\n      // check gears\n      for (let i = 0; i < 3; i++) {\n        const dx = x - gearX[i];\n        const dy = y - gearY;\n        if (dx * dx + dy * dy <= gearR * gearR) {\n          // select this gear\n          this.selectionIndex = i * 2;\n          // change number on click\n          this.numbers[i] = (this.numbers[i] % 9) + 1;\n          this.audio.playClick();\n          this.addLive(`Changed gear ${i + 1} to ${this.numbers[i]}.`);\n          return;\n        }\n      }\n      // check levers (ops)\n      const leverX = [cx - 100, cx + 100];\n      const leverY = cy - 20;\n      const leverW = 80;\n      const leverH = 40;\n      for (let j = 0; j < 2; j++) {\n        const lx = leverX[j] - leverW / 2;\n        const ly = leverY - leverH / 2;\n        if (x >= lx && x <= lx + leverW && y >= ly && y <= ly + leverH) {\n          this.selectionIndex = j * 2 + 1;\n          // toggle op on click\n          const idx = OPS.indexOf(this.ops[j]);\n          this.ops[j] = OPS[(idx + 1) % OPS.length];\n          this.audio.playClick();\n          this.addLive(`Set lever ${j + 1} to ${this.ops[j]}.`);\n          return;\n        }\n      }\n      // check process button area (bottom)\n      const btnX = this.canvas.width / 2 - 80;\n      const btnY = this.canvas.height - 80;\n      const btnW = 160;\n      const btnH = 48;\n      if (x >= btnX && x <= btnX + btnW && y >= btnY && y <= btnY + btnH) {\n        this.processMachine();\n      }\n    }\n\n    processMachine() {\n      if (!this.running) return;\n      this.attempts++;\n      this.audio.playProcess();\n      // compute left-to-right\n      let v = applyOp(this.numbers[0], this.ops[0], this.numbers[1]);\n      v = applyOp(v, this.ops[1], this.numbers[2]);\n      if (v === this.target) {\n        // correct\n        this.solvedCount++;\n        this.addLive(`Correct! You reached ${v}. Great job!`);\n        this.audio.playCorrect();\n        this.spawnConfetti(30);\n        // short delay then next round\n        setTimeout(() => {\n          this.newRound();\n        }, 900);\n      } else {\n        // incorrect\n        this.audio.playWrong();\n        this.addLive(`Oops \u2014 result ${v} does not match target ${this.target}. Attempt ${this.attempts} of ${this.maxAttempts}.`);\n        // show hint after 2 attempts\n        if (this.attempts >= this.maxAttempts) {\n          // reveal solution and proceed to next\n          // compute an actual solution by brute-forcing ops\n          const sol = this.findSolution();\n          if (sol) {\n            this.addLive(`Here's a helpful hint: try ${this.numbers[0]} ${sol[0]} ${this.numbers[1]} ${sol[1]} ${this.numbers[2]} = ${this.target}. Moving to next round.`);\n            // animate gears for reveal\n            this.spawnParticles(20);\n            setTimeout(() => {\n              this.newRound();\n            }, 1400);\n          } else {\n            // Should not happen because we generated the target from a valid combination\n            this.addLive('No valid solution found (unexpected). Moving on.');\n            setTimeout(() => this.newRound(), 1000);\n          }\n        }\n      }\n    }\n\n    findSolution() {\n      for (const a of OPS) {\n        for (const b of OPS) {\n          let v = applyOp(this.numbers[0], a, this.numbers[1]);\n          v = applyOp(v, b, this.numbers[2]);\n          if (v === this.target) return [a, b];\n        }\n      }\n      return null;\n    }\n\n    spawnParticles(n) {\n      for (let i = 0; i < n; i++) {\n        this.particles.push({\n          x: this.canvas.width / 2 + randInt(-50, 50),\n          y: this.canvas.height / 2 + randInt(-30, 30),\n          vx: (Math.random() - 0.5) * 2,\n          vy: -Math.random() * 2 - 1,\n          life: randInt(40, 80),\n          color: `hsla(${randInt(160, 220)},50%,60%,0.9)`\n        });\n      }\n    }\n\n    spawnConfetti(n) {\n      for (let i = 0; i < n; i++) {\n        this.confetti.push({\n          x: this.canvas.width / 2 + randInt(-200, 200),\n          y: this.canvas.height / 2 - 60 + randInt(-20, 20),\n          vx: (Math.random() - 0.5) * 6,\n          vy: Math.random() * 3 + 1,\n          rot: Math.random() * Math.PI,\n          vr: (Math.random() - 0.5) * 0.2,\n          life: randInt(80, 180),\n          color: `hsla(${randInt(0, 360)},70%,60%,0.95)`\n        });\n      }\n    }\n\n    updateParticles() {\n      for (let p of this.particles) {\n        p.x += p.vx;\n        p.y += p.vy;\n        p.vy += 0.08;\n        p.life--;\n      }\n      this.particles = this.particles.filter(p => p.life > 0 && p.y < this.canvas.height + 50);\n\n      for (let c of this.confetti) {\n        c.x += c.vx;\n        c.y += c.vy;\n        c.vy += 0.05;\n        c.rot += c.vr;\n        c.life--;\n      }\n      this.confetti = this.confetti.filter(c => c.life > 0 && c.y < this.canvas.height + 50);\n    }\n\n    drawBackground() {\n      const g = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);\n      g.addColorStop(0, '#E8F6F3');\n      g.addColorStop(1, '#F8FBFF');\n      this.ctx.fillStyle = g;\n      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n      // soft cloud blobs\n      for (let i = 0; i < 6; i++) {\n        const x = (i * 140 + (this.animationTime * 10) % 840) % (this.canvas.width + 200) - 100;\n        const y = 60 + Math.sin((i + this.animationTime / 100) * 0.7) * 10;\n        this.ctx.beginPath();\n        this.ctx.fillStyle = 'rgba(255,255,255,0.85)';\n        this.ctx.moveTo(x, y);\n        this.ctx.ellipse(x, y, 70, 30, 0, 0, Math.PI * 2);\n        this.ctx.fill();\n      }\n    }\n\n    drawMachine() {\n      const cx = this.canvas.width / 2;\n      const cy = this.canvas.height / 2;\n\n      // machine base\n      this.ctx.fillStyle = '#DCECF2';\n      this.roundedRect(this.ctx, cx - 320, cy - 120, 640, 240, 24);\n      this.ctx.fill();\n\n      // console panel\n      this.ctx.fillStyle = '#C5E2EC';\n      this.roundedRect(this.ctx, cx - 260, cy - 100, 520, 60, 12);\n      this.ctx.fill();\n\n      // Target display on top left\n      this.ctx.fillStyle = '#073B4C';\n      this.ctx.font = '20px \"Segoe UI\", Roboto, sans-serif';\n      this.ctx.fillText('Target:', cx - 240, cy - 70);\n      this.ctx.fillStyle = '#0B8793';\n      this.ctx.font = '28px \"Segoe UI\", Roboto, sans-serif';\n      this.ctx.fillText(String(this.target), cx - 160, cy - 70);\n\n      // attempts and round display top right\n      this.ctx.fillStyle = '#073B4C';\n      this.ctx.font = '16px \"Segoe UI\", Roboto, sans-serif';\n      this.ctx.fillText(`Round ${this.round}/${this.totalRounds}`, cx + 10, cy - 70);\n      this.ctx.fillText(`Attempts ${this.attempts}/${this.maxAttempts}`, cx + 10, cy - 50);\n\n      // draw three gears and levers\n      const gearX = [cx - 200, cx, cx + 200];\n      const gearY = cy - 20;\n      const gearR = 60;\n\n      // draw levers (ops)\n      const leverX = [cx - 100, cx + 100];\n      for (let j = 0; j < 2; j++) {\n        const lx = leverX[j];\n        const ly = gearY;\n        const w = 80;\n        const h = 40;\n        // lever body\n        this.ctx.fillStyle = '#F6F9FB';\n        this.roundedRect(this.ctx, lx - w / 2, ly - h / 2 - 20, w, h, 10);\n        this.ctx.fill();\n        // lever text\n        this.ctx.fillStyle = this.selectionIndex === j * 2 + 1 ? '#0B8793' : '#2E5E6D';\n        this.ctx.font = '26px \"Segoe UI\", Roboto, sans-serif';\n        this.ctx.fillText(this.ops[j], lx - 8, ly + 2 - 20);\n        // small lever handle\n        this.ctx.fillStyle = '#D6EEF3';\n        this.ctx.beginPath();\n        this.ctx.ellipse(lx, ly + 14 - 20, 28, 9, 0, 0, Math.PI * 2);\n        this.ctx.fill();\n      }\n\n      // draw gears\n      for (let i = 0; i < 3; i++) {\n        const x = gearX[i];\n        const y = gearY;\n        // gear rotation depends on overall animation and index\n        const angle = this.gearAngle * (i % 2 === 0 ? 1 : -1) * (1 + i * 0.1);\n        this.drawGear(x, y, gearR, angle, i === 0 ? '#BEE8D2' : i === 1 ? '#FFE2A8' : '#FFD6E0', this.selectionIndex === i * 2 ? '#0B8793' : '#376B78', String(this.numbers[i]));\n      }\n\n      // process button\n      const btnX = this.canvas.width / 2 - 80;\n      const btnY = this.canvas.height - 80;\n      const btnW = 160;\n      const btnH = 48;\n      this.ctx.fillStyle = '#0B8793';\n      this.roundedRect(this.ctx, btnX, btnY, btnW, btnH, 12);\n      this.ctx.fill();\n      this.ctx.fillStyle = '#F6F9FB';\n      this.ctx.font = '20px \"Segoe UI\", Roboto, sans-serif';\n      this.ctx.fillText('Process', btnX + 42, btnY + 32);\n\n      // small sound indicator\n      this.ctx.fillStyle = this.muted ? '#FF6B6B' : '#7DD3C7';\n      this.ctx.beginPath();\n      this.ctx.ellipse(this.canvas.width - 40, 40, 18, 12, 0, 0, Math.PI * 2);\n      this.ctx.fill();\n      this.ctx.fillStyle = '#073B4C';\n      this.ctx.font = '12px \"Segoe UI\", Roboto, sans-serif';\n      this.ctx.fillText(this.muted ? 'Muted' : 'Audio', this.canvas.width - 62, 44);\n    }\n\n    drawGear(cx, cy, r, angle, fillColor, strokeColor, label) {\n      // gear body\n      this.ctx.save();\n      this.ctx.translate(cx, cy);\n      this.ctx.rotate(angle);\n      // outer\n      this.ctx.beginPath();\n      const teeth = 12;\n      for (let t = 0; t < teeth; t++) {\n        const a0 = (t / teeth) * Math.PI * 2;\n        const a1 = ((t + 0.5) / teeth) * Math.PI * 2;\n        const a2 = ((t + 1) / teeth) * Math.PI * 2;\n        const r0 = r;\n        const r1 = r + 8;\n        const x0 = Math.cos(a0) * r0;\n        const y0 = Math.sin(a0) * r0;\n        const x1 = Math.cos(a1) * r1;\n        const y1 = Math.sin(a1) * r1;\n        const x2 = Math.cos(a2) * r0;\n        const y2 = Math.sin(a2) * r0;\n        if (t === 0) this.ctx.moveTo(x0, y0);\n        this.ctx.lineTo(x1, y1);\n        this.ctx.lineTo(x2, y2);\n      }\n      this.ctx.closePath();\n      this.ctx.fillStyle = fillColor;\n      this.ctx.fill();\n      this.ctx.lineWidth = 2;\n      this.ctx.strokeStyle = strokeColor;\n      this.ctx.stroke();\n\n      // inner disc\n      this.ctx.beginPath();\n      this.ctx.arc(0, 0, r - 18, 0, Math.PI * 2);\n      this.ctx.fillStyle = '#F6FBFA';\n      this.ctx.fill();\n      this.ctx.strokeStyle = '#D1E7E4';\n      this.ctx.lineWidth = 2;\n      this.ctx.stroke();\n\n      // center label\n      this.ctx.fillStyle = '#073B4C';\n      this.ctx.font = '30px \"Segoe UI\", Roboto, sans-serif';\n      this.ctx.textAlign = 'center';\n      this.ctx.textBaseline = 'middle';\n      this.ctx.fillText(label, 0, 0);\n\n      this.ctx.restore();\n    }\n\n    roundedRect(ctx, x, y, w, h, r) {\n      ctx.beginPath();\n      ctx.moveTo(x + r, y);\n      ctx.arcTo(x + w, y, x + w, y + h, r);\n      ctx.arcTo(x + w, y + h, x, y + h, r);\n      ctx.arcTo(x, y + h, x, y, r);\n      ctx.arcTo(x, y, x + w, y, r);\n      ctx.closePath();\n    }\n\n    drawOverlay() {\n      // draw particle confetti\n      for (let c of this.confetti) {\n        this.ctx.save();\n        this.ctx.translate(c.x, c.y);\n        this.ctx.rotate(c.rot);\n        this.ctx.fillStyle = c.color;\n        this.ctx.fillRect(-4, -6, 8, 12);\n        this.ctx.restore();\n      }\n\n      // draw floating particles\n      for (let p of this.particles) {\n        this.ctx.beginPath();\n        this.ctx.fillStyle = p.color;\n        this.ctx.globalAlpha = clamp(p.life / 80, 0, 1);\n        this.ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);\n        this.ctx.fill();\n        this.ctx.globalAlpha = 1;\n      }\n\n      // draw instructions panel bottom-left\n      const x = 18;\n      const y = this.canvas.height - 130;\n      this.ctx.fillStyle = 'rgba(255,255,255,0.7)';\n      this.roundedRect(this.ctx, x, y, 280, 110, 10);\n      this.ctx.fill();\n      this.ctx.fillStyle = '#073B4C';\n      this.ctx.font = '13px \"Segoe UI\", Roboto, sans-serif';\n      this.ctx.fillText('Controls:', x + 12, y + 24);\n      this.ctx.font = '12px \"Segoe UI\", Roboto, sans-serif';\n      this.ctx.fillText('Left/Right: move selection', x + 12, y + 44);\n      this.ctx.fillText('Up/Down: change number or operation', x + 12, y + 64);\n      this.ctx.fillText('Space: randomize selection', x + 12, y + 84);\n      this.ctx.fillText('Enter: process. M: mute/unmute', x + 12, y + 104);\n    }\n\n    frame(t) {\n      if (!this.running) {\n        // Draw final screen\n        this.drawBackground();\n        ctx.fillStyle = '#073B4C';\n        ctx.font = '28px \"Segoe UI\", Roboto, sans-serif';\n        ctx.fillText(`All done! You solved ${this.solvedCount}/${this.totalRounds} puzzles.`, 60, 200);\n        ctx.font = '18px \"Segoe UI\", Roboto, sans-serif';\n        ctx.fillText('Press Enter to play again.', 60, 240);\n        return;\n      }\n\n      const dt = (t - this.lastTime) / 1000;\n      this.lastTime = t;\n      this.animationTime += dt * 1000;\n      this.gearAngle += dt * 0.9;\n\n      // update particles\n      this.updateParticles();\n\n      // clear and draw\n      this.drawBackground();\n      this.drawMachine();\n      this.drawOverlay();\n\n      // subtle floating status line\n      this.ctx.fillStyle = '#0B8793';\n      this.ctx.font = '14px \"Segoe UI\", Roboto, sans-serif';\n      this.ctx.fillText(`Try to make the machine output the target number. Round ${this.round}`, 18, 26);\n\n      this.rafId = requestAnimationFrame((tt) => this.frame(tt));\n    }\n  }\n\n  // Initialize audio then start game\n  audio.initPromise.then(() => {\n    // attach a visible small prompt to enable audio (some browsers require user gesture).\n    const statusText = document.createElement('div');\n    statusText.style.position = 'absolute';\n    statusText.style.left = '8px';\n    statusText.style.top = '8px';\n    statusText.style.background = 'rgba(255,255,255,0.6)';\n    statusText.style.padding = '6px 8px';\n    statusText.style.borderRadius = '8px';\n    statusText.style.fontFamily = 'Segoe UI, Roboto, sans-serif';\n    statusText.style.fontSize = '12px';\n    statusText.style.color = '#073B4C';\n    statusText.textContent = audio.available ? 'Audio ready \u2014 press any key or click to enable sound' : 'Audio not available on this device';\n    container.appendChild(statusText);\n\n    // Remove status after a short time or on first interaction\n    const removeStatus = () => {\n      try {\n        statusText.remove();\n      } catch (e) {}\n      // ensure audio is started when user interacts\n      if (audio.available) audio.ensureStarted().catch(() => {});\n      window.removeEventListener('keydown', removeStatus);\n      canvas.removeEventListener('pointerdown', removeStatus);\n    };\n\n    window.addEventListener('keydown', removeStatus, { once: true });\n    canvas.addEventListener('pointerdown', removeStatus, { once: true });\n\n    // create and start game\n    try {\n      const game = new MachineGame(ctx, canvas, audio, liveRegion);\n      // expose restart for debugging (optional)\n      container.game = game;\n    } catch (e) {\n      console.error('Failed to start game:', e);\n      liveRegion.textContent = 'An unexpected error occurred while starting the game.';\n    }\n  }).catch((err) => {\n    console.warn('Audio init promise rejected', err);\n    // start game without audio\n    try {\n      const game = new MachineGame(ctx, canvas, audio, liveRegion);\n      container.game = game;\n    } catch (e) {\n      console.error('Failed to start game:', e);\n      liveRegion.textContent = 'An unexpected error occurred while starting the game.';\n    }\n  });\n\n})();\n---\n",
  "improve_response_tokens": 20742,
  "formatted_code": true,
  "formatting_response_tokens": 23018,
  "final_functionality": {
    "score": 7,
    "max_score": 8,
    "percentage": 87.5,
    "passing": true,
    "issues": [],
    "warnings": [
      "No game state management found"
    ]
  }
}