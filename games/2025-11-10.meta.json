{
  "generated_date": "2025-11-10",
  "generated_timestamp": "2025-11-10T00:29:54.897504",
  "model": "gpt-5-mini",
  "theme": "drones",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones\n\nThe game must:\n\u2022 Be beatable with CLEAR WIN AND LOSS CONDITIONS:\n  - Include a specific goal (e.g., \"answer 10 questions correctly\", \"reach level 5\", \"collect 50 stars\")\n  - Include a way to lose or fail (e.g., \"3 wrong answers = game over\", \"timer runs out\", \"lives system\")\n  - Show a victory screen when the player wins\n  - Show a game over screen when the player loses\n  - Include a restart button or instruction on both end screens\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:\n  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)\n  - Use ctx.measureText() to calculate text width before drawing\n  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)\n  - Use background rectangles behind text for readability\n  - Test that multi-line text doesn't overlap with game elements\n  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 10397,
  "game_filename": "2025-11-10.js",
  "game_size_bytes": 30103,
  "functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 5
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nMAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.\nMAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Drone Math Adventure\n  // For ages 7-9. All visuals drawn on canvas inside element #game-of-the-day-stage.\n  // Single-file JS. No external resources.\n\n  // ---------- Setup and Safety ----------\n  const container = document.getElementById('game-of-the-day-stage');\n  if (!container) {\n    console.error('Missing container element with ID \"game-of-the-day-stage\".');\n    return;\n  }\n\n  // Clear container and create canvas sized exactly 720x480\n  container.innerHTML = '';\n  const canvas = document.createElement('canvas');\n  canvas.width = 720;\n  canvas.height = 480;\n  canvas.setAttribute('role', 'application');\n  canvas.setAttribute('aria-label', 'Drone Math Adventure. Press number keys or arrow keys and Enter to answer. Press R to restart.');\n  canvas.setAttribute('tabindex', '0'); // allow keyboard focus\n  canvas.style.outline = 'none';\n  container.appendChild(canvas);\n\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    console.error('Canvas 2D context not available.');\n    return;\n  }\n\n  // Ensure crisp text rendering\n  ctx.imageSmoothingEnabled = true;\n\n  // ---------- Audio Setup ----------\n  let audioEnabled = true;\n  let audioContext = null;\n  let masterGain = null;\n  let ambientOsc = null;\n  let ambientGain = null;\n\n  function tryCreateAudioContext() {\n    if (audioContext) return;\n    try {\n      const AC = window.AudioContext || window.webkitAudioContext;\n      if (!AC) {\n        audioEnabled = false;\n        console.warn('Web Audio API not supported in this browser.');\n        return;\n      }\n      audioContext = new AC();\n      masterGain = audioContext.createGain();\n      masterGain.gain.value = 0.9;\n      masterGain.connect(audioContext.destination);\n\n      // gentle ambient hum as background effect\n      try {\n        ambientOsc = audioContext.createOscillator();\n        ambientGain = audioContext.createGain();\n        ambientOsc.type = 'sine';\n        ambientOsc.frequency.value = 80; // low hum\n        ambientGain.gain.value = 0.0015; // very gentle\n        ambientOsc.connect(ambientGain);\n        ambientGain.connect(masterGain);\n        ambientOsc.start();\n      } catch (e) {\n        console.warn('Ambient sound failed to start:', e);\n      }\n    } catch (err) {\n      audioEnabled = false;\n      console.warn('Failed to create AudioContext:', err);\n    }\n  }\n\n  // Play simple sounds: correct (pleasant chime), incorrect (buzz), click\n  function playSound(type) {\n    if (!audioEnabled) return;\n    try {\n      if (!audioContext) tryCreateAudioContext();\n      if (!audioContext) return;\n\n      const now = audioContext.currentTime;\n      if (type === 'correct') {\n        // rising chord-like beep\n        const freqs = [880, 1100, 1320];\n        freqs.forEach((f, i) => {\n          const o = audioContext.createOscillator();\n          const g = audioContext.createGain();\n          o.type = 'sine';\n          o.frequency.value = f;\n          g.gain.value = 0;\n          o.connect(g);\n          g.connect(masterGain);\n          o.start(now + i * 0.02);\n          g.gain.setValueAtTime(0.0001, now + i * 0.02);\n          g.gain.exponentialRampToValueAtTime(0.06, now + i * 0.02 + 0.06);\n          g.gain.exponentialRampToValueAtTime(0.0001, now + i * 0.02 + 0.35);\n          o.stop(now + i * 0.02 + 0.36);\n        });\n      } else if (type === 'incorrect') {\n        const o = audioContext.createOscillator();\n        const g = audioContext.createGain();\n        o.type = 'sawtooth';\n        o.frequency.value = 200;\n        g.gain.value = 0.0001;\n        o.connect(g);\n        g.connect(masterGain);\n        o.start(now);\n        g.gain.exponentialRampToValueAtTime(0.06, now + 0.02);\n        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.32);\n        o.frequency.exponentialRampToValueAtTime(60, now + 0.32);\n        o.stop(now + 0.34);\n      } else if (type === 'click') {\n        const o = audioContext.createOscillator();\n        const g = audioContext.createGain();\n        o.type = 'square';\n        o.frequency.value = 1200;\n        g.gain.value = 0.01;\n        o.connect(g);\n        g.connect(masterGain);\n        o.start(now);\n        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.09);\n        o.stop(now + 0.1);\n      }\n    } catch (e) {\n      console.warn('Error playing sound:', e);\n      audioEnabled = false;\n    }\n  }\n\n  // ---------- Game Variables ----------\n  const WIDTH = canvas.width;\n  const HEIGHT = canvas.height;\n\n  const UI_PADDING = 10; // minimum padding between UI elements\n\n  const GOAL = 10; // collect 10 correct batteries\n  const MAX_WRONG = 3; // 3 wrong answers => game over\n\n  let score = 0;\n  let wrongCount = 0;\n  let gameState = 'playing'; // 'playing', 'victory', 'gameover', 'title'\n  let soundVisualTimer = 0; // visual indicator when sound plays\n  let lastInteractionTime = 0;\n\n  // Current question\n  let question = null; // {text, choices:[...], answerIndex}\n  let selectedChoice = 0; // 0..2\n  let anims = []; // animations for drone, explosions etc.\n\n  // Drone state for animation\n  const drone = {\n    x: 100,\n    y: 200,\n    targetX: 100,\n    targetY: 200,\n    speed: 220, // pixels per second\n    propellerAngle: 0,\n    size: 40,\n  };\n\n  // Batteries positions (collected) -- but will spawn for each success\n  let battery = null; // {x,y,active,progress}\n\n  // Clouds array for background animation\n  const clouds = createClouds();\n\n  // UI positions - compute using measureText to ensure no overlapping\n  const ui = {\n    scorePos: { x: 18, y: 24 },\n    livesPos: { x: WIDTH - 18, y: 24 }, // measureText to right align\n    centerTopPos: { x: WIDTH / 2, y: 24 },\n    choicesArea: { y: 350, height: 110 }, // bottom area for choices\n    instructionPos: { x: WIDTH / 2, y: HEIGHT - 20 },\n  };\n\n  // ---------- Utilities ----------\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  function clamp(v, a, b) {\n    return Math.max(a, Math.min(b, v));\n  }\n\n  function formatTextWidth(text, font) {\n    ctx.save();\n    ctx.font = font;\n    const m = ctx.measureText(text);\n    ctx.restore();\n    return m.width;\n  }\n\n  // ---------- Question Generation ----------\n  function generateQuestion() {\n    // Basic addition/subtraction within suitable ranges for ages 7-9\n    const type = Math.random() < 0.6 ? 'add' : 'sub';\n    let a, b;\n    if (type === 'add') {\n      a = randInt(1, 12);\n      b = randInt(1, 12);\n    } else {\n      a = randInt(5, 18);\n      b = randInt(1, Math.min(8, a - 1));\n    }\n    const text = type === 'add' ? `${a} + ${b} = ?` : `${a} - ${b} = ?`;\n    const answer = type === 'add' ? a + b : a - b;\n\n    // Create 3 choices, one correct, others plausible\n    const choices = [];\n    const correctIndex = randInt(0, 2);\n    for (let i = 0; i < 3; i++) {\n      if (i === correctIndex) {\n        choices.push(answer);\n      } else {\n        // plausible distractor within +/-3 but not equal\n        let candidate;\n        let tries = 0;\n        do {\n          const delta = randInt(-3, 3);\n          candidate = answer + delta;\n          tries++;\n        } while ((candidate === answer || candidate < 0) && tries < 10);\n        if (candidate === answer || candidate < 0) candidate = answer + (i === 0 ? 2 : -2);\n        choices.push(candidate);\n      }\n    }\n\n    return {\n      text,\n      choices,\n      answerIndex: correctIndex,\n    };\n  }\n\n  // ---------- Cloud Generation ----------\n  function createClouds() {\n    const arr = [];\n    const count = 6;\n    for (let i = 0; i < count; i++) {\n      arr.push({\n        x: Math.random() * WIDTH,\n        y: Math.random() * 120 + 10,\n        w: 80 + Math.random() * 120,\n        h: 36 + Math.random() * 28,\n        speed: 8 + Math.random() * 30,\n        puff: Math.random() * 8 + 8,\n      });\n    }\n    return arr;\n  }\n\n  // ---------- Input Handling ----------\n  // Keyboard and mouse events\n  canvas.addEventListener('keydown', (e) => {\n    lastInteractionTime = Date.now();\n    if (!audioContext && audioEnabled) tryCreateAudioContext();\n    if (gameState === 'title') {\n      if (e.key.toLowerCase() === 's' || e.key === 'Enter') {\n        e.preventDefault();\n        startGame();\n        return;\n      }\n    }\n    if (gameState === 'victory' || gameState === 'gameover') {\n      if (e.key.toLowerCase() === 'r') {\n        e.preventDefault();\n        restartGame();\n        playSound('click');\n      }\n      return;\n    }\n    if (gameState !== 'playing') return;\n\n    if (e.key === 'ArrowLeft') {\n      selectedChoice = (selectedChoice + 3 - 1) % 3;\n      playSound('click');\n    } else if (e.key === 'ArrowRight') {\n      selectedChoice = (selectedChoice + 1) % 3;\n      playSound('click');\n    } else if (e.key === 'Enter') {\n      e.preventDefault();\n      submitAnswer(selectedChoice);\n    } else if (e.key >= '1' && e.key <= '3') {\n      const idx = parseInt(e.key, 10) - 1;\n      selectedChoice = idx;\n      submitAnswer(idx);\n    } else if (e.key.toLowerCase() === 'm') {\n      // toggle audio\n      audioEnabled = !audioEnabled;\n      if (!audioEnabled && ambientGain) ambientGain.gain.value = 0;\n      playSound('click');\n    }\n  });\n\n  canvas.addEventListener('click', (e) => {\n    lastInteractionTime = Date.now();\n    if (!audioContext && audioEnabled) tryCreateAudioContext();\n    const r = canvas.getBoundingClientRect();\n    const mx = (e.clientX - r.left) * (canvas.width / r.width);\n    const my = (e.clientY - r.top) * (canvas.height / r.height);\n    if (gameState === 'title') {\n      startGame();\n      playSound('click');\n      return;\n    }\n    if (gameState === 'victory' || gameState === 'gameover') {\n      // detect click on restart button\n      if (isPointInRect(mx, my, restartButtonRect)) {\n        restartGame();\n        playSound('click');\n      }\n      return;\n    }\n    if (gameState !== 'playing') return;\n\n    // Check clicks on choice rectangles\n    for (let i = 0; i < 3; i++) {\n      const rect = getChoiceRect(i);\n      if (isPointInRect(mx, my, rect)) {\n        selectedChoice = i;\n        submitAnswer(i);\n        return;\n      }\n    }\n  });\n\n  function isPointInRect(x, y, rect) {\n    return x >= rect.x && x <= rect.x + rect.w && y >= rect.y && y <= rect.y + rect.h;\n  }\n\n  // ---------- Game Logic ----------\n  function startGame() {\n    score = 0;\n    wrongCount = 0;\n    gameState = 'playing';\n    selectedChoice = 0;\n    question = generateQuestion();\n    battery = null;\n    drone.x = 100;\n    drone.y = 200;\n    drone.targetX = drone.x;\n    drone.targetY = drone.y;\n    anims.length = 0;\n  }\n\n  function restartGame() {\n    gameState = 'playing';\n    lastInteractionTime = Date.now();\n    startGame();\n  }\n\n  function submitAnswer(idx) {\n    if (gameState !== 'playing' || !question) return;\n    // Confirm selection\n    const correct = idx === question.answerIndex;\n    if (correct) {\n      score += 1;\n      playSound('correct');\n      soundVisualTimer = 0.6;\n      // spawn a battery somewhere mildly random but reachable\n      battery = {\n        x: clamp(randInt(160, WIDTH - 120), 120, WIDTH - 120),\n        y: clamp(randInt(100, 300), 80, 320),\n        active: true,\n        progress: 0,\n      };\n      // set drone target to battery\n      drone.targetX = battery.x;\n      drone.targetY = battery.y - 40;\n      // add a friendly twinkle animation\n      anims.push(createTwinkle(battery.x, battery.y));\n      // next question will be generated after drone reaches battery and collects\n    } else {\n      wrongCount += 1;\n      playSound('incorrect');\n      soundVisualTimer = 0.4;\n      // small explosion animation\n      anims.push(createExplosion(drone.x, drone.y));\n      // nudge drone back\n      drone.targetX = clamp(drone.x - 60, 60, WIDTH - 60);\n      drone.targetY = clamp(drone.y + 20, 80, HEIGHT - 120);\n    }\n    // lock selection briefly: generate next question after short delay or after drone collects\n    selectedChoice = 0;\n    question = null; // wait until after animations to show next question\n\n    // Check immediate game end on wrongCount exceeding\n    if (wrongCount >= MAX_WRONG) {\n      setTimeout(() => {\n        gameState = 'gameover';\n      }, 700);\n    }\n  }\n\n  // ---------- Animations Helpers ----------\n  function createExplosion(x, y) {\n    return {\n      type: 'explosion',\n      x,\n      y,\n      t: 0,\n      duration: 0.7,\n    };\n  }\n\n  function createTwinkle(x, y) {\n    return {\n      type: 'twinkle',\n      x,\n      y,\n      t: 0,\n      duration: 0.9,\n    };\n  }\n\n  // ---------- Rendering Helpers ----------\n  function drawRoundedRect(ctx, x, y, w, h, r) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.arcTo(x + w, y, x + w, y + h, r);\n    ctx.arcTo(x + w, y + h, x, y + h, r);\n    ctx.arcTo(x, y + h, x, y, r);\n    ctx.arcTo(x, y, x + w, y, r);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  function drawSky() {\n    // calm gradient sky\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, '#BFE9FF');\n    g.addColorStop(1, '#DFF6FF');\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n  }\n\n  function drawClouds(dt) {\n    ctx.save();\n    ctx.globalAlpha = 0.9;\n    for (const c of clouds) {\n      c.x += (c.speed * dt) / 60;\n      if (c.x - c.w > WIDTH + 50) c.x = -c.w - 50;\n      // draw layered puffs\n      ctx.fillStyle = '#F1FBFF';\n      ctx.beginPath();\n      const puffCount = Math.max(3, Math.floor(c.puff));\n      for (let i = 0; i < puffCount; i++) {\n        const px = c.x + (i / (puffCount - 1 || 1)) * c.w;\n        const py = c.y + Math.sin((i / puffCount) * Math.PI) * 6;\n        ctx.moveTo(px, py);\n        ctx.arc(px, py, c.h * (0.6 + Math.random() * 0.2), 0, Math.PI * 2);\n      }\n      ctx.fill();\n      // subtle underside\n      ctx.fillStyle = 'rgba(180,220,240,0.25)';\n      ctx.fillRect(c.x, c.y + c.h * 0.2, c.w, c.h * 0.3);\n    }\n    ctx.restore();\n  }\n\n  function drawDrone(dt) {\n    // propeller rotation\n    drone.propellerAngle += dt * 12; // speed\n    // move toward target\n    const dx = drone.targetX - drone.x;\n    const dy = drone.targetY - drone.y;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n    if (dist > 1) {\n      const move = Math.min((drone.speed * dt) / 1000, dist);\n      drone.x += (dx / dist) * move;\n      drone.y += (dy / dist) * move;\n    }\n\n    // body\n    ctx.save();\n    ctx.translate(drone.x, drone.y);\n    // body shadow\n    ctx.fillStyle = 'rgba(0,0,0,0.08)';\n    ctx.beginPath();\n    ctx.ellipse(0, drone.size * 0.6, drone.size * 0.8, drone.size * 0.28, 0, 0, Math.PI * 2);\n    ctx.fill();\n\n    // main hull\n    ctx.fillStyle = '#FFD838';\n    ctx.strokeStyle = '#6C4A00';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.ellipse(0, 0, drone.size * 1.2, drone.size * 0.7, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n\n    // windows\n    ctx.fillStyle = '#9EE7FF';\n    ctx.beginPath();\n    ctx.arc(-10, -2, 10, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(10, -2, 6, 0, Math.PI * 2);\n    ctx.fill();\n\n    // legs\n    ctx.strokeStyle = '#6C4A00';\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.moveTo(-18, drone.size * 0.3);\n    ctx.lineTo(-26, drone.size * 0.9);\n    ctx.moveTo(18, drone.size * 0.3);\n    ctx.lineTo(26, drone.size * 0.9);\n    ctx.stroke();\n\n    // propellers\n    ctx.save();\n    ctx.rotate(drone.propellerAngle);\n    for (let i = -1; i <= 1; i += 2) {\n      ctx.save();\n      ctx.translate(i * 26, -18);\n      ctx.fillStyle = 'rgba(100,100,120,0.7)';\n      ctx.beginPath();\n      ctx.ellipse(0, 0, 28, 6, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.strokeStyle = 'rgba(0,0,0,0.12)';\n      ctx.stroke();\n      ctx.restore();\n    }\n    ctx.restore();\n\n    ctx.restore();\n  }\n\n  function drawBattery(bat, dt) {\n    if (!bat) return;\n    // twinkle if active\n    ctx.save();\n    const shine = 0.3 + 0.7 * Math.sin(Date.now() / 250);\n    ctx.translate(bat.x, bat.y);\n    ctx.fillStyle = `rgba(255,220,60,${0.95 + 0.05 * shine})`;\n    ctx.strokeStyle = '#8B6A00';\n    ctx.lineWidth = 2;\n    drawRoundedRect(ctx, -18, -12, 36, 24, 6);\n    ctx.fillStyle = '#FFF8D7';\n    ctx.fillRect(-6, -8, 12, 16);\n    ctx.restore();\n  }\n\n  // choice rectangles computed based on text widths\n  function getChoiceRect(i) {\n    // layout three columns within choices area with spacing, use measureText to ensure text fits\n    const area = ui.choicesArea;\n    const y = area.y + 14;\n    const heights = 52;\n    // compute column widths: balance space\n    const gap = 18;\n    const totalGap = gap * 2;\n    const available = WIDTH - UI_PADDING * 2 - totalGap;\n    const colW = Math.floor(available / 3);\n    const x = UI_PADDING + i * (colW + gap);\n    return { x, y, w: colW, h: heights };\n  }\n\n  // ---------- Main Update & Draw Loop ----------\n  let lastTime = performance.now();\n  let restartButtonRect = { x: 0, y: 0, w: 0, h: 0 };\n\n  function update(now) {\n    const dtMs = Math.min(now - lastTime, 40);\n    const dt = dtMs;\n    lastTime = now;\n\n    // update sound visual timer\n    if (soundVisualTimer > 0) soundVisualTimer = Math.max(0, soundVisualTimer - dt / 1000);\n\n    // update anims\n    for (let i = anims.length - 1; i >= 0; i--) {\n      const a = anims[i];\n      a.t += dt / 1000;\n      if (a.t >= a.duration) anims.splice(i, 1);\n    }\n\n    // robot auto-behaviors: if battery exists and drone near battery, collect it\n    if (battery && battery.active) {\n      const dx = battery.x - drone.x;\n      const dy = battery.y - 40 - drone.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      if (dist < 8) {\n        // collect\n        battery.active = false;\n        anims.push({\n          type: 'collect',\n          x: battery.x,\n          y: battery.y,\n          t: 0,\n          duration: 0.8,\n        });\n        // after short delay, spawn next question or victory\n        setTimeout(() => {\n          if (score >= GOAL) {\n            gameState = 'victory';\n          } else if (wrongCount >= MAX_WRONG) {\n            gameState = 'gameover';\n          } else {\n            question = generateQuestion();\n          }\n          battery = null;\n        }, 600);\n      }\n    }\n\n    // draw everything\n    drawFrame(dtMs / 1000);\n\n    requestAnimationFrame(update);\n  }\n\n  // ---------- Drawing Frame ----------\n  function drawFrame(dt) {\n    // background\n    drawSky();\n    drawClouds(dt);\n\n    // draw playground ground\n    ctx.fillStyle = '#E8FFF2';\n    ctx.fillRect(0, HEIGHT - 90, WIDTH, 90);\n\n    // draw anims behind drone\n    for (const a of anims) {\n      if (a.type === 'explosion') drawExplosion(a);\n    }\n\n    // battery (maybe behind drone)\n    drawBattery(battery, dt);\n\n    // drone\n    drawDrone(dt);\n\n    // draw anims above drone (twinkles, collect)\n    for (const a of anims) {\n      if (a.type === 'twinkle' || a.type === 'collect') {\n        drawTwinkle(a);\n      }\n    }\n\n    // top UI: score, progress, lives\n    drawTopUI();\n\n    // bottom: choices area\n    drawChoicesArea();\n\n    // instructions bottom center\n    drawInstructions();\n\n    // sound visual indicator\n    if (soundVisualTimer > 0 || !audioEnabled) drawSoundIcon();\n\n    // if title or end screens\n    if (gameState === 'title') drawTitleScreen();\n    if (gameState === 'victory') drawVictoryScreen();\n    if (gameState === 'gameover') drawGameOverScreen();\n  }\n\n  // ---------- UI Drawing ----------\n  function drawTopUI() {\n    // Score top-left\n    const scoreText = `Batteries: ${score} / ${GOAL}`;\n    ctx.font = 'bold 20px sans-serif';\n    const sw = ctx.measureText(scoreText).width;\n    const pad = 12;\n    const x = ui.scorePos.x;\n    const y = ui.scorePos.y - 18;\n    ctx.fillStyle = 'rgba(255,255,255,0.6)';\n    drawRoundedRect(ctx, x - pad / 2, 6, sw + pad * 1.2, 36, 8);\n    ctx.fillStyle = '#004466';\n    ctx.fillText(scoreText, x + 6, ui.scorePos.y + 2);\n\n    // Lives top-right\n    const livesText = `Errors: ${wrongCount} / ${MAX_WRONG}`;\n    ctx.font = 'bold 20px sans-serif';\n    const lw = ctx.measureText(livesText).width;\n    const rx = ui.livesPos.x;\n    const ry = ui.livesPos.y - 18;\n    ctx.fillStyle = 'rgba(255,255,255,0.6)';\n    drawRoundedRect(ctx, rx - lw - 18, 6, lw + 14, 36, 8);\n    ctx.fillStyle = '#660000';\n    ctx.fillText(livesText, rx - lw - 4, ui.livesPos.y + 2);\n\n    // center top: if question exists show small hint\n    ctx.font = '18px sans-serif';\n    const hintText = `Drone Pilot: Collect ${GOAL} batteries by answering correctly.`;\n    const hw = ctx.measureText(hintText).width;\n    const hx = ui.centerTopPos.x - hw / 2;\n    ctx.fillStyle = 'rgba(255,255,255,0.5)';\n    drawRoundedRect(ctx, hx - 10, 6, hw + 20, 36, 8);\n    ctx.fillStyle = '#003344';\n    ctx.fillText(hintText, hx + 6, ui.centerTopPos.y + 2);\n  }\n\n  function drawChoicesArea() {\n    // background container\n    ctx.fillStyle = 'rgba(255,255,255,0.7)';\n    drawRoundedRect(ctx, UI_PADDING - 6, ui.choicesArea.y + 2, WIDTH - (UI_PADDING - 6) * 2, ui.choicesArea.height, 12);\n\n    // question box (centered above choices)\n    ctx.font = '22px sans-serif';\n    const qText = question ? question.text : '...';\n    const qw = ctx.measureText(qText).width;\n    const qx = WIDTH / 2 - qw / 2;\n    const qy = ui.choicesArea.y - 24;\n    ctx.fillStyle = 'rgba(0,0,0,0.06)';\n    drawRoundedRect(ctx, qx - 10, qy - 6, qw + 20, 36, 8);\n    ctx.fillStyle = '#002233';\n    ctx.fillText(qText, qx, qy + 22);\n\n    // draw three choice rectangles\n    for (let i = 0; i < 3; i++) {\n      const rect = getChoiceRect(i);\n      // measure text width\n      ctx.font = '20px sans-serif';\n      const text = question ? String(question.choices[i]) : '\u2014';\n      const tw = ctx.measureText(`${i + 1}. ${text}`).width;\n      const padding = 12;\n      // choose style depending on selection\n      const isSelected = i === selectedChoice && gameState === 'playing';\n      ctx.fillStyle = isSelected ? 'rgba(61, 128, 255, 0.95)' : 'rgba(245, 255, 250, 0.95)';\n      // ensure rect width at least fits text\n      const w = Math.max(rect.w, tw + padding * 2);\n      // center within rect area\n      const rx = rect.x + (rect.w - w) / 2;\n      const ry = rect.y;\n      const rh = rect.h;\n      ctx.fillStyle = isSelected ? '#2B6FE8' : '#FFFFFF';\n      ctx.strokeStyle = 'rgba(0,0,0,0.08)';\n      ctx.lineWidth = 2;\n      drawRoundedRect(ctx, rx, ry, w, rh, 10);\n      // text\n      ctx.fillStyle = isSelected ? '#FFFFFF' : '#003344';\n      ctx.font = isSelected ? 'bold 20px sans-serif' : '20px sans-serif';\n      const label = `${i + 1}. ${text}`;\n      // measure to center vertically/horizontally\n      const twreal = ctx.measureText(label).width;\n      const tx = rx + (w - twreal) / 2;\n      const ty = ry + rh / 2 + 8;\n      ctx.fillText(label, tx, ty);\n\n      // small border icon showing correct/incorrect after selection processed\n      if (!question) {\n        // during animation/no question, show nothing\n      } else {\n        // draw small hint dot to left\n        ctx.beginPath();\n        ctx.fillStyle = '#F0F8FF';\n        ctx.arc(rx + 14, ry + rh / 2, 10, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n\n    // accessibility: show key controls\n    ctx.font = '14px sans-serif';\n    ctx.fillStyle = '#003344';\n    ctx.fillText('Use \u2190 \u2192 to choose, Enter to confirm, or press 1-3. Press M to mute/unmute.', UI_PADDING + 4, ui.choicesArea.y + ui.choicesArea.height - 8);\n  }\n\n  function drawInstructions() {\n    ctx.save();\n    ctx.font = '16px sans-serif';\n    const instr = gameState === 'playing' ? 'Answer correctly to guide your drone to batteries. 3 mistakes and the game ends.' : '';\n    const w = ctx.measureText(instr).width;\n    ctx.fillStyle = 'rgba(255,255,255,0.7)';\n    drawRoundedRect(ctx, ui.instructionPos.x - w / 2 - 12, ui.instructionPos.y - 22, w + 24, 36, 8);\n    ctx.fillStyle = '#002244';\n    ctx.fillText(instr, ui.instructionPos.x - w / 2, ui.instructionPos.y - 6);\n    ctx.restore();\n  }\n\n  function drawSoundIcon() {\n    // top-left near score show a small speaker icon and animation if sound just played or muted\n    const x = ui.scorePos.x + 6;\n    const y = ui.scorePos.y + 40;\n    ctx.save();\n    ctx.globalAlpha = 0.95;\n    ctx.fillStyle = audioEnabled ? '#2B6FE8' : '#777';\n    // small rectangle background\n    drawRoundedRect(ctx, x - 6, y - 18, 110, 30, 8);\n    ctx.fillStyle = audioEnabled ? '#2B6FE8' : '#777';\n    // speaker triangle\n    ctx.beginPath();\n    ctx.moveTo(x + 8, y - 2);\n    ctx.lineTo(x + 18, y + 8);\n    ctx.lineTo(x + 18, y - 12);\n    ctx.closePath();\n    ctx.fillStyle = '#FFF';\n    ctx.fill();\n\n    // sound wave visual if playing recently\n    if (soundVisualTimer > 0 && audioEnabled) {\n      ctx.strokeStyle = '#FFFB';\n      ctx.lineWidth = 2;\n      ctx.beginPath();\n      ctx.arc(x + 36, y - 2, 8 + soundVisualTimer * 18, -0.6, 0.6);\n      ctx.stroke();\n    } else {\n      ctx.fillStyle = '#FFFFFF';\n      ctx.font = '12px sans-serif';\n      ctx.fillText(audioEnabled ? 'Sound: On (M)' : 'Sound: Off (M)', x + 48, y + 4);\n    }\n    ctx.restore();\n  }\n\n  // ---------- Anim Drawings ----------\n  function drawExplosion(a) {\n    const p = a.t / a.duration;\n    if (p > 1) return;\n    const alpha = 1 - p;\n    ctx.save();\n    ctx.globalAlpha = alpha;\n    for (let i = 0; i < 8; i++) {\n      const ang = (i / 8) * Math.PI * 2 + p * 6;\n      const r = 6 + p * 40;\n      ctx.fillStyle = `rgba(255, ${120 + i * 10}, 64, ${0.9 - p * 0.9})`;\n      ctx.beginPath();\n      ctx.ellipse(a.x + Math.cos(ang) * r, a.y + Math.sin(ang) * r, 8 * (1 - p * 0.8), 6 * (1 - p * 0.8), 0, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    ctx.restore();\n  }\n\n  function drawTwinkle(a) {\n    const p = a.t / a.duration;\n    if (p > 1) return;\n    const size = 6 + Math.sin(p * Math.PI) * 18;\n    ctx.save();\n    ctx.globalAlpha = 0.9 * (1 - p);\n    ctx.fillStyle = '#FFFFFF';\n    for (let i = 0; i < 6; i++) {\n      const rot = (i / 6) * Math.PI * 2;\n      ctx.beginPath();\n      ctx.moveTo(a.x, a.y);\n      ctx.lineTo(a.x + Math.cos(rot) * size, a.y + Math.sin(rot) * size);\n      ctx.strokeStyle = `rgba(255,255,255,${0.9 - p})`;\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  // ---------- Title and End Screens ----------\n  function drawTitleScreen() {\n    ctx.save();\n    const title = 'Drone Math Adventure';\n    ctx.font = 'bold 36px sans-serif';\n    ctx.fillStyle = '#003344';\n    const tw = ctx.measureText(title).width;\n    ctx.fillText(title, WIDTH / 2 - tw / 2, HEIGHT / 2 - 40);\n\n    ctx.font = '18px sans-serif';\n    const desc = 'Help your friendly drone collect batteries by answering math problems!';\n    const dw = ctx.measureText(desc).width;\n    ctx.fillStyle = '#002233';\n    ctx.fillText(desc, WIDTH / 2 - dw / 2, HEIGHT / 2 - 8);\n\n    ctx.font = '16px sans-serif';\n    const hint = 'Press S or Enter to Start. Use 1-3, arrow keys, or click choices. R to restart after game over.';\n    const hw = ctx.measureText(hint).width;\n    ctx.fillText(hint, WIDTH / 2 - hw / 2, HEIGHT / 2 + 18);\n    ctx.restore();\n  }\n\n  function drawVictoryScreen() {\n    ctx.save();\n    // translucent overlay\n    ctx.fillStyle = 'rgba(0,0,0,0.35)';\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    const title = 'Victory! Batteries Collected.';\n    ctx.font = 'bold 36px sans-serif';\n    ctx.fillStyle = '#FFF8E6';\n    const tw = ctx.measureText(title).width;\n    ctx.fillText(title, WIDTH / 2 - tw / 2, HEIGHT / 2 - 40);\n\n    ctx.font = '20px sans-serif';\n    ctx.fillStyle = '#FFF';\n    const msg = `You collected ${score} batteries and guided the drone safely!`;\n    const mw = ctx.measureText(msg).width;\n    ctx.fillText(msg, WIDTH / 2 - mw / 2, HEIGHT / 2 - 4);\n\n    // restart button\n    const btnText = 'Restart (R)';\n    ctx.font = '18px sans-serif';\n    const bw = ctx.measureText(btnText).width;\n    const btnW = bw + 30;\n    const btnH = 44;\n    const bx = WIDTH / 2 - btnW / 2;\n    const by = HEIGHT / 2 + 20;\n    restartButtonRect = { x: bx, y: by, w: btnW, h: btnH };\n    ctx.fillStyle = '#2B6FE8';\n    drawRoundedRect(ctx, bx, by, btnW, btnH, 10);\n    ctx.fillStyle = '#FFF';\n    ctx.fillText(btnText, bx + (btnW - bw) / 2, by + 28);\n\n    ctx.restore();\n  }\n\n  function drawGameOverScreen() {\n    ctx.save();\n    ctx.fillStyle = 'rgba(60, 0, 0, 0.6)';\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.font = 'bold 36px sans-serif';\n    ctx.fillStyle = '#FFDDD6';\n    const title = 'Game Over';\n    const tw = ctx.measureText(title).width;\n    ctx.fillText(title, WIDTH / 2 - tw / 2, HEIGHT / 2 - 40);\n\n    ctx.font = '20px sans-serif';\n    const msg = `You made ${wrongCount} mistakes. You collected ${score} batteries.`;\n    const mw = ctx.measureText(msg).width;\n    ctx.fillText(msg, WIDTH / 2 - mw / 2, HEIGHT / 2 - 4);\n\n    const btnText = 'Try Again (R)';\n    ctx.font = '18px sans-serif';\n    const bw = ctx.measureText(btnText).width;\n    const btnW = bw + 30;\n    const btnH = 44;\n    const bx = WIDTH / 2 - btnW / 2;\n    const by = HEIGHT / 2 + 20;\n    restartButtonRect = { x: bx, y: by, w: btnW, h: btnH };\n    ctx.fillStyle = '#F2584B';\n    drawRoundedRect(ctx, bx, by, btnW, btnH, 10);\n    ctx.fillStyle = '#FFF';\n    ctx.fillText(btnText, bx + (btnW - bw) / 2, by + 28);\n\n    ctx.restore();\n  }\n\n  // ---------- Init and Start ----------\n  function init() {\n    // show title\n    gameState = 'title';\n    question = null;\n    selectedChoice = 0;\n    // start loop\n    lastTime = performance.now();\n    requestAnimationFrame(update);\n  }\n\n  // start on first user interaction because Chrome requires gesture to start audio\n  let firstInteractionSet = false;\n  function onFirstInteraction() {\n    if (firstInteractionSet) return;\n    firstInteractionSet = true;\n    tryCreateAudioContext();\n    // resume context if suspended\n    if (audioContext && audioContext.state === 'suspended') {\n      audioContext.resume().catch(() => {});\n    }\n  }\n\n  ['click', 'keydown', 'touchstart'].forEach((ev) => {\n    canvas.addEventListener(ev, onFirstInteraction, { once: true, passive: true });\n    window.addEventListener(ev, onFirstInteraction, { once: true, passive: true });\n  });\n\n  // initialize fonts and draw initial frame\n  try {\n    ctx.font = '16px sans-serif';\n  } catch (e) {\n    console.warn('Font setting failed:', e);\n  }\n\n  // Accessibility note drawn textually on canvas and aria-label set earlier\n  init();\n})();\n---\n",
  "improve_response_tokens": 20190,
  "formatted_code": true,
  "formatting_response_tokens": 21107,
  "final_functionality": {
    "score": 12,
    "max_score": 12,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}