{
  "generated_date": "2025-08-30",
  "generated_timestamp": "2025-08-30T00:26:02.224484",
  "model": "gpt-5-mini",
  "theme": "machines",
  "prompt": "You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines\n\nThe game must:\n\u2022 Be beatable.\n\u2022 Use visually calming and interesting and wacky elements.\n\u2022 Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.\n\u2022 Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .\n\u2022 Have a game area exactly 720px wide by 480px tall.\n\u2022 Be written in clean, readable JavaScript with proper formatting, indentation, and comments.\n\u2022 Use modern JavaScript practices and avoid minification.\n\u2022 Include proper error handling for audio and resource loading.\n\u2022 Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.\n\u2022 Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\n\u2022 Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.\n\u2022 Generate all sounds using Web Audio API oscillators and filters.\n\u2022 Include proper error handling for audio context creation.\n\u2022 Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.\n\u2022 Do not wrap the code in ```javascript or any other markdown formatting.",
  "response_tokens": 10090,
  "game_filename": "2025-08-30.js",
  "game_size_bytes": 29718,
  "functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  },
  "dependencies": {
    "has_external_deps": false,
    "issues": [],
    "warnings": [],
    "canvas_methods_used": 6
  },
  "improved_visuals_audio": true,
  "improve_prompt": "You are an expert educational game designer. \nTake the following JavaScript game code and improve ONLY the visuals and audio. \nDo not change the game mechanics or math logic. \nEnhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. \nRender entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).\nHave a game area exactly 720px wide by 480px tall.\nBe written in clean, readable JavaScript with proper formatting, indentation, and comments.\nUse modern JavaScript practices and avoid minification.\nInclude proper error handling for audio and resource loading.\nUse ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.\nCreate all visual elements using canvas drawing methods (rect, arc, fillText, etc.).\nGenerate all sounds using Web Audio API oscillators and filters.\nInclude proper error handling for audio context creation.\nOutput only JavaScript code. No extra explanation, no markdown formatting, no code blocks.\nDo not wrap the code in ```javascript or any other markdown formatting.\n\n---\n(function () {\n  // Machine Math - Canvas Game for ages 7-9\n  // Renders inside element with id \"game-of-the-day-stage\"\n  // Uses Canvas and Web Audio API only (no external assets)\n\n  // Configuration\n  const WIDTH = 720;\n  const HEIGHT = 480;\n  const STAGE_ID = \"game-of-the-day-stage\";\n\n  // Helpers\n  function clamp(v, a, b) {\n    return Math.max(a, Math.min(b, v));\n  }\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n  function pick(arr) {\n    return arr[randInt(0, arr.length - 1)];\n  }\n\n  // Get stage element\n  const stage = document.getElementById(STAGE_ID);\n  if (!stage) {\n    console.error(\"Game stage element not found:\", STAGE_ID);\n    return;\n  }\n  stage.innerHTML = \"\"; // clear\n  stage.style.width = WIDTH + \"px\";\n  stage.style.height = HEIGHT + \"px\";\n  stage.style.position = \"relative\";\n  stage.style.userSelect = \"none\";\n\n  // Create accessible live region for screen readers\n  const live = document.createElement(\"div\");\n  live.setAttribute(\"aria-live\", \"polite\");\n  live.style.position = \"absolute\";\n  live.style.left = \"-9999px\";\n  live.style.width = \"1px\";\n  live.style.height = \"1px\";\n  live.style.overflow = \"hidden\";\n  stage.appendChild(live);\n\n  // Canvas\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = WIDTH;\n  canvas.height = HEIGHT;\n  canvas.setAttribute(\"role\", \"img\");\n  canvas.setAttribute(\"aria-label\", \"Math machine game canvas\");\n  stage.appendChild(canvas);\n  const ctx = canvas.getContext(\"2d\", { alpha: false });\n\n  // Audio setup variables\n  let audioCtx = null;\n  let audioAllowed = false;\n  let bgOsc = null;\n  let bgGain = null;\n  let masterGain = null;\n\n  // Audio creation with error handling\n  async function initAudio() {\n    if (audioCtx) return true;\n    try {\n      audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n      masterGain = audioCtx.createGain();\n      masterGain.gain.value = 0.9;\n      masterGain.connect(audioCtx.destination);\n\n      // Create gentle background hum\n      bgOsc = audioCtx.createOscillator();\n      bgOsc.type = \"sine\";\n      bgOsc.frequency.value = 80; // low hum\n      const bgFilter = audioCtx.createBiquadFilter();\n      bgFilter.type = \"lowpass\";\n      bgFilter.frequency.value = 600;\n      bgGain = audioCtx.createGain();\n      bgGain.gain.value = 0.02; // very gentle\n      bgOsc.connect(bgFilter);\n      bgFilter.connect(bgGain);\n      bgGain.connect(masterGain);\n      bgOsc.start();\n\n      audioAllowed = true;\n      return true;\n    } catch (e) {\n      console.warn(\"Audio initialization failed:\", e && e.message);\n      audioCtx = null;\n      audioAllowed = false;\n      return false;\n    }\n  }\n\n  // Sound utilities\n  function playBeep(success = true) {\n    if (!audioCtx || !audioAllowed) return;\n    try {\n      const now = audioCtx.currentTime;\n      if (!masterGain) return;\n      const osc = audioCtx.createOscillator();\n      const gain = audioCtx.createGain();\n      const filter = audioCtx.createBiquadFilter();\n\n      if (success) {\n        osc.type = \"triangle\";\n        filter.type = \"lowpass\";\n        filter.frequency.value = 1200;\n        osc.frequency.setValueAtTime(600, now);\n        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.18);\n        gain.gain.setValueAtTime(0.0001, now);\n        gain.gain.exponentialRampToValueAtTime(0.12, now + 0.02);\n        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);\n      } else {\n        osc.type = \"sawtooth\";\n        filter.type = \"highpass\";\n        filter.frequency.value = 800;\n        osc.frequency.setValueAtTime(200, now);\n        osc.frequency.exponentialRampToValueAtTime(80, now + 0.18);\n        gain.gain.setValueAtTime(0.0001, now);\n        gain.gain.exponentialRampToValueAtTime(0.15, now + 0.01);\n        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);\n      }\n\n      osc.connect(filter);\n      filter.connect(gain);\n      gain.connect(masterGain);\n\n      osc.start(now);\n      osc.stop(now + 0.45);\n    } catch (e) {\n      console.warn(\"Sound play error:\", e && e.message);\n    }\n  }\n\n  // Game state\n  let running = false;\n  let level = 1;\n  let score = 0;\n  let roundIndex = 0;\n  let attempts = 0;\n  let maxAttempts = 3;\n\n  // Interactive elements: chips, operator gears, slots, buttons\n  const chips = []; // {id,num,x,y,radius,held,selected}\n  const operators = []; // {id,op,x,y,r}\n  const slots = {\n    A: { x: 360 - 110, y: 220, r: 36, content: null },\n    B: { x: 360 + 110, y: 220, r: 36, content: null },\n    operator: { x: 360, y: 160, r: 36, content: null },\n  };\n  const runButton = { x: 360, y: 360, w: 120, h: 44, hot: false };\n  const resetButton = { x: 590, y: 18, w: 110, h: 30 };\n\n  let targetNumber = null;\n  let solution = null; // {a,b,op}\n\n  // Dragging state\n  let dragging = null;\n  let dragOffset = { x: 0, y: 0 };\n\n  // Keyboard focus\n  let focus = { area: \"start\", index: 0 }; // areas: start, chips, ops, run, reset\n\n  // Accessibility announcements\n  function announce(text) {\n    if (!live) return;\n    live.textContent = text;\n  }\n\n  // Utility to generate round ensuring it's solvable\n  function generateRound() {\n    attempts = 0;\n    const opSets = level === 1 ? [\"+\", \"-\"] : level === 2 ? [\"+\", \"-\", \"\u00d7\"] : [\"+\", \"-\", \"\u00d7\"];\n    const maxNum = level === 1 ? 10 : level === 2 ? 12 : 20;\n\n    // Choose two solution numbers and operator, compute target\n    let a = randInt(1, maxNum);\n    let b = randInt(1, maxNum);\n    let op = pick(opSets);\n    // Ensure subtraction non-negative for age appropriateness\n    if (op === \"-\" && a < b) [a, b] = [b, a];\n    const compute = (x, y, o) => (o === \"+\" ? x + y : o === \"-\" ? x - y : x * y);\n    const t = compute(a, b, op);\n\n    targetNumber = t;\n    solution = { a, b, op };\n    // Create chip set including correct numbers and distractors\n    chips.length = 0;\n    const chipNums = new Set([a, b]);\n    while (chipNums.size < 8) {\n      chipNums.add(randInt(1, maxNum));\n    }\n    const arr = Array.from(chipNums);\n    // Shuffle\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    // Place chips on left side in rows\n    const startX = 60;\n    const startY = 100;\n    const gapX = 80;\n    const gapY = 70;\n    arr.forEach((n, i) => {\n      const col = i % 2;\n      const row = Math.floor(i / 2);\n      chips.push({\n        id: i,\n        num: n,\n        x: startX + col * gapX + randInt(-6, 6),\n        y: startY + row * gapY + randInt(-6, 6),\n        r: 28,\n        held: false,\n        originalX: startX + col * gapX,\n        originalY: startY + row * gapY,\n      });\n    });\n\n    // Operators: place 3 operators possibly with duplicates of allowed set\n    operators.length = 0;\n    const opsToShow = opSets.slice(0, 3); // up to 3\n    const opsPos = [{ x: 360 - 120, y: 40 }, { x: 360, y: 40 }, { x: 360 + 120, y: 40 }];\n    for (let i = 0; i < opsToShow.length; i++) {\n      operators.push({\n        id: i,\n        op: opsToShow[i],\n        x: opsPos[i].x,\n        y: opsPos[i].y,\n        r: 30,\n      });\n    }\n\n    // Clear slots\n    slots.A.content = null;\n    slots.B.content = null;\n    slots.operator.content = null;\n\n    roundIndex++;\n    announce(`Round ${roundIndex}. Target number is ${targetNumber}. Choose two numbers and an operator to make ${targetNumber}.`);\n  }\n\n  // Drawing functions\n  function drawBackground() {\n    // Soft gradient\n    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);\n    g.addColorStop(0, \"#f2f6f8\");\n    g.addColorStop(1, \"#e6f0f4\");\n    ctx.fillStyle = g;\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n  }\n\n  function drawCalmPatterns(time) {\n    // Wacky but calming gears in background\n    ctx.save();\n    ctx.globalAlpha = 0.12;\n    const center = { x: 100, y: 420 };\n    for (let i = 0; i < 4; i++) {\n      ctx.beginPath();\n      const r = 28 + i * 18;\n      ctx.strokeStyle = `hsl(${200 + i * 30},60%,60%)`;\n      ctx.lineWidth = 6 - i;\n      ctx.setLineDash([6, 8]);\n      ctx.arc(center.x + i * 40, center.y - i * 20, r, 0, Math.PI * 2);\n      ctx.stroke();\n    }\n    ctx.setLineDash([]);\n    ctx.restore();\n  }\n\n  function drawMachine() {\n    // Draw machine body\n    ctx.save();\n    // base rectangle\n    ctx.fillStyle = \"#dfeef3\";\n    ctx.strokeStyle = \"#b9d6df\";\n    ctx.lineWidth = 2;\n    ctx.fillRect(200, 120, 320, 260);\n    ctx.strokeRect(200, 120, 320, 260);\n\n    // Conveyor belt\n    ctx.fillStyle = \"#c4dbe2\";\n    ctx.fillRect(220, 300, 280, 44);\n    ctx.strokeStyle = \"#9fb7bf\";\n    ctx.strokeRect(220, 300, 280, 44);\n\n    // Two slots\n    Object.keys(slots).forEach((k) => {\n      const s = slots[k];\n      ctx.beginPath();\n      ctx.fillStyle = \"#ffffff\";\n      ctx.strokeStyle = \"#7aa2ab\";\n      ctx.lineWidth = 3;\n      ctx.arc(s.x, s.y, s.r + 4, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n      // inner\n      ctx.beginPath();\n      ctx.fillStyle = \"#f8fdfd\";\n      ctx.arc(s.x, s.y, s.r - 2, 0, Math.PI * 2);\n      ctx.fill();\n    });\n\n    // Draw pipes and connectors\n    ctx.strokeStyle = \"#94c0c7\";\n    ctx.lineWidth = 6;\n    ctx.beginPath();\n    ctx.moveTo(slots.A.x + 36, slots.A.y + 6);\n    ctx.lineTo(320, 260);\n    ctx.lineTo(360, 260);\n    ctx.lineTo(400, 260);\n    ctx.lineTo(slots.B.x - 36, slots.B.y + 6);\n    ctx.stroke();\n\n    // target window\n    ctx.fillStyle = \"#dff3f7\";\n    ctx.fillRect(300, 30, 200, 80);\n    ctx.strokeStyle = \"#9fd0d8\";\n    ctx.strokeRect(300, 30, 200, 80);\n    ctx.fillStyle = \"#064b57\";\n    ctx.font = \"24px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"TARGET\", 400, 58);\n    ctx.font = \"36px sans-serif\";\n    ctx.fillText(String(targetNumber !== null ? targetNumber : \"--\"), 400, 94);\n\n    ctx.restore();\n  }\n\n  function drawChips() {\n    chips.forEach((c, i) => {\n      ctx.save();\n      // playful shape: circle with little eyes\n      ctx.beginPath();\n      ctx.fillStyle = \"#fffbe6\";\n      ctx.strokeStyle = \"#b99b57\";\n      ctx.lineWidth = 2;\n      ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n\n      // stripy pattern\n      ctx.fillStyle = \"rgba(0,0,0,0.03)\";\n      ctx.beginPath();\n      ctx.ellipse(c.x - 6, c.y - 8, c.r * 0.6, c.r * 0.25, 0.2, 0, Math.PI * 2);\n      ctx.fill();\n\n      // eyes\n      ctx.fillStyle = \"#333\";\n      ctx.beginPath();\n      ctx.arc(c.x - 8, c.y - 6, 3, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.beginPath();\n      ctx.arc(c.x + 6, c.y - 6, 3, 0, Math.PI * 2);\n      ctx.fill();\n\n      // number text\n      ctx.fillStyle = \"#2b4f56\";\n      ctx.font = \"20px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(String(c.num), c.x, c.y + 8);\n\n      // focus ring\n      if (focus.area === \"chips\" && focus.index === i) {\n        ctx.strokeStyle = \"#2ba6b4\";\n        ctx.lineWidth = 3;\n        ctx.beginPath();\n        ctx.arc(c.x, c.y, c.r + 4, 0, Math.PI * 2);\n        ctx.stroke();\n      }\n\n      // if held, draw shadow on top\n      if (c.held) {\n        ctx.fillStyle = \"rgba(0,0,0,0.08)\";\n        ctx.beginPath();\n        ctx.ellipse(c.x + 6, c.y + 16, c.r * 0.6, c.r * 0.25, 0, 0, Math.PI * 2);\n        ctx.fill();\n      }\n\n      ctx.restore();\n    });\n  }\n\n  function drawOperators() {\n    operators.forEach((opObj, i) => {\n      ctx.save();\n      // gear circle\n      ctx.beginPath();\n      ctx.fillStyle = \"#fff7f3\";\n      ctx.strokeStyle = \"#d59a7b\";\n      ctx.lineWidth = 2;\n      ctx.arc(opObj.x, opObj.y, opObj.r, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.stroke();\n\n      // little teeth\n      ctx.fillStyle = \"#ffd7c4\";\n      for (let t = 0; t < 8; t++) {\n        const ang = (t / 8) * Math.PI * 2 + (i % 2 ? 0.2 : -0.1);\n        const tx = opObj.x + Math.cos(ang) * (opObj.r + 6);\n        const ty = opObj.y + Math.sin(ang) * (opObj.r + 6);\n        ctx.beginPath();\n        ctx.arc(tx, ty, 4, 0, Math.PI * 2);\n        ctx.fill();\n      }\n\n      ctx.fillStyle = \"#7a3b2f\";\n      ctx.font = \"22px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(opObj.op, opObj.x, opObj.y + 8);\n\n      if (focus.area === \"ops\" && focus.index === i) {\n        ctx.strokeStyle = \"#2ba6b4\";\n        ctx.lineWidth = 3;\n        ctx.beginPath();\n        ctx.arc(opObj.x, opObj.y, opObj.r + 6, 0, Math.PI * 2);\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    });\n  }\n\n  function drawSlotsContent() {\n    // Draw placed numbers or operator symbol inside slots\n    [\"A\", \"B\"].forEach((k) => {\n      const s = slots[k];\n      ctx.save();\n      if (s.content !== null) {\n        ctx.fillStyle = \"#2b4f56\";\n        ctx.font = \"22px sans-serif\";\n        ctx.textAlign = \"center\";\n        ctx.fillText(String(s.content), s.x, s.y + 8);\n      } else {\n        ctx.fillStyle = \"#9fb7bf\";\n        ctx.font = \"14px sans-serif\";\n        ctx.textAlign = \"center\";\n        ctx.fillText(k === \"A\" ? \"Slot A\" : \"Slot B\", s.x, s.y + 6);\n      }\n      ctx.restore();\n    });\n    const so = slots.operator;\n    ctx.save();\n    if (so.content !== null) {\n      ctx.fillStyle = \"#7a3b2f\";\n      ctx.font = \"28px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(String(so.content), so.x, so.y + 10);\n    } else {\n      ctx.fillStyle = \"#7aa2ab\";\n      ctx.font = \"14px sans-serif\";\n      ctx.textAlign = \"center\";\n      ctx.fillText(\"Operator\", so.x, so.y + 6);\n    }\n    ctx.restore();\n  }\n\n  function drawButtons() {\n    // Run button\n    ctx.save();\n    ctx.fillStyle = runButton.hot ? \"#74c2c9\" : \"#a8e1e5\";\n    ctx.strokeStyle = \"#4aa1a9\";\n    ctx.lineWidth = 2;\n    roundRect(ctx, runButton.x - runButton.w / 2, runButton.y - runButton.h / 2, runButton.w, runButton.h, 8, true, true);\n    ctx.fillStyle = \"#05343a\";\n    ctx.font = \"20px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"RUN\", runButton.x, runButton.y + 6);\n\n    // Reset button\n    ctx.fillStyle = \"#ffdede\";\n    ctx.strokeStyle = \"#e59b9b\";\n    ctx.lineWidth = 2;\n    roundRect(ctx, resetButton.x, resetButton.y, resetButton.w, resetButton.h, 6, true, true);\n    ctx.fillStyle = \"#7a2a2a\";\n    ctx.font = \"14px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"Reset\", resetButton.x + resetButton.w / 2, resetButton.y + 20);\n\n    // Audio icon indicator top-right\n    ctx.fillStyle = audioAllowed ? \"#2ba6b4\" : \"#c3c3c3\";\n    ctx.beginPath();\n    ctx.arc(42, 22, 12, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = \"#fff\";\n    ctx.font = \"12px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(audioAllowed ? \"\u266a\" : \"\u00d7\", 42, 26);\n\n    ctx.restore();\n  }\n\n  function drawHUD() {\n    ctx.save();\n    ctx.fillStyle = \"#064b57\";\n    ctx.font = \"16px sans-serif\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(`Level: ${level}`, 18, 28);\n    ctx.fillText(`Score: ${score}`, 18, 48);\n    ctx.fillText(`Attempts left: ${maxAttempts - attempts}`, 18, 68);\n\n    ctx.fillStyle = \"#2b4f56\";\n    ctx.textAlign = \"center\";\n    ctx.font = \"14px sans-serif\";\n    ctx.fillText(\"Drag or use keyboard to place numbers and operator\", WIDTH / 2, HEIGHT - 10);\n    ctx.restore();\n  }\n\n  function roundRect(ctx, x, y, w, h, r, fill, stroke) {\n    if (typeof r === \"number\") {\n      r = { tl: r, tr: r, br: r, bl: r };\n    } else {\n      r = Object.assign({ tl: 0, tr: 0, br: 0, bl: 0 }, r);\n    }\n    ctx.beginPath();\n    ctx.moveTo(x + r.tl, y);\n    ctx.lineTo(x + w - r.tr, y);\n    ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);\n    ctx.lineTo(x + w, y + h - r.br);\n    ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);\n    ctx.lineTo(x + r.bl, y + h);\n    ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);\n    ctx.lineTo(x, y + r.tl);\n    ctx.quadraticCurveTo(x, y, x + r.tl, y);\n    ctx.closePath();\n    if (fill) ctx.fill();\n    if (stroke) ctx.stroke();\n  }\n\n  // Main render\n  function render(time) {\n    // time in ms\n    drawBackground();\n    drawCalmPatterns(time);\n    drawMachine();\n    drawOperators();\n    drawChips();\n    drawSlotsContent();\n    drawButtons();\n    drawHUD();\n  }\n\n  // Hit testing\n  function pointInCircle(px, py, cx, cy, r) {\n    const dx = px - cx;\n    const dy = py - cy;\n    return dx * dx + dy * dy <= r * r;\n  }\n\n  // Mouse and touch events\n  canvas.addEventListener(\"mousedown\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    handlePointerDown(x, y);\n  });\n  canvas.addEventListener(\"mousemove\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    handlePointerMove(x, y);\n  });\n  canvas.addEventListener(\"mouseup\", (e) => {\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    handlePointerUp(x, y);\n  });\n  canvas.addEventListener(\"touchstart\", (e) => {\n    e.preventDefault();\n    const rect = canvas.getBoundingClientRect();\n    const t = e.changedTouches[0];\n    const x = t.clientX - rect.left;\n    const y = t.clientY - rect.top;\n    handlePointerDown(x, y);\n  }, { passive: false });\n  canvas.addEventListener(\"touchmove\", (e) => {\n    e.preventDefault();\n    const rect = canvas.getBoundingClientRect();\n    const t = e.changedTouches[0];\n    const x = t.clientX - rect.left;\n    const y = t.clientY - rect.top;\n    handlePointerMove(x, y);\n  }, { passive: false });\n  canvas.addEventListener(\"touchend\", (e) => {\n    e.preventDefault();\n    const rect = canvas.getBoundingClientRect();\n    const t = e.changedTouches[0];\n    if (!t) { handlePointerUp(0,0); return; }\n    const x = t.clientX - rect.left;\n    const y = t.clientY - rect.top;\n    handlePointerUp(x, y);\n  }, { passive: false });\n\n  // Pointer handlers\n  function handlePointerDown(x, y) {\n    // If start not running, treat as start button press\n    if (!running) {\n      // Start button placed in center - we draw start text on initial screen later\n      startGame();\n      return;\n    }\n    // Check chips\n    for (let i = chips.length - 1; i >= 0; i--) {\n      const c = chips[i];\n      if (pointInCircle(x, y, c.x, c.y, c.r)) {\n        dragging = c;\n        c.held = true;\n        dragOffset.x = x - c.x;\n        dragOffset.y = y - c.y;\n        focus = { area: \"chips\", index: i };\n        return;\n      }\n    }\n    // Check operators\n    for (let i = 0; i < operators.length; i++) {\n      const op = operators[i];\n      if (pointInCircle(x, y, op.x, op.y, op.r)) {\n        // place operator into operator slot\n        slots.operator.content = op.op;\n        focus = { area: \"ops\", index: i };\n        announce(`Operator ${op.op} selected`);\n        return;\n      }\n    }\n    // Check run button\n    if (x >= runButton.x - runButton.w / 2 && x <= runButton.x + runButton.w / 2 &&\n      y >= runButton.y - runButton.h / 2 && y <= runButton.y + runButton.h / 2) {\n      runButton.hot = true;\n      runMachine();\n      return;\n    }\n    // Reset button\n    if (x >= resetButton.x && x <= resetButton.x + resetButton.w &&\n      y >= resetButton.y && y <= resetButton.y + resetButton.h) {\n      resetRound();\n      return;\n    }\n  }\n\n  function handlePointerMove(x, y) {\n    if (dragging) {\n      dragging.x = x - dragOffset.x;\n      dragging.y = y - dragOffset.y;\n    }\n  }\n\n  function handlePointerUp(x, y) {\n    if (dragging) {\n      // Check if over slot A or B\n      if (pointInCircle(x, y, slots.A.x, slots.A.y, slots.A.r + 12)) {\n        slots.A.content = dragging.num;\n        announce(`Placed ${dragging.num} into Slot A`);\n        // return chip to original position (or hide)\n        removeChip(dragging.id);\n      } else if (pointInCircle(x, y, slots.B.x, slots.B.y, slots.B.r + 12)) {\n        slots.B.content = dragging.num;\n        announce(`Placed ${dragging.num} into Slot B`);\n        removeChip(dragging.id);\n      } else {\n        // return to original position\n        dragging.x = dragging.originalX;\n        dragging.y = dragging.originalY;\n        dragging.held = false;\n      }\n      dragging.held = false;\n      dragging = null;\n    }\n    runButton.hot = false;\n  }\n\n  function removeChip(id) {\n    // remove chip from chips array by id (and keep others)\n    const idx = chips.findIndex((c) => c.id === id);\n    if (idx >= 0) chips.splice(idx, 1);\n  }\n\n  // Run the machine: animate and check answer\n  let animating = false;\n  async function runMachine() {\n    if (animating) return;\n    // Need two slots and operator\n    if (slots.A.content === null || slots.B.content === null || slots.operator.content === null) {\n      announce(\"Please place two numbers and choose an operator before running.\");\n      playBeep(false);\n      return;\n    }\n    animating = true;\n    attempts++;\n    announce(\"Running machine...\");\n    // Simple animation: spin and conveyor\n    const startTime = performance.now();\n    const duration = 1000;\n    const initialPositions = chips.map(c => ({ id: c.id, x: c.x, y: c.y }));\n    const from = performance.now();\n    function animFrame(now) {\n      const t = clamp((now - from) / duration, 0, 1);\n      // draw with tempo changes: rotate operator gear, sway conveyor (but we just re-render)\n      render(now);\n      // overlay running effects\n      ctx.save();\n      // steam puffs\n      ctx.fillStyle = `rgba(255,255,255,${0.3 * (1 - t)})`;\n      ctx.beginPath();\n      ctx.arc(360, 100 - t * 20, 16 + t * 10, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n      if (t < 1) {\n        requestAnimationFrame(animFrame);\n      } else {\n        animating = false;\n        evaluateAnswer();\n      }\n    }\n    requestAnimationFrame(animFrame);\n\n    // Play running sound\n    if (audioCtx && audioAllowed) {\n      try {\n        const now = audioCtx.currentTime;\n        const osc = audioCtx.createOscillator();\n        const gain = audioCtx.createGain();\n        osc.type = \"sine\";\n        osc.frequency.setValueAtTime(220, now);\n        osc.frequency.exponentialRampToValueAtTime(120, now + 0.8);\n        gain.gain.setValueAtTime(0.0001, now);\n        gain.gain.exponentialRampToValueAtTime(0.08, now + 0.05);\n        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.9);\n        osc.connect(gain);\n        gain.connect(masterGain);\n        osc.start(now);\n        osc.stop(now + 0.95);\n      } catch (e) {\n        console.warn(\"Run sound error:\", e && e.message);\n      }\n    }\n  }\n\n  function evaluateAnswer() {\n    const a = Number(slots.A.content);\n    const b = Number(slots.B.content);\n    const op = slots.operator.content;\n    const compute = (x, y, o) => (o === \"+\" ? x + y : o === \"-\" ? x - y : x * y);\n    const result = compute(a, b, op);\n    if (result === targetNumber) {\n      score++;\n      announce(`Correct! ${a} ${op} ${b} = ${result}. Well done!`);\n      playBeep(true);\n      // reward animation and next round\n      setTimeout(() => {\n        level = Math.min(3, 1 + Math.floor(score / 3)); // level up every 3 points\n        generateRound();\n      }, 800);\n    } else {\n      playBeep(false);\n      if (attempts >= maxAttempts) {\n        // reveal solution and reset round\n        announce(`Oops, no more attempts. The correct solution was ${solution.a} ${solution.op} ${solution.b} = ${targetNumber}.`);\n        // show solution in slots\n        slots.A.content = solution.a;\n        slots.B.content = solution.b;\n        slots.operator.content = solution.op;\n        // prepare next round after pause\n        setTimeout(() => {\n          generateRound();\n        }, 1600);\n      } else {\n        announce(`Not quite. ${a} ${op} ${b} = ${result}. Try again. Attempts left: ${maxAttempts - attempts}.`);\n      }\n    }\n  }\n\n  // Reset round: return all chips and clear slots\n  function resetRound() {\n    // Recreate chips at original positions and clear slots\n    chips.length = 0;\n    // regenerate round to restore chips\n    generateRound();\n    announce(\"Round reset.\");\n  }\n\n  // Keyboard controls\n  window.addEventListener(\"keydown\", (e) => {\n    if (!running) {\n      if (e.key === \"Enter\" || e.key === \" \") {\n        startGame();\n        e.preventDefault();\n      }\n      return;\n    }\n    const area = focus.area;\n    if (e.key === \"Tab\") {\n      e.preventDefault();\n      // cycle focus: chips -> ops -> run -> reset -> chips ...\n      const order = [\"chips\", \"ops\", \"run\", \"reset\"];\n      let idx = order.indexOf(area);\n      idx = (idx + 1) % order.length;\n      setFocusArea(order[idx], 0);\n      return;\n    }\n    if (area === \"chips\") {\n      if (e.key === \"ArrowRight\") {\n        focus.index = (focus.index + 1) % chips.length;\n        e.preventDefault();\n      } else if (e.key === \"ArrowLeft\") {\n        focus.index = (focus.index - 1 + chips.length) % chips.length;\n        e.preventDefault();\n      } else if (e.key === \"Enter\" || e.key === \" \") {\n        // select chip to place: if slot A empty place in A else in B\n        const c = chips[focus.index];\n        if (!c) return;\n        if (slots.A.content === null) {\n          slots.A.content = c.num;\n          announce(`Placed ${c.num} into Slot A`);\n          removeChip(c.id);\n        } else if (slots.B.content === null) {\n          slots.B.content = c.num;\n          announce(`Placed ${c.num} into Slot B`);\n          removeChip(c.id);\n        } else {\n          announce(\"Both slots are full. Use Reset to try different chips or remove a placed number.\");\n        }\n        e.preventDefault();\n      }\n    } else if (area === \"ops\") {\n      if (e.key === \"ArrowRight\") {\n        focus.index = (focus.index + 1) % operators.length;\n        e.preventDefault();\n      } else if (e.key === \"ArrowLeft\") {\n        focus.index = (focus.index - 1 + operators.length) % operators.length;\n        e.preventDefault();\n      } else if (e.key === \"Enter\" || e.key === \" \") {\n        const op = operators[focus.index];\n        if (op) {\n          slots.operator.content = op.op;\n          announce(`Operator ${op.op} selected`);\n        }\n        e.preventDefault();\n      }\n    } else if (area === \"run\") {\n      if (e.key === \"Enter\" || e.key === \" \") {\n        runMachine();\n        e.preventDefault();\n      } else if (e.key === \"ArrowLeft\") {\n        setFocusArea(\"ops\", 0);\n        e.preventDefault();\n      } else if (e.key === \"ArrowRight\") {\n        setFocusArea(\"reset\", 0);\n        e.preventDefault();\n      }\n    } else if (area === \"reset\") {\n      if (e.key === \"Enter\" || e.key === \" \") {\n        resetRound();\n        e.preventDefault();\n      } else if (e.key === \"ArrowLeft\") {\n        setFocusArea(\"run\", 0);\n        e.preventDefault();\n      }\n    }\n  });\n\n  function setFocusArea(areaName, idx) {\n    focus.area = areaName;\n    focus.index = idx || 0;\n    announce(`Focus on ${areaName}`);\n  }\n\n  // Start screen and start game\n  function drawStartScreen() {\n    drawBackground();\n    ctx.save();\n    ctx.fillStyle = \"#073642\";\n    ctx.font = \"28px sans-serif\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(\"Machine Math\", WIDTH / 2, 80);\n    ctx.font = \"16px sans-serif\";\n    ctx.fillText(\"Build a wacky machine to make the target number!\", WIDTH / 2, 110);\n\n    // Start button\n    ctx.fillStyle = \"#a8e1e5\";\n    ctx.strokeStyle = \"#4aa1a9\";\n    roundRect(ctx, WIDTH / 2 - 90, HEIGHT / 2 - 26, 180, 52, 12, true, true);\n    ctx.fillStyle = \"#05343a\";\n    ctx.font = \"20px sans-serif\";\n    ctx.fillText(\"Click or press Enter to Start\", WIDTH / 2, HEIGHT / 2 + 8);\n\n    // Small instructions\n    ctx.fillStyle = \"#2b4f56\";\n    ctx.font = \"14px sans-serif\";\n    ctx.fillText(\"Drag a number into Slot A and B, choose an operator, then press RUN.\", WIDTH / 2, HEIGHT / 2 + 80);\n    ctx.fillText(\"You can also use the keyboard: Tab to cycle focus, arrows to move, Enter to pick.\", WIDTH / 2, HEIGHT / 2 + 100);\n    ctx.restore();\n  }\n\n  function startGame() {\n    // try to init audio on user gesture\n    initAudio().then((ok) => {\n      if (!ok) {\n        announce(\"Audio unavailable. The game will play silently.\");\n      } else {\n        announce(\"Audio enabled.\");\n      }\n    });\n    running = true;\n    score = 0;\n    level = 1;\n    roundIndex = 0;\n    generateRound();\n    setFocusArea(\"chips\", 0);\n    animate();\n  }\n\n  // Animation loop\n  let raf = null;\n  function animate(time) {\n    render(time);\n    raf = requestAnimationFrame(animate);\n  }\n\n  // Initial draw: start screen\n  drawStartScreen();\n\n  // Initialize by rendering occasionally so start screen visible\n  let startRenderId = requestAnimationFrame(function loop(t) {\n    drawStartScreen();\n    startRenderId = requestAnimationFrame(loop);\n  });\n\n  // Once running, cancel start screen render and run animate\n  const originalStartGame = startGame;\n  startGame = function () {\n    cancelAnimationFrame(startRenderId);\n    originalStartGame();\n  };\n\n  // Safety: ensure audio is handled on page visibility change\n  document.addEventListener(\"visibilitychange\", () => {\n    if (document.hidden && audioCtx && audioCtx.state === \"running\") {\n      audioCtx.suspend().catch(() => { });\n    } else if (audioCtx && audioAllowed && audioCtx.state === \"suspended\") {\n      audioCtx.resume().catch(() => { });\n    }\n  });\n\n  // Error handling for context resume\n  window.addEventListener(\"unhandledrejection\", (e) => {\n    console.warn(\"Unhandled rejection:\", e.reason);\n  });\n\n  // Expose restart via double-click for quick testing (accessible)\n  canvas.addEventListener(\"dblclick\", () => {\n    if (running) {\n      resetRound();\n    }\n  });\n\n  // Ensure the canvas is focusable for keyboard\n  canvas.tabIndex = 0;\n  canvas.style.outline = \"none\";\n  canvas.addEventListener(\"focus\", () => {\n    // show focus hint\n    announce(\"Canvas focused. Use Tab to cycle focus, arrow keys and Enter to control.\");\n  });\n\n  // Provide instructions in live region at load\n  announce(\"Welcome to Machine Math. Click the canvas or press Enter to start the game. Use drag-and-drop or keyboard to place numbers and operator then press Run.\");\n\n})();\n---\n",
  "improve_response_tokens": 21013,
  "formatted_code": true,
  "formatting_response_tokens": 22116,
  "final_functionality": {
    "score": 8,
    "max_score": 8,
    "percentage": 100.0,
    "passing": true,
    "issues": [],
    "warnings": []
  }
}