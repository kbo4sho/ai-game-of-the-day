# Game of the Day - 2025-09-12

## Metadata
- **Generated Date:** 2025-09-12
- **Generated Time:** 2025-09-12T00:26:25.458185
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-12.js
- **File Size:** 35831 bytes
- **Tokens Used:** 11377

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-12.js` - The playable game
- `2025-09-12.meta.json` - Machine-readable metadata
- `2025-09-12.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 24759

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 26071

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Machine Math: Canvas game for ages 7-9
  // Renders inside element with ID 'game-of-the-day-stage'
  // All graphics drawn on canvas. Sounds produced with Web Audio API oscillators.
  // Accessible: keyboard controls, ARIA live text, instructions on canvas, visual audio indicator.
  // Author: AI educational game designer

  // CONFIG
  const WIDTH = 720;
  const HEIGHT = 480;
  const STAGE_ID = "game-of-the-day-stage";
  const MAX_LEVEL = 5;
  const INITIAL_LIVES = 3;

  // UTILITIES
  function clamp(v, a, b) {
    return Math.max(a, Math.min(b, v));
  }

  function randInt(a, b) {
    return Math.floor(Math.random() * (b - a + 1)) + a;
  }

  function choose(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
  }

  // Ensure stage exists
  const stage = document.getElementById(STAGE_ID);
  if (!stage) {
    console.error("Game mount element not found: #" + STAGE_ID);
    return;
  }

  // Clear stage
  stage.innerHTML = "";
  stage.style.position = "relative";

  // Create ARIA live region (for screen readers)
  const ariaStatus = document.createElement("div");
  ariaStatus.setAttribute("role", "status");
  ariaStatus.setAttribute("aria-live", "polite");
  ariaStatus.style.position = "absolute";
  ariaStatus.style.left = "-9999px";
  ariaStatus.style.width = "1px";
  ariaStatus.style.height = "1px";
  ariaStatus.style.overflow = "hidden";
  stage.appendChild(ariaStatus);

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute("tabindex", "0"); // focusable
  canvas.style.outline = "none";
  stage.appendChild(canvas);

  const ctx = canvas.getContext("2d");

  // Setup audio manager
  class AudioManager {
    constructor() {
      this.enabled = false;
      this.ctx = null;
      this.gain = null;
      this.bgOsc = null;
      this.muted = false;
      this.available = false;
      this.init();
    }

    async init() {
      try {
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        if (!AudioCtx) throw new Error("Web Audio API not supported");
        this.ctx = new AudioCtx();
        // create master gain
        this.gain = this.ctx.createGain();
        this.gain.gain.value = 0.12; // gentle
        this.gain.connect(this.ctx.destination);
        // create gentle background hum
        this.bgOsc = this.ctx.createOscillator();
        this.bgOsc.type = "sine";
        this.bgOsc.frequency.value = 110; // low hum
        // create subtle filter for warmth
        const filter = this.ctx.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.value = 800;
        this.bgOsc.connect(filter);
        filter.connect(this.gain);
        this.bgOsc.start();
        this.available = true;
        this.enabled = true;
      } catch (e) {
        console.warn("Audio initialization failed:", e);
        this.available = false;
        this.enabled = false;
      }
    }

    async resumeIfNeeded() {
      if (!this.ctx) return;
      try {
        if (this.ctx.state === "suspended") {
          await this.ctx.resume();
        }
      } catch (e) {
        console.warn("Audio resume failed:", e);
      }
    }

    setMuted(m) {
      this.muted = !!m;
      if (this.gain) {
        this.gain.gain.value = this.muted ? 0 : 0.12;
      }
    }

    // correct chime: rising triad
    playCorrect() {
      if (!this.available || this.muted) return;
      try {
        const now = this.ctx.currentTime;
        const notes = [440, 550, 660];
        notes.forEach((freq, i) => {
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.type = "sine";
          o.frequency.value = freq;
          g.gain.value = 0;
          o.connect(g);
          g.connect(this.gain);
          g.gain.cancelScheduledValues(now);
          g.gain.setValueAtTime(0, now);
          g.gain.linearRampToValueAtTime(0.12, now + 0.02);
          g.gain.linearRampToValueAtTime(0.0001, now + 0.22 + i * 0.05);
          o.start(now + i * 0.05);
          o.stop(now + 0.25 + i * 0.05);
        });
      } catch (e) {
        console.warn("playCorrect error:", e);
      }
    }

    // incorrect buzzer
    playIncorrect() {
      if (!this.available || this.muted) return;
      try {
        const now = this.ctx.currentTime;
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        o.type = "square";
        o.frequency.value = 220;
        filter.type = "lowpass";
        filter.frequency.value = 800;
        g.gain.value = 0.0001;
        o.connect(filter);
        filter.connect(g);
        g.connect(this.gain);
        g.gain.setValueAtTime(0.0001, now);
        g.gain.linearRampToValueAtTime(0.16, now + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.32);
        o.start(now);
        o.stop(now + 0.34);
      } catch (e) {
        console.warn("playIncorrect error:", e);
      }
    }

    // single click sound
    playClick() {
      if (!this.available || this.muted) return;
      try {
        const now = this.ctx.currentTime;
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        o.type = "triangle";
        o.frequency.value = 660;
        g.gain.value = 0.0001;
        o.connect(g);
        g.connect(this.gain);
        g.gain.setValueAtTime(0.0001, now);
        g.gain.linearRampToValueAtTime(0.08, now + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);
        o.start(now);
        o.stop(now + 0.14);
      } catch (e) {
        console.warn("playClick error:", e);
      }
    }

    dispose() {
      try {
        if (this.bgOsc) {
          this.bgOsc.stop();
        }
        if (this.ctx && this.ctx.close) {
          this.ctx.close();
        }
      } catch (e) {
        // ignore
      }
    }
  }

  const audio = new AudioManager();

  // GAME STATE
  let game = {
    level: 1,
    lives: INITIAL_LIVES,
    score: 0,
    target: 0,
    slots: 2,
    cogValues: [],
    selectedCogIndex: null,
    placed: [], // values or null per slot
    draggingIndex: null,
    statusMessage: "Welcome! Click or press Enter to begin.",
    hintUsed: false,
    levelComplete: false,
    finished: false,
    audioEnabled: audio.available,
  };

  // Accessibility helper
  function announce(msg) {
    try {
      ariaStatus.textContent = msg;
    } catch (e) {
      // ignore
    }
  }

  // Generate solvable puzzle for a level
  function generateLevel(level) {
    const slots = clamp(2 + Math.floor((level - 1) / 2), 2, 3); // level 1-2:2, 3-4:3 maybe
    // Set target range based on level
    const minTarget = 5 + (level - 1) * 2;
    const maxTarget = 12 + (level - 1) * 4;
    // We'll choose a combination of 'slots' numbers to form target
    const chosen = [];
    for (let i = 0; i < slots; i++) {
      // pick components to create interesting combos
      chosen.push(randInt(1, Math.max(8, Math.floor(maxTarget / (slots + 1)))));
    }
    // Adjust to make target reachable
    let target = chosen.reduce((a, b) => a + b, 0);
    // Randomly nudge target into the desired range by adding another term if needed
    if (target < minTarget) {
      target += randInt(minTarget - target, Math.max(1, minTarget - target + 3));
    }
    if (target > maxTarget) {
      // reduce some elements
      while (target > maxTarget && chosen.length && Math.random() < 0.8) {
        const i = randInt(0, chosen.length - 1);
        const reduce = randInt(1, Math.floor(chosen[i] / 2) + 1);
        chosen[i] = Math.max(1, chosen[i] - reduce);
        target = chosen.reduce((a, b) => a + b, 0);
      }
      // if still big, set target to something smaller by trimming last
      if (target > maxTarget) {
        target = Math.min(maxTarget, Math.max(minTarget, target));
      }
    }
    // Now create distractor cogs and final cog list
    const totalCogs = 6;
    const cogs = [];
    // Place the chosen numbers among the cogs
    const chosenCopy = chosen.slice();
    while (chosenCopy.length < Math.min(totalCogs, chosen.length + 2)) {
      // sometimes add an extra useful cog
      chosenCopy.push(randInt(1, 9));
    }
    // Fill with left over distractors
    while (cogs.length < totalCogs) {
      if (chosenCopy.length > 0) {
        cogs.push(chosenCopy.pop());
      } else {
        // produce distractor number but avoid exactly making new valid combos accidentally
        cogs.push(randInt(1, Math.max(10, Math.floor(maxTarget / 2))));
      }
    }
    // Shuffle
    for (let i = cogs.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [cogs[i], cogs[j]] = [cogs[j], cogs[i]];
    }
    // Ensure solvable: check if there's a combination of 'slots' from cogs that sum to target
    function existsCombination(nums, k, targetSum) {
      function helper(i, k, sum) {
        if (k === 0) return sum === targetSum;
        if (i >= nums.length) return false;
        // choose
        if (helper(i + 1, k - 1, sum + nums[i])) return true;
        // skip
        return helper(i + 1, k, sum);
      }
      return helper(0, k, 0);
    }
    // If not solvable, forcibly build a solvable set by ensuring chosen slots included
    if (!existsCombination(cogs, slots, target)) {
      // replace first 'slots' elements with chosen numbers that sum to target
      const forced = [];
      // Try to find integer partition of target into 'slots' parts using numbers between 1-12
      if (slots === 2) {
        const a = randInt(1, target - 1);
        forced.push(a, target - a);
      } else {
        // 3 slots
        const a = randInt(1, Math.max(1, Math.floor(target / 3)));
        const b = randInt(1, Math.max(1, Math.floor((target - a) / 2)));
        const c = target - a - b;
        forced.push(a, b, c);
      }
      // Place forced into cogs
      for (let i = 0; i < forced.length && i < cogs.length; i++) {
        cogs[i] = Math.max(1, forced[i]);
      }
    }

    return {
      target: target,
      slots: slots,
      cogs: cogs,
    };
  }

  // Initialize or reset level
  function startLevel(lvl) {
    const data = generateLevel(lvl);
    game.level = lvl;
    game.target = data.target;
    game.slots = data.slots;
    game.cogValues = data.cogs;
    game.selectedCogIndex = null;
    game.placed = new Array(game.slots).fill(null);
    game.draggingIndex = null;
    game.statusMessage = `Level ${lvl}: Make ${game.target} by placing ${game.slots} cog${game.slots > 1 ? "s" : ""}.`;
    game.hintUsed = false;
    game.levelComplete = false;
    game.finished = false;
    announce(game.statusMessage);
  }

  // Draw functions
  function draw() {
    // Clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Background - calming wavy gradient
    const grad = ctx.createLinearGradient(0, 0, WIDTH, HEIGHT);
    grad.addColorStop(0, "#E8F5F9");
    grad.addColorStop(1, "#FFF7EC");
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Draw subtle mechanical pattern: floating gears (simple spirals)
    drawFloatingGears();

    // Panel for machine
    drawMachinePanel();

    // Draw cogs area
    drawCogsArea();

    // Draw HUD: level, lives, score, audio indicator
    drawHUD();

    // Draw instructions and status at bottom
    drawFooter();
  }

  function drawFloatingGears() {
    // Small decorative gears moving slowly
    ctx.save();
    const time = Date.now() / 1500;
    for (let i = 0; i < 6; i++) {
      const x = (i + 1) * 100;
      const y = 60 + Math.sin(time + i) * 10;
      drawGear(x, y, 18 + (i % 3) * 4, (time + i) * 0.8, "#DDEFF3", "#C9E6F2", 0.4);
    }
    ctx.restore();
  }

  function drawGear(x, y, radius, rotation, fillStyle, strokeStyle, alpha = 1) {
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.translate(x, y);
    ctx.rotate(rotation);
    ctx.fillStyle = fillStyle;
    ctx.strokeStyle = strokeStyle;
    ctx.lineWidth = 1.3;
    // gear teeth
    const teeth = 8;
    for (let i = 0; i < teeth; i++) {
      const angle = (i / teeth) * Math.PI * 2;
      const x1 = Math.cos(angle) * radius;
      const y1 = Math.sin(angle) * radius;
      const x2 = Math.cos(angle) * (radius + 6);
      const y2 = Math.sin(angle) * (radius + 6);
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }
    // center circle
    ctx.beginPath();
    ctx.arc(0, 0, radius - 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  function drawMachinePanel() {
    // Machine centered left of center
    const panelX = 120;
    const panelY = 120;
    const panelW = 420;
    const panelH = 220;
    // Outer machine body
    roundRect(ctx, panelX, panelY, panelW, panelH, 18, "#F8F2E6");
    ctx.strokeStyle = "#C7A47A";
    ctx.lineWidth = 2;
    ctx.stroke();

    // Wacky machine face - friendly
    // Eyes
    ctx.fillStyle = "#FFFFFF";
    ctx.beginPath();
    ctx.ellipse(panelX + 100, panelY + 60, 22, 14, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(panelX + 180, panelY + 60, 22, 14, 0, 0, Math.PI * 2);
    ctx.fill();
    // Pupils
    ctx.fillStyle = "#333";
    ctx.beginPath();
    ctx.arc(panelX + 100, panelY + 62, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(panelX + 180, panelY + 62, 6, 0, Math.PI * 2);
    ctx.fill();
    // Smiling mouth
    ctx.strokeStyle = "#8B5E3C";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(panelX + 140, panelY + 110, 36, 0.15 * Math.PI, 0.85 * Math.PI);
    ctx.stroke();

    // Target display (like screen)
    ctx.fillStyle = "#213547";
    ctx.fillRect(panelX + 250, panelY + 24, 120, 52);
    ctx.fillStyle = "#BEE7FF";
    ctx.font = "bold 28px sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("Target", panelX + 310, panelY + 40);
    ctx.font = "bold 44px sans-serif";
    ctx.fillText(game.target.toString(), panelX + 310, panelY + 68);

    // Slots area (where player places cogs)
    const slotStartX = panelX + 50;
    const slotY = panelY + 150;
    const slotGap = 90;
    for (let i = 0; i < game.slots; i++) {
      const sx = slotStartX + i * slotGap;
      // slot background
      ctx.beginPath();
      ctx.fillStyle = "#F0F7FA";
      roundRect(ctx, sx - 28, slotY - 28, 56, 56, 12);
      ctx.fill();
      ctx.strokeStyle = "#B3D6E6";
      ctx.lineWidth = 2;
      ctx.stroke();
      // If placed, draw cog value inside
      const v = game.placed[i];
      if (v !== null && v !== undefined) {
        drawBigCog(sx, slotY, 22, "#FFE9D4", "#FFC78B");
        ctx.fillStyle = "#6A3C12";
        ctx.font = "bold 20px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(v.toString(), sx, slotY + 2);
      } else {
        // empty slot icon
        ctx.fillStyle = "#DDEFF3";
        ctx.beginPath();
        ctx.arc(sx, slotY, 10, 0, Math.PI * 2);
        ctx.fill();
      }
      // highlight if selected and slot empty
      if (game.selectedCogIndex !== null && game.draggingIndex === null) {
        // nothing
      }
    }

    // Machine lever / button
    const buttonX = panelX + 340;
    const buttonY = panelY + 150;
    ctx.fillStyle = "#FFCF6B";
    roundRect(ctx, buttonX - 28, buttonY - 18, 56, 36, 8);
    ctx.fill();
    ctx.strokeStyle = "#C9952E";
    ctx.stroke();
    ctx.fillStyle = "#3B2B1C";
    ctx.font = "bold 16px sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("CHECK", buttonX, buttonY);

    // visual cue for audio enabled
    ctx.fillStyle = game.audioEnabled ? "#A6E3A1" : "#E7A6A6";
    ctx.beginPath();
    ctx.arc(panelX + panelW - 20, panelY + 12, 10, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#2D2D2D";
    ctx.font = "10px sans-serif";
    ctx.textAlign = "right";
    ctx.fillText(game.audioEnabled ? "Audio On" : "Audio Off", panelX + panelW - 28, panelY + 10);
  }

  function drawBigCog(x, y, radius, fillStyle, strokeStyle) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate((Date.now() / 2000) % (Math.PI * 2));
    ctx.fillStyle = fillStyle;
    ctx.strokeStyle = strokeStyle;
    ctx.lineWidth = 2;
    const teeth = 10;
    for (let i = 0; i < teeth; i++) {
      const angle = (i / teeth) * Math.PI * 2;
      const x1 = Math.cos(angle) * radius;
      const y1 = Math.sin(angle) * radius;
      const x2 = Math.cos(angle) * (radius + 6);
      const y2 = Math.sin(angle) * (radius + 6);
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }
    ctx.beginPath();
    ctx.arc(0, 0, radius - 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  function drawCogsArea() {
    const areaX = 40;
    const areaY = 320;
    const areaW = WIDTH - 80;
    const areaH = 130;
    // background
    ctx.fillStyle = "#F4FCFF";
    roundRect(ctx, areaX, areaY, areaW, areaH, 12);
    ctx.fillStyle = "#ECF8FF";
    ctx.strokeStyle = "#CFEAF6";
    ctx.lineWidth = 2;
    ctx.stroke();

    // title
    ctx.fillStyle = "#2B4A5A";
    ctx.font = "18px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText("Cogs (Pick and place onto the machine):", areaX + 12, areaY + 24);

    // Draw cog tokens
    const startX = areaX + 40;
    const startY = areaY + 68;
    const gap = 100;
    for (let i = 0; i < game.cogValues.length; i++) {
      const x = startX + i * gap;
      const y = startY;
      const v = game.cogValues[i];
      const isSelected = game.selectedCogIndex === i || game.draggingIndex === i;
      // If cog already used (placed into slot), draw it faded or hidden
      if (isCogUsed(i)) {
        // draw faded small indicator where used originally
        ctx.globalAlpha = 0.15;
      } else {
        ctx.globalAlpha = 1;
      }
      // highlight border if selected
      drawCogToken(x, y, 32, v, isSelected);
      ctx.globalAlpha = 1;
      // draw keyboard hint (index)
      ctx.fillStyle = "#2D2D2D";
      ctx.font = "12px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText((i + 1).toString(), x + 28, y - 10);
    }

    // Accessibility text: keyboard guide
    ctx.fillStyle = "#2B4A5A";
    ctx.font = "12px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText("Keyboard: ←/→ move, Enter pick/place, H hint, R reset, S toggle sound", areaX + 12, areaY + areaH - 10);
  }

  function drawCogToken(x, y, radius, value, selected) {
    // outer body
    ctx.save();
    ctx.translate(x, y);
    ctx.shadowColor = "rgba(0,0,0,0.08)";
    ctx.shadowBlur = 6;
    ctx.fillStyle = selected ? "#FFEDD7" : "#FFF8F3";
    ctx.beginPath();
    ctx.arc(0, 0, radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = selected ? "#F3B47F" : "#E2C2A4";
    ctx.lineWidth = selected ? 3 : 2;
    ctx.stroke();
    // little gear teeth
    ctx.rotate((Date.now() / 1000 + x) % 10);
    for (let t = 0; t < 8; t++) {
      const a = (t / 8) * Math.PI * 2;
      const x1 = Math.cos(a) * radius;
      const y1 = Math.sin(a) * radius;
      const x2 = Math.cos(a) * (radius + 5);
      const y2 = Math.sin(a) * (radius + 5);
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.strokeStyle = "#ECD0B2";
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    // number
    ctx.fillStyle = "#5A3B1C";
    ctx.font = "bold 20px sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(value.toString(), 0, 0);
    ctx.restore();
  }

  function drawHUD() {
    // Top right info
    ctx.fillStyle = "#2B4A5A";
    ctx.font = "14px sans-serif";
    ctx.textAlign = "right";
    ctx.fillText(`Level: ${game.level} / ${MAX_LEVEL}`, WIDTH - 14, 22);
    ctx.fillText(`Lives: ${game.lives}`, WIDTH - 14, 42);
    ctx.fillText(`Score: ${game.score}`, WIDTH - 14, 62);

    // Visual life hearts
    const heartX = WIDTH - 140;
    for (let i = 0; i < game.lives; i++) {
      drawHeart(heartX + i * 18, 46, 8, "#FF6B6B");
    }
  }

  function drawHeart(x, y, size, color) {
    ctx.save();
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.bezierCurveTo(x, y - size / 2, x - size, y - size / 2, x - size, y + size / 4);
    ctx.bezierCurveTo(x - size, y + size, x, y + size * 1.5, x, y + size * 2);
    ctx.bezierCurveTo(x, y + size * 1.5, x + size, y + size, x + size, y + size / 4);
    ctx.bezierCurveTo(x + size, y - size / 2, x, y - size / 2, x, y);
    ctx.fill();
    ctx.restore();
  }

  function drawFooter() {
    ctx.fillStyle = "#2B4A5A";
    ctx.font = "bold 16px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText(game.statusMessage, 16, HEIGHT - 10);
  }

  // Utility: rounded rectangle
  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }

  // Game logic helpers
  function isCogUsed(index) {
    // A cog is used if its value exists in placed as that particular reference; but there can be duplicates
    // We'll mark used by tracking placedIndices mapping to original index when placing
    return (game._placedIndices && game._placedIndices.includes(index));
  }

  // The placedIndices array stores which cog indices are in slots
  // We'll maintain game._placedIndices in tandem with game.placed
  function placeCogToSlot(cogIndex, slotIndex) {
    if (cogIndex === null || slotIndex === null) return false;
    if (isCogUsed(cogIndex)) return false;
    if (game.placed[slotIndex] !== null) return false;
    game.placed[slotIndex] = game.cogValues[cogIndex];
    game._placedIndices = game._placedIndices || [];
    game._placedIndices[slotIndex] = cogIndex;
    audio.playClick();
    announce(`Placed cog ${cogIndex + 1} with value ${game.cogValues[cogIndex]} into slot ${slotIndex + 1}`);
    return true;
  }

  function removeCogFromSlot(slotIndex) {
    if (slotIndex == null) return false;
    if (game.placed[slotIndex] === null) return false;
    // free index
    if (game._placedIndices) {
      const idx = game._placedIndices[slotIndex];
      game._placedIndices[slotIndex] = null;
    }
    game.placed[slotIndex] = null;
    audio.playClick();
    announce(`Removed from slot ${slotIndex + 1}`);
    return true;
  }

  function checkSolution() {
    // If any slot empty, notify
    for (let i = 0; i < game.slots; i++) {
      if (game.placed[i] === null) {
        game.statusMessage = "Place all cogs before checking.";
        announce(game.statusMessage);
        audio.playIncorrect();
        return false;
      }
    }
    const sum = game.placed.reduce((a, b) => a + b, 0);
    if (sum === game.target) {
      audio.playCorrect();
      game.statusMessage = `Nice! Level ${game.level} complete.`;
      game.score += 10 + (game.hintUsed ? 0 : 5);
      game.levelComplete = true;
      announce(game.statusMessage);
      // advance after short delay
      setTimeout(() => {
        if (game.level >= MAX_LEVEL) {
          game.finished = true;
          game.statusMessage = "You fixed all the machines! Great job!";
          announce(game.statusMessage);
        } else {
          startLevel(game.level + 1);
        }
        draw();
      }, 900);
      return true;
    } else {
      audio.playIncorrect();
      game.lives -= 1;
      if (game.lives <= 0) {
        // reset progress to level 1
        game.statusMessage = "Oh no! The machine stopped. Restarting level.";
        announce(game.statusMessage);
        setTimeout(() => {
          game.lives = INITIAL_LIVES;
          startLevel(1);
          draw();
        }, 1200);
      } else {
        game.statusMessage = `Not quite. The machine output ${sum}. Try again!`;
        // allow player to change placements - maybe clear placed slots or allow swap
        // we'll clear placed slots for simplicity
        game.placed = new Array(game.slots).fill(null);
        game._placedIndices = new Array(game.slots).fill(null);
        announce(game.statusMessage + ` Lives left: ${game.lives}`);
      }
      draw();
      return false;
    }
  }

  function giveHint() {
    // find a valid combination and reveal one slot
    game.hintUsed = true;
    const nums = game.cogValues.slice();
    // Try all combinations
    let found = null;
    function helper(start, k, sum, chosenIndices) {
      if (k === 0) {
        if (sum === game.target) {
          found = chosenIndices.slice();
          return true;
        }
        return false;
      }
      for (let i = start; i <= nums.length - k; i++) {
        if (helper(i + 1, k - 1, sum + nums[i], chosenIndices.concat(i))) return true;
      }
      return false;
    }
    helper(0, game.slots, 0, []);
    if (found && found.length > 0) {
      // place the first value into first empty slot
      let slotToFill = null;
      for (let s = 0; s < game.slots; s++) {
        if (game.placed[s] === null) {
          slotToFill = s;
          break;
        }
      }
      if (slotToFill === null) slotToFill = 0;
      placeCogToSlot(found[0], slotToFill);
      game.statusMessage = "Hint: one cog placed to help you get started.";
      announce(game.statusMessage);
    } else {
      game.statusMessage = "Hmm, I couldn't find a hint. Try a different choice!";
      announce(game.statusMessage);
    }
  }

  // Input handling
  // Map keyboard to selection and actions
  let focusedCog = 0; // for keyboard navigation among cogs

  function handleKey(e) {
    if (game.finished) {
      if (e.key === "r" || e.key === "R") {
        startLevel(1);
      }
      return;
    }
    if (e.key === "ArrowRight") {
      focusedCog = (focusedCog + 1) % game.cogValues.length;
      game.selectedCogIndex = focusedCog;
      audio.playClick();
      announce(`Selected cog ${focusedCog + 1} value ${game.cogValues[focusedCog]}`);
      draw();
      e.preventDefault();
    } else if (e.key === "ArrowLeft") {
      focusedCog = (focusedCog - 1 + game.cogValues.length) % game.cogValues.length;
      game.selectedCogIndex = focusedCog;
      audio.playClick();
      announce(`Selected cog ${focusedCog + 1} value ${game.cogValues[focusedCog]}`);
      draw();
      e.preventDefault();
    } else if (e.key === "Enter") {
      // pick or place depending on selection
      if (game.selectedCogIndex !== null) {
        // try to place to first empty slot
        let placed = false;
        for (let s = 0; s < game.slots; s++) {
          if (game.placed[s] === null) {
            placed = placeCogToSlot(game.selectedCogIndex, s);
            break;
          }
        }
        if (!placed) {
          // maybe remove last placed
          // allow removing from slot using keyboard: ENTER on selected cog removes it from slot if used
          const usedPos = (game._placedIndices || []).indexOf(game.selectedCogIndex);
          if (usedPos >= 0) {
            removeCogFromSlot(usedPos);
          } else {
            game.statusMessage = "That cog is already used or no empty slot.";
            announce(game.statusMessage);
            audio.playIncorrect();
          }
        }
        draw();
      } else {
        // no cog selected -> nothing
        game.statusMessage = "Select a cog first with Left/Right.";
        announce(game.statusMessage);
        audio.playIncorrect();
      }
      e.preventDefault();
    } else if (e.key === "h" || e.key === "H") {
      giveHint();
      draw();
      e.preventDefault();
    } else if (e.key === "r" || e.key === "R") {
      startLevel(game.level);
      draw();
      audio.playClick();
      announce("Level reset.");
      e.preventDefault();
    } else if (e.key === "s" || e.key === "S") {
      // toggle audio
      game.audioEnabled = !game.audioEnabled;
      audio.setMuted(!game.audioEnabled);
      announce(game.audioEnabled ? "Audio enabled" : "Audio disabled");
      draw();
      e.preventDefault();
    } else if (e.key === " ") {
      // space attempts check
      checkSolution();
      draw();
      e.preventDefault();
    } else if (e.key === "Tab") {
      // move selection cycle
      focusedCog = (focusedCog + 1) % game.cogValues.length;
      game.selectedCogIndex = focusedCog;
      draw();
      e.preventDefault();
    }
  }

  // Mouse events: pick cog, drag to slot, click check button
  let mouse = {
    down: false,
    x: 0,
    y: 0,
  };

  function getCogIndexAt(x, y) {
    const areaX = 40;
    const areaY = 320;
    const startX = areaX + 40;
    const startY = areaY + 68;
    const gap = 100;
    for (let i = 0; i < game.cogValues.length; i++) {
      const cx = startX + i * gap;
      const cy = startY;
      const dx = x - cx;
      const dy = y - cy;
      if (dx * dx + dy * dy <= 32 * 32) return i;
    }
    return null;
  }

  function getSlotAt(x, y) {
    const panelX = 120;
    const panelY = 120;
    const slotStartX = panelX + 50;
    const slotY = panelY + 150;
    const slotGap = 90;
    for (let i = 0; i < game.slots; i++) {
      const sx = slotStartX + i * slotGap;
      const sy = slotY;
      const dx = x - sx;
      const dy = y - sy;
      if (dx * dx + dy * dy <= 40 * 40) return i;
    }
    return null;
  }

  function getCheckButtonAt(x, y) {
    const panelX = 120;
    const panelY = 120;
    const buttonX = panelX + 340;
    const buttonY = panelY + 150;
    if (Math.abs(x - buttonX) <= 40 && Math.abs(y - buttonY) <= 24) return true;
    return false;
  }

  canvas.addEventListener("mousedown", (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    mouse.down = true;
    mouse.x = x;
    mouse.y = y;
    // resume audio if suspended
    audio.resumeIfNeeded();

    const cogIdx = getCogIndexAt(x, y);
    if (cogIdx !== null) {
      // if cog is used, remove it instead
      if (isCogUsed(cogIdx)) {
        // find slot
        const slot = (game._placedIndices || []).indexOf(cogIdx);
        if (slot >= 0) {
          removeCogFromSlot(slot);
        }
      } else {
        game.selectedCogIndex = cogIdx;
        game.draggingIndex = cogIdx;
        focusedCog = cogIdx;
        audio.playClick();
        announce(`Picked up cog ${cogIdx + 1}, value ${game.cogValues[cogIdx]}`);
      }
      draw();
      return;
    }
    // click machine check button?
    if (getCheckButtonAt(x, y)) {
      checkSolution();
      draw();
      return;
    }
    // click on slot to remove if present
    const slotIdx = getSlotAt(x, y);
    if (slotIdx !== null) {
      if (game.placed[slotIdx] !== null) {
        removeCogFromSlot(slotIdx);
        draw();
      } else {
        // if selected cog exists, place into this slot
        if (game.selectedCogIndex !== null && !isCogUsed(game.selectedCogIndex)) {
          placeCogToSlot(game.selectedCogIndex, slotIdx);
          draw();
        }
      }
      return;
    }
  });

  canvas.addEventListener("mousemove", (e) => {
    if (!mouse.down) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    mouse.x = x;
    mouse.y = y;
    // visual dragging handled in drawing: store draggingIndex
    draw();
  });

  canvas.addEventListener("mouseup", (e) => {
    mouse.down = false;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    // If dragging a cog, attempt to drop to a slot
    if (game.draggingIndex !== null) {
      const slotIdx = getSlotAt(x, y);
      if (slotIdx !== null) {
        // attempt to place
        const success = placeCogToSlot(game.draggingIndex, slotIdx);
        if (!success) {
          game.statusMessage = "Can't place there.";
          announce(game.statusMessage);
        }
      } else {
        // dropped elsewhere, remain selected but not placed
        game.statusMessage = "Cog returned to its place.";
        announce(game.statusMessage);
      }
      game.draggingIndex = null;
      draw();
    }
  });

  // Click/tap to focus for keyboard controls
  canvas.addEventListener("click", (e) => {
    canvas.focus();
    // resume audio on user gesture
    audio.resumeIfNeeded();
  });

  // Touch support: map to mouse events
  canvas.addEventListener("touchstart", (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;
    mouse.down = true;
    mouse.x = x;
    mouse.y = y;
    const cogIdx = getCogIndexAt(x, y);
    if (cogIdx !== null) {
      if (isCogUsed(cogIdx)) {
        const slot = (game._placedIndices || []).indexOf(cogIdx);
        if (slot >= 0) removeCogFromSlot(slot);
      } else {
        game.selectedCogIndex = cogIdx;
        game.draggingIndex = cogIdx;
        focusedCog = cogIdx;
      }
      draw();
      return;
    }
    if (getCheckButtonAt(x, y)) {
      checkSolution();
      draw();
      return;
    }
  });

  canvas.addEventListener("touchmove", (e) => {
    e.preventDefault();
    if (!mouse.down) return;
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    mouse.x = touch.clientX - rect.left;
    mouse.y = touch.clientY - rect.top;
    draw();
  });

  canvas.addEventListener("touchend", (e) => {
    e.preventDefault();
    mouse.down = false;
    if (game.draggingIndex !== null) {
      // drop at last location
      const x = mouse.x, y = mouse.y;
      const slotIdx = getSlotAt(x, y);
      if (slotIdx !== null) {
        placeCogToSlot(game.draggingIndex, slotIdx);
      }
      game.draggingIndex = null;
      draw();
    }
  });

  window.addEventListener("keydown", handleKey);

  // Main render loop for animations
  function frame() {
    // draw dynamic dragging preview
    // We'll draw the base scene then overlay dragged cog if any
    drawBaseSceneWithDrag();
    requestAnimationFrame(frame);
  }

  function drawBaseSceneWithDrag() {
    // draw everything
    draw();
    // overlay dragging cog
    if (game.draggingIndex !== null && mouse.x !== undefined) {
      const i = game.draggingIndex;
      // draw semi-transparent cog following cursor
      ctx.save();
      ctx.globalAlpha = 0.95;
      drawCogToken(mouse.x, mouse.y, 32, game.cogValues[i], true);
      ctx.restore();
    }
  }

  // Start the game
  function initGame() {
    startLevel(1);
    draw();
    announce("Game ready. Use mouse or keyboard to play. Press S to toggle sound.");
    // Kick off render loop
    requestAnimationFrame(frame);
  }

  // Initialize audio state from manager readiness after small delay (allow init)
  setTimeout(() => {
    if (!audio.available) {
      game.audioEnabled = false;
      game.statusMessage = "Audio is not available in this browser or was blocked. Use S to toggle sound.";
      announce(game.statusMessage);
      draw();
    } else {
      game.audioEnabled = true;
      audio.setMuted(!game.audioEnabled);
      announce("Audio is ready. Click canvas to enable sound if needed.");
    }
  }, 300);

  // Accessibility: click-to-enable audio button displayed graphically inside canvas, but we also provide keyboard S toggle.

  // Error handling for page unloading: dispose audio
  window.addEventListener("beforeunload", () => {
    try {
      audio.dispose();
    } catch (e) {}
  });

  // Kick off
  initGame();
})();
---

