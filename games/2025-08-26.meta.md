# Game of the Day - 2025-08-26

## Metadata
- **Generated Date:** 2025-08-26
- **Generated Time:** 2025-08-26T00:27:57.328774
- **Model:** gpt-5-mini
- **Theme:** electricity
- **Game File:** 2025-08-26.js
- **File Size:** 31380 bytes
- **Tokens Used:** 10187

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** âœ… PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** âœ… NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. Each day, you will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts. Today's theme: electricity

The game must:
â€¢ Be engaging and fun first by having a primary visually interesting game mechanic, age-appropriate, and suitable for early learners.
â€¢ Reinforce the math concept through a real-world narratives tied to theme.
â€¢ Include fun, unique memorable characters tied to the theme.
â€¢ Use visually calming and interesting and wacky elements.
â€¢ Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
â€¢ Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
â€¢ Have a game area exactly 720px wide by 480px tall.
â€¢ Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
â€¢ Use modern JavaScript practices and avoid minification.
â€¢ Include proper error handling for audio and resource loading.
â€¢ Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
â€¢ Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
â€¢ Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
â€¢ Generate all sounds using Web Audio API oscillators and filters.
â€¢ Include proper error handling for audio context creation.
â€¢ Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
â€¢ Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "electricity".

## Files Generated
- `2025-08-26.js` - The playable game
- `2025-08-26.meta.json` - Machine-readable metadata
- `2025-08-26.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 20506

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 20501

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** âœ… PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Electricity Math Game for ages 7-9
// Renders into element with id "game-of-the-day-stage" as a 720x480 canvas
// Uses Web Audio API for sounds. All graphics drawn with canvas.
// Accessible: keyboard controls, canvas ARIA label, visual audio cues, instructions.

(function () {
  'use strict';

  // --- Setup DOM and Canvas ---
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Game container element with id "game-of-the-day-stage" not found.');
    return;
  }
  // Clear container and create canvas
  container.innerHTML = '';
  const canvas = document.createElement('canvas');
  canvas.width = 720;
  canvas.height = 480;
  canvas.tabIndex = 0; // make focusable
  canvas.setAttribute('role', 'img');
  canvas.setAttribute(
    'aria-label',
    'Electricity math game. Drag numbered charges to lamps to match a target. Use mouse or keyboard. Press space to pick up or drop a charge. Click enable sound to play audio.'
  );
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Some constants
  const GAME_W = 720;
  const GAME_H = 480;

  // Accessibility text area (drawn in canvas) - also store messages
  let accessibilityMessage = 'Welcome! Use mouse or keyboard. Press space to pick up/drop charges.';

  // --- Audio Setup with error handling ---
  let audioCtx = null;
  let masterGain = null;
  let backgroundGain = null;
  let soundEnabled = false;
  let bgOsc = null;
  // Simple function to safely create audio context on user gesture
  function tryCreateAudioContext() {
    if (audioCtx) return audioCtx;
    try {
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtx) throw new Error('Web Audio API not supported');
      audioCtx = new AudioCtx();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.9;
      masterGain.connect(audioCtx.destination);

      // Background gentle hum
      backgroundGain = audioCtx.createGain();
      backgroundGain.gain.value = 0.06;
      backgroundGain.connect(masterGain);

      bgOsc = audioCtx.createOscillator();
      bgOsc.type = 'sine';
      bgOsc.frequency.value = 52; // low hum
      const bgLfo = audioCtx.createOscillator();
      bgLfo.type = 'sine';
      bgLfo.frequency.value = 0.2;
      const bgLfoGain = audioCtx.createGain();
      bgLfoGain.gain.value = 6;
      bgOsc.frequency.value = 52;
      bgLfo.connect(bgLfoGain);
      bgLfoGain.connect(bgOsc.frequency);
      bgOsc.connect(backgroundGain);

      bgOsc.start();
      bgLfo.start();

      soundEnabled = true;
    } catch (err) {
      console.warn('Audio initialization failed:', err);
      audioCtx = null;
      soundEnabled = false;
    }
    return audioCtx;
  }

  // envelope helper
  function playTone({ type = 'sine', frequency = 440, duration = 0.2, volume = 0.3, detune = 0 }) {
    if (!audioCtx) return;
    try {
      const o = audioCtx.createOscillator();
      o.type = type;
      o.frequency.value = frequency;
      o.detune.value = detune;
      const g = audioCtx.createGain();
      g.gain.value = 0.0001;
      o.connect(g);
      g.connect(masterGain);
      const now = audioCtx.currentTime;
      g.gain.cancelScheduledValues(now);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(volume, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);
      o.start(now);
      o.stop(now + duration + 0.05);
    } catch (err) {
      console.warn('playTone error', err);
    }
  }

  // Specialized sounds
  function playCorrect() {
    if (!audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const o1 = audioCtx.createOscillator();
      o1.type = 'sine';
      o1.frequency.setValueAtTime(420, now);
      o1.frequency.exponentialRampToValueAtTime(840, now + 0.18);
      const g1 = audioCtx.createGain();
      g1.gain.value = 0.0001;
      o1.connect(g1);
      g1.connect(masterGain);
      g1.gain.exponentialRampToValueAtTime(0.25, now + 0.02);
      g1.gain.exponentialRampToValueAtTime(0.0001, now + 0.3);
      o1.start(now);
      o1.stop(now + 0.35);
    } catch (err) {
      console.warn('playCorrect error', err);
    }
  }
  function playIncorrect() {
    if (!audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      o.type = 'square';
      o.frequency.setValueAtTime(220, now);
      o.frequency.exponentialRampToValueAtTime(80, now + 0.25);
      const g = audioCtx.createGain();
      g.gain.value = 0.0001;
      o.connect(g);
      g.connect(masterGain);
      g.gain.exponentialRampToValueAtTime(0.16, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);
      o.start(now);
      o.stop(now + 0.4);
    } catch (err) {
      console.warn('playIncorrect error', err);
    }
  }
  function playClick() {
    if (!audioCtx) return;
    playTone({ type: 'triangle', frequency: 880, duration: 0.08, volume: 0.06 });
  }

  // --- Game Data & Characters ---
  const characters = {
    spark: { name: 'Spark', desc: 'A tiny zig-zag lightning buddy who giggles when lamps light.' },
    watt: { name: 'Professor Watt', desc: 'A wise glowing bulb owl who asks for exact power.' },
    gigi: { name: 'Gigi the Gizmo', desc: 'A wacky robot helper who hands you charges.' },
  };

  // Lamps: target values and state
  // We'll create 5 lamps with varying targets
  function generateLampTargets() {
    // Simple list between 4 and 12 tailored for ages 7-9
    const list = [5, 7, 9, 6, 10];
    // shuffle a bit
    for (let i = list.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [list[i], list[j]] = [list[j], list[i]];
    }
    return list;
  }
  let lampTargets = generateLampTargets();

  // charges queue - numbers 1..9 randomized
  function generateCharges(count = 8) {
    const arr = [];
    for (let i = 0; i < count; i++) {
      arr.push(1 + Math.floor(Math.random() * 9));
    }
    return arr;
  }

  let charges = generateCharges(9);

  // Charge objects
  const chargeObjects = []; // each with x,y,w,h,num,held,fromQueue,index
  const QUEUE_START_X = 40;
  const QUEUE_START_Y = 360;
  function layoutCharges() {
    chargeObjects.length = 0;
    for (let i = 0; i < charges.length; i++) {
      const num = charges[i];
      const x = QUEUE_START_X + i * 70;
      const y = QUEUE_START_Y;
      chargeObjects.push({
        id: 'c' + i,
        num,
        x,
        y,
        w: 56,
        h: 56,
        held: false,
        homeX: x,
        homeY: y,
      });
    }
  }

  layoutCharges();

  // Lamps positions and states
  const lamps = [];
  function layoutLamps() {
    lamps.length = 0;
    const startX = 80;
    const startY = 80;
    const gapX = 120;
    for (let i = 0; i < lampTargets.length; i++) {
      const x = startX + i * gapX;
      const y = startY;
      lamps.push({
        id: 'L' + i,
        x,
        y,
        w: 96,
        h: 140,
        target: lampTargets[i],
        current: 0,
        filled: false,
        // sockets for charges to snap into visually (we'll allow up to 3 sockets)
        sockets: [
          { dx: -20, dy: 60, occupied: null },
          { dx: 0, dy: 60, occupied: null },
          { dx: 20, dy: 60, occupied: null },
        ],
      });
    }
  }
  layoutLamps();

  // UI state
  let heldCharge = null;
  let pointer = { x: 0, y: 0, isDown: false };
  let score = 0;
  let mistakes = 0;
  let level = 1;
  let lastSparkTime = 0;

  // Keyboard selection state
  let selectedIndex = 0; // index in chargeObjects
  function clampSelected() {
    if (chargeObjects.length === 0) {
      selectedIndex = -1;
      return;
    }
    selectedIndex = Math.max(0, Math.min(chargeObjects.length - 1, selectedIndex));
  }
  clampSelected();

  // Helper: is point in rect
  function pointInRect(px, py, r) {
    return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;
  }

  // Drag & Drop logic
  function pickUpCharge(chg) {
    if (!chg) return;
    heldCharge = chg;
    chg.held = true;
    // bring to top by reordering
    const idx = chargeObjects.indexOf(chg);
    if (idx >= 0) {
      chargeObjects.splice(idx, 1);
      chargeObjects.push(chg);
    }
    accessibilityMessage = `Picked up charge ${chg.num}. Use pointer or arrow keys to move, press space to drop.`;
    if (soundEnabled) playClick();
  }
  function dropChargeAt(x, y) {
    if (!heldCharge) return;
    // snap to nearest socket if within range
    const chg = heldCharge;
    let placed = false;
    for (const lamp of lamps) {
      // check each socket
      for (let si = 0; si < lamp.sockets.length; si++) {
        const s = lamp.sockets[si];
        const sx = lamp.x + lamp.w / 2 + s.dx;
        const sy = lamp.y + s.dy;
        const dx = x - sx;
        const dy = y - sy;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 34 && !s.occupied && !lamp.filled) {
          // Place here
          s.occupied = chg;
          chg.x = sx - chg.w / 2;
          chg.y = sy - chg.h / 2;
          chg.homeX = chg.x;
          chg.homeY = chg.y;
          chg.placedOn = lamp.id;
          // update lamp current
          lamp.current += chg.num;
          placed = true;
          accessibilityMessage = `${characters.watt.name} says: added ${chg.num} charge to lamp needing ${lamp.target}. Current total ${lamp.current}.`;
          if (soundEnabled) playClick();
          // Check lamp status
          checkLamp(lamp);
          break;
        }
      }
      if (placed) break;
    }
    if (!placed) {
      // return to queue spot
      chg.x = chg.homeX;
      chg.y = chg.homeY;
      chg.held = false;
      chg.placedOn = null;
      accessibilityMessage = 'Charge returned to the queue.';
      if (soundEnabled) playClick();
    } else {
      chg.held = false;
      // remove from queue if it was from queue (we will keep it shown but it's now placed)
    }
    heldCharge = null;
  }

  // Check lamp completion or overflows
  function checkLamp(lamp) {
    if (lamp.current === lamp.target) {
      lamp.filled = true;
      score += 10;
      accessibilityMessage = `${characters.spark.name} giggles! Lamp completed! You earned 10 points.`;
      if (soundEnabled) playCorrect();
      // visual spark
      lastSparkTime = performance.now();
      // disable sockets
      for (const s of lamp.sockets) s.occupied = s.occupied; // keep occupied charges
    } else if (lamp.current > lamp.target) {
      // overcharged: flash and return charges
      mistakes += 1;
      accessibilityMessage = `${characters.gigi.name} buzzes! Too much power. Charges will be returned.`;
      if (soundEnabled) playIncorrect();
      // find occupied sockets, return charges back to queue positions
      for (let si = 0; si < lamp.sockets.length; si++) {
        const s = lamp.sockets[si];
        if (s.occupied) {
          const ch = s.occupied;
          // find a free queue spot (we'll place back at rightmost free)
          let freeX = QUEUE_START_X + chargeObjects.indexOf(ch) * 70;
          // We'll simply animate them back home: homeX/homeY pre-existing
          ch.x = ch.homeX;
          ch.y = ch.homeY;
          ch.held = false;
          ch.placedOn = null;
          s.occupied = null;
        }
      }
      lamp.current = 0;
      lamp.filled = false;
    } else {
      // still under target: play small click
      if (soundEnabled) playClick();
    }
  }

  // Reset level
  function resetLevel() {
    lampTargets = generateLampTargets();
    lampTargets.length = 5;
    for (let i = 0; i < lampTargets.length; i++) lampTargets[i] = lampTargets[i] || 5;
    lamps.forEach((l, idx) => {
      l.target = lampTargets[idx];
      l.current = 0;
      l.filled = false;
      for (const s of l.sockets) s.occupied = null;
    });
    charges = generateCharges(9);
    layoutCharges();
    score = 0;
    mistakes = 0;
    accessibilityMessage = 'New challenge! Place charges to match each lamp\'s target power.';
  }

  // --- Input Handling (pointer and keyboard) ---
  // Pointer events
  canvas.addEventListener('pointerdown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const px = e.clientX - rect.left;
    const py = e.clientY - rect.top;
    pointer.isDown = true;
    pointer.x = px;
    pointer.y = py;

    // enable audio if not already
    if (!audioCtx) {
      tryCreateAudioContext();
      if (audioCtx && audioCtx.state === 'suspended') {
        audioCtx.resume().catch(() => {});
      }
      if (soundEnabled) accessibilityMessage = 'Sound enabled. Good luck!';
      else accessibilityMessage = 'Sound not available. Continue playing silently.';
    }

    // If clicked on a charge
    for (let i = chargeObjects.length - 1; i >= 0; i--) {
      const ch = chargeObjects[i];
      if (pointInRect(px, py, ch)) {
        pickUpCharge(ch);
        ch.x = px - ch.w / 2;
        ch.y = py - ch.h / 2;
        return;
      }
    }

    // If clicked on a socket (to remove a charge)
    for (const lamp of lamps) {
      for (const s of lamp.sockets) {
        if (s.occupied) {
          const sx = lamp.x + lamp.w / 2 + s.dx;
          const sy = lamp.y + s.dy;
          const rect = { x: sx - 28, y: sy - 28, w: 56, h: 56 };
          if (px >= rect.x && px <= rect.x + rect.w && py >= rect.y && py <= rect.y + rect.h) {
            // pick up that charge
            const ch = s.occupied;
            s.occupied = null;
            lamp.current -= ch.num;
            ch.held = true;
            heldCharge = ch;
            // set position to mouse
            ch.x = px - ch.w / 2;
            ch.y = py - ch.h / 2;
            accessibilityMessage = `Picked up charge ${ch.num} from lamp.`;
            if (soundEnabled) playClick();
            return;
          }
        }
      }
    }
  });

  canvas.addEventListener('pointermove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const px = e.clientX - rect.left;
    const py = e.clientY - rect.top;
    pointer.x = px;
    pointer.y = py;
    if (heldCharge) {
      heldCharge.x = px - heldCharge.w / 2;
      heldCharge.y = py - heldCharge.h / 2;
    }
  });

  canvas.addEventListener('pointerup', (e) => {
    pointer.isDown = false;
    const rect = canvas.getBoundingClientRect();
    const px = e.clientX - rect.left;
    const py = e.clientY - rect.top;
    if (heldCharge) {
      dropChargeAt(px, py);
    }
  });

  canvas.addEventListener('mouseleave', (e) => {
    pointer.isDown = false;
  });

  // Keyboard controls
  canvas.addEventListener('keydown', (e) => {
    const key = e.key;
    const gridMove = 8;
    if (key === 'ArrowLeft') {
      // if holding, move held object
      if (heldCharge) {
        heldCharge.x -= gridMove;
      } else {
        selectedIndex = Math.max(0, selectedIndex - 1);
        accessibilityMessage = `Selected charge ${chargeObjects[selectedIndex] ? chargeObjects[selectedIndex].num : ''}.`;
      }
      e.preventDefault();
    } else if (key === 'ArrowRight') {
      if (heldCharge) {
        heldCharge.x += gridMove;
      } else {
        selectedIndex = Math.min(chargeObjects.length - 1, selectedIndex + 1);
        accessibilityMessage = `Selected charge ${chargeObjects[selectedIndex] ? chargeObjects[selectedIndex].num : ''}.`;
      }
      e.preventDefault();
    } else if (key === 'ArrowUp') {
      if (heldCharge) heldCharge.y -= gridMove;
      else {
        // move selection up maybe to lamp row for placing
        accessibilityMessage = 'Tip: Press space to pick up the selected charge.';
      }
      e.preventDefault();
    } else if (key === 'ArrowDown') {
      if (heldCharge) heldCharge.y += gridMove;
      e.preventDefault();
    } else if (key === ' ' || key === 'Spacebar') {
      // pick up or drop with space
      e.preventDefault();
      if (!heldCharge && selectedIndex >= 0 && chargeObjects[selectedIndex]) {
        pickUpCharge(chargeObjects[selectedIndex]);
      } else if (heldCharge) {
        // drop at current center of canvas or near selection area
        const dropX = heldCharge.x + heldCharge.w / 2;
        const dropY = heldCharge.y + heldCharge.h / 2;
        dropChargeAt(dropX, dropY);
      }
    } else if (key.toLowerCase() === 'r') {
      // reset level
      resetLevel();
      if (soundEnabled) playTone({ frequency: 330, duration: 0.12, volume: 0.06 });
    } else if (key.toLowerCase() === 's') {
      // toggle sound
      if (!audioCtx) {
        tryCreateAudioContext();
      }
      if (audioCtx) {
        if (audioCtx.state === 'suspended') {
          audioCtx.resume().then(() => {
            soundEnabled = true;
            accessibilityMessage = 'Sound turned on.';
            if (soundEnabled) playClick();
          }).catch(()=>{});
        } else {
          audioCtx.suspend().then(() => {
            soundEnabled = false;
            accessibilityMessage = 'Sound turned off.';
          }).catch(()=>{});
        }
      } else {
        accessibilityMessage = 'Sound unavailable on this device/browser.';
      }
    }
  });

  // Focus canvas for keyboard
  canvas.addEventListener('focus', () => {
    accessibilityMessage = 'Use arrows and space to pick up and place charges. Press R to reset, S to toggle sound.';
  });

  // --- Drawing functions ---
  function drawBackground() {
    // calming gradient background with wacky stars
    const g = ctx.createLinearGradient(0, 0, 0, GAME_H);
    g.addColorStop(0, '#E9F5FF');
    g.addColorStop(1, '#F6FBFF');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, GAME_W, GAME_H);

    // Wacky swirls: simple arcs representing currents
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.strokeStyle = '#9FE8FF';
    ctx.lineWidth = 4;
    for (let i = 0; i < 6; i++) {
      ctx.beginPath();
      const cx = 60 + i * 110;
      ctx.arc(cx, 240 + Math.sin((performance.now() / 1200) + i) * 10, 56, 0, Math.PI * 1.25);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawCharacters() {
    // Draw three characters on left bottom: Spark (zigzag), Watt (owl bulb), Gigi (robot)
    // Spark
    const sx = 30;
    const sy = 420;
    ctx.save();
    ctx.fillStyle = '#FFD24D';
    ctx.strokeStyle = '#FFB400';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(sx, sy - 10);
    ctx.lineTo(sx + 12, sy);
    ctx.lineTo(sx + 4, sy - 2);
    ctx.lineTo(sx + 22, sy + 12);
    ctx.lineTo(sx + 6, sy + 4);
    ctx.lineTo(sx + 16, sy + 18);
    ctx.lineTo(sx - 6, sy + 2);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    // eyes
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.arc(sx + 2, sy - 2, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(sx + 14, sy - 4, 3, 0, Math.PI * 2);
    ctx.fill();
    // label
    ctx.fillStyle = '#444';
    ctx.font = '12px sans-serif';
    ctx.fillText(characters.spark.name, sx - 6, sy + 34);
    ctx.restore();

    // Watt (bulb owl)
    const wx = 110;
    const wy = 410;
    ctx.save();
    // bulb body
    ctx.fillStyle = '#FFF3B0';
    ctx.strokeStyle = '#D3B700';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(wx, wy - 8, 18, 26, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    // owl eyes
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(wx - 6, wy - 14, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(wx + 6, wy - 14, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.arc(wx - 6, wy - 14, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(wx + 6, wy - 14, 3, 0, Math.PI * 2);
    ctx.fill();
    // beak
    ctx.fillStyle = '#FFB400';
    ctx.beginPath();
    ctx.moveTo(wx, wy - 8);
    ctx.lineTo(wx - 6, wy - 2);
    ctx.lineTo(wx + 6, wy - 2);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = '#444';
    ctx.font = '12px sans-serif';
    ctx.fillText(characters.watt.name, wx - 26, wy + 22);
    ctx.restore();

    // Gigi robot
    const gx = 190;
    const gy = 414;
    ctx.save();
    ctx.fillStyle = '#E3F2FF';
    ctx.strokeStyle = '#8AC3FF';
    ctx.lineWidth = 2;
    ctx.fillRect(gx - 14, gy - 24, 28, 28);
    ctx.strokeRect(gx - 14, gy - 24, 28, 28);
    // eye
    ctx.fillStyle = '#333';
    ctx.fillRect(gx - 6, gy - 18, 12, 8);
    // antenna
    ctx.beginPath();
    ctx.moveTo(gx, gy - 24);
    ctx.lineTo(gx, gy - 34);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(gx, gy - 36, 3, 0, Math.PI * 2);
    ctx.fillStyle = '#FFB6C1';
    ctx.fill();
    ctx.fillStyle = '#444';
    ctx.font = '12px sans-serif';
    ctx.fillText(characters.gigi.name, gx - 22, gy + 10);
    ctx.restore();
  }

  function drawLamps(now) {
    // lamps array
    for (const lamp of lamps) {
      ctx.save();
      // lamp body
      ctx.fillStyle = lamp.filled ? '#FFF8C6' : '#FFFFFF';
      ctx.strokeStyle = '#A7C8FF';
      ctx.lineWidth = 2;
      roundRect(ctx, lamp.x, lamp.y, lamp.w, lamp.h, 12, true, true);

      // socket area (glass)
      ctx.fillStyle = '#E8F6FF';
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.ellipse(lamp.x + lamp.w / 2, lamp.y + 36, 34, 28, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // filament or smiley when lit
      if (lamp.filled) {
        // glow
        const fade = Math.max(0, 1 - (now - lastSparkTime) / 800);
        ctx.fillStyle = `rgba(255,220,80,${0.2 + 0.4 * fade})`;
        ctx.beginPath();
        ctx.ellipse(lamp.x + lamp.w / 2, lamp.y + 54, 46, 28, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      // target number
      ctx.fillStyle = '#3A3A3A';
      ctx.font = '18px sans-serif';
      ctx.fillText(`Target: ${lamp.target}`, lamp.x + 12, lamp.y + 22);

      // current number big
      ctx.font = '20px sans-serif';
      ctx.fillStyle = lamp.filled ? '#D86B00' : '#3A3A3A';
      ctx.fillText(`Power: ${lamp.current}`, lamp.x + 12, lamp.y + 46);

      // sockets
      for (let si = 0; si < lamp.sockets.length; si++) {
        const s = lamp.sockets[si];
        const sx = lamp.x + lamp.w / 2 + s.dx;
        const sy = lamp.y + s.dy;
        // socket base
        ctx.fillStyle = '#F0F8FF';
        ctx.strokeStyle = '#9FCBFF';
        ctx.lineWidth = 2;
        roundRect(ctx, sx - 28, sy - 28, 56, 56, 10, true, true);

        // if occupied, draw the charge here
        if (s.occupied) {
          const ch = s.occupied;
          drawCharge(ch, sx - ch.w / 2, sy - ch.h / 2);
        } else {
          // draw placeholder
          ctx.fillStyle = '#EAF6FF';
          ctx.beginPath();
          ctx.arc(sx, sy, 8, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      ctx.restore();
    }
  }

  // draw charge object
  function drawCharge(ch, drawX = null, drawY = null) {
    const x = drawX !== null ? drawX : ch.x;
    const y = drawY !== null ? drawY : ch.y;
    // glow when selected
    ctx.save();
    if (ch.held) {
      ctx.shadowColor = 'rgba(255,255,120,0.8)';
      ctx.shadowBlur = 18;
    } else {
      ctx.shadowColor = 'rgba(0,0,0,0.06)';
      ctx.shadowBlur = 6;
    }
    // charge body (rounded)
    ctx.fillStyle = '#FFF7EC';
    ctx.strokeStyle = '#FFB84D';
    ctx.lineWidth = 2;
    roundRect(ctx, x, y, ch.w, ch.h, 10, true, true);
    // lightning icon
    ctx.fillStyle = '#FF8C00';
    ctx.beginPath();
    ctx.moveTo(x + ch.w / 2 - 6, y + 12);
    ctx.lineTo(x + ch.w / 2 + 4, y + ch.h / 2 - 4);
    ctx.lineTo(x + ch.w / 2 - 2, y + ch.h / 2 - 6);
    ctx.lineTo(x + ch.w / 2 + 8, y + ch.h - 10);
    ctx.lineTo(x + ch.w / 2 - 6, y + ch.h / 2 + 6);
    ctx.lineTo(x + ch.w / 2 - 2, y + ch.h / 2 + 4);
    ctx.closePath();
    ctx.fill();

    // number
    ctx.fillStyle = '#3A3A3A';
    ctx.font = '20px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(ch.num.toString(), x + ch.w / 2, y + ch.h / 2);
    ctx.restore();
  }

  function drawQueue() {
    // header
    ctx.save();
    ctx.fillStyle = '#333';
    ctx.font = '16px sans-serif';
    ctx.fillText('Charge Queue', QUEUE_START_X, QUEUE_START_Y - 24);
    // draw each charge
    for (let i = 0; i < chargeObjects.length; i++) {
      const ch = chargeObjects[i];
      // highlight selected
      if (selectedIndex === i && !ch.held) {
        ctx.save();
        ctx.strokeStyle = '#66C2FF';
        ctx.lineWidth = 3;
        roundRect(ctx, ch.x - 4, ch.y - 4, ch.w + 8, ch.h + 8, 12, false, true);
        ctx.restore();
      }
      if (!ch.placedOn) drawCharge(ch);
      else {
        // If placedOn is not null but still in queue array, show faint
        drawCharge({ ...ch, x: ch.x, y: ch.y, w: ch.w, h: ch.h, held: false });
      }
    }
    ctx.restore();
  }

  function drawHUD() {
    // top right status: score, mistakes, level
    ctx.save();
    ctx.fillStyle = '#48658A';
    ctx.font = '16px sans-serif';
    ctx.fillText(`Score: ${score}`, 560, 28);
    ctx.fillText(`Mistakes: ${mistakes}`, 560, 50);
    ctx.fillText(`Level: ${level}`, 560, 72);

    // audio visual cue
    ctx.fillStyle = soundEnabled ? '#2E8B57' : '#B22222';
    ctx.beginPath();
    ctx.arc(640, 100, 12, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#FFF';
    ctx.font = '12px sans-serif';
    ctx.fillText(soundEnabled ? 'ðŸ”Š' : 'ðŸ”‡', 636, 104);

    ctx.restore();
  }

  function drawInstructions() {
    ctx.save();
    ctx.fillStyle = '#333';
    ctx.font = '14px sans-serif';
    const lines = [
      'Instructions: Drag or keyboard-select a charge and place it into a lamp socket to match the Target power.',
      'If the lamp reaches exactly the target, it lights up! Too much power returns charges and resets that lamp.',
      'Keyboard: â† â†’ select, Space to pick/place, R reset, S toggle sound.',
      'Characters: Spark (lightning), Professor Watt (bulb owl), Gigi the Gizmo (robot).',
    ];
    for (let i = 0; i < lines.length; i++) {
      ctx.fillText(lines[i], 20, 140 + i * 18);
    }
    // accessibility message box
    ctx.fillStyle = '#FFF';
    ctx.strokeStyle = '#D0E8FF';
    ctx.lineWidth = 1;
    roundRect(ctx, 20, 220, 680, 60, 8, true, true);
    ctx.fillStyle = '#333';
    ctx.font = '13px sans-serif';
    ctx.fillText('Status: ' + accessibilityMessage, 28, 248);
    ctx.restore();
  }

  function drawSparkEffects(now) {
    // when lamp completed recently, draw sparks
    if (now - lastSparkTime < 700) {
      const intensity = 1 - (now - lastSparkTime) / 700;
      for (let i = 0; i < 18; i++) {
        const angle = (i / 18) * Math.PI * 2 + (now / 800);
        const r = 18 + Math.random() * 40 * intensity;
        const cx = 360 + Math.cos(angle) * r + Math.sin(now / 200 + i) * 6;
        const cy = 120 + Math.sin(angle * 1.2) * r * 0.6 + Math.cos(now / 250 + i) * 2;
        ctx.beginPath();
        ctx.fillStyle = `rgba(255,${180 + i * 2},20,${0.06 + 0.3 * intensity})`;
        ctx.arc(cx, cy, 4 + Math.random() * 4 * intensity, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  // utility: rounded rectangle
  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    if (typeof r === 'undefined') r = 5;
    if (typeof stroke === 'undefined') stroke = true;
    if (typeof fill === 'undefined') fill = true;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // --- Main Loop ---
  function update(delta) {
    // nothing heavy for now - simple physics for charges if held, hover
    if (!heldCharge) {
      // small bobbing for queue charges
      for (let i = 0; i < chargeObjects.length; i++) {
        const ch = chargeObjects[i];
        if (!ch.placedOn) {
          // bounce slightly
          ch.y = ch.homeY + Math.sin(performance.now() / 400 + i) * 3;
        }
      }
    } else {
      // make sure heldCharge on top
      // already reordering in pickUpCharge
    }
  }

  let lastTime = performance.now();
  function loop(now) {
    const delta = now - lastTime;
    lastTime = now;
    update(delta);

    // Draw everything
    ctx.clearRect(0, 0, GAME_W, GAME_H);
    drawBackground();
    drawCharacters();
    drawLamps(now);
    drawQueue();
    drawHUD();
    drawInstructions();
    drawSparkEffects(now);

    // If selected via keyboard and not held, draw focus ring
    if (selectedIndex >= 0 && chargeObjects[selectedIndex] && !chargeObjects[selectedIndex].held) {
      const ch = chargeObjects[selectedIndex];
      ctx.save();
      ctx.strokeStyle = '#7FD1FF';
      ctx.lineWidth = 2;
      ctx.setLineDash([6, 4]);
      roundRect(ctx, ch.x - 6, ch.y - 6, ch.w + 12, ch.h + 12, 12, false, true);
      ctx.restore();
    }

    // visual cue for audio enable: draw button-like area
    ctx.save();
    ctx.fillStyle = '#FFFFFF';
    ctx.strokeStyle = '#D0E8FF';
    ctx.lineWidth = 1;
    roundRect(ctx, 520, 110, 180, 36, 8, true, true);
    ctx.fillStyle = '#444';
    ctx.font = '14px sans-serif';
    ctx.fillText(soundEnabled ? 'Sound: ON (press S to toggle)' : 'Sound: OFF - click here to enable', 535, 132);
    ctx.restore();

    // pointer represented
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = '#FFFFFF';
    ctx.strokeStyle = '#66C2FF';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(pointer.x, pointer.y, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    requestAnimationFrame(loop);
  }

  // Start main loop
  requestAnimationFrame(loop);

  // Click on the audio text box to enable audio
  canvas.addEventListener('click', (e) => {
    // compute if click was inside audio box
    const rect = canvas.getBoundingClientRect();
    const px = e.clientX - rect.left;
    const py = e.clientY - rect.top;
    if (px >= 520 && px <= 700 && py >= 110 && py <= 146) {
      // toggle or enable
      if (!audioCtx) {
        tryCreateAudioContext();
      }
      if (audioCtx) {
        if (audioCtx.state === 'suspended') {
          audioCtx.resume().then(() => {
            soundEnabled = true;
            accessibilityMessage = 'Sound enabled.';
            playClick();
          }).catch(() => {
            accessibilityMessage = 'Unable to enable sound due to browser restrictions.';
          });
        } else {
          soundEnabled = !soundEnabled;
          accessibilityMessage = soundEnabled ? 'Sound enabled.' : 'Sound disabled.';
          if (soundEnabled) playClick();
        }
      } else {
        accessibilityMessage = 'Sound unavailable on this device/browser.';
      }
    }
  });

  // Expose some functions to the container for assistive tech (debug)
  container.gameApi = {
    reset: resetLevel,
    enableSound: () => {
      tryCreateAudioContext();
      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
      soundEnabled = !!audioCtx;
    },
  };

  // initial vocal accessibility message
  accessibilityMessage = 'Welcome to Spark City! Place the numbered charges into lamp sockets to match each lamp\'s target power.';

  // Make sure errors with AudioContext creation are handled:
  window.addEventListener('unhandledrejection', (ev) => {
    console.warn('Unhandled rejection in game:', ev.reason);
  });
})();
---

