# Game of the Day - 2025-11-14

## Metadata
- **Generated Date:** 2025-11-14
- **Generated Time:** 2025-11-14T00:28:28.972801
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-11-14.js
- **File Size:** 24241 bytes
- **Tokens Used:** 8656

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-11-14.js` - The playable game
- `2025-11-14.meta.json` - Machine-readable metadata
- `2025-11-14.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 17391

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 19134

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Drone Math Rescue - JavaScript Game
// Renders inside element with ID "game-of-the-day-stage"
// Canvas size: 720x480
// No external assets. Sounds generated via Web Audio API oscillators.
// Accessible: keyboard controls, offscreen text alternatives, visual audio cues.
// Clear win/loss: Reach 10 correct answers to win. 3 wrong answers = game over.

// Immediately-invoked function to avoid polluting global scope
(function () {
  // Constants and configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const PADDING = 12; // minimum padding between UI elements
  const GOAL = 10;
  const MAX_WRONG = 3;
  const DRONE_Y = 260;
  const DRONE_COUNT = 3;
  const DRONE_X_SPACING = WIDTH / (DRONE_COUNT + 1);
  const QUESTION_FONT = "26px Arial";
  const INFO_FONT = "18px Arial";
  const BODY_FONT = "16px Arial";
  const BUTTON_FONT = "20px Arial";
  const BATTERY_ICON_RADIUS = 10;

  // Game state
  let stage = document.getElementById("game-of-the-day-stage");
  if (!stage) {
    throw new Error('Missing container element with id "game-of-the-day-stage".');
  }
  stage.style.position = "relative";

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute("role", "img");
  canvas.setAttribute("aria-label", "Drone Math Rescue game. Use number keys 1-3 or click to answer.");
  canvas.style.display = "block";
  canvas.style.outline = "none";
  stage.appendChild(canvas);

  // Offscreen accessible status region for screen readers
  const srStatus = document.createElement("div");
  srStatus.setAttribute("role", "status");
  srStatus.setAttribute("aria-live", "polite");
  srStatus.style.position = "absolute";
  srStatus.style.left = "-9999px";
  srStatus.style.width = "1px";
  srStatus.style.height = "1px";
  stage.appendChild(srStatus);

  const ctx = canvas.getContext("2d");
  if (!ctx) {
    throw new Error("Canvas 2D context not available");
  }

  // Audio setup with error handling
  let audioCtx = null;
  let audioAvailable = false;
  let bgOsc = null;
  let bgGain = null;
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (AudioContext) {
      audioCtx = new AudioContext();
      audioAvailable = true;
    } else {
      audioAvailable = false;
    }
  } catch (e) {
    console.warn("AudioContext unavailable:", e);
    audioAvailable = false;
  }

  function resumeAudioOnGesture() {
    // due to browser policies, resume audio context on user gesture
    if (!audioAvailable || !audioCtx) return;
    if (audioCtx.state === "suspended") {
      audioCtx.resume().catch((e) => {
        console.warn("Audio resume failed:", e);
      });
    }
  }

  // Start gentle background hum
  function startBackgroundHum() {
    if (!audioAvailable || !audioCtx) return;
    stopBackgroundHum();
    try {
      bgOsc = audioCtx.createOscillator();
      const lfo = audioCtx.createOscillator();
      const lfoGain = audioCtx.createGain();
      bgGain = audioCtx.createGain();

      bgOsc.type = "sine";
      bgOsc.frequency.value = 80; // low drone hum
      bgGain.gain.value = 0.02; // gentle

      lfo.type = "sine";
      lfo.frequency.value = 0.15; // slow wobble
      lfoGain.gain.value = 30; // modulate frequency a bit

      lfo.connect(lfoGain);
      lfoGain.connect(bgOsc.frequency);
      bgOsc.connect(bgGain);
      bgGain.connect(audioCtx.destination);

      bgOsc.start();
      lfo.start();
    } catch (e) {
      console.warn("Failed to start background hum:", e);
    }
  }

  function stopBackgroundHum() {
    try {
      if (bgOsc) {
        bgOsc.stop();
        bgOsc.disconnect();
        bgOsc = null;
      }
      if (bgGain) {
        bgGain.disconnect();
        bgGain = null;
      }
    } catch (e) {
      console.warn("Error stopping background hum:", e);
    }
  }

  // Sound effects: correct (pleasant ascending arpeggio), wrong (buzz)
  function playCorrect() {
    if (!audioAvailable || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.08, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);
      g.connect(audioCtx.destination);

      const freqs = [440, 660, 880];
      freqs.forEach((f, i) => {
        const o = audioCtx.createOscillator();
        o.type = "sine";
        o.frequency.value = f;
        o.connect(g);
        o.start(now + i * 0.06);
        o.stop(now + 0.1 + i * 0.06);
      });
    } catch (e) {
      console.warn("playCorrect failed:", e);
    }
  }

  function playWrong() {
    if (!audioAvailable || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "sawtooth";
      o.frequency.setValueAtTime(120, now);
      o.frequency.exponentialRampToValueAtTime(60, now + 0.4);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.08, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);
      o.connect(g);
      g.connect(audioCtx.destination);
      o.start(now);
      o.stop(now + 0.5);
    } catch (e) {
      console.warn("playWrong failed:", e);
    }
  }

  // Utility functions
  function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // Generate a simple math question suitable for ages 7-9
  function generateQuestion() {
    // mix addition, subtraction, and small multiplication occasionally
    const typeRoll = Math.random();
    if (typeRoll < 0.5) {
      // addition within 20
      const a = randomInt(1, 15);
      const b = randomInt(1, Math.max(3, 20 - a));
      return {
        text: `${a} + ${b} = ?`,
        answer: a + b,
      };
    } else if (typeRoll < 0.85) {
      // subtraction without negative
      const a = randomInt(5, 20);
      const b = randomInt(1, Math.min(10, a - 1));
      return {
        text: `${a} - ${b} = ?`,
        answer: a - b,
      };
    } else {
      // small multiplication (2-5)
      const a = randomInt(2, 6);
      const b = randomInt(2, 5);
      return {
        text: `${a} × ${b} = ?`,
        answer: a * b,
      };
    }
  }

  // Game variables
  let correctCount = 0;
  let wrongCount = 0;
  let currentQuestion = null;
  let options = []; // three numbers
  let selectedIndex = 0;
  let animating = []; // animations to draw
  let gameState = "playing"; // "playing", "won", "lost", "menu"
  let soundOn = audioAvailable; // visual indicator and toggle via 'M' key
  let lastActionTime = 0;

  // Positioning for drone options
  function dronePositions() {
    const positions = [];
    for (let i = 1; i <= DRONE_COUNT; i++) {
      const x = DRONE_X_SPACING * i;
      positions.push({ x, y: DRONE_Y });
    }
    return positions;
  }
  const drones = dronePositions();

  // Create initial question
  function nextQuestion() {
    currentQuestion = generateQuestion();
    // create three options: include correct answer and two plausible wrong ones
    const correct = currentQuestion.answer;
    const wrongs = new Set();
    while (wrongs.size < 2) {
      const delta = randomInt(1, Math.max(2, Math.floor(correct / 2) + 2));
      const direction = Math.random() < 0.5 ? -1 : 1;
      let val = correct + direction * delta;
      if (val < 0) val = Math.abs(val) + 1;
      if (val === correct) continue;
      wrongs.add(val);
    }
    const arr = Array.from(wrongs);
    arr.push(correct);
    // shuffle
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    options = arr;
    // selected index default to 0
    selectedIndex = 0;
    announceToSR(`New question: ${currentQuestion.text}`);
  }

  // Accessibility announcements
  function announceToSR(text) {
    try {
      srStatus.innerText = text;
    } catch (e) {
      // ignore
    }
  }

  // Drawing helpers with measured background rectangles to avoid overlap
  function drawTextWithBackground(text, x, y, align = "left", font = BODY_FONT, textColor = "#022", bgColor = "rgba(255,255,255,0.7)", padding = 8) {
    ctx.font = font;
    const metrics = ctx.measureText(text);
    const textWidth = metrics.width;
    const textHeight = parseInt(font, 10) || 16;
    let drawX = x;
    if (align === "center") {
      drawX = x - textWidth / 2;
    } else if (align === "right") {
      drawX = x - textWidth;
    }
    const rectX = drawX - padding / 2;
    const rectY = y - textHeight + -4; // adjust baseline
    const rectW = textWidth + padding;
    const rectH = textHeight + padding / 2;
    // ensure rect within canvas boundaries
    ctx.fillStyle = bgColor;
    roundRect(ctx, rectX, rectY, rectW, rectH, 6, true, false);
    ctx.fillStyle = textColor;
    ctx.textBaseline = "top";
    ctx.fillText(text, drawX, rectY + (padding / 4));
  }

  // Rounded rectangle helper
  function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
    if (typeof radius === "number") {
      radius = { tl: radius, tr: radius, br: radius, bl: radius };
    } else {
      const defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };
      for (const side in defaultRadius) {
        radius[side] = radius[side] || 0;
      }
    }
    ctx.beginPath();
    ctx.moveTo(x + radius.tl, y);
    ctx.lineTo(x + width - radius.tr, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
    ctx.lineTo(x + width, y + height - radius.br);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
    ctx.lineTo(x + radius.bl, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
    ctx.lineTo(x, y + radius.tl);
    ctx.quadraticCurveTo(x, y, x + radius.tl, y);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // Draw calm, wacky background with floating clouds and fun shapes
  function drawBackground(time) {
    // Sky gradient
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, "#eaf6ff");
    g.addColorStop(1, "#e6fff4");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Soft hills
    ctx.fillStyle = "#d7f3e8";
    ctx.beginPath();
    ctx.moveTo(0, HEIGHT * 0.75);
    ctx.quadraticCurveTo(WIDTH * 0.25, HEIGHT * 0.60, WIDTH * 0.5, HEIGHT * 0.75);
    ctx.quadraticCurveTo(WIDTH * 0.75, HEIGHT * 0.90, WIDTH, HEIGHT * 0.75);
    ctx.lineTo(WIDTH, HEIGHT);
    ctx.lineTo(0, HEIGHT);
    ctx.closePath();
    ctx.fill();

    // Floating silly clouds
    const cloudCount = 4;
    for (let i = 0; i < cloudCount; i++) {
      const cx = ((time / 800 + i * 0.3) * 120 + i * 180) % (WIDTH + 160) - 80;
      const cy = 60 + (i % 2) * 30;
      drawCloud(cx, cy, 40 + (i % 3) * 8, `rgba(255,255,255,0.9)`);
    }

    // Wacky wind socks and markers
    ctx.fillStyle = "#fff4e6";
    ctx.strokeStyle = "#ffdca8";
    roundRect(ctx, 10, HEIGHT * 0.6 + 10, 160, 40, 10, true, true);
    ctx.fillStyle = "#ffdca8";
    ctx.font = "14px Arial";
    ctx.textBaseline = "middle";
    ctx.fillText("Drone Rescue Zone: Solve math to collect batteries!", 18, HEIGHT * 0.6 + 30);
  }

  function drawCloud(x, y, size, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x, y, size * 0.6, 0, Math.PI * 2);
    ctx.arc(x + size * 0.6, y - size * 0.1, size * 0.7, 0, Math.PI * 2);
    ctx.arc(x + size * 1.1, y + size * 0.1, size * 0.5, 0, Math.PI * 2);
    ctx.arc(x + size * 0.4, y + size * 0.3, size * 0.55, 0, Math.PI * 2);
    ctx.closePath();
    ctx.fill();
  }

  // Draw a drone at position with option number / label
  function drawDrone(x, y, label, isSelected, index) {
    // Shadow
    ctx.fillStyle = "rgba(0,0,0,0.12)";
    ctx.beginPath();
    ctx.ellipse(x, y + 36, 48, 12, 0, 0, Math.PI * 2);
    ctx.fill();

    // Body
    ctx.fillStyle = isSelected ? "#ffd26a" : "#ffefc0";
    roundRect(ctx, x - 48, y - 20, 96, 44, 12, true, false);

    // Dome
    ctx.fillStyle = isSelected ? "#7ed7ff" : "#aee9ff";
    ctx.beginPath();
    ctx.ellipse(x, y - 8, 32, 22, 0, Math.PI, 0);
    ctx.fill();

    // Propellers (wacky)
    for (let i = -1; i <= 1; i += 2) {
      const px = x + i * 40;
      const py = y - 18;
      ctx.fillStyle = "#ddd";
      ctx.beginPath();
      ctx.ellipse(px, py, 8, 18, i * 0.6, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#bbb";
      ctx.beginPath();
      ctx.ellipse(px + i * 3, py, 4, 10, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    // Face / sticker
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.arc(x - 18, y - 6, 8, 0, Math.PI * 2);
    ctx.fill();

    // Option label on body
    ctx.fillStyle = "#022";
    ctx.font = "bold 18px Arial";
    ctx.textBaseline = "middle";
    const labelText = label.toString();
    const m = ctx.measureText(labelText);
    ctx.fillText(labelText, x - m.width / 2, y + 22 - 8);

    // Small battery icon above returning drones if selected
    if (isSelected) {
      ctx.fillStyle = "#ffb703";
      ctx.beginPath();
      ctx.rect(x + 36, y - 28, 8, 12);
      ctx.fill();
      ctx.fillStyle = "#fff";
      ctx.fillRect(x + 36, y - 28, 2, 12);
    }

    // Index number small
    ctx.font = "14px Arial";
    ctx.fillStyle = "#444";
    ctx.fillText((index + 1).toString(), x - 4, y - 36);
  }

  // Draw UI elements: score top-left, lives top-right, audio indicator top-center, instructions bottom-center
  function drawUI() {
    // Score top-left
    const scoreText = `Batteries: ${correctCount} / ${GOAL}`;
    ctx.font = INFO_FONT;
    const scoreWidth = ctx.measureText(scoreText).width;
    drawTextWithBackground(scoreText, PADDING, PADDING + 6, "left", INFO_FONT, "#023", "rgba(255,255,255,0.85)", 10);

    // Lives / wrong top-right
    const livesText = `Wrong: ${wrongCount} / ${MAX_WRONG}`;
    ctx.font = INFO_FONT;
    const livesWidth = ctx.measureText(livesText).width;
    drawTextWithBackground(livesText, WIDTH - PADDING, PADDING + 6, "right", INFO_FONT, "#023", "rgba(255,255,255,0.85)", 10);

    // Audio indicator top-center
    const audioText = soundOn ? "Sound: ON (press M to mute)" : "Sound: OFF (press M to unmute)";
    ctx.font = "14px Arial";
    drawTextWithBackground(audioText, WIDTH / 2, PADDING + 6, "center", "14px Arial", "#044", "rgba(255,255,255,0.85)", 8);

    // Question area center top
    if (gameState === "playing") {
      const questionText = currentQuestion ? currentQuestion.text : "";
      ctx.font = QUESTION_FONT;
      const metrics = ctx.measureText(questionText);
      drawTextWithBackground(questionText, WIDTH / 2, 120, "center", QUESTION_FONT, "#022", "rgba(255,255,255,0.9)", 12);
    }

    // Instructions bottom-center (keyboard controls)
    const instructions = [
      "Controls: Click a drone or press 1-3 to answer.",
      "Use ← → to change selection, Enter to confirm.",
      "Goal: collect 10 batteries. 3 wrong = game over.",
    ];
    ctx.font = BODY_FONT;
    const lineHeight = 20;
    let baseY = HEIGHT - PADDING - instructions.length * lineHeight - 6;
    for (let i = 0; i < instructions.length; i++) {
      const text = instructions[i];
      drawTextWithBackground(text, WIDTH / 2, baseY + i * lineHeight, "center", BODY_FONT, "#043", "rgba(255,255,255,0.9)", 12);
    }
  }

  // Animation tick and rendering
  let lastTime = performance.now();
  function gameLoop(time) {
    const dt = time - lastTime;
    lastTime = time;

    // Clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Background and scenery
    drawBackground(time);

    // UI and question/drones
    drawUI();

    // Drones and options
    for (let i = 0; i < DRONE_COUNT; i++) {
      const pos = drones[i];
      const label = options[i] !== undefined ? options[i] : "";
      const isSel = selectedIndex === i && gameState === "playing";
      drawDrone(pos.x, pos.y, label, isSel, i);
    }

    // Animating floating collected batteries
    const now = performance.now();
    animating = animating.filter((a) => {
      const t = (now - a.start) / a.duration;
      if (t >= 1) return false;
      // draw
      const alpha = 1 - t;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = "#ffb703";
      ctx.beginPath();
      ctx.arc(a.x, a.y - t * 80, 10 + t * 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      return true;
    });

    // Draw victory/loss overlays if needed
    if (gameState === "won") {
      drawEndScreen("Victory! Drones saved the batteries!", "You collected all batteries!", "#d6f6e0");
    } else if (gameState === "lost") {
      drawEndScreen("Game Over", "Too many wrong answers. Try again!", "#ffe6e6");
    }

    // Loop
    if (gameState !== "menu") {
      requestAnimationFrame(gameLoop);
    }
  }

  function drawEndScreen(title, subtitle, bgColor) {
    ctx.fillStyle = bgColor;
    roundRect(ctx, WIDTH * 0.1, HEIGHT * 0.2, WIDTH * 0.8, HEIGHT * 0.55, 14, true, false);

    // Title
    ctx.fillStyle = "#023";
    ctx.font = "28px Arial";
    const titleY = HEIGHT * 0.32;
    drawTextWithBackground(title, WIDTH / 2, titleY, "center", "28px Arial", "#023", "rgba(255,255,255,0)", 12);

    // Subtitle
    ctx.font = "20px Arial";
    const subY = HEIGHT * 0.4;
    drawTextWithBackground(subtitle, WIDTH / 2, subY, "center", "20px Arial", "#033", "rgba(255,255,255,0)", 12);

    // Stats
    ctx.font = BODY_FONT;
    drawTextWithBackground(`Batteries: ${correctCount} / ${GOAL}`, WIDTH / 2, HEIGHT * 0.48, "center", BODY_FONT, "#023", "rgba(255,255,255,0)", 12);
    drawTextWithBackground(`Wrong answers: ${wrongCount} / ${MAX_WRONG}`, WIDTH / 2, HEIGHT * 0.52, "center", BODY_FONT, "#023", "rgba(255,255,255,0)", 12);

    // Restart button
    const btnW = 220;
    const btnH = 48;
    const btnX = WIDTH / 2 - btnW / 2;
    const btnY = HEIGHT * 0.62;
    ctx.fillStyle = "#6fcf97";
    roundRect(ctx, btnX, btnY, btnW, btnH, 10, true, false);
    ctx.fillStyle = "#022";
    ctx.font = BUTTON_FONT;
    ctx.textBaseline = "middle";
    const btnText = "Restart (R or Enter)";
    const bw = ctx.measureText(btnText).width;
    ctx.fillText(btnText, WIDTH / 2 - bw / 2, btnY + btnH / 2 - 2);

    // Instruction to press keys
    ctx.font = "14px Arial";
    drawTextWithBackground("Press R or click the button to play again. Press M to toggle sound.", WIDTH / 2, btnY + btnH + 36, "center", "14px Arial", "#033", "rgba(255,255,255,0)", 10);
  }

  // Input handling
  function onCanvasClick(e) {
    resumeAudioOnGesture();
    if (gameState === "won" || gameState === "lost") {
      // Check if click on restart button
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const btnW = 220;
      const btnH = 48;
      const btnX = WIDTH / 2 - btnW / 2;
      const btnY = HEIGHT * 0.62;
      if (mx >= btnX && mx <= btnX + btnW && my >= btnY && my <= btnY + btnH) {
        restartGame();
      }
      return;
    }

    if (gameState !== "playing") return;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    // Check drone hitboxes
    for (let i = 0; i < DRONE_COUNT; i++) {
      const d = drones[i];
      const dx = mx - d.x;
      const dy = my - d.y;
      if (dx * dx + dy * dy <= 48 * 48) {
        // clicked drone i
        handleAnswer(i);
        break;
      }
    }
  }

  function handleAnswer(i) {
    if (gameState !== "playing") return;
    selectedIndex = i;
    const chosen = options[i];
    if (chosen === currentQuestion.answer) {
      // Correct
      correctCount++;
      animating.push({
        start: performance.now(),
        duration: 900,
        x: drones[i].x,
        y: drones[i].y - 10,
      });
      if (soundOn) playCorrect();
      announceToSR(`Correct! ${currentQuestion.text} = ${chosen}. Batteries collected ${correctCount} of ${GOAL}.`);
      if (correctCount >= GOAL) {
        gameState = "won";
        announceToSR("You won! Press R to play again.");
        stopBackgroundHum();
      } else {
        nextQuestion();
      }
    } else {
      // Wrong
      wrongCount++;
      if (soundOn) playWrong();
      announceToSR(`Oops! ${chosen} is not correct. Wrong count ${wrongCount} of ${MAX_WRONG}.`);
      // small shake animation: track as animating with negative movement
      animating.push({
        start: performance.now(),
        duration: 600,
        x: drones[i].x,
        y: drones[i].y,
        shake: true,
      });
      if (wrongCount >= MAX_WRONG) {
        gameState = "lost";
        announceToSR("Game over. Too many wrong answers. Press R to try again.");
        stopBackgroundHum();
      } else {
        // present new question after a brief delay
        setTimeout(() => {
          nextQuestion();
        }, 600);
      }
    }
    lastActionTime = performance.now();
  }

  function onKeyDown(e) {
    resumeAudioOnGesture();
    if (gameState === "won" || gameState === "lost") {
      if (e.key === "r" || e.key === "R" || e.key === "Enter") {
        restartGame();
      }
      if (e.key === "m" || e.key === "M") {
        toggleSound();
      }
      return;
    }

    if (gameState !== "playing") return;

    if (e.key === "ArrowRight") {
      selectedIndex = (selectedIndex + 1) % DRONE_COUNT;
      announceToSR(`Selected option ${selectedIndex + 1}: ${options[selectedIndex]}`);
    } else if (e.key === "ArrowLeft") {
      selectedIndex = (selectedIndex - 1 + DRONE_COUNT) % DRONE_COUNT;
      announceToSR(`Selected option ${selectedIndex + 1}: ${options[selectedIndex]}`);
    } else if (e.key === "1" || e.key === "2" || e.key === "3") {
      const idx = parseInt(e.key, 10) - 1;
      handleAnswer(idx);
    } else if (e.key === "Enter") {
      handleAnswer(selectedIndex);
    } else if (e.key === "m" || e.key === "M") {
      toggleSound();
    }
  }

  function toggleSound() {
    soundOn = !soundOn;
    announceToSR(soundOn ? "Sound on" : "Sound off");
    if (soundOn) {
      if (!audioAvailable) {
        announceToSR("Audio not available in this browser.");
      } else {
        startBackgroundHum();
      }
    } else {
      stopBackgroundHum();
    }
  }

  // Restart game
  function restartGame() {
    correctCount = 0;
    wrongCount = 0;
    gameState = "playing";
    // reset question and start hum
    nextQuestion();
    if (soundOn && audioAvailable) startBackgroundHum();
    announceToSR("Game restarted. Good luck!");
    // restart loop
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
  }

  // Initialize input listeners
  canvas.addEventListener("click", onCanvasClick);
  window.addEventListener("keydown", onKeyDown);

  // Make canvas keyboard-focusable for accessibility
  canvas.tabIndex = 0;
  canvas.addEventListener("focus", () => {
    // Show hint in screen reader
    announceToSR("Canvas focused. Use number keys or click to answer.");
  });

  // Start the game initially
  function init() {
    try {
      nextQuestion();
      if (soundOn && audioAvailable) {
        startBackgroundHum();
      }
      // Kick off rendering
      lastTime = performance.now();
      requestAnimationFrame(gameLoop);
      announceToSR("Welcome to Drone Math Rescue! Answer questions to collect batteries.");
    } catch (e) {
      console.error("Initialization failed:", e);
      ctx.clearRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      drawTextWithBackground("An error occurred while loading the game.", WIDTH / 2, HEIGHT / 2 - 20, "center", "18px Arial", "#900", "rgba(255,255,255,0.9)", 12);
      drawTextWithBackground("Please reload the page.", WIDTH / 2, HEIGHT / 2 + 16, "16px Arial", "center", "#900", "rgba(255,255,255,0.9)", 12);
      announceToSR("Game could not be loaded. Please reload the page.");
    }
  }

  // Expose a friendly control to ensure audio resumes on mobile when tapping anywhere in the stage
  stage.addEventListener("pointerdown", () => {
    resumeAudioOnGesture();
  }, { once: true });

  init();
})();
---

