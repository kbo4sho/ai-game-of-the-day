# Game of the Day - 2025-08-30

## Metadata
- **Generated Date:** 2025-08-30
- **Generated Time:** 2025-08-30T00:26:02.224484
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-08-30.js
- **File Size:** 29718 bytes
- **Tokens Used:** 10090

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-08-30.js` - The playable game
- `2025-08-30.meta.json` - Machine-readable metadata
- `2025-08-30.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 21013

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 22116

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Machine Math - Canvas Game for ages 7-9
  // Renders inside element with id "game-of-the-day-stage"
  // Uses Canvas and Web Audio API only (no external assets)

  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const STAGE_ID = "game-of-the-day-stage";

  // Helpers
  function clamp(v, a, b) {
    return Math.max(a, Math.min(b, v));
  }
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  function pick(arr) {
    return arr[randInt(0, arr.length - 1)];
  }

  // Get stage element
  const stage = document.getElementById(STAGE_ID);
  if (!stage) {
    console.error("Game stage element not found:", STAGE_ID);
    return;
  }
  stage.innerHTML = ""; // clear
  stage.style.width = WIDTH + "px";
  stage.style.height = HEIGHT + "px";
  stage.style.position = "relative";
  stage.style.userSelect = "none";

  // Create accessible live region for screen readers
  const live = document.createElement("div");
  live.setAttribute("aria-live", "polite");
  live.style.position = "absolute";
  live.style.left = "-9999px";
  live.style.width = "1px";
  live.style.height = "1px";
  live.style.overflow = "hidden";
  stage.appendChild(live);

  // Canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute("role", "img");
  canvas.setAttribute("aria-label", "Math machine game canvas");
  stage.appendChild(canvas);
  const ctx = canvas.getContext("2d", { alpha: false });

  // Audio setup variables
  let audioCtx = null;
  let audioAllowed = false;
  let bgOsc = null;
  let bgGain = null;
  let masterGain = null;

  // Audio creation with error handling
  async function initAudio() {
    if (audioCtx) return true;
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.9;
      masterGain.connect(audioCtx.destination);

      // Create gentle background hum
      bgOsc = audioCtx.createOscillator();
      bgOsc.type = "sine";
      bgOsc.frequency.value = 80; // low hum
      const bgFilter = audioCtx.createBiquadFilter();
      bgFilter.type = "lowpass";
      bgFilter.frequency.value = 600;
      bgGain = audioCtx.createGain();
      bgGain.gain.value = 0.02; // very gentle
      bgOsc.connect(bgFilter);
      bgFilter.connect(bgGain);
      bgGain.connect(masterGain);
      bgOsc.start();

      audioAllowed = true;
      return true;
    } catch (e) {
      console.warn("Audio initialization failed:", e && e.message);
      audioCtx = null;
      audioAllowed = false;
      return false;
    }
  }

  // Sound utilities
  function playBeep(success = true) {
    if (!audioCtx || !audioAllowed) return;
    try {
      const now = audioCtx.currentTime;
      if (!masterGain) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();

      if (success) {
        osc.type = "triangle";
        filter.type = "lowpass";
        filter.frequency.value = 1200;
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.18);
        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(0.12, now + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);
      } else {
        osc.type = "sawtooth";
        filter.type = "highpass";
        filter.frequency.value = 800;
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(80, now + 0.18);
        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(0.15, now + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);
      }

      osc.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);

      osc.start(now);
      osc.stop(now + 0.45);
    } catch (e) {
      console.warn("Sound play error:", e && e.message);
    }
  }

  // Game state
  let running = false;
  let level = 1;
  let score = 0;
  let roundIndex = 0;
  let attempts = 0;
  let maxAttempts = 3;

  // Interactive elements: chips, operator gears, slots, buttons
  const chips = []; // {id,num,x,y,radius,held,selected}
  const operators = []; // {id,op,x,y,r}
  const slots = {
    A: { x: 360 - 110, y: 220, r: 36, content: null },
    B: { x: 360 + 110, y: 220, r: 36, content: null },
    operator: { x: 360, y: 160, r: 36, content: null },
  };
  const runButton = { x: 360, y: 360, w: 120, h: 44, hot: false };
  const resetButton = { x: 590, y: 18, w: 110, h: 30 };

  let targetNumber = null;
  let solution = null; // {a,b,op}

  // Dragging state
  let dragging = null;
  let dragOffset = { x: 0, y: 0 };

  // Keyboard focus
  let focus = { area: "start", index: 0 }; // areas: start, chips, ops, run, reset

  // Accessibility announcements
  function announce(text) {
    if (!live) return;
    live.textContent = text;
  }

  // Utility to generate round ensuring it's solvable
  function generateRound() {
    attempts = 0;
    const opSets = level === 1 ? ["+", "-"] : level === 2 ? ["+", "-", "×"] : ["+", "-", "×"];
    const maxNum = level === 1 ? 10 : level === 2 ? 12 : 20;

    // Choose two solution numbers and operator, compute target
    let a = randInt(1, maxNum);
    let b = randInt(1, maxNum);
    let op = pick(opSets);
    // Ensure subtraction non-negative for age appropriateness
    if (op === "-" && a < b) [a, b] = [b, a];
    const compute = (x, y, o) => (o === "+" ? x + y : o === "-" ? x - y : x * y);
    const t = compute(a, b, op);

    targetNumber = t;
    solution = { a, b, op };
    // Create chip set including correct numbers and distractors
    chips.length = 0;
    const chipNums = new Set([a, b]);
    while (chipNums.size < 8) {
      chipNums.add(randInt(1, maxNum));
    }
    const arr = Array.from(chipNums);
    // Shuffle
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    // Place chips on left side in rows
    const startX = 60;
    const startY = 100;
    const gapX = 80;
    const gapY = 70;
    arr.forEach((n, i) => {
      const col = i % 2;
      const row = Math.floor(i / 2);
      chips.push({
        id: i,
        num: n,
        x: startX + col * gapX + randInt(-6, 6),
        y: startY + row * gapY + randInt(-6, 6),
        r: 28,
        held: false,
        originalX: startX + col * gapX,
        originalY: startY + row * gapY,
      });
    });

    // Operators: place 3 operators possibly with duplicates of allowed set
    operators.length = 0;
    const opsToShow = opSets.slice(0, 3); // up to 3
    const opsPos = [{ x: 360 - 120, y: 40 }, { x: 360, y: 40 }, { x: 360 + 120, y: 40 }];
    for (let i = 0; i < opsToShow.length; i++) {
      operators.push({
        id: i,
        op: opsToShow[i],
        x: opsPos[i].x,
        y: opsPos[i].y,
        r: 30,
      });
    }

    // Clear slots
    slots.A.content = null;
    slots.B.content = null;
    slots.operator.content = null;

    roundIndex++;
    announce(`Round ${roundIndex}. Target number is ${targetNumber}. Choose two numbers and an operator to make ${targetNumber}.`);
  }

  // Drawing functions
  function drawBackground() {
    // Soft gradient
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, "#f2f6f8");
    g.addColorStop(1, "#e6f0f4");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
  }

  function drawCalmPatterns(time) {
    // Wacky but calming gears in background
    ctx.save();
    ctx.globalAlpha = 0.12;
    const center = { x: 100, y: 420 };
    for (let i = 0; i < 4; i++) {
      ctx.beginPath();
      const r = 28 + i * 18;
      ctx.strokeStyle = `hsl(${200 + i * 30},60%,60%)`;
      ctx.lineWidth = 6 - i;
      ctx.setLineDash([6, 8]);
      ctx.arc(center.x + i * 40, center.y - i * 20, r, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.setLineDash([]);
    ctx.restore();
  }

  function drawMachine() {
    // Draw machine body
    ctx.save();
    // base rectangle
    ctx.fillStyle = "#dfeef3";
    ctx.strokeStyle = "#b9d6df";
    ctx.lineWidth = 2;
    ctx.fillRect(200, 120, 320, 260);
    ctx.strokeRect(200, 120, 320, 260);

    // Conveyor belt
    ctx.fillStyle = "#c4dbe2";
    ctx.fillRect(220, 300, 280, 44);
    ctx.strokeStyle = "#9fb7bf";
    ctx.strokeRect(220, 300, 280, 44);

    // Two slots
    Object.keys(slots).forEach((k) => {
      const s = slots[k];
      ctx.beginPath();
      ctx.fillStyle = "#ffffff";
      ctx.strokeStyle = "#7aa2ab";
      ctx.lineWidth = 3;
      ctx.arc(s.x, s.y, s.r + 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      // inner
      ctx.beginPath();
      ctx.fillStyle = "#f8fdfd";
      ctx.arc(s.x, s.y, s.r - 2, 0, Math.PI * 2);
      ctx.fill();
    });

    // Draw pipes and connectors
    ctx.strokeStyle = "#94c0c7";
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(slots.A.x + 36, slots.A.y + 6);
    ctx.lineTo(320, 260);
    ctx.lineTo(360, 260);
    ctx.lineTo(400, 260);
    ctx.lineTo(slots.B.x - 36, slots.B.y + 6);
    ctx.stroke();

    // target window
    ctx.fillStyle = "#dff3f7";
    ctx.fillRect(300, 30, 200, 80);
    ctx.strokeStyle = "#9fd0d8";
    ctx.strokeRect(300, 30, 200, 80);
    ctx.fillStyle = "#064b57";
    ctx.font = "24px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("TARGET", 400, 58);
    ctx.font = "36px sans-serif";
    ctx.fillText(String(targetNumber !== null ? targetNumber : "--"), 400, 94);

    ctx.restore();
  }

  function drawChips() {
    chips.forEach((c, i) => {
      ctx.save();
      // playful shape: circle with little eyes
      ctx.beginPath();
      ctx.fillStyle = "#fffbe6";
      ctx.strokeStyle = "#b99b57";
      ctx.lineWidth = 2;
      ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // stripy pattern
      ctx.fillStyle = "rgba(0,0,0,0.03)";
      ctx.beginPath();
      ctx.ellipse(c.x - 6, c.y - 8, c.r * 0.6, c.r * 0.25, 0.2, 0, Math.PI * 2);
      ctx.fill();

      // eyes
      ctx.fillStyle = "#333";
      ctx.beginPath();
      ctx.arc(c.x - 8, c.y - 6, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(c.x + 6, c.y - 6, 3, 0, Math.PI * 2);
      ctx.fill();

      // number text
      ctx.fillStyle = "#2b4f56";
      ctx.font = "20px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(String(c.num), c.x, c.y + 8);

      // focus ring
      if (focus.area === "chips" && focus.index === i) {
        ctx.strokeStyle = "#2ba6b4";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(c.x, c.y, c.r + 4, 0, Math.PI * 2);
        ctx.stroke();
      }

      // if held, draw shadow on top
      if (c.held) {
        ctx.fillStyle = "rgba(0,0,0,0.08)";
        ctx.beginPath();
        ctx.ellipse(c.x + 6, c.y + 16, c.r * 0.6, c.r * 0.25, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();
    });
  }

  function drawOperators() {
    operators.forEach((opObj, i) => {
      ctx.save();
      // gear circle
      ctx.beginPath();
      ctx.fillStyle = "#fff7f3";
      ctx.strokeStyle = "#d59a7b";
      ctx.lineWidth = 2;
      ctx.arc(opObj.x, opObj.y, opObj.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // little teeth
      ctx.fillStyle = "#ffd7c4";
      for (let t = 0; t < 8; t++) {
        const ang = (t / 8) * Math.PI * 2 + (i % 2 ? 0.2 : -0.1);
        const tx = opObj.x + Math.cos(ang) * (opObj.r + 6);
        const ty = opObj.y + Math.sin(ang) * (opObj.r + 6);
        ctx.beginPath();
        ctx.arc(tx, ty, 4, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.fillStyle = "#7a3b2f";
      ctx.font = "22px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(opObj.op, opObj.x, opObj.y + 8);

      if (focus.area === "ops" && focus.index === i) {
        ctx.strokeStyle = "#2ba6b4";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(opObj.x, opObj.y, opObj.r + 6, 0, Math.PI * 2);
        ctx.stroke();
      }

      ctx.restore();
    });
  }

  function drawSlotsContent() {
    // Draw placed numbers or operator symbol inside slots
    ["A", "B"].forEach((k) => {
      const s = slots[k];
      ctx.save();
      if (s.content !== null) {
        ctx.fillStyle = "#2b4f56";
        ctx.font = "22px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(String(s.content), s.x, s.y + 8);
      } else {
        ctx.fillStyle = "#9fb7bf";
        ctx.font = "14px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(k === "A" ? "Slot A" : "Slot B", s.x, s.y + 6);
      }
      ctx.restore();
    });
    const so = slots.operator;
    ctx.save();
    if (so.content !== null) {
      ctx.fillStyle = "#7a3b2f";
      ctx.font = "28px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(String(so.content), so.x, so.y + 10);
    } else {
      ctx.fillStyle = "#7aa2ab";
      ctx.font = "14px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Operator", so.x, so.y + 6);
    }
    ctx.restore();
  }

  function drawButtons() {
    // Run button
    ctx.save();
    ctx.fillStyle = runButton.hot ? "#74c2c9" : "#a8e1e5";
    ctx.strokeStyle = "#4aa1a9";
    ctx.lineWidth = 2;
    roundRect(ctx, runButton.x - runButton.w / 2, runButton.y - runButton.h / 2, runButton.w, runButton.h, 8, true, true);
    ctx.fillStyle = "#05343a";
    ctx.font = "20px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("RUN", runButton.x, runButton.y + 6);

    // Reset button
    ctx.fillStyle = "#ffdede";
    ctx.strokeStyle = "#e59b9b";
    ctx.lineWidth = 2;
    roundRect(ctx, resetButton.x, resetButton.y, resetButton.w, resetButton.h, 6, true, true);
    ctx.fillStyle = "#7a2a2a";
    ctx.font = "14px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("Reset", resetButton.x + resetButton.w / 2, resetButton.y + 20);

    // Audio icon indicator top-right
    ctx.fillStyle = audioAllowed ? "#2ba6b4" : "#c3c3c3";
    ctx.beginPath();
    ctx.arc(42, 22, 12, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#fff";
    ctx.font = "12px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(audioAllowed ? "♪" : "×", 42, 26);

    ctx.restore();
  }

  function drawHUD() {
    ctx.save();
    ctx.fillStyle = "#064b57";
    ctx.font = "16px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText(`Level: ${level}`, 18, 28);
    ctx.fillText(`Score: ${score}`, 18, 48);
    ctx.fillText(`Attempts left: ${maxAttempts - attempts}`, 18, 68);

    ctx.fillStyle = "#2b4f56";
    ctx.textAlign = "center";
    ctx.font = "14px sans-serif";
    ctx.fillText("Drag or use keyboard to place numbers and operator", WIDTH / 2, HEIGHT - 10);
    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    if (typeof r === "number") {
      r = { tl: r, tr: r, br: r, bl: r };
    } else {
      r = Object.assign({ tl: 0, tr: 0, br: 0, bl: 0 }, r);
    }
    ctx.beginPath();
    ctx.moveTo(x + r.tl, y);
    ctx.lineTo(x + w - r.tr, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
    ctx.lineTo(x + w, y + h - r.br);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
    ctx.lineTo(x + r.bl, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
    ctx.lineTo(x, y + r.tl);
    ctx.quadraticCurveTo(x, y, x + r.tl, y);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // Main render
  function render(time) {
    // time in ms
    drawBackground();
    drawCalmPatterns(time);
    drawMachine();
    drawOperators();
    drawChips();
    drawSlotsContent();
    drawButtons();
    drawHUD();
  }

  // Hit testing
  function pointInCircle(px, py, cx, cy, r) {
    const dx = px - cx;
    const dy = py - cy;
    return dx * dx + dy * dy <= r * r;
  }

  // Mouse and touch events
  canvas.addEventListener("mousedown", (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    handlePointerDown(x, y);
  });
  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    handlePointerMove(x, y);
  });
  canvas.addEventListener("mouseup", (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    handlePointerUp(x, y);
  });
  canvas.addEventListener("touchstart", (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const t = e.changedTouches[0];
    const x = t.clientX - rect.left;
    const y = t.clientY - rect.top;
    handlePointerDown(x, y);
  }, { passive: false });
  canvas.addEventListener("touchmove", (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const t = e.changedTouches[0];
    const x = t.clientX - rect.left;
    const y = t.clientY - rect.top;
    handlePointerMove(x, y);
  }, { passive: false });
  canvas.addEventListener("touchend", (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const t = e.changedTouches[0];
    if (!t) { handlePointerUp(0,0); return; }
    const x = t.clientX - rect.left;
    const y = t.clientY - rect.top;
    handlePointerUp(x, y);
  }, { passive: false });

  // Pointer handlers
  function handlePointerDown(x, y) {
    // If start not running, treat as start button press
    if (!running) {
      // Start button placed in center - we draw start text on initial screen later
      startGame();
      return;
    }
    // Check chips
    for (let i = chips.length - 1; i >= 0; i--) {
      const c = chips[i];
      if (pointInCircle(x, y, c.x, c.y, c.r)) {
        dragging = c;
        c.held = true;
        dragOffset.x = x - c.x;
        dragOffset.y = y - c.y;
        focus = { area: "chips", index: i };
        return;
      }
    }
    // Check operators
    for (let i = 0; i < operators.length; i++) {
      const op = operators[i];
      if (pointInCircle(x, y, op.x, op.y, op.r)) {
        // place operator into operator slot
        slots.operator.content = op.op;
        focus = { area: "ops", index: i };
        announce(`Operator ${op.op} selected`);
        return;
      }
    }
    // Check run button
    if (x >= runButton.x - runButton.w / 2 && x <= runButton.x + runButton.w / 2 &&
      y >= runButton.y - runButton.h / 2 && y <= runButton.y + runButton.h / 2) {
      runButton.hot = true;
      runMachine();
      return;
    }
    // Reset button
    if (x >= resetButton.x && x <= resetButton.x + resetButton.w &&
      y >= resetButton.y && y <= resetButton.y + resetButton.h) {
      resetRound();
      return;
    }
  }

  function handlePointerMove(x, y) {
    if (dragging) {
      dragging.x = x - dragOffset.x;
      dragging.y = y - dragOffset.y;
    }
  }

  function handlePointerUp(x, y) {
    if (dragging) {
      // Check if over slot A or B
      if (pointInCircle(x, y, slots.A.x, slots.A.y, slots.A.r + 12)) {
        slots.A.content = dragging.num;
        announce(`Placed ${dragging.num} into Slot A`);
        // return chip to original position (or hide)
        removeChip(dragging.id);
      } else if (pointInCircle(x, y, slots.B.x, slots.B.y, slots.B.r + 12)) {
        slots.B.content = dragging.num;
        announce(`Placed ${dragging.num} into Slot B`);
        removeChip(dragging.id);
      } else {
        // return to original position
        dragging.x = dragging.originalX;
        dragging.y = dragging.originalY;
        dragging.held = false;
      }
      dragging.held = false;
      dragging = null;
    }
    runButton.hot = false;
  }

  function removeChip(id) {
    // remove chip from chips array by id (and keep others)
    const idx = chips.findIndex((c) => c.id === id);
    if (idx >= 0) chips.splice(idx, 1);
  }

  // Run the machine: animate and check answer
  let animating = false;
  async function runMachine() {
    if (animating) return;
    // Need two slots and operator
    if (slots.A.content === null || slots.B.content === null || slots.operator.content === null) {
      announce("Please place two numbers and choose an operator before running.");
      playBeep(false);
      return;
    }
    animating = true;
    attempts++;
    announce("Running machine...");
    // Simple animation: spin and conveyor
    const startTime = performance.now();
    const duration = 1000;
    const initialPositions = chips.map(c => ({ id: c.id, x: c.x, y: c.y }));
    const from = performance.now();
    function animFrame(now) {
      const t = clamp((now - from) / duration, 0, 1);
      // draw with tempo changes: rotate operator gear, sway conveyor (but we just re-render)
      render(now);
      // overlay running effects
      ctx.save();
      // steam puffs
      ctx.fillStyle = `rgba(255,255,255,${0.3 * (1 - t)})`;
      ctx.beginPath();
      ctx.arc(360, 100 - t * 20, 16 + t * 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
      if (t < 1) {
        requestAnimationFrame(animFrame);
      } else {
        animating = false;
        evaluateAnswer();
      }
    }
    requestAnimationFrame(animFrame);

    // Play running sound
    if (audioCtx && audioAllowed) {
      try {
        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = "sine";
        osc.frequency.setValueAtTime(220, now);
        osc.frequency.exponentialRampToValueAtTime(120, now + 0.8);
        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(0.08, now + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.9);
        osc.connect(gain);
        gain.connect(masterGain);
        osc.start(now);
        osc.stop(now + 0.95);
      } catch (e) {
        console.warn("Run sound error:", e && e.message);
      }
    }
  }

  function evaluateAnswer() {
    const a = Number(slots.A.content);
    const b = Number(slots.B.content);
    const op = slots.operator.content;
    const compute = (x, y, o) => (o === "+" ? x + y : o === "-" ? x - y : x * y);
    const result = compute(a, b, op);
    if (result === targetNumber) {
      score++;
      announce(`Correct! ${a} ${op} ${b} = ${result}. Well done!`);
      playBeep(true);
      // reward animation and next round
      setTimeout(() => {
        level = Math.min(3, 1 + Math.floor(score / 3)); // level up every 3 points
        generateRound();
      }, 800);
    } else {
      playBeep(false);
      if (attempts >= maxAttempts) {
        // reveal solution and reset round
        announce(`Oops, no more attempts. The correct solution was ${solution.a} ${solution.op} ${solution.b} = ${targetNumber}.`);
        // show solution in slots
        slots.A.content = solution.a;
        slots.B.content = solution.b;
        slots.operator.content = solution.op;
        // prepare next round after pause
        setTimeout(() => {
          generateRound();
        }, 1600);
      } else {
        announce(`Not quite. ${a} ${op} ${b} = ${result}. Try again. Attempts left: ${maxAttempts - attempts}.`);
      }
    }
  }

  // Reset round: return all chips and clear slots
  function resetRound() {
    // Recreate chips at original positions and clear slots
    chips.length = 0;
    // regenerate round to restore chips
    generateRound();
    announce("Round reset.");
  }

  // Keyboard controls
  window.addEventListener("keydown", (e) => {
    if (!running) {
      if (e.key === "Enter" || e.key === " ") {
        startGame();
        e.preventDefault();
      }
      return;
    }
    const area = focus.area;
    if (e.key === "Tab") {
      e.preventDefault();
      // cycle focus: chips -> ops -> run -> reset -> chips ...
      const order = ["chips", "ops", "run", "reset"];
      let idx = order.indexOf(area);
      idx = (idx + 1) % order.length;
      setFocusArea(order[idx], 0);
      return;
    }
    if (area === "chips") {
      if (e.key === "ArrowRight") {
        focus.index = (focus.index + 1) % chips.length;
        e.preventDefault();
      } else if (e.key === "ArrowLeft") {
        focus.index = (focus.index - 1 + chips.length) % chips.length;
        e.preventDefault();
      } else if (e.key === "Enter" || e.key === " ") {
        // select chip to place: if slot A empty place in A else in B
        const c = chips[focus.index];
        if (!c) return;
        if (slots.A.content === null) {
          slots.A.content = c.num;
          announce(`Placed ${c.num} into Slot A`);
          removeChip(c.id);
        } else if (slots.B.content === null) {
          slots.B.content = c.num;
          announce(`Placed ${c.num} into Slot B`);
          removeChip(c.id);
        } else {
          announce("Both slots are full. Use Reset to try different chips or remove a placed number.");
        }
        e.preventDefault();
      }
    } else if (area === "ops") {
      if (e.key === "ArrowRight") {
        focus.index = (focus.index + 1) % operators.length;
        e.preventDefault();
      } else if (e.key === "ArrowLeft") {
        focus.index = (focus.index - 1 + operators.length) % operators.length;
        e.preventDefault();
      } else if (e.key === "Enter" || e.key === " ") {
        const op = operators[focus.index];
        if (op) {
          slots.operator.content = op.op;
          announce(`Operator ${op.op} selected`);
        }
        e.preventDefault();
      }
    } else if (area === "run") {
      if (e.key === "Enter" || e.key === " ") {
        runMachine();
        e.preventDefault();
      } else if (e.key === "ArrowLeft") {
        setFocusArea("ops", 0);
        e.preventDefault();
      } else if (e.key === "ArrowRight") {
        setFocusArea("reset", 0);
        e.preventDefault();
      }
    } else if (area === "reset") {
      if (e.key === "Enter" || e.key === " ") {
        resetRound();
        e.preventDefault();
      } else if (e.key === "ArrowLeft") {
        setFocusArea("run", 0);
        e.preventDefault();
      }
    }
  });

  function setFocusArea(areaName, idx) {
    focus.area = areaName;
    focus.index = idx || 0;
    announce(`Focus on ${areaName}`);
  }

  // Start screen and start game
  function drawStartScreen() {
    drawBackground();
    ctx.save();
    ctx.fillStyle = "#073642";
    ctx.font = "28px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("Machine Math", WIDTH / 2, 80);
    ctx.font = "16px sans-serif";
    ctx.fillText("Build a wacky machine to make the target number!", WIDTH / 2, 110);

    // Start button
    ctx.fillStyle = "#a8e1e5";
    ctx.strokeStyle = "#4aa1a9";
    roundRect(ctx, WIDTH / 2 - 90, HEIGHT / 2 - 26, 180, 52, 12, true, true);
    ctx.fillStyle = "#05343a";
    ctx.font = "20px sans-serif";
    ctx.fillText("Click or press Enter to Start", WIDTH / 2, HEIGHT / 2 + 8);

    // Small instructions
    ctx.fillStyle = "#2b4f56";
    ctx.font = "14px sans-serif";
    ctx.fillText("Drag a number into Slot A and B, choose an operator, then press RUN.", WIDTH / 2, HEIGHT / 2 + 80);
    ctx.fillText("You can also use the keyboard: Tab to cycle focus, arrows to move, Enter to pick.", WIDTH / 2, HEIGHT / 2 + 100);
    ctx.restore();
  }

  function startGame() {
    // try to init audio on user gesture
    initAudio().then((ok) => {
      if (!ok) {
        announce("Audio unavailable. The game will play silently.");
      } else {
        announce("Audio enabled.");
      }
    });
    running = true;
    score = 0;
    level = 1;
    roundIndex = 0;
    generateRound();
    setFocusArea("chips", 0);
    animate();
  }

  // Animation loop
  let raf = null;
  function animate(time) {
    render(time);
    raf = requestAnimationFrame(animate);
  }

  // Initial draw: start screen
  drawStartScreen();

  // Initialize by rendering occasionally so start screen visible
  let startRenderId = requestAnimationFrame(function loop(t) {
    drawStartScreen();
    startRenderId = requestAnimationFrame(loop);
  });

  // Once running, cancel start screen render and run animate
  const originalStartGame = startGame;
  startGame = function () {
    cancelAnimationFrame(startRenderId);
    originalStartGame();
  };

  // Safety: ensure audio is handled on page visibility change
  document.addEventListener("visibilitychange", () => {
    if (document.hidden && audioCtx && audioCtx.state === "running") {
      audioCtx.suspend().catch(() => { });
    } else if (audioCtx && audioAllowed && audioCtx.state === "suspended") {
      audioCtx.resume().catch(() => { });
    }
  });

  // Error handling for context resume
  window.addEventListener("unhandledrejection", (e) => {
    console.warn("Unhandled rejection:", e.reason);
  });

  // Expose restart via double-click for quick testing (accessible)
  canvas.addEventListener("dblclick", () => {
    if (running) {
      resetRound();
    }
  });

  // Ensure the canvas is focusable for keyboard
  canvas.tabIndex = 0;
  canvas.style.outline = "none";
  canvas.addEventListener("focus", () => {
    // show focus hint
    announce("Canvas focused. Use Tab to cycle focus, arrow keys and Enter to control.");
  });

  // Provide instructions in live region at load
  announce("Welcome to Machine Math. Click the canvas or press Enter to start the game. Use drag-and-drop or keyboard to place numbers and operator then press Run.");

})();
---

