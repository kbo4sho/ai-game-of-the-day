# Game of the Day - 2025-09-18

## Metadata
- **Generated Date:** 2025-09-18
- **Generated Time:** 2025-09-18T00:25:27.261710
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-18.js
- **File Size:** 25752 bytes
- **Tokens Used:** 9389

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** âœ… PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** âœ… NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
â€¢ Be beatable.
â€¢ Use visually calming and interesting and wacky elements.
â€¢ Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
â€¢ Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
â€¢ Have a game area exactly 720px wide by 480px tall.
â€¢ Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
â€¢ Use modern JavaScript practices and avoid minification.
â€¢ Include proper error handling for audio and resource loading.
â€¢ Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
â€¢ Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
â€¢ Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
â€¢ Generate all sounds using Web Audio API oscillators and filters.
â€¢ Include proper error handling for audio context creation.
â€¢ Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
â€¢ Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-18.js` - The playable game
- `2025-09-18.meta.json` - Machine-readable metadata
- `2025-09-18.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 19805

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 22190

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** âœ… PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Wacky Machine Math Game
  // For ages 7-9. Renders into existing element with id "game-of-the-day-stage".
  // All visuals are canvas-drawn. Sounds use Web Audio API oscillators/filters.
  // Written with accessibility in mind (keyboard controls and aria-live updates).

  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const CONTAINER_ID = 'game-of-the-day-stage';
  const LEVEL_COUNT = 8;

  // Utility helpers
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const randInt = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;
  const safeText = s => String(s == null ? '' : s);

  // Find container
  const container = document.getElementById(CONTAINER_ID);
  if (!container) {
    console.error(`Game container with id "${CONTAINER_ID}" not found.`);
    return;
  }

  // Clear container and set accessible label
  container.innerHTML = '';
  container.style.position = 'relative';

  // Create a hidden accessible live region for screen readers
  const ariaLive = document.createElement('div');
  ariaLive.setAttribute('role', 'status');
  ariaLive.setAttribute('aria-live', 'polite');
  ariaLive.style.position = 'absolute';
  ariaLive.style.left = '0';
  ariaLive.style.top = '0';
  ariaLive.style.width = '1px';
  ariaLive.style.height = '1px';
  ariaLive.style.overflow = 'hidden';
  ariaLive.style.clip = 'rect(1px, 1px, 1px, 1px)';
  ariaLive.style.whiteSpace = 'nowrap';
  container.appendChild(ariaLive);

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.tabIndex = 0; // make it focusable for keyboard events
  canvas.setAttribute('aria-label', 'Wacky Machines math game. Use arrow keys to play. Press M to toggle sound.');
  canvas.style.outline = 'none';
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d', { alpha: false });

  // Game state
  let running = true;
  let frame = 0;
  let selectedKnob = 0; // 0,1,2
  let level = 0;
  let attempts = 0;
  let solvedCount = 0;
  let showHint = false;
  let audioAllowed = false;
  let audioOk = false;
  let audioEnabled = true;
  let audioContext = null; // will be created on first user gesture
  let masterGain = null;
  let bgNodes = null; // background audio nodes
  let lastAudioError = null;
  let spinner = 0;

  // Puzzle data: each level has three knobs values and a target sum
  const puzzles = [];

  // Generate puzzles (simple addition tasks)
  function generatePuzzles() {
    puzzles.length = 0;
    for (let i = 0; i < LEVEL_COUNT; i++) {
      // Levels start easy and grow slightly
      const min = 0;
      const maxBase = 5 + Math.floor(i * 1.5); // 5,6.5,8...
      const max = clamp(maxBase + randInt(0, 4), 6, 12);
      const a = randInt(min, max);
      const b = randInt(min, max);
      const c = randInt(min, max);
      const target = a + b + c + randInt(-3, 3);
      // Ensure target is reasonable and positive
      puzzles.push({
        knobs: [a, b, c].map(v => clamp(v, 0, 12)),
        target: clamp(target, 0, 30),
      });
    }
  }

  generatePuzzles();

  // Copy initial values for current play
  let current = {
    knobs: [0, 0, 0],
    target: 0,
  };

  function startLevel(index = 0) {
    level = clamp(index, 0, puzzles.length - 1);
    attempts = 0;
    showHint = false;
    selectedKnob = 0;
    const p = puzzles[level];
    current.knobs = p.knobs.slice(); // start with the puzzle's values as default
    current.target = p.target;
    updateAria(`Level ${level + 1}. The target is ${current.target}. Use left/right to pick a knob and up/down to change its number, then press Enter to submit.`);
  }

  startLevel(0);

  // Accessibility update
  function updateAria(text) {
    ariaLive.textContent = text;
  }

  // Input handling
  canvas.addEventListener('keydown', (e) => {
    if (e.defaultPrevented) return;
    const key = e.key;
    if (key === 'ArrowLeft') {
      selectedKnob = (selectedKnob + 3 - 1) % 3;
      e.preventDefault();
      playClick();
      updateAria(`Knob ${selectedKnob + 1} selected, value ${current.knobs[selectedKnob]}.`);
    } else if (key === 'ArrowRight') {
      selectedKnob = (selectedKnob + 1) % 3;
      e.preventDefault();
      playClick();
      updateAria(`Knob ${selectedKnob + 1} selected, value ${current.knobs[selectedKnob]}.`);
    } else if (key === 'ArrowUp') {
      changeKnob(selectedKnob, 1);
      e.preventDefault();
    } else if (key === 'ArrowDown') {
      changeKnob(selectedKnob, -1);
      e.preventDefault();
    } else if (key === 'Enter' || key === ' ') {
      submitAttempt();
      e.preventDefault();
    } else if (key.toLowerCase() === 'm') {
      toggleAudio();
      e.preventDefault();
    } else if (key.toLowerCase() === 'r') {
      startLevel(0);
      solvedCount = 0;
      updateAria('Game reset. Starting at level 1.');
      e.preventDefault();
    } else if (key.toLowerCase() === 'h') {
      showHint = !showHint;
      updateAria(showHint ? 'Hint shown.' : 'Hint hidden.');
      e.preventDefault();
    }
  });

  // Mouse handling
  canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);
    // Click detection for knobs and submit/mute buttons
    const clicked = handleClick(x, y);
    if (clicked) {
      // allow audio to start on first user gesture
      ensureAudioResume();
    }
  });

  // Wheel to adjust knob
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const dy = Math.sign(e.deltaY);
    changeKnob(selectedKnob, -dy);
    ensureAudioResume();
  }, { passive: false });

  // Touch support: simple tap to select/submit
  canvas.addEventListener('touchstart', (e) => {
    if (e.touches.length > 0) {
      const rect = canvas.getBoundingClientRect();
      const t = e.touches[0];
      const x = (t.clientX - rect.left) * (canvas.width / rect.width);
      const y = (t.clientY - rect.top) * (canvas.height / rect.height);
      handleClick(x, y);
      ensureAudioResume();
    }
  });

  // Change knob value
  function changeKnob(idx, delta) {
    current.knobs[idx] = clamp(current.knobs[idx] + delta, 0, 20);
    attempts++;
    playClick();
    updateAria(`Knob ${idx + 1} is now ${current.knobs[idx]}.`);
  }

  // Submit attempt
  function submitAttempt() {
    attempts++;
    const sum = current.knobs.reduce((a, b) => a + b, 0);
    if (sum === current.target) {
      solvedCount++;
      playCorrect();
      updateAria(`Good job! You fixed the machine. Level ${level + 1} complete.`);
      // Move to next after short delay
      setTimeout(() => {
        if (level + 1 < puzzles.length) {
          startLevel(level + 1);
        } else {
          winGame();
        }
      }, 900);
    } else {
      playIncorrect();
      updateAria(`Not quite. The total is ${sum}. Try again.`);
    }
  }

  function winGame() {
    updateAria(`All machines fixed! You completed all ${puzzles.length} levels with ${attempts} attempts on the last level. Press R to play again.`);
    // show confetti-like wacky gears animation and reset option
    // reset after a beat
    setTimeout(() => {
      startLevel(0);
      solvedCount = 0;
    }, 3000);
  }

  // Click handling: determine which part was clicked
  function handleClick(x, y) {
    // Knobs area positions
    const knobPositions = [
      { x: 180, y: 260 },
      { x: 360, y: 240 },
      { x: 540, y: 260 },
    ];
    for (let i = 0; i < knobPositions.length; i++) {
      const k = knobPositions[i];
      const dx = x - k.x;
      const dy = y - k.y;
      if (Math.hypot(dx, dy) < 60) {
        selectedKnob = i;
        playClick();
        updateAria(`Knob ${i + 1} selected, value ${current.knobs[i]}.`);
        return true;
      }
    }
    // Submit button
    if (x >= 600 && x <= 690 && y >= 380 && y <= 440) {
      submitAttempt();
      return true;
    }
    // Mute toggle (top-right tiny speaker)
    if (x >= 680 && x <= 708 && y >= 8 && y <= 36) {
      toggleAudio();
      return true;
    }
    // Hint bubble (top-left)
    if (x >= 8 && x <= 88 && y >= 8 && y <= 48) {
      showHint = !showHint;
      updateAria(showHint ? 'Hint shown.' : 'Hint hidden.');
      return true;
    }
    return false;
  }

  // Audio: Web Audio API setup and functions
  function initAudio() {
    if (audioContext) return;
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) {
        lastAudioError = new Error('Web Audio API not supported in this browser.');
        audioOk = false;
        console.warn(lastAudioError.message);
        return;
      }
      audioContext = new AC();
      masterGain = audioContext.createGain();
      masterGain.gain.value = 0.6;
      masterGain.connect(audioContext.destination);

      // Background gentle tones - two oscillators with slow LFO on filter
      const oscA = audioContext.createOscillator();
      const oscB = audioContext.createOscillator();
      const mixGain = audioContext.createGain();
      const filter = audioContext.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 600;
      filter.Q.value = 1;

      oscA.type = 'sine';
      oscB.type = 'triangle';
      oscA.frequency.value = 220;
      oscB.frequency.value = 110;
      mixGain.gain.value = 0.12;

      oscA.connect(mixGain);
      oscB.connect(mixGain);
      mixGain.connect(filter);
      filter.connect(masterGain);

      // LFO to slowly modulate filter frequency
      const lfo = audioContext.createOscillator();
      const lfoGain = audioContext.createGain();
      lfo.type = 'sine';
      lfo.frequency.value = 0.08; // slow
      lfoGain.gain.value = 120;
      lfo.connect(lfoGain);
      lfoGain.connect(filter.frequency);

      oscA.start();
      oscB.start();
      lfo.start();

      bgNodes = { oscA, oscB, lfo, filter, mixGain };

      audioOk = true;
      lastAudioError = null;
    } catch (err) {
      lastAudioError = err;
      audioOk = false;
      console.error('Audio initialization failed:', err);
    }
  }

  // Ensure audio is resumed on user gesture according to browser policies
  function ensureAudioResume() {
    audioAllowed = true;
    if (!audioContext) {
      try {
        initAudio();
      } catch (e) {
        // error handled in initAudio
      }
    }
    if (audioContext && audioContext.state === 'suspended') {
      audioContext.resume().catch((err) => {
        console.warn('Audio resume failed:', err);
      });
    }
  }

  function toggleAudio() {
    audioEnabled = !audioEnabled;
    if (masterGain) {
      masterGain.gain.setTargetAtTime(audioEnabled ? 0.6 : 0.0, audioContext.currentTime, 0.02);
    }
    updateAria(audioEnabled ? 'Sound on.' : 'Sound muted.');
    playClick();
  }

  // Play short click sound for UI interactions
  function playClick() {
    if (!audioEnabled) return;
    try {
      if (!audioContext) initAudio();
      if (!audioOk) return;
      const o = audioContext.createOscillator();
      const g = audioContext.createGain();
      const f = audioContext.createBiquadFilter();
      o.type = 'square';
      o.frequency.value = 880;
      f.type = 'highpass';
      f.frequency.value = 400;
      g.gain.value = 0.0001;
      o.connect(f);
      f.connect(g);
      g.connect(masterGain);
      const now = audioContext.currentTime;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.08, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);
      o.start(now);
      o.stop(now + 0.2);
    } catch (err) {
      console.warn('playClick error', err);
    }
  }

  // Play success melody
  function playCorrect() {
    if (!audioEnabled) return;
    try {
      if (!audioContext) initAudio();
      if (!audioOk) return;
      const notes = [880, 1046, 1318]; // A5, C6, E6
      const now = audioContext.currentTime;
      notes.forEach((freq, i) => {
        const o = audioContext.createOscillator();
        const g = audioContext.createGain();
        o.type = i === 1 ? 'triangle' : 'sine';
        o.frequency.value = freq;
        g.gain.value = 0.0001;
        o.connect(g);
        g.connect(masterGain);
        const start = now + i * 0.12;
        const end = start + 0.18;
        g.gain.setValueAtTime(0.0001, start);
        g.gain.exponentialRampToValueAtTime(0.12, start + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, end);
        o.start(start);
        o.stop(end + 0.02);
      });
    } catch (err) {
      console.warn('playCorrect error', err);
    }
  }

  // Play incorrect buzzer
  function playIncorrect() {
    if (!audioEnabled) return;
    try {
      if (!audioContext) initAudio();
      if (!audioOk) return;
      const now = audioContext.currentTime;
      // descending buzz
      for (let i = 0; i < 3; i++) {
        const o = audioContext.createOscillator();
        const g = audioContext.createGain();
        o.type = 'sawtooth';
        o.frequency.value = 660 - i * 110;
        g.gain.value = 0.0001;
        o.connect(g);
        g.connect(masterGain);
        const start = now + i * 0.06;
        const end = start + 0.12;
        g.gain.setValueAtTime(0.0001, start);
        g.gain.exponentialRampToValueAtTime(0.08, start + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, end);
        o.start(start);
        o.stop(end + 0.02);
      }
    } catch (err) {
      console.warn('playIncorrect error', err);
    }
  }

  // Fallback if audio cannot be initialized
  if (!audioContext) {
    try {
      initAudio();
    } catch (e) { /* handled above */ }
  }

  // Drawing helpers
  function drawRoundedRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  // Colors and palette (calming, wacky)
  const palette = {
    bg: '#F7FBFF',
    panel: '#E8F1F8',
    accent: '#7BB7D6',
    knob: '#F3DFAE',
    knob2: '#D1E8E2',
    text: '#22313A',
    highlight: '#FFB84D',
    wrong: '#FF6B6B',
    correct: '#6BE38D',
    gentle: '#B7DDF0',
  };

  // Drawing the full scene each frame
  function draw() {
    frame++;
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Background gradient
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, palette.bg);
    g.addColorStop(1, '#ECF8FF');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Soft floating gears in background (wacky)
    drawGearsBackground();

    // Large machine body
    ctx.fillStyle = palette.panel;
    drawRoundedRect(ctx, 80, 60, 560, 300, 18);

    // Wacky antenna and eyes
    drawAntenna();
    drawGooglyEyes();

    // Display panel with target
    drawDisplay();

    // Knobs
    drawKnobs();

    // Conveyor belt and output
    drawConveyor();

    // Buttons: submit and hint and mute
    drawControls();

    // Instruction text
    drawInstructions();

    // Tiny debug / audio status
    drawAudioIndicator();

    // Possibly draw hint bubble
    if (showHint) drawHint();

    // Drawing done
  }

  // Background gears animation
  function drawGearsBackground() {
    const baseY = 420;
    for (let i = 0; i < 6; i++) {
      const x = 40 + i * 120 + (Math.sin((frame + i * 10) * 0.02) * 8);
      const y = baseY + Math.cos((frame + i * 15) * 0.013) * 6;
      const r = 28 + (i % 2 ? 6 : 0);
      drawGear(x, y, r, (frame * 0.5 + i * 8) * (i % 2 ? -0.02 : 0.02));
    }
  }

  function drawGear(cx, cy, radius, rotation) {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(rotation);
    // Soft gear shadow
    ctx.beginPath();
    ctx.fillStyle = 'rgba(140,160,170,0.06)';
    ctx.arc(6, 6, radius + 6, 0, Math.PI * 2);
    ctx.fill();
    // Gear body
    ctx.fillStyle = palette.gentle;
    ctx.beginPath();
    ctx.arc(0, 0, radius, 0, Math.PI * 2);
    ctx.fill();
    // Teeth
    for (let i = 0; i < 10; i++) {
      const a = (i / 10) * Math.PI * 2;
      const x = Math.cos(a) * (radius + 8);
      const y = Math.sin(a) * (radius + 8);
      ctx.fillStyle = palette.panel;
      ctx.fillRect(x - 4, y - 6, 8, 12);
    }
    // center hole
    ctx.fillStyle = '#E7FBFF';
    ctx.beginPath();
    ctx.arc(0, 0, radius * 0.4, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawAntenna() {
    ctx.save();
    ctx.strokeStyle = palette.accent;
    ctx.lineWidth = 6;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(600, 90);
    ctx.lineTo(650, 30 + Math.sin(frame * 0.06) * 6);
    ctx.stroke();
    // top bulb
    ctx.fillStyle = palette.highlight;
    ctx.beginPath();
    ctx.arc(650, 30 + Math.sin(frame * 0.06) * 6, 12, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawGooglyEyes() {
    // two eyes on machine
    const left = { x: 240, y: 120 };
    const right = { x: 320, y: 118 };
    drawEye(left.x, left.y, 26, 0.6 + Math.sin(frame * 0.06) * 0.6);
    drawEye(right.x, right.y, 26, 0.4 + Math.cos(frame * 0.05) * 0.6);
  }

  function drawEye(x, y, r, offset) {
    ctx.save();
    // white
    ctx.fillStyle = '#FFF';
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
    // iris
    ctx.fillStyle = '#2E6A7A';
    ctx.beginPath();
    ctx.arc(x + offset * 6, y, r * 0.42, 0, Math.PI * 2);
    ctx.fill();
    // highlight
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    ctx.beginPath();
    ctx.arc(x + offset * 6 - 3, y - 4, r * 0.12, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawDisplay() {
    // machine numeric display for target
    ctx.save();
    ctx.fillStyle = '#112';
    ctx.globalAlpha = 0.06;
    drawRoundedRect(ctx, 210, 90, 300, 80, 10);
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#0B2B36';
    drawRoundedRect(ctx, 230, 100, 260, 60, 8);
    ctx.fillStyle = palette.accent;
    ctx.fillRect(240, 110, 240, 40);
    // text
    ctx.fillStyle = '#08323a';
    ctx.font = 'bold 26px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`TARGET: ${current.target}`, 350, 138);
    ctx.restore();
  }

  function drawKnobs() {
    const positions = [
      { x: 180, y: 260 },
      { x: 360, y: 240 },
      { x: 540, y: 260 },
    ];
    for (let i = 0; i < 3; i++) {
      const p = positions[i];
      drawSingleKnob(p.x, p.y, current.knobs[i], i === selectedKnob);
    }
  }

  function drawSingleKnob(x, y, value, selected) {
    ctx.save();
    // base plate
    ctx.fillStyle = selected ? '#FFF6E6' : '#FFF';
    ctx.beginPath();
    ctx.ellipse(x, y + 8, 72, 48, 0, 0, Math.PI * 2);
    ctx.fill();
    // knob circle
    ctx.fillStyle = palette.knob;
    ctx.beginPath();
    ctx.arc(x, y, 50, 0, Math.PI * 2);
    ctx.fill();
    // inner shadow
    ctx.fillStyle = 'rgba(0,0,0,0.08)';
    ctx.beginPath();
    ctx.arc(x, y + 6, 48, 0, Math.PI * 2);
    ctx.fill();
    // number
    ctx.fillStyle = palette.text;
    ctx.font = 'bold 28px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(String(value), x, y + 10);

    // little screw
    ctx.fillStyle = '#C9DDE6';
    ctx.beginPath();
    ctx.arc(x, y - 24, 6, 0, Math.PI * 2);
    ctx.fill();

    // highlight ring if selected
    if (selected) {
      ctx.strokeStyle = palette.highlight;
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.arc(x, y, 58, 0, Math.PI * 2);
      ctx.stroke();
    }

    // small +/- visual indicators
    ctx.fillStyle = '#8EAEC0';
    ctx.font = '12px sans-serif';
    ctx.fillText('+', x + 38, y - 8);
    ctx.fillText('âˆ’', x - 38, y - 8);

    ctx.restore();
  }

  function drawConveyor() {
    ctx.save();
    // belt
    ctx.fillStyle = '#E2F2FB';
    ctx.fillRect(120, 330, 480, 34);

    // output window
    const sum = current.knobs.reduce((a, b) => a + b, 0);
    ctx.fillStyle = sum === current.target ? palette.correct : '#E8EEF1';
    drawRoundedRect(ctx, 300, 330, 120, 34, 6);

    ctx.fillStyle = palette.text;
    ctx.font = '20px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`OUTPUT: ${sum}`, 360, 353);

    // moving screws/wacky items on conveyor
    for (let i = 0; i < 8; i++) {
      const x = 140 + ((frame * 1.2 + i * 40) % 480);
      ctx.fillStyle = i % 2 ? palette.knob2 : '#D9EEF6';
      ctx.beginPath();
      ctx.arc(x, 347, 8 + (i % 3), 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawControls() {
    ctx.save();
    // Submit button
    ctx.fillStyle = '#FFDD99';
    ctx.fillRect(600, 380, 90, 56);
    ctx.fillStyle = palette.text;
    ctx.font = 'bold 18px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('FIX IT!', 645, 416);

    // Hint bubble (top-left)
    ctx.fillStyle = showHint ? palette.highlight : palette.panel;
    drawRoundedRect(ctx, 8, 8, 80, 40, 8);
    ctx.fillStyle = palette.text;
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Hint', 20, 34);
    // small hint icon
    ctx.beginPath();
    ctx.fillStyle = '#FFF';
    ctx.arc(66, 20, 10, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#22313A';
    ctx.fillText('?', 62, 26);

    // Mute icon top-right
    ctx.fillStyle = palette.panel;
    drawRoundedRect(ctx, 680, 8, 28, 28, 6);
    ctx.fillStyle = '#22313A';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(audioEnabled ? 'ðŸ”Š' : 'ðŸ”ˆ', 694, 26);
    ctx.restore();
  }

  function drawInstructions() {
    ctx.save();
    ctx.fillStyle = '#10323A';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Pick a knob (â†â†’), change value (â†‘â†“), press Enter to submit. Press M to toggle sound. H for hint.', 20, 460);
    ctx.restore();
  }

  function drawAudioIndicator() {
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = '#FFF';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'left';
    if (!audioOk) {
      ctx.fillStyle = palette.wrong;
      ctx.fillText('Audio unavailable', 520, 32);
      ctx.fillStyle = 'rgba(0,0,0,0.15)';
      ctx.fillRect(512, 12, 196, 26);
    } else {
      ctx.fillStyle = audioEnabled ? palette.correct : palette.wrong;
      ctx.fillText(audioEnabled ? 'Sound on' : 'Muted', 540, 32);
    }
    ctx.restore();
  }

  function drawHint() {
    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    ctx.strokeStyle = palette.panel;
    drawRoundedRect(ctx, 80, 360, 440, 100, 12);
    ctx.fillStyle = palette.text;
    ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'left';
    const sum = current.knobs.reduce((a, b) => a + b, 0);
    const diff = current.target - sum;
    let hintText = '';
    if (Math.abs(diff) <= 2) {
      hintText = `You're close! Change one knob by ${diff >= 0 ? '+' + diff : diff}.`;
    } else {
      hintText = `Try to reach ${current.target} by adjusting the three knobs. Add small numbers or reduce large ones.`;
    }
    ctx.fillText(hintText, 96, 398);
    ctx.restore();
  }

  // Main animation loop
  function loop() {
    if (!running) return;
    draw();
    requestAnimationFrame(loop);
  }

  // Start loop
  loop();

  // Initialize audio on first user gesture for browsers requiring interaction
  function initAutoAudioOnGesture() {
    const resumeHandler = () => {
      ensureAudioResume();
      // Try to fade-in background
      if (audioContext && masterGain) {
        masterGain.gain.setTargetAtTime(audioEnabled ? 0.6 : 0.0, audioContext.currentTime, 0.02);
      }
      window.removeEventListener('mousedown', resumeHandler);
      window.removeEventListener('keydown', resumeHandler);
      window.removeEventListener('touchstart', resumeHandler);
    };
    window.addEventListener('mousedown', resumeHandler, { once: true });
    window.addEventListener('keydown', resumeHandler, { once: true });
    window.addEventListener('touchstart', resumeHandler, { once: true });
  }

  initAutoAudioOnGesture();

  // Expose some debug in container (non-intrusive) for errors
  const statusBox = document.createElement('div');
  statusBox.style.position = 'absolute';
  statusBox.style.right = '6px';
  statusBox.style.bottom = '6px';
  statusBox.style.background = 'rgba(255,255,255,0.6)';
  statusBox.style.borderRadius = '6px';
  statusBox.style.padding = '6px 8px';
  statusBox.style.fontSize = '11px';
  statusBox.style.color = '#234';
  statusBox.style.pointerEvents = 'none';
  statusBox.textContent = 'Wacky Machines';
  container.appendChild(statusBox);

  // Periodically update status text and handle audio errors
  setInterval(() => {
    let s = `Level ${level + 1}/${puzzles.length}`;
    if (!audioOk && lastAudioError) {
      s += ' â€¢ Audio error';
    }
    statusBox.textContent = s;
  }, 1100);

  // Ensure focus for keyboard controls
  canvas.addEventListener('focus', () => {
    canvas.style.boxShadow = '0 0 0 4px rgba(120,180,200,0.12)';
  });
  canvas.addEventListener('blur', () => {
    canvas.style.boxShadow = 'none';
  });
  // Auto-focus the canvas for convenience
  setTimeout(() => {
    try { canvas.focus(); } catch (e) { /* ignore */ }
  }, 300);

  // Clean up on unload
  window.addEventListener('unload', () => {
    running = false;
    try {
      if (audioContext) {
        audioContext.close();
      }
    } catch (e) { /* ignore */ }
  });

  // Expose some helpful messages to ariaLive at start
  updateAria('Welcome to Wacky Machines. Use left and right arrows to select a knob, up and down to change its number, and Enter to submit. Press M to toggle sound.');

})();
---

