# Game of the Day - 2025-11-20

## Metadata
- **Generated Date:** 2025-11-20
- **Generated Time:** 2025-11-20T00:28:22.495013
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-11-20.js
- **File Size:** 25859 bytes
- **Tokens Used:** 9532

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
• Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-11-20.js` - The playable game
- `2025-11-20.meta.json` - Machine-readable metadata
- `2025-11-20.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 19419

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 21796

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Drone Math Adventure
  // Game renders inside #game-of-the-day-stage
  // Canvas-based, Web Audio API generated sounds, accessible controls.
  "use strict";

  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const REQUIRED_CORRECT = 10;
  const MAX_WRONG = 3;
  const UI_PADDING = 10;
  const BODY_FONT = "16px sans-serif"; // >=14px
  const IMPORTANT_FONT = "20px sans-serif"; // >=18px
  const TITLE_FONT = "28px sans-serif";
  const OPTION_FONT = "22px sans-serif";

  // Utility helpers
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function randInt(a, b) { return Math.floor(Math.random() * (b - a + 1)) + a; }
  function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

  // Get container
  const container = document.getElementById("game-of-the-day-stage");
  if (!container) {
    console.error("Container #game-of-the-day-stage not found.");
    return;
  }

  // Clear container
  container.innerHTML = "";

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute("role", "application");
  canvas.setAttribute("aria-label", "Drone Math Adventure game area. Use mouse or keyboard to play.");
  canvas.style.outline = "none";
  container.appendChild(canvas);
  const ctx = canvas.getContext("2d");

  // Accessibility: focus canvas to receive keyboard events
  canvas.tabIndex = 0;
  canvas.focus();

  // Audio setup with error handling
  let audioEnabled = true;
  let audioCtx = null;
  let masterGain = null;
  let ambientGain = null;
  let ambientOsc = null;
  try {
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) throw new Error("Web Audio API not supported.");
    audioCtx = new AC();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.9;
    masterGain.connect(audioCtx.destination);

    // Ambient gentle hum
    ambientGain = audioCtx.createGain();
    ambientGain.gain.value = 0.08;
    ambientGain.connect(masterGain);

    ambientOsc = audioCtx.createOscillator();
    ambientOsc.type = "sine";
    ambientOsc.frequency.value = 110; // low hum
    const ambientFilter = audioCtx.createBiquadFilter();
    ambientFilter.type = "lowpass";
    ambientFilter.frequency.value = 600;
    ambientOsc.connect(ambientFilter);
    ambientFilter.connect(ambientGain);
    ambientOsc.start();
  } catch (e) {
    console.warn("Audio unavailable:", e);
    audioEnabled = false;
    audioCtx = null;
  }

  function resumeAudioIfNeeded() {
    if (!audioEnabled || !audioCtx) return;
    if (audioCtx.state === "suspended") {
      audioCtx.resume().catch((e) => console.warn("Audio resume failed:", e));
    }
  }

  // Sound effects
  function playBeep(options = {}) {
    if (!audioEnabled || !audioCtx) return;
    try {
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = options.type || "sine";
      osc.frequency.value = options.freq || 440;
      gain.gain.value = 0;
      osc.connect(gain);
      gain.connect(masterGain);
      const dur = options.duration || 0.18;
      const attack = 0.01;
      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime((options.volume || 0.6), now + attack);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + dur);
      osc.start(now);
      osc.stop(now + dur + 0.02);
      osc.onended = () => {
        try { osc.disconnect(); gain.disconnect(); } catch (e) { /* ignore */ }
      };
    } catch (e) {
      console.warn("playBeep error:", e);
    }
  }

  function playCorrectSound() {
    // Pleasant ascending arpeggio
    if (!audioEnabled || !audioCtx) return;
    resumeAudioIfNeeded();
    const base = 660;
    playBeep({ freq: base, type: "sine", duration: 0.12, volume: 0.12 });
    setTimeout(() => playBeep({ freq: base * 1.25, type: "triangle", duration: 0.12, volume: 0.12 }), 120);
    setTimeout(() => playBeep({ freq: base * 1.5, type: "sawtooth", duration: 0.18, volume: 0.14 }), 240);
  }

  function playIncorrectSound() {
    if (!audioEnabled || !audioCtx) return;
    resumeAudioIfNeeded();
    // Low "buzz" then small click
    playBeep({ freq: 180, type: "sawtooth", duration: 0.22, volume: 0.12 });
    setTimeout(() => playBeep({ freq: 120, type: "square", duration: 0.12, volume: 0.10 }), 210);
  }

  // Game state
  let state = "start"; // start, playing, win, gameover
  let score = 0;
  let wrongCount = 0;
  let question = null;
  let options = [];
  let selectedOption = -1; // index 0-3 for keyboard selection
  let hoverOption = -1;
  let questionStartTime = 0;
  let droneX = WIDTH / 2;
  let droneY = HEIGHT / 2 - 40;
  let droneBob = 0;
  let lastTime = performance.now();

  // Layout positions
  const scoreBox = { x: UI_PADDING, y: UI_PADDING, w: 0, h: 40 };
  const livesBox = { x: 0, y: UI_PADDING, w: 0, h: 40 }; // x set later to top-right
  const questionBox = { x: 0, y: 70, w: WIDTH, h: 60 };
  const optionsArea = { x: 60, y: 150, w: WIDTH - 120, h: 260 };
  const instructionsBox = { x: 0, y: HEIGHT - 80, w: WIDTH, h: 70 };

  // Option hitboxes
  const optionBoxes = []; // {x,y,w,h}

  // Generate math question (age 7-9): addition/subtraction up to 20
  function generateQuestion() {
    const type = Math.random() < 0.6 ? "add" : "sub";
    let a, b, correct;
    if (type === "add") {
      a = randInt(1, 12);
      b = randInt(1, 12);
      correct = a + b;
    } else {
      a = randInt(2, 18);
      b = randInt(1, a - 1);
      correct = a - b;
    }
    // Create three distractors reasonably close
    const distractors = new Set();
    while (distractors.size < 3) {
      const delta = pick([-3, -2, -1, 1, 2, 3, 4]);
      const val = correct + delta;
      if (val >= 0 && val <= 30 && val !== correct) distractors.add(val);
    }
    const opts = [...distractors, correct];
    // Shuffle
    for (let i = opts.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [opts[i], opts[j]] = [opts[j], opts[i]];
    }
    question = { a, b, type, correct };
    options = opts;
    selectedOption = -1;
    hoverOption = -1;
    questionStartTime = performance.now();
  }

  // Drawing helpers
  function safeFillText(text, x, y, font, color = "#000", align = "left", baseline = "middle") {
    ctx.font = font;
    ctx.fillStyle = color;
    ctx.textAlign = align;
    ctx.textBaseline = baseline;
    ctx.fillText(text, x, y);
  }

  function drawRoundedRect(x, y, w, h, r = 8, fillStyle = "#fff", strokeStyle = null) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fillStyle) {
      ctx.fillStyle = fillStyle;
      ctx.fill();
    }
    if (strokeStyle) {
      ctx.strokeStyle = strokeStyle;
      ctx.stroke();
    }
  }

  // Draw a fun wacky drone at droneX, droneY
  function drawDrone(t) {
    const x = droneX;
    const y = droneY + Math.sin(t / 300) * 6; // bob
    // Body
    ctx.save();
    ctx.translate(x, y);
    // shadow
    ctx.beginPath();
    ctx.ellipse(0, 42, 46, 16, 0, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(0,0,0,0.12)";
    ctx.fill();
    // body
    drawRoundedRect(-48, -18, 96, 44, 14, "#E3F6FF", "#1E90FF");
    // window
    ctx.beginPath();
    ctx.ellipse(0, -2, 26, 18, 0, 0, Math.PI * 2);
    ctx.fillStyle = "#BEEBFF";
    ctx.fill();
    ctx.strokeStyle = "rgba(0,0,0,0.08)";
    ctx.stroke();
    // propellers with wacky arms
    const armAngle = Math.sin(t / 150) * 0.12;
    for (let i = -1; i <= 1; i += 2) {
      ctx.save();
      ctx.translate(i * 56, -8);
      ctx.rotate(armAngle * i);
      ctx.fillStyle = "#D8F3FF";
      ctx.fillRect(-4, -4, 40, 8);
      // propeller blades
      ctx.beginPath();
      ctx.ellipse(26, 0, 14, 4, 0, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(0,0,0,0.06)";
      ctx.fill();
      ctx.restore();
    }
    // silly antenna
    ctx.beginPath();
    ctx.moveTo(20, -22);
    ctx.quadraticCurveTo(30, -36, 10, -44);
    ctx.strokeStyle = "#2b2b2b";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(10, -44, 6, 0, Math.PI * 2);
    ctx.fillStyle = "#FFD166";
    ctx.fill();
    ctx.restore();
  }

  // Draw calming sky background with clouds
  function drawBackground(t) {
    // gradient sky
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, "#F0FBFF");
    g.addColorStop(1, "#E6F7FF");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // gentle hills
    ctx.fillStyle = "#EAFBF4";
    ctx.beginPath();
    ctx.moveTo(0, HEIGHT);
    ctx.quadraticCurveTo(WIDTH * 0.25, HEIGHT - 120 - Math.sin(t / 1200) * 8, WIDTH * 0.5, HEIGHT - 60);
    ctx.quadraticCurveTo(WIDTH * 0.75, HEIGHT - 20 + Math.cos(t / 900) * 8, WIDTH, HEIGHT - 80);
    ctx.lineTo(WIDTH, HEIGHT);
    ctx.closePath();
    ctx.fill();

    // clouds
    for (let i = 0; i < 5; i++) {
      const cx = (i * 200 + (t / 6)) % (WIDTH + 160) - 80;
      const cy = 60 + (i % 2) * 20 + Math.sin((t / 500) + i) * 6;
      ctx.beginPath();
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.ellipse(cx, cy, 40, 18, 0, 0, Math.PI * 2);
      ctx.ellipse(cx - 28, cy + 6, 28, 12, 0, 0, Math.PI * 2);
      ctx.ellipse(cx + 26, cy + 6, 30, 12, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Draw UI layout ensuring no overlapping using measureText
  function drawUI(t) {
    ctx.save();
    // Score box top-left
    ctx.font = IMPORTANT_FONT;
    const scoreText = `Score: ${score}/${REQUIRED_CORRECT}`;
    const scoreW = ctx.measureText(scoreText).width + UI_PADDING * 3;
    scoreBox.w = clamp(scoreW, 80, 200);
    scoreBox.h = 44;
    drawRoundedRect(scoreBox.x, scoreBox.y, scoreBox.w, scoreBox.h, 8, "#FFFFFFAA", "#1E90FF");
    safeFillText(scoreText, scoreBox.x + 12, scoreBox.y + scoreBox.h / 2, IMPORTANT_FONT, "#1E2A78");

    // Lives top-right
    ctx.font = IMPORTANT_FONT;
    const livesText = `Lives: ${MAX_WRONG - wrongCount}`;
    const livesW = ctx.measureText(livesText).width + UI_PADDING * 3;
    livesBox.w = clamp(livesW, 100, 200);
    livesBox.h = 44;
    livesBox.x = WIDTH - livesBox.w - UI_PADDING;
    drawRoundedRect(livesBox.x, livesBox.y, livesBox.w, livesBox.h, 8, "#FFF2F2", "#D43F3F");
    safeFillText(livesText, livesBox.x + 12, livesBox.y + livesBox.h / 2, IMPORTANT_FONT, "#8B0000");

    // Progress bar under top area
    const progX = scoreBox.x + scoreBox.w + UI_PADDING;
    const progW = livesBox.x - progX - UI_PADDING;
    if (progW > 60) {
      const progY = scoreBox.y + (scoreBox.h - 16) / 2;
      ctx.fillStyle = "#FFFFFFCC";
      ctx.fillRect(progX, progY, progW, 16);
      ctx.fillStyle = "#70C1B3";
      const fraction = score / REQUIRED_CORRECT;
      ctx.fillRect(progX, progY, Math.max(6, progW * fraction), 16);
      safeFillText(`Progress`, progX + 6, progY + 8, BODY_FONT, "#133B2A", "left", "middle");
    }

    // Question in center top
    ctx.font = TITLE_FONT;
    const qText = question ? (question.type === "add" ? `${question.a} + ${question.b} = ?` : `${question.a} - ${question.b} = ?`) : "Ready?";
    const qW = ctx.measureText(qText).width;
    const qBoxW = qW + 32;
    questionBox.x = (WIDTH - qBoxW) / 2;
    questionBox.w = qBoxW;
    questionBox.h = 60;
    drawRoundedRect(questionBox.x, questionBox.y, questionBox.w, questionBox.h, 10, "#FFFFFFCC", "#0B5E6F");
    safeFillText(qText, questionBox.x + questionBox.w / 2, questionBox.y + questionBox.h / 2, TITLE_FONT, "#003E4D", "center");

    // Options area background
    drawRoundedRect(optionsArea.x - 10, optionsArea.y - 10, optionsArea.w + 20, optionsArea.h + 20, 14, "#FFFFFFEE", "#91C7B1");

    // Draw options as landing pads in a grid 2x2
    optionBoxes.length = 0;
    const rows = 2, cols = 2;
    const padW = (optionsArea.w - (cols - 1) * 20) / cols;
    const padH = (optionsArea.h - (rows - 1) * 20) / rows;
    ctx.font = OPTION_FONT;
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const idx = r * cols + c;
        const ox = optionsArea.x + c * (padW + 20);
        const oy = optionsArea.y + r * (padH + 20);
        const bx = ox;
        const by = oy;
        const bw = padW;
        const bh = padH;
        let fillColor = "#F7FFF7";
        let strokeColor = "#3A7D44";
        if (idx === hoverOption) {
          fillColor = "#FFF8E1";
          strokeColor = "#E9A800";
        } else if (idx === selectedOption) {
          fillColor = "#E8F6FF";
          strokeColor = "#146C94";
        }
        drawRoundedRect(bx, by, bw, bh, 12, fillColor, strokeColor);
        // Labeling option with number for keyboard (1-4)
        const label = `${idx + 1}. ${options[idx] !== undefined ? options[idx] : ""}`;
        // Ensure text fits
        let fontToUse = OPTION_FONT;
        ctx.font = fontToUse;
        let textWidth = ctx.measureText(label).width;
        if (textWidth > bw - 24) {
          // reduce font
          fontToUse = "18px sans-serif";
          ctx.font = fontToUse;
          textWidth = ctx.measureText(label).width;
        }
        // Draw number badge
        const badgeW = 36;
        drawRoundedRect(bx + 10, by + 10, badgeW, 28, 8, "#1E90FF", "#0F4C81");
        safeFillText(`${idx + 1}`, bx + 10 + badgeW / 2, by + 10 + 14, "18px sans-serif", "#FFF", "center");
        // Draw option number
        safeFillText(label, bx + 10 + badgeW + 12, by + bh / 2, fontToUse, "#05386B", "left");
        optionBoxes.push({ x: bx, y: by, w: bw, h: bh });
      }
    }

    // Draw mini speaker audio indicator bottom-left
    const audioText = audioEnabled ? "Audio: ON (M)" : "Audio: OFF (M)";
    ctx.font = BODY_FONT;
    const atW = ctx.measureText(audioText).width + 20;
    const aBoxX = UI_PADDING;
    const aBoxY = HEIGHT - 120;
    drawRoundedRect(aBoxX, aBoxY, atW, 36, 8, "#FFFFFFDD", "#666");
    safeFillText(audioText, aBoxX + 12, aBoxY + 18, BODY_FONT, "#333");

    // Instructions bottom-center
    ctx.font = BODY_FONT;
    const instrLines = [
      "Controls: Click an option or press 1-4 to pick. Use ← → to change selection, Enter or Space to confirm.",
      "Goal: Answer 10 questions correctly. You can make 3 mistakes. Press R to restart at any time.",
    ];
    const instrPadding = 12;
    // Measure maximum width
    let maxW = 0;
    instrLines.forEach(line => {
      const w = ctx.measureText(line).width;
      if (w > maxW) maxW = w;
    });
    const instrW = maxW + instrPadding * 2;
    instructionsBox.w = instrW;
    instructionsBox.x = (WIDTH - instrW) / 2;
    drawRoundedRect(instructionsBox.x, instructionsBox.y, instructionsBox.w, instructionsBox.h, 10, "#FFFFFFCC", "#264653");
    ctx.fillStyle = "#071B2F";
    for (let i = 0; i < instrLines.length; i++) {
      safeFillText(instrLines[i], instructionsBox.x + instructionsBox.w / 2, instructionsBox.y + 16 + i * 20, BODY_FONT, "#073B4C", "center", "top");
    }

    ctx.restore();
  }

  // Draw overlay screens
  function drawStartScreen() {
    // translucent overlay
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    // title
    drawRoundedRect(80, 80, WIDTH - 160, HEIGHT - 160, 14, "#FFFFFFEE", "#0B5E6F");
    safeFillText("Drone Math Adventure!", WIDTH / 2, 130, TITLE_FONT, "#083D77", "center");
    ctx.font = IMPORTANT_FONT;
    const desc = "Fly your friendly drone to pick the correct answers to math puzzles!";
    const w = ctx.measureText(desc).width;
    safeFillText(desc, WIDTH / 2, 170, BODY_FONT, "#0B5E6F", "center");
    // start button
    const btnW = 220, btnH = 48;
    const bx = WIDTH / 2 - btnW / 2, by = HEIGHT / 2 - 20;
    drawRoundedRect(bx, by, btnW, btnH, 10, "#70C1B3", "#167F6B");
    safeFillText("Start Game (Enter)", bx + btnW / 2, by + btnH / 2, IMPORTANT_FONT, "#052B2A", "center");
    // small help
    ctx.font = BODY_FONT;
    safeFillText("Hint: Use number keys 1-4 for quick answers. Press M to toggle audio.", WIDTH / 2, by + btnH + 36, BODY_FONT, "#083D77", "center");
  }

  function drawWinScreen() {
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    safeFillText("You did it!", WIDTH / 2, 120, TITLE_FONT, "#0B5E6F", "center");
    safeFillText(`Correct answers: ${score}`, WIDTH / 2, 160, IMPORTANT_FONT, "#0B5E6F", "center");
    // confetti doodles
    for (let i = 0; i < 28; i++) {
      const x = Math.random() * WIDTH;
      const y = 210 + Math.random() * 180;
      ctx.fillStyle = `hsl(${Math.floor(Math.random() * 360)}, 80%, 60%)`;
      ctx.fillRect(x, y, 6, 6);
    }
    // victory drone larger
    ctx.save();
    ctx.translate(WIDTH / 2, 250);
    drawDrone(performance.now());
    ctx.restore();
    // Restart button
    const btnW = 200, btnH = 46;
    const bx = WIDTH / 2 - btnW / 2, by = HEIGHT - 120;
    drawRoundedRect(bx, by, btnW, btnH, 10, "#FDE68A", "#D97706");
    safeFillText("Play Again (R)", bx + btnW / 2, by + btnH / 2, IMPORTANT_FONT, "#5B3E02", "center");
  }

  function drawGameOverScreen() {
    // smoky overlay
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    drawRoundedRect(80, 80, WIDTH - 160, HEIGHT - 160, 14, "#FFF5F5", "#8B0000");
    safeFillText("Game Over", WIDTH / 2, 130, TITLE_FONT, "#8B0000", "center");
    safeFillText(`You answered ${score} correctly.`, WIDTH / 2, 170, IMPORTANT_FONT, "#641E16", "center");
    // broken drone
    ctx.save();
    ctx.translate(WIDTH / 2, 260);
    ctx.rotate(-0.05);
    // broken body
    drawRoundedRect(-60, -20, 120, 40, 10, "#FFECEC", "#C53030");
    // cracked window
    ctx.beginPath();
    ctx.arc(10, -2, 20, 0, Math.PI * 2);
    ctx.fillStyle = "#FFFBF0";
    ctx.fill();
    ctx.strokeStyle = "#C53030";
    ctx.beginPath();
    ctx.moveTo(0, -8);
    ctx.lineTo(18, 2);
    ctx.moveTo(6, -12);
    ctx.lineTo(6, 8);
    ctx.stroke();
    ctx.restore();
    // Restart button
    const btnW = 200, btnH = 46;
    const bx = WIDTH / 2 - btnW / 2, by = HEIGHT - 120;
    drawRoundedRect(bx, by, btnW, btnH, 10, "#FFB4B4", "#9B1C1C");
    safeFillText("Try Again (R)", bx + btnW / 2, by + btnH / 2, IMPORTANT_FONT, "#6E0F0F", "center");
  }

  // Click/interaction handlers
  function getOptionIndexAt(x, y) {
    for (let i = 0; i < optionBoxes.length; i++) {
      const b = optionBoxes[i];
      if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) return i;
    }
    return -1;
  }

  function handleClick(x, y) {
    if (state === "start") {
      // Check start button area
      const bx = WIDTH / 2 - 110, by = HEIGHT / 2 - 20, bw = 220, bh = 48;
      if (x >= bx && x <= bx + bw && y >= by && y <= by + bh) {
        startGame();
      }
    } else if (state === "playing") {
      // Check options
      const idx = getOptionIndexAt(x, y);
      if (idx >= 0) {
        selectedOption = idx;
        confirmSelection();
        return;
      }
      // Check audio toggle area
      const aBoxX = UI_PADDING, aBoxY = HEIGHT - 120, aBoxW = ctx.measureText(audioEnabled ? "Audio: ON (M)" : "Audio: OFF (M)").width + 20, aBoxH = 36;
      if (x >= aBoxX && x <= aBoxX + aBoxW && y >= aBoxY && y <= aBoxY + aBoxH) {
        toggleAudio();
        return;
      }
    } else if (state === "win" || state === "gameover") {
      // Restart button
      const bx = WIDTH / 2 - 100, by = HEIGHT - 120, bw = 200, bh = 46;
      if (x >= bx && x <= bx + bw && y >= by && y <= by + bh) {
        restartGame();
      }
    }
  }

  // Confirm selection (evaluation)
  function confirmSelection() {
    if (state !== "playing") return;
    if (selectedOption < 0 || selectedOption >= options.length) return;
    const chosen = options[selectedOption];
    if (chosen === question.correct) {
      score++;
      playCorrectSound();
      // small celebration: animate drone upward briefly
      droneY -= 8;
      if (score >= REQUIRED_CORRECT) {
        state = "win";
        // stop ambient if wanted but keep audio
      } else {
        // next question after short delay
        setTimeout(() => {
          generateQuestion();
        }, 600);
      }
    } else {
      wrongCount++;
      playIncorrectSound();
      // shake drone
      droneX += (Math.random() - 0.5) * 12;
      if (wrongCount >= MAX_WRONG) {
        state = "gameover";
      } else {
        // show a hint bubble maybe
        setTimeout(() => {
          generateQuestion();
        }, 600);
      }
    }
  }

  // Keyboard handling
  canvas.addEventListener("keydown", (e) => {
    // Ensure audio resume first user gesture
    resumeAudioIfNeeded();
    if (e.key === "r" || e.key === "R") {
      restartGame();
      e.preventDefault();
      return;
    }
    if (e.key === "m" || e.key === "M") {
      toggleAudio();
      e.preventDefault();
      return;
    }
    if (state === "start") {
      if (e.key === "Enter" || e.key === " ") {
        startGame();
        e.preventDefault();
      }
      return;
    }
    if (state === "playing") {
      if (e.key >= "1" && e.key <= "4") {
        const idx = parseInt(e.key, 10) - 1;
        if (idx < options.length) {
          selectedOption = idx;
          confirmSelection();
        }
        e.preventDefault();
        return;
      }
      if (e.key === "ArrowLeft" || e.key === "ArrowUp") {
        // move selection left/up
        if (selectedOption === -1) selectedOption = 0;
        else selectedOption = (selectedOption + options.length - 1) % options.length;
        e.preventDefault();
        return;
      }
      if (e.key === "ArrowRight" || e.key === "ArrowDown") {
        if (selectedOption === -1) selectedOption = 0;
        else selectedOption = (selectedOption + 1) % options.length;
        e.preventDefault();
        return;
      }
      if (e.key === "Enter" || e.key === " ") {
        if (selectedOption >= 0) confirmSelection();
        e.preventDefault();
        return;
      }
    }
    if (state === "win" || state === "gameover") {
      if (e.key === "r" || e.key === "R" || e.key === "Enter") {
        restartGame();
        e.preventDefault();
      }
    }
  });

  // Mouse events
  canvas.addEventListener("mousedown", (ev) => {
    const rect = canvas.getBoundingClientRect();
    const x = (ev.clientX - rect.left) * (canvas.width / rect.width);
    const y = (ev.clientY - rect.top) * (canvas.height / rect.height);
    handleClick(x, y);
  });

  canvas.addEventListener("mousemove", (ev) => {
    const rect = canvas.getBoundingClientRect();
    const x = (ev.clientX - rect.left) * (canvas.width / rect.width);
    const y = (ev.clientY - rect.top) * (canvas.height / rect.height);
    // track hover
    const idx = getOptionIndexAt(x, y);
    if (idx !== hoverOption) {
      hoverOption = idx;
    }
  });

  // Toggle audio
  function toggleAudio() {
    if (!audioCtx) {
      audioEnabled = false;
      return;
    }
    audioEnabled = !audioEnabled;
    if (!audioEnabled) {
      try { masterGain.gain.setValueAtTime(0, audioCtx.currentTime); } catch (e) { /* ignore */ }
    } else {
      try { masterGain.gain.setValueAtTime(0.9, audioCtx.currentTime); resumeAudioIfNeeded(); } catch (e) { /* ignore */ }
    }
  }

  // Start and restart
  function startGame() {
    score = 0;
    wrongCount = 0;
    state = "playing";
    generateQuestion();
    // set drone starting position
    droneX = WIDTH / 2;
    droneY = HEIGHT / 2 - 40;
    lastTime = performance.now();
    resumeAudioIfNeeded();
  }

  function restartGame() {
    // Reset audio resume gesture
    if (audioCtx && audioCtx.state === "suspended") resumeAudioIfNeeded();
    score = 0;
    wrongCount = 0;
    selectedOption = -1;
    hoverOption = -1;
    state = "start";
  }

  // Initialize
  restartGame();

  // Main loop
  function loop(now) {
    const dt = now - lastTime;
    lastTime = now;
    // Update drone drift towards selected option visually for fun
    if (state === "playing") {
      // Slight aim towards hovered option to encourage clicking
      if (hoverOption >= 0 && optionBoxes[hoverOption]) {
        const b = optionBoxes[hoverOption];
        const targetX = b.x + b.w / 2;
        const targetY = b.y - 20;
        droneX += (targetX - droneX) * 0.04;
        droneY += (targetY - droneY) * 0.03;
      } else {
        // drift to center
        droneX += (WIDTH / 2 - droneX) * 0.02;
        droneY += ((HEIGHT / 2 - 40) - droneY) * 0.02;
      }
    } else {
      // idle bob at center
      droneX += (WIDTH / 2 - droneX) * 0.05;
      droneY += ((HEIGHT / 2 - 40) - droneY) * 0.05;
    }

    // Draw frame
    drawBackground(now);
    drawUI(now);
    // draw drone on top
    drawDrone(now);

    // State overlays
    if (state === "start") {
      drawStartScreen();
    } else if (state === "win") {
      drawWinScreen();
    } else if (state === "gameover") {
      drawGameOverScreen();
    }

    // Visual cues for audio state: small border change if audio disabled
    ctx.save();
    if (!audioEnabled) {
      ctx.strokeStyle = "#FF6B6B";
      ctx.lineWidth = 4;
      ctx.strokeRect(6, 6, WIDTH - 12, HEIGHT - 12);
      // small text
      ctx.font = BODY_FONT;
      safeFillText("Audio disabled", WIDTH - 100, HEIGHT - 20, BODY_FONT, "#FF6B6B");
    }
    ctx.restore();

    // Ensure text elements do not overlap: minimal checks
    // (We placed elements with padding and used measureText to size boxes.)
    // Next frame
    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);

  // Expose some stuff to console for debugging (non-essential)
  window.__droneMathGame = {
    restartGame,
    startGame,
    toggleAudio,
    getState: () => ({ state, score, wrongCount }),
  };
})();
---

