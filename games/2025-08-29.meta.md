# Game of the Day - 2025-08-29

## Metadata
- **Generated Date:** 2025-08-29
- **Generated Time:** 2025-08-29T00:27:11.839064
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-08-29.js
- **File Size:** 30229 bytes
- **Tokens Used:** 9989

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-08-29.js` - The playable game
- `2025-08-29.meta.json` - Machine-readable metadata
- `2025-08-29.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 20742

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 23018

### Final Functionality Score After Improvement
- **Score:** 7/8 (87.5%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- ⚠️  No game state management found

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function() {
  // Machine Math — a calming, wacky math game for ages 7-9
  // Renders inside the element with ID "game-of-the-day-stage".
  // All visuals drawn to canvas. All sounds generated with Web Audio API.
  // Controls: Left/Right to move selection, Up/Down to change values, Enter to process,
  // Space to toggle values/ops, M to mute/unmute. Click/tap also supported.
  // Accessible live region included for screen readers.

  // -----------------------
  // Setup container & canvas
  // -----------------------
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Error: container element with id "game-of-the-day-stage" not found.');
    return;
  }
  container.style.position = 'relative';
  container.style.userSelect = 'none';
  container.setAttribute('tabindex', '0'); // make focusable for keyboard

  // Clean container
  container.innerHTML = '';

  // Create an offscreen (visually hidden) live region for accessibility
  const liveRegion = document.createElement('div');
  liveRegion.setAttribute('role', 'status');
  liveRegion.setAttribute('aria-live', 'polite');
  liveRegion.style.position = 'absolute';
  liveRegion.style.left = '-9999px';
  liveRegion.style.width = '1px';
  liveRegion.style.height = '1px';
  liveRegion.style.overflow = 'hidden';
  container.appendChild(liveRegion);

  // Canvas creation
  const canvas = document.createElement('canvas');
  canvas.width = 720;
  canvas.height = 480;
  canvas.style.width = '720px';
  canvas.style.height = '480px';
  canvas.style.display = 'block';
  canvas.style.outline = 'none';
  canvas.setAttribute('aria-label', 'Machine Math game canvas');
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Focus container for keyboard events
  container.focus();

  // -----------------------
  // Utility functions
  // -----------------------
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function clamp(v, a, b) {
    return Math.max(a, Math.min(b, v));
  }

  function safeText(s) {
    return String(s);
  }

  // -----------------------
  // Audio Manager
  // -----------------------
  class AudioManager {
    constructor() {
      this.enabled = true;
      this.available = false;
      this.ctx = null;
      this.master = null;
      this.bgGain = null;
      this.bgOsc = null;
      this.lfo = null;
      this.lfoGain = null;
      this.initPromise = this.init();
    }

    async init() {
      try {
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        if (!AudioCtx) throw new Error('Web Audio API not supported');

        this.ctx = new AudioCtx();
        this.master = this.ctx.createGain();
        this.master.gain.value = 0.9;
        this.master.connect(this.ctx.destination);

        // Background hum: gentle triangle/sine with lowpass
        this.bgGain = this.ctx.createGain();
        this.bgGain.gain.value = 0.02;
        this.bgGain.connect(this.master);

        this.bgOsc = this.ctx.createOscillator();
        this.bgOsc.type = 'sine';
        this.bgOsc.frequency.value = 110; // low hum
        this.bgOsc.connect(this.bgGain);

        // subtle movement with LFO
        this.lfo = this.ctx.createOscillator();
        this.lfo.type = 'sine';
        this.lfo.frequency.value = 0.05;
        this.lfoGain = this.ctx.createGain();
        this.lfoGain.gain.value = 8; // modulate frequency slightly
        this.lfo.connect(this.lfoGain);
        this.lfoGain.connect(this.bgOsc.frequency);

        // start if allowed; might require user gesture to resume later
        try {
          this.bgOsc.start();
          this.lfo.start();
        } catch (e) {
          // Some browsers may throw if not allowed to start yet.
        }

        this.available = true;
        return true;
      } catch (err) {
        console.warn('Audio init failed:', err);
        this.available = false;
        return false;
      }
    }

    async ensureStarted() {
      if (!this.available) return false;
      try {
        if (this.ctx.state === 'suspended') {
          await this.ctx.resume();
        }
        if (this.bgOsc && this.bgGain) {
          this.bgGain.gain.setTargetAtTime(0.02, this.ctx.currentTime, 0.05);
        }
        return true;
      } catch (err) {
        console.warn('Audio resume failed:', err);
        return false;
      }
    }

    setMuted(muted) {
      this.enabled = !muted;
      if (this.master) {
        this.master.gain.value = this.enabled ? 0.9 : 0;
      }
    }

    // simple click sound
    playClick() {
      if (!this.available || !this.enabled) return;
      try {
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        o.type = 'square';
        o.frequency.value = 600;
        g.gain.value = 0.0001;
        o.connect(g);
        g.connect(this.master);
        const t = this.ctx.currentTime;
        g.gain.setValueAtTime(0.0001, t);
        g.gain.exponentialRampToValueAtTime(0.07, t + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, t + 0.18);
        o.start(t);
        o.stop(t + 0.2);
      } catch (e) {
        console.warn('playClick error', e);
      }
    }

    // correct chime: ascending arpeggio
    playCorrect() {
      if (!this.available || !this.enabled) return;
      try {
        const now = this.ctx.currentTime;
        const freqs = [440, 660, 880];
        freqs.forEach((f, i) => {
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.type = 'sine';
          o.frequency.value = f;
          g.gain.value = 0.0001;
          o.connect(g);
          g.connect(this.master);
          const t0 = now + i * 0.09;
          g.gain.setValueAtTime(0.0001, t0);
          g.gain.exponentialRampToValueAtTime(0.12, t0 + 0.06);
          g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.26);
          o.start(t0);
          o.stop(t0 + 0.28);
        });
      } catch (e) {
        console.warn('playCorrect error', e);
      }
    }

    // wrong buzzer
    playWrong() {
      if (!this.available || !this.enabled) return;
      try {
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        const f = this.ctx.createBiquadFilter();
        o.type = 'sawtooth';
        o.frequency.value = 200;
        f.type = 'lowpass';
        f.frequency.value = 900;
        g.gain.value = 0.0001;
        o.connect(f);
        f.connect(g);
        g.connect(this.master);
        const now = this.ctx.currentTime;
        g.gain.setValueAtTime(0.0001, now);
        g.gain.exponentialRampToValueAtTime(0.12, now + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.45);
        o.frequency.setValueAtTime(200, now);
        o.frequency.linearRampToValueAtTime(80, now + 0.45);
        o.start(now);
        o.stop(now + 0.5);
      } catch (e) {
        console.warn('playWrong error', e);
      }
    }

    // gentle whoosh for machine processing
    playProcess() {
      if (!this.available || !this.enabled) return;
      try {
        const now = this.ctx.currentTime;
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        const f = this.ctx.createBiquadFilter();
        o.type = 'triangle';
        o.frequency.value = 300;
        f.type = 'lowpass';
        f.frequency.value = 800;
        o.connect(f);
        f.connect(g);
        g.connect(this.master);
        g.gain.setValueAtTime(0.0001, now);
        g.gain.linearRampToValueAtTime(0.09, now + 0.06);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.8);
        o.frequency.setValueAtTime(300, now);
        o.frequency.exponentialRampToValueAtTime(80, now + 0.8);
        o.start(now);
        o.stop(now + 0.9);
      } catch (e) {
        console.warn('playProcess error', e);
      }
    }
  }

  const audio = new AudioManager();

  // -----------------------
  // Game logic
  // -----------------------
  const OPS = ['+', '-', '×']; // multiplication shown as ×
  function applyOp(a, op, b) {
    if (op === '+') return a + b;
    if (op === '-') return a - b;
    if (op === '×') return a * b;
    return a;
  }

  class MachineGame {
    constructor(ctx, canvas, audio, liveRegion) {
      this.ctx = ctx;
      this.canvas = canvas;
      this.audio = audio;
      this.liveRegion = liveRegion;

      // game state
      this.numbers = [1, 2, 3];
      this.ops = ['+', '+'];
      this.target = 0;
      this.attempts = 0;
      this.maxAttempts = 4;
      this.round = 0;
      this.totalRounds = 6;
      this.solvedCount = 0;
      this.selectionIndex = 0; // 0..4 mapping: 0 gear0,1 op0,2 gear1,3 op1,4 gear2
      this.animationTime = 0;
      this.running = true;
      this.muted = false;

      // visual elements
      this.gearAngle = 0;
      this.particles = [];
      this.confetti = [];

      // initialize first round
      this.newRound();

      // input handlers
      this.setupInput();

      // start animation loop
      this.lastTime = performance.now();
      this.rafId = requestAnimationFrame((t) => this.frame(t));
    }

    newRound() {
      this.round++;
      if (this.round > this.totalRounds) {
        // done; show summary
        this.endGame();
        return;
      }
      // generate numbers 1..9 and a solution ops, then set target accordingly
      // Keep numbers simple for ages 7-9 by using 1..9 small numbers
      this.numbers = [randInt(1, 9), randInt(1, 9), randInt(1, 9)];

      // pick a random pair of ops as the solution
      const solutionOps = [OPS[randInt(0, OPS.length - 1)], OPS[randInt(0, OPS.length - 1)]];

      // compute target by applying left-to-right
      let value = applyOp(this.numbers[0], solutionOps[0], this.numbers[1]);
      value = applyOp(value, solutionOps[1], this.numbers[2]);
      this.target = value;

      // display initial ops scrambled (random) so player must find solution
      this.ops = [OPS[randInt(0, OPS.length - 1)], OPS[randInt(0, OPS.length - 1)]];

      // reset attempts
      this.attempts = 0;
      this.selectionIndex = 0;
      this.addLive(`Round ${this.round} of ${this.totalRounds}. Target ${this.target}. Use arrows or click to set operations and numbers. Press Enter to process.`);
    }

    endGame() {
      this.running = false;
      // stop animation and show final screen (but still allow restart)
      this.addLive(`Game complete. You solved ${this.solvedCount} out of ${this.totalRounds} puzzles.`);
    }

    addLive(text) {
      try {
        this.liveRegion.textContent = text;
      } catch (e) {
        // ignore
      }
    }

    setupInput() {
      // keyboard
      this.keyDownHandler = (e) => {
        // ensure audio context is started on first user interaction
        if (this.audio && this.audio.available) {
          this.audio.ensureStarted().catch(() => {});
        }
        if (!this.running) {
          // allow restart with Enter
          if (e.key === 'Enter') {
            this.restart();
          }
          return;
        }

        if (e.key === 'ArrowLeft') {
          this.selectionIndex = clamp(this.selectionIndex - 1, 0, 4);
          this.audio.playClick();
          e.preventDefault();
        } else if (e.key === 'ArrowRight') {
          this.selectionIndex = clamp(this.selectionIndex + 1, 0, 4);
          this.audio.playClick();
          e.preventDefault();
        } else if (e.key === 'ArrowUp') {
          this.changeSelected(1);
          e.preventDefault();
        } else if (e.key === 'ArrowDown') {
          this.changeSelected(-1);
          e.preventDefault();
        } else if (e.key === ' ' || e.key === 'Spacebar') {
          // toggle or quick rotate (space)
          this.toggleSelected();
          e.preventDefault();
        } else if (e.key === 'Enter') {
          this.processMachine();
          e.preventDefault();
        } else if (e.key.toLowerCase() === 'm') {
          this.toggleMute();
          e.preventDefault();
        }
      };
      container.addEventListener('keydown', this.keyDownHandler);

      // mouse / touch
      this.canvas.addEventListener('pointerdown', (e) => {
        const rect = this.canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (this.canvas.width / rect.width);
        const y = (e.clientY - rect.top) * (this.canvas.height / rect.height);
        this.handlePointer(x, y);
        // start audio context on interaction
        if (this.audio && this.audio.available) {
          this.audio.ensureStarted().catch(() => {});
        }
      });
    }

    restart() {
      // reset stats
      this.round = 0;
      this.solvedCount = 0;
      this.running = true;
      this.newRound();
      this.lastTime = performance.now();
      this.rafId = requestAnimationFrame((t) => this.frame(t));
    }

    toggleMute() {
      this.muted = !this.muted;
      this.audio.setMuted(this.muted);
      this.addLive(this.muted ? 'Sound muted.' : 'Sound unmuted.');
    }

    changeSelected(delta) {
      if (!this.running) return;
      if (this.selectionIndex % 2 === 0) {
        // gear selected: change number
        const gearIndex = this.selectionIndex / 2;
        this.numbers[gearIndex] = clamp(this.numbers[gearIndex] + delta, 1, 12);
        this.audio.playClick();
      } else {
        // op selected: cycle through OPS
        const opIndex = Math.floor(this.selectionIndex / 2);
        const currentIndex = OPS.indexOf(this.ops[opIndex]);
        const nextIndex = (currentIndex + (delta > 0 ? 1 : OPS.length - 1)) % OPS.length;
        this.ops[opIndex] = OPS[nextIndex];
        this.audio.playClick();
      }
      this.addLive(`Selected ${this.describeSelection()}. Numbers: ${this.numbers.join(', ')}. Operations: ${this.ops.join(', ')}.`);
    }

    toggleSelected() {
      if (!this.running) return;
      // a quick toggle for numbers and ops
      if (this.selectionIndex % 2 === 0) {
        // set to random number for fun
        const gearIndex = this.selectionIndex / 2;
        this.numbers[gearIndex] = randInt(1, 9);
        this.audio.playClick();
      } else {
        const opIndex = Math.floor(this.selectionIndex / 2);
        const i = OPS.indexOf(this.ops[opIndex]);
        this.ops[opIndex] = OPS[(i + 1) % OPS.length];
        this.audio.playClick();
      }
      this.addLive(`Selected ${this.describeSelection()}.`);
    }

    describeSelection() {
      if (this.selectionIndex % 2 === 0) {
        return `gear ${this.selectionIndex / 2 + 1}`;
      } else {
        return `lever ${Math.floor(this.selectionIndex / 2) + 1}`;
      }
    }

    handlePointer(x, y) {
      // detect clicked element
      // Machine layout: central horizontal band where gears and levers are centered
      const cx = this.canvas.width / 2;
      const cy = this.canvas.height / 2;
      // positions for three gears
      const gearX = [cx - 200, cx, cx + 200];
      const gearY = cy - 20;
      const gearR = 60;
      // check gears
      for (let i = 0; i < 3; i++) {
        const dx = x - gearX[i];
        const dy = y - gearY;
        if (dx * dx + dy * dy <= gearR * gearR) {
          // select this gear
          this.selectionIndex = i * 2;
          // change number on click
          this.numbers[i] = (this.numbers[i] % 9) + 1;
          this.audio.playClick();
          this.addLive(`Changed gear ${i + 1} to ${this.numbers[i]}.`);
          return;
        }
      }
      // check levers (ops)
      const leverX = [cx - 100, cx + 100];
      const leverY = cy - 20;
      const leverW = 80;
      const leverH = 40;
      for (let j = 0; j < 2; j++) {
        const lx = leverX[j] - leverW / 2;
        const ly = leverY - leverH / 2;
        if (x >= lx && x <= lx + leverW && y >= ly && y <= ly + leverH) {
          this.selectionIndex = j * 2 + 1;
          // toggle op on click
          const idx = OPS.indexOf(this.ops[j]);
          this.ops[j] = OPS[(idx + 1) % OPS.length];
          this.audio.playClick();
          this.addLive(`Set lever ${j + 1} to ${this.ops[j]}.`);
          return;
        }
      }
      // check process button area (bottom)
      const btnX = this.canvas.width / 2 - 80;
      const btnY = this.canvas.height - 80;
      const btnW = 160;
      const btnH = 48;
      if (x >= btnX && x <= btnX + btnW && y >= btnY && y <= btnY + btnH) {
        this.processMachine();
      }
    }

    processMachine() {
      if (!this.running) return;
      this.attempts++;
      this.audio.playProcess();
      // compute left-to-right
      let v = applyOp(this.numbers[0], this.ops[0], this.numbers[1]);
      v = applyOp(v, this.ops[1], this.numbers[2]);
      if (v === this.target) {
        // correct
        this.solvedCount++;
        this.addLive(`Correct! You reached ${v}. Great job!`);
        this.audio.playCorrect();
        this.spawnConfetti(30);
        // short delay then next round
        setTimeout(() => {
          this.newRound();
        }, 900);
      } else {
        // incorrect
        this.audio.playWrong();
        this.addLive(`Oops — result ${v} does not match target ${this.target}. Attempt ${this.attempts} of ${this.maxAttempts}.`);
        // show hint after 2 attempts
        if (this.attempts >= this.maxAttempts) {
          // reveal solution and proceed to next
          // compute an actual solution by brute-forcing ops
          const sol = this.findSolution();
          if (sol) {
            this.addLive(`Here's a helpful hint: try ${this.numbers[0]} ${sol[0]} ${this.numbers[1]} ${sol[1]} ${this.numbers[2]} = ${this.target}. Moving to next round.`);
            // animate gears for reveal
            this.spawnParticles(20);
            setTimeout(() => {
              this.newRound();
            }, 1400);
          } else {
            // Should not happen because we generated the target from a valid combination
            this.addLive('No valid solution found (unexpected). Moving on.');
            setTimeout(() => this.newRound(), 1000);
          }
        }
      }
    }

    findSolution() {
      for (const a of OPS) {
        for (const b of OPS) {
          let v = applyOp(this.numbers[0], a, this.numbers[1]);
          v = applyOp(v, b, this.numbers[2]);
          if (v === this.target) return [a, b];
        }
      }
      return null;
    }

    spawnParticles(n) {
      for (let i = 0; i < n; i++) {
        this.particles.push({
          x: this.canvas.width / 2 + randInt(-50, 50),
          y: this.canvas.height / 2 + randInt(-30, 30),
          vx: (Math.random() - 0.5) * 2,
          vy: -Math.random() * 2 - 1,
          life: randInt(40, 80),
          color: `hsla(${randInt(160, 220)},50%,60%,0.9)`
        });
      }
    }

    spawnConfetti(n) {
      for (let i = 0; i < n; i++) {
        this.confetti.push({
          x: this.canvas.width / 2 + randInt(-200, 200),
          y: this.canvas.height / 2 - 60 + randInt(-20, 20),
          vx: (Math.random() - 0.5) * 6,
          vy: Math.random() * 3 + 1,
          rot: Math.random() * Math.PI,
          vr: (Math.random() - 0.5) * 0.2,
          life: randInt(80, 180),
          color: `hsla(${randInt(0, 360)},70%,60%,0.95)`
        });
      }
    }

    updateParticles() {
      for (let p of this.particles) {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.08;
        p.life--;
      }
      this.particles = this.particles.filter(p => p.life > 0 && p.y < this.canvas.height + 50);

      for (let c of this.confetti) {
        c.x += c.vx;
        c.y += c.vy;
        c.vy += 0.05;
        c.rot += c.vr;
        c.life--;
      }
      this.confetti = this.confetti.filter(c => c.life > 0 && c.y < this.canvas.height + 50);
    }

    drawBackground() {
      const g = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
      g.addColorStop(0, '#E8F6F3');
      g.addColorStop(1, '#F8FBFF');
      this.ctx.fillStyle = g;
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

      // soft cloud blobs
      for (let i = 0; i < 6; i++) {
        const x = (i * 140 + (this.animationTime * 10) % 840) % (this.canvas.width + 200) - 100;
        const y = 60 + Math.sin((i + this.animationTime / 100) * 0.7) * 10;
        this.ctx.beginPath();
        this.ctx.fillStyle = 'rgba(255,255,255,0.85)';
        this.ctx.moveTo(x, y);
        this.ctx.ellipse(x, y, 70, 30, 0, 0, Math.PI * 2);
        this.ctx.fill();
      }
    }

    drawMachine() {
      const cx = this.canvas.width / 2;
      const cy = this.canvas.height / 2;

      // machine base
      this.ctx.fillStyle = '#DCECF2';
      this.roundedRect(this.ctx, cx - 320, cy - 120, 640, 240, 24);
      this.ctx.fill();

      // console panel
      this.ctx.fillStyle = '#C5E2EC';
      this.roundedRect(this.ctx, cx - 260, cy - 100, 520, 60, 12);
      this.ctx.fill();

      // Target display on top left
      this.ctx.fillStyle = '#073B4C';
      this.ctx.font = '20px "Segoe UI", Roboto, sans-serif';
      this.ctx.fillText('Target:', cx - 240, cy - 70);
      this.ctx.fillStyle = '#0B8793';
      this.ctx.font = '28px "Segoe UI", Roboto, sans-serif';
      this.ctx.fillText(String(this.target), cx - 160, cy - 70);

      // attempts and round display top right
      this.ctx.fillStyle = '#073B4C';
      this.ctx.font = '16px "Segoe UI", Roboto, sans-serif';
      this.ctx.fillText(`Round ${this.round}/${this.totalRounds}`, cx + 10, cy - 70);
      this.ctx.fillText(`Attempts ${this.attempts}/${this.maxAttempts}`, cx + 10, cy - 50);

      // draw three gears and levers
      const gearX = [cx - 200, cx, cx + 200];
      const gearY = cy - 20;
      const gearR = 60;

      // draw levers (ops)
      const leverX = [cx - 100, cx + 100];
      for (let j = 0; j < 2; j++) {
        const lx = leverX[j];
        const ly = gearY;
        const w = 80;
        const h = 40;
        // lever body
        this.ctx.fillStyle = '#F6F9FB';
        this.roundedRect(this.ctx, lx - w / 2, ly - h / 2 - 20, w, h, 10);
        this.ctx.fill();
        // lever text
        this.ctx.fillStyle = this.selectionIndex === j * 2 + 1 ? '#0B8793' : '#2E5E6D';
        this.ctx.font = '26px "Segoe UI", Roboto, sans-serif';
        this.ctx.fillText(this.ops[j], lx - 8, ly + 2 - 20);
        // small lever handle
        this.ctx.fillStyle = '#D6EEF3';
        this.ctx.beginPath();
        this.ctx.ellipse(lx, ly + 14 - 20, 28, 9, 0, 0, Math.PI * 2);
        this.ctx.fill();
      }

      // draw gears
      for (let i = 0; i < 3; i++) {
        const x = gearX[i];
        const y = gearY;
        // gear rotation depends on overall animation and index
        const angle = this.gearAngle * (i % 2 === 0 ? 1 : -1) * (1 + i * 0.1);
        this.drawGear(x, y, gearR, angle, i === 0 ? '#BEE8D2' : i === 1 ? '#FFE2A8' : '#FFD6E0', this.selectionIndex === i * 2 ? '#0B8793' : '#376B78', String(this.numbers[i]));
      }

      // process button
      const btnX = this.canvas.width / 2 - 80;
      const btnY = this.canvas.height - 80;
      const btnW = 160;
      const btnH = 48;
      this.ctx.fillStyle = '#0B8793';
      this.roundedRect(this.ctx, btnX, btnY, btnW, btnH, 12);
      this.ctx.fill();
      this.ctx.fillStyle = '#F6F9FB';
      this.ctx.font = '20px "Segoe UI", Roboto, sans-serif';
      this.ctx.fillText('Process', btnX + 42, btnY + 32);

      // small sound indicator
      this.ctx.fillStyle = this.muted ? '#FF6B6B' : '#7DD3C7';
      this.ctx.beginPath();
      this.ctx.ellipse(this.canvas.width - 40, 40, 18, 12, 0, 0, Math.PI * 2);
      this.ctx.fill();
      this.ctx.fillStyle = '#073B4C';
      this.ctx.font = '12px "Segoe UI", Roboto, sans-serif';
      this.ctx.fillText(this.muted ? 'Muted' : 'Audio', this.canvas.width - 62, 44);
    }

    drawGear(cx, cy, r, angle, fillColor, strokeColor, label) {
      // gear body
      this.ctx.save();
      this.ctx.translate(cx, cy);
      this.ctx.rotate(angle);
      // outer
      this.ctx.beginPath();
      const teeth = 12;
      for (let t = 0; t < teeth; t++) {
        const a0 = (t / teeth) * Math.PI * 2;
        const a1 = ((t + 0.5) / teeth) * Math.PI * 2;
        const a2 = ((t + 1) / teeth) * Math.PI * 2;
        const r0 = r;
        const r1 = r + 8;
        const x0 = Math.cos(a0) * r0;
        const y0 = Math.sin(a0) * r0;
        const x1 = Math.cos(a1) * r1;
        const y1 = Math.sin(a1) * r1;
        const x2 = Math.cos(a2) * r0;
        const y2 = Math.sin(a2) * r0;
        if (t === 0) this.ctx.moveTo(x0, y0);
        this.ctx.lineTo(x1, y1);
        this.ctx.lineTo(x2, y2);
      }
      this.ctx.closePath();
      this.ctx.fillStyle = fillColor;
      this.ctx.fill();
      this.ctx.lineWidth = 2;
      this.ctx.strokeStyle = strokeColor;
      this.ctx.stroke();

      // inner disc
      this.ctx.beginPath();
      this.ctx.arc(0, 0, r - 18, 0, Math.PI * 2);
      this.ctx.fillStyle = '#F6FBFA';
      this.ctx.fill();
      this.ctx.strokeStyle = '#D1E7E4';
      this.ctx.lineWidth = 2;
      this.ctx.stroke();

      // center label
      this.ctx.fillStyle = '#073B4C';
      this.ctx.font = '30px "Segoe UI", Roboto, sans-serif';
      this.ctx.textAlign = 'center';
      this.ctx.textBaseline = 'middle';
      this.ctx.fillText(label, 0, 0);

      this.ctx.restore();
    }

    roundedRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
      ctx.closePath();
    }

    drawOverlay() {
      // draw particle confetti
      for (let c of this.confetti) {
        this.ctx.save();
        this.ctx.translate(c.x, c.y);
        this.ctx.rotate(c.rot);
        this.ctx.fillStyle = c.color;
        this.ctx.fillRect(-4, -6, 8, 12);
        this.ctx.restore();
      }

      // draw floating particles
      for (let p of this.particles) {
        this.ctx.beginPath();
        this.ctx.fillStyle = p.color;
        this.ctx.globalAlpha = clamp(p.life / 80, 0, 1);
        this.ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.globalAlpha = 1;
      }

      // draw instructions panel bottom-left
      const x = 18;
      const y = this.canvas.height - 130;
      this.ctx.fillStyle = 'rgba(255,255,255,0.7)';
      this.roundedRect(this.ctx, x, y, 280, 110, 10);
      this.ctx.fill();
      this.ctx.fillStyle = '#073B4C';
      this.ctx.font = '13px "Segoe UI", Roboto, sans-serif';
      this.ctx.fillText('Controls:', x + 12, y + 24);
      this.ctx.font = '12px "Segoe UI", Roboto, sans-serif';
      this.ctx.fillText('Left/Right: move selection', x + 12, y + 44);
      this.ctx.fillText('Up/Down: change number or operation', x + 12, y + 64);
      this.ctx.fillText('Space: randomize selection', x + 12, y + 84);
      this.ctx.fillText('Enter: process. M: mute/unmute', x + 12, y + 104);
    }

    frame(t) {
      if (!this.running) {
        // Draw final screen
        this.drawBackground();
        ctx.fillStyle = '#073B4C';
        ctx.font = '28px "Segoe UI", Roboto, sans-serif';
        ctx.fillText(`All done! You solved ${this.solvedCount}/${this.totalRounds} puzzles.`, 60, 200);
        ctx.font = '18px "Segoe UI", Roboto, sans-serif';
        ctx.fillText('Press Enter to play again.', 60, 240);
        return;
      }

      const dt = (t - this.lastTime) / 1000;
      this.lastTime = t;
      this.animationTime += dt * 1000;
      this.gearAngle += dt * 0.9;

      // update particles
      this.updateParticles();

      // clear and draw
      this.drawBackground();
      this.drawMachine();
      this.drawOverlay();

      // subtle floating status line
      this.ctx.fillStyle = '#0B8793';
      this.ctx.font = '14px "Segoe UI", Roboto, sans-serif';
      this.ctx.fillText(`Try to make the machine output the target number. Round ${this.round}`, 18, 26);

      this.rafId = requestAnimationFrame((tt) => this.frame(tt));
    }
  }

  // Initialize audio then start game
  audio.initPromise.then(() => {
    // attach a visible small prompt to enable audio (some browsers require user gesture).
    const statusText = document.createElement('div');
    statusText.style.position = 'absolute';
    statusText.style.left = '8px';
    statusText.style.top = '8px';
    statusText.style.background = 'rgba(255,255,255,0.6)';
    statusText.style.padding = '6px 8px';
    statusText.style.borderRadius = '8px';
    statusText.style.fontFamily = 'Segoe UI, Roboto, sans-serif';
    statusText.style.fontSize = '12px';
    statusText.style.color = '#073B4C';
    statusText.textContent = audio.available ? 'Audio ready — press any key or click to enable sound' : 'Audio not available on this device';
    container.appendChild(statusText);

    // Remove status after a short time or on first interaction
    const removeStatus = () => {
      try {
        statusText.remove();
      } catch (e) {}
      // ensure audio is started when user interacts
      if (audio.available) audio.ensureStarted().catch(() => {});
      window.removeEventListener('keydown', removeStatus);
      canvas.removeEventListener('pointerdown', removeStatus);
    };

    window.addEventListener('keydown', removeStatus, { once: true });
    canvas.addEventListener('pointerdown', removeStatus, { once: true });

    // create and start game
    try {
      const game = new MachineGame(ctx, canvas, audio, liveRegion);
      // expose restart for debugging (optional)
      container.game = game;
    } catch (e) {
      console.error('Failed to start game:', e);
      liveRegion.textContent = 'An unexpected error occurred while starting the game.';
    }
  }).catch((err) => {
    console.warn('Audio init promise rejected', err);
    // start game without audio
    try {
      const game = new MachineGame(ctx, canvas, audio, liveRegion);
      container.game = game;
    } catch (e) {
      console.error('Failed to start game:', e);
      liveRegion.textContent = 'An unexpected error occurred while starting the game.';
    }
  });

})();
---

