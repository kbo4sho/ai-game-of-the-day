# Game of the Day - 2025-10-23

## Metadata
- **Generated Date:** 2025-10-23
- **Generated Time:** 2025-10-23T00:28:41.545144
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-10-23.js
- **File Size:** 26134 bytes
- **Tokens Used:** 8975

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** âœ… PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** âœ… NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
â€¢ Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
â€¢ Use visually calming and interesting and wacky elements.
â€¢ Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
â€¢ Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
â€¢ Have a game area exactly 720px wide by 480px tall.
â€¢ Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
â€¢ Use modern JavaScript practices and avoid minification.
â€¢ Include proper error handling for audio and resource loading.
â€¢ Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
â€¢ Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
â€¢ Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
â€¢ Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
â€¢ Generate all sounds using Web Audio API oscillators and filters.
â€¢ Include proper error handling for audio context creation.
â€¢ Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
â€¢ Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-10-23.js` - The playable game
- `2025-10-23.meta.json` - Machine-readable metadata
- `2025-10-23.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 19015

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 21550

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** âœ… PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Drone Math Adventure - Canvas Game for ages 7-9
  // Renders inside element with ID 'game-of-the-day-stage'
  // Strictly uses Canvas and Web Audio API, no external assets.

  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const TARGET_CORRECT = 10;
  const MAX_WRONG = 3;
  const PADDING = 12; // minimum spacing between UI elements
  const BODY_FONT = '16px Arial';
  const IMPORTANT_FONT = '22px Arial';
  const TITLE_FONT = '28px Arial';
  const ANSWER_FONT = '20px Arial';

  // Get stage element
  const stage = document.getElementById('game-of-the-day-stage');
  if (!stage) {
    console.error('Element with id "game-of-the-day-stage" not found.');
    return;
  }

  // Clear stage and set up
  stage.innerHTML = '';
  stage.style.position = 'relative';

  // Create an accessibility live region (hidden visually but available to screen readers)
  const liveRegion = document.createElement('div');
  liveRegion.setAttribute('aria-live', 'polite');
  liveRegion.style.position = 'absolute';
  liveRegion.style.left = '-9999px';
  liveRegion.style.width = '1px';
  liveRegion.style.height = '1px';
  liveRegion.style.overflow = 'hidden';
  stage.appendChild(liveRegion);

  // Create canvas
  const canvas = document.createElement('canvas');
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute('tabindex', '0'); // make focusable for keyboard input
  canvas.style.outline = 'none';
  stage.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Audio setup with error handling
  let audioCtx = null;
  let masterGain = null;
  let ambientOsc = null;
  let audioEnabled = true;

  function initAudio() {
    if (audioCtx) return;
    try {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AudioContext();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.18; // gentle volume
      masterGain.connect(audioCtx.destination);

      // Create ambient hum (soft drone)
      ambientOsc = audioCtx.createOscillator();
      const ambientGain = audioCtx.createGain();
      ambientOsc.type = 'sine';
      ambientOsc.frequency.value = 80; // low hum
      ambientGain.gain.value = 0.03;
      const lpf = audioCtx.createBiquadFilter();
      lpf.type = 'lowpass';
      lpf.frequency.value = 500;
      ambientOsc.connect(ambientGain);
      ambientGain.connect(lpf);
      lpf.connect(masterGain);
      ambientOsc.start();
      // gently modulate
      const lfo = audioCtx.createOscillator();
      const lfoGain = audioCtx.createGain();
      lfo.type = 'sine';
      lfo.frequency.value = 0.15;
      lfoGain.gain.value = 20;
      lfo.connect(lfoGain);
      lfoGain.connect(ambientOsc.frequency);
      lfo.start();
    } catch (e) {
      console.warn('Web Audio API not available:', e);
      audioEnabled = false;
      audioCtx = null;
    }
  }

  function playTone({ freq = 440, duration = 0.2, type = 'sine', attack = 0.01, decay = 0.05, isCorrect = true } = {}) {
    if (!audioEnabled || !audioCtx) return;
    try {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      gain.gain.value = 0;
      osc.connect(gain);
      const filter = audioCtx.createBiquadFilter();
      filter.type = isCorrect ? 'lowpass' : 'highshelf';
      filter.frequency.value = isCorrect ? 1200 : 800;
      gain.connect(filter);
      filter.connect(masterGain);

      const t = audioCtx.currentTime;
      gain.gain.cancelScheduledValues(t);
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.12, t + attack);
      gain.gain.exponentialRampToValueAtTime(0.001, t + duration);
      osc.start(t);
      osc.stop(t + duration + 0.05);
    } catch (e) {
      console.warn('Audio play error:', e);
    }
  }

  // Utility helpers
  const randInt = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;

  function generateQuestion() {
    // Randomly choose addition or subtraction, easy levels
    const type = Math.random() < 0.6 ? 'add' : 'sub';
    if (type === 'add') {
      const a = randInt(1, 12);
      const b = randInt(1, 12);
      const answer = a + b;
      const options = makeOptions(answer, 4, 1, 24);
      return { text: `${a} + ${b} = ?`, answer, options };
    } else {
      let a = randInt(5, 20);
      let b = randInt(1, a - 1);
      const answer = a - b;
      const options = makeOptions(answer, 4, 0, 20);
      return { text: `${a} - ${b} = ?`, answer, options };
    }
  }

  function makeOptions(correct, count, min, max) {
    const set = new Set();
    set.add(correct);
    while (set.size < count) {
      const delta = randInt(-4, 4);
      const candidate = correct + delta;
      if (candidate >= min && candidate <= max) set.add(candidate);
    }
    const arr = Array.from(set);
    // shuffle
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  // Game State
  let state = {
    screen: 'start', // 'start', 'playing', 'win', 'lose'
    score: 0,
    wrong: 0,
    question: null,
    selectedIndex: 0,
    optionsBoxes: [], // store rectangles for click detection
    drones: [],
    clock: 0,
    audioOn: true,
  };

  // Create some drone objects for calming wacky visuals
  function createDrones() {
    state.drones = [];
    const colors = ['#FFA7C4', '#A7D8FF', '#FFF7A7', '#B8FFA7', '#D0A7FF'];
    for (let i = 0; i < 5; i++) {
      state.drones.push({
        x: Math.random() * WIDTH,
        y: 80 + Math.random() * 220,
        vx: 0.3 + Math.random() * 0.9,
        vy: Math.sin(Math.random() * Math.PI * 2) * 0.2,
        size: 22 + Math.random() * 14,
        color: colors[i % colors.length],
        rotorAng: Math.random() * Math.PI * 2,
      });
    }
  }

  createDrones();

  // UI layout positions
  function layoutPositions() {
    // Score top-left
    const scorePos = { x: PADDING, y: PADDING };
    // Lives top-right
    const livesPos = { x: WIDTH - PADDING, y: PADDING };
    // Question top center
    const questionPos = { x: WIDTH / 2, y: 70 };
    // Answers block center
    const answersArea = { x: WIDTH / 2, y: 180, width: WIDTH - 2 * PADDING, height: 220 };
    // Instructions bottom center
    const instructionPos = { x: WIDTH / 2, y: HEIGHT - 60 };
    return { scorePos, livesPos, questionPos, answersArea, instructionPos };
  }

  // Drawing helpers with measureText to ensure proper background rectangles
  function drawTextWithBackground(text, font, x, y, align = 'left', textColor = '#000', bgColor = 'rgba(255,255,255,0.7)') {
    ctx.save();
    ctx.font = font;
    ctx.textAlign = align;
    ctx.textBaseline = 'top';
    const metrics = ctx.measureText(text);
    const textWidth = metrics.width;
    const textHeight = parseInt(font, 10) + 6; // approximate height
    let bx = x;
    if (align === 'center') bx = x - textWidth / 2;
    else if (align === 'right') bx = x - textWidth;
    const padding = 8;
    ctx.fillStyle = bgColor;
    ctx.fillRect(bx - padding, y - padding / 2, textWidth + padding * 2, textHeight + padding);
    ctx.fillStyle = textColor;
    ctx.fillText(text, x, y);
    ctx.restore();
    return { bx: bx - padding, by: y - padding / 2, bw: textWidth + padding * 2, bh: textHeight + padding };
  }

  // Draw calming background with clouds
  function drawBackground(t) {
    // gradient sky
    const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    grad.addColorStop(0, '#E8F6FF');
    grad.addColorStop(1, '#F8FFF4');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // soft ground
    ctx.fillStyle = '#EAF7E6';
    ctx.fillRect(0, HEIGHT - 80, WIDTH, 80);

    // moving clouds
    const cloudCount = 6;
    for (let i = 0; i < cloudCount; i++) {
      const cx = ((t * 0.02) + i * 140) % (WIDTH + 200) - 100;
      const cy = 40 + ((i % 3) * 30);
      drawCloud(cx, cy, 40 + (i % 3) * 10, 0.85);
    }
  }

  function drawCloud(cx, cy, size, alpha) {
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath();
    ctx.arc(cx, cy, size * 0.6, 0, Math.PI * 2);
    ctx.arc(cx + size * 0.5, cy + 4, size * 0.5, 0, Math.PI * 2);
    ctx.arc(cx - size * 0.5, cy + 6, size * 0.45, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawDrone(drone, t) {
    ctx.save();
    ctx.translate(drone.x, drone.y);
    // body
    ctx.fillStyle = drone.color;
    ctx.beginPath();
    ctx.ellipse(0, 0, drone.size * 1.2, drone.size * 0.75, 0, 0, Math.PI * 2);
    ctx.fill();

    // cockpit
    ctx.fillStyle = '#ffffff';
    ctx.globalAlpha = 0.7;
    ctx.beginPath();
    ctx.ellipse(-drone.size * 0.2, 0, drone.size * 0.5, drone.size * 0.35, -0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // legs
    ctx.strokeStyle = '#6b6b6b';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-drone.size * 0.6, drone.size * 0.5);
    ctx.lineTo(-drone.size * 0.8, drone.size * 0.9);
    ctx.moveTo(drone.size * 0.6, drone.size * 0.5);
    ctx.lineTo(drone.size * 0.8, drone.size * 0.9);
    ctx.stroke();

    // rotors - 2
    const rotorOffset = drone.size * 0.9;
    for (let i = -1; i <= 1; i += 2) {
      ctx.save();
      ctx.translate(i * rotorOffset, -drone.size * 0.4);
      ctx.rotate(drone.rotorAng);
      ctx.fillStyle = '#444';
      ctx.fillRect(-drone.size * 0.05, -drone.size * 0.8, drone.size * 0.1, drone.size * 1.6);
      ctx.beginPath();
      ctx.fillStyle = '#222';
      ctx.ellipse(0, -drone.size * 0.95, drone.size * 0.12, drone.size * 0.02, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    ctx.restore();
  }

  // Draw UI frames
  function drawUI() {
    ctx.save();
    ctx.font = BODY_FONT;
    ctx.textBaseline = 'top';

    const pos = layoutPositions();

    // Score top-left
    const scoreText = `Score: ${state.score}`;
    drawTextWithBackground(scoreText, BODY_FONT, pos.scorePos.x + 4, pos.scorePos.y + 4, 'left', '#003', 'rgba(255,255,255,0.8)');

    // Lives top-right and audio toggle
    const livesText = `Wrong: ${state.wrong} / ${MAX_WRONG}`;
    // measure lives width
    ctx.font = BODY_FONT;
    const livesW = ctx.measureText(livesText).width;
    const livesX = WIDTH - PADDING;
    // draw background aligned to right
    const livesBox = drawTextWithBackground(livesText, BODY_FONT, livesX, pos.livesPos.y + 4, 'right', '#600', 'rgba(255,255,255,0.8)');

    // Audio toggle small icon next to lives (left of lives box)
    const iconSize = 28;
    const iconX = livesBox.bx - PADDING - iconSize;
    const iconY = pos.livesPos.y + 4;
    ctx.fillStyle = state.audioOn ? '#4CAF50' : '#B0B0B0';
    ctx.fillRect(iconX, iconY, iconSize, iconSize);
    ctx.fillStyle = '#fff';
    ctx.font = '16px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(state.audioOn ? 'ðŸ”Š' : 'ðŸ”ˆ', iconX + iconSize / 2, iconY + iconSize / 2);

    // Store audio icon rect for clicks
    state.audioIconRect = { x: iconX, y: iconY, w: iconSize, h: iconSize };

    ctx.restore();
  }

  function drawQuestionAndAnswers() {
    const pos = layoutPositions();
    ctx.save();
    // Question
    ctx.font = IMPORTANT_FONT;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    const q = state.question ? state.question.text : 'Press Start to begin';
    // draw background wide enough
    const qMetrics = ctx.measureText(q);
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    const qPad = 10;
    ctx.fillRect(pos.questionPos.x - qMetrics.width / 2 - qPad, pos.questionPos.y - qPad, qMetrics.width + qPad * 2, 36 + qPad);
    ctx.fillStyle = '#1a3';
    ctx.fillText(q, pos.questionPos.x, pos.questionPos.y + 6);
    ctx.restore();

    // Answers: arrange in two rows of two
    const opts = state.question ? state.question.options : [];
    state.optionsBoxes = [];
    const area = { x: WIDTH / 2 - 260, y: pos.questionPos.y + 60, w: 520, h: 220 };
    const boxW = 240;
    const boxH = 80;
    const gapX = 40;
    const gapY = 20;
    ctx.save();
    ctx.font = ANSWER_FONT;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    for (let i = 0; i < opts.length; i++) {
      const col = i % 2;
      const row = Math.floor(i / 2);
      const bx = area.x + col * (boxW + gapX);
      const by = area.y + row * (boxH + gapY);
      // highlight if selected
      const isSelected = state.selectedIndex === i && state.screen === 'playing';
      ctx.fillStyle = isSelected ? 'rgba(200,255,200,0.95)' : 'rgba(255,255,255,0.9)';
      // rounded rect
      roundRect(ctx, bx, by, boxW, boxH, 10, true, false, isSelected ? '#bfe7be' : '#eee');
      ctx.fillStyle = '#003';
      ctx.fillText(String(opts[i]), bx + boxW / 2, by + boxH / 2);
      state.optionsBoxes.push({ x: bx, y: by, w: boxW, h: boxH });
    }
    ctx.restore();
  }

  // Utility to draw a rounded rectangle with optional fill
  function roundRect(ctx, x, y, w, h, r, fill, stroke, fillColor) {
    if (r < 0) r = 0;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) {
      ctx.fillStyle = fillColor || '#fff';
      ctx.fill();
    }
    if (stroke) ctx.stroke();
  }

  // Draw start screen, win screen, lose screen overlays
  function drawOverlay() {
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    ctx.restore();
  }

  function drawStartScreen() {
    drawOverlay();
    ctx.save();
    ctx.font = TITLE_FONT;
    ctx.textAlign = 'center';
    ctx.fillStyle = '#012';
    const title = 'Drone Math Adventure';
    ctx.fillText(title, WIDTH / 2, 120);

    ctx.font = IMPORTANT_FONT;
    ctx.fillStyle = '#044';
    ctx.fillText('Help the friendly drones deliver parcels by solving math!', WIDTH / 2, 170);

    ctx.font = BODY_FONT;
    ctx.fillStyle = '#003';
    ctx.textAlign = 'center';
    const lines = [
      'Goal: Answer 10 questions correctly.',
      `You can get ${MAX_WRONG} wrong answers before the game is over.`,
      'Use number keys 1-4, arrow keys, or click answers. Press Enter to confirm.',
      'Press SPACE or click START to begin. Toggle sound with the speaker icon.',
    ];
    let y = 230;
    for (let line of lines) {
      const metrics = ctx.measureText(line);
      // draw background
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fillRect(WIDTH / 2 - metrics.width / 2 - 10, y - 6, metrics.width + 20, 28);
      ctx.fillStyle = '#002';
      ctx.fillText(line, WIDTH / 2, y);
      y += 34;
    }

    // Draw start button
    const btnW = 160;
    const btnH = 54;
    const bx = WIDTH / 2 - btnW / 2;
    const by = y + 12;
    roundRect(ctx, bx, by, btnW, btnH, 10, true, false, '#6BC8FF');
    ctx.font = IMPORTANT_FONT;
    ctx.fillStyle = '#013';
    ctx.fillText('START', WIDTH / 2, by + 12);
    state.startButton = { x: bx, y: by, w: btnW, h: btnH };
    ctx.restore();
  }

  function drawEndScreen(win) {
    drawOverlay();
    ctx.save();
    ctx.font = TITLE_FONT;
    ctx.textAlign = 'center';
    ctx.fillStyle = win ? '#0A6' : '#A00';
    const title = win ? 'Hooray! Drones Delivered Everything!' : 'Uh-oh! Parcels missed!';
    ctx.fillText(title, WIDTH / 2, 120);

    ctx.font = IMPORTANT_FONT;
    ctx.fillStyle = '#013';
    ctx.fillText(`Score: ${state.score}`, WIDTH / 2, 170);

    ctx.font = BODY_FONT;
    ctx.fillStyle = '#013';
    const message = win
      ? 'You answered enough questions to guide the drones home. Great job!'
      : 'The drones need more practice. Try again to improve your score!';
    const metrics = ctx.measureText(message);
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.fillRect(WIDTH / 2 - metrics.width / 2 - 10, 220 - 6, metrics.width + 20, 28);
    ctx.fillStyle = '#013';
    ctx.fillText(message, WIDTH / 2, 220);

    // Restart button
    const btnW = 180;
    const btnH = 54;
    const bx = WIDTH / 2 - btnW / 2;
    const by = 260;
    roundRect(ctx, bx, by, btnW, btnH, 10, true, false, '#FFD76B');
    ctx.font = IMPORTANT_FONT;
    ctx.fillStyle = '#333';
    ctx.fillText('PLAY AGAIN', WIDTH / 2, by + 12);
    state.restartButton = { x: bx, y: by, w: btnW, h: btnH };

    // Instructions for restart with keyboard
    ctx.font = BODY_FONT;
    ctx.fillStyle = '#023';
    ctx.fillText('Press R to restart', WIDTH / 2, by + btnH + 18);
    ctx.restore();
  }

  // Feedback messages and live region updates
  function announceForAccessibility(text) {
    if (!liveRegion) return;
    liveRegion.textContent = text;
  }

  // Input handling
  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    handleClick(mx, my);
    // Ensure audio context unlocked on first tap
    if (audioEnabled && audioCtx && audioCtx.state === 'suspended') {
      audioCtx.resume().catch(() => {});
    }
    canvas.focus();
  });

  function handleClick(mx, my) {
    if (state.screen === 'start') {
      const b = state.startButton;
      if (b && pointInRect(mx, my, b)) {
        startGame();
        return;
      }
    } else if (state.screen === 'playing') {
      // audio toggle
      if (state.audioIconRect && pointInRect(mx, my, state.audioIconRect)) {
        toggleAudio();
        return;
      }
      // click answer boxes
      for (let i = 0; i < state.optionsBoxes.length; i++) {
        if (pointInRect(mx, my, state.optionsBoxes[i])) {
          state.selectedIndex = i;
          submitAnswer();
          return;
        }
      }
    } else if (state.screen === 'win' || state.screen === 'lose') {
      const b = state.restartButton;
      if (b && pointInRect(mx, my, b)) {
        restartGame();
        return;
      }
    }
  }

  function pointInRect(px, py, r) {
    return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;
  }

  // Keyboard controls
  canvas.addEventListener('keydown', (e) => {
    if (state.screen === 'start') {
      if (e.code === 'Space' || e.code === 'Enter') {
        startGame();
        e.preventDefault();
      }
      if (e.key.toLowerCase() === 'm') toggleAudio();
    } else if (state.screen === 'playing') {
      if (e.key >= '1' && e.key <= '4') {
        const idx = parseInt(e.key, 10) - 1;
        if (idx < state.question.options.length) {
          state.selectedIndex = idx;
          submitAnswer();
        }
      } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
        state.selectedIndex = (state.selectedIndex + state.question.options.length - 1) % state.question.options.length;
      } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
        state.selectedIndex = (state.selectedIndex + 1) % state.question.options.length;
      } else if (e.key === 'Enter') {
        submitAnswer();
      } else if (e.key.toLowerCase() === 'm') {
        toggleAudio();
      }
    } else if (state.screen === 'win' || state.screen === 'lose') {
      if (e.key.toLowerCase() === 'r' || e.code === 'Enter') {
        restartGame();
      }
      if (e.key.toLowerCase() === 'm') toggleAudio();
    }
  });

  // Toggle audio on/off
  function toggleAudio() {
    if (!audioCtx && audioEnabled) {
      initAudio();
      if (!audioCtx) {
        audioEnabled = false;
        state.audioOn = false;
        announceForAccessibility('Audio not available.');
        return;
      }
    }
    state.audioOn = !state.audioOn;
    if (audioCtx && masterGain) {
      masterGain.gain.value = state.audioOn ? 0.18 : 0;
    }
    announceForAccessibility(`Audio ${state.audioOn ? 'on' : 'off'}`);
  }

  // Game control functions
  function startGame() {
    initAudio();
    state.screen = 'playing';
    state.score = 0;
    state.wrong = 0;
    state.selectedIndex = 0;
    state.question = generateQuestion();
    announceForAccessibility('Game started. ' + state.question.text);
  }

  function restartGame() {
    state.screen = 'start';
    state.score = 0;
    state.wrong = 0;
    state.selectedIndex = 0;
    state.question = null;
    announceForAccessibility('Game restarted. Press start to play again.');
  }

  function submitAnswer() {
    if (!state.question) return;
    const chosen = state.question.options[state.selectedIndex];
    if (chosen === state.question.answer) {
      state.score += 1;
      playFeedback(true);
      announceForAccessibility(`Correct! ${state.question.text.replace('= ?', `= ${chosen}`)}. Score ${state.score}.`);
      // check for win
      if (state.score >= TARGET_CORRECT) {
        state.screen = 'win';
        announceForAccessibility('You won! All packages delivered. Press R to play again.');
        return;
      }
    } else {
      state.wrong += 1;
      playFeedback(false);
      announceForAccessibility(`Oops, ${chosen} is not correct. ${state.question.text.replace('= ?', `= ${state.question.answer}`)}. Wrong ${state.wrong} of ${MAX_WRONG}.`);
      if (state.wrong >= MAX_WRONG) {
        state.screen = 'lose';
        announceForAccessibility('Game over. The drones need practice. Press R to try again.');
        return;
      }
    }
    // next question
    state.question = generateQuestion();
    state.selectedIndex = 0;
  }

  function playFeedback(correct) {
    if (!audioEnabled) return;
    if (!audioCtx) {
      initAudio();
      if (!audioCtx) return;
    }
    // ensure audio context is resumed on interaction
    if (audioCtx.state === 'suspended') audioCtx.resume().catch(() => {});
    if (correct) {
      // pleasant chirp sequence
      playTone({ freq: 600, duration: 0.12, type: 'sine', isCorrect: true });
      setTimeout(() => playTone({ freq: 800, duration: 0.08, type: 'sine', isCorrect: true }), 100);
    } else {
      // soft buzzer
      playTone({ freq: 250, duration: 0.25, type: 'square', isCorrect: false });
    }
  }

  // Animation loop
  let lastTS = performance.now();
  function loop(ts) {
    const dt = ts - lastTS;
    lastTS = ts;
    state.clock += dt;
    update(dt / 1000);
    render();
    requestAnimationFrame(loop);
  }

  function update(dt) {
    // Update drones positions
    for (let d of state.drones) {
      d.x += d.vx * dt * 40;
      d.rotorAng += 0.6 + dt * 10;
      d.y += Math.sin((state.clock * 0.002) + d.x * 0.01) * 0.2;
      if (d.x - d.size > WIDTH + 40) {
        d.x = -40 - d.size;
        d.y = 80 + Math.random() * 200;
      }
    }
  }

  function render() {
    // clear
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // background
    drawBackground(state.clock);

    // draw drones behind UI
    for (let d of state.drones) drawDrone(d, state.clock);

    // UI
    drawUI();

    // Question + answers (or start or end screens)
    if (state.screen === 'start') {
      drawQuestionAndAnswers(); // show placeholders
      drawStartScreen();
    } else if (state.screen === 'playing') {
      drawQuestionAndAnswers();
      // instructions bottom center
      const ipos = layoutPositions().instructionPos;
      ctx.save();
      ctx.font = BODY_FONT;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      const instr = '1-4 or click an answer. Use arrows/Enter. Toggle sound with speaker icon';
      const metrics = ctx.measureText(instr);
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.fillRect(ipos.x - metrics.width / 2 - 10, ipos.y - 6, metrics.width + 20, 28);
      ctx.fillStyle = '#012';
      ctx.fillText(instr, ipos.x, ipos.y);
      ctx.restore();
    } else if (state.screen === 'win') {
      drawQuestionAndAnswers();
      drawEndScreen(true);
    } else if (state.screen === 'lose') {
      drawQuestionAndAnswers();
      drawEndScreen(false);
    }

    // ensure no overlapping text: check bounding boxes and adjust if needed
    ensureNoOverlap();
  }

  // Basic overlapping check: move instruction area slightly if overlaps answers boxes or header
  function ensureNoOverlap() {
    // For simplicity, ensure instruction area doesn't overlap answer area
    const pos = layoutPositions();
    // instruction rectangle
    ctx.font = BODY_FONT;
    const instr = state.screen === 'playing'
      ? '1-4 or click an answer. Use arrows/Enter. Toggle sound with speaker icon'
      : '';
    const metrics = ctx.measureText(instr);
    const instrRect = {
      x: pos.instructionPos.x - metrics.width / 2 - 10,
      y: pos.instructionPos.y - 6,
      w: metrics.width + 20,
      h: 28,
    };
    // answer area
    const answersTop = pos.questionPos.y + 60;
    const answersRect = { x: WIDTH / 2 - 260, y: answersTop, w: 520, h: 220 };
    if (rectsOverlap(instrRect, answersRect)) {
      // draw a small divider so they don't visually overlap (move instruction lower)
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.fillRect(instrRect.x, answersRect.y + answersRect.h + 6, instrRect.w, instrRect.h);
      ctx.fillStyle = '#012';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.fillText(instr, pos.instructionPos.x, answersRect.y + answersRect.h + 10);
      ctx.restore();
    }
  }

  function rectsOverlap(a, b) {
    return !(a.x + a.w < b.x || b.x + b.w < a.x || a.y + a.h < b.y || b.y + b.h < a.y);
  }

  // Start the animation loop
  requestAnimationFrame(loop);

  // Initial focus for keyboard
  canvas.addEventListener('focus', () => {
    // ensure audio unlocked on first focus if necessary
    if (audioEnabled && audioCtx && audioCtx.state === 'suspended') {
      audioCtx.resume().catch(() => {});
    }
  });

  // Initialize audio if user allows on first interaction - hint: draw audio toggling
  // Also ensure initial accessibility message
  announceForAccessibility('Welcome to Drone Math Adventure. Press Space to start.');

  // Expose some functions for debugging (not required)
  window._droneMathGame = {
    state,
    startGame,
    restartGame,
    toggleAudio,
  };
})();
---

