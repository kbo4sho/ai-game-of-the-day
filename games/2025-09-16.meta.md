# Game of the Day - 2025-09-16

## Metadata
- **Generated Date:** 2025-09-16
- **Generated Time:** 2025-09-16T00:26:16.299239
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-09-16.js
- **File Size:** 29150 bytes
- **Tokens Used:** 9453

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-09-16.js` - The playable game
- `2025-09-16.meta.json` - Machine-readable metadata
- `2025-09-16.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 19982

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 21929

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function() {
  // Machine Math Game (ages 7-9)
  // Renders into #game-of-the-day-stage as a 720x480 canvas
  // All graphics drawn with Canvas API. Sounds generated with Web Audio API.
  'use strict';

  // Utility helpers
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function rand(min, max) { return Math.random() * (max - min) + min; }
  function choice(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

  // Locate container
  const container = document.getElementById('game-of-the-day-stage');
  if (!container) {
    console.error('Game container with id "game-of-the-day-stage" not found.');
    return;
  }

  // Clear container and create canvas
  container.innerHTML = '';
  const canvas = document.createElement('canvas');
  canvas.width = 720;
  canvas.height = 480;
  canvas.setAttribute('tabindex', '0'); // allow keyboard focus
  canvas.setAttribute('role', 'application');
  canvas.setAttribute('aria-label', 'Machine Math Game. Press Enter to start or click to interact. Use arrow keys to move parts, space to place. Press M to toggle sound.');
  canvas.style.outline = 'none';
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Accessibility: visually show focus ring when canvas focused
  let hasFocus = false;
  canvas.addEventListener('focus', () => { hasFocus = true; draw(); });
  canvas.addEventListener('blur', () => { hasFocus = false; draw(); });

  // Audio setup with error handling
  let audioContext = null;
  let audioAllowed = false;
  let audioErr = null;
  let masterGain = null;
  let bgGain = null;
  let bgOsc = null;
  let bgFilter = null;
  let isMuted = false;

  function createAudioContext() {
    if (audioContext) return audioContext;
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      audioContext = new AC();
      masterGain = audioContext.createGain();
      masterGain.gain.value = 0.7;
      masterGain.connect(audioContext.destination);

      // Gentle background oscillator with slow modulation
      bgGain = audioContext.createGain();
      bgGain.gain.value = 0.02;
      bgOsc = audioContext.createOscillator();
      bgOsc.type = 'sine';
      bgOsc.frequency.value = 110; // low drone
      bgFilter = audioContext.createBiquadFilter();
      bgFilter.type = 'lowpass';
      bgFilter.frequency.value = 400;
      bgOsc.connect(bgFilter);
      bgFilter.connect(bgGain);
      bgGain.connect(masterGain);
      bgOsc.start();

      // LFO to modulate filter for gentle movement
      const lfo = audioContext.createOscillator();
      lfo.frequency.value = 0.08;
      const lfoGain = audioContext.createGain();
      lfoGain.gain.value = 200;
      lfo.connect(lfoGain);
      lfoGain.connect(bgFilter.frequency);
      lfo.start();

      audioAllowed = true;
      isMuted = false;
      return audioContext;
    } catch (e) {
      console.warn('Audio context creation failed:', e);
      audioErr = e;
      audioAllowed = false;
      return null;
    }
  }

  function resumeAudioIfNeeded() {
    if (!audioContext) return createAudioContext();
    if (audioContext.state === 'suspended') {
      audioContext.resume().catch((e) => {
        console.warn('Audio resume failed:', e);
      });
    }
  }

  function setMuted(m) {
    isMuted = !!m;
    if (masterGain) masterGain.gain.value = isMuted ? 0 : 0.7;
    draw(); // update speaker icon
  }

  // Play sound effects generated with oscillators
  function playCorrectSound() {
    if (!audioAllowed || !audioContext || isMuted) return;
    try {
      const t0 = audioContext.currentTime;
      const notes = [440, 660, 880];
      notes.forEach((freq, i) => {
        const osc = audioContext.createOscillator();
        const g = audioContext.createGain();
        osc.type = i === 1 ? 'triangle' : 'sine';
        osc.frequency.value = freq;
        g.gain.value = 0;
        osc.connect(g);
        g.connect(masterGain);
        const start = t0 + i * 0.07;
        const dur = 0.18;
        g.gain.setValueAtTime(0, start);
        g.gain.linearRampToValueAtTime(0.12, start + 0.01);
        g.gain.exponentialRampToValueAtTime(0.001, start + dur);
        osc.start(start);
        osc.stop(start + dur + 0.05);
      });
    } catch (e) {
      console.warn('playCorrectSound error', e);
    }
  }

  function playWrongSound() {
    if (!audioAllowed || !audioContext || isMuted) return;
    try {
      const t0 = audioContext.currentTime;
      const osc = audioContext.createOscillator();
      const g = audioContext.createGain();
      const filt = audioContext.createBiquadFilter();
      filt.type = 'highpass';
      filt.frequency.value = 500;
      osc.type = 'sawtooth';
      osc.frequency.value = 140;
      g.gain.value = 0;
      osc.connect(filt);
      filt.connect(g);
      g.connect(masterGain);
      g.gain.setValueAtTime(0, t0);
      g.gain.linearRampToValueAtTime(0.12, t0 + 0.02);
      g.gain.exponentialRampToValueAtTime(0.001, t0 + 0.35);
      osc.start(t0);
      osc.stop(t0 + 0.4);
    } catch (e) {
      console.warn('playWrongSound error', e);
    }
  }

  // Visual theme elements
  const bgStars = Array.from({length: 18}, () => ({
    x: rand(0, canvas.width),
    y: rand(0, canvas.height),
    r: rand(1.5, 4),
    sway: rand(0.5, 1.5),
    phase: rand(0, Math.PI * 2)
  }));

  // Game state
  let rngSeed = Date.now();
  const state = {
    level: 0,
    maxLevels: 6,
    parts: [], // available parts
    slots: [], // slot positions with placed parts or null
    target: 0,
    selectedPartIndex: -1,
    dragging: false,
    dragOffset: {x:0,y:0},
    score: 0,
    message: 'Press Enter or Click to start',
    started: false,
    completed: false,
    animTime: 0,
    lastTick: performance.now(),
    showFocusHint: true
  };

  // Generate level data: number of slots and simple sums to practice addition/subtraction
  function generateLevel(n) {
    // n from 0..maxLevels-1
    const slotCount = clamp(2 + Math.floor(n/2), 2, 4); // 2 to 4 slots
    const maxValue = 5 + n * 2; // increase values
    // Build a target by adding random values for the number of slots but hide some choices
    const targetParts = [];
    for (let i=0;i<slotCount;i++) {
      targetParts.push(Math.floor(rand(1, maxValue+1)));
    }
    const target = targetParts.reduce((a,b) => a+b, 0);
    // Create available parts pool: include correct parts and some distractors
    const parts = [];
    // Add each needed part as an item
    targetParts.forEach((v) => parts.push({val: v, x: 560 + Math.random()*120, y: 120 + Math.random()*260}));
    // Add distractors
    for (let i=0;i<Math.max(2, slotCount);i++) {
      parts.push({val: Math.floor(rand(1, maxValue+1)), x: 560 + Math.random()*120, y: 120 + Math.random()*260});
    }
    // Shuffle and assign gentle angles
    for (let i=parts.length-1;i>0;i--) {
      const j = Math.floor(Math.random()*(i+1));
      [parts[i], parts[j]] = [parts[j], parts[i]];
    }
    // Assign visuals positions
    parts.forEach((p, idx) => {
      p.x = 520 + (idx%3) * 60 + rand(-8,8);
      p.y = 150 + Math.floor(idx/3) * 70 + rand(-6,6);
      p.wob = rand(0, Math.PI*2);
      p.id = Math.random().toString(36).slice(2);
      p.placed = false;
      p.selected = false;
    });

    // Slots positioned on the machine
    const slots = [];
    const centerX = 320;
    const centerY = 230;
    const gap = 72;
    const startX = centerX - (slotCount-1) * gap / 2;
    for (let i=0;i<slotCount;i++){
      slots.push({
        x: startX + i*gap,
        y: centerY + 6 + (i%2===0? -8 : 8),
        r: 28,
        placedPart: null
      });
    }
    return {parts, slots, target};
  }

  function startGame() {
    state.level = 0;
    state.score = 0;
    state.started = true;
    state.completed = false;
    state.message = 'Assemble the machine! Reach the target number.';
    nextLevel();
    resumeAudioIfNeeded();
  }

  function nextLevel() {
    if (state.level >= state.maxLevels) {
      // Game completed
      state.completed = true;
      state.message = 'Fantastic! You fixed all the machines!';
      playCorrectSound();
      return;
    }
    const data = generateLevel(state.level);
    state.parts = data.parts;
    state.slots = data.slots;
    state.target = data.target;
    state.selectedPartIndex = -1;
    state.dragging = false;
    state.message = `Level ${state.level+1}: Make ${state.target}`;
    state.animTime = 0;
  }

  // Hit test for parts
  function partAt(x,y) {
    for (let i = state.parts.length - 1; i >= 0; i--) {
      const p = state.parts[i];
      if (p.placed) continue;
      // circular parts
      const dx = x - p.x;
      const dy = y - p.y;
      if (Math.sqrt(dx*dx + dy*dy) < 24) return i;
    }
    return -1;
  }

  function slotAt(x,y) {
    for (let i=0;i<state.slots.length;i++){
      const s = state.slots[i];
      const dx = x - s.x;
      const dy = y - s.y;
      if (Math.sqrt(dx*dx + dy*dy) < s.r + 6) return i;
    }
    return -1;
  }

  // Place part into slot; validate sum when all filled
  function tryPlacePart(partIndex, slotIndex) {
    const p = state.parts[partIndex];
    const s = state.slots[slotIndex];
    if (s.placedPart) {
      // swap back: return to free area
      state.message = 'That slot is occupied. Try a different slot.';
      playWrongSound();
      return false;
    }
    // Place it
    p.placed = true;
    p.selected = false;
    s.placedPart = p;
    // Snap position
    p.x = s.x;
    p.y = s.y;
    checkLevelComplete();
    draw();
    return true;
  }

  function removeFromSlot(slotIndex) {
    const s = state.slots[slotIndex];
    if (!s.placedPart) return;
    const p = s.placedPart;
    s.placedPart = null;
    p.placed = false;
    // Return it to the pool area
    p.x = 520 + rand(0,140);
    p.y = 150 + rand(0,260);
    draw();
  }

  function checkLevelComplete() {
    // If all slots filled, evaluate
    const allFilled = state.slots.every(s => s.placedPart !== null);
    if (!allFilled) return;
    const sum = state.slots.reduce((acc, s) => acc + (s.placedPart ? s.placedPart.val : 0), 0);
    if (sum === state.target) {
      // success
      state.message = 'Perfect! Machine fixed!';
      state.score += 10 + state.level*2;
      playCorrectSound();
      // animate machine run for a moment then advance
      setTimeout(() => {
        state.level++;
        nextLevel();
      }, 1200);
    } else {
      // failure: show gentle feedback, unplace one part automatically to give learning
      state.message = `Oops! That adds to ${sum}. Try again.`;
      playWrongSound();
      // unplace a random slot to give second chance
      const placedSlots = state.slots.map((s,i)=>s.placedPart?i:null).filter(i=>i!==null);
      if (placedSlots.length>0) {
        const idx = choice(placedSlots);
        setTimeout(()=> removeFromSlot(idx), 600);
      }
    }
  }

  // Input handling
  canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    const my = (e.clientY - rect.top) * (canvas.height / rect.height);
    if (!state.started) {
      state.started = true;
      startGame();
      return;
    }
    // Check clicking on speaker toggler
    if (mx > 16 && mx < 56 && my > 16 && my < 56) {
      // toggle mute
      if (!audioAllowed) {
        createAudioContext();
      } else {
        setMuted(!isMuted);
      }
      draw();
      return;
    }
    // click on part
    const idx = partAt(mx, my);
    if (idx >= 0) {
      const p = state.parts[idx];
      if (p.placed) {
        // already placed, find its slot and remove
        const slotIndex = state.slots.findIndex(s => s.placedPart && s.placedPart.id === p.id);
        if (slotIndex >= 0) {
          removeFromSlot(slotIndex);
        }
        return;
      }
      state.selectedPartIndex = idx;
      state.dragging = true;
      state.dragOffset.x = mx - p.x;
      state.dragOffset.y = my - p.y;
      p.selected = true;
      // Ensure audio context started by user gesture
      createAudioContext();
      resumeAudioIfNeeded();
      draw();
      return;
    }
    // click on slot to remove part if any
    const slotIdx = slotAt(mx,my);
    if (slotIdx >= 0) {
      if (state.slots[slotIdx].placedPart) {
        removeFromSlot(slotIdx);
      } else {
        state.message = 'Drop a number here.';
        draw();
      }
      return;
    }
  });

  window.addEventListener('mouseup', (e) => {
    if (!state.dragging) return;
    // drop logic
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    const my = (e.clientY - rect.top) * (canvas.height / rect.height);
    if (state.selectedPartIndex >= 0) {
      const slotIdx = slotAt(mx,my);
      if (slotIdx >= 0) {
        tryPlacePart(state.selectedPartIndex, slotIdx);
      } else {
        // return to pocket
        const p = state.parts[state.selectedPartIndex];
        p.selected = false;
        p.x = 520 + rand(0,140);
        p.y = 150 + rand(0,260);
        state.message = 'Try placing numbers in the slots to reach the target.';
        draw();
      }
    }
    state.dragging = false;
    state.selectedPartIndex = -1;
  });

  canvas.addEventListener('mousemove', (e) => {
    if (!state.dragging || state.selectedPartIndex < 0) return;
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    const my = (e.clientY - rect.top) * (canvas.height / rect.height);
    const p = state.parts[state.selectedPartIndex];
    p.x = mx - state.dragOffset.x;
    p.y = my - state.dragOffset.y;
    draw();
  });

  // Keyboard controls
  canvas.addEventListener('keydown', (e) => {
    if (!state.started) {
      if (e.key === 'Enter' || e.key === ' ') {
        startGame();
        e.preventDefault();
      }
      return;
    }
    // Toggle sound with M
    if (e.key.toLowerCase() === 'm') {
      if (!audioAllowed) {
        createAudioContext();
      } else {
        setMuted(!isMuted);
      }
      e.preventDefault();
      return;
    }
    // Quick help with H
    if (e.key.toLowerCase() === 'h') {
      state.message = 'Use arrows to pick parts, Enter to drop into nearest slot, Space to pick/place, M toggles sound.';
      draw();
      e.preventDefault();
      return;
    }
    // Number keys to pick a part by index (1..9)
    if (/^[1-9]$/.test(e.key)) {
      const idx = parseInt(e.key,10)-1;
      if (idx < state.parts.length) {
        const p = state.parts[idx];
        if (!p.placed) {
          state.selectedPartIndex = idx;
          p.selected = true;
          state.dragging = false;
          state.message = `Selected part ${p.val}. Use arrow keys to move; Enter to place into nearest slot.`;
          draw();
        }
      }
      e.preventDefault();
      return;
    }
    // If selection exists, arrow keys move it
    if (state.selectedPartIndex >= 0) {
      const p = state.parts[state.selectedPartIndex];
      let moved = false;
      if (e.key === 'ArrowLeft') { p.x -= 12; moved = true; }
      if (e.key === 'ArrowRight') { p.x += 12; moved = true; }
      if (e.key === 'ArrowUp') { p.y -= 10; moved = true; }
      if (e.key === 'ArrowDown') { p.y += 10; moved = true; }
      if (moved) {
        p.x = clamp(p.x, 480, canvas.width-40);
        p.y = clamp(p.y, 80, canvas.height-40);
        draw();
        e.preventDefault();
        return;
      }
      if (e.key === ' ' || e.key === 'Enter') {
        // drop into nearest slot if within distance
        const nearest = state.slots.reduce((best, s, i) => {
          const d = Math.hypot(p.x - s.x, p.y - s.y);
          if (d < best.dist) return {dist: d, idx: i};
          return best;
        }, {dist: 9999, idx: -1});
        if (nearest.idx >= 0 && nearest.dist < 80) {
          tryPlacePart(state.selectedPartIndex, nearest.idx);
        } else {
          // place back to pool
          p.selected = false;
          p.x = 520 + rand(0,140);
          p.y = 150 + rand(0,260);
          state.selectedPartIndex = -1;
          draw();
        }
        e.preventDefault();
        return;
      }
      if (e.key === 'Escape') {
        p.selected = false;
        state.selectedPartIndex = -1;
        draw();
        e.preventDefault();
        return;
      }
    } else {
      // No selection: use arrows to cycle selection
      if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
        cycleSelect(-1);
        e.preventDefault();
      } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
        cycleSelect(1);
        e.preventDefault();
      } else if (e.key === 'Enter') {
        // pick nearest part to center
        const idx = nearestPartTo(320,240);
        if (idx >= 0) {
          state.selectedPartIndex = idx;
          state.parts[idx].selected = true;
          state.message = `Selected part ${state.parts[idx].val}.`;
          draw();
        }
        e.preventDefault();
      }
    }
  });

  function cycleSelect(dir) {
    let start = state.selectedPartIndex;
    if (start < 0) start = -1;
    let i = start;
    for (let k=0;k<state.parts.length;k++) {
      i = (i + dir + state.parts.length) % state.parts.length;
      const p = state.parts[i];
      if (!p.placed) {
        if (state.selectedPartIndex >= 0) state.parts[state.selectedPartIndex].selected = false;
        state.selectedPartIndex = i;
        p.selected = true;
        state.message = `Selected part ${p.val}. Use arrows & Enter to place.`;
        draw();
        return;
      }
    }
  }

  function nearestPartTo(x,y) {
    let best = {dist: 9999, idx: -1};
    for (let i=0;i<state.parts.length;i++){
      const p = state.parts[i];
      if (p.placed) continue;
      const d = Math.hypot(p.x-x, p.y-y);
      if (d < best.dist) { best = {dist:d, idx:i}; }
    }
    return best.idx;
  }

  // Main draw loop
  function drawBackground(ts) {
    // calming gradient
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0, '#eef7f9');
    g.addColorStop(1, '#dfeff6');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // floating wacky plants / gears as blobs
    ctx.save();
    for (let i=0;i<bgStars.length;i++){
      const s = bgStars[i];
      const sway = Math.sin((ts/1000)*s.sway + s.phase) * 6;
      ctx.beginPath();
      ctx.fillStyle = `rgba(120,160,200, 0.12)`;
      ctx.ellipse(s.x + sway, s.y + Math.sin((ts/700)+s.phase)*8, s.r*6, s.r*3, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.fillStyle = `rgba(255,255,255,0.6)`;
      ctx.arc(s.x + sway, s.y + Math.cos((ts/900)+s.phase)*8, s.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // Soft grid behind machine
    ctx.save();
    ctx.strokeStyle = 'rgba(0,0,0,0.03)';
    ctx.lineWidth = 1;
    for (let x=0;x<canvas.width;x+=36) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
    }
    for (let y=0;y<canvas.height;y+=36) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvas.width, y);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawMachine(ts) {
    // Central machine body
    const mx = 320, my = 220;
    ctx.save();
    // body
    ctx.fillStyle = '#cfe3ea';
    ctx.strokeStyle = '#8aa9b6';
    ctx.lineWidth = 4;
    roundRect(ctx, mx-160, my-96, 320, 192, 18, true, true);

    // display window showing target
    ctx.fillStyle = '#ffffff';
    roundRect(ctx, mx-72, my-86, 144, 44, 12, true, true);
    ctx.fillStyle = '#123c4b';
    ctx.font = '22px "Arial", sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('TARGET', mx, my-56);

    ctx.font = '30px "Comic Sans MS", "Arial", sans-serif';
    ctx.fillStyle = '#0b3b47';
    ctx.fillText(String(state.target), mx, my-28);

    // slots area: draw connectors
    state.slots.forEach((s, i) => {
      // connector tube
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(20,40,50,0.12)';
      ctx.lineWidth = 10;
      ctx.moveTo(mx, my - 6);
      const cx = s.x - 12;
      ctx.quadraticCurveTo((mx+cx)/2, my - 40 + (i%2?20:-20), s.x, s.y-18);
      ctx.stroke();

      // slot ring
      ctx.beginPath();
      ctx.fillStyle = '#e9f4f6';
      ctx.strokeStyle = '#7aa0ad';
      ctx.lineWidth = 3;
      ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      // inner dashed
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.setLineDash([4,6]);
      ctx.lineWidth = 2;
      ctx.arc(s.x, s.y, s.r-8, 0, Math.PI*2);
      ctx.stroke();
      ctx.setLineDash([]);
      // show placed number
      if (s.placedPart) {
        ctx.fillStyle = '#13414b';
        ctx.font = '20px "Arial", sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(String(s.placedPart.val), s.x, s.y+6);
      } else {
        ctx.fillStyle = 'rgba(10,20,30,0.06)';
        ctx.font = '16px "Arial", sans-serif';
        ctx.fillText('?', s.x, s.y+6);
      }
    });

    // decorative levers & silly face
    ctx.fillStyle = '#a7d0dc';
    ctx.beginPath();
    ctx.ellipse(mx+160, my-60, 30, 24, Math.PI/8, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#fefefe';
    ctx.beginPath();
    ctx.arc(mx+160-6, my-64, 4, 0, Math.PI*2);
    ctx.arc(mx+160+8, my-64, 4, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function drawParts(ts) {
    // Pool area on right
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    roundRect(ctx, 480, 100, 224, 300, 14, true, false);

    ctx.fillStyle = '#0b3b47';
    ctx.font = '16px "Arial", sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Parts Rack', 492, 122);

    // Draw each part as a colorful cog
    for (let i=0;i<state.parts.length;i++){
      const p = state.parts[i];
      // wobble
      p.wob += 0.02;
      const wob = Math.sin(p.wob) * 2;
      const x = p.x;
      const y = p.y + wob;
      // background cog
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(Math.sin((ts/800)+p.wob)*0.08);
      // body
      ctx.beginPath();
      ctx.fillStyle = p.selected ? '#ffdfa3' : '#fff5e6';
      ctx.strokeStyle = '#b18f67';
      ctx.lineWidth = 2;
      ctx.arc(0,0,22,0,Math.PI*2);
      ctx.fill();
      ctx.stroke();
      // teeth
      for (let t=0;t<8;t++){
        ctx.rotate(Math.PI*2/8);
        ctx.fillStyle = 'rgba(80,130,140,0.12)';
        ctx.fillRect(14, -6, 6, 12);
      }
      // number
      ctx.fillStyle = '#154b52';
      ctx.font = '18px "Comic Sans MS", "Arial", sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(String(p.val), 0, 6);
      ctx.restore();

      // index label for keyboard users
      ctx.fillStyle = 'rgba(20,40,50,0.12)';
      ctx.font = '12px "Arial", sans-serif';
      ctx.fillText(String(i+1), x+18, y+18);
    }
    ctx.restore();
  }

  function drawUI(ts) {
    // Top left panel: message and small controls
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    roundRect(ctx, 12, 12, 260, 72, 10, true, true);

    ctx.fillStyle = '#0b3b47';
    ctx.font = '18px "Arial", sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`Level: ${Math.min(state.level+1, state.maxLevels)}/${state.maxLevels}`, 28, 36);

    ctx.font = '14px "Arial", sans-serif';
    ctx.fillStyle = '#0b3b47';
    ctx.fillText(state.message, 28, 56);

    // Speaker icon
    ctx.restore();
    ctx.save();
    const sx = 20, sy = 20;
    // clickable square
    ctx.fillStyle = 'rgba(255,255,255,0.0)';
    ctx.fillRect(sx-4, sy-4, 40, 40);
    // speaker
    ctx.fillStyle = '#0b3b47';
    ctx.beginPath();
    ctx.moveTo(sx+6, sy+12);
    ctx.lineTo(sx+18, sy+8);
    ctx.lineTo(sx+18, sy+28);
    ctx.lineTo(sx+6, sy+24);
    ctx.closePath();
    ctx.fill();
    if (audioAllowed && !isMuted) {
      // draw small bars as visual audio cue
      ctx.fillStyle = '#6bb6c6';
      for (let i=0;i<3;i++){
        ctx.fillRect(sx+22+i*6, sy+10 - Math.abs(Math.sin(ts/300 + i))*8, 4, 8 + Math.abs(Math.sin(ts/300 + i))*8);
      }
    } else {
      // draw muted cross
      ctx.strokeStyle = '#dd5b5b';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(sx+22, sy+6);
      ctx.lineTo(sx+34, sy+18);
      ctx.moveTo(sx+34, sy+6);
      ctx.lineTo(sx+22, sy+18);
      ctx.stroke();
    }
    ctx.restore();

    // Instructions bottom left
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    roundRect(ctx, 12, 380, 260, 88, 10, true, true);
    ctx.fillStyle = '#0b3b47';
    ctx.font = '13px "Arial", sans-serif';
    ctx.fillText('Controls:', 28, 398);
    ctx.fillText('- Click or press Enter to select a part', 28, 416);
    ctx.fillText('- Arrow keys move selected part', 28, 434);
    ctx.fillText('- Press Enter/Space near a slot to place it', 28, 452);
    ctx.restore();

    // Focus ring
    if (hasFocus) {
      ctx.save();
      ctx.strokeStyle = 'rgba(20,80,100,0.18)';
      ctx.lineWidth = 4;
      roundRect(ctx, 4, 4, canvas.width-8, canvas.height-8, 18, false, true);
      ctx.restore();
    }
  }

  function drawFooter(ts) {
    ctx.save();
    ctx.fillStyle = '#0b3b47';
    ctx.font = '16px "Arial", sans-serif';
    ctx.textAlign = 'center';
    if (!state.started) {
      ctx.fillText('Wacky Machine Workshop — Click or press Enter to start', canvas.width/2, canvas.height - 12);
    } else if (state.completed) {
      ctx.fillText('You fixed the machines! Great job!', canvas.width/2, canvas.height - 12);
    } else {
      ctx.fillText(`Score: ${state.score}`, canvas.width - 76, canvas.height - 12);
    }
    ctx.restore();
  }

  // Small utility to draw rounded rectangles
  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    if (typeof r === 'undefined') r = 5;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // Main render
  function draw(ts = 0) {
    // clear
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBackground(ts);
    drawMachine(ts);
    drawParts(ts);
    drawUI(ts);
    drawFooter(ts);
    // If dragging, draw ghost drop target
    if (state.selectedPartIndex >= 0) {
      const p = state.parts[state.selectedPartIndex];
      const nearest = state.slots.reduce((best, s, i) => {
        const d = Math.hypot(p.x - s.x, p.y - s.y);
        if (d < best.dist) return {dist: d, idx: i, s:s};
        return best;
      }, {dist:9999, idx:-1});
      if (nearest.idx !== -1 && nearest.dist < 80) {
        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = 'rgba(110,180,190,0.14)';
        ctx.arc(nearest.s.x, nearest.s.y, nearest.s.r+8, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }
    // Overlay instructions if audio not allowed or blocked
    if (!audioAllowed && audioErr) {
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      roundRect(ctx, 160, 200, 400, 80, 10, true, true);
      ctx.fillStyle = '#d23f3f';
      ctx.font = '16px "Arial", sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Audio is unavailable in this browser.', canvas.width/2, 228);
      ctx.fillStyle = '#0b3b47';
      ctx.fillText('Sound will remain off. You can still play the game.', canvas.width/2, 254);
      ctx.restore();
    } else if (!audioAllowed) {
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      roundRect(ctx, 160, 200, 400, 80, 10, true, true);
      ctx.fillStyle = '#0b3b47';
      ctx.font = '16px "Arial", sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Tap or press M to enable sound for fun chimes.', canvas.width/2, 228);
      ctx.fillText('Sounds are generated on your device — no downloads.', canvas.width/2, 254);
      ctx.restore();
    }
  }

  // Game loop for animations
  function tick(now) {
    const dt = (now - state.lastTick) / 1000;
    state.lastTick = now;
    state.animTime += dt;
    // gentle floating of background
    draw(now);
    requestAnimationFrame(tick);
  }

  // Kick things off
  draw();
  requestAnimationFrame(tick);

  // Expose some debugging on container for testing (not necessary for gameplay)
  container.dataset.gameReady = 'true';

  // Ensure canvas is focusable and initially focused for keyboard controls
  setTimeout(() => {
    try { canvas.focus(); } catch(e){}
  }, 200);

  // Basic keyboard instructions in console for accessibility testers
  console.info('Machine Math Game ready. Controls: Click parts to pick & drag, arrows to move, Enter/Space to place, M to toggle sound.');

  // Error handling example: catch unexpected errors in event loop
  window.addEventListener('error', (ev) => {
    console.error('Unexpected error in Machine Math Game:', ev.error || ev.message);
    state.message = 'An unexpected error occurred. Please reload the page.';
    draw();
  });

})();
---

