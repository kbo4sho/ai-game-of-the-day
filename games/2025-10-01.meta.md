# Game of the Day - 2025-10-01

## Metadata
- **Generated Date:** 2025-10-01
- **Generated Time:** 2025-10-01T00:30:53.017365
- **Model:** gpt-5-mini
- **Theme:** machines
- **Game File:** 2025-10-01.js
- **File Size:** 33928 bytes
- **Tokens Used:** 11419

## Functionality Score
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** ✅ NONE
- **Canvas Methods Used:** 6

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: machines

The game must:
• Be beatable.
• Use visually calming and interesting and wacky elements.
• Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
• Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
• Have a game area exactly 720px wide by 480px tall.
• Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
• Use modern JavaScript practices and avoid minification.
• Include proper error handling for audio and resource loading.
• Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
• Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
• Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
• Generate all sounds using Web Audio API oscillators and filters.
• Include proper error handling for audio context creation.
• Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
• Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "machines".

## Files Generated
- `2025-10-01.js` - The playable game
- `2025-10-01.meta.json` - Machine-readable metadata
- `2025-10-01.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 23549

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 25468

### Final Functionality Score After Improvement
- **Score:** 8/8 (100.0%)
- **Status:** ✅ PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
// Educational Math Game: "Wacky Machine Mixer"
// Renders into element with id "game-of-the-day-stage"
// All graphics drawn on canvas, sounds via Web Audio API oscillators
// Accessible: keyboard controls, ARIA status updates, visual audio indicator
(function () {
  // Configuration
  const WIDTH = 720;
  const HEIGHT = 480;
  const MAX_LEVELS = 8; // beatable
  const STAGE_ID = "game-of-the-day-stage";

  // Utility helpers
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function clamp(v, a, b) {
    return Math.max(a, Math.min(b, v));
  }

  // Find container
  const container = document.getElementById(STAGE_ID);
  if (!container) {
    console.error("Game container not found: #" + STAGE_ID);
    return;
  }
  container.innerHTML = ""; // clear
  container.style.position = "relative";
  container.setAttribute("role", "application");
  container.setAttribute("aria-label", "Wacky Machine Math Game");

  // Create offscreen live region for accessibility messages
  const liveRegion = document.createElement("div");
  liveRegion.setAttribute("aria-live", "polite");
  liveRegion.style.position = "absolute";
  liveRegion.style.left = "-9999px";
  liveRegion.style.width = "1px";
  liveRegion.style.height = "1px";
  container.appendChild(liveRegion);

  // Create canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute("tabindex", "0"); // to capture keyboard
  canvas.style.outline = "none";
  container.appendChild(canvas);
  const ctx = canvas.getContext("2d");
  if (!ctx) {
    console.error("Canvas 2D not supported.");
    liveRegion.textContent = "Your browser does not support the game canvas.";
    return;
  }

  // Audio setup with error handling
  let audioAvailable = true;
  let audioCtx = null;
  let masterGain = null;
  let bgGain = null;
  let bgOsc = null;
  let bgLFO = null;
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AudioContext();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.9;
    masterGain.connect(audioCtx.destination);
    // Background gentle pad
    bgGain = audioCtx.createGain();
    bgGain.gain.value = 0.02; // very gentle
    bgGain.connect(masterGain);
    bgOsc = audioCtx.createOscillator();
    bgOsc.type = "sine";
    bgOsc.frequency.value = 120; // low tone
    // LFO to modulate filter
    bgLFO = audioCtx.createOscillator();
    bgLFO.frequency.value = 0.08; // slow
    const lfoGain = audioCtx.createGain();
    lfoGain.gain.value = 200;
    // filter
    const bgFilter = audioCtx.createBiquadFilter();
    bgFilter.type = "lowpass";
    bgFilter.frequency.value = 300;
    bgOsc.connect(bgFilter);
    bgFilter.connect(bgGain);
    bgLFO.connect(lfoGain);
    lfoGain.connect(bgFilter.frequency);
    bgOsc.start();
    bgLFO.start();
    // Initially suspend until user interacts
    if (audioCtx.state === "suspended") {
      audioAvailable = true; // still available but suspended
    }
  } catch (e) {
    console.warn("Audio context not created:", e);
    audioAvailable = false;
    audioCtx = null;
    masterGain = null;
  }

  // Simple sound primitives
  function ensureAudioRunning() {
    if (!audioCtx) return Promise.resolve(false);
    if (audioCtx.state === "suspended") {
      return audioCtx.resume().then(() => true).catch(() => false);
    }
    return Promise.resolve(true);
  }

  function playBeep(time = 0, duration = 0.18, freq = 880, type = "sine", volume = 0.08) {
    if (!audioCtx) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = volume;
      o.connect(g);
      g.connect(masterGain);
      const now = audioCtx.currentTime;
      o.start(now + time);
      g.gain.setValueAtTime(volume, now + time);
      g.gain.exponentialRampToValueAtTime(0.001, now + time + duration);
      o.stop(now + time + duration + 0.02);
    } catch (e) {
      console.warn("playBeep failed:", e);
    }
  }

  function playCorrectTune() {
    ensureAudioRunning().then((ok) => {
      if (!ok) return;
      // simple arpeggio
      playBeep(0, 0.16, 880, "sine", 0.06);
      playBeep(0.12, 0.18, 1046.5, "sine", 0.06);
      playBeep(0.26, 0.24, 1318.5, "sine", 0.07);
    });
  }

  function playWrongThud() {
    ensureAudioRunning().then((ok) => {
      if (!ok) return;
      try {
        const now = audioCtx.currentTime;
        const o = audioCtx.createOscillator();
        const f = audioCtx.createBiquadFilter();
        const g = audioCtx.createGain();
        o.type = "square";
        o.frequency.value = 120;
        f.type = "lowpass";
        f.frequency.value = 200;
        g.gain.value = 0.08;
        o.connect(f);
        f.connect(g);
        g.connect(masterGain);
        o.start(now);
        g.gain.setValueAtTime(0.08, now);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
        o.stop(now + 0.36);
      } catch (e) {
        console.warn("playWrongThud failed:", e);
      }
    });
  }

  function playClick() {
    ensureAudioRunning().then((ok) => {
      if (!ok) return;
      playBeep(0, 0.06, 1200, "square", 0.03);
    });
  }

  // Game state
  let level = 1;
  let score = 0;
  let tokens = []; // token objects
  let selectedIds = new Set();
  let target = 0;
  let attemptsLeft = 3;
  let rotatingCogAngle = 0;
  let tick = 0;
  let showAudioOn = true;

  // Visual theme colors
  const palette = {
    bg: "#f0f7fb",
    machine: "#cfe7f3",
    accent: "#8ab6c6",
    tokenFill: ["#ffd6a5", "#c8f7d8", "#d0c7ff", "#fff2a6", "#f8c6d8"],
    text: "#153243",
    wrong: "#ff8a8a",
    right: "#7ee787",
    subtle: "#b7dbe6",
  };

  // Accessibility: update live region
  function aria(msg) {
    liveRegion.textContent = msg;
  }

  // Generate tokens that guarantee a solvable subset for the target
  function generateLevel(lv) {
    // target grows with level
    const minTarget = 5 + Math.floor((lv - 1) * 1.5);
    const maxTarget = 9 + lv * 2;
    target = randInt(minTarget, maxTarget);
    // choose number of tokens 3..6
    const n = clamp(4 + Math.floor(lv / 3), 3, 6);
    // create one guaranteed solution: pick k numbers between 1 and 9 whose sum = target, with k 2..3
    let solution = null;
    for (let attempts = 0; attempts < 200 && !solution; attempts++) {
      const k = randInt(2, Math.min(3, Math.max(2, Math.floor(target / 3))));
      // generate k numbers sum to target but each 1..9
      // simple approach: pick k-1 random then last = target - sum
      const parts = [];
      let sum = 0;
      for (let i = 0; i < k - 1; i++) {
        const rem = target - sum - (k - i - 1) * 1;
        const maxVal = Math.min(9, rem - (k - i - 2) * 1);
        const val = Math.max(1, randInt(1, Math.max(1, maxVal)));
        parts.push(val);
        sum += val;
      }
      const last = target - sum;
      if (last >= 1 && last <= 9) {
        parts.push(last);
        // ensure parts not too many large duplicates (not necessary)
        solution = parts;
      }
    }
    if (!solution) {
      // fallback: target as one token if <=9
      if (target <= 9) solution = [target];
      else solution = [Math.min(9, target - 1), Math.max(1, target - Math.min(9, target - 1))];
    }
    // Fill remaining tokens
    tokens = [];
    const usedColors = palette.tokenFill;
    let idx = 0;
    // Place solution tokens in random positions among tokens
    const positions = [];
    const margin = 40;
    const startX = 120;
    const gap = (WIDTH - 2 * startX) / (n - 1);
    for (let i = 0; i < n; i++) {
      positions.push({ x: startX + gap * i, y: HEIGHT - 110 });
    }
    shuffleArray(positions);
    // add solution numbers first
    for (let v of solution) {
      const pos = positions.pop();
      tokens.push(makeToken(v, pos.x, pos.y, usedColors[idx % usedColors.length]));
      idx++;
    }
    // fill with distractors
    while (tokens.length < n) {
      // create random value 1..9 but avoid accidental trivial extra solutions that sum to target when combined with others maybe allow
      const v = randInt(1, 9);
      const pos = positions.pop();
      tokens.push(makeToken(v, pos.x, pos.y, usedColors[idx % usedColors.length]));
      idx++;
    }
    shuffleArray(tokens); // random order
    // reset selection etc.
    selectedIds = new Set();
    attemptsLeft = 3;
    aria(`Level ${level}. Target ${target}. Choose tokens that add up to ${target}.`);
  }

  function makeToken(value, x, y, color) {
    return {
      id: Math.random().toString(36).slice(2, 9),
      value,
      x,
      y,
      r: 28,
      color,
      used: false,
      wobble: Math.random() * Math.PI * 2,
    };
  }

  function shuffleArray(a) {
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
  }

  // Interaction state
  let drag = null;
  let pointerDown = false;
  let keyboardIndex = 0;

  // Input handlers
  canvas.addEventListener("mousedown", (e) => {
    const pos = getMouse(e);
    pointerDown = true;
    const t = findTokenAt(pos.x, pos.y);
    if (t) {
      drag = { token: t, offsetX: pos.x - t.x, offsetY: pos.y - t.y };
      playClick();
      keyboardIndex = tokens.findIndex((tk) => tk.id === t.id);
      canvas.focus();
    } else {
      // check submit or clear or toggle audio
      const btn = hitButtonAt(pos.x, pos.y);
      if (btn === "submit") handleSubmit();
      if (btn === "clear") handleClear();
      if (btn === "audio") toggleAudio();
    }
  });

  canvas.addEventListener("mousemove", (e) => {
    if (!drag) return;
    const pos = getMouse(e);
    drag.token.x = pos.x - drag.offsetX;
    drag.token.y = pos.y - drag.offsetY;
  });

  canvas.addEventListener("mouseup", (e) => {
    pointerDown = false;
    if (drag) {
      // dropping near machine bowl (center) toggles selection
      const bowl = { x: WIDTH / 2 + 140, y: HEIGHT / 2 + 20, r: 90 };
      const t = drag.token;
      const dist = Math.hypot(t.x - bowl.x, t.y - bowl.y);
      if (dist < bowl.r + 20) {
        toggleTokenSelection(t.id);
      } else {
        // snap back to base row
        snapTokenBack(t);
      }
    }
    drag = null;
  });

  // Touch support
  canvas.addEventListener("touchstart", (e) => {
    e.preventDefault();
    const t0 = e.changedTouches[0];
    const rect = canvas.getBoundingClientRect();
    const pos = { x: t0.clientX - rect.left, y: t0.clientY - rect.top };
    pointerDown = true;
    const tkn = findTokenAt(pos.x, pos.y);
    if (tkn) {
      drag = { token: tkn, offsetX: pos.x - tkn.x, offsetY: pos.y - tkn.y };
      playClick();
      keyboardIndex = tokens.findIndex((tk) => tk.id === tkn.id);
      canvas.focus();
    } else {
      const btn = hitButtonAt(pos.x, pos.y);
      if (btn === "submit") handleSubmit();
      if (btn === "clear") handleClear();
      if (btn === "audio") toggleAudio();
    }
  });

  canvas.addEventListener("touchmove", (e) => {
    e.preventDefault();
    if (!drag) return;
    const t0 = e.changedTouches[0];
    const rect = canvas.getBoundingClientRect();
    const pos = { x: t0.clientX - rect.left, y: t0.clientY - rect.top };
    drag.token.x = pos.x - drag.offsetX;
    drag.token.y = pos.y - drag.offsetY;
  });

  canvas.addEventListener("touchend", (e) => {
    e.preventDefault();
    pointerDown = false;
    if (!drag) return;
    const bowl = { x: WIDTH / 2 + 140, y: HEIGHT / 2 + 20, r: 90 };
    const t = drag.token;
    const dist = Math.hypot(t.x - bowl.x, t.y - bowl.y);
    if (dist < bowl.r + 20) {
      toggleTokenSelection(t.id);
    } else {
      snapTokenBack(t);
    }
    drag = null;
  });

  function getMouse(e) {
    const rect = canvas.getBoundingClientRect();
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
  }

  function findTokenAt(x, y) {
    for (let i = tokens.length - 1; i >= 0; i--) {
      const t = tokens[i];
      const d = Math.hypot(x - t.x, y - t.y);
      if (d <= t.r + 6) return t;
    }
    return null;
  }

  function snapTokenBack(t) {
    // return to original anchored row positions (distribute)
    const basePositions = computeTokenBasePositions(tokens.length);
    const index = tokens.findIndex((tk) => tk.id === t.id);
    const pos = basePositions[index];
    animateMove(t, pos.x, pos.y, 280);
  }

  function computeTokenBasePositions(n) {
    const startX = 120;
    const gap = (WIDTH - 2 * startX) / (Math.max(1, n - 1));
    const arr = [];
    for (let i = 0; i < n; i++) {
      arr.push({ x: startX + gap * i, y: HEIGHT - 110 });
    }
    return arr;
  }

  // Selection logic
  function toggleTokenSelection(id) {
    const t = tokens.find((tk) => tk.id === id);
    if (!t) return;
    if (selectedIds.has(id)) {
      selectedIds.delete(id);
      // visually push back
      snapTokenBack(t);
      playClick();
      aria(`Removed ${t.value} from machine. Current sum ${currentSelectionSum()}.`);
      return;
    }
    // select only up to 4 tokens to avoid complexity
    if (selectedIds.size >= 4) {
      aria("You can use up to 4 tokens. Remove one before adding.");
      playWrongThud();
      return;
    }
    selectedIds.add(id);
    // animate token to bowl area
    const bowlCenter = { x: WIDTH / 2 + 140, y: HEIGHT / 2 + 20 };
    const offset = { x: randInt(-40, 40), y: randInt(-20, 20) };
    animateMove(t, bowlCenter.x + offset.x, bowlCenter.y + offset.y, 380);
    playClick();
    aria(`Added ${t.value}. Current sum ${currentSelectionSum()}.`);
  }

  function animateMove(obj, tx, ty, duration = 300) {
    const start = { x: obj.x, y: obj.y, t: performance.now() };
    const end = { x: tx, y: ty };
    function step(now) {
      const p = Math.min(1, (now - start.t) / duration);
      const ease = p < 0.5 ? 2 * p * p : -1 + (4 - 2 * p) * p;
      obj.x = start.x + (end.x - start.x) * ease;
      obj.y = start.y + (end.y - start.y) * ease;
      if (p < 1) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  function currentSelectionSum() {
    let s = 0;
    for (let id of selectedIds) {
      const t = tokens.find((tk) => tk.id === id);
      if (t) s += t.value;
    }
    return s;
  }

  function handleSubmit() {
    const s = currentSelectionSum();
    if (s === 0) {
      aria("No tokens selected. Choose tokens to make the target total.");
      playWrongThud();
      return;
    }
    if (s === target) {
      // correct
      score += 10 + attemptsLeft * 2;
      playCorrectTune();
      aria(`Correct! You made ${target}. Level ${level} completed.`);
      // mark tokens as used and move to success animation
      for (let id of selectedIds) {
        const t = tokens.find((tk) => tk.id === id);
        if (t) t.used = true;
      }
      selectedIds.clear();
      setTimeout(() => {
        level++;
        if (level > MAX_LEVELS) {
          // win game
          showWin();
        } else {
          generateLevel(level);
        }
      }, 900);
    } else {
      attemptsLeft--;
      playWrongThud();
      aria(`Not quite. Your sum is ${s}. Attempts left: ${attemptsLeft}.`);
      if (attemptsLeft <= 0) {
        // reveal correct hint and advance
        revealHint();
        setTimeout(() => {
          level++;
          if (level > MAX_LEVELS) showWin();
          else generateLevel(level);
        }, 1200);
      }
    }
  }

  function revealHint() {
    // find any subset that makes target and highlight
    const vals = tokens.map((t) => t.value);
    const idxs = subsetSumIndices(vals, target);
    if (idxs) {
      for (let i of idxs) {
        selectedIds.add(tokens[i].id);
      }
      // animate bowl acceptance
      playCorrectTune();
      aria("Here's a helpful hint: some tokens are highlighted.");
    } else {
      aria("No hint found; moving to next round.");
    }
  }

  // subset sum solver returning indices
  function subsetSumIndices(arr, target) {
    const n = arr.length;
    // try all subsets up to size 4
    for (let size = 1; size <= Math.min(4, n); size++) {
      const comb = [];
      if (search(0, 0)) {
        return comb;
      }
      function search(i, sum) {
        if (sum === target && comb.length === size) return true;
        if (sum > target) return false;
        if (i >= n) return false;
        // choose
        comb.push(i);
        if (search(i + 1, sum + arr[i])) return true;
        comb.pop();
        // skip
        return search(i + 1, sum);
      }
    }
    // try any subset
    const best = [];
    function dfs(i, sum) {
      if (sum === target) return [];
      if (i >= n) return null;
      // choose
      const withChoose = dfs(i + 1, sum + arr[i]);
      if (withChoose !== null) {
        return [i].concat(withChoose);
      }
      return dfs(i + 1, sum);
    }
    return dfs(0, 0);
  }

  function handleClear() {
    selectedIds.clear();
    // snap back all tokens that are not used
    tokens.forEach((t, i) => {
      if (!t.used) {
        const pos = computeTokenBasePositions(tokens.length)[i];
        animateMove(t, pos.x, pos.y, 300);
      }
    });
    aria("Selection cleared.");
    playClick();
  }

  function toggleAudio() {
    showAudioOn = !showAudioOn;
    if (audioCtx && showAudioOn) {
      ensureAudioRunning();
      bgGain.gain.value = 0.02;
    } else if (audioCtx) {
      bgGain.gain.value = 0;
    }
    aria(showAudioOn ? "Audio enabled." : "Audio muted.");
  }

  function hitButtonAt(x, y) {
    // Submit button rectangle
    const submit = { x: WIDTH - 140, y: HEIGHT - 120, w: 110, h: 44 };
    const clear = { x: WIDTH - 280, y: HEIGHT - 120, w: 110, h: 44 };
    const audioBtn = { x: WIDTH - 70, y: 20, r: 18 };
    if (x >= submit.x && x <= submit.x + submit.w && y >= submit.y && y <= submit.y + submit.h) return "submit";
    if (x >= clear.x && x <= clear.x + clear.w && y >= clear.y && y <= clear.y + clear.h) return "clear";
    if (Math.hypot(x - audioBtn.x, y - audioBtn.y) <= audioBtn.r) return "audio";
    return null;
  }

  // Keyboard controls
  canvas.addEventListener("keydown", (e) => {
    // Ensure audio starts on first key
    if (audioAvailable && audioCtx && audioCtx.state === "suspended") {
      ensureAudioRunning();
    }
    if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].includes(e.key)) {
      e.preventDefault();
    }
    switch (e.key) {
      case "ArrowLeft":
        keyboardIndex = (keyboardIndex - 1 + tokens.length) % tokens.length;
        playClick();
        aria(`Selected token ${tokens[keyboardIndex].value}. Press Enter to toggle it.`);
        break;
      case "ArrowRight":
        keyboardIndex = (keyboardIndex + 1) % tokens.length;
        playClick();
        aria(`Selected token ${tokens[keyboardIndex].value}. Press Enter to toggle it.`);
        break;
      case "Enter":
      case " ":
        // toggle selected token
        if (tokens[keyboardIndex]) {
          toggleTokenSelection(tokens[keyboardIndex].id);
        }
        break;
      case "Backspace":
      case "Delete":
        handleClear();
        break;
      case "s":
      case "S":
        handleSubmit();
        break;
      case "a":
      case "A":
        toggleAudio();
        break;
    }
  });

  // Draw helpers
  function drawRoundedRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  // Main render loop
  function render() {
    tick++;
    rotatingCogAngle += 0.008 * (1 + level * 0.05);
    // background
    ctx.fillStyle = palette.bg;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // soft gradient sky panel
    const g = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    g.addColorStop(0, "#eef7fb");
    g.addColorStop(1, "#f6fbff");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Soft ground
    ctx.fillStyle = "#eaf7f5";
    ctx.fillRect(0, HEIGHT - 110, WIDTH, 110);

    // Wacky machine body
    ctx.save();
    ctx.translate(WIDTH / 2 - 40, HEIGHT / 2 - 20);
    ctx.fillStyle = palette.machine;
    drawRoundedRect(-180, -120, 420, 240, 24); // main body
    ctx.fillStyle = palette.subtle;
    // machine screen
    ctx.fillRect(40, -90, 160, 60);
    ctx.fillStyle = palette.accent;
    ctx.fillRect(48, -82, 144, 44);
    ctx.restore();

    // Screen text
    ctx.fillStyle = palette.text;
    ctx.font = "22px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText("Wacky Machine Mixer", 18, 36);

    // Draw rotating cog (left)
    drawCog(88, 120, 48, rotatingCogAngle, "#d6e9f0", "#7fb6c7");
    // Draw small cog right
    drawCog(WIDTH - 140, 120, 30, -rotatingCogAngle * 1.4, "#f0e1f9", "#b69ff0");

    // Draw gauge showing target
    drawGauge(WIDTH / 2 + 160, HEIGHT / 2 - 40, target);

    // Draw bowl where tokens go
    drawBowl(WIDTH / 2 + 140, HEIGHT / 2 + 20, 90);

    // Draw tokens
    for (let i = 0; i < tokens.length; i++) {
      const t = tokens[i];
      // gently bobbing
      t.wobble += 0.02;
      if (!selectedIds.has(t.id) && !t.used && (!drag || drag.token.id !== t.id)) {
        // drift toward base position
        const base = computeTokenBasePositions(tokens.length)[i];
        t.x += (base.x - t.x) * 0.08;
        t.y += (base.y - t.y) * 0.08;
      }
      drawToken(t, i === keyboardIndex);
    }

    // Draw submit and clear buttons
    drawButtons();

    // Draw HUD: level, score, attempts
    ctx.fillStyle = palette.text;
    ctx.font = "16px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText(`Level ${level} / ${MAX_LEVELS}`, 18, HEIGHT - 78);
    ctx.fillText(`Score ${score}`, 18, HEIGHT - 54);
    ctx.fillText(`Attempts left: ${attemptsLeft}`, 18, HEIGHT - 30);

    // Draw audio icon + visualizer
    drawAudioIcon(WIDTH - 70, 20, showAudioOn);

    // Draw subtle wacky animated pipes
    drawPipes();

    requestAnimationFrame(render);
  }

  function drawPipes() {
    ctx.save();
    ctx.globalAlpha = 0.6;
    ctx.strokeStyle = "#cbeaf0";
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(20, 80);
    ctx.bezierCurveTo(120, 20, 240, 40, WIDTH / 2 - 120, HEIGHT / 2 - 40);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(WIDTH - 20, 80);
    ctx.bezierCurveTo(WIDTH - 160, 20, WIDTH - 280, 80, WIDTH / 2 + 80, HEIGHT / 2 - 40);
    ctx.stroke();
    ctx.restore();
  }

  function drawAudioIcon(x, y, on) {
    // circle speaker with pulse
    ctx.save();
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.fillStyle = on ? "#e9fff8" : "#f5f5f5";
    ctx.fill();
    ctx.strokeStyle = "#cde7e3";
    ctx.stroke();
    // speaker shape
    ctx.fillStyle = on ? "#1a6b5a" : "#6c6c6c";
    ctx.beginPath();
    ctx.moveTo(x - 6, y - 6);
    ctx.lineTo(x - 2, y - 6);
    ctx.lineTo(x + 2, y - 10);
    ctx.lineTo(x + 2, y + 10);
    ctx.lineTo(x - 2, y + 6);
    ctx.lineTo(x - 6, y + 6);
    ctx.closePath();
    ctx.fill();
    // waves if on, animate
    if (on) {
      const waveCount = 2;
      for (let i = 1; i <= waveCount; i++) {
        ctx.beginPath();
        ctx.strokeStyle = `rgba(26,107,90,${0.18 - i * 0.06})`;
        ctx.lineWidth = 2;
        ctx.arc(x + 4, y, 6 + (tick * 0.8 + i * 8) % 12, -0.6, 0.6);
        ctx.stroke();
      }
    }
    ctx.restore();
  }

  function drawButtons() {
    // clear
    const clear = { x: WIDTH - 280, y: HEIGHT - 120, w: 110, h: 44 };
    ctx.fillStyle = "#fff";
    ctx.strokeStyle = "#cfe7f3";
    ctx.lineWidth = 2;
    drawRoundedRect(clear.x, clear.y, clear.w, clear.h, 8);
    ctx.fillStyle = palette.text;
    ctx.font = "16px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("Clear", clear.x + clear.w / 2, clear.y + clear.h / 2 + 6);

    // submit
    const submit = { x: WIDTH - 140, y: HEIGHT - 120, w: 110, h: 44 };
    ctx.fillStyle = "#aee7d6";
    ctx.strokeStyle = "#89cdb3";
    drawRoundedRect(submit.x, submit.y, submit.w, submit.h, 10);
    ctx.fillStyle = palette.text;
    ctx.fillText("Submit", submit.x + submit.w / 2, submit.y + submit.h / 2 + 6);
  }

  function drawBowl(cx, cy, r) {
    ctx.save();
    ctx.translate(cx, cy);
    // shadow
    ctx.beginPath();
    ctx.ellipse(0, r - 12, r * 1.1, 16, 0, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(40,60,60,0.06)";
    ctx.fill();
    // bowl
    ctx.beginPath();
    ctx.moveTo(-r, -20);
    ctx.quadraticCurveTo(0, -r - 10, r, -20);
    ctx.lineTo(r, 40);
    ctx.quadraticCurveTo(0, r, -r, 40);
    ctx.closePath();
    ctx.fillStyle = "#f3fbff";
    ctx.fill();
    ctx.strokeStyle = "#cfe7f3";
    ctx.stroke();
    // digital display showing current sum
    ctx.fillStyle = "#e7f7ff";
    ctx.fillRect(-54, -12, 108, 28);
    ctx.strokeStyle = "#bfe6f0";
    ctx.strokeRect(-54, -12, 108, 28);
    ctx.fillStyle = palette.text;
    ctx.font = "18px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(`${currentSelectionSum()} / ${target}`, 0, 8);
    ctx.restore();
  }

  function drawGauge(x, y, value) {
    ctx.save();
    ctx.translate(x, y);
    // circular gauge
    ctx.beginPath();
    ctx.arc(0, 0, 64, Math.PI * 0.8, Math.PI * 2.2);
    ctx.strokeStyle = "#ddeffd";
    ctx.lineWidth = 18;
    ctx.stroke();
    // needle
    const fraction = clamp(value / 30, 0, 1); // scale
    const angle = Math.PI * 0.8 + (Math.PI * 1.4) * fraction;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(Math.cos(angle) * 56, Math.sin(angle) * 56);
    ctx.strokeStyle = "#15707a";
    ctx.lineWidth = 3;
    ctx.stroke();
    // center dot
    ctx.beginPath();
    ctx.arc(0, 0, 6, 0, Math.PI * 2);
    ctx.fillStyle = "#15707a";
    ctx.fill();
    // label
    ctx.fillStyle = palette.text;
    ctx.font = "18px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("Target", 0, -84);
    ctx.font = "24px sans-serif";
    ctx.fillText(value, 0, -56);
    ctx.restore();
  }

  function drawToken(t, highlighted = false) {
    ctx.save();
    // shadow
    ctx.beginPath();
    ctx.ellipse(t.x + 6, t.y + 8, t.r * 0.9, t.r * 0.5, 0, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(40,60,60,0.08)";
    ctx.fill();

    // token body
    ctx.beginPath();
    ctx.arc(t.x, t.y, t.r, 0, Math.PI * 2);
    ctx.fillStyle = t.color;
    ctx.fill();
    ctx.strokeStyle = highlighted ? "#3b6f6b" : "#c7dfe6";
    ctx.lineWidth = highlighted ? 4 : 2;
    ctx.stroke();

    // little face to be wacky
    ctx.fillStyle = "#ffffffcc";
    ctx.beginPath();
    ctx.arc(t.x - 8, t.y - 4, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(t.x + 6, t.y - 4, 6, 0, Math.PI * 2);
    ctx.fill();
    // pupils
    ctx.fillStyle = "#333";
    ctx.beginPath();
    ctx.arc(t.x - 7, t.y - 3, 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(t.x + 5, t.y - 3, 2, 0, Math.PI * 2);
    ctx.fill();

    // value text
    ctx.fillStyle = palette.text;
    ctx.font = "bold 18px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(t.value, t.x, t.y + 6);

    // used overlay
    if (t.used) {
      ctx.fillStyle = "rgba(255,255,255,0.7)";
      ctx.beginPath();
      ctx.arc(t.x, t.y, t.r - 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = palette.text;
      ctx.font = "14px sans-serif";
      ctx.fillText("✓", t.x, t.y + 5);
    }

    // selection glow
    if (selectedIds.has(t.id)) {
      ctx.beginPath();
      ctx.arc(t.x, t.y, t.r + 8, 0, Math.PI * 2);
      ctx.strokeStyle = palette.right;
      ctx.lineWidth = 6;
      ctx.stroke();
    }

    ctx.restore();
  }

  function drawCog(cx, cy, radius, angle, fill, stroke) {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(angle);
    const teeth = 10;
    ctx.beginPath();
    for (let i = 0; i < teeth; i++) {
      const a = (i / teeth) * Math.PI * 2;
      const r1 = radius;
      const r2 = radius * 1.28;
      const x1 = Math.cos(a) * r1;
      const y1 = Math.sin(a) * r1;
      const x2 = Math.cos(a + Math.PI / teeth) * r2;
      const y2 = Math.sin(a + Math.PI / teeth) * r2;
      if (i === 0) ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
    }
    ctx.closePath();
    ctx.fillStyle = fill;
    ctx.fill();
    ctx.strokeStyle = stroke;
    ctx.lineWidth = 3;
    ctx.stroke();
    // center
    ctx.beginPath();
    ctx.arc(0, 0, radius * 0.6, 0, Math.PI * 2);
    ctx.fillStyle = "#f8fbff";
    ctx.fill();
    ctx.strokeStyle = "#c9eaf1";
    ctx.stroke();
    ctx.restore();
  }

  // Win state drawing and handling
  let winning = false;
  function showWin() {
    winning = true;
    aria(`Fantastic! You finished all ${MAX_LEVELS} levels with a score of ${score}.`);
    // celebration sounds
    if (audioCtx) {
      playBeep(0, 0.18, 880, "sine", 0.06);
      playBeep(0.12, 0.18, 1100, "sine", 0.06);
      playBeep(0.24, 0.26, 1318, "sine", 0.06);
    }
    // show animated fireworks for a few seconds then reset to intro
    let t0 = performance.now();
    let done = false;
    function celebrate(now) {
      // clear area
      ctx.fillStyle = palette.bg;
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = "#f0fbff";
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      // big message
      ctx.fillStyle = palette.text;
      ctx.font = "40px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("BRAVO! Machine Master!", WIDTH / 2, HEIGHT / 2 - 20);
      ctx.font = "20px sans-serif";
      ctx.fillText(`Score: ${score}`, WIDTH / 2, HEIGHT / 2 + 14);
      // simple fireworks
      const elapsed = now - t0;
      for (let i = 0; i < 8; i++) {
        const phase = (elapsed / 1000) * (0.5 + i * 0.07);
        const cx = WIDTH / 2 + Math.cos(phase + i) * 160;
        const cy = HEIGHT / 2 + Math.sin(phase * 1.3 + i * 0.4) * 80;
        drawSpark(cx, cy, (i * 37) % 360, (elapsed / 100) % 360, i + 5);
      }
      if (elapsed > 4200) {
        done = true;
      }
      if (!done) requestAnimationFrame(celebrate);
      else {
        // reset game
        level = 1;
        score = 0;
        winning = false;
        generateLevel(level);
      }
    }
    requestAnimationFrame(celebrate);
  }

  function drawSpark(cx, cy, hue, phase, spikes) {
    ctx.save();
    ctx.translate(cx, cy);
    for (let j = 0; j < spikes; j++) {
      ctx.beginPath();
      const a = (j / spikes) * Math.PI * 2;
      const r1 = 2 + (Math.sin((tick * 0.1) + j) + 1) * 10;
      const r2 = 2 + (Math.cos((tick * 0.12) + j) + 1) * 12;
      ctx.moveTo(Math.cos(a) * r1, Math.sin(a) * r1);
      ctx.lineTo(Math.cos(a + 0.02) * r2, Math.sin(a + 0.02) * r2);
      ctx.strokeStyle = `hsla(${(hue + j * 30) % 360},70%,60%,0.95)`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    ctx.restore();
  }

  // Start screen
  function showIntro() {
    ctx.fillStyle = palette.bg;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    ctx.fillStyle = palette.text;
    ctx.font = "28px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("Wacky Machine Mixer", WIDTH / 2, 120);
    ctx.font = "18px sans-serif";
    ctx.fillText("Make the machine happy by choosing tokens that add up to the target number!", WIDTH / 2, 160);
    ctx.fillText("Use the mouse or keyboard (arrow keys to select, Enter to pick, S to submit).", WIDTH / 2, 190);
    ctx.fillText("You can use up to 4 tokens. Press A to toggle audio. Beat all levels to win!", WIDTH / 2, 220);

    // small start button drawn on canvas
    ctx.fillStyle = "#aee7d6";
    drawRoundedRect(WIDTH / 2 - 80, 260, 160, 52, 10);
    ctx.fillStyle = palette.text;
    ctx.font = "20px sans-serif";
    ctx.fillText("Start Game", WIDTH / 2, 292);

    // keyboard instructions block left
    ctx.fillStyle = "#fff";
    drawRoundedRect(32, 320, 240, 120, 12);
    ctx.fillStyle = palette.text;
    ctx.font = "14px sans-serif";
    ctx.textAlign = "left";
    ctx.fillText("Keyboard", 48, 344);
    ctx.fillText("← → : Select tokens", 48, 364);
    ctx.fillText("Enter or Space: Toggle token", 48, 384);
    ctx.fillText("S: Submit   Delete: Clear", 48, 404);

    // clickable start
    canvas.addEventListener("click", startClickHandler);
    canvas.addEventListener("touchend", startClickHandler);
    aria("Welcome! Press Start to play. Use keyboard or mouse to interact.");
  }

  function startClickHandler(e) {
    let pos;
    if (e.changedTouches) {
      const t0 = e.changedTouches[0];
      const rect = canvas.getBoundingClientRect();
      pos = { x: t0.clientX - rect.left, y: t0.clientY - rect.top };
    } else {
      pos = getMouse(e);
    }
    if (pos.x >= WIDTH / 2 - 80 && pos.x <= WIDTH / 2 + 80 && pos.y >= 260 && pos.y <= 312) {
      canvas.removeEventListener("click", startClickHandler);
      canvas.removeEventListener("touchend", startClickHandler);
      // ensure audio will start on next gesture
      if (audioCtx && audioCtx.state === "suspended") {
        ensureAudioRunning();
      }
      generateLevel(level);
      requestAnimationFrame(render);
    }
  }

  // Error and fallback messages for audio
  if (!audioAvailable) {
    aria("Audio is not available in this browser. The game will play without sound.");
    showAudioOn = false;
  } else {
    // ensure audio starts on first canvas focus/click
    const resumeOnInteract = () => {
      if (audioCtx && audioCtx.state === "suspended") {
        audioCtx.resume().catch(() => {});
      }
      canvas.removeEventListener("pointerdown", resumeOnInteract);
      canvas.removeEventListener("keydown", resumeOnInteract);
    };
    canvas.addEventListener("pointerdown", resumeOnInteract);
    canvas.addEventListener("keydown", resumeOnInteract);
  }

  // Initialize to intro
  showIntro();

  // Helper: subsetSumIndices requires careful but this simple approach above is ok.

  // END of IIFE
})();
---

