# Game of the Day - 2025-11-05

## Metadata
- **Generated Date:** 2025-11-05
- **Generated Time:** 2025-11-05T00:28:58.883405
- **Model:** gpt-5-mini
- **Theme:** drones
- **Game File:** 2025-11-05.js
- **File Size:** 25419 bytes
- **Tokens Used:** 9254

## Functionality Score
- **Score:** 12/12 (100.0%)
- **Status:** âœ… PASSING

### Functionality Issues
- None

### Functionality Warnings
- None

## Dependency Analysis
- **External Dependencies:** âœ… NONE
- **Canvas Methods Used:** 5

### Dependency Issues
- None

### Dependency Warnings
- None

## Prompt Used
You are an expert educational game designer. You will generate a fun, playable math game in JavaScript for children ages 7 to 9, focused on foundational concepts presented in a way that is engaging and fun. Today's theme: drones

The game must:
â€¢ Be beatable with CLEAR WIN AND LOSS CONDITIONS:
  - Include a specific goal (e.g., "answer 10 questions correctly", "reach level 5", "collect 50 stars")
  - Include a way to lose or fail (e.g., "3 wrong answers = game over", "timer runs out", "lives system")
  - Show a victory screen when the player wins
  - Show a game over screen when the player loses
  - Include a restart button or instruction on both end screens
â€¢ Use visually calming and interesting and wacky elements.
â€¢ Include sound, using the Web Audio API for correct/incorrect feedback, gentle background effects, or interactions. Use an audio context.
â€¢ Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it .
â€¢ Have a game area exactly 720px wide by 480px tall.
â€¢ Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
â€¢ Use modern JavaScript practices and avoid minification.
â€¢ Include proper error handling for audio and resource loading.
â€¢ Be accessible: include keyboard controls, text alternatives, visual cues for audio, clear instructions, and error handling.
â€¢ Have PROPER UI LAYOUT with NO OVERLAPPING TEXT:
  - Ensure all text has adequate spacing (minimum 10px padding between UI elements)
  - Use ctx.measureText() to calculate text width before drawing
  - Place UI elements in non-overlapping positions (e.g., score top-left, lives top-right, instructions bottom-center)
  - Use background rectangles behind text for readability
  - Test that multi-line text doesn't overlap with game elements
  - Ensure proper font sizes (minimum 14px for body text, 18px+ for important info)
â€¢ Use ONLY canvas-drawn graphics or 3js and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
â€¢ Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.) or 3js.
â€¢ Generate all sounds using Web Audio API oscillators and filters.
â€¢ Include proper error handling for audio context creation.
â€¢ Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks, no HTML, no CSS.
â€¢ Do not wrap the code in ```javascript or any other markdown formatting.

## Game Description
This game was automatically generated using OpenAI's gpt-5-mini model with the theme: "drones".

## Files Generated
- `2025-11-05.js` - The playable game
- `2025-11-05.meta.json` - Machine-readable metadata
- `2025-11-05.meta.md` - This human-readable documentation


---

## Visuals & Audio Improvement
A second model call was made to enhance visuals and audio.

- **Tokens Used (improvement):** 17847

## Code Formatting
A third model call was made to ensure proper code formatting and readability.

- **Tokens Used (formatting):** 19133

### Final Functionality Score After Improvement
- **Score:** 12/12 (100.0%)
- **Status:** âœ… PASSING

### Final Functionality Issues
- None

### Final Functionality Warnings
- None

### Prompt Used for Improvement
You are an expert educational game designer. 
Take the following JavaScript game code and improve ONLY the visuals and audio. 
Do not change the game mechanics or math logic. 
Enhance the visual appeal (colors, animations, backgrounds, characters), avoid overstimulation with sounds and visuals, and add or improve sound effects and background audio. 
Render entirely inside the existing HTML element with ID game-of-the-day-stage. You may create a canvas element inside it (do not include angle brackets in text instructions).
Have a game area exactly 720px wide by 480px tall.
Be written in clean, readable JavaScript with proper formatting, indentation, and comments.
Use modern JavaScript practices and avoid minification.
Include proper error handling for audio and resource loading.
Use ONLY canvas-drawn graphics and Web Audio API - NO external image URLs, NO external audio files, NO external dependencies.
Create all visual elements using canvas drawing methods (rect, arc, fillText, etc.).
Generate all sounds using Web Audio API oscillators and filters.
Include proper error handling for audio context creation.
MAINTAIN clear win and loss conditions - do not remove game completion logic or end screens.
MAINTAIN proper UI spacing - ensure text has padding, no overlaps, and proper alignment.
Output only JavaScript code. No extra explanation, no markdown formatting, no code blocks.
Do not wrap the code in ```javascript or any other markdown formatting.

---
(function () {
  // Drone Math Collector - JavaScript Game
  // Rendered inside existing element with id "game-of-the-day-stage"
  // All graphics via Canvas; all sounds generated with Web Audio API.
  // Designed for children ages 7-9; goal: collect 10 correct packages, lose after 3 wrong picks.

  // ------------------------------
  // Initialization and Utilities
  // ------------------------------

  const CONTAINER_ID = "game-of-the-day-stage";
  const WIDTH = 720;
  const HEIGHT = 480;
  const GOAL_CORRECT = 10;
  const MAX_WRONG = 3;
  const PACKAGE_SPAWN_INTERVAL = 1400; // ms
  const PACKAGE_SPEED_MIN = 0.4;
  const PACKAGE_SPEED_MAX = 1.2;

  const container = document.getElementById(CONTAINER_ID);
  if (!container) {
    console.error(`Container element with id "${CONTAINER_ID}" not found.`);
    return;
  }

  // Clear container and set relative positioning
  container.innerHTML = "";
  container.style.position = "relative";
  container.setAttribute("tabindex", "0"); // allow keyboard focus

  // Create accessible text area for screen readers (visually hidden)
  const liveRegion = document.createElement("div");
  liveRegion.setAttribute("aria-live", "polite");
  liveRegion.style.position = "absolute";
  liveRegion.style.left = "-9999px";
  container.appendChild(liveRegion);

  // Create the canvas
  const canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.setAttribute("role", "img");
  canvas.setAttribute("aria-label", "Drone math game. Move with arrow keys or WASD. Press space to pick packages.");
  container.appendChild(canvas);

  const ctx = canvas.getContext("2d");
  if (!ctx) {
    console.error("2D context not available.");
    return;
  }

  // Utility clamp
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  // ------------------------------
  // Audio Setup with Error Handling
  // ------------------------------
  let audioCtx = null;
  let audioEnabled = true;
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AudioContext();
    // Gentle background hum
    const bgOsc = audioCtx.createOscillator();
    const bgGain = audioCtx.createGain();
    bgOsc.type = "sine";
    bgOsc.frequency.value = 110; // low hum
    bgGain.gain.value = 0.003; // very subtle
    bgOsc.connect(bgGain).connect(audioCtx.destination);
    bgOsc.start();
  } catch (e) {
    console.warn("AudioContext not available or failed to create:", e);
    audioEnabled = false;
    audioCtx = null;
  }

  function playCorrectSound() {
    if (!audioEnabled || !audioCtx) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "triangle";
      o.frequency.setValueAtTime(440, audioCtx.currentTime);
      o.frequency.exponentialRampToValueAtTime(880, audioCtx.currentTime + 0.25);
      g.gain.setValueAtTime(0, audioCtx.currentTime);
      g.gain.linearRampToValueAtTime(0.12, audioCtx.currentTime + 0.01);
      g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.7);
      o.connect(g).connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime + 0.8);
    } catch (e) {
      console.warn("Error playing correct sound:", e);
    }
  }

  function playWrongSound() {
    if (!audioEnabled || !audioCtx) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "square";
      o.frequency.setValueAtTime(200, audioCtx.currentTime);
      o.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.25);
      g.gain.setValueAtTime(0.15, audioCtx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
      const f = audioCtx.createBiquadFilter();
      f.type = "lowpass";
      f.frequency.value = 1200;
      o.connect(f).connect(g).connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime + 0.6);
    } catch (e) {
      console.warn("Error playing wrong sound:", e);
    }
  }

  // Toggle audio on/off
  function toggleAudio() {
    if (!audioCtx) {
      audioEnabled = false;
      return;
    }
    if (audioCtx.state === "suspended") {
      audioCtx.resume().then(() => {
        audioEnabled = true;
      });
    } else {
      // Can't really suspend the one-time bg oscillator easily, but we can set a flag
      audioEnabled = !audioEnabled;
    }
  }

  // ------------------------------
  // Game State
  // ------------------------------

  let lastTime = performance.now();
  let spawnTimer = 0;
  let packages = [];
  let keys = {};
  let mouse = { x: 0, y: 0, down: false };
  let gameState = "playing"; // 'playing', 'victory', 'gameover'
  let correctCount = 0;
  let wrongCount = 0;
  let currentQuestion = null;
  let accessibleMessage = "";

  // Drone object
  const drone = {
    x: WIDTH / 2,
    y: HEIGHT / 2,
    radius: 26,
    vx: 0,
    vy: 0,
    speed: 2.2,
    propellerAngle: 0
  };

  // Colors (calming pastel palette)
  const BG_COLOR = "#E8F6FF";
  const CLOUD_COLOR = "#FFFFFF";
  const PACKAGE_COLORS = ["#FFD6A5", "#BDE0FE", "#CDEAC0", "#F6C2D7"];
  const DRONE_COLOR = "#6C6CE5";
  const TEXT_COLOR = "#123456";
  const UI_BG = "rgba(255,255,255,0.85)";

  // ------------------------------
  // Math Question Generation
  // ------------------------------

  function generateQuestion() {
    // For ages 7-9: addition and subtraction within 0-20, occasional small multiplies.
    const types = ["add", "sub", "add", "add", "mul"]; // weighting addition
    const t = types[Math.floor(Math.random() * types.length)];
    let a, b, answer, text;
    if (t === "add") {
      a = Math.floor(Math.random() * 11); // 0..10
      b = Math.floor(Math.random() * 11);
      answer = a + b;
      text = `${a} + ${b} = ?`;
    } else if (t === "sub") {
      a = Math.floor(Math.random() * 11) + 5; // 5..15
      b = Math.floor(Math.random() * 6); // 0..5
      answer = a - b;
      text = `${a} - ${b} = ?`;
    } else {
      a = Math.floor(Math.random() * 5) + 2; // 2..6
      b = Math.floor(Math.random() * 5) + 2;
      answer = a * b;
      text = `${a} Ã— ${b} = ?`;
    }
    return { a, b, answer, text, type: t };
  }

  function createPackagesForQuestion(question) {
    const correct = question.answer;
    // Create two plausible wrong answers
    const wrongs = new Set();
    while (wrongs.size < 2) {
      let candidate;
      if (Math.random() < 0.5) {
        candidate = correct + (Math.floor(Math.random() * 5) - 2);
      } else {
        candidate = Math.max(0, correct + (Math.random() < 0.5 ? -3 : 3) + Math.floor(Math.random() * 3));
      }
      if (candidate !== correct && candidate >= 0 && candidate <= 100) wrongs.add(candidate);
    }
    const answers = shuffleArray([correct, ...Array.from(wrongs)]);
    // Place packages spaced across top
    const margin = 60;
    const step = (WIDTH - margin * 2) / (answers.length - 1);
    const list = answers.map((ans, i) => {
      return {
        id: Math.random().toString(36).slice(2, 9),
        x: margin + step * i,
        y: -30 - Math.random() * 80,
        w: 82,
        h: 54,
        vx: (Math.random() - 0.5) * 0.2,
        vy: PACKAGE_SPEED_MIN + Math.random() * (PACKAGE_SPEED_MAX - PACKAGE_SPEED_MIN),
        value: ans,
        color: PACKAGE_COLORS[i % PACKAGE_COLORS.length],
        alive: true
      };
    });
    return list;
  }

  function shuffleArray(arr) {
    const copy = arr.slice();
    for (let i = copy.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [copy[i], copy[j]] = [copy[j], copy[i]];
    }
    return copy;
  }

  // Initialize first question and packages
  function newQuestion() {
    currentQuestion = generateQuestion();
    packages = createPackagesForQuestion(currentQuestion);
    announce(`New question: ${currentQuestion.text}`);
  }

  // Accessibility announcer
  function announce(text) {
    accessibleMessage = text;
    liveRegion.textContent = text;
  }

  // ------------------------------
  // Input Handling
  // ------------------------------
  window.addEventListener("keydown", (e) => {
    keys[e.key.toLowerCase()] = true;

    // Help: restart with r
    if (e.key.toLowerCase() === "r") {
      if (gameState === "victory" || gameState === "gameover") {
        restartGame();
      } else {
        // Also allow mid-game restart
        restartGame();
      }
    }

    // Space to pick overlapping package
    if (e.key === " " || e.key === "Spacebar") {
      if (gameState === "playing") {
        pickOverlappingPackage();
      }
      e.preventDefault();
    }

    // Number keys 1-3 to pick left-to-right packages
    if (["1", "2", "3"].includes(e.key) && gameState === "playing") {
      const idx = parseInt(e.key, 10) - 1;
      if (packages[idx]) {
        pickPackage(packages[idx]);
      }
    }

    // Toggle audio with m
    if (e.key.toLowerCase() === "m") {
      toggleAudio();
      announce(audioEnabled ? "Audio on" : "Audio off");
    }
  });

  window.addEventListener("keyup", (e) => {
    keys[e.key.toLowerCase()] = false;
  });

  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
    mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
  });

  canvas.addEventListener("mousedown", (e) => {
    mouse.down = true;
    // click picks a package when clicking on it
    const p = packages.find((pck) => {
      return (
        mouse.x >= pck.x - pck.w / 2 &&
        mouse.x <= pck.x + pck.w / 2 &&
        mouse.y >= pck.y - pck.h / 2 &&
        mouse.y <= pck.y + pck.h / 2
      );
    });
    if (p && gameState === "playing") {
      pickPackage(p);
    }

    // If in end screen, check restart button area
    if ((gameState === "victory" || gameState === "gameover") && restartButtonRect) {
      const r = restartButtonRect;
      if (mouse.x >= r.x && mouse.x <= r.x + r.w && mouse.y >= r.y && mouse.y <= r.y + r.h) {
        restartGame();
      }
    }
  });

  canvas.addEventListener("mouseup", () => {
    mouse.down = false;
  });

  // ------------------------------
  // Picking and Collision
  // ------------------------------
  function pickOverlappingPackage() {
    const collided = packages.find((p) => circleRectCollision(drone.x, drone.y, drone.radius, p));
    if (collided) {
      pickPackage(collided);
    } else {
      announce("No package in reach. Fly closer to a package and press space.");
    }
  }

  function circleRectCollision(cx, cy, r, rect) {
    const rx = rect.x - rect.w / 2;
    const ry = rect.y - rect.h / 2;
    // Find closest point
    const closestX = clamp(cx, rx, rx + rect.w);
    const closestY = clamp(cy, ry, ry + rect.h);
    const dx = cx - closestX;
    const dy = cy - closestY;
    return dx * dx + dy * dy <= r * r;
  }

  function pickPackage(p) {
    if (!p || !p.alive) return;
    p.alive = false;
    if (p.value === currentQuestion.answer) {
      correctCount++;
      playCorrectSound();
      announce(`Correct! ${currentQuestion.text} Answer: ${currentQuestion.answer}. ${correctCount} correct collected.`);
      // Check win
      if (correctCount >= GOAL_CORRECT) {
        gameState = "victory";
        announce(`You collected ${GOAL_CORRECT} correct packages! Victory! Press R to restart.`);
      } else {
        // new question after a short delay
        setTimeout(newQuestion, 700);
      }
    } else {
      wrongCount++;
      playWrongSound();
      announce(`Oops! That was ${p.value}. Wrong answers: ${wrongCount} out of ${MAX_WRONG}.`);
      if (wrongCount >= MAX_WRONG) {
        gameState = "gameover";
        announce(`Game over. You made ${wrongCount} incorrect picks. Press R to try again.`);
      } else {
        // small shake / visual; continue with same question but remove package
      }
    }
  }

  // ------------------------------
  // Restart
  // ------------------------------
  function restartGame() {
    correctCount = 0;
    wrongCount = 0;
    packages = [];
    gameState = "playing";
    drone.x = WIDTH / 2;
    drone.y = HEIGHT / 2;
    newQuestion();
    announce("Game restarted. " + currentQuestion.text);
  }

  // ------------------------------
  // UI Layout helpers (measureText)
  // ------------------------------
  function measureTextSize(text, font = "16px sans-serif") {
    ctx.save();
    ctx.font = font;
    const metrics = ctx.measureText(text);
    const w = metrics.width;
    ctx.restore();
    return w;
  }

  // ------------------------------
  // Drawing Functions
  // ------------------------------

  function drawBackground(delta) {
    // Sky
    ctx.fillStyle = BG_COLOR;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Gentle moving clouds (two layers)
    const t = performance.now() / 1000;
    ctx.fillStyle = CLOUD_COLOR;
    drawCloud(WIDTH * 0.2 + Math.sin(t * 0.3) * 20, 80, 60);
    drawCloud(WIDTH * 0.7 + Math.cos(t * 0.2) * 30, 120, 50);
    drawCloud(WIDTH * 0.5 + Math.sin(t * 0.15) * 40, 40, 40);
  }

  function drawCloud(cx, cy, size) {
    ctx.beginPath();
    ctx.ellipse(cx - size * 0.5, cy, size * 0.6, size * 0.45, 0, 0, Math.PI * 2);
    ctx.ellipse(cx + size * 0.2, cy - size * 0.1, size * 0.7, size * 0.5, 0, 0, Math.PI * 2);
    ctx.ellipse(cx + size * 0.7, cy, size * 0.5, size * 0.36, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawDrone() {
    // Slight bob
    const bob = Math.sin(performance.now() / 220) * 2;
    ctx.save();
    ctx.translate(drone.x, drone.y + bob);

    // Drone body
    ctx.fillStyle = DRONE_COLOR;
    roundRect(ctx, -28, -12, 56, 24, 8, true, false);

    // Drone dome
    ctx.fillStyle = "#A9B0FF";
    ctx.beginPath();
    ctx.arc(0, -6, 12, Math.PI, 2 * Math.PI);
    ctx.fill();

    // Propellers - wacky shapes
    ctx.save();
    ctx.translate(-24, -10);
    ctx.rotate(drone.propellerAngle);
    drawPropeller(ctx);
    ctx.restore();

    ctx.save();
    ctx.translate(24, -10);
    ctx.rotate(-drone.propellerAngle);
    drawPropeller(ctx);
    ctx.restore();

    // Eyes / face (funny)
    ctx.fillStyle = "#123456";
    ctx.beginPath();
    ctx.arc(-8, -2, 3.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(8, -2, 3.2, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();

    // Propeller angle animation
    drone.propellerAngle += 0.18 + Math.abs(drone.vx) * 0.02 + Math.abs(drone.vy) * 0.02;
  }

  function drawPropeller(ctxLocal) {
    ctxLocal.fillStyle = "rgba(0,0,0,0.15)";
    ctxLocal.beginPath();
    ctxLocal.ellipse(0, 0, 20, 6, 0, 0, Math.PI * 2);
    ctxLocal.fill();
  }

  function roundRect(ctxLocal, x, y, w, h, r, fill, stroke) {
    ctxLocal.beginPath();
    ctxLocal.moveTo(x + r, y);
    ctxLocal.arcTo(x + w, y, x + w, y + h, r);
    ctxLocal.arcTo(x + w, y + h, x, y + h, r);
    ctxLocal.arcTo(x, y + h, x, y, r);
    ctxLocal.arcTo(x, y, x + w, y, r);
    ctxLocal.closePath();
    if (fill) ctxLocal.fill();
    if (stroke) ctxLocal.stroke();
  }

  function drawPackages(delta) {
    packages.forEach((p, i) => {
      if (!p.alive) return;
      // update position
      p.x += p.vx * delta;
      p.y += p.vy * delta;
      // drift horizontally gently
      p.vx += (Math.random() - 0.5) * 0.01;
      p.vx = clamp(p.vx, -0.6, 0.6);

      // Draw package shadow
      ctx.fillStyle = "rgba(0,0,0,0.08)";
      ctx.beginPath();
      ctx.ellipse(p.x, p.y + p.h / 2 + 6, p.w * 0.4, 6, 0, 0, Math.PI * 2);
      ctx.fill();

      // package box
      ctx.fillStyle = p.color;
      roundRect(ctx, p.x - p.w / 2, p.y - p.h / 2, p.w, p.h, 6, true, false);

      // label band
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      roundRect(ctx, p.x - p.w / 2 + 8, p.y - 10, p.w - 16, 20, 4, true, false);

      // value text
      ctx.fillStyle = TEXT_COLOR;
      ctx.font = "18px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(p.value), p.x, p.y);

      // If package is off-screen below, respawn above
      if (p.y - p.h / 2 > HEIGHT + 40) {
        p.y = -40;
        p.x = 40 + Math.random() * (WIDTH - 80);
      }
    });
  }

  // ------------------------------
  // UI Drawing (score, lives, audio, instructions)
  // ------------------------------
  let restartButtonRect = null;

  function drawUI() {
    // Score top-left
    ctx.font = "20px sans-serif";
    ctx.textBaseline = "middle";
    ctx.textAlign = "left";

    const scoreText = `Correct: ${correctCount}/${GOAL_CORRECT}`;
    const scoreW = measureTextSize(scoreText, "20px sans-serif");
    const scorePad = 10;
    const scoreBox = { x: 10, y: 10, w: scoreW + scorePad * 2, h: 36 };

    ctx.fillStyle = UI_BG;
    roundRect(ctx, scoreBox.x, scoreBox.y, scoreBox.w, scoreBox.h, 8, true, false);
    ctx.fillStyle = TEXT_COLOR;
    ctx.fillText(scoreText, scoreBox.x + scorePad, scoreBox.y + scoreBox.h / 2);

    // Lives top-right
    const livesText = `Lives: ${Math.max(0, MAX_WRONG - wrongCount)}`;
    const livesW = measureTextSize(livesText, "20px sans-serif");
    const livesPad = 10;
    const livesBox = { x: WIDTH - livesW - livesPad * 2 - 10, y: 10, w: livesW + livesPad * 2, h: 36 };
    ctx.fillStyle = UI_BG;
    roundRect(ctx, livesBox.x, livesBox.y, livesBox.w, livesBox.h, 8, true, false);
    ctx.fillStyle = TEXT_COLOR;
    ctx.textAlign = "left";
    ctx.fillText(livesText, livesBox.x + livesPad, livesBox.y + livesBox.h / 2);

    // Audio indicator top-center
    const audioText = audioEnabled ? "Audio: On (M)" : "Audio: Off (M)";
    ctx.font = "16px sans-serif";
    const audioW = measureTextSize(audioText, "16px sans-serif");
    const audioPad = 8;
    let audioX = Math.floor((WIDTH - audioW - audioPad * 2) / 2);
    const audioBox = { x: audioX, y: 12, w: audioW + audioPad * 2, h: 30 };

    // Ensure 10px spacing between audioBox and scoreBox/livesBox
    if (audioBox.x - (scoreBox.x + scoreBox.w) < 10) {
      audioBox.x = scoreBox.x + scoreBox.w + 10;
    }
    if ((livesBox.x - (audioBox.x + audioBox.w)) < 10) {
      audioBox.x = livesBox.x - audioBox.w - 10;
    }
    ctx.fillStyle = UI_BG;
    roundRect(ctx, audioBox.x, audioBox.y, audioBox.w, audioBox.h, 8, true, false);
    ctx.fillStyle = TEXT_COLOR;
    ctx.textAlign = "left";
    ctx.fillText(audioText, audioBox.x + audioPad, audioBox.y + audioBox.h / 2);

    // Current Question center-top below the audio
    ctx.font = "22px sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    const qText = currentQuestion ? currentQuestion.text : "";
    const qW = measureTextSize(qText, "22px sans-serif");
    const qPad = 12;
    const qBox = {
      x: Math.floor((WIDTH - qW - qPad * 2) / 2),
      y: audioBox.y + audioBox.h + 8,
      w: qW + qPad * 2,
      h: 40
    };
    ctx.fillStyle = UI_BG;
    roundRect(ctx, qBox.x, qBox.y, qBox.w, qBox.h, 8, true, false);
    ctx.fillStyle = TEXT_COLOR;
    ctx.fillText(qText, qBox.x + qBox.w / 2, qBox.y + 8);

    // Place instructions bottom-center with multi-line support
    const instructions = [
      "Controls: Arrow keys or WASD to fly. Space to pick up a package.",
      "You can also click or press 1/2/3 to pick the left/middle/right package.",
      `Goal: Collect ${GOAL_CORRECT} correct packages. Wrong picks allowed: ${MAX_WRONG}.`,
      "Press M to toggle audio. Press R to restart."
    ];
    ctx.font = "16px sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    const lineHeight = 20;
    const maxLineWidth = WIDTH - 40;
    // Compute width as max of lines
    let maxW = 0;
    const measuredLines = instructions.map((line) => {
      const w = Math.min(measureTextSize(line, "16px sans-serif"), maxLineWidth);
      if (w > maxW) maxW = w;
      return { line, w };
    });
    const instrW = maxW + 24;
    const instrH = instructions.length * lineHeight + 18;
    const instrX = Math.floor((WIDTH - instrW) / 2);
    const instrY = HEIGHT - instrH - 10;
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    roundRect(ctx, instrX, instrY, instrW, instrH, 10, true, false);
    ctx.fillStyle = TEXT_COLOR;
    instructions.forEach((line, idx) => {
      ctx.fillText(line, WIDTH / 2, instrY + 10 + idx * lineHeight);
    });
  }

  // ------------------------------
  // End Screens
  // ------------------------------
  function drawEndScreen() {
    ctx.save();
    // Dim background
    ctx.fillStyle = "rgba(8,12,20,0.48)";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Panel
    const panelW = 520;
    const panelH = 260;
    const panelX = (WIDTH - panelW) / 2;
    const panelY = (HEIGHT - panelH) / 2;
    ctx.fillStyle = "rgba(255,255,255,0.98)";
    roundRect(ctx, panelX, panelY, panelW, panelH, 12, true, false);

    // Title
    ctx.fillStyle = TEXT_COLOR;
    ctx.font = "28px sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";

    if (gameState === "victory") {
      ctx.fillText("ðŸŽ‰ Victory! ðŸŽ‰", panelX + panelW / 2, panelY + 18);
      ctx.font = "20px sans-serif";
      ctx.fillText(`You collected ${correctCount} correct packages!`, panelX + panelW / 2, panelY + 62);
    } else {
      ctx.fillText("Game Over", panelX + panelW / 2, panelY + 18);
      ctx.font = "20px sans-serif";
      ctx.fillText(`You made ${wrongCount} incorrect picks.`, panelX + panelW / 2, panelY + 62);
    }

    // Small friendly message
    ctx.font = "16px sans-serif";
    ctx.fillText("Great flying! Try again to beat your best.", panelX + panelW / 2, panelY + 110);

    // Restart button
    const btnW = 180;
    const btnH = 46;
    const btnX = panelX + panelW / 2 - btnW / 2;
    const btnY = panelY + panelH - btnH - 28;
    restartButtonRect = { x: btnX, y: btnY, w: btnW, h: btnH };

    ctx.fillStyle = "#6C6CE5";
    roundRect(ctx, btnX, btnY, btnW, btnH, 8, true, false);
    ctx.fillStyle = "#FFFFFF";
    ctx.font = "18px sans-serif";
    ctx.fillText("Restart (R)", btnX + btnW / 2, btnY + 12);

    // Extra small instruction below button
    ctx.font = "14px sans-serif";
    ctx.fillStyle = "#333";
    ctx.fillText("Or press R key", panelX + panelW / 2, btnY + btnH + 6);

    ctx.restore();
  }

  // ------------------------------
  // Game Loop
  // ------------------------------
  function update(delta) {
    if (gameState !== "playing") return;

    // Drone movement
    const moveX = (keys["arrowleft"] || keys["a"]) ? -1 : (keys["arrowright"] || keys["d"]) ? 1 : 0;
    const moveY = (keys["arrowup"] || keys["w"]) ? -1 : (keys["arrowdown"] || keys["s"]) ? 1 : 0;
    drone.vx = moveX * drone.speed;
    drone.vy = moveY * drone.speed;

    drone.x += drone.vx * delta;
    drone.y += drone.vy * delta;
    drone.x = clamp(drone.x, drone.radius + 6, WIDTH - drone.radius - 6);
    drone.y = clamp(drone.y, drone.radius + 20, HEIGHT - drone.radius - 100);

    // Spawn packages occasionally if less than 3 alive
    spawnTimer += delta;
    const aliveCount = packages.filter((p) => p.alive).length;
    if (spawnTimer > PACKAGE_SPAWN_INTERVAL && aliveCount < 3) {
      spawnTimer = 0;
      // Spawn a new package with wrong or correct occasionally
      const p = {
        id: Math.random().toString(36).slice(2, 9),
        x: 40 + Math.random() * (WIDTH - 80),
        y: -30,
        w: 82,
        h: 54,
        vx: (Math.random() - 0.5) * 0.4,
        vy: PACKAGE_SPEED_MIN + Math.random() * (PACKAGE_SPEED_MAX - PACKAGE_SPEED_MIN),
        value: Math.random() < 0.4 ? currentQuestion.answer : Math.max(0, currentQuestion.answer + (Math.floor(Math.random() * 7) - 3)),
        color: PACKAGE_COLORS[Math.floor(Math.random() * PACKAGE_COLORS.length)],
        alive: true
      };
      packages.push(p);
    }

    // Check automatic collision pickup (if drone touches package, automatically pick in case player wants)
    packages.forEach((p) => {
      if (p.alive && circleRectCollision(drone.x, drone.y, drone.radius, p)) {
        // gentle auto pickup to avoid requiring precise Space presses
        pickPackage(p);
      }
    });
  }

  function render(now) {
    const dt = now - lastTime;
    const delta = dt / 16.6667; // approx frames
    lastTime = now;

    // Draw scene
    drawBackground(delta);
    drawPackages(delta);
    drawDrone();
    drawUI();

    // Draw helpful targeting indicator near drone
    ctx.save();
    ctx.strokeStyle = "rgba(18,52,86,0.12)";
    ctx.beginPath();
    ctx.arc(drone.x, drone.y, drone.radius + 8, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();

    // If end screen
    if (gameState === "victory" || gameState === "gameover") {
      drawEndScreen();
    }

    // Update
    update(delta);

    requestAnimationFrame(render);
  }

  // ------------------------------
  // Start the Game
  // ------------------------------
  try {
    newQuestion();
    announce("Welcome! Solve the math questions by picking the correct packages. Use arrow keys or WASD to fly. Press R to restart anytime.");
    lastTime = performance.now();
    requestAnimationFrame(render);
  } catch (e) {
    console.error("Error starting the game:", e);
    ctx.fillStyle = "#000";
    ctx.font = "18px sans-serif";
    ctx.fillText("An error occurred starting the game. Please reload.", 20, 40);
    announce("An error occurred starting the game. Please reload the page.");
  }
})();
---

